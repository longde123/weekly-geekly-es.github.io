<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèª üíÇ üë®üèº‚Äçüé§ Deja de usar Ngrx / efectos para esto üë∫ üéë üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A veces, la implementaci√≥n m√°s simple de la funcionalidad en √∫ltima instancia crea m√°s problemas que buenos, solo que aumenta la complejidad en otros ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deja de usar Ngrx / efectos para esto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448858/"><img src="https://habrastorage.org/webt/73/82/fl/7382flctc9zmk_xd-mox_6ahrru.jpeg" alt="busto con efectos"><br><br>  A veces, la implementaci√≥n m√°s simple de la funcionalidad en √∫ltima instancia crea m√°s problemas que buenos, solo que aumenta la complejidad en otros lugares.  El resultado final es una arquitectura zagged que nadie quiere tocar. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Notas del traductor</b> <div class="spoiler_text"><p>  El art√≠culo fue escrito en 2017, pero es relevante para este d√≠a.  Est√° dirigido a personas con experiencia en RxJS y Ngrx, o que quieran probar Redux en Angular. </p><br>  Los fragmentos de c√≥digo se actualizaron seg√∫n la sintaxis actual de RxJS y se modificaron ligeramente para mejorar la legibilidad y la facilidad de comprensi√≥n. <br></div></div><br><p> Ngrx / store es una biblioteca angular que ayuda a contener la complejidad de las funciones individuales.  Una raz√≥n es que ngrx / store abarca la programaci√≥n funcional, que limita lo que se puede hacer dentro de una funci√≥n para lograr m√°s razonabilidad fuera de ella.  En ngrx / store, cosas como los reductores (en adelante denominados reductores), los selectores (en adelante denominados selectores) y los operadores RxJS son funciones puras. </p><br><p>  Las funciones puras son m√°s f√°ciles de probar, depurar, analizar, paralelizar y combinar.  Una funci√≥n est√° limpia si: </p><br><ul><li>  con la misma entrada, siempre devuelve la misma salida; </li><li>  sin efectos secundarios </li></ul><br><p>  Los efectos secundarios no se pueden evitar, pero est√°n aislados en ngrx / store, por lo que el resto de la aplicaci√≥n puede consistir en funciones puras. </p><br><h3>  Efectos secundarios </h3><br><p>  Cuando el usuario env√≠a el formulario, debemos realizar cambios en el servidor.  Cambiar el servidor y responder al cliente es un efecto secundario.  Esto se puede manejar en el componente: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data) <span class="hljs-comment"><span class="hljs-comment">// POST    .pipe(map(res =&gt; this.store.dispatch({ type: 'DATA_SAVED' }))) .subscribe();</span></span></code> </pre> <br><p>  Ser√≠a bueno si pudi√©ramos enviar la acci√≥n (en adelante, la acci√≥n) dentro del componente cuando el usuario env√≠a el formulario y maneja el efecto secundario en otro lugar. </p><br><p>  Ngrx / effects es middleware para manejar efectos secundarios en ngrx / store.  Escucha las acciones enviadas en el hilo observable, realiza efectos secundarios y devuelve nuevas acciones de forma inmediata o asincr√≥nica.  Las acciones devueltas se pasan al reductor. </p><br><p>  La capacidad de manejar los efectos secundarios de la manera RxJS hace que el c√≥digo sea m√°s limpio.  Despu√©s de enviar la acci√≥n inicial <code>SAVE_DATA</code> desde el componente, crea una clase de efecto para manejar el resto: </p><br><pre> <code class="javascript hljs">@Effect() saveData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>), pluck(<span class="hljs-string"><span class="hljs-string">'payload'</span></span>), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DATA_SAVED'</span></span> })), );</code> </pre><br><p>  Esto simplifica la operaci√≥n del componente solo antes de enviar acciones y suscribirse a observables. </p><br><h2>  F√°cil de abusar de Ngrx / efectos </h2><br><p>  Ngrx / effects es una soluci√≥n muy poderosa, por lo que es f√°cil de abusar.  Aqu√≠ hay algunos antipatrones comunes de ngrx / store que Ngrx / effects simplifica: </p><br><h3>  1. Estado duplicado </h3><br><p>  Supongamos que est√° trabajando en alg√∫n tipo de aplicaci√≥n multimedia y tiene las siguientes propiedades en el √°rbol de estado: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">mediaPlaying</span></span>: boolean; audioPlaying: boolean; videoPlaying: boolean; }</code> </pre><br><p>  Como el audio es un tipo de medio, siempre que <code>audioPlaying</code> sea ‚Äã‚Äãverdadero, <code>mediaPlaying</code> tambi√©n deber√≠a ser cierto.  As√≠ que aqu√≠ est√° la pregunta: "¬øC√≥mo me aseguro de que mediaPlaying se actualice cuando se actualice audioPlaying?" </p><br><p>  <b>Respuesta no</b> v√°lida: ¬°usa Ngrx / effects! </p><br><pre> <code class="javascript hljs">@Effect() playMediaWithAudio$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'PLAY_AUDIO'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'PLAY_MEDIA'</span></span> })), );</code> </pre><br><p>  <b>La respuesta correcta es</b> : si el estado de <code>mediaPlaying</code> completamente predicho por otra parte del √°rbol de estado, entonces este no es un estado verdadero.  Este es un estado derivado.  Pertenece al selector, no a la tienda. </p><br><pre> <code class="javascript hljs">audioPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'audioPlaying'</span></span>); videoPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'videoPlaying'</span></span>); mediaPlaying$ = combineLatest(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioPlaying$, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.videoPlaying$).pipe( map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[audioPlaying, videoPlaying]</span></span></span><span class="hljs-function">) =&gt;</span></span> audioPlaying || videoPlaying), );</code> </pre><br><p>  Ahora nuestra condici√≥n puede permanecer limpia y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">normalizada</a> , y no usamos Ngrx / effects para algo que no sea un efecto secundario. </p><br><h3>  2. Encadenamiento de acciones con reductor </h3><br><p>  Imagine que tiene estas propiedades en su √°rbol de estado: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">items</span></span>: { [index: number]: Item }; favoriteItems: number[]; }</code> </pre><br><p>  Luego, el usuario elimina el elemento.  Cuando se devuelve la solicitud de eliminaci√≥n, se <code>DELETE_ITEM_SUCCESS</code> acci√≥n <code>DELETE_ITEM_SUCCESS</code> para actualizar el estado de nuestra aplicaci√≥n.  En el reductor de <code>items</code> , se elimina un <code>Item</code> individual del objeto de <code>items</code> .  Pero si este identificador de elemento estaba en la matriz <code>favoriteItems</code> , el elemento al que hace referencia estar√° ausente.  Entonces, la pregunta es, ¬øc√≥mo puedo asegurarme de que el identificador se elimine de <code>favoriteItems</code> al enviar la acci√≥n <code>DELETE_ITEM_SUCCESS</code> ? </p><br><p>  <b>Respuesta no</b> v√°lida: ¬°usa Ngrx / effects! </p><br><pre> <code class="javascript hljs">@Effect() removeFavoriteItemId$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM_ID'</span></span> })), );</code> </pre><br><p>  Entonces, ahora tendremos dos acciones enviadas una tras otra, y dos reductores que devuelven nuevos estados uno tras otro. </p><br><p>  <b>Respuesta correcta</b> : <code>DELETE_ITEM_SUCCESS</code> puede ser procesado tanto por el reductor de <code>items</code> como por el reductor de <code>items</code> <code>favoriteItems</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">favoriteItemsReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action: Action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemId = action.payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> id !== itemId); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre><br><p>  El objetivo de la acci√≥n es separar lo que sucedi√≥ de c√≥mo deber√≠a cambiar el estado.  Lo que sucedi√≥ fue <code>DELETE_ITEM_SUCCESS</code> .  La tarea de los reductores es provocar un cambio de estado correspondiente. </p><br><p>  Eliminar un identificador de <code>favoriteItems</code> no <code>favoriteItems</code> un efecto secundario de eliminar un <code>Item</code> .  Todo el proceso est√° totalmente sincronizado y puede ser procesado por reductores.  Ngrx / efectos no es necesario. </p><br><h3>  3. Solicitar datos para el componente </h3><br><p>  Su componente necesita datos de la tienda, pero primero debe obtenerlos del servidor.  La pregunta es, ¬øc√≥mo podemos poner los datos en la tienda para que el componente pueda recibirlos? </p><br><p>  <b>Manera dolorosa</b> : ¬°usa Ngrx / efectos! </p><br><p>  En el componente, iniciamos la solicitud enviando una acci√≥n: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> }); }</code> </pre><br><p>  En la clase de efectos, escuchamos <code>GET_USERS</code> : </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), );</code> </pre><br><p>  Ahora suponga que el usuario decide que una ruta determinada tarda demasiado en cargarse, por lo que cambiar√° de una a otra.  Para ser eficiente y no cargar datos innecesarios, queremos cancelar esta solicitud.  Cuando se destruye el componente, cancelaremos la suscripci√≥n de la solicitud enviando la acci√≥n: </p><br><pre> <code class="javascript hljs">ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> }); }</code> </pre><br><p>  Ahora en la clase de efectos escuchamos ambas acciones: </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>, <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> action), switchMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> action.type === <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().pipe(map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users }))), ), );</code> </pre><br><p>  Bueno  Ahora, otro desarrollador agrega un componente que requiere la misma solicitud HTTP (no haremos ninguna suposici√≥n sobre otros componentes).  El componente env√≠a las mismas acciones en los mismos lugares.  Si ambos componentes est√°n activos al mismo tiempo, el primer componente inicia una solicitud HTTP para inicializarlo.  Cuando se inicializa el segundo componente, no suceder√° nada adicional, porque <code>needUsers</code> ser√° <code>false</code> .  Genial </p><br><p>  Luego, cuando se destruye el primer componente, enviar√° <code>CANCEL_GET_USERS</code> .  Pero el segundo componente todav√≠a necesita estos datos.  ¬øC√≥mo podemos evitar que se cancele una solicitud?  ¬øQuiz√°s comencemos el contador de todos los suscriptores?  No voy a implementar esto, pero supongo que entendiste el punto.  Estamos comenzando a sospechar que hay una mejor manera de administrar estas dependencias de datos. </p><br><p>  Ahora suponga que aparece otro componente y depende de los datos que no se pueden recuperar hasta que <code>users</code> datos de los <code>users</code> aparezcan en la tienda.  Esto puede ser una conexi√≥n a un socket web para chat, informaci√≥n adicional sobre algunos usuarios u otra cosa.  No sabemos si este componente se inicializar√° antes o despu√©s de suscribir otros dos componentes a los <code>users</code> . </p><br><p>  La mejor ayuda que he encontrado para este escenario en particular es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta gran publicaci√≥n</a> .  En su ejemplo, <code>callApiY</code> requiere que <code>callApiX</code> ya <code>callApiX</code> haya completado.  Elimin√© los comentarios para que parezca menos intimidante, pero no dude en leer la publicaci√≥n original para obtener m√°s informaci√≥n: </p><br><pre> <code class="javascript hljs">@Effect() actionX$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>), map(toPayload), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiX(payload).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err })), ), ), ); @Effect() actionY$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_Y'</span></span>), map(toPayload), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> state.someBoolean)), switchMap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[payload, someBoolean]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callHttpY = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiY(v).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err, }), ), ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someBoolean) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>, payload }).merge( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>), first(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'Because ACTION_X failed.'</span></span>, }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); }), ), ); }), );</code> </pre><br><p>  Ahora agregue el requisito de que las solicitudes HTTP deben cancelarse cuando los componentes ya no las necesiten, y esto se volver√° a√∫n m√°s complejo. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  Entonces, ¬øpor qu√© hay tantos problemas con la gesti√≥n de dependencia de datos cuando RxJS deber√≠a hacerlo realmente f√°cil? </p><br><p>  Aunque los datos que provienen del servidor son t√©cnicamente un efecto secundario, no me parece que Ngrx / effects sea la mejor manera de manejar esto. </p><br><p>  Los componentes son interfaces de entrada / salida de usuario.  Muestran datos y env√≠an acciones realizadas por √©l.  Cuando se carga un componente, no env√≠a ninguna acci√≥n realizada por este usuario.  Quiere mostrar los datos.  Esto se parece m√°s a una suscripci√≥n que a un efecto secundario. </p><br><p>  Muy a menudo puede ver aplicaciones que usan acciones para iniciar una solicitud de datos.  Estas aplicaciones implementan una interfaz especial para efectos secundarios observables.  Y, como vimos, esta interfaz puede volverse muy inc√≥moda y engorrosa.  Suscribirse, darse de baja y conectarse a observables es mucho m√°s f√°cil. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  <b>De manera menos dolorosa</b> : el componente registrar√° su inter√©s en los datos suscribi√©ndose a ellos a trav√©s de observables. </p><br><p>  Crearemos observables que contengan las solicitudes HTTP necesarias.  Veremos qu√© tan f√°cil es administrar m√∫ltiples suscripciones y cadenas de consulta que dependen unas de otras usando RxJS puro, en lugar de hacerlo a trav√©s de efectos. </p><br><p>  Cree estos observables en el servicio: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), finalize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), );</code> </pre><br><p>  La suscripci√≥n a los <code>users$</code> se transmitir√° tanto a <code>requireUsers$</code> como a <code>this.store.pipe(select(selectUsers))</code> , pero los datos se recibir√°n solo de <code>this.store.pipe(select(selectUsers))</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>muteFirst</code></a> implementaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>muteFirst</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>muteFirst</code></a> fijo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su prueba</a> ) </p><br><p>  En componente: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.users$; }</code> </pre><br><p>  Dado que esta dependencia de datos es ahora un simple observable, podemos suscribirnos y cancelar la suscripci√≥n en la plantilla usando una tuber√≠a <code>async</code> , y ya no necesitamos enviar acciones.  Si la aplicaci√≥n deja la ruta del √∫ltimo componente firmado para datos, la solicitud HTTP se cancela o se cierra el socket web. </p><br><p>  La cadena de dependencia de datos puede procesarse as√≠: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), ); requireUsersExtraData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$.pipe( withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectNeedUsersExtraData))), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[users, needData]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(users.length) &amp;&amp; needData), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS_EXTRA_DATA'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS_EXTRA_DATA'</span></span>, users, }), ), share(), ); public usersExtraData$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsersExtraData$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsersExtraData)), );</code> </pre><br><p>  Aqu√≠ hay una comparaci√≥n paralela del m√©todo anterior con este m√©todo: </p><br><img src="https://habrastorage.org/webt/xd/cb/ho/xdcbhozsjus5vu64eqp9x8nsnuy.png" alt="comparaci√≥n paralela"><br><br><p>  El uso de puro observable requiere menos l√≠neas de c√≥digo y se cancela autom√°ticamente de las dependencias de datos en toda la cadena.  (Me salte√© las declaraciones de <code>finalize</code> que se incluyeron originalmente para hacer que la comparaci√≥n sea m√°s comprensible, pero incluso sin ellas, las consultas se cancelar√°n en consecuencia). </p><br><img src="https://habrastorage.org/webt/mj/2m/pc/mj2mpclzeric84dwrap4c5fpkqm.jpeg" alt="efectos como la cereza en un c√≥ctel"><br><br><h2>  Conclusi√≥n </h2><br><p>  ¬°Ngrx / effects es una gran herramienta!  Pero considere estas preguntas antes de usarlo: </p><br><ul><li>  ¬øEs esto realmente un efecto secundario? </li><li>  ¬øEs Ngrx / effects la mejor manera de hacer esto? </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448858/">https://habr.com/ru/post/448858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448842/index.html">Monitor de calidad del aire Honeywell HAQ</a></li>
<li><a href="../448846/index.html">Lo que es importante no olvidar al implementar Agile en una gran empresa</a></li>
<li><a href="../448848/index.html">Acerca de eliminar una tendencia de datos experimentales</a></li>
<li><a href="../448854/index.html">La tripulaci√≥n del drag√≥n explot√≥</a></li>
<li><a href="../448856/index.html">Torfon: una aplicaci√≥n m√≥vil para telefon√≠a an√≥nima</a></li>
<li><a href="../448860/index.html">Notas de la versi√≥n de Android Studio 3.4 (abril de 2019)</a></li>
<li><a href="../448866/index.html">Detalles de la transici√≥n de tasas de cambio pareadas (relativas) a absolutas. Manejo de errores</a></li>
<li><a href="../448868/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 295 (del 15 al 21 de abril)</a></li>
<li><a href="../448870/index.html">Optlib Implementaci√≥n de un algoritmo de optimizaci√≥n gen√©tica en Rust</a></li>
<li><a href="../448872/index.html">Traducci√≥n de libros de intercomunicaci√≥n sobre gesti√≥n de productos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>