<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍭 🗜️ 🚣🏼 WebSockets dans Angular: créez un service angulaire pour travailler avec des sockets Web 👲🏿 🤛🏿 😷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais essayer de couvrir en détail l'étendue étroite de la technologie dans le cadre du cadre angulaire et de son assistant déjà i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets dans Angular: créez un service angulaire pour travailler avec des sockets Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416155/"><img src="https://habrastorage.org/webt/dz/-h/c_/dz-hc_la-a4emvhkqbd4ihr5zfe.jpeg" alt="image"><br>  Dans cet article, je vais essayer de couvrir en détail l'étendue étroite de la technologie dans le cadre du cadre angulaire et de son assistant déjà intégré - RxJs, alors que nous n'aborderons pas délibérément les implémentations de serveur, comme  Il s'agit d'un sujet à part entière pour un article séparé. <br><br>  Ce texte sera utile à ceux qui connaissent déjà Angular, mais qui souhaitent approfondir leurs connaissances directement sur le sujet. <br><a name="habracut"></a><br>  Tout d'abord, quelques informations de base. <br><br><h2>  Qu'est-ce que WebSocket et pourquoi en avez-vous besoin </h2><br><blockquote>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> , WebSocket est un «protocole de communication duplex (il peut transmettre et recevoir en même temps) sur une connexion TCP, conçu pour la messagerie en temps réel entre un navigateur et un serveur Web. <br>  WebSocket est conçu pour être implémenté dans les navigateurs Web et les serveurs Web, mais il peut être utilisé pour n'importe quelle application client ou serveur.  Le protocole WebSocket est un protocole indépendant basé sur le protocole TCP.  Il permet une interaction plus étroite entre le navigateur et le site Web, facilitant la distribution de contenu interactif et la création d'applications en temps réel. » <br></blockquote><br>  En d'autres termes, WebSocket permet au serveur de recevoir des demandes du client et d'envoyer des demandes au client à tout moment souhaité, ainsi, le navigateur (client) et le serveur reçoivent des droits égaux et la possibilité d'échanger des messages lors de la connexion.  Une demande AJAX régulière nécessite la transmission d'en-têtes HTTP complets, ce qui signifie un trafic accru dans les deux sens, tandis que la surcharge des sockets Web après l'établissement d'une connexion n'est que de deux octets.  La socket Web réduit la quantité d'informations transmises dans les en-têtes HTTP par des centaines et des milliers de fois et réduit considérablement le temps d'attente.  Les connexions de socket Web prennent en charge plusieurs domaines comme CORS. <br><br>  Côté serveur, il existe des packages pour la prise en charge du socket web, sur le client c'est l'API HTML5 WebSocket, qui a une interface de trois méthodes: <br><br>  <b><i>WebSocket</i></b> - l'interface principale pour se connecter à un serveur WebSocket, puis envoyer et recevoir des données via la connexion; <br>  <b><i>CloseEvent</i></b> - un événement distribué par l'objet WebSocket lorsque la connexion a été fermée; <br>  <b><i>MessageEvent</i></b> - Un événement distribué par un WebSocket lorsqu'un message est reçu du serveur. <br><br>  Voici à quoi cela ressemble au niveau d'implémentation JavaSript: <br><br><pre><code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com/socketserver", "protocolOne"); ws.onopen = () =&gt; { ws.onmessage = (event) =&gt; { console.log(event); } ws.send("Here's some text that the server is urgently awaiting!"); };</code> </pre> <br>  <b><i>onmessage</i></b> - écoute les messages du serveur <br>  <b><i>envoyer</i></b> - envoyez vos messages au serveur <br><br>  Autrement dit, dans sa forme de base, tout est extrêmement simple, mais si vous souhaitez vous plonger dans le sujet, vous pouvez vous tourner vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDN Web Docs</a> et en même temps étudier des bibliothèques qui implémentent leurs propres couches au-dessus de cette API. <br><br><h2>  Pourquoi ne pas avoir peur d'utiliser WebSocket </h2><br>  Le premier point qui peut effrayer est la <b>prise en charge du navigateur</b> .  Aujourd'hui, il n'y a pas un tel problème - WebSocket est pris en charge presque complètement à la fois sur le Web et dans le segment mobile. <br><br><img src="https://habrastorage.org/webt/6q/kt/br/6qktbrrlnloyi0ec862v8qzclts.png" alt="image"><br><br><img src="https://habrastorage.org/webt/bn/pk/k5/bnpkk58xzozo2c9plnkgszfjnk4.png" alt="image"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://caniuse.com/#feat=websockets</a> <br><br>  Le deuxième point est la <b>facilité de mise en œuvre</b> .  Oui, au début, c'est décourageant. <br><br>  L'API est si simple qu'à première vue, il peut être difficile de comprendre comment travailler avec un nombre aussi modeste de méthodes, car toutes, sauf une, signalent des erreurs ou des connexions, et une seule d'entre elles - <b><i>onmessage</i></b> - contient pour quelles prises Web sont utilisées, c.-à-d.  pour recevoir des données du serveur. <br><br>  Dans le même temps, le problème est que le serveur envoie généralement des données différentes, par conséquent, nous avons besoin de plusieurs messages différents?  Ou avez-vous besoin de créer votre propre connexion pour chaque modèle de données? <br><br>  Donc, la tâche: vous devez accepter le modèle utilisateur et le dernier modèle d'actualités du serveur, et peut-être même autre chose. <br><br>  J'ai rencontré une telle implémentation "élégante": <br><br><pre> <code class="plaintext hljs">const wsUser = new WebSocket("ws://www.example.com/user"); wsUser.onmessage = (event) =&gt; { // ... }; const wsNews = new WebSocket("ws://www.example.com/news"); wsNews.onmessage = (event) =&gt; { // ... }; const wsTime = new WebSocket("ws://www.example.com/time"); wsTime.onmessage = (event) =&gt; { // ... }; const wsDinner = new WebSocket("ws://www.example.com/dinner"); wsDinner.onmessage = (event) =&gt; { // ... }; const wsCurrency = new WebSocket("ws://www.example.com/currency"); wsCurrency.onmessage = (event) =&gt; { // ... }; const wsOnline = new WebSocket("ws://www.example.com/online"); wsOnline.onmessage = (event) =&gt; { // ... }; const wsLogin = new WebSocket("ws://www.example.com/login"); wsLogin.onmessage = (event) =&gt; { // ... }; const wsLogout = new WebSocket("ws://www.example.com/logout"); wsLogout.onmessage = (event) =&gt; { // ... };</code> </pre> <br>  À première vue, tout est logique.  Mais imaginez maintenant à quoi cela ressemblera s'il y en a des dizaines ou des centaines.  Dans l'un des projets sur lesquels j'ai travaillé, il y a eu environ trois cents événements. <br><br><img src="https://habrastorage.org/webt/d3/rg/dl/d3rgdlp8eggnms2ot2ely5zktz8.jpeg" alt="image"><br><br>  Nous résolvons le problème. <br><br>  Toutes les bibliothèques tierces pour travailler avec des sockets Web vous permettent de vous abonner aux messages du type addEventListener.  Cela ressemble à ceci: <br><br><pre> <code class="plaintext hljs">ws.on("user", (userData) =&gt; { / .. })</code> </pre> <br>  Comme nous le savons, nous pouvons fonctionner avec une seule méthode - <b><i>onmessage</i></b> , qui reçoit toutes les données dans le cadre de sa connexion, donc ce code semble quelque peu inhabituel.  Ceci est implémenté comme suit: <b><i>onmessage</i></b> renvoie un <b><i>MessageEvent</i></b> qui contient le champ de <b><i>données</i></b> .  Ce sont des <b><i>données qui</i></b> contiennent les informations que le serveur nous envoie.  Cet objet ressemble à ceci: <br><br><pre> <code class="plaintext hljs">{ "event": "user", "data": { "name": "John Doe", ... } }</code> </pre> <br>  où <b><i>événement</i></b> est la clé permettant de déterminer les informations envoyées par le serveur.  Ensuite, du côté frontal, un bus est créé qui filtre les informations par événement et les envoie à l'adresse souhaitée: <br><br><pre> <code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com"); ws.onmessage = (event) =&gt; { const data = JSON.parse(event.data); if (data.event === 'user') { // ... } if (data.event === 'news') { // ... } };</code> </pre> <br><br>  Cela permet de recevoir différentes données au sein d'une même connexion et de s'y abonner via une syntaxe similaire à celle habituelle pour les événements JS. <br><br><h2>  WebSockets en angulaire </h2><br>  Enfin, nous sommes arrivés à la chose la plus importante: utiliser WebSockets directement dans Angular. <br><br>  Malgré la simplicité de travailler avec l'API WebSocket native, dans cet article, nous utiliserons RxJs, ce qui bien sûr, car nous parlons d'Angular. <br><br>  L'API WebSocket native peut être utilisée dans des applications angulaires, créer une interface facile à utiliser, RxJs Observable, s'abonner aux messages nécessaires, etc., mais RxJs a déjà fait le travail principal pour vous: WebSocketSubject est un wrapper réactif sur le WebSocket standard API  Il ne crée pas de bus d'événements ni ne reconnecte le traitement.  Il s'agit d'un sujet standard, avec lequel vous pouvez travailler avec des sockets Web de style réactif. <br><br><h2>  RxJs WebSocketSubject </h2><br>  Ainsi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSocketSubject</a> attend <a href="">WebSocketSubjectConfig</a> et une destination facultative, dans laquelle vous pouvez passer un lien vers votre sujet observé, crée un observable à travers lequel vous pouvez écouter et envoyer des messages pour les sockets Web. <br><br>  Autrement dit, vous passez l'URL de connexion en tant qu'argument WebSocketSubject et vous abonnez à toute l'activité du socket Web de la manière habituelle pour les RxJ.  Et si vous devez envoyer un message au serveur, utilisez la même méthode habituelle webSocketSubject.next (data). <br><br><h2>  Nous faisons un service pour travailler avec WebSocket Angular </h2><br>  Décrivez brièvement ce que nous attendons du service: <br><br><ul><li>  Interface unifiée et concise; </li><li>  Possibilité de configuration au niveau de la connexion des dépendances <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DI</a> ; </li><li>  La possibilité de réutilisation; </li><li>  Dactylographie; </li><li>  La possibilité de s'abonner pour recevoir des informations par clé; </li><li>  Possibilité de résilier un abonnement; </li><li>  Envoi de messages au serveur; </li><li>  Reconnectez-vous. </li></ul><br>  Le dernier point mérite une attention particulière.  La reconnexion, ou l'organisation de la reconnexion au serveur, est un facteur primordial lorsque vous travaillez avec des sockets Web, comme  les ruptures de réseau, les pannes de serveur ou d'autres erreurs qui provoquent une rupture de connexion peuvent entraîner le blocage de l'application. <br><br>  Il est important de noter que les tentatives de reconnexion <b>ne devraient pas être trop fréquentes</b> et ne devraient pas se poursuivre indéfiniment, car  ce comportement peut suspendre le client. <br><br>  Commençons. <br><br>  Tout d'abord, nous allons créer une interface de configuration de service et un module qui offrira la possibilité de configurer une fois connecté. <br><br>  Si possible, je raccourcirai le code, la version complète que vous pouvez voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la communauté angulaire russophone sur GitHub</a> . <br><br><pre> <code class="plaintext hljs">export interface WebSocketConfig { url: string; reconnectInterval?: number; reconnectAttempts?: number; } export class WebsocketModule { public static config(wsConfig: WebSocketConfig): ModuleWithProviders { return { ngModule: WebsocketModule, providers: [{ provide: config, useValue: wsConfig }] }; } }</code> </pre> <br>  Ensuite, nous devons décrire l'interface du message de socket Web: <br><br><pre> <code class="plaintext hljs">export interface IWsMessage&lt;T&gt; { event: string; data: T; }</code> </pre> <br>  où <b><i>événement</i></b> est la clé et les <b><i>données</i></b> obtenues par la clé sont un modèle typé. <br><br>  L'interface publique du service ressemble à ceci: <br><br><pre> <code class="plaintext hljs">export interface IWebsocketService { on&lt;T&gt;(event: string): Observable&lt;T&gt;; send(event: string, data: any): void; status: Observable&lt;boolean&gt;; }</code> </pre> <br>  Le service a des champs: <br><br><pre> <code class="plaintext hljs">//   WebSocketSubject private config: WebSocketSubjectConfig&lt;IWsMessage&lt;any&gt;&gt;; private websocketSub: SubscriptionLike; private statusSub: SubscriptionLike; // Observable    interval private reconnection$: Observable&lt;number&gt;; private websocket$: WebSocketSubject&lt;IWsMessage&lt;any&gt;&gt;; // ,      private connection$: Observer&lt;boolean&gt;; //  Observable       private wsMessages$: Subject&lt;IWsMessage&lt;any&gt;&gt;; //       private reconnectInterval: number; //    private reconnectAttempts: number; //      private isConnected: boolean; //   public status: Observable&lt;boolean&gt;;</code> </pre> <br>  Dans le constructeur de la classe de service, nous obtenons l'objet WebSocketConfig spécifié lorsque le module était connecté: <br><br><pre> <code class="plaintext hljs">constructor(@Inject(config) private wsConfig: WebSocketConfig) { this.wsMessages$ = new Subject&lt;IWsMessage&lt;any&gt;&gt;(); //  ,  ,     this.reconnectInterval = wsConfig.reconnectInterval || 5000; this.reconnectAttempts = wsConfig.reconnectAttempts || 10; //      connection$   websocket$ this.config = { url: wsConfig.url, closeObserver: { next: (event: CloseEvent) =&gt; { this.websocket$ = null; this.connection$.next(false); } }, //     connection$ openObserver: { next: (event: Event) =&gt; { console.log('WebSocket connected!'); this.connection$.next(true); } } }; // connection status this.status = new Observable&lt;boolean&gt;((observer) =&gt; { this.connection$ = observer; }).pipe(share(), distinctUntilChanged()); //      this.statusSub = this.status .subscribe((isConnected) =&gt; { this.isConnected = isConnected; if (!this.reconnection$ &amp;&amp; typeof(isConnected) === 'boolean' &amp;&amp; !isConnected) { this.reconnect(); } }); // ,  -    this.websocketSub = this.wsMessages$.subscribe( null, (error: ErrorEvent) =&gt; console.error('WebSocket error!', error) ); //  this.connect(); }</code> </pre> <br>  La méthode de connexion elle-même est simple: <br><br><pre> <code class="plaintext hljs">private connect(): void { this.websocket$ = new WebSocketSubject(this.config); //  //   ,    , //  ,  // ,    this.websocket$.subscribe( (message) =&gt; this.wsMessages$.next(message), (error: Event) =&gt; { if (!this.websocket$) { // run reconnect if errors this.reconnect(); } }); }</code> </pre> <br>  La reconnexion est un peu plus compliquée: <br><br><pre> <code class="plaintext hljs">private reconnect(): void { //  interval    reconnectInterval this.reconnection$ = interval(this.reconnectInterval) .pipe(takeWhile((v, index) =&gt; index &lt; this.reconnectAttempts &amp;&amp; !this.websocket$)); //     ,        this.reconnection$.subscribe( () =&gt; this.connect(), null, () =&gt; { // Subject complete if reconnect attemts ending this.reconnection$ = null; if (!this.websocket$) { this.wsMessages$.complete(); this.connection$.complete(); } }); }</code> </pre> <br>  La méthode on, c'est aussi extrêmement simple, il n'y a même rien à commenter. <br><br><pre> <code class="plaintext hljs">public on&lt;T&gt;(event: string): Observable&lt;T&gt; { if (event) { return this.wsMessages$.pipe( filter((message: IWsMessage&lt;T&gt;) =&gt; message.event === event), map((message: IWsMessage&lt;T&gt;) =&gt; message.data) ); } }</code> </pre> <br>  La méthode d' <b><i>envoi</i></b> est encore plus simple: <br><br><pre> <code class="plaintext hljs">public send(event: string, data: any = {}): void { if (event &amp;&amp; this.isConnected) { //   any ,   ""   string //      :) this.websocket$.next(&lt;any&gt;JSON.stringify({ event, data })); } else { console.error('Send error!'); } }</code> </pre> <br>  C'est tout le service.  Comme vous pouvez le voir, l'essentiel du code est tombé sur l'organisation de la reconnexion. <br><br>  Voyons maintenant comment l'utiliser.  Connectez le module WebsocketModule: <br><br><pre> <code class="plaintext hljs">imports: [ WebsocketModule.config({ url: environment.ws //      'ws://www.example.com' }) ]</code> </pre> <br>  Dans le constructeur du composant, nous injectons le service et souscrivons aux messages de ' <b><i>messages</i></b> ', renvoyons le texte au serveur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private wsService: WebsocketService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.on&lt;IMessage[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'messages'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages: IMessage[]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.send(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Text!'</span></span>); }); }</code> </pre> <br>  Le nom des événements est plus pratique pour mettre des constantes ou une énumération.  Nous créons quelque part le fichier websocket.events.ts et l'écrivons dedans: <br><br><pre> <code class="plaintext hljs">export const WS = { ON: { MESSAGES: 'messages' }, SEND: { TEXT: 'text' } };</code> </pre> <br>  Réécrivez les abonnements à l'aide de l'objet WS créé: <br><br><pre> <code class="plaintext hljs">this.wsService.on&lt;IMessage[]&gt;(WS.ON.MESSAGES) .subscribe((messages: IMessage[]) =&gt; { console.log(messages); this.wsService.send(WS.SEND.TEXT, 'Test Text!'); });</code> </pre> <br><img src="https://habrastorage.org/webt/zn/jz/k7/znjzk75iy2uudtgep2wr4u8djmk.jpeg" alt="image"><br><br><h2>  En conclusion </h2><br>  En fait, c'est tout.  C'est un minimum nécessaire qu'un développeur Angular doit connaître sur WebSockets.  J'espère avoir couvert ce sujet assez clairement.  La version complète du service est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Pour toutes questions que vous pouvez contacter dans les commentaires, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à moi</a> sur Telegram ou sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le canal angulaire</a> au même endroit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416155/">https://habr.com/ru/post/fr416155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416143/index.html">Le livre "Une autopsie va montrer!" Analyse pratique des malwares »</a></li>
<li><a href="../fr416147/index.html">Organisation de la navigation dans les applications iOS à l'aide du Root Controller</a></li>
<li><a href="../fr416149/index.html">Questions et réponses sur les énergies renouvelables, partie 1</a></li>
<li><a href="../fr416151/index.html">Ballon sans dimension. Magie d'analyse de dimension utilitaire</a></li>
<li><a href="../fr416153/index.html">Les avions deviendront-ils plus fiables? Les constructeurs d'avions présentent des robots aux entreprises</a></li>
<li><a href="../fr416157/index.html">Dans les bras de Python (femmes uniquement)</a></li>
<li><a href="../fr416159/index.html">Comment nous avons été chargés de comparer un hérisson avec un serpent</a></li>
<li><a href="../fr416161/index.html">10 raisons [de ne pas] utiliser k8s</a></li>
<li><a href="../fr416163/index.html">Apprenez OpenGL. Leçon 5.6 - Mappage de parallaxe</a></li>
<li><a href="../fr416167/index.html">Peter Norwig: apprendre la programmation en ... 10 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>