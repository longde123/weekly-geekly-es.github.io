<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç≠ üóúÔ∏è üö£üèº WebSockets dans Angular: cr√©ez un service angulaire pour travailler avec des sockets Web üë≤üèø ü§õüèø üò∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais essayer de couvrir en d√©tail l'√©tendue √©troite de la technologie dans le cadre du cadre angulaire et de son assistant d√©j√† i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebSockets dans Angular: cr√©ez un service angulaire pour travailler avec des sockets Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416155/"><img src="https://habrastorage.org/webt/dz/-h/c_/dz-hc_la-a4emvhkqbd4ihr5zfe.jpeg" alt="image"><br>  Dans cet article, je vais essayer de couvrir en d√©tail l'√©tendue √©troite de la technologie dans le cadre du cadre angulaire et de son assistant d√©j√† int√©gr√© - RxJs, alors que nous n'aborderons pas d√©lib√©r√©ment les impl√©mentations de serveur, comme  Il s'agit d'un sujet √† part enti√®re pour un article s√©par√©. <br><br>  Ce texte sera utile √† ceux qui connaissent d√©j√† Angular, mais qui souhaitent approfondir leurs connaissances directement sur le sujet. <br><a name="habracut"></a><br>  Tout d'abord, quelques informations de base. <br><br><h2>  Qu'est-ce que WebSocket et pourquoi en avez-vous besoin </h2><br><blockquote>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> , WebSocket est un ¬´protocole de communication duplex (il peut transmettre et recevoir en m√™me temps) sur une connexion TCP, con√ßu pour la messagerie en temps r√©el entre un navigateur et un serveur Web. <br>  WebSocket est con√ßu pour √™tre impl√©ment√© dans les navigateurs Web et les serveurs Web, mais il peut √™tre utilis√© pour n'importe quelle application client ou serveur.  Le protocole WebSocket est un protocole ind√©pendant bas√© sur le protocole TCP.  Il permet une interaction plus √©troite entre le navigateur et le site Web, facilitant la distribution de contenu interactif et la cr√©ation d'applications en temps r√©el. ¬ª <br></blockquote><br>  En d'autres termes, WebSocket permet au serveur de recevoir des demandes du client et d'envoyer des demandes au client √† tout moment souhait√©, ainsi, le navigateur (client) et le serveur re√ßoivent des droits √©gaux et la possibilit√© d'√©changer des messages lors de la connexion.  Une demande AJAX r√©guli√®re n√©cessite la transmission d'en-t√™tes HTTP complets, ce qui signifie un trafic accru dans les deux sens, tandis que la surcharge des sockets Web apr√®s l'√©tablissement d'une connexion n'est que de deux octets.  La socket Web r√©duit la quantit√© d'informations transmises dans les en-t√™tes HTTP par des centaines et des milliers de fois et r√©duit consid√©rablement le temps d'attente.  Les connexions de socket Web prennent en charge plusieurs domaines comme CORS. <br><br>  C√¥t√© serveur, il existe des packages pour la prise en charge du socket web, sur le client c'est l'API HTML5 WebSocket, qui a une interface de trois m√©thodes: <br><br>  <b><i>WebSocket</i></b> - l'interface principale pour se connecter √† un serveur WebSocket, puis envoyer et recevoir des donn√©es via la connexion; <br>  <b><i>CloseEvent</i></b> - un √©v√©nement distribu√© par l'objet WebSocket lorsque la connexion a √©t√© ferm√©e; <br>  <b><i>MessageEvent</i></b> - Un √©v√©nement distribu√© par un WebSocket lorsqu'un message est re√ßu du serveur. <br><br>  Voici √† quoi cela ressemble au niveau d'impl√©mentation JavaSript: <br><br><pre><code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com/socketserver", "protocolOne"); ws.onopen = () =&gt; { ws.onmessage = (event) =&gt; { console.log(event); } ws.send("Here's some text that the server is urgently awaiting!"); };</code> </pre> <br>  <b><i>onmessage</i></b> - √©coute les messages du serveur <br>  <b><i>envoyer</i></b> - envoyez vos messages au serveur <br><br>  Autrement dit, dans sa forme de base, tout est extr√™mement simple, mais si vous souhaitez vous plonger dans le sujet, vous pouvez vous tourner vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDN Web Docs</a> et en m√™me temps √©tudier des biblioth√®ques qui impl√©mentent leurs propres couches au-dessus de cette API. <br><br><h2>  Pourquoi ne pas avoir peur d'utiliser WebSocket </h2><br>  Le premier point qui peut effrayer est la <b>prise en charge du navigateur</b> .  Aujourd'hui, il n'y a pas un tel probl√®me - WebSocket est pris en charge presque compl√®tement √† la fois sur le Web et dans le segment mobile. <br><br><img src="https://habrastorage.org/webt/6q/kt/br/6qktbrrlnloyi0ec862v8qzclts.png" alt="image"><br><br><img src="https://habrastorage.org/webt/bn/pk/k5/bnpkk58xzozo2c9plnkgszfjnk4.png" alt="image"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://caniuse.com/#feat=websockets</a> <br><br>  Le deuxi√®me point est la <b>facilit√© de mise en ≈ìuvre</b> .  Oui, au d√©but, c'est d√©courageant. <br><br>  L'API est si simple qu'√† premi√®re vue, il peut √™tre difficile de comprendre comment travailler avec un nombre aussi modeste de m√©thodes, car toutes, sauf une, signalent des erreurs ou des connexions, et une seule d'entre elles - <b><i>onmessage</i></b> - contient pour quelles prises Web sont utilis√©es, c.-√†-d.  pour recevoir des donn√©es du serveur. <br><br>  Dans le m√™me temps, le probl√®me est que le serveur envoie g√©n√©ralement des donn√©es diff√©rentes, par cons√©quent, nous avons besoin de plusieurs messages diff√©rents?  Ou avez-vous besoin de cr√©er votre propre connexion pour chaque mod√®le de donn√©es? <br><br>  Donc, la t√¢che: vous devez accepter le mod√®le utilisateur et le dernier mod√®le d'actualit√©s du serveur, et peut-√™tre m√™me autre chose. <br><br>  J'ai rencontr√© une telle impl√©mentation "√©l√©gante": <br><br><pre> <code class="plaintext hljs">const wsUser = new WebSocket("ws://www.example.com/user"); wsUser.onmessage = (event) =&gt; { // ... }; const wsNews = new WebSocket("ws://www.example.com/news"); wsNews.onmessage = (event) =&gt; { // ... }; const wsTime = new WebSocket("ws://www.example.com/time"); wsTime.onmessage = (event) =&gt; { // ... }; const wsDinner = new WebSocket("ws://www.example.com/dinner"); wsDinner.onmessage = (event) =&gt; { // ... }; const wsCurrency = new WebSocket("ws://www.example.com/currency"); wsCurrency.onmessage = (event) =&gt; { // ... }; const wsOnline = new WebSocket("ws://www.example.com/online"); wsOnline.onmessage = (event) =&gt; { // ... }; const wsLogin = new WebSocket("ws://www.example.com/login"); wsLogin.onmessage = (event) =&gt; { // ... }; const wsLogout = new WebSocket("ws://www.example.com/logout"); wsLogout.onmessage = (event) =&gt; { // ... };</code> </pre> <br>  √Ä premi√®re vue, tout est logique.  Mais imaginez maintenant √† quoi cela ressemblera s'il y en a des dizaines ou des centaines.  Dans l'un des projets sur lesquels j'ai travaill√©, il y a eu environ trois cents √©v√©nements. <br><br><img src="https://habrastorage.org/webt/d3/rg/dl/d3rgdlp8eggnms2ot2ely5zktz8.jpeg" alt="image"><br><br>  Nous r√©solvons le probl√®me. <br><br>  Toutes les biblioth√®ques tierces pour travailler avec des sockets Web vous permettent de vous abonner aux messages du type addEventListener.  Cela ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">ws.on("user", (userData) =&gt; { / .. })</code> </pre> <br>  Comme nous le savons, nous pouvons fonctionner avec une seule m√©thode - <b><i>onmessage</i></b> , qui re√ßoit toutes les donn√©es dans le cadre de sa connexion, donc ce code semble quelque peu inhabituel.  Ceci est impl√©ment√© comme suit: <b><i>onmessage</i></b> renvoie un <b><i>MessageEvent</i></b> qui contient le champ de <b><i>donn√©es</i></b> .  Ce sont des <b><i>donn√©es qui</i></b> contiennent les informations que le serveur nous envoie.  Cet objet ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">{ "event": "user", "data": { "name": "John Doe", ... } }</code> </pre> <br>  o√π <b><i>√©v√©nement</i></b> est la cl√© permettant de d√©terminer les informations envoy√©es par le serveur.  Ensuite, du c√¥t√© frontal, un bus est cr√©√© qui filtre les informations par √©v√©nement et les envoie √† l'adresse souhait√©e: <br><br><pre> <code class="plaintext hljs">const ws = new WebSocket("ws://www.example.com"); ws.onmessage = (event) =&gt; { const data = JSON.parse(event.data); if (data.event === 'user') { // ... } if (data.event === 'news') { // ... } };</code> </pre> <br><br>  Cela permet de recevoir diff√©rentes donn√©es au sein d'une m√™me connexion et de s'y abonner via une syntaxe similaire √† celle habituelle pour les √©v√©nements JS. <br><br><h2>  WebSockets en angulaire </h2><br>  Enfin, nous sommes arriv√©s √† la chose la plus importante: utiliser WebSockets directement dans Angular. <br><br>  Malgr√© la simplicit√© de travailler avec l'API WebSocket native, dans cet article, nous utiliserons RxJs, ce qui bien s√ªr, car nous parlons d'Angular. <br><br>  L'API WebSocket native peut √™tre utilis√©e dans des applications angulaires, cr√©er une interface facile √† utiliser, RxJs Observable, s'abonner aux messages n√©cessaires, etc., mais RxJs a d√©j√† fait le travail principal pour vous: WebSocketSubject est un wrapper r√©actif sur le WebSocket standard API  Il ne cr√©e pas de bus d'√©v√©nements ni ne reconnecte le traitement.  Il s'agit d'un sujet standard, avec lequel vous pouvez travailler avec des sockets Web de style r√©actif. <br><br><h2>  RxJs WebSocketSubject </h2><br>  Ainsi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSocketSubject</a> attend <a href="">WebSocketSubjectConfig</a> et une destination facultative, dans laquelle vous pouvez passer un lien vers votre sujet observ√©, cr√©e un observable √† travers lequel vous pouvez √©couter et envoyer des messages pour les sockets Web. <br><br>  Autrement dit, vous passez l'URL de connexion en tant qu'argument WebSocketSubject et vous abonnez √† toute l'activit√© du socket Web de la mani√®re habituelle pour les RxJ.  Et si vous devez envoyer un message au serveur, utilisez la m√™me m√©thode habituelle webSocketSubject.next (data). <br><br><h2>  Nous faisons un service pour travailler avec WebSocket Angular </h2><br>  D√©crivez bri√®vement ce que nous attendons du service: <br><br><ul><li>  Interface unifi√©e et concise; </li><li>  Possibilit√© de configuration au niveau de la connexion des d√©pendances <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DI</a> ; </li><li>  La possibilit√© de r√©utilisation; </li><li>  Dactylographie; </li><li>  La possibilit√© de s'abonner pour recevoir des informations par cl√©; </li><li>  Possibilit√© de r√©silier un abonnement; </li><li>  Envoi de messages au serveur; </li><li>  Reconnectez-vous. </li></ul><br>  Le dernier point m√©rite une attention particuli√®re.  La reconnexion, ou l'organisation de la reconnexion au serveur, est un facteur primordial lorsque vous travaillez avec des sockets Web, comme  les ruptures de r√©seau, les pannes de serveur ou d'autres erreurs qui provoquent une rupture de connexion peuvent entra√Æner le blocage de l'application. <br><br>  Il est important de noter que les tentatives de reconnexion <b>ne devraient pas √™tre trop fr√©quentes</b> et ne devraient pas se poursuivre ind√©finiment, car  ce comportement peut suspendre le client. <br><br>  Commen√ßons. <br><br>  Tout d'abord, nous allons cr√©er une interface de configuration de service et un module qui offrira la possibilit√© de configurer une fois connect√©. <br><br>  Si possible, je raccourcirai le code, la version compl√®te que vous pouvez voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la communaut√© angulaire russophone sur GitHub</a> . <br><br><pre> <code class="plaintext hljs">export interface WebSocketConfig { url: string; reconnectInterval?: number; reconnectAttempts?: number; } export class WebsocketModule { public static config(wsConfig: WebSocketConfig): ModuleWithProviders { return { ngModule: WebsocketModule, providers: [{ provide: config, useValue: wsConfig }] }; } }</code> </pre> <br>  Ensuite, nous devons d√©crire l'interface du message de socket Web: <br><br><pre> <code class="plaintext hljs">export interface IWsMessage&lt;T&gt; { event: string; data: T; }</code> </pre> <br>  o√π <b><i>√©v√©nement</i></b> est la cl√© et les <b><i>donn√©es</i></b> obtenues par la cl√© sont un mod√®le typ√©. <br><br>  L'interface publique du service ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">export interface IWebsocketService { on&lt;T&gt;(event: string): Observable&lt;T&gt;; send(event: string, data: any): void; status: Observable&lt;boolean&gt;; }</code> </pre> <br>  Le service a des champs: <br><br><pre> <code class="plaintext hljs">//   WebSocketSubject private config: WebSocketSubjectConfig&lt;IWsMessage&lt;any&gt;&gt;; private websocketSub: SubscriptionLike; private statusSub: SubscriptionLike; // Observable    interval private reconnection$: Observable&lt;number&gt;; private websocket$: WebSocketSubject&lt;IWsMessage&lt;any&gt;&gt;; // ,      private connection$: Observer&lt;boolean&gt;; //  Observable       private wsMessages$: Subject&lt;IWsMessage&lt;any&gt;&gt;; //       private reconnectInterval: number; //    private reconnectAttempts: number; //      private isConnected: boolean; //   public status: Observable&lt;boolean&gt;;</code> </pre> <br>  Dans le constructeur de la classe de service, nous obtenons l'objet WebSocketConfig sp√©cifi√© lorsque le module √©tait connect√©: <br><br><pre> <code class="plaintext hljs">constructor(@Inject(config) private wsConfig: WebSocketConfig) { this.wsMessages$ = new Subject&lt;IWsMessage&lt;any&gt;&gt;(); //  ,  ,     this.reconnectInterval = wsConfig.reconnectInterval || 5000; this.reconnectAttempts = wsConfig.reconnectAttempts || 10; //      connection$   websocket$ this.config = { url: wsConfig.url, closeObserver: { next: (event: CloseEvent) =&gt; { this.websocket$ = null; this.connection$.next(false); } }, //     connection$ openObserver: { next: (event: Event) =&gt; { console.log('WebSocket connected!'); this.connection$.next(true); } } }; // connection status this.status = new Observable&lt;boolean&gt;((observer) =&gt; { this.connection$ = observer; }).pipe(share(), distinctUntilChanged()); //      this.statusSub = this.status .subscribe((isConnected) =&gt; { this.isConnected = isConnected; if (!this.reconnection$ &amp;&amp; typeof(isConnected) === 'boolean' &amp;&amp; !isConnected) { this.reconnect(); } }); // ,  -    this.websocketSub = this.wsMessages$.subscribe( null, (error: ErrorEvent) =&gt; console.error('WebSocket error!', error) ); //  this.connect(); }</code> </pre> <br>  La m√©thode de connexion elle-m√™me est simple: <br><br><pre> <code class="plaintext hljs">private connect(): void { this.websocket$ = new WebSocketSubject(this.config); //  //   ,    , //  ,  // ,    this.websocket$.subscribe( (message) =&gt; this.wsMessages$.next(message), (error: Event) =&gt; { if (!this.websocket$) { // run reconnect if errors this.reconnect(); } }); }</code> </pre> <br>  La reconnexion est un peu plus compliqu√©e: <br><br><pre> <code class="plaintext hljs">private reconnect(): void { //  interval    reconnectInterval this.reconnection$ = interval(this.reconnectInterval) .pipe(takeWhile((v, index) =&gt; index &lt; this.reconnectAttempts &amp;&amp; !this.websocket$)); //     ,        this.reconnection$.subscribe( () =&gt; this.connect(), null, () =&gt; { // Subject complete if reconnect attemts ending this.reconnection$ = null; if (!this.websocket$) { this.wsMessages$.complete(); this.connection$.complete(); } }); }</code> </pre> <br>  La m√©thode on, c'est aussi extr√™mement simple, il n'y a m√™me rien √† commenter. <br><br><pre> <code class="plaintext hljs">public on&lt;T&gt;(event: string): Observable&lt;T&gt; { if (event) { return this.wsMessages$.pipe( filter((message: IWsMessage&lt;T&gt;) =&gt; message.event === event), map((message: IWsMessage&lt;T&gt;) =&gt; message.data) ); } }</code> </pre> <br>  La m√©thode d' <b><i>envoi</i></b> est encore plus simple: <br><br><pre> <code class="plaintext hljs">public send(event: string, data: any = {}): void { if (event &amp;&amp; this.isConnected) { //   any ,   ""   string //      :) this.websocket$.next(&lt;any&gt;JSON.stringify({ event, data })); } else { console.error('Send error!'); } }</code> </pre> <br>  C'est tout le service.  Comme vous pouvez le voir, l'essentiel du code est tomb√© sur l'organisation de la reconnexion. <br><br>  Voyons maintenant comment l'utiliser.  Connectez le module WebsocketModule: <br><br><pre> <code class="plaintext hljs">imports: [ WebsocketModule.config({ url: environment.ws //      'ws://www.example.com' }) ]</code> </pre> <br>  Dans le constructeur du composant, nous injectons le service et souscrivons aux messages de ' <b><i>messages</i></b> ', renvoyons le texte au serveur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private wsService: WebsocketService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.on&lt;IMessage[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'messages'</span></span></span></span></span><span class="hljs-function">) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages: IMessage[]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wsService.send(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, <span class="hljs-string"><span class="hljs-string">'Test Text!'</span></span>); }); }</code> </pre> <br>  Le nom des √©v√©nements est plus pratique pour mettre des constantes ou une √©num√©ration.  Nous cr√©ons quelque part le fichier websocket.events.ts et l'√©crivons dedans: <br><br><pre> <code class="plaintext hljs">export const WS = { ON: { MESSAGES: 'messages' }, SEND: { TEXT: 'text' } };</code> </pre> <br>  R√©√©crivez les abonnements √† l'aide de l'objet WS cr√©√©: <br><br><pre> <code class="plaintext hljs">this.wsService.on&lt;IMessage[]&gt;(WS.ON.MESSAGES) .subscribe((messages: IMessage[]) =&gt; { console.log(messages); this.wsService.send(WS.SEND.TEXT, 'Test Text!'); });</code> </pre> <br><img src="https://habrastorage.org/webt/zn/jz/k7/znjzk75iy2uudtgep2wr4u8djmk.jpeg" alt="image"><br><br><h2>  En conclusion </h2><br>  En fait, c'est tout.  C'est un minimum n√©cessaire qu'un d√©veloppeur Angular doit conna√Ætre sur WebSockets.  J'esp√®re avoir couvert ce sujet assez clairement.  La version compl√®te du service est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Pour toutes questions que vous pouvez contacter dans les commentaires, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† moi</a> sur Telegram ou sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le canal angulaire</a> au m√™me endroit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416155/">https://habr.com/ru/post/fr416155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416143/index.html">Le livre "Une autopsie va montrer!" Analyse pratique des malwares ¬ª</a></li>
<li><a href="../fr416147/index.html">Organisation de la navigation dans les applications iOS √† l'aide du Root Controller</a></li>
<li><a href="../fr416149/index.html">Questions et r√©ponses sur les √©nergies renouvelables, partie 1</a></li>
<li><a href="../fr416151/index.html">Ballon sans dimension. Magie d'analyse de dimension utilitaire</a></li>
<li><a href="../fr416153/index.html">Les avions deviendront-ils plus fiables? Les constructeurs d'avions pr√©sentent des robots aux entreprises</a></li>
<li><a href="../fr416157/index.html">Dans les bras de Python (femmes uniquement)</a></li>
<li><a href="../fr416159/index.html">Comment nous avons √©t√© charg√©s de comparer un h√©risson avec un serpent</a></li>
<li><a href="../fr416161/index.html">10 raisons [de ne pas] utiliser k8s</a></li>
<li><a href="../fr416163/index.html">Apprenez OpenGL. Le√ßon 5.6 - Mappage de parallaxe</a></li>
<li><a href="../fr416167/index.html">Peter Norwig: apprendre la programmation en ... 10 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>