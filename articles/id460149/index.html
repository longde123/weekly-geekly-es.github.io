<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™»ï¸ â˜ğŸ½ ğŸ‘¨ğŸ½â€ğŸ¨ Pengetikan yang benar: aspek kode bersih yang diremehkan ğŸ’Œ ğŸ‘©ğŸ½â€ğŸš€ ğŸ‘©â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo kolega. 

 Belum lama ini, perhatian kami tertarik pada buku yang hampir selesai oleh Manning Publishing House "Programming with types", yang mer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengetikan yang benar: aspek kode bersih yang diremehkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/460149/">  Halo kolega. <br><br>  Belum lama ini, perhatian kami tertarik pada buku yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hampir selesai</a> oleh Manning Publishing House "Programming with types", yang merinci pentingnya mengetik yang tepat dan perannya dalam menulis kode yang bersih dan tahan lama. <br><br><img src="https://habrastorage.org/webt/i9/d8/mp/i9d8mpulnbdmza0fjef3zfzutaa.png"><br><br>  Pada saat yang sama, di blog penulis, kami menemukan sebuah artikel yang ditulis, tampaknya, pada tahap awal pengerjaan buku dan memungkinkan untuk membuat kesan materi.  Kami menyarankan untuk mendiskusikan seberapa menarik ide penulis dan, berpotensi, keseluruhan buku <br><a name="habracut"></a><br>  <b>Pengorbit iklim Mars</b> <br><br>  Pesawat ruang angkasa Mars Climate Orbiter jatuh selama pendaratan dan hancur berantakan di atmosfer Mars, karena komponen perangkat lunak Lockheed memberikan nilai momentum, diukur dalam pound-force dt., Sedangkan komponen lain yang dikembangkan oleh NASA mengambil nilai momentum dalam Newtons- detik <br><br>  Anda dapat membayangkan komponen yang dikembangkan oleh NASA dalam kira-kira bentuk berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  &gt;= 2 N s void trajectory_correction(double momentum) { if (momentum &lt; 2 /* N s */) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Anda juga dapat membayangkan bahwa komponen Lockheed menyebut kode di atas seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-number"><span class="hljs-number">1.5</span></span> <span class="hljs-comment"><span class="hljs-comment">/* lbf s */</span></span>); }</code> </pre> <br>  Pound-force-second (lbfs) adalah sekitar 4,448222 newton per detik (Ns).  Dengan demikian, dari sudut pandang Lockheed, melewatkan 1,5 lbfs ke <code>trajectory_correction</code> harus normal: 1,5 lbfs sekitar 6,672333 Ns, jauh di atas ambang 2 Ns. <br><br>  Masalahnya adalah interpretasi data.  Akibatnya, komponen NASA membandingkan lbfs dengan Ns tanpa konversi dan secara keliru menginterpretasikan input ke lbfs sebagai input ke Ns.  Karena 1,5 kurang dari 2, pengorbit runtuh.  Ini adalah antipattern terkenal yang disebut obsesi primitif. <br><br>  <b>Obsesi dengan primitif</b> <br><br>  Fiksasi pada primitif memanifestasikan dirinya ketika kita menggunakan tipe data primitif untuk mewakili nilai dalam domain masalah dan memungkinkan situasi seperti yang dijelaskan di atas.  Jika Anda menyatakan kode pos sebagai angka, nomor telepon sebagai string, Ns dan lbfs sebagai angka presisi ganda, inilah yang terjadi. <br><br>  Akan jauh lebih aman untuk mendefinisikan tipe <code>Ns</code> sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ns</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Demikian pula, Anda dapat mendefinisikan tipe <code>lbfs</code> sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Sekarang Anda dapat menerapkan varian <code>trajectory_correction</code> jenis-aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   &gt;= 2 N s void trajectory_correction(Ns momentum) { if (momentum &lt; Ns{ 2 }) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Jika Anda menyebutnya dengan <code>lbfs</code> , seperti pada contoh di atas, maka kode tersebut tidak dapat dikompilasi karena ketidakcocokan jenis: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> }); }</code> </pre> <br>  Perhatikan bagaimana informasi tipe nilai, yang biasanya ditunjukkan dalam komentar, ( <code>2 /*Ns */, /* lbfs */</code> ) sekarang ditarik ke dalam sistem tipe dan dinyatakan dalam kode: ( <code>Ns{ 2 }, lbfs{ 1.5 }</code> ) . <br><br>  Tentu saja, dimungkinkan untuk memberikan pengurangan <code>lbfs</code> menjadi <code>Ns</code> dalam bentuk operator eksplisit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">4.448222</span></span>; } };</code> </pre> <br>  Berbekal teknik ini, Anda dapat memanggil <code>trajectory_correction</code> menggunakan gips statis: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ns&gt;(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> })); }</code> </pre> <br>  Di sini kebenaran kode dicapai dengan mengalikan dengan koefisien.  Pemain juga dapat dilakukan secara implisit (menggunakan kata kunci implisit), dalam hal ini para pemain akan diterapkan secara otomatis.  Sebagai aturan empiris, Anda bisa menggunakan salah satu dari Python coans di sini: <br><blockquote>  Eksplisit lebih baik daripada implisit </blockquote>  Moral dari cerita ini adalah bahwa, meskipun hari ini kita memiliki mekanisme pemeriksaan tipe yang sangat cerdas, mereka masih perlu memberikan informasi yang cukup untuk menangkap kesalahan jenis ini.  Informasi ini masuk ke dalam program jika kami mendeklarasikan tipe-tipe dengan mempertimbangkan secara spesifik area subjek kami. <br><br>  <b>Ruang negara</b> <br><br>  Masalah terjadi ketika suatu program berakhir dalam <i>keadaan buruk</i> .  Jenis membantu mempersempit bidang untuk terjadinya mereka.  Mari kita coba memperlakukan jenis sebagai set nilai yang mungkin.  Misalnya, bool adalah himpunan <code>{true, false}</code> , di mana variabel jenis ini dapat mengambil salah satu dari dua nilai ini.  Demikian pula, <code>uint32_t</code> adalah himpunan <code>{0 ...4294967295}</code> .  Mempertimbangkan tipe-tipe dengan cara ini, kita dapat mendefinisikan ruang keadaan dari program kita sebagai produk dari tipe semua variabel hidup pada titik waktu tertentu. <br><br>  Jika kita memiliki variabel tipe <code>bool</code> dan variabel tipe <code>uint32_t</code> , maka ruang keadaan kita akan menjadi <code>{true, false} X {0 ...4294967295}</code> .  Ini hanya berarti bahwa kedua variabel dapat dalam keadaan apa pun yang mungkin untuk mereka, dan karena kami memiliki dua variabel, program dapat berakhir dalam keadaan gabungan dari kedua jenis ini. <br><br>  Semuanya menjadi jauh lebih menarik jika kita mempertimbangkan fungsi yang menginisialisasi nilai: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_momentum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ns&amp; momentum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; momentum = Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dalam contoh di atas, kita mengambil Ns dengan referensi dan menginisialisasi jika beberapa kondisi terpenuhi.  Fungsi mengembalikan <code>true</code> jika nilai diinisialisasi dengan benar.  Jika fungsi karena alasan tertentu tidak dapat mengatur nilai, maka itu mengembalikan <code>false</code> . <br><br>  Mempertimbangkan situasi ini dari sudut pandang ruang keadaan, kita dapat mengatakan bahwa ruang keadaan adalah produk <code>bool X Ns</code> .  Jika fungsi mengembalikan true, itu berarti bahwa impuls telah diatur, dan merupakan salah satu nilai yang mungkin dari <code>Ns</code> .  Masalahnya adalah ini: jika fungsi mengembalikan <code>false</code> , itu berarti bahwa impuls tidak disetel.  Salah satu cara atau yang lain, momentum milik set nilai yang mungkin dari Ns, tetapi itu bukan nilai yang valid.  Seringkali ada bug di mana keadaan yang tidak dapat diterima berikut secara tidak sengaja mulai menyebar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momenum; get_momentum(momentum); trajectory_correction(momentum); }</code> </pre><br>  Sebaliknya, kita hanya perlu melakukan ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momentum; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (get_momentum(momentum)) { trajectory_correction(momentum); } }</code> </pre> <br>  Namun, ada cara yang lebih baik untuk melakukan ini secara paksa: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;Ns&gt; get_momentum() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_optional(Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }); }</code> </pre> <br>  Jika Anda menggunakan <code>optional</code> , maka ruang status fungsi ini akan berkurang secara signifikan: alih-alih <code>bool X Ns</code> kami mendapatkan <code>Ns + 1</code> .  Fungsi ini akan mengembalikan nilai <code>Ns</code> atau <code>nullopt</code> valid untuk menunjukkan tidak ada nilai.  Sekarang, kita tidak bisa memiliki <code>Ns</code> yang tidak valid yang akan menyebar di sistem.  Juga sekarang menjadi tidak mungkin untuk lupa memeriksa nilai kembali, karena opsional tidak dapat secara implisit dikonversi ke <code>Ns</code> - kita perlu membongkar secara khusus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> maybeMomentum = get_momentum(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maybeMomentum) { trajectory_correction(*maybeMomentum); } }</code> </pre> <br>  Pada dasarnya, kami berupaya agar fungsi kami mengembalikan hasil atau kesalahan, bukan hasil dan kesalahan.  Dengan demikian, kami mengecualikan kondisi di mana kami memiliki kesalahan, dan juga kami aman dari hasil yang tidak dapat diterima, yang kemudian dapat bocor ke perhitungan lebih lanjut. <br><br>  Dari sudut pandang ini, melempar pengecualian adalah normal, karena sesuai dengan prinsip yang dijelaskan di atas: suatu fungsi akan mengembalikan hasil atau melempar pengecualian. <br><br>  <b>RAII</b> <br><br>  RAII berarti Akuisisi Sumber Daya Adalah Inisialisasi, tetapi pada tingkat yang lebih besar prinsip ini dikaitkan dengan pelepasan sumber daya.  Nama pertama kali muncul di C ++, namun pola ini dapat diimplementasikan dalam bahasa apa pun (lihat, misalnya, <code>IDisposable</code> dari .NET).  RAII menyediakan pembersihan sumber daya otomatis. <br><br>  Apa itu sumber daya?  Berikut adalah beberapa contoh: memori dinamis, koneksi basis data, deskriptor OS.  Pada prinsipnya, sumber daya adalah sesuatu yang diambil dari dunia luar dan dapat kembali setelah kita tidak lagi membutuhkannya.  Kami mengembalikan sumber daya menggunakan operasi yang sesuai: lepaskan, hapus, tutup, dll. <br><br>  Karena sumber daya ini bersifat eksternal, mereka tidak secara eksplisit dinyatakan dalam sistem tipe kami.  Sebagai contoh, jika kita memilih sebuah fragmen memori dinamis, kita akan mendapatkan sebuah pointer dimana kita harus memanggil <code>delete</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">/*  foo */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre><br>  Tetapi apa yang terjadi jika kita lupa melakukan ini, atau apakah ada yang menghentikan kita dari panggilan <code>delete</code> ? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre> <br>  Dalam hal ini, kami tidak lagi memanggil <code>delete</code> dan mendapatkan sumber kebocoran.  Pada prinsipnya, pembersihan sumber daya secara manual seperti itu tidak diinginkan.  Untuk memori dinamis, kami memiliki <code>unique_ptr</code> untuk membantu kami mengaturnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Foo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); }</code> </pre> <br>  <code>unique_ptr</code> kami adalah objek tumpukan, oleh karena itu, jika ia <code>unique_ptr</code> ruang lingkup (ketika fungsi melempar pengecualian atau ketika tumpukan membongkar ketika pengecualian dilemparkan), destruktornya disebut.  Destructor inilah yang mengimplementasikan panggilan <code>delete</code> .  Karenanya, kami tidak lagi harus mengelola sumber daya memori - kami mentransfer karya ini ke pembungkus, yang memiliki dan bertanggung jawab atas pelepasannya. <br><br>  Pembungkus serupa ada (atau dapat dibuat) untuk sumber daya lainnya (misalnya, OS HANDLE dari Windows dapat dibungkus dalam suatu jenis, dalam hal ini destruktornya akan memanggil <code>CloseHandle</code> ). <br><br>  Kesimpulan utama dalam kasus ini adalah tidak pernah melakukan pembersihan sumber daya secara manual;  Baik menggunakan pembungkus yang ada, atau jika tidak ada pembungkus yang cocok untuk skenario spesifik Anda, kami akan menerapkannya sendiri. <br><br>  <b>Kesimpulan</b> <br><br>  Kami memulai artikel ini dengan contoh terkenal yang menunjukkan pentingnya mengetik, dan kemudian memeriksa tiga aspek penting dari penggunaan jenis untuk membantu menulis kode yang lebih aman: <br><br><ul><li>  Mendeklarasikan dan menggunakan tipe yang lebih kuat (sebagai lawan obsesi dengan primitif). </li><li>  Mengurangi ruang keadaan, mengembalikan hasil atau kesalahan, bukan hasil atau kesalahan. </li><li>  RAII dan manajemen sumber daya otomatis. </li></ul><br>  Jadi, tipe sangat membantu untuk membuat kode lebih aman dan menyesuaikannya untuk digunakan kembali. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460149/">https://habr.com/ru/post/id460149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460137/index.html">Ulasan Fujitsu LIFEBOOK U939X: Ringan dan Kinerja 2-in-1</a></li>
<li><a href="../id460139/index.html">Programming Championship: tugas parsing untuk pengembang front-end</a></li>
<li><a href="../id460141/index.html">Bukan bahasa pemrograman lain. Bagian 2: Logika Representasi</a></li>
<li><a href="../id460143/index.html">Modul dis Python dan konvolusi konstanta</a></li>
<li><a href="../id460147/index.html">Kerangka kerja microservices PHP - Swoft 2.0.3 diterbitkan</a></li>
<li><a href="../id460151/index.html">Desain berorientasi model. Motor DC Brushless</a></li>
<li><a href="../id460153/index.html">Petualangan tanda tangan elektronik di Rusia</a></li>
<li><a href="../id460155/index.html">Redux ReactiveX</a></li>
<li><a href="../id460157/index.html">Bagaimana jawaban "benar" dari responden dapat mengubah hasil survei tanpa bisa dikenali</a></li>
<li><a href="../id460159/index.html">Metode untuk memantau kondisi jalan Rusia saat ini oleh ponsel cerdas pengguna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>