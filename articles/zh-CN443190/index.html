<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏪ 🕛 👇🏻 安全专业人员的Kubernetes网络策略简介 👃🏼 👨🏽‍🔬 👴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意事项 佩雷夫 ：本文的作者-Reuven Harrison-在软件开发方面拥有20多年的经验，如今是Tufin（一家创建安全策略管理解决方案的公司）的技术总监和共同创始人。 考虑到Kubernetes网络策略是在集群中进行网络分段的足够强大的工具，他认为在实践中应用它们并不是那么容易。 该材料（...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>安全专业人员的Kubernetes网络策略简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/443190/"><img src="https://habrastorage.org/webt/dt/ya/kp/dtyakpb8umg8hkfvtfcrll8kc9y.png"><br><br>  <i><b>注意事项</b></i>  <i><b>佩雷夫</b></i>  <i>：本文的作者-Reuven Harrison-在软件开发方面拥有20多年的经验，如今是Tufin（一家创建安全策略管理解决方案的公司）的技术总监和共同创始人。</i>  <i>考虑到Kubernetes网络策略是在集群中进行网络分段的足够强大的工具，他认为在实践中应用它们并不是那么容易。</i>  <i>该材料（相当大量）旨在提高专家对此事的知识，并帮助他们创建必要的配置。</i> <a name="habracut"></a><br><br> 如今，许多公司越来越选择Kubernetes来运行其应用程序。 人们对该软件的兴趣如此之高，以至于有人称Kubernetes为“新数据中心操作系统”。 逐渐地，Kubernetes（或k8s）开始被视为业务的关键部分，这需要组织成熟的业务流程，包括网络安全性。 <br><br> 对于那些对使用Kubernetes感到困惑的安全专业人员来说，该平台的默认策略可能是一个真正的发现：允许所有这些。 <br><br> 本指南将帮助您了解网络策略的内部结构。 了解它们与普通防火墙的规则有何不同。 还将描述一些陷阱，并提出一些建议，以帮助保护Kubernetes中的应用程序。 <br><br><h2>  Kubernetes网络策略 </h2><br>  Kubernetes网络策略机制允许您在网络级别（OSI模型中的第三个）控制部署在平台上的应用程序的交互。 网络策略缺少现代防火墙的某些高级功能，例如OSI 7级监视和威胁检测，但是它们提供了基本的网络安全级别，这是一个很好的起点。 <br><br><h2> 网络策略控制Pod之间的通信 </h2><br>  Kubernetes工作负载分布在由一个或多个部署在一起的容器组成的Pod中。  Kubernetes为每个Pod分配一个可从其他Pod访问的IP地址。  Kubernetes网络策略为pod组设置权限的方式与使用云中的安全组控制对虚拟机实例的访问的方式相同。 <br><br><h2> 定义网络策略 </h2><br> 与其他Kubernetes资源一样，网络策略也是在YAML中设置的。 在下面的示例中， <code>balance</code>被授予访问<code>postgres</code>权限： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: podSelector: matchLabels: app: postgres ingress: - from: - podSelector: matchLabels: app: balance policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ee/d3/wf/eed3wfhzcdtuhobly7r3wdhyvhk.png"><br><br>  <i>（ <b>注意</b> ：此屏幕快照与所有后续类似屏幕快照一样，不是使用Kubernetes原生工具创建的，而是使用Tufin Orca工具创建的，该工具由原始文章的作者开发，并在本文的结尾提到。）</i> <br><br> 定义自己的网络策略将需要基本的YAML知识。 该语言基于缩进（由空格而不是制表符指定）。 缩进元素属于其上方最近的缩进元素。 新列表项以连字符开头，所有其他项均为<i>键值</i> 。 <br><br> 在YAML中描述了该策略之后，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubectl</a>在集群中创建它： <br><br><pre> <code class="bash hljs">kubectl create -f policy.yaml</code> </pre> <br><h2> 网络策略规范 </h2><br>  Kubernetes网络策略规范包括四个要素： <br><br><ol><li>  <code>podSelector</code> ：定义受此政策影响的Pod（目标）-强制； </li><li>  <code>policyTypes</code> ：指示其中包括哪些类型的策略：入口和/或出口-可选，但是，我建议您在所有情况下都明确注册它； </li><li>  <code>ingress</code> ：定义允许的到目标容器的<b>传入</b>流量-可选； </li><li>  <code>egress</code> ：定义允许从目标吊舱<b>流出的</b>流量-可选。 </li></ol><br> 从Kubernetes网站借用的示例（我用<code>app</code>替换了<code>role</code> ）显示了如何使用所有四个元素： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: # &lt;&lt;&lt; matchLabels: app: db policyTypes: # &lt;&lt;&lt; - Ingress - Egress ingress: # &lt;&lt;&lt; - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: # &lt;&lt;&lt; - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br><img src="https://habrastorage.org/webt/ln/sa/ni/lnsanisggaar5tf3lbda8njxaau.png"><br><img src="https://habrastorage.org/webt/bo/re/in/borein4ll_4hoovj6vdhlo_zfee.png"><br><br> 请注意，所有四个元素都是可选的。 只<code>podSelector</code> ，可以根据需要使用其他参数。 <br><br> 如果省略<code>policyTypes</code> ，则该策略将解释如下： <br><br><ul><li> 默认情况下，假定它定义了入口侧。 如果该策略未明确指出，则系统将认为所有流量都被禁止。 </li><li> 出口侧的行为将取决于是否存在相应的出口参数。 </li></ul><br> 为避免错误，建议<b>始终明确指定<code>policyTypes</code></b> 。 <br><br> 根据上述逻辑，如果省略了<code>ingress</code>和/或<code>egress</code> ，则该策略将禁止所有流量（请参阅下面的“剥离规则”）。 <br><br><h2> 默认策略是允许 </h2><br> 如果未定义任何策略，Kubernetes默认会允许所有流量。 所有Pod均可自由交换信息。 从安全角度来看，这似乎违反直觉，但请记住，Kubernetes最初是由开发人员创建的，目的是确保应用程序交互。 网络策略是在以后添加的。 <br><br><h2> 命名空间 </h2><br> 命名空间是Kubernetes的一种协作机制。 它们旨在隔离逻辑环境，而默认情况下允许空间之间的数据交换。 <br><br> 与大多数Kubernetes组件一样，网络策略位于特定的名称空间中。 在<code>metadata</code>块中，您可以指定策略所属的空间： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: my-namespace # &lt;&lt;&lt; spec: ...</code> </pre> <br> 如果未在元数据中显式编写名称空间，则系统将使用kubectl中指定的名称空间（默认情况下， <code>namespace=default</code> ）： <br><br><pre> <code class="bash hljs">kubectl apply -n my-namespace -f namespace.yaml</code> </pre> <br> 我建议<b>显式指定一个名称空间，</b>除非您要一次编写用于多个名称空间的策略。 <br><br>  <b>策略中的主要</b> <code>podSelector</code>元素将从策略所属的名称空间中选择Pod（拒绝从另一个名称空间访问Pod）。 <br><br> 同样， <b>入口和出口块中的</b> podSelector只能从其名称空间中选择Pod，除非您将它们与<code>namespaceSelector</code>结合使用（这将在“按名称空间和Pod过滤”一节中进行讨论） 。 <br><br><h2> 策略命名规则 </h2><br> 策略名称在单个名称空间中是唯一的。 在一个空间中不能有两个具有相同名称的策略，但是在不同的空间中可能会具有相同名称的策略。 当您要在多个空间中重新应用同一策略时，此功能很有用。 <br><br> 我特别喜欢一种命名方式。 它包括将名称空间名称与目标Pod组合在一起。 例如： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres # &lt;&lt;&lt; namespace: default spec: podSelector: matchLabels: app: postgres ingress: - from: - podSelector: matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/pp/rf/6a/pprf6aa0w2bysbuw6_-lbt926mi.png"><br><br><h2> 标签 </h2><br> 可以将自定义标签附加到Kubernetes对象上，例如吊舱和名称空间。 标签相当于云中的标签。  Kubernetes网络策略使用标签来选择要应用的<b>Pod</b> ： <br><br><pre> <code class="plaintext hljs">podSelector: matchLabels: role: db</code> </pre> <br>  ...或它们适用<b>的名称空间</b> 。 在此示例中，将选择名称空间中带有相应标签的所有窗格： <br><br><pre> <code class="plaintext hljs">namespaceSelector: matchLabels: project: myproject</code> </pre> <br> 一个警告：使用<code>namespaceSelector</code> <b>确保所选的</b> <code>namespaceSelector</code> <b>包含所需的标签</b> 。 请记住， <code>default</code> ，内置名称空间（例如<code>default</code>和<code>kube-system</code>不包含标签。 <br><br> 您可以如下所示向该空间添加标签： <br><br><pre> <code class="bash hljs">kubectl label namespace default namespace=default</code> </pre> <br> 在这种情况下， <code>metadata</code>部分中的名称空间应引用空间的实际名称，而不是标签： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default # &lt;&lt;&lt; spec: ...</code> </pre> <br><h2> 来源和目的地 </h2><br> 防火墙策略由带有源和目标的规则组成。 为此定义了Kubernetes网络策略-对其应用了一组Pod，然后为传入（入口）和/或传出（出口）流量建立规则。 在我们的示例中，策略目标将是<code>default</code>名称空间中的所有Pod，并带有带有<code>app</code>密钥和<code>db</code>值的标签： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: app: db # &lt;&lt;&lt; policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978</code> </pre> <br><img src="https://habrastorage.org/webt/zd/un/wi/zdunwi6xxqfdkvd7tj0qqpmjxly.png"><br><img src="https://habrastorage.org/webt/se/dj/wp/sedjwp5-arw7sxn7hm4dblgqhku.png"><br><br> 此策略中的“ <code>ingress</code>小节将进入的流量打开到目标容器。 换句话说，入口是源，目标是适当的目的地。 同样，出口是目标，目标是其来源。 <br><br><img src="https://habrastorage.org/webt/rs/nf/u9/rsnfu97eapuetrrhbwejb-awnas.png"><br><br>  <i>这等效于防火墙的两个规则：入口→目标；</i>  <i>目标→出口。</i> <br><br><h2> 出口和DNS（重要！） </h2><br> 在限制出站流量时，请<b>特别注意DNS</b> -Kubernetes使用此服务将服务映射到IP地址。 例如，以下策略将不起作用，因为您不允许<code>balance</code>应用程序访问DNS： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/6w/dy/jf/6wdyjftwhfiynlxrx22vivumtli.png"><br><br> 您可以通过打开对DNS服务的访问来修复它： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: # &lt;&lt;&lt; ports: # &lt;&lt;&lt; - protocol: UDP # &lt;&lt;&lt; port: 53 # &lt;&lt;&lt; policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/z4/np/5m/z4np5m-afkmcbkqlgoxufjgc4fm.png"><br><br>  last to元素为空，因此它间接选择<b>所有名称空间中的所有Pod</b> ，从而使<code>balance</code>将DNS查询发送到相应的Kubernetes服务（它通常在<code>kube-system</code>空间中工作）。 <br><br> 这种方法有效，但是<b>过于宽松和不安全</b> ，因为它允许您将DNS查询定向到群集之外。 <br><br> 您可以通过三个连续的步骤对其进行改进。 <br><br>  1.通过添加<code>namespaceSelector</code>仅允许集群中的DNS查询： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: - namespaceSelector: {} # &lt;&lt;&lt; ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/a1/hk/8v/a1hk8vmrton9izmj1jwhxtz-q1e.png"><br><br>  2.仅在<code>kube-system</code>名称空间中允许DNS查询。 <br><br> 为此，将标签添加到<code>kube-system</code> <code>kubectl label namespace kube-system namespace=kube-system</code> ： <code>kubectl label namespace kube-system namespace=kube-system</code>并使用<code>namespaceSelector</code>在策略中注册它： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.balance namespace: default spec: podSelector: matchLabels: app: balance egress: - to: - podSelector: matchLabels: app: postgres - to: - namespaceSelector: # &lt;&lt;&lt; matchLabels: # &lt;&lt;&lt; namespace: kube-system # &lt;&lt;&lt; ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/q6/e2/ed/q6e2edqwfz63nbamlvk2v5zpjhy.png"><br><br>  3.偏执狂甚至可以走得更远，并将DNS查询限制为<code>kube-system</code>的特定DNS服务。 在“按名称空间和容器过滤”部分中，我们将说明如何实现此目的。 <br><br> 另一个选择是在名称空间级别解析DNS。 在这种情况下，无需为每个服务打开它： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.dns namespace: default spec: podSelector: {} # &lt;&lt;&lt; egress: - to: - namespaceSelector: {} ports: - protocol: UDP port: 53 policyTypes: - Egress</code> </pre> <br> 空的<code>podSelector</code>选择名称空间中的所有pod。 <br><br><img src="https://habrastorage.org/webt/ua/hn/7t/uahn7tgfus08_yt1u-rsilqoi90.png"><br><br><h2> 首次比赛和规则顺序 </h2><br> 在普通防火墙中，数据包的操作（“允许”或“拒绝”）由它满足的第一条规则确定。  <b>在Kubernetes中，策略的顺序无关紧要。</b> <br><br> 默认情况下，未设置策略时，将允许Pod之间的通信，并且它们可以自由交换信息。 一旦您开始制定策略，受其中至少一个影响的Pod就会根据已选择策略的所有策略的分离（逻辑或）而被隔离。 不受任何政策影响的豆荚保持开放状态。 <br><br> 您可以使用剥离规则更改此行为。 <br><br><h2> 剥离规则（拒绝） </h2><br> 防火墙策略通常禁止任何明确未经授权的流量。 <br><br>  <b>Kubernetes没有拒绝动作</b> ，但是，通过选择空的一组源Pod（入口），使用常规（允许）策略可以实现类似的效果： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all namespace: default spec: podSelector: {} policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/65/-s/au/65-sauxptvceaqgedw9xvsadlso.png"><br><br> 此策略选择名称空间中的所有Pod，并使入口保持未定义状态，从而阻止所有传入流量。 <br><br> 同样，您可以限制名称空间中的所有传出流量： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: deny-all-egress namespace: default spec: podSelector: {} policyTypes: - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/bn/fg/vq/bnfgvqcfwsgaj-jyompezzmhz6q.png"><br><br> 请注意， <b>任何允许流向名称空间中的Pod的其他策略都将优先于此规则</b> （类似于在防火墙配置中添加允许规则而不是拒绝规则）。 <br><br><h2> 允许所有（任何允许任何允许） </h2><br> 要创建“允许所有”策略，您必须添加上述禁止策略并添加一个空的<code>ingress</code>元素： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all namespace: default spec: podSelector: {} ingress: # &lt;&lt;&lt; - {} # &lt;&lt;&lt; policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/bl/x6/ed/blx6edy0ez8h-yrkil5vb0yeb5g.png"><br><br> 它允许从<b>所有名称空间（和所有IP）中的所有容器访问<code>default</code>名称空间中的任何容器</b> 。 默认情况下，此行为是启用的，因此通常不需要进一步定义。 但是，有时可能需要暂时禁用某些特定权限才能诊断问题。 <br><br> 可以缩小规则，并仅允许访问<code>default</code>名称空间中的一组<b>特定Pod</b> （ <code>app:balance</code> ）： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all-to-balance namespace: default spec: podSelector: matchLabels: app: balance ingress: - {} policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ji/jn/ki/jijnkiy1fzkligxx9b2okk8arm8.png"><br><br> 以下策略允许所有入口和出口流量，包括访问群集外部的任何IP： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: allow-all spec: podSelector: {} ingress: - {} egress: - {} policyTypes: - Ingress - Egress</code> </pre> <br><img src="https://habrastorage.org/webt/yx/eq/c4/yxeqc4hamtqwvirrodsrym7y4iy.png"><br><img src="https://habrastorage.org/webt/bi/nu/ob/binuob-mafzfz6w_r-2fmdseu2c.png"><br><br><h2> 结合多种政策 </h2><br> 使用逻辑或在三个级别上组合策略； 每个Pod的权限是根据影响它的所有策略的相异性设置的： <br><br>  1.在<code>from</code>和<code>to</code>字段中，可以定义三种类型的元素（所有元素都使用OR组合）： <br><br><ul><li>  <code>namespaceSelector</code>选择整个命名空间； </li><li>  <code>podSelector</code>选择吊舱； </li><li>  <code>ipBlock</code>选择一个子网。 </li></ul><br> 此外， <code>from</code> / <code>to</code>小节中的元素数量（即使相同）也不受限制。 所有这些将通过逻辑或组合。 <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - podSelector: matchLabels: app: admin podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/_y/pu/xy/_ypuxynlq6wslkjk65yyj5_zwsi.png"><br><br>  2.在策略内部， <code>ingress</code>部分可以具有许多<code>from</code>元素（通过逻辑OR组合）。 同样， <code>egress</code>部分可以包含许多to元素（也可以通过子句连接）： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - from: - podSelector: matchLabels: app: admin podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/4t/-l/f9/4t-lf9a8fm1f4whkitifyhgyfee.png"><br><br>  3.各种策略也通过逻辑或组合 <br><br> 但是，在组合它们时， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">克里斯·库尼</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指出了</a>一个限制：Kubernetes只能组合具有不同<code>policyTypes</code> （ <code>Ingress</code>或<code>Egress</code> ）的策略。 定义入口（或出口）的策略将相互覆盖。 <br><br><h2> 命名空间之间的关系 </h2><br> 默认情况下，名称空间之间的信息交换是允许的。 可以使用限制到命名空间的传出和/或传入流量的禁止策略来更改此设置（请参见上面的“剥离规则”）。 <br><br> 通过阻止对名称空间的访问（请参见上面的“剥离规则”），可以通过使用<code>namespaceSelector</code>允许来自特定名称<code>namespaceSelector</code>连接来限制策略的例外： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: # &lt;&lt;&lt; matchLabels: namespace: default policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/gh/-0/ed/gh-0edsyfhl5st5_8nngwadmoai.png"><br><br> 结果， <code>default</code>名称空间中的所有容器都将有权访问<code>database</code>名称空间中的<code>postgres</code>容器。 但是，如果您想仅对<code>default</code>名称空间中的特定容器开放对<code>postgres</code>访问权限，该怎么办？ <br><br><h2> 按名称空间和Pod过滤 </h2><br>  Kubernetes 1.11和更高版本允许您使用逻辑I组合<code>namespaceSelector</code>和<code>podSelector</code>运算符。它看起来像这样： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: matchLabels: namespace: default podSelector: # &lt;&lt;&lt; matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/47/_b/op/47_bopr6mjii5-qkujgiwgs2bku.png"><br><br> 为什么将其解释为AND而不是通常的OR？ <br><br> 请注意， <code>podSelector</code>不能以连字符开头。 在YAML中，这意味着<code>podSelector</code>和位于其前面的<code>namespaceSelector</code>引用相同的列表项。 因此，它们由逻辑I组合。 <br><br> 在<code>podSelector</code>前面添加连字符将产生一个新列表项，该列表项将使用逻辑OR与先前的<code>namespaceSelector</code>组合。 <br><br> 要<b>在所有名称空间中</b>选择带有特定标签的Pod，请输入一个空的<code>namespaceSelector</code> ： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: database.postgres namespace: database spec: podSelector: matchLabels: app: postgres ingress: - from: - namespaceSelector: {} podSelector: matchLabels: app: admin policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/t9/lc/vn/t9lcvnyl17u39krw9vn1nc-5xmk.png"><br><br><h2> 多个标签与AND结合 </h2><br> 使用逻辑或将具有许多对象（主机，网络，组）的防火墙的规则组合在一起。 如果数据包的来源与<code>Host_1</code>或<code>Host_2</code>匹配，则以下规则将起作用： <br><br><pre> <code class="plaintext hljs">| Source | Destination | Service | Action | | ----------------------------------------| | Host_1 | Subnet_A | HTTPS | Allow | | Host_2 | | | | | ----------------------------------------|</code> </pre> <br> 相反，在Kubernetes中， <code>podSelector</code>或<code>namespaceSelector</code>中的各种标签由逻辑I组合。例如，以下规则将选择同时具有两个标签的Pod， <code>role=db</code> AND <code>version=v2</code> ： <br><br><pre> <code class="plaintext hljs">podSelector: matchLabels: role: db version: v2</code> </pre> <br> 相同的逻辑适用于所有类型的运算符：策略目标选择器，窗格选择器和名称空间选择器。 <br><br><h2> 子网和IP地址（IP块） </h2><br> 防火墙使用VLAN，IP地址和子网来划分网络。 <br><br> 在Kubernetes中，IP地址是自动分配给Pod的，并且可以经常更改，因此标签用于在网络策略中选择Pod和名称空间。 <br><br>  <code>ipBlocks</code> （ <code>ipBlocks</code> ）用于控制入站（入站）或出站（出站）外部（南北）连接。 例如，此策略使所有从<code>default</code>名称空间访问的Pod都可以访问Google DNS服务： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-dns namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 8.8.8.8/32 ports: - protocol: UDP port: 53</code> </pre> <br><img src="https://habrastorage.org/webt/fm/uc/oa/fmucoaptwhse0i5yx-hsize1d0e.png"><br><br> 此示例中的空容器选择器表示“选择名称空间中的所有容器”。 <br><br> 该策略仅提供对8.8.8.8的访问； 拒绝访问任何其他IP。 因此，从本质上讲，您阻止了对Kubernetes内部DNS服务的访问。 如果仍然要打开它，请明确指定它。 <br><br> 通常，由于<code>ipBlocks</code>中未使用<code>ipBlocks</code>的内部IP地址，因此<code>ipBlocks</code>和<code>podSelectors</code>是互斥的。  <b>通过</b>指定<b>内部IP容器</b> ，您实际上将允许使用这些地址与容器进行连接。 实际上，您将不知道要使用哪个IP地址，这就是为什么不应将其用于选择Pod的原因。 <br><br> 作为反例，以下策略包括所有IP，因此允许访问所有其他Pod： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-any namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 0.0.0.0/0</code> </pre> <br><img src="https://habrastorage.org/webt/yt/dt/ow/ytdtowaueimdgmppg5x9mp7y2ec.png"><br><br> 您可以通过排除容器的内部IP地址来仅打开对外部IP的访问。 例如，如果您的Pod的子网是10.16.0.0/14： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: egress-any namespace: default spec: podSelector: {} policyTypes: - Egress egress: - to: - ipBlock: cidr: 0.0.0.0/0 except: - 10.16.0.0/14</code> </pre> <br><img src="https://habrastorage.org/webt/9a/iz/c4/9aizc4r0bjzljsl0smkwaagpgfm.png"><br><br><h2> 端口和协议 </h2><br> 通常，pod在一个端口上侦听。 这意味着您可以简单地省略策略中的端口号，并将所有内容保留为默认值。 但是，建议对策略进行严格限制，因此在某些情况下，您仍然可以指定端口： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer - podSelector: matchLabels: app: admin ports: # &lt;&lt;&lt; - port: 443 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; - port: 80 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/ie/yo/og/ieyoogygmsewwwxtg0ncvsapxmw.png"><br><br> 注意， <code>ports</code>选择器应用于它包含的<code>to</code>或<code>from</code>块中的所有元素。 要为不同的元素集指定不同的端口，请使用<code>to</code>或<code>from</code>输入或<code>egress</code>分成几个小节，并在每个小节中列出您的端口： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default.postgres namespace: default spec: ingress: - from: - podSelector: matchLabels: app: indexer ports: # &lt;&lt;&lt; - port: 443 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; - from: - podSelector: matchLabels: app: admin ports: # &lt;&lt;&lt; - port: 80 # &lt;&lt;&lt; protocol: TCP # &lt;&lt;&lt; podSelector: matchLabels: app: postgres policyTypes: - Ingress</code> </pre> <br><img src="https://habrastorage.org/webt/bw/_a/8p/bw_a8p4luekpljv4c9zh6p4hw_y.png"><br><br> 默认端口起作用： <br><br><ul><li> 如果您完全省略端口的定义，则表示所有协议和所有端口。 </li><li> 如果省略协议定义，则表示TCP。 </li><li> 如果省略端口的定义，则表示所有端口。 </li></ul><br> 最佳实践：不要依赖默认值，明确指定所需的内容。 <br><br> 请注意，有必要使用Pod端口，而不是服务（下一段中将对此进行更多说明）。 <br><br><h2> 是否为Pod或服务定义了策略？ </h2><br> 通常，Kubernetes中的Pod通过服务相互联系-虚拟负载平衡器将流量重定向到实现该服务的Pod。 您可能会认为网络策略控制对服务的访问，但事实并非如此。  <b>Kubernetes网络策略适用于Pod端口，而不适用于服务。</b> <br><br> ,    80- ,      8080  pod',       8080. <br><br>     :      (   pod')    . <br><br>      Service Mesh <i>(, .  Istio  — . .)</i>     . <br><br><h2>     Ingress,   Egress? </h2><br>   — ,  pod     pod' ,       (    egress-),  pod        ( , ,  ingress-). <br><br>         ,       . <br><br>   pod- <b></b>      <b>egress</b> -,        .         pod'- <b></b> .  pod   - ,   (egress)    . <br><br>    pod'- <b></b> ,     <b>ingress</b> -,    .           pod'-.  pod   - ,   (ingress)      . <br><br> .  «Stateful  Stateless» . <br><br><h2>  </h2><br>   Kubernetes    .    ,     ,       . <br><br><h2>       </h2><br>   Kubernetes       (DNS)   egress.             ,   IP- (  aws.com). <br><br><h2>   </h2><br>         . Kubernetes    .      kubectl Kubernetes  ,   ,    .    Kubernetes       .      : <br><br><pre> <code class="plaintext hljs">kubernetes get networkpolicy &lt;policy-name&gt; -o yaml</code> </pre> <br>   ,    Kubernetes        . <br><br><h2>  </h2><br> Kubernetes      ,    API-,        ,  Container Networking Interface (CNI).     Kubernetes    CNI             .        CNI ,    Kubernetes,    <i>(     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> — . .)</i> ,   ,   CNI  . <br><br>  ,  Kubernetes   ,         CNI. <br><br><h3> Stateful  Stateless? </h3><br>  CNI Kubernetes,     ,   (, Calico  Linux conntrack).   pod'      TCP-     .       Kubernetes,      (statefulness). <br><br><h2>     </h2><br>          Kubernetes: <br><br><ol><li>   Service Mesh  sidecar-           .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Istio</a> . </li><li>    CNI   ,        Kubernetes. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tufin Orca</a>       Kubernetes. </li></ol><br>  Tufin Orca    Kubernetes (   ,  ). <br><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  ,  Ahmet Alp Balkan'  GKE</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Kubernetes</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Kubernetes</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a> . </li></ul><br><h2> 结论 </h2><br>   Kubernetes       ,        .  ,  -        .             . <br><br> ,          ,     . <br><br><h2> 译者的PS </h2><br> 另请参阅我们的博客： <br><br><ul><li> «     Istio»: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 1 (   )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 2 (,  )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 3 ()</a> ; </li><li> «      Kubernetes»: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 1  2 ( ,  )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 3 (   )</a> ; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker  Kubernetes     </a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">9       Kubernetes</a> »; </li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">11  ()     Kubernetes</a> ». </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443190/">https://habr.com/ru/post/zh-CN443190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443180/index.html">船员龙降落和小行星视频拍摄</a></li>
<li><a href="../zh-CN443182/index.html">从Commodore 64拉YPbPr</a></li>
<li><a href="../zh-CN443184/index.html">从爱到掌控一步</a></li>
<li><a href="../zh-CN443186/index.html">3CX技术支持响应-5 IP PBX安全规则</a></li>
<li><a href="../zh-CN443188/index.html">三只眼睛垂在柱子上，或者传说ATtiny13的五条腿就足够了</a></li>
<li><a href="../zh-CN443192/index.html">Python中没有下划线和接口的私有方法</a></li>
<li><a href="../zh-CN443194/index.html">WFIRM工程师发明了一种生物打印机，可以直接在伤口上打印皮肤</a></li>
<li><a href="../zh-CN443196/index.html">离线一分钟-选择工业LTE路由器</a></li>
<li><a href="../zh-CN443198/index.html">马克·扎克伯格（Mark Zuckerberg）说，Facebook正在研究一种用于阅读思想的神经接口</a></li>
<li><a href="../zh-CN443200/index.html">伊朗黑客从Citrix窃取了TB的数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>