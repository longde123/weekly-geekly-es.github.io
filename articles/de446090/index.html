<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∫Ô∏è ü§≥üèæ üèåÔ∏è Micropython auf GSM + GPS-Modul A9G ü§º üò∞ üë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieses Mal habe ich vorsichtshalber dar√ºber nachgedacht, einen GPS-Tracker in meinem Fahrrad zu verstecken. Auf dem Markt gibt es unz√§hlige autonome G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Micropython auf GSM + GPS-Modul A9G</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446090/"><p>  Dieses Mal habe ich vorsichtshalber dar√ºber nachgedacht, einen GPS-Tracker in meinem Fahrrad zu verstecken.  Auf dem Markt gibt es unz√§hlige autonome Ger√§te zur Verfolgung von Autos, Fracht, Fahrr√§dern, Gep√§ck, Kindern und Tieren.  Die √ºberwiegende Mehrheit von ihnen interagiert mit dem Benutzer per SMS.  Teurere Optionen bieten die Funktion "Mein Telefon suchen", sind jedoch an einen bestimmten Onlinedienst gebunden. <br>  Idealerweise m√∂chte ich die volle Kontrolle √ºber den Tracker haben: Verwenden Sie ihn in einem praktischen Modus ohne SMS und Registrierung.  Oberfl√§chliches Google brachte mir ein paar Module aus China, von denen ich eines bestellte (A9G Pudding Board) (~ 15 $). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7f/b34/fe0/f7fb34fe016bb3a6c532712b9b2e75e1.png" alt="Modul"></p><br><p>  In diesem Artikel geht es darum, wie Python in diesem Modul funktioniert. </p><a name="habracut"></a><br><p>  Wenn der A9G ein Analogon von ESP ist (der Hersteller ist √ºbrigens derselbe), ist die Puddingplatine selbst ein Analogon der NodeMCU-Platine, au√üer dass die Puddingplatine keinen eingebauten USB-UART-Konverter hat.  Aber es gibt noch viele andere interessante Dinge.  <a href="">Herstellerspezifikationen</a> : </p><br><ul><li>  32-Bit-Kern (RISC), bis zu 312 MHz </li><li>  29x GPIO (alle sind verl√∂tet, alle Schnittstellen sind in dieser Nummer enthalten) </li><li>  Uhren und Wachhund </li><li>  1x USB 1.1-Schnittstelle (ich habe sie dort nicht gefunden, aber von au√üerhalb kopiert) und microUSB f√ºr die Stromversorgung </li><li>  2x UART (+1 Service) </li><li>  2x SPI (nicht ausprobiert) </li><li>  3x I2C (nicht ausprobiert) </li><li>  1x SDMMC (mit physischem Steckplatz) </li><li>  2x analoge Eing√§nge (10 Bit, m√∂glicherweise einer davon wird von Lithium-Batterie-Controllern verwendet) </li><li>  4 MB Flash </li><li>  4 MB PSRAM </li><li>  ADC (Mikrofon, physisch vorhanden auf der Platine) und DAC (Lautsprecher, nicht vorhanden) </li><li>  Batterieladesteuerung (es gibt keine Batterie selbst) </li><li>  in der Tat GSM (800, 900, 1800, 1900 MHz) mit SMS, Sprache und GPRS </li><li>  GPS √ºber UART2 verbunden (es gibt ein "A9" -Modul ohne es) </li><li>  SIM-Steckplatz (nanoSIM) </li><li>  zwei Tasten (eine zur√ºckgesetzt, die andere - Aufnahme und programmierbare Funktion) </li><li>  zwei LEDs </li></ul><br><p>  Die Betriebsspannung betr√§gt 3,3 V, die Eingangsspannung 5-3,8 V (je nach Anschluss).  Im Allgemeinen verf√ºgt das Modul √ºber die erforderliche Hardware, um daraus ein einfaches mobiles Druckknopfger√§t zusammenzusetzen.  Aber aus den Beispielen geht hervor, dass die Chinesen es zum Verkauf an Spielautomaten oder Spielautomaten oder √§hnlichem kaufen.  Alternativen zum Modul sind die recht beliebten SIM800-Module, die leider kein √∂ffentlich zug√§ngliches SDK haben (d. H. Die Module werden als AT-Modems verkauft). </p><br><h1>  SDK </h1><br><p> Das Modul wird mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDK</a> in zufriedenstellendem Englisch geliefert.  Wird unter Ubuntu installiert, Windows und Container werden jedoch bevorzugt.  Alles funktioniert durch St√∂bern in der GUI: ESPtool f√ºr dieses Modul muss noch zur√ºckgesetzt werden.  Die Firmware selbst wird vom Makefile erstellt.  Der Debugger ist vorhanden: Vor dem Einfrieren wirft das Modul den Stack-Trace in den Service-Port.  Aber pers√∂nlich konnte ich die Adressen nicht in Codezeilen √ºbersetzen (GDB berichtet, dass die Adressen nichts entsprechen).  M√∂glicherweise liegt dies an der schlechten Unterst√ºtzung von Linux als solchem.  Wenn Sie also mit dem Modul basteln m√∂chten, versuchen Sie es unter Windows (und melden Sie sich bei github ab).  Ansonsten ist hier die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> f√ºr Linux.  Nach der Installation m√ºssen Sie die Richtigkeit der Pfade in .bashrc √ºberpr√ºfen und alle <code>CSDTK/lib/libQt*</code> l√∂schen (umbenennen). <code>CSDTK/lib/libQt*</code> der <code>CSDTK/lib/libQt*</code> (auch als Debugger bezeichnet) aufgrund eines Konflikts mit wahrscheinlich installiertem libQt einfach nicht gestartet. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/955/5bc/7a79555bca02e1ad6363b8da9559c91e.png" alt="Blinker"></p><br><p>  Zum Blinker gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisung</a> . </p><br><h1>  Verbindung </h1><br><p>  Alles ist komplizierter als bei NodeMCU.  Die Module sehen √§hnlich aus, aber es gibt keinen USB-TTY-Chip auf der Puddingplatte und microUSB wird nur f√ºr die Stromversorgung verwendet.  Dementsprechend ben√∂tigen Sie USB-TTY bei 3,3V.  Zwei sind besser: einer f√ºr den Debug-Port und einer f√ºr UART1: Der erste dient zum Hochladen der Firmware und der zweite kann als regul√§res Terminal verwendet werden.  Um nicht all diesen Rotz auf den Computer zu ziehen, habe ich zus√§tzlich einen 4-Port-USB-Splitter mit einem zwei Meter langen Kabel und einem externen Netzteil (erforderlich) gekauft.  Die Gesamtkosten f√ºr dieses Kit mit dem Modul selbst betragen 25 bis 30 USD (ohne Stromversorgung: Verwendung √ºber das Telefon). </p><br><h1>  Firmware </h1><br><p>  Das Modul wird mit AT-Firmware geliefert: Sie k√∂nnen eine Verbindung zu einem 3,3-V-Arduino herstellen und es √ºber UART1 als Modem verwenden.  Ihre Firmware ist in C geschrieben. <code>make</code> erstellt zwei Firmware-Dateien: Eine wird etwa eine Minute lang gen√§ht, die andere ist schnell genug.  Es kann nur eine dieser Dateien gen√§ht werden: Das erste Mal ist gro√ü, die folgenden Zeiten sind klein.  Insgesamt habe ich w√§hrend des Entwicklungsprozesses das chinesische SDK ( <code>coolwatcher</code> ) auf dem Desktop ge√∂ffnet, um das Modul zu verwalten, miniterm als stdio und den Code-Editor. </p><br><h1>  API </h1><br><p>  Der Inhalt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> spiegelt die obige Liste wider und √§hnelt dem ESP8266 in seinen Anf√§ngen: Ich habe ungef√§hr 3 Stunden gebraucht, um HelloWorld zu starten.  Leider sind die Funktionen, die dem Benutzer zur Verf√ºgung stehen, sehr begrenzt: Beispielsweise gibt es keinen Zugriff auf das Telefonbuch auf der SIM-Karte, Informationen auf niedriger Ebene zum Herstellen einer Verbindung zum Mobilfunknetz usw.  Die API-Dokumentation ist noch weniger vollst√§ndig, daher m√ºssen Sie sich auf Beispiele (von denen es zwei Dutzend gibt) verlassen und Dateien einschlie√üen.  Trotzdem kann das Modul viele Dinge bis hin zu SSL-Verbindungen tun: Offensichtlich hat sich der Hersteller auf die Funktionen mit der h√∂chsten Priorit√§t konzentriert. </p><br><p>  Die Programmierung chinesischer Mikrocontroller √ºber die chinesische API muss jedoch geliebt werden.  F√ºr alle anderen begann der Hersteller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micropython</a> auf dieses Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu portieren</a> .  Ich habe mich entschlossen, mich in einem Open-Source-Projekt zu versuchen und diese gute Arbeit fortzusetzen (Link am Ende des Artikels). </p><br><h1>  Mikropython </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a1/b46/e00/9a1b46e00d290db2f478ebb54f7d9e74.jpg" alt="Logo"></p><br><p>  Micropython ist ein Open-Source-Projekt, das cPython auf Mikrocontroller portiert.  Die Entwicklung erfolgt in zwei Richtungen.  Die erste ist die Unterst√ºtzung und Entwicklung von Kernbibliotheken, die allen Mikrocontrollern gemeinsam sind und die Arbeit mit den wichtigsten Datentypen in Python beschreiben: Objekte, Funktionen, Klassen, Zeichenfolgen, Atomtypen und mehr.  Das zweite sind in der Tat die Ports: F√ºr jeden Mikrocontroller muss die Bibliothek ‚Äûgelehrt‚Äú werden, mit UART f√ºr die Eingabe / Ausgabe zu arbeiten, einen Stapel f√ºr eine virtuelle Maschine ausw√§hlen und eine Reihe von Optimierungen angeben.  Optional wird die Arbeit mit Hardware beschrieben: GPIO, Stromversorgung, WLAN, Dateisystem. <br>  All dies ist in reinem C mit Makros geschrieben: micropython bietet eine Reihe empfohlener Rezepte, von der Deklaration von Zeichenfolgen im ROM bis zum Schreiben von Modulen.  Dar√ºber hinaus werden selbst geschriebene Python-Module vollst√§ndig unterst√ºtzt (die Hauptsache ist, die Speichergr√∂√üe nicht zu vergessen).  Die Kuratoren des Projekts hatten sich zum Ziel gesetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, einen Dzhanga</a> (Bild mit einem Laib Brot) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu lancieren</a> .  Als Werbung: Das Projekt verkauft ein eigenes Board f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pyboard-</a> Studenten, aber auch Ports f√ºr die Module ESP8266 und ESP32 sind beliebt. </p><br><p>  Wenn die Firmware fertig ist und hochgeladen wurde, stellen Sie einfach √ºber UART eine Verbindung zum Mikrocontroller her und gelangen in die Python-REPL. </p><br><pre> <code class="bash hljs">$ miniterm.py /dev/ttyUSB1 115200 --raw MicroPython cd2f742 on 2017-11-29; unicorn with Cortex-M3 Type <span class="hljs-string"><span class="hljs-string">"help()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) hello</code> </pre> <br><p>  Danach k√∂nnen Sie mit dem Schreiben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in fast normalem Python3 beginnen,</a> ohne die Speicherbeschr√§nkungen zu vergessen. </p><br><p>  Ein A9G-Modul wird nicht offiziell unterst√ºtzt (eine Liste der offiziell unterst√ºtzten Module ist in <code>micropython/ports</code> verf√ºgbar, es gibt ungef√§hr ein Dutzend davon).  Trotzdem gabelte der Eisenhersteller Micropython und schuf die Umgebung f√ºr den A9G-Port: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>micropython/ports/gprs_a9</code></a> , wof√ºr er sich sehr bedankt.  Als ich mich f√ºr dieses Problem interessierte, wurde der Port erfolgreich kompiliert und der Mikrocontroller begr√º√üte mich mit REPL.  Leider wurde von Modulen von Drittanbietern nur mit dem Dateisystem und GPIO gearbeitet: Es war nichts in Bezug auf das drahtlose Netzwerk und GPS verf√ºgbar.  Ich habe mich entschlossen, diesen Fehler zu beheben und mir das Ziel gesetzt, alle f√ºr einen GPS-Tracker erforderlichen Funktionen zu portieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die offizielle Dokumentation</a> f√ºr diesen Fall ist unn√∂tig kurz: Deshalb musste ich mich im Code umsehen. </p><br><h2>  Wo soll ich anfangen? </h2><br><p>  Gehen Sie zun√§chst zu <code>micropython/ports</code> und kopieren Sie <code>micropython/ports/minimal</code> in den neuen Ordner, in dem sich der Port befindet.  Bearbeiten Sie dann <code>main.c</code> f√ºr Ihre Plattform.  Denken Sie daran, dass sich alle Leckereien in der Hauptfunktion befinden, in der Sie den Initialisierer <code>mp_init()</code> aufrufen <code>mp_init()</code> , nachdem Sie zuvor die Einstellungen f√ºr den Mikrocontroller und den Stapel vorbereitet haben.  Anschlie√üend m√ºssen Sie f√ºr die ereignisgesteuerte API <code>pyexec_event_repl_init()</code> aufrufen und die √ºber UART eingegebenen Zeichen der Funktion <code>pyexec_event_repl_process_char(char)</code> .  Dies bietet Interoperabilit√§t durch REPL.  Die zweite Datei, <code>micropython/ports/minimal/uart_core.c</code> beschreibt das Blockieren der Ein- und Ausgabe in UART.  Ich bringe den Originalcode f√ºr STM32 f√ºr diejenigen mit, die zu faul sind, um danach zu suchen. </p><br><p> <code>main.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_dummy; stack_top = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)&amp;stack_dummy; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_GC gc_init(heap, heap + sizeof(heap)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> mp_init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_COMPILER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_REPL_EVENT_DRIVEN pyexec_event_repl_init(); for (;;) { int c = mp_hal_stdin_rx_chr(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pyexec_event_repl_process_char(c)) { break; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pyexec_friendly_repl(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//do_str("print('hello world!', list(x+1 for x in range(10)), end='eol\\n')", MP_PARSE_SINGLE_INPUT); //do_str("for i in range(10):\r\n print(i)", MP_PARSE_FILE_INPUT); #else pyexec_frozen_module("frozentest.py"); #endif mp_deinit(); return 0; }</span></span></span></span></code> </pre> <br><p> <code>uart_core.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Receive single character int mp_hal_stdin_rx_chr(void) { unsigned char c = 0; #if MICROPY_MIN_USE_STDOUT int r = read(0, &amp;c, 1); (void)r; #elif MICROPY_MIN_USE_STM32_MCU // wait for RXNE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 5)) == 0) { } c = USART1-&gt;DR; #endif return c; } // Send string of given length void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) { #if MICROPY_MIN_USE_STDOUT int r = write(1, str, len); (void)r; #elif MICROPY_MIN_USE_STM32_MCU while (len--) { // wait for TXE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 7)) == 0) { } USART1-&gt;DR = *str++; } #endif }</span></span></code> </pre> <br><p>  Danach m√ºssen Sie das Makefile mit den Empfehlungen / dem Compiler des Herstellers neu schreiben: Hier ist alles individuell.  Alles, dies sollte im Idealfall ausreichen: Wir sammeln, f√ºllen die Firmware aus und sehen REPL in UART. <br>  Nachdem Sie <code>micropython</code> wiederbelebt <code>micropython</code> Sie sich um sein Wohlbefinden k√ºmmern: <code>micropython</code> Sie den Garbage Collector ein, die richtige Reaktion auf Strg-D (Soft Reset) und einige andere Dinge, auf die ich nicht <code>mpconfigport.h</code> werde: siehe die Datei <code>mpconfigport.h</code> . </p><br><h2>  Erstellen Sie ein Modul </h2><br><p>  Am interessantesten ist es, eigene Module zu schreiben.  Das Modul (nicht notwendig, aber w√ºnschenswert) beginnt also mit einer eigenen <code>mod[].c</code> Datei, die vom <code>Makefile</code> hinzugef√ºgt wird ( <code>SRC_C</code> Variable, wenn Sie der Konvention folgen).  Ein leeres Modul lautet wie folgt: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nlr - non-local return:  C  ,      goto-  . //  nlr_raise             . #include "py/nlr.h" //   .  ,  mp_map_elem_t,  ,   . #include "py/obj.h" //   . mp_raise_ValueError(char* msg)  mp_raise_OSError(int errorcode)   . //  ,   mp_call_function_*     Callable (  callback-). #include "py/runtime.h" #include "py/binary.h" //  header   :       #include "portmodules.h" //    --  .     MP_QSTR_[ ]. MP_OBJ_NEW_QSTR   . //             RAM. //      -      __name__ STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, }; //      STATIC MP_DEFINE_CONST_DICT (mp_module_mymodule_globals, mymodule_globals_table); //   :             const mp_obj_module_t mp_module_mymodule = { .base = { &amp;mp_type_module }, .globals = (mp_obj_dict_t*)&amp;mp_module_mymodule_globals, };</span></span></code> </pre> <br><p>  Nat√ºrlich erkennt der Port selbst die Konstante <code>mp_module_mymodule</code> : Sie muss der Variablen <code>MICROPY_PORT_BUILTIN_MODULES</code> in den <code>mpconfigport.h</code> <code>MICROPY_PORT_BUILTIN_MODULES</code> <code>mpconfigport.h</code> .  √úbrigens <del>  langweilige Tapeten </del>  Dort √§ndern sich auch der Chipname und der Portname.  Nach all diesen √Ñnderungen k√∂nnen Sie versuchen, das Modul zu kompilieren und aus REPL zu importieren.  F√ºr das Modul ist nur ein <code>__name__</code> Attribut mit dem <code>__name__</code> verf√ºgbar (ein <code>__name__</code> Fall f√ºr die √úberpr√ºfung der automatischen Vervollst√§ndigung in REPL √ºber die Registerkarte). </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.__name__ <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span></code> </pre> <br><h2>  Konstanten </h2><br><p>  Die n√§chste Stufe der Komplexit√§t ist das Hinzuf√ºgen von Konstanten.  F√ºr Einstellungen ( <code>INPUT</code> , <code>OUTPUT</code> , <code>HIGH</code> , <code>LOW</code> usw.) sind h√§ufig Konstanten erforderlich. <code>OUTPUT</code> ist alles recht einfach.  Hier ist zum Beispiel die Konstante <code>magic_number = 10</code> : </p><br><pre> <code class="cpp hljs">STATIC <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mp_map_elem_t</span></span> mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, };</code> </pre> <br><p>  Testen: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.magic_number <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><h2>  Funktionen </h2><br><p>  Das Hinzuf√ºgen einer Funktion zu einem Modul folgt dem allgemeinen Prinzip: deklarieren, umbrechen, hinzuf√ºgen (ich gebe ein etwas komplexeres Beispiel als in der Dokumentation). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  STATIC mp_obj_t conditional_add_one(mp_obj_t value) { //   int.         -  :   . int value_int = mp_obj_get_int(value); value_int ++; if (value_int == 10) { //  None return mp_const_none; } //   int return mp_obj_new_int(value); } //    .     // runtime.h   . STATIC MP_DEFINE_CONST_FUN_OBJ_1(conditional_add_one_obj, conditional_add_one); //  STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, };</span></span></code> </pre> <br><p>  Test: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">9</span></span>) &gt;&gt;&gt;</code> </pre> <br><h2>  Klassen (Typen) </h2><br><p>  Bei Klassen (Typen) ist auch alles relativ einfach.  Hier ist ein Beispiel aus der Dokumentation (na ja, fast): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = {}; //   STATIC MP_DEFINE_CONST_DICT(mymodule_hello_locals_dict, mymodule_hello_locals_dict_table); // ,  ,   const mp_obj_type_t mymodule_helloObj_type = { //    { &amp;mp_type_type }, // : helloObj .name = MP_QSTR_helloObj, //  .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, }; //    STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;mymodule_helloObj_type }, };</span></span></code> </pre> <br><p>  Test: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>mymodule.helloObj &lt;type <span class="hljs-string"><span class="hljs-string">'helloObj'</span></span>&gt;</code> </pre> <br><p>  Der resultierende Typ kann vererbt und verglichen werden, hat jedoch keinen Konstruktor oder zugeh√∂rige Daten.  Die Daten werden "neben" dem Konstruktor hinzugef√ºgt: Es wird vorgeschlagen, eine separate Struktur zu erstellen, in der der Python-Typ separat und separat gespeichert wird - ein beliebiger Datensatz. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -. ,    typedef struct _mymodule_hello_obj_t { //   mp_obj_base_t base; // -  uint8_t hello_number; } mymodule_hello_obj_t;</span></span></code> </pre> <br><p>  Wie interagiere ich mit diesen Daten?  Eine der schwierigsten M√∂glichkeiten ist der Konstruktor. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -,   (,  ,   mymodule_helloObj_type //   ,     - ),   (args  kwargs)  //        : args, kwargs STATIC mp_obj_t mymodule_hello_make_new( const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args ) { //    mp_arg_check_num(n_args, n_kw, 1, 1, true); //   mymodule_hello_obj_t *self = m_new_obj(mymodule_hello_obj_t); //     self-&gt;base.type = &amp;mymodule_hello_type; //   self-&gt;hello_number = mp_obj_get_int(args[0]) //   return MP_OBJ_FROM_PTR(self); //    __init__, ,  } //      make_new const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, //  .make_new = mymodule_hello_make_new, };</span></span></code> </pre> <br><p>  Von den anderen Feldern gibt es auch <code>.print</code> , und ich denke, der Rest der Magie von <code>Python3</code> . </p><br><p>  <code>make_new</code> ist jedoch √ºberhaupt nicht erforderlich, um eine Instanz eines Objekts <code>make_new</code> : Die Initialisierung kann in einer beliebigen Funktion erfolgen.  Hier ist ein gutes Beispiel aus <code>micropython/ports/esp32/modsocket.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   :       STATIC mp_obj_t get_socket(size_t n_args, const mp_obj_t *args) { socket_obj_t *sock = m_new_obj_with_finaliser(socket_obj_t); sock-&gt;base.type = &amp;socket_type; sock-&gt;domain = AF_INET; sock-&gt;type = SOCK_STREAM; sock-&gt;proto = 0; sock-&gt;peer_closed = false; if (n_args &gt; 0) { sock-&gt;domain = mp_obj_get_int(args[0]); if (n_args &gt; 1) { sock-&gt;type = mp_obj_get_int(args[1]); if (n_args &gt; 2) { sock-&gt;proto = mp_obj_get_int(args[2]); } } } sock-&gt;fd = lwip_socket(sock-&gt;domain, sock-&gt;type, sock-&gt;proto); if (sock-&gt;fd &lt; 0) { exception_from_errno(errno); } _socket_settimeout(sock, UINT64_MAX); return MP_OBJ_FROM_PTR(sock); } //     0-3  STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(get_socket_obj, 0, 3, get_socket);</span></span></code> </pre> <br><h2>  Gebundene Methoden </h2><br><p>  Der n√§chste Schritt ist das Hinzuf√ºgen der gebundenen Methoden.  Dies unterscheidet sich jedoch nicht wesentlich von allen anderen Methoden.  Wir kehren aus der Dokumentation zum Beispiel zur√ºck: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    :     1 (self) STATIC mp_obj_t mymodule_hello_increment(mp_obj_t self_in) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); self-&gt;hello_number += 1; return mp_const_none; } //     MP_DEFINE_CONST_FUN_OBJ_1(mymodule_hello_increment_obj, mymodule_hello_increment); //      'inc' STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR_inc), (mp_obj_t)&amp;mymodule_hello_increment_obj }, }</span></span></code> </pre> <br><p>  Das ist alles! </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.inc()</code> </pre> <br><h2>  Alle anderen Attribute: <strong>getattr</strong> , <strong>setattr</strong> </h2><br><p>  Wie w√§re es mit dem Hinzuf√ºgen von <code>@property</code> mit <code>@property</code> und im Allgemeinen Ihrem eigenen <code>__getattr__</code> ?  Bitte: Dies erfolgt manuell unter Umgehung von <code>mymodule_hello_locals_dict_table</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ... STATIC void mymodule_hello_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); if (dest[0] != MP_OBJ_NULL) { // __setattr__ if (attr == MP_QSTR_val) { self-&gt;val = dest[1]; dest[0] = MP_OBJ_NULL; } } else { // __getattr__ if (attr == MP_QSTR_val) { dest[0] = self-&gt;val; } } } // ...     attr const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, //     //.locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, .make_new = mymodule_hello_make_new, //   - attr .attr = mymodule_hello_attr, };</span></span></code> </pre><br><p>  Es hat sich etwas schmerzhaft Pr√§gnantes herausgestellt, sagen Sie.  Wo sind all diese <code>mp_raise_AttributeError</code> ( <em>Hinweis</em> : Eine solche Funktion gibt es nicht)?  Tats√§chlich wird ein <code>AttributeError</code> automatisch aufgerufen.  Das Geheimnis ist, dass <code>dest</code> ein Array von zwei Elementen ist.  Das erste Element hat die Bedeutung "Ausgabe", schreibgesch√ºtzt: Es nimmt den Wert <code>MP_OBJ_SENTINEL</code> wenn der Wert geschrieben werden muss, und <code>MP_OBJ_NULL</code> wenn er gelesen werden muss.  Dementsprechend wird beim Verlassen der Funktion im ersten Fall <code>mp_obj_t</code> im zweiten etwas <code>mp_obj_t</code> erwartet.  Das zweite Element ist schreibgesch√ºtzt: <code>MP_OBJ_NULL</code> den Wert des zu schreibenden Objekts, wenn der Wert geschrieben werden muss, und <code>MP_OBJ_NULL</code> wenn er gelesen werden muss.  Sie m√ºssen es nicht √§ndern. </p><br><p>  Das ist alles, was Sie √ºberpr√ºfen k√∂nnen: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.val = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; x.val <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Am interessantesten ist, dass die Tab-Vervollst√§ndigung in REPL immer noch funktioniert und <code>.val</code> bietet!  Um ehrlich zu sein, bin ich kein Experte f√ºr C, daher kann ich nur raten, wie dies geschieht (indem ich den Operator '==' neu definiere). </p><br><h2>  Hafen </h2><br><p>  Zur√ºck zum A9G-Modul habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Unterst√ºtzung aller Grundfunktionen beschrieben, n√§mlich SMS, GPRS (Usockets), GPS und Energieverwaltung.  Jetzt k√∂nnen Sie so etwas in das Modul hochladen und es wird funktionieren: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cellular <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usocket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> machine <span class="hljs-comment"><span class="hljs-comment">#   print("Waiting network registration ...") while not c.is_network_registered(): time.sleep(1) time.sleep(2) #  GPRS print("Activating ...") c.gprs_activate("internet", "", "") print("Local IP:", sock.get_local_ip()) #  GPS gps.on() #    thingspeak host = "api.thingspeak.com" api_key = "some-api-key" fields = ('latitude', 'longitude', 'battery', 'sat_visible', 'sat_tracked') #  ,      ! fields = dict(zip(fields, map(lambda x: "field{}".format(x+1), range(len(fields))) )) x, y = gps.get_location() level = machine.get_input_voltage()[1] sats_vis, sats_tracked = gps.get_satellites() s = sock.socket() print("Connecting ...") s.connect((host, 80)) print("Sending ...") #      ,     HTTP.           HTTP, SSL   print("Sent:", s.send("GET /update?api_key={}&amp;{latitude}={:f}&amp;{longitude}={:f}&amp;{battery}={:f}&amp;{sat_visible}={:d}&amp;{sat_tracked}={:d} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n".format( api_key, x, y, level, sats_vis, sats_tracked, host, **fields ))) print("Receiving ...") print("Received:", s.recv(128)) s.close()</span></span></code> </pre> <br><p>  Das Projekt freut sich √ºber jede m√∂gliche Hilfe.  Wenn Ihnen das Projekt und / oder dieser Artikel gefallen hat, vergessen Sie nicht, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Like auf dem Github zu hinterlassen</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446090/">https://habr.com/ru/post/de446090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446078/index.html">‚ÄûSound‚Äú: Diskussion eines Podcasts √ºber Audiotechnologie</a></li>
<li><a href="../de446080/index.html">In den USA empfahl das Gericht, den Import bestimmter iPhone-Modelle wegen Versto√ües gegen die Patente von Qualcomm Apple zu verbieten</a></li>
<li><a href="../de446082/index.html">Die Geschichte der halben Ringe</a></li>
<li><a href="../de446086/index.html">Linux-Geschichte. Teil III: Neue M√§rkte und alte "Feinde"</a></li>
<li><a href="../de446088/index.html">Dinge, die ich 2018 nicht wei√ü</a></li>
<li><a href="../de446092/index.html">Nur ohne H√§nde! Roboter, die Benutzeraktionen nicht wiederholen</a></li>
<li><a href="../de446094/index.html">Mit einem Periodensystem f√ºrs Leben</a></li>
<li><a href="../de446096/index.html">Das Buch ‚ÄûTasteVill: Wie man im Einzelhandel eine Revolution macht und alles falsch macht‚Äú</a></li>
<li><a href="../de446098/index.html">Sowjetisches Flugkontrollzentrum aus der Zeit von "Wostok" und "Sonnenaufgang"</a></li>
<li><a href="../de446100/index.html">Erstellen Sie automatisch Android- und iOS-Lokalisierungsdateien aus einer Excel-Tabelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>