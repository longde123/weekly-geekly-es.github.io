<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎖️ 🙏🏼 🌹 Top 10 des erreurs les plus courantes que j'ai rencontrées dans les projets Go 🐸 🎓 😏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce message est mon top des erreurs les plus courantes que j'ai rencontrées dans les projets Go. L'ordre n'a pas d'importance. 



 Valeur inconnue d'E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 des erreurs les plus courantes que j'ai rencontrées dans les projets Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Ce message est mon top des erreurs les plus courantes que j'ai rencontrées dans les projets Go.</i></b>  L'ordre n'a pas d'importance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="image"><br><br><h3>  Valeur inconnue d'Enum </h3><br>  Jetons un coup d'œil à un exemple simple: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Ici, nous créons un énumérateur en utilisant iota, ce qui conduira à cet état: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Imaginons maintenant que ce type de statut fasse partie de la requête JSON qui sera compressée / décompressée.  Nous pouvons concevoir la structure suivante: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Ensuite, nous obtenons le résultat de cette requête: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  En général, rien de spécial - le statut sera décompressé dans StatusOpen. <br>  Maintenant, obtenons une autre réponse dans laquelle la valeur d'état n'est pas définie: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  Dans ce cas, le champ Status de la structure Request sera initialisé à zéro (pour uint32, il est égal à 0).  Par conséquent, nous obtenons à nouveau StatusOpen au lieu de StatusUnknown. <br><br>  Dans ce cas, il est préférable de définir d'abord la valeur inconnue de l'énumérateur - c'est-à-dire  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Si le statut ne fait pas partie de la demande JSON, il sera initialisé dans StatusUnknown, comme nous nous y attendons. <br><br><h3>  Analyse comparative </h3><br>  Une analyse comparative correcte est assez difficile.  Trop de facteurs peuvent influencer le résultat. <br><br>  Une erreur courante est trompée par les optimisations du compilateur.  Voyons un exemple spécifique de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque teivah / bitvector</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Cette fonction efface les bits dans une plage donnée.  Nous pouvons tester les performances de cette manière: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  Dans ce test, le compilateur remarquera que clear n'appelle aucune autre fonction, il l'incorpore donc simplement tel quel.  Une fois qu'il est intégré, le compilateur verra qu'aucun effet secondaire ne se produit.  Ainsi, l'appel clair sera simplement supprimé, ce qui entraînera des résultats inexacts. <br><br>  Une solution peut être de définir le résultat sur une variable globale, comme celle-ci: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Ici, le compilateur ne saura pas si l'appel crée un effet secondaire.  Par conséquent, le repère sera précis. <br><br><h3>  Pointeurs!  Les pointeurs sont partout! </h3><br>  Le passage d'une variable par valeur créera une copie de cette variable.  En passant par le pointeur, copiez simplement l'adresse en mémoire. <br><br>  Par conséquent, passer un pointeur sera toujours plus rapide, non? <br><br>  Si vous le pensez, jetez un œil à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet exemple</a> .  Il s'agit d'une référence pour une structure de données de 0,3 Ko que nous transmettons et recevons d'abord par pointeur, puis par valeur.  0,3 Ko est un peu - sur les structures de données habituelles avec lesquelles nous travaillons quotidiennement occupent à peu près autant. <br><br>  Lorsque j'exécute ces tests dans un environnement local, la transmission valeur par valeur est plus de 4 fois plus rapide.  Assez inattendu, non? <br><br>  L'explication de ce résultat est liée à une compréhension de la façon dont la gestion de la mémoire se produit dans Go.  Je ne peux pas l'expliquer aussi brillamment que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">William Kennedy</a> , mais essayons de résumer en un mot. <br><br>  Une variable peut être placée sur le tas ou la pile: <br><ul><li>  La pile contient les variables actuelles de ce programme.  Dès que la fonction revient, les variables sont extraites de la pile. </li><li>  Le tas contient des variables communes (variables globales, etc.). </li></ul><br>  Regardons un exemple simple où nous retournons une valeur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Ici, la variable de résultat est créée par le goroutine actuel.  Cette variable est poussée sur la pile actuelle.  Dès le retour de la fonction, le client recevra une copie de cette variable.  La variable elle-même est extraite de la pile.  Elle existe toujours en mémoire jusqu'à ce qu'une autre variable soit remplacée, mais elle n'est plus accessible. <br>  Maintenant le même exemple, mais avec un pointeur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  La variable de résultat est toujours créée par le goroutine actuel, mais le client recevra un pointeur (une copie de l'adresse de la variable).  Si la variable de résultat a été extraite de la pile, le client de cette fonction ne pourra pas y accéder. <br><br>  Dans ce scénario, le compilateur Go affichera la variable de résultat là où les variables peuvent être partagées, c'est-à-dire  en groupe. <br><br>  Un autre script pour passer des pointeurs: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Puisque nous appelons f dans le même programme, la variable p n'a pas besoin d'être empilée.  Il est simplement poussé sur la pile et une sous-fonction peut y accéder. <br><br>  Par exemple, de cette manière, une tranche est obtenue dans la méthode Read de io.Reader.  Le retour d'une tranche (qui est un pointeur) la place dans un tas. <br><br>  Pourquoi la pile est-elle si rapide?  Il y a deux raisons: <br><ul><li>  Pas besoin d'utiliser le ramasse-miettes sur la pile.  Comme nous l'avons déjà dit, une variable est simplement poussée après avoir été créée, puis extraite de la pile lorsque la fonction revient.  Pas besoin de déclencher un processus compliqué pour renvoyer des variables inutilisées, etc. </li><li>  La pile appartient à une seule goroutine, donc le stockage de la variable n'a pas besoin d'être synchronisé, comme cela arrive avec le stockage sur le tas, ce qui entraîne également une augmentation des performances. </li></ul><br>  En conclusion, lorsque nous créons une fonction, notre action par défaut devrait être d'utiliser des valeurs au lieu de pointeurs.  Un pointeur ne doit être utilisé que si nous voulons partager une variable. <br><br>  De plus, si nous souffrons de problèmes de performances, l'une des optimisations possibles pourrait être de vérifier si les pointeurs aident dans des situations spécifiques?  Si le compilateur génère une variable dans le tas, vous pouvez le savoir avec la commande suivante: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Mais, encore une fois, pour la plupart de nos tâches quotidiennes, il est préférable d'utiliser des valeurs. <br><br><h3>  Abandon de / commutateur ou de / sélection </h3><br>  Que se passe-t-il dans l'exemple suivant si f renvoie vrai? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Nous appelons pause.  Seule cette coupure rompt l'interrupteur, pas la boucle for. <br><br>  Même problème ici: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  Break est associé à une instruction select, pas à une boucle for. <br><br>  Une solution possible pour interrompre pour / changer ou pour / sélectionner est d'utiliser une étiquette: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Gestion des erreurs </h3><br>  Go est encore jeune, surtout dans le domaine du traitement des erreurs.  Surmonter cette lacune est l'une des innovations les plus attendues de Go 2. <br><br>  La bibliothèque standard actuelle (antérieure à Go 1.13) ne propose que des fonctions de construction d'erreurs.  Par conséquent, il sera intéressant de regarder le paquetage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>pkg / errors</i></a> . <br><br>  Cette bibliothèque est un bon moyen de suivre une règle qui n'est pas toujours respectée: <br><blockquote>  L'erreur ne doit être traitée qu'une seule fois.  La journalisation des erreurs est la gestion des erreurs </blockquote>  .  Par conséquent, l'erreur doit être enregistrée ou lancée plus haut. <br><br>  Dans la bibliothèque standard actuelle, ce principe est difficile à observer, car nous pouvons vouloir ajouter du contexte à l'erreur et avoir une sorte de hiérarchie. <br><br>  Regardons un exemple avec un appel REST conduisant à une erreur de base de données: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Si nous utilisons pkg / errors, nous pouvons faire ce qui suit: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  L'erreur initiale (si elle n'est pas renvoyée par la bibliothèque externe) peut être créée à l'aide d'erreurs.  La couche intermédiaire, insert, encapsule cette erreur, en y ajoutant plus de contexte.  Ensuite, le parent l'enregistre.  Ainsi, chaque niveau renvoie ou traite une erreur. <br><br>  Nous pouvons également vouloir rechercher la cause de l'erreur, par exemple, pour rappeler.  Supposons que nous ayons un package db d'une bibliothèque externe qui a accès à une base de données.  Cette bibliothèque peut renvoyer une erreur temporaire appelée db.DBError.  Pour déterminer si nous devons réessayer, nous devons établir la cause de l'erreur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Cela se fait en utilisant des erreurs.Cause, qui est également incluse dans <i>pkg / errors</i> : <br><br>  L'une des erreurs courantes que j'ai rencontrées a été l'utilisation partielle de <i>pkg / errors</i> .  Une vérification d'erreur, par exemple, a été effectuée comme suit: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Dans cet exemple, si db.DBError est encapsulé, il ne fera jamais un deuxième appel. <br><br><h3>  Initialisation de tranche </h3><br>  Parfois, nous savons quelle sera la longueur finale de la tranche.  Par exemple, supposons que nous voulons convertir une tranche Foo en tranche Bar, ce qui signifie que ces deux tranches auront la même longueur. <br><br>  Je rencontre souvent des tranches initialisées de cette façon: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Slice n'est pas une structure magique.  Sous le capot, il met en œuvre une stratégie pour augmenter la taille s'il n'y a plus d'espace libre.  Dans ce cas, un nouveau tableau est automatiquement créé (avec une plus grande capacité) et tous les éléments y sont copiés. <br><br>  Imaginons maintenant que nous devions répéter cette opération d'augmentation de la taille plusieurs fois, car notre [] Foo contient des milliers d'éléments.  La complexité de l'algorithme d'insertion restera O (1), mais en pratique, cela affectera les performances. <br><br>  Par conséquent, si nous connaissons la longueur finale, nous pouvons: <br><br><ul><li>  Initialisez-le avec une longueur prédéfinie: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Ou initialisez-le avec une longueur de 0 et une capacité prédéterminée: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Quelle est la meilleure option?  Le premier est un peu plus rapide.  Cependant, vous pouvez préférer cette dernière, car elle est plus cohérente: que nous connaissions ou non la taille initiale, l'ajout d'un élément à la fin de la tranche se fait en utilisant append. <br><br><h3>  Gestion du contexte </h3><br>  context.Context est souvent mal compris par les développeurs.  Selon la documentation officielle: <br><blockquote>  Le contexte porte l'échéance, le signal d'annulation et d'autres valeurs au-delà des limites de l'API. <br>  Cette description est assez générale, elle peut donc induire le programmeur en erreur quant à son utilisation correcte. </blockquote><br>  Essayons de le comprendre.  Le contexte peut porter: <br><ul><li>  Date limite - signifie soit la durée (par exemple, 250 ms) ou la date-heure (par exemple, 2019-01-08 01:00:00), selon laquelle nous pensons que si elle est atteinte, l'action en cours doit être annulée (demande d'E / S ), en attente de l'entrée du canal, etc.). </li><li>  Annuler le signal (essentiellement &lt;-chan struct {}).  Ici, le comportement est similaire.  Dès que nous recevons un signal, nous devons arrêter le travail en cours.  Par exemple, supposons que nous recevions deux demandes.  L'une pour insérer des données, l'autre pour annuler la première demande (car elle n'est plus pertinente, par exemple).  Ceci peut être réalisé en utilisant le contexte annulé dans le premier appel, qui sera ensuite annulé dès que nous recevrons la deuxième demande. </li><li>  Liste de clés / valeurs (toutes deux basées sur le type d'interface {}). </li></ul><br>  Encore deux points.  Premièrement, le contexte est composable.  Par conséquent, nous pouvons avoir un contexte qui porte l'échéance et la liste clé / valeur, par exemple.  De plus, plusieurs goroutines peuvent partager le même contexte, donc un signal d'annulation peut potentiellement arrêter plusieurs travaux. <br><br>  Revenant à notre sujet, voici une erreur que j'ai rencontrée. <br><br>  L’application Go était basée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>urfave / cli</i></a> (si vous ne savez pas, c’est une bonne bibliothèque pour créer des applications de ligne de commande dans Go).  Une fois lancé, le développeur hérite d'une sorte de contexte d'application.  Cela signifie que lorsque l'application est arrêtée, la bibliothèque utilise le contexte pour envoyer un signal d'annulation. <br><br>  J'ai remarqué que ce contexte était transmis directement, par exemple, lorsqu'un point de terminaison gRPC était appelé.  Ce n'est pas du tout ce dont nous avons besoin. <br><br>  Au lieu de cela, nous voulons dire à la bibliothèque gRPC: veuillez annuler la demande lorsque l'application est arrêtée, ou après 100 ms, par exemple. <br><br>  Pour y parvenir, nous pouvons simplement créer un contexte composite.  Si parent est le nom du contexte d'application (créé par <i>urfave / cli</i> ), alors nous pouvons simplement faire ceci: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Les contextes ne sont pas si difficiles à comprendre et, à mon avis, c'est l'une des meilleures caractéristiques du langage. <br><br><h3>  Ne pas utiliser l'option -race </h3><br>  Tester une application Go sans l'option -race est un bug que je rencontre constamment. <br><br>  Comme écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> , bien que Go ait été « <i>conçu pour rendre la programmation parallèle plus simple et moins sujette aux erreurs</i> », nous souffrons toujours grandement de problèmes de concurrence. <br><br>  De toute évidence, le détecteur de course Go ne résoudra aucun problème.  Cependant, c'est un outil précieux et nous devons toujours l'inclure lors du test de nos applications. <br><br><h3>  Utilisation du nom de fichier comme entrée </h3><br>  Une autre erreur courante consiste à transmettre le nom de fichier à une fonction. <br><br>  Supposons que nous devons implémenter une fonction pour compter le nombre de lignes vides dans un fichier.  L'implémentation la plus naturelle ressemblerait à ceci: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Le nom du fichier est défini comme une entrée, nous l'ouvrons donc, puis implémentons notre logique, non? <br><br>  Supposons maintenant que nous voulons couvrir cette fonction avec des tests unitaires.  Nous allons tester avec un fichier normal, un fichier vide, un fichier avec un type d'encodage différent, etc. Cela peut être très difficile à gérer. <br><br>  De plus, si nous voulons implémenter la même logique, par exemple, pour le corps HTTP, nous devrons créer une autre fonction pour cela. <br><br>  Go est livré avec deux grandes abstractions: io.Reader et io.Writer.  Au lieu de passer le nom du fichier, nous pouvons simplement passer io.Reader, qui va abstraire la source de données. <br>  S'agit-il d'un fichier?  Corps HTTP?  Tampon d'octets?  Cela n'a pas d'importance, car nous utiliserons toujours la même méthode de lecture. <br><br>  Dans notre cas, nous pouvons même tamponner l'entrée pour la lire ligne par ligne.  Pour ce faire, vous pouvez utiliser bufio.Reader et sa méthode ReadLine: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Désormais, la responsabilité de l'ouverture du fichier a été déléguée au client de comptage: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  Dans une deuxième implémentation, une fonction peut être appelée quelle que soit la source de données réelle.  En attendant, cela facilitera nos tests unitaires, car nous pouvons simplement créer bufio.Reader à partir de la ligne: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutines et variables de cycle </h3><br>  La dernière erreur commune que j'ai rencontrée était lors de l'utilisation de goroutines avec des variables de boucle. <br><br>  Quelle sera la conclusion de l'exemple suivant? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 au hasard?  Non. <br><br>  Dans cet exemple, chaque goroutine utilise la même instance d'une variable, elle affichera donc 3 3 3 (le plus probable). <br><br>  Il existe deux solutions à ce problème.  La première consiste à passer la valeur de la variable i à la fermeture (fonction interne): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  La seconde consiste à créer une autre variable dans la boucle for: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Attribuer i: = i peut sembler un peu étrange, mais cette conception est parfaitement valide.  Être dans une boucle signifie être dans une portée différente.  Par conséquent, i: = i crée une autre instance de la variable i.  Bien sûr, nous pouvons l'appeler avec un nom différent pour plus de lisibilité. <br><br>  <i>Si vous connaissez d'autres erreurs courantes, n'hésitez pas à en parler dans les commentaires.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461051/">https://habr.com/ru/post/fr461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461041/index.html">Arrondi ou à angle aigu?</a></li>
<li><a href="../fr461043/index.html">La gestion des conflits en équipe - un équilibre ou une nécessité vitale?</a></li>
<li><a href="../fr461045/index.html">Obtenez un extrait de Rosreestr via FSIS USRN et python. Partie 1</a></li>
<li><a href="../fr461047/index.html">Écrire ou ne pas écrire. Lettres aux autorités lors des événements</a></li>
<li><a href="../fr461049/index.html">ONYX BOOX Faust - Celui qui cherche n'est pas obligé d'errer</a></li>
<li><a href="../fr461053/index.html">Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 2 - Cartes vectorielles</a></li>
<li><a href="../fr461055/index.html">Rekko Challenge 2019: comment c'était</a></li>
<li><a href="../fr461057/index.html">Chaînes de télégramme sur le développement de jeux</a></li>
<li><a href="../fr461059/index.html">Écrire une application Android pour les fans de films - Partie 1 (Prototypage)</a></li>
<li><a href="../fr461061/index.html">Alliages de magnésium, frontières jumelles et ségrégation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>