<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéñÔ∏è üôèüèº üåπ Top 10 des erreurs les plus courantes que j'ai rencontr√©es dans les projets Go üê∏ üéì üòè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce message est mon top des erreurs les plus courantes que j'ai rencontr√©es dans les projets Go. L'ordre n'a pas d'importance. 



 Valeur inconnue d'E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 des erreurs les plus courantes que j'ai rencontr√©es dans les projets Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Ce message est mon top des erreurs les plus courantes que j'ai rencontr√©es dans les projets Go.</i></b>  L'ordre n'a pas d'importance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="image"><br><br><h3>  Valeur inconnue d'Enum </h3><br>  Jetons un coup d'≈ìil √† un exemple simple: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Ici, nous cr√©ons un √©num√©rateur en utilisant iota, ce qui conduira √† cet √©tat: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Imaginons maintenant que ce type de statut fasse partie de la requ√™te JSON qui sera compress√©e / d√©compress√©e.  Nous pouvons concevoir la structure suivante: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Ensuite, nous obtenons le r√©sultat de cette requ√™te: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  En g√©n√©ral, rien de sp√©cial - le statut sera d√©compress√© dans StatusOpen. <br>  Maintenant, obtenons une autre r√©ponse dans laquelle la valeur d'√©tat n'est pas d√©finie: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  Dans ce cas, le champ Status de la structure Request sera initialis√© √† z√©ro (pour uint32, il est √©gal √† 0).  Par cons√©quent, nous obtenons √† nouveau StatusOpen au lieu de StatusUnknown. <br><br>  Dans ce cas, il est pr√©f√©rable de d√©finir d'abord la valeur inconnue de l'√©num√©rateur - c'est-√†-dire  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Si le statut ne fait pas partie de la demande JSON, il sera initialis√© dans StatusUnknown, comme nous nous y attendons. <br><br><h3>  Analyse comparative </h3><br>  Une analyse comparative correcte est assez difficile.  Trop de facteurs peuvent influencer le r√©sultat. <br><br>  Une erreur courante est tromp√©e par les optimisations du compilateur.  Voyons un exemple sp√©cifique de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que teivah / bitvector</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Cette fonction efface les bits dans une plage donn√©e.  Nous pouvons tester les performances de cette mani√®re: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  Dans ce test, le compilateur remarquera que clear n'appelle aucune autre fonction, il l'incorpore donc simplement tel quel.  Une fois qu'il est int√©gr√©, le compilateur verra qu'aucun effet secondaire ne se produit.  Ainsi, l'appel clair sera simplement supprim√©, ce qui entra√Ænera des r√©sultats inexacts. <br><br>  Une solution peut √™tre de d√©finir le r√©sultat sur une variable globale, comme celle-ci: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Ici, le compilateur ne saura pas si l'appel cr√©e un effet secondaire.  Par cons√©quent, le rep√®re sera pr√©cis. <br><br><h3>  Pointeurs!  Les pointeurs sont partout! </h3><br>  Le passage d'une variable par valeur cr√©era une copie de cette variable.  En passant par le pointeur, copiez simplement l'adresse en m√©moire. <br><br>  Par cons√©quent, passer un pointeur sera toujours plus rapide, non? <br><br>  Si vous le pensez, jetez un ≈ìil √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet exemple</a> .  Il s'agit d'une r√©f√©rence pour une structure de donn√©es de 0,3 Ko que nous transmettons et recevons d'abord par pointeur, puis par valeur.  0,3 Ko est un peu - sur les structures de donn√©es habituelles avec lesquelles nous travaillons quotidiennement occupent √† peu pr√®s autant. <br><br>  Lorsque j'ex√©cute ces tests dans un environnement local, la transmission valeur par valeur est plus de 4 fois plus rapide.  Assez inattendu, non? <br><br>  L'explication de ce r√©sultat est li√©e √† une compr√©hension de la fa√ßon dont la gestion de la m√©moire se produit dans Go.  Je ne peux pas l'expliquer aussi brillamment que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">William Kennedy</a> , mais essayons de r√©sumer en un mot. <br><br>  Une variable peut √™tre plac√©e sur le tas ou la pile: <br><ul><li>  La pile contient les variables actuelles de ce programme.  D√®s que la fonction revient, les variables sont extraites de la pile. </li><li>  Le tas contient des variables communes (variables globales, etc.). </li></ul><br>  Regardons un exemple simple o√π nous retournons une valeur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Ici, la variable de r√©sultat est cr√©√©e par le goroutine actuel.  Cette variable est pouss√©e sur la pile actuelle.  D√®s le retour de la fonction, le client recevra une copie de cette variable.  La variable elle-m√™me est extraite de la pile.  Elle existe toujours en m√©moire jusqu'√† ce qu'une autre variable soit remplac√©e, mais elle n'est plus accessible. <br>  Maintenant le m√™me exemple, mais avec un pointeur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  La variable de r√©sultat est toujours cr√©√©e par le goroutine actuel, mais le client recevra un pointeur (une copie de l'adresse de la variable).  Si la variable de r√©sultat a √©t√© extraite de la pile, le client de cette fonction ne pourra pas y acc√©der. <br><br>  Dans ce sc√©nario, le compilateur Go affichera la variable de r√©sultat l√† o√π les variables peuvent √™tre partag√©es, c'est-√†-dire  en groupe. <br><br>  Un autre script pour passer des pointeurs: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Puisque nous appelons f dans le m√™me programme, la variable p n'a pas besoin d'√™tre empil√©e.  Il est simplement pouss√© sur la pile et une sous-fonction peut y acc√©der. <br><br>  Par exemple, de cette mani√®re, une tranche est obtenue dans la m√©thode Read de io.Reader.  Le retour d'une tranche (qui est un pointeur) la place dans un tas. <br><br>  Pourquoi la pile est-elle si rapide?  Il y a deux raisons: <br><ul><li>  Pas besoin d'utiliser le ramasse-miettes sur la pile.  Comme nous l'avons d√©j√† dit, une variable est simplement pouss√©e apr√®s avoir √©t√© cr√©√©e, puis extraite de la pile lorsque la fonction revient.  Pas besoin de d√©clencher un processus compliqu√© pour renvoyer des variables inutilis√©es, etc. </li><li>  La pile appartient √† une seule goroutine, donc le stockage de la variable n'a pas besoin d'√™tre synchronis√©, comme cela arrive avec le stockage sur le tas, ce qui entra√Æne √©galement une augmentation des performances. </li></ul><br>  En conclusion, lorsque nous cr√©ons une fonction, notre action par d√©faut devrait √™tre d'utiliser des valeurs au lieu de pointeurs.  Un pointeur ne doit √™tre utilis√© que si nous voulons partager une variable. <br><br>  De plus, si nous souffrons de probl√®mes de performances, l'une des optimisations possibles pourrait √™tre de v√©rifier si les pointeurs aident dans des situations sp√©cifiques?  Si le compilateur g√©n√®re une variable dans le tas, vous pouvez le savoir avec la commande suivante: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Mais, encore une fois, pour la plupart de nos t√¢ches quotidiennes, il est pr√©f√©rable d'utiliser des valeurs. <br><br><h3>  Abandon de / commutateur ou de / s√©lection </h3><br>  Que se passe-t-il dans l'exemple suivant si f renvoie vrai? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Nous appelons pause.  Seule cette coupure rompt l'interrupteur, pas la boucle for. <br><br>  M√™me probl√®me ici: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  Break est associ√© √† une instruction select, pas √† une boucle for. <br><br>  Une solution possible pour interrompre pour / changer ou pour / s√©lectionner est d'utiliser une √©tiquette: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Gestion des erreurs </h3><br>  Go est encore jeune, surtout dans le domaine du traitement des erreurs.  Surmonter cette lacune est l'une des innovations les plus attendues de Go 2. <br><br>  La biblioth√®que standard actuelle (ant√©rieure √† Go 1.13) ne propose que des fonctions de construction d'erreurs.  Par cons√©quent, il sera int√©ressant de regarder le paquetage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>pkg / errors</i></a> . <br><br>  Cette biblioth√®que est un bon moyen de suivre une r√®gle qui n'est pas toujours respect√©e: <br><blockquote>  L'erreur ne doit √™tre trait√©e qu'une seule fois.  La journalisation des erreurs est la gestion des erreurs </blockquote>  .  Par cons√©quent, l'erreur doit √™tre enregistr√©e ou lanc√©e plus haut. <br><br>  Dans la biblioth√®que standard actuelle, ce principe est difficile √† observer, car nous pouvons vouloir ajouter du contexte √† l'erreur et avoir une sorte de hi√©rarchie. <br><br>  Regardons un exemple avec un appel REST conduisant √† une erreur de base de donn√©es: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Si nous utilisons pkg / errors, nous pouvons faire ce qui suit: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  L'erreur initiale (si elle n'est pas renvoy√©e par la biblioth√®que externe) peut √™tre cr√©√©e √† l'aide d'erreurs.  La couche interm√©diaire, insert, encapsule cette erreur, en y ajoutant plus de contexte.  Ensuite, le parent l'enregistre.  Ainsi, chaque niveau renvoie ou traite une erreur. <br><br>  Nous pouvons √©galement vouloir rechercher la cause de l'erreur, par exemple, pour rappeler.  Supposons que nous ayons un package db d'une biblioth√®que externe qui a acc√®s √† une base de donn√©es.  Cette biblioth√®que peut renvoyer une erreur temporaire appel√©e db.DBError.  Pour d√©terminer si nous devons r√©essayer, nous devons √©tablir la cause de l'erreur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Cela se fait en utilisant des erreurs.Cause, qui est √©galement incluse dans <i>pkg / errors</i> : <br><br>  L'une des erreurs courantes que j'ai rencontr√©es a √©t√© l'utilisation partielle de <i>pkg / errors</i> .  Une v√©rification d'erreur, par exemple, a √©t√© effectu√©e comme suit: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Dans cet exemple, si db.DBError est encapsul√©, il ne fera jamais un deuxi√®me appel. <br><br><h3>  Initialisation de tranche </h3><br>  Parfois, nous savons quelle sera la longueur finale de la tranche.  Par exemple, supposons que nous voulons convertir une tranche Foo en tranche Bar, ce qui signifie que ces deux tranches auront la m√™me longueur. <br><br>  Je rencontre souvent des tranches initialis√©es de cette fa√ßon: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Slice n'est pas une structure magique.  Sous le capot, il met en ≈ìuvre une strat√©gie pour augmenter la taille s'il n'y a plus d'espace libre.  Dans ce cas, un nouveau tableau est automatiquement cr√©√© (avec une plus grande capacit√©) et tous les √©l√©ments y sont copi√©s. <br><br>  Imaginons maintenant que nous devions r√©p√©ter cette op√©ration d'augmentation de la taille plusieurs fois, car notre [] Foo contient des milliers d'√©l√©ments.  La complexit√© de l'algorithme d'insertion restera O (1), mais en pratique, cela affectera les performances. <br><br>  Par cons√©quent, si nous connaissons la longueur finale, nous pouvons: <br><br><ul><li>  Initialisez-le avec une longueur pr√©d√©finie: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Ou initialisez-le avec une longueur de 0 et une capacit√© pr√©d√©termin√©e: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Quelle est la meilleure option?  Le premier est un peu plus rapide.  Cependant, vous pouvez pr√©f√©rer cette derni√®re, car elle est plus coh√©rente: que nous connaissions ou non la taille initiale, l'ajout d'un √©l√©ment √† la fin de la tranche se fait en utilisant append. <br><br><h3>  Gestion du contexte </h3><br>  context.Context est souvent mal compris par les d√©veloppeurs.  Selon la documentation officielle: <br><blockquote>  Le contexte porte l'√©ch√©ance, le signal d'annulation et d'autres valeurs au-del√† des limites de l'API. <br>  Cette description est assez g√©n√©rale, elle peut donc induire le programmeur en erreur quant √† son utilisation correcte. </blockquote><br>  Essayons de le comprendre.  Le contexte peut porter: <br><ul><li>  Date limite - signifie soit la dur√©e (par exemple, 250 ms) ou la date-heure (par exemple, 2019-01-08 01:00:00), selon laquelle nous pensons que si elle est atteinte, l'action en cours doit √™tre annul√©e (demande d'E / S ), en attente de l'entr√©e du canal, etc.). </li><li>  Annuler le signal (essentiellement &lt;-chan struct {}).  Ici, le comportement est similaire.  D√®s que nous recevons un signal, nous devons arr√™ter le travail en cours.  Par exemple, supposons que nous recevions deux demandes.  L'une pour ins√©rer des donn√©es, l'autre pour annuler la premi√®re demande (car elle n'est plus pertinente, par exemple).  Ceci peut √™tre r√©alis√© en utilisant le contexte annul√© dans le premier appel, qui sera ensuite annul√© d√®s que nous recevrons la deuxi√®me demande. </li><li>  Liste de cl√©s / valeurs (toutes deux bas√©es sur le type d'interface {}). </li></ul><br>  Encore deux points.  Premi√®rement, le contexte est composable.  Par cons√©quent, nous pouvons avoir un contexte qui porte l'√©ch√©ance et la liste cl√© / valeur, par exemple.  De plus, plusieurs goroutines peuvent partager le m√™me contexte, donc un signal d'annulation peut potentiellement arr√™ter plusieurs travaux. <br><br>  Revenant √† notre sujet, voici une erreur que j'ai rencontr√©e. <br><br>  L‚Äôapplication Go √©tait bas√©e sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>urfave / cli</i></a> (si vous ne savez pas, c‚Äôest une bonne biblioth√®que pour cr√©er des applications de ligne de commande dans Go).  Une fois lanc√©, le d√©veloppeur h√©rite d'une sorte de contexte d'application.  Cela signifie que lorsque l'application est arr√™t√©e, la biblioth√®que utilise le contexte pour envoyer un signal d'annulation. <br><br>  J'ai remarqu√© que ce contexte √©tait transmis directement, par exemple, lorsqu'un point de terminaison gRPC √©tait appel√©.  Ce n'est pas du tout ce dont nous avons besoin. <br><br>  Au lieu de cela, nous voulons dire √† la biblioth√®que gRPC: veuillez annuler la demande lorsque l'application est arr√™t√©e, ou apr√®s 100 ms, par exemple. <br><br>  Pour y parvenir, nous pouvons simplement cr√©er un contexte composite.  Si parent est le nom du contexte d'application (cr√©√© par <i>urfave / cli</i> ), alors nous pouvons simplement faire ceci: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Les contextes ne sont pas si difficiles √† comprendre et, √† mon avis, c'est l'une des meilleures caract√©ristiques du langage. <br><br><h3>  Ne pas utiliser l'option -race </h3><br>  Tester une application Go sans l'option -race est un bug que je rencontre constamment. <br><br>  Comme √©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> , bien que Go ait √©t√© ¬´ <i>con√ßu pour rendre la programmation parall√®le plus simple et moins sujette aux erreurs</i> ¬ª, nous souffrons toujours grandement de probl√®mes de concurrence. <br><br>  De toute √©vidence, le d√©tecteur de course Go ne r√©soudra aucun probl√®me.  Cependant, c'est un outil pr√©cieux et nous devons toujours l'inclure lors du test de nos applications. <br><br><h3>  Utilisation du nom de fichier comme entr√©e </h3><br>  Une autre erreur courante consiste √† transmettre le nom de fichier √† une fonction. <br><br>  Supposons que nous devons impl√©menter une fonction pour compter le nombre de lignes vides dans un fichier.  L'impl√©mentation la plus naturelle ressemblerait √† ceci: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Le nom du fichier est d√©fini comme une entr√©e, nous l'ouvrons donc, puis impl√©mentons notre logique, non? <br><br>  Supposons maintenant que nous voulons couvrir cette fonction avec des tests unitaires.  Nous allons tester avec un fichier normal, un fichier vide, un fichier avec un type d'encodage diff√©rent, etc. Cela peut √™tre tr√®s difficile √† g√©rer. <br><br>  De plus, si nous voulons impl√©menter la m√™me logique, par exemple, pour le corps HTTP, nous devrons cr√©er une autre fonction pour cela. <br><br>  Go est livr√© avec deux grandes abstractions: io.Reader et io.Writer.  Au lieu de passer le nom du fichier, nous pouvons simplement passer io.Reader, qui va abstraire la source de donn√©es. <br>  S'agit-il d'un fichier?  Corps HTTP?  Tampon d'octets?  Cela n'a pas d'importance, car nous utiliserons toujours la m√™me m√©thode de lecture. <br><br>  Dans notre cas, nous pouvons m√™me tamponner l'entr√©e pour la lire ligne par ligne.  Pour ce faire, vous pouvez utiliser bufio.Reader et sa m√©thode ReadLine: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  D√©sormais, la responsabilit√© de l'ouverture du fichier a √©t√© d√©l√©gu√©e au client de comptage: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  Dans une deuxi√®me impl√©mentation, une fonction peut √™tre appel√©e quelle que soit la source de donn√©es r√©elle.  En attendant, cela facilitera nos tests unitaires, car nous pouvons simplement cr√©er bufio.Reader √† partir de la ligne: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutines et variables de cycle </h3><br>  La derni√®re erreur commune que j'ai rencontr√©e √©tait lors de l'utilisation de goroutines avec des variables de boucle. <br><br>  Quelle sera la conclusion de l'exemple suivant? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 au hasard?  Non. <br><br>  Dans cet exemple, chaque goroutine utilise la m√™me instance d'une variable, elle affichera donc 3 3 3 (le plus probable). <br><br>  Il existe deux solutions √† ce probl√®me.  La premi√®re consiste √† passer la valeur de la variable i √† la fermeture (fonction interne): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  La seconde consiste √† cr√©er une autre variable dans la boucle for: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Attribuer i: = i peut sembler un peu √©trange, mais cette conception est parfaitement valide.  √ätre dans une boucle signifie √™tre dans une port√©e diff√©rente.  Par cons√©quent, i: = i cr√©e une autre instance de la variable i.  Bien s√ªr, nous pouvons l'appeler avec un nom diff√©rent pour plus de lisibilit√©. <br><br>  <i>Si vous connaissez d'autres erreurs courantes, n'h√©sitez pas √† en parler dans les commentaires.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461051/">https://habr.com/ru/post/fr461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461041/index.html">Arrondi ou √† angle aigu?</a></li>
<li><a href="../fr461043/index.html">La gestion des conflits en √©quipe - un √©quilibre ou une n√©cessit√© vitale?</a></li>
<li><a href="../fr461045/index.html">Obtenez un extrait de Rosreestr via FSIS USRN et python. Partie 1</a></li>
<li><a href="../fr461047/index.html">√âcrire ou ne pas √©crire. Lettres aux autorit√©s lors des √©v√©nements</a></li>
<li><a href="../fr461049/index.html">ONYX BOOX Faust - Celui qui cherche n'est pas oblig√© d'errer</a></li>
<li><a href="../fr461053/index.html">Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 2 - Cartes vectorielles</a></li>
<li><a href="../fr461055/index.html">Rekko Challenge 2019: comment c'√©tait</a></li>
<li><a href="../fr461057/index.html">Cha√Ænes de t√©l√©gramme sur le d√©veloppement de jeux</a></li>
<li><a href="../fr461059/index.html">√âcrire une application Android pour les fans de films - Partie 1 (Prototypage)</a></li>
<li><a href="../fr461061/index.html">Alliages de magn√©sium, fronti√®res jumelles et s√©gr√©gation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>