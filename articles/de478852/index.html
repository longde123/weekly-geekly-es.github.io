<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèΩ üöª ‚û∞ Einf√ºhrung in GitOps f√ºr OpenShift üèåÔ∏è ‚è≥ üë©üèΩ‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir √ºber die Prinzipien und Modelle von GitOps sprechen und wie diese Modelle auf der OpenShift-Plattform implementiert werden. Eine Onli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in GitOps f√ºr OpenShift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/478852/">  Heute werden wir √ºber die Prinzipien und Modelle von GitOps sprechen und wie diese Modelle auf der OpenShift-Plattform implementiert werden.  Eine Online-Anleitung zu diesem Thema finden Sie <a href="https://learn.openshift.com/introduction/gitops-introduction/%3FextIdCarryOver%3Dtrue%26sc_cid%3D701f2000001OH74AAG">hier</a> . <br><br><img src="https://habrastorage.org/webt/sk/g4/vk/skg4vkilbd51gs_dk6vk3-emy2o.jpeg" width="100%"><br><br>  Kurz gesagt, GitOps ist eine Sammlung praktischer Methoden zur Verwendung von Git-Pull-Anforderungen zum Verwalten von Infrastruktur- und Anwendungskonfigurationen.  Das Git-Repository in GitOps wird als eine einzige Informationsquelle √ºber den Systemstatus betrachtet. Alle √Ñnderungen in diesem Status werden vollst√§ndig √ºberwacht und √ºberwacht. <br><a name="habracut"></a><br>  Die Idee der √Ñnderungsnachverfolgung in GitOps ist keineswegs neu, diese Methode wird seit langem fast √ºberall bei der Arbeit mit Anwendungsquellcode verwendet.  GitOps implementiert einfach √§hnliche Funktionen (√úberpr√ºfungen, Pull-Anforderungen, Tags usw.) beim Verwalten von Infrastruktur- und Anwendungskonfigurationen und bietet √§hnliche Vorteile wie im Fall der Quellcodeverwaltung. <br><br>  F√ºr GitOps gibt es keine akademische Definition oder genehmigte Regeln, sondern nur eine Reihe von Grunds√§tzen, auf denen diese Praxis basiert: <br><br><ul><li>  Die deklarative Beschreibung des Systems wird im Git-Repository gespeichert (Konfiguration, √úberwachung usw.). </li><li>  Status√§nderungen werden √ºber Pull-Anforderungen vorgenommen. </li><li>  Der Status laufender Systeme wird mithilfe von Git-Push-Anforderungen mit den Daten im Repository abgeglichen. </li></ul><br><h3>  GitOps-Prinzipien </h3><br><ul><li>  <b>Systemdefinitionen werden als Quellcode beschrieben.</b> </li></ul><br>  Die Systemkonfiguration wird als Code betrachtet, sodass sie im Git-Repository gespeichert und automatisch versioniert werden kann, das als einzige Quelle der Wahrheit dient.  Dieser Ansatz erleichtert das Rollout und Rollback von √Ñnderungen an Systemen. <br><br><ul><li>  <b>Gew√ºnschter Status und Systemkonfiguration werden in Git festgelegt und versioniert</b> </li></ul><br>  Indem wir den gew√ºnschten Status der Systeme in Git speichern und versionieren, erhalten wir die M√∂glichkeit, √Ñnderungen an Systemen und Anwendungen einfach r√ºckg√§ngig zu machen.  Wir k√∂nnen auch die Sicherheitsmechanismen von Git verwenden, um den Besitz von Code zu kontrollieren und dessen Authentizit√§t zu √ºberpr√ºfen. <br><br><ul><li>  <b>Konfigurations√§nderungen k√∂nnen mithilfe von Pull-Anforderungen automatisch angewendet werden.</b> </li></ul><br>  Mithilfe von Git-Pull-Anforderungen k√∂nnen wir einfach steuern, wie √Ñnderungen an Konfigurationen im Repository angewendet werden.  Sie k√∂nnen beispielsweise zur √úberpr√ºfung an andere Teammitglieder gesendet oder CI-Tests usw. durchlaufen werden. <br><br>  Gleichzeitig m√ºssen Sie nicht rechts und links Administratorberechtigungen erteilen.  Zum Festschreiben von Konfigurations√§nderungen verf√ºgen Benutzer √ºber ausreichende Berechtigungen im Git-Repository, in dem diese Konfigurationen gespeichert sind. <br><br><ul><li>  <b>Korrigieren Sie unkontrollierte Drift-Konfigurationen</b> </li></ul><br>  Wenn der gew√ºnschte Status des Systems im Git-Repository gespeichert ist, k√∂nnen wir nur Software finden, die steuert, dass der aktuelle Status des Systems dem gew√ºnschten Status entspricht.  Ist dies nicht der Fall, sollte diese Software - abh√§ngig von den Einstellungen - die Diskrepanz entweder selbst beheben oder uns √ºber die Konfigurationsabweichung informieren. <br><br><h3>  GitOps-Modelle f√ºr OpenShift </h3><br><h4>  On-Cluster Resource Reconciller </h4><br>  Gem√§√ü diesem Modell verf√ºgt der Cluster √ºber einen Controller, der f√ºr den Vergleich von Kubernetes-Ressourcen (YAML-Dateien) im Git-Repository mit realen Cluster-Ressourcen zust√§ndig ist.  Im Falle von Unstimmigkeiten sendet der Controller Benachrichtigungen und ergreift m√∂glicherweise Ma√ünahmen, um Inkonsistenzen zu beseitigen.  Dieses GitOps-Modell wird von Anthos Config Management und Weaveworks Flux verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/c9/p2/lhc9p2tphyarqpe6jrsh10fgo7e.png"></div><br><br><h4>  Externer Ressourcenabgleich (Push) </h4><br>  Dieses Modell kann als Variation des vorherigen angesehen werden, wenn wir einen oder mehrere Controller haben, die f√ºr die paarweise Synchronisierung der Ressourcen verantwortlich sind. ‚ÄúGit-Repository - Kubernetes-Cluster‚Äù.  Der Unterschied besteht darin, dass f√ºr jeden verwalteten Cluster kein separater Controller erforderlich ist.  Git-k8s-Clusterpaare werden h√§ufig als benutzerdefinierte CRDs f√ºr die Ressourcendefinition definiert, die beschreiben, wie der Controller die Synchronisation durchf√ºhren soll.  Innerhalb dieses Modells vergleichen Controller das in CRD angegebene Git-Repository mit den Ressourcen des Kubernetes-Clusters, die ebenfalls in CRD definiert sind, und f√ºhren die entsprechenden Aktionen auf der Grundlage der Ergebnisse des Vergleichs aus.  Insbesondere wird ein solches GitOps-Modell in ArgoCD verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/51/ip/zw51ipo5hqcn8ccnc8vfqkqbc88.png"></div><br><br><h3>  GitOps auf der OpenShift-Plattform </h3><br><h4>  Multicluster Kubernetes Infrastructure Administration </h4><br>  Mit der Verbreitung von Kubernetes und der wachsenden Beliebtheit von Multi-Cloud-Strategien und Edge-Computing ist auch die durchschnittliche Anzahl von OpenShift-Clustern pro Kunde gestiegen. <br><br>  Wenn Sie beispielsweise Peripherieger√§te verwenden, k√∂nnen Cluster eines einzelnen Kunden in Hunderten oder sogar Tausenden bereitgestellt werden.  Infolgedessen muss er mehrere unabh√§ngige oder koordinierte OpenShift-Cluster in der √∂ffentlichen Cloud und vor Ort verwalten. <br><br>  Gleichzeitig m√ºssen viele Probleme gel√∂st werden, insbesondere: <br><br><ul><li>  Um zu kontrollieren, dass sich die Cluster in identischem Zustand befinden (Konfiguration, √úberwachung, Speicherung usw.) </li><li>  Erstellen Sie Cluster gem√§√ü einem bekannten Status neu (oder stellen Sie sie wieder her). </li><li>  Erstellen Sie neue Cluster nach einem bekannten Status. </li><li>  √Ñnderungen in mehreren OpenShift-Clustern √ºbernehmen. </li><li>  Machen Sie √Ñnderungen an mehreren OpenShift-Clustern r√ºckg√§ngig. </li><li>  Verkn√ºpfen Sie gemusterte Konfigurationen mit verschiedenen Umgebungen. </li></ul><br><h4>  Anwendungskonfigurationen </h4><br>  W√§hrend ihres Lebenszyklus durchlaufen Anwendungen h√§ufig eine Reihe von Clustern (dev, stage usw.), bevor sie in einen Produktionscluster gelangen.  Aufgrund der Verf√ºgbarkeits- und Skalierbarkeitsanforderungen stellen Kunden Anwendungen h√§ufig in mehreren lokalen Clustern oder in mehreren Regionen einer √∂ffentlichen Cloud-Plattform bereit. <br><br>  In diesem Fall m√ºssen folgende Aufgaben gel√∂st werden: <br><ul><li>  Stellen Sie sicher, dass Anwendungen (Binaries, Configs usw.) zwischen Clustern (dev, stage usw.) verschoben werden. </li><li>  F√ºhren Sie √Ñnderungen an Anwendungen (Bin√§rdateien, Konfigurationen usw.) in mehreren OpenShift-Clustern aus. </li><li>  Setzen Sie √Ñnderungen in Anwendungen auf die Ebene des vorherigen bekannten Status zur√ºck. </li></ul><br><h3>  OpenShift GitOps-Nutzungsszenarien </h3><br><h4>  1. √úbernehmen Sie die √Ñnderungen aus dem Git-Repository </h4><br>  Der Cluster-Administrator kann die OpenShift-Cluster-Konfigurationen im Git-Repository speichern und automatisch anwenden, um ohne zus√§tzlichen Aufwand neue Cluster zu erstellen und in einen Status zu versetzen, der mit dem im Git-Repository gespeicherten Status identisch ist. <br><br><h4>  2. Mit Secret Manager synchronisieren </h4><br>  Der Administrator wird es auch n√ºtzlich finden, geheime OpenShift-Objekte mit geeigneter Software wie Vault zu synchronisieren, um sie mit speziell daf√ºr erstellten Tools zu verwalten. <br><br><h4>  3. Drift-Konfigurationen steuern </h4><br>  Der Administrator ist nur dann daf√ºr, wenn OpenShift GitOps Abweichungen zwischen den tats√§chlichen und den im Repository angegebenen Konfigurationen erkennt und warnt, sodass Sie schnell auf Abweichungen reagieren k√∂nnen. <br><br><h4>  4. Konfigurationsdrift-Benachrichtigungen </h4><br>  Dies ist praktisch, wenn der Administrator schnell Informationen zu Drift-Konfigurationen erhalten m√∂chte, um selbst schnell geeignete Ma√ünahmen ergreifen zu k√∂nnen. <br><br><h4>  5. Manuelle Synchronisation der Konfigurationen beim Driften </h4><br>  Erm√∂glicht dem Administrator das Synchronisieren des OpenShift-Clusters mit dem Git-Repository im Falle von Drift-Konfigurationen, um den Cluster schnell in einen fr√ºheren bekannten Zustand zu versetzen. <br><br><h4>  6. Automatische Synchronisation von Drift-Konfigurationen </h4><br>  Der Administrator kann das OpenShift-Cluster auch so konfigurieren, dass es automatisch mit dem Repository synchronisiert wird, wenn eine Abweichung festgestellt wird, sodass die Clusterkonfiguration immer mit den Konfigurationen in Git √ºbereinstimmt. <br><br><h4>  7. Mehrere Cluster - Ein Repository </h4><br>  Der Administrator kann Konfigurationen mehrerer verschiedener OpenShift-Cluster in einem Git-Repository speichern und diese nach Bedarf selektiv anwenden. <br><br><h4>  8. Hierarchie der Cluster-Konfigurationen (Vererbung) </h4><br>  Der Administrator kann die Hierarchie der Cluster-Konfigurationen im Repository festlegen (B√ºhne, Produkt, App-Portfolio usw. mit Vererbung).  Mit anderen Worten kann festgelegt werden, wie Konfigurationen angewendet werden sollen - auf einen oder mehrere Cluster. <br><br>  Wenn der Administrator beispielsweise die Hierarchie "Produktionscluster (prod) ‚Üí Cluster von System X ‚Üí Produktionscluster von System X" im Git-Repository definiert, werden die folgenden Konfigurationen auf die Produktionscluster von System X angewendet: <br><br><ul><li>  Konfigurationen, die allen Produktionsclustern gemeinsam sind. </li><li>  Konfigurationen f√ºr das Clustersystem X. </li><li>  Konfigurationen f√ºr den Produktionscluster von System X. </li></ul><br><h4>  9. Muster und Konfigurations√ºberschreibungen </h4><br>  Der Administrator kann die Menge der geerbten Konfigurationen und ihre Werte √ºberschreiben, um beispielsweise die Konfiguration f√ºr bestimmte Cluster, auf die sie angewendet werden, zu optimieren. <br><br><h4>  10. Selektives Einschlie√üen und Ausschlie√üen f√ºr Konfigurationen und Anwendungskonfiguration </h4><br>  Der Administrator kann die Bedingungen f√ºr das Anwenden oder Nichtanwenden bestimmter Konfigurationen auf Cluster mit bestimmten Merkmalen festlegen. <br><br><h4>  11. Musterunterst√ºtzung </h4><br>  Entwickler werden es n√ºtzlich finden, auszuw√§hlen, wie die Anwendungsressourcen bestimmt werden (Helm Chart, reines Kubernetes Yaml usw.), um das am besten geeignete Format f√ºr die jeweilige Anwendung zu verwenden. <br><br><h3>  GitOps-Tools auf der OpenShift-Plattform </h3><br><h4>  Argocd </h4><br>  ArgoCD implementiert das External Resource Reconcile-Modell und bietet eine zentralisierte Benutzeroberfl√§che zum Orchestrieren von Beziehungen zwischen Clustern und Git-Repositorys in einer Eins-zu-Viele-Weise.  Zu den Nachteilen dieses Programms geh√∂rt die Unf√§higkeit, Anwendungen zu verwalten, w√§hrend ArgoCD nicht funktioniert. <br><br>  <a href="https://argoproj.github.io/argo-cd/">Offiziellen Website</a> <br><br><h4>  Flussmittel </h4><br>  Flux implementiert das On-Cluster Resource Reconcile-Modell. Daher gibt es keine zentralisierte Verwaltung des Definitionsrepositorys, was eine Schwachstelle darstellt.  Andererseits bleibt gerade wegen der fehlenden Zentralisierung die F√§higkeit zur Verwaltung von Anwendungen erhalten, selbst wenn ein Cluster ausf√§llt. <br><br>  <a href="https://fluxcd.io/">Offiziellen Website</a> <br><br><h3>  Installieren Sie ArgoCD unter OpenShift </h3><br>  ArgoCD bietet eine hervorragende Befehlszeilenschnittstelle und eine Webkonsole. Daher werden Flux und andere Alternativen hier nicht ber√ºcksichtigt. <br><br>  Gehen Sie wie folgt vor, um ArgoCD auf der OpenShift 4-Plattform bereitzustellen: <br><br><h4>  Bereitstellen von ArgoCD-Komponenten auf der OpenShift-Plattform </h4><br><pre><code class="plaintext hljs"># Create a new namespace for ArgoCD components oc create namespace argocd # Apply the ArgoCD Install Manifest oc -n argocd apply -f https://raw.githubusercontent.com/argoproj/argo-cd/v1.2.2/manifests/install.yaml # Get the ArgoCD Server password ARGOCD_SERVER_PASSWORD=$(oc -n argocd get pod -l "app.kubernetes.io/name=argocd-server" -o jsonpath='{.items[*].metadata.name}')</code> </pre> <br><h4>  Verfeinerung des ArgoCD-Servers f√ºr OpenShift Route </h4><br><pre> <code class="plaintext hljs"># Patch ArgoCD Server so no TLS is configured on the server (--insecure) PATCH='{"spec":{"template":{"spec":{"$setElementOrder/containers":[{"name":"argocd-server"}],"containers":[{"command":["argocd-server","--insecure","--staticassets","/shared/app"],"name":"argocd-server"}]}}}}' oc -n argocd patch deployment argocd-server -p $PATCH # Expose the ArgoCD Server using an Edge OpenShift Route so TLS is used for incoming connections oc -n argocd create route edge argocd-server --service=argocd-server --port=http --insecure-policy=Redirect</code> </pre> <br><h4>  Stellen Sie das ArgoCD Cli Tool bereit </h4><br><pre> <code class="plaintext hljs"># Download the argocd binary, place it under /usr/local/bin and give it execution permissions curl -L https://github.com/argoproj/argo-cd/releases/download/v1.2.2/argocd-linux-amd64 -o /usr/local/bin/argocd chmod +x /usr/local/bin/argocd</code> </pre> <br><h4>  √Ñndern Sie das Administratorkennwort von ArgoCD Server </h4><br><pre> <code class="plaintext hljs"># Get ArgoCD Server Route Hostname ARGOCD_ROUTE=$(oc -n argocd get route argocd-server -o jsonpath='{.spec.host}') # Login with the current admin password argocd --insecure --grpc-web login ${ARGOCD_ROUTE}:443 --username admin --password ${ARGOCD_SERVER_PASSWORD} # Update admin's password argocd --insecure --grpc-web --server ${ARGOCD_ROUTE}:443 account update-password --current-password ${ARGOCD_SERVER_PASSWORD} --new-password</code> </pre> <br>  Nachdem Sie diese Schritte ausgef√ºhrt haben, k√∂nnen Sie mit ArgoCD Server √ºber die ArgoCD WebUI-Webkonsole oder das ArgoCD Cli-Befehlszeilentool arbeiten. <br>  <a href="https://blog.openshift.com/is-it-too-late-to-integrate-gitops/">https://blog.openshift.com/is-it-too-late-to-integrate-gitops/</a> <br><br><h3>  GitOps - Es ist nie zu sp√§t </h3><br>  ‚ÄûDer Zug ist abgereist‚Äú - das sagen sie √ºber die Situation, in der die Gelegenheit, etwas zu tun, verpasst wird.  Im Falle von OpenShift f√ºhrt der Wunsch, sofort mit der Nutzung dieser neuen coolen Plattform zu beginnen, h√§ufig zu einer solchen Situation bei der Verwaltung und Pflege von Routen, Bereitstellungen und anderen OpenShift-Objekten.  Aber wird die Chance immer komplett verpasst? <br><br>  In einer Reihe von Artikeln √ºber <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">GitOps</a> wird heute gezeigt, wie eine manuell erstellte Anwendung und ihre Ressourcen in einen bestimmten Prozess umgewandelt werden, in dem das GitOps-Toolkit alles steuert.  Dazu stellen wir zuerst die httpd-Anwendung mit unseren H√§nden bereit.  Der folgende Screenshot zeigt, wie wir einen Namespace, eine Bereitstellung und einen Dienst erstellen und dann bereitstellen, damit dieser Dienst eine Route erstellt. <br><br><pre> <code class="plaintext hljs">oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/namespace.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/deployment.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/service.yaml oc expose svc/httpd -n simple-app</code> </pre> <br>  Wir haben also eine manuell erstellte Anwendung.  Jetzt muss es unter der Kontrolle von GitOps ohne Verlust der Verf√ºgbarkeit √ºbertragen werden.  Kurz gesagt: <br><br><ul><li>  Erstellen Sie ein Git-Repository f√ºr den Code. </li><li>  Wir exportieren unsere aktuellen Objekte und laden sie in das Git-Repository. </li><li>  W√§hlen Sie das GitOps-Toolkit aus und stellen Sie es bereit. </li><li>  F√ºgen Sie diesem Toolkit unser Repository hinzu. </li><li>  Wir definieren die Anwendung in unserem GitOps-Toolkit. </li><li>  F√ºhren Sie einen Testlauf der Anwendung mit dem GitOps-Toolkit durch. </li><li>  Wir synchronisieren Objekte mit dem GitOps-Toolkit. </li><li>  Wir schalten das Beschneiden und die automatische Synchronisation von Objekten ein. </li></ul><br>  Wie im vorherigen <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">Artikel erw√§hnt</a> , verf√ºgt GitOps √ºber eine einzige Informationsquelle zu allen Objekten in den Kubernetes-Clustern - das Git-Repository.  Des Weiteren gehen wir davon aus, dass Ihre Organisation bereits ein Git-Repository verwendet.  Es kann √∂ffentlich oder privat sein, muss aber Kubernetes Clustern zur Verf√ºgung stehen.  Dies kann das gleiche Repository wie f√ºr Anwendungscode sein oder ein separates Repository, das speziell f√ºr die Bereitstellung erstellt wurde.  Es wird empfohlen, dass Sie strikte Berechtigungen im Repository haben, da geheime Objekte, Routen und andere sicherheitsrelevante Dinge dort gespeichert werden. <br><br>  In unserem Beispiel erstellen wir ein neues √∂ffentliches Repository auf GitHub.  Sie k√∂nnen es benennen, wie Sie m√∂chten, wir verwenden den Namen Blogpost. <br><br>  Wenn die YAML-Dateien der Objekte nicht lokal oder in Git gespeichert wurden, m√ºssen Sie die Bin√§rdateien oc oder kubectl verwenden.  In der Abbildung unten fordern wir YAML f√ºr unseren Namespace, unsere Bereitstellung, unseren Service und unsere Route an.  Davor haben wir das neu erstellte Repository geklont und sind mit dem Befehl cd dorthin gezogen. <br><br><pre> <code class="plaintext hljs">oc get namespace simple-app -o yaml --export &gt; namespace.yaml oc get deployment httpd -o yaml -n simple-app --export &gt; deployment.yaml oc get service httpd -o yaml -n simple-app --export &gt; service.yaml oc get route httpd -o yaml -n simple-app --export &gt; route.yaml</code> </pre> <br>  Korrigieren Sie nun die Datei deployment.yaml, um ein Feld daraus zu entfernen, das von der Argo-CD nicht synchronisiert werden kann. <br><br><pre> <code class="plaintext hljs">sed -i '/\sgeneration: .*/d' deployment.yaml</code> </pre> <br>  Au√üerdem m√ºssen Sie die Route √§ndern.  Wir werden zuerst die mehrzeilige Variable setzen und dann ingress: null durch den Inhalt dieser Variablen ersetzen. <br><br><pre> <code class="plaintext hljs">export ROUTE=" ingress:\\ - conditions:\\ - status: 'True'\\ type: Admitted" sed -i "s/ ingress: null/$ROUTE/g" route.yaml</code> </pre> <br>  Nachdem die Dateien aussortiert wurden, m√ºssen sie im Git-Repository gespeichert werden.  Danach wird dieses Repository zur einzigen Informationsquelle, und manuelle √Ñnderungen an Objekten sollten strengstens untersagt werden. <br><br><pre> <code class="plaintext hljs">git commit -am 'initial commit of objects' git push origin master</code> </pre> <br>  Weiter gehen wir davon aus, dass ArgoCD bereits f√ºr Sie implementiert ist (wie das geht, lesen Sie im vorherigen <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">Beitrag</a> ).  Daher f√ºgen wir der Argo-CD das von uns erstellte Repository hinzu, das den Anwendungscode aus unserem Beispiel enth√§lt.  Stellen Sie einfach sicher, dass Sie das genaue Repository angeben, das Sie zuvor erstellt haben. <br><br><pre> <code class="plaintext hljs">argocd repo add https://github.com/cooktheryan/blogpost</code> </pre> <br>  Erstellen Sie nun die Anwendung.  Die Anwendung legt die Werte so fest, dass das GitOps-Toolkit erkennt, welches Repository und welche Pfade verwendet werden sollen, welche OpenShift-Funktion zum Verwalten von Objekten erforderlich ist, welcher bestimmte Zweig des Repositorys erforderlich ist und ob Ressourcen automatisch synchronisiert werden sollen. <br><br><pre> <code class="plaintext hljs">argocd app create --project default \ --name simple-app --repo https://github.com/cooktheryan/blogpost.git \ --path . --dest-server https://kubernetes.default.svc \ --dest-namespace simple-app --revision master --sync-policy none</code> </pre> <br>  Nachdem die Anwendung auf der Argo-CD angegeben wurde, √ºberpr√ºft dieses Toolkit bereits implementierte Objekte auf √úbereinstimmung mit den Definitionen im Repository.  In unserem Beispiel sind die automatische Synchronisierung und Bereinigung deaktiviert, sodass sich die Elemente noch nicht √§ndern.  Bitte beachten Sie, dass unsere Anwendung auf der Argo CD-Oberfl√§che den Status ‚ÄûNicht synchronisiert‚Äú hat, da ArgoCD kein Label-Label anbringt. <br>  Aus diesem Grund wird die erneute Bereitstellung von Objekten nicht ausgef√ºhrt, wenn die Synchronisierung etwas sp√§ter beginnt. <br><br>  F√ºhren Sie nun einen Testlauf durch, um sicherzustellen, dass unsere Dateien keine Fehler enthalten. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app --dry-run</code> </pre> <br>  Wenn keine Fehler vorliegen, k√∂nnen Sie mit der Synchronisierung fortfahren. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app</code> </pre> <br>  Nachdem Sie den Befehl argocd get f√ºr unsere Anwendung ausgef√ºhrt haben, sollten Sie feststellen, dass sich der Status der Anwendung in Fehlerfrei oder Synchronisiert ge√§ndert hat.  Dies bedeutet, dass alle Ressourcen im Git-Repository jetzt den bereits bereitgestellten Ressourcen entsprechen. <br><br><pre> <code class="plaintext hljs">argocd app get simple-app Name: simple-app Project: default Server: https://kubernetes.default.svc Namespace: simple-app URL: https://argocd-server-route-argocd.apps.example.com/applications/simple-app Repo: https://github.com/cooktheryan/blogpost.git Target: master Path: . Sync Policy: &lt;none&gt; Sync Status: Synced to master (60e1678) Health Status: Healthy ...</code> </pre> <br>  Jetzt k√∂nnen Sie die automatische Synchronisierung und Bereinigung aktivieren, um sicherzustellen, dass nichts manuell erstellt wird und dass die Bereitstellung jedes Mal durchgef√ºhrt wird, wenn das Objekt im Repository erstellt oder aktualisiert wird. <br><br><pre> <code class="plaintext hljs">argocd app set simple-app --sync-policy automated --auto-prune</code> </pre> <br>  Wir haben also erfolgreich eine Anwendung auf die Steuerung von GitOps √ºbertragen, die GitOps anfangs in keiner Weise verwendet hat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478852/">https://habr.com/ru/post/de478852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478840/index.html">Wo beginnt die Schaffung eines Marktplatzes? Teil zwei</a></li>
<li><a href="../de478844/index.html">Angst und Abscheu vor IT</a></li>
<li><a href="../de478846/index.html">Systemd, interaktive Skripte und Timer</a></li>
<li><a href="../de478848/index.html">Die Evolution der digitalen Fotografie</a></li>
<li><a href="../de478850/index.html">CSS Grid Naming</a></li>
<li><a href="../de478854/index.html">Der Kampf der Webserver. Teil 1 - HTTP von der Realit√§t getrennt:</a></li>
<li><a href="../de478856/index.html">SD-WAN - aktuelle Trends und Prognosen f√ºr 2020</a></li>
<li><a href="../de478858/index.html">Vergleichen von Profilierungssitzungen in XHProf Admin</a></li>
<li><a href="../de478862/index.html">Wie ist der Frontend-Test in Yandex.Market aufgebaut und warum lehnen wir w√∂chentliche Releases ab?</a></li>
<li><a href="../de478866/index.html">Meet Space - Neues Produkt von JetBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>