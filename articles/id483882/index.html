<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äóÔ∏è ü•¶ ‚ñ´Ô∏è Pengujian unit dalam arsitektur Clean Swift üçÜ üéûÔ∏è üòØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pembaca! 


 Bukan rahasia lagi bahwa pengujian adalah bagian integral dari pengembangan apa pun. Pada artikel sebelumnya, kami melihat arsitektu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian unit dalam arsitektur Clean Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483882/"><p>  Halo pembaca! </p><br><p>  Bukan rahasia lagi bahwa pengujian adalah bagian integral dari pengembangan apa pun.  Pada artikel sebelumnya, kami melihat arsitektur dasar dari arsitektur <strong>Swift Bersih</strong> , dan sekarang saatnya untuk belajar bagaimana menutupi <strong>Unitnya dengan</strong> tes.  Kami akan mengambil proyek dari artikel tentang <strong>Pekerja sebagai dasar</strong> dan menganalisis poin utama. </p><br><p><img src="https://habrastorage.org/webt/go/5w/bl/go5wblfd9u-psfnut7x-fgwv7mk.jpeg"></p><a name="habracut"></a><br><h2 id="teoriya">  Teori </h2><br><p> Berkat <strong>injeksi ketergantungan</strong> dan <strong>berorientasi protokol</strong> , semua komponen adegan dalam <strong>Bersihkan Swift saling</strong> independen dan dapat diuji secara terpisah.  Sebagai contoh, <strong>Interactor</strong> bergantung pada <strong>Presenter</strong> dan <strong>Worker</strong> , tetapi dependensi ini bersifat opsional dan berbasis protokol.  Dengan demikian, <strong>Interactor</strong> dapat melakukan pekerjaannya (meskipun lebih rendah) tanpa <strong>Presenter'a</strong> dan <strong>Worker'a</strong> , dan kami juga dapat menggantinya dengan objek lain yang ditandatangani di bawah protokol mereka. </p><br><p>  Karena kami ingin menguji setiap komponen secara terpisah, kami perlu mengganti dependensi dengan <strong>komponen semu</strong> .  Ini akan membantu kami menjadi mata-mata (Mata-mata).  <strong>Mata</strong> - <strong>mata</strong> adalah benda uji yang mengimplementasikan protokol yang ingin kita masukkan dan lacak panggilan metode di dalamnya.  Dengan kata lain, kami membuat <strong>Spy</strong> for <strong>Presenter</strong> dan <strong>Worker</strong> , dan kemudian menyuntikkannya ke <strong>Interactor</strong> untuk melacak panggilan metode. </p><br><p><img src="https://habrastorage.org/webt/gf/t0/ka/gft0kanj4wecq7blljg90_s1ss8.jpeg"></p><br><p>  Dalam keadilan, saya akan menambahkan bahwa ada juga objek uji ( <strong>Uji Ganda</strong> ) <strong>Dummy</strong> , <strong>Fake</strong> , <strong>Stub</strong> and <strong>Mock</strong> .  Namun dalam kerangka artikel ini, kami tidak akan memengaruhi mereka.  Baca lebih lanjut di sini - <a href="https://martinfowler.com/bliki/TestDouble.html">TestDoubles</a> </p><br><h2 id="praktika">  Berlatih </h2><br><p>  Selesai dengan kata-kata, mari kita mulai bisnis.  Untuk menghemat waktu Anda, kami akan mempertimbangkan kode abstrak tanpa merinci implementasi dari setiap metode.  <a href="https://github.com/AlekseyPleshkov/CleanSwift/tree/master/Examples/CleanSwiftTests">Rincian</a> kode aplikasi dapat ditemukan di sini: <a href="https://github.com/AlekseyPleshkov/CleanSwift/tree/master/Examples/CleanSwiftTests">CleanSwiftTests</a> </p><br><p>  Untuk setiap komponen adegan, kami membuat file dengan tes dan uji ganda untuk dependensi komponen ( <strong>Uji Ganda</strong> ). </p><br><p>  Contoh struktur seperti itu: </p><br><p><img src="https://habrastorage.org/webt/f-/e2/v5/f-e2v59mhhgomcpfi_k_ymxhwx4.png"></p><br><p>  Struktur setiap file tes (untuk komponen) terlihat sama dan mengikuti kira-kira urutan penulisan berikut: </p><br><ul><li>  Kami mendeklarasikan variabel dengan <strong>SUT</strong> (objek yang akan kami uji) dan variabel dengan dependensi utamanya </li><li>  Kami menginisialisasi <strong>SUT</strong> dan dependensinya di <strong>setUp ()</strong> , lalu menghapusnya di <strong>tearDown ()</strong> </li><li>  Metode pengujian </li></ul><br><p>  Seperti yang kita bahas dalam teori, setiap komponen adegan dapat diuji secara terpisah.  Kami dapat menyuntikkan duplikat uji ( <strong>Spy</strong> ) ke dalam dependensinya dan dengan demikian memantau pengoperasian metode <strong>SUT</strong> kami.  Mari kita melihat lebih dekat pada proses penulisan tes menggunakan contoh <strong>Interactor</strong> dari adegan <strong>Home</strong> . </p><br><p>  <strong>HomeInteractor</strong> bergantung pada dua objek - <strong>Presenter</strong> dan <strong>Worker</strong> .  Kedua variabel di kelas memiliki tipe protokol.  Ini berarti bahwa kita dapat membuat duplikat uji yang ditandatangani di bawah <strong>protokol HomePresentationLogic</strong> dan <strong>HomeWorkingLogic</strong> , dan kemudian menyuntikkannya ke <strong>HomeInteractor</strong> . </p><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeBusinessLogic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeDataStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MARK: - Public Properties var presenter: HomePresentationLogic? lazy var worker: HomeWorkingLogic = HomeWorker() var users: [User] = [] var selectedUser: User? // MARK: - HomeBusinessLogic func fetchUsers(_ request: HomeModels.FetchUsers.Request) { // ... } func selectUser(_ request: HomeModels.SelectUser.Request) { // ... }</span></span></code> </pre> <br><p>  Kami akan menguji dua metode: </p><br><ul><li>  <strong>fetchUsers (:)</strong> .  Bertanggung jawab untuk mendapatkan daftar pengguna dengan <strong>API</strong> .  Permintaan <strong>API</strong> dikirim menggunakan <strong>Pekerja</strong> . </li><li>  <strong>selectUser (:)</strong> .  Bertanggung jawab untuk memilih pengguna aktif (Pengguna <strong>terpilih</strong> ) dari daftar pengguna yang dimuat ( <strong>pengguna</strong> ). </li></ul><br><p>  Untuk mulai menulis tes <strong>Interactor</strong> , kita perlu membuat mata-mata yang akan melacak permohonan metode di <strong>HomePresentationLogic</strong> dan <strong>HomeWorkingLogic</strong> .  Untuk melakukan ini, buat kelas <strong>HomePresentationLogicSpy</strong> di direktori 'CleanSwiftTestsTests / Stores / Home / TestDoubles / Spies', tanda tangani protokol <strong>HomePresentationLogic</strong> dan terapkan metode protokol ini. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomePresentationLogicSpy</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomePresentationLogic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MARK: - Public Properties private(set) var isCalledPresentFetchedUsers = false // MARK: - Public Methods func presentFetchedUsers(_ response: HomeModels.FetchUsers.Response) { isCalledPresentFetchedUsers = true } }</span></span></code> </pre> <br><p>  Semuanya sangat transparan di sini.  Jika metode <strong>presentFetchedUsers</strong> ( <strong>HomePresentationLogic</strong> ) dipanggil, kami menetapkan nilai variabel <strong>isCalledPresentFetchedUsers</strong> menjadi <strong>true</strong> .  Dengan demikian, kita dapat melacak apakah metode ini dipanggil selama pengujian <strong>Interactor</strong> . </p><br><p>  <strong>Dengan menggunakan</strong> prinsip yang sama, buat <strong>HomeWorkingLogicSpy</strong> .  Satu perbedaan, kami sebut <strong>selesai</strong> , karena  bagian dari kode di <strong>Interactor</strong> akan dibungkus dengan penutupan metode ini.  Metode <strong>HomeWorkingLogic menangani</strong> permintaan jaringan.  Kita perlu menghindari permintaan jaringan nyata selama pengujian.  Untuk melakukan ini, kami menggantinya dengan uji coba, yang melacak panggilan metode dan mengembalikan data templat, tetapi tidak membuat permintaan apa pun ke jaringan. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeWorkingLogicSpy</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeWorkingLogic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MARK: - Public Properties private(set) var isCalledFetchUsers = false let users: [User] = [ User(id: 1, name: "Ivan", username: "ivan91"), User(id: 2, name: "Igor", username: "igor_test") ] // MARK: - Public Methods func fetchUsers(_ completion: @escaping ([User]?) -&gt; Void) { isCalledFetchUsers = true completion(users) } }</span></span></code> </pre> <br><p>  Selanjutnya, kita membuat kelas <strong>HomeInteractorTests</strong> , yang dengannya kita akan menguji <strong>HomeInteractor</strong> . </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeInteractorTests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XCTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MARK: - Private Properties private var sut: HomeInteractor! private var worker: HomeWorkingLogicSpy! private var presenter: HomePresentationLogicSpy! // MARK: - Lifecycle override func setUp() { super.setUp() let homeInteractor = HomeInteractor() let homeWorker = HomeWorkingLogicSpy() let homePresenter = HomePresentationLogicSpy() homeInteractor.worker = homeWorker homeInteractor.presenter = homePresenter sut = homeInteractor worker = homeWorker presenter = homePresenter } override func tearDown() { sut = nil worker = nil presenter = nil super.tearDown() } // MARK: - Public Methods func testFetchUsers() { // ... } func testSelectUser() { // ... } }</span></span></code> </pre> <br><p>  Kami menunjukkan tiga variabel utama - <strong>sut</strong> , <strong>pekerja</strong> dan <strong>presenter</strong> . </p><br><p>  Di <strong>setUp (),</strong> inisialisasi objek yang diperlukan, menyuntikkan dependensi di <strong>Interactor,</strong> dan menetapkan objek ke variabel kelas. <br>  Di <strong>tearDown (),</strong> kami menghapus variabel kelas untuk kemurnian percobaan. </p><br><p>  Metode <strong>setUp ()</strong> dipanggil sebelum metode pengujian dimulai, misalnya <strong>testFetchUsers ()</strong> , dan <strong>tearDown ()</strong> ketika metode ini telah menyelesaikan pekerjaannya.  Dengan demikian, kami membuat ulang objek uji ( <strong>sut</strong> ) sebelum setiap metode pengujian dijalankan. </p><br><p>  Selanjutnya adalah metode pengujian sendiri.  Struktur ini dibagi menjadi 3 blok logis utama - pembuatan objek yang diperlukan, peluncuran metode yang diuji dalam <strong>SUT</strong> dan verifikasi hasil.  Dalam contoh di bawah ini, kami membuat permintaan (dalam kasus kami, tidak memiliki parameter), jalankan <strong>fetchUsers (:)</strong> Metode <strong>Interactor'a</strong> , dan kemudian periksa apakah metode yang diperlukan telah dipanggil di <strong>HomeWorkingLogicSpy</strong> dan <strong>HomePresentationLogicSpy</strong> .  Kami juga memeriksa apakah <strong>Interactor</strong> telah menyimpan data uji yang diterima dari <strong>Pekerja</strong> ke <strong>DataStore</strong> - <strong>nya</strong> . </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFetchUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">HomeModels</span></span>.<span class="hljs-type"><span class="hljs-type">FetchUsers</span></span>.<span class="hljs-type"><span class="hljs-type">Request</span></span>() sut.fetchUsers(request) <span class="hljs-type"><span class="hljs-type">XCTAssertTrue</span></span>(worker.isCalledFetchUsers, <span class="hljs-string"><span class="hljs-string">"Not started worker.fetchUsers(:)"</span></span>) <span class="hljs-type"><span class="hljs-type">XCTAssertTrue</span></span>(presenter.isCalledPresentFetchedUsers, <span class="hljs-string"><span class="hljs-string">"Not started presenter.presentFetchedUsers(:)"</span></span>) <span class="hljs-type"><span class="hljs-type">XCTAssertEqual</span></span>(sut.users.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, worker.users.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) }</code> </pre> <br><p>  Kami akan menguji pilihan pengguna dengan struktur serupa.  Kami mendeklarasikan variabel <strong>expectationId</strong> dan <strong>expectationName</strong> , dimana kami akan membandingkan hasil pemilihan pengguna.  Variabel <strong>pengguna</strong> menyimpan daftar uji pengguna yang kami tetapkan untuk <strong>Interactor</strong> .  Karena  metode pengujian disebut secara independen satu sama lain, dan di <strong>tearDown ()</strong> kita nol data, maka daftar pengguna <strong>Interactor</strong> kosong dan kita perlu mengisinya dengan sesuatu.  Dan kemudian kami memeriksa apakah pengguna ditugaskan di <strong>DataStore</strong> <strong>Interactor'a</strong> , setelah memanggil <strong>sut.selectUser (:)</strong> , dan apakah pengguna itu yang benar. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSelectUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expectationId = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expectationName = <span class="hljs-string"><span class="hljs-string">"Vasya"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> users = [ <span class="hljs-type"><span class="hljs-type">User</span></span>(id: <span class="hljs-number"><span class="hljs-number">1</span></span>, name: <span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"ivan"</span></span>), <span class="hljs-type"><span class="hljs-type">User</span></span>(id: <span class="hljs-number"><span class="hljs-number">2</span></span>, name: <span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"vasya91"</span></span>), <span class="hljs-type"><span class="hljs-type">User</span></span>(id: <span class="hljs-number"><span class="hljs-number">3</span></span>, name: <span class="hljs-string"><span class="hljs-string">"Maria"</span></span>, username: <span class="hljs-string"><span class="hljs-string">"maria_love"</span></span>) ] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">HomeModels</span></span>.<span class="hljs-type"><span class="hljs-type">SelectUser</span></span>.<span class="hljs-type"><span class="hljs-type">Request</span></span>(index: <span class="hljs-number"><span class="hljs-number">1</span></span>) sut.users = users sut.selectUser(request) <span class="hljs-type"><span class="hljs-type">XCTAssertNotNil</span></span>(sut.selectedUser, <span class="hljs-string"><span class="hljs-string">"User not selected"</span></span>) <span class="hljs-type"><span class="hljs-type">XCTAssertEqual</span></span>(sut.selectedUser?.id, expectationId) <span class="hljs-type"><span class="hljs-type">XCTAssertEqual</span></span>(sut.selectedUser?.name, expectationName) }</code> </pre> <br><p>  Pengujian <strong>Presenter'a</strong> dan <strong>ViewController'a</strong> terjadi pada prinsip yang sama, dengan perbedaan minimal.  Salah satu perbedaannya adalah bahwa untuk menguji <strong>ViewController, Anda</strong> harus membuat <strong>UIWindow</strong> dan mendapatkan pengontrol dari <strong>Storyboard</strong> di <strong>setUp ()</strong> , serta membuat objek <strong>Spy</strong> pada tabel dan koleksi.  Namun nuansa ini berbeda dari kebutuhan. </p><br><p>  Untuk kelengkapan, saya sarankan Anda membiasakan diri dengan proyek dengan tautan di akhir artikel. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Kami telah membahas prinsip-prinsip dasar aplikasi pengujian pada arsitektur <strong>Swift Bersih</strong> .  Itu tidak memiliki perbedaan kuat secara fundamental dari proyek pengujian pada arsitektur lain, semua tes yang sama berlipat ganda, injeksi dan protokol.  Hal utama adalah jangan lupa bahwa setiap siklus <strong>VIP</strong> harus memiliki satu (dan hanya satu!) Tanggung jawab.  Ini akan membuat kode lebih bersih dan tes lebih jelas. </p><br><p>  Tautan ke proyek: <a href="https://github.com/AlekseyPleshkov/CleanSwift/tree/master/Examples/CleanSwiftTests">CleanSwiftTests</a> <br>  Bantuan dalam menulis artikel: <a href="https://habr.com/ru/users/bastien/" class="user_link">Bastien</a> </p><br><h2 id="seriya-statey">  Seri artikel </h2><br><ol><li>  <a href="https://habr.com/ru/post/453986/">Tinjauan Arsitektur Swift Bersih</a> </li><li>  <a href="https://habr.com/ru/post/454032/">Router dan Passing Data dalam Arsitektur Swift Bersih</a> </li><li>  <a href="https://habr.com/ru/post/465991/">Pekerja dalam Arsitektur Swift Bersih</a> </li><li>  Unit testing dalam arsitektur Clean Swift (Anda ada di sini) </li><li>  Contoh arsitektur toko online sederhana Clean Swift </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483882/">https://habr.com/ru/post/id483882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483864/index.html">Lebih cepat dari C ++; lebih lambat dari php</a></li>
<li><a href="../id483872/index.html">Pola di jendela atau momok pengendara: bagaimana es dua dimensi tumbuh</a></li>
<li><a href="../id483874/index.html">Publikasi kode VVVVVV menunjukkan betapa tidak sopannya permainan yang ada di dalamnya</a></li>
<li><a href="../id483876/index.html">Budaya perusahaan merah adalah masalah utama bisnis Rusia (Bagian 1)</a></li>
<li><a href="../id483880/index.html">Bagaimana pemrograman hari ini berbeda dari pemrograman 20 tahun yang lalu?</a></li>
<li><a href="../id483886/index.html">Set-top box Movix Pro: dari perangkat lunak hingga kacang terakhir</a></li>
<li><a href="../id483888/index.html">Menjalankan program file tunggal di Java 11 tanpa kompilasi</a></li>
<li><a href="../id483894/index.html">Pertemuan Avito Kafka: konektor, integrasi, awan</a></li>
<li><a href="../id483896/index.html">Cara meluncurkan produk sendiri jika Anda seorang pengembang: Kiat dari pencipta Laravel Taylor Otvel. Bagian 2: Menemukan Ide</a></li>
<li><a href="../id483898/index.html">Documents sebagai kode yang menentang atau bersama dengan Confluence? Gambaran umum dari beberapa cara untuk menerbitkan dari repositori ke Confluence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>