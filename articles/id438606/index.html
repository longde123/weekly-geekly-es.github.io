<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏻 🖖🏼 😜 Degradasi anggun. Laporkan Yandex.Taxi 🐀 🤢 👨🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Layanan harus ditulis agar fungsi minimal selalu dipertahankan - bahkan jika komponen penting gagal. Ilya Sidorov, kepala salah satu tim pengembangan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Degradasi anggun. Laporkan Yandex.Taxi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/438606/">  Layanan harus ditulis agar fungsi minimal selalu dipertahankan - bahkan jika komponen penting gagal.  Ilya Sidorov, kepala salah satu tim pengembangan produk backend Yandex.Taxi, menjelaskan dalam laporannya bagaimana kami membiarkan pengguna memesan mobil ketika bagian-bagian tertentu dari sistem tidak berfungsi, dan dengan logika apa kami mengaktifkan versi layanan yang disederhanakan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AGg6jQ8c7a8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  Penting untuk menulis tidak hanya layanan yang bekerja dengan baik, tetapi juga layanan yang berhasil dengan baik. </blockquote><a name="habracut"></a><br>  "Aku sangat senang melihat kalian semua."  Hari ini saya akan berbicara tentang degradasi yang anggun.  Jika Anda mencarinya di Yandex, kemungkinan besar Anda akan belajar cara membuat situs Anda berfungsi tanpa JS.  Saya akan ceritakan sedikit tentang hal lain.  Tentang degradasi anggun dalam kaitannya dengan backend. <br><br><img src="https://habrastorage.org/webt/iq/jt/d_/iqjtd_bdklo3pamg3m24l8vuroi.jpeg"><br><br>  Mari kita mulai dengan definisi.  Seperti apa kenyataannya? <br><br><img src="https://habrastorage.org/webt/_p/xv/ze/_pxvzecaz6chduqig03o3xcxnsq.jpeg"><br><br>  Di sinilah aplikasi Yandex.Taxi kami disajikan jika salah satu layanan tidak berfungsi - layanan untuk memilih tujuan di mana pengemudi harus membawa Anda.  Seperti yang Anda lihat, pada layar ini tidak ada tombol besar "Pesan taksi", yang berarti bahwa pengguna tidak akan dapat menggunakan layanan ini.  Tetapi Anda dapat mencoba menurunkan dan memungkinkan pengguna untuk tidak memilih titik B. <br><br>  Maka dia tidak akan dapat mengetahui harga pasti dari perjalanan, kita tidak akan dapat membangun rute, tetapi pengguna akan memiliki tombol "Pesan taksi" dan dia akan dapat menggunakan layanan kami.  Fungsi utama aplikasi kita akan tersedia.  Itulah yang ingin saya bicarakan hari ini.  Tentang cara mendegradasi dengan benar dan apa yang dapat dilakukan dengan layanan yang rusak. <br><br>  Rencana kinerja.  Saya akan memberi tahu Anda cara menurunkan apa yang harus dilakukan dengan layanan.  Anda dapat mematikannya, dan juga menggunakan perilaku yang berbeda.  Maka saya akan memberi tahu Anda cara memahami kapan saatnya mematikan layanan kami.  Dan pada akhirnya saya akan berbicara tentang beberapa nuansa yang harus kami hadapi ketika kami membuat sistem degradasi otomatis untuk Yandex.Taxi. <br><br>  Apa yang bisa dilakukan dengan layanan yang rusak?  Anda dapat mematikan fungsionalitas.  Jika layanan untuk memprediksi tujuan individu tidak berfungsi, maka Anda mematikan layanan ini.  Jika obrolan antara pengemudi dan penumpang tidak berfungsi, maka Anda mematikan obrolan.  Jika Anda tidak dapat memesan mobil, maka Anda mematikan tombol "Pesan mobil" - oh, tidak, itu tidak berfungsi.  Tidak semua fungsi dapat dimatikan.  Dan jika Anda tidak dapat mematikan sesuatu, maka Anda perlu menggunakan pendekatan yang berbeda.  Misalnya, Anda dapat mencoba membuat tata letak atau fungsionalitas yang disederhanakan.  Kami menyebut perilaku yang disederhanakan di Yandex sebagai labu - kami mengatakan bahwa layanan tersebut telah berubah menjadi labu. <br><br>  Mari kita pertimbangkan solusi ini secara lebih rinci. <br><br><img src="https://habrastorage.org/webt/kx/ax/6y/kxax6y_rsi3jmftoafoauxjbh1s.jpeg"><br><br>  Bagaimana cara menonaktifkan layanan?  Anda mungkin dapat membuat arsitektur yang tepat.  Misalkan kita memiliki satu layanan monolitik.  Jika salah satu bagiannya gagal, maka seluruh layanan rusak.  Tetapi jika kita membagi layanan menjadi beberapa bagian sehingga pelanggan menggunakan layanan yang berbeda untuk permintaan yang berbeda, itu akan menjadi jauh lebih baik. <br><br>  Bagaimana ini akan bekerja pada contoh?  Ada layanan Yandex.Taxi, di mana ada dua fungsi utama: memesan taksi dan mengobrol dengan pengemudi.  Selama kita memiliki satu backend monolitik, jika obrolan dengan pengemudi gagal, fungsi dasar memesan taksi akan terpengaruh. <br><br><img src="https://habrastorage.org/webt/mj/_x/i0/mj_xi0omqlaxn2ex1enlh-oiapi.jpeg"><br><br><img src="https://habrastorage.org/webt/mr/ca/ru/mrcaruv0giuwducafpjjdzoih_g.jpeg"><br><br>  Apa yang bisa Anda coba lakukan?  Bagilah layanan monolitik menjadi dua bagian.  Satu bagian akan bertanggung jawab untuk memesan taksi, dan yang lainnya - untuk komunikasi dengan pengemudi. <br><br>  Sekarang semuanya terlihat jauh lebih baik.  Jika obrolan dengan sopir rusak, maka semua yang lain terus berfungsi dengan benar. <br><br><img src="https://habrastorage.org/webt/hl/5q/oc/hl5qocwpwgfjq9kfoz8ytpp026c.jpeg"><br><br>  Seperti yang Anda lihat, klien menggunakan API yang berbeda, permintaan yang berbeda untuk melakukan pemesanan dan berkomunikasi dengan pengemudi. <br><br>  Tetapi pada kenyataannya, tampaknya sekarang semuanya tidak begitu baik, karena ada koneksi palsu antara layanan obrolan dan layanan pesanan.  Dan mungkin ternyata layanan pesanan menggunakan layanan obrolan kosong.  Dalam hal ini, fungsi utama tidak akan berfungsi. <br><br><img src="https://habrastorage.org/webt/qb/qo/sm/qbqosmna7oy3tpgm1furclwvhve.jpeg"><br><br>  Dan dalam hal ini, semuanya jauh lebih baik.  Komunikasi palsu telah menghilang, dan sekarang layanan kami benar-benar independen satu sama lain.  Jadi, jika layanan obrolan mogok, Anda masih bisa naik taksi. <br><br>  Kesimpulan dari ini adalah sebagai berikut: jika Anda ingin menurunkan menggunakan pemisahan layanan, sangat penting untuk membuat layanan independen satu sama lain.  Ini berarti bahwa mereka harus memiliki titik masuk yang berbeda, titik akhir yang berbeda.  Mereka harus memiliki runtimes yang berbeda.  Dan tentu saja, mereka harus menggunakan basis data yang berbeda.  Jika tidak, satu layanan rusak dapat menghancurkan semua layanan lainnya di sepanjang rantai. <br><br><img src="https://habrastorage.org/webt/dv/5g/6w/dv5g6wvfqd4bslnt_gtuq98fp0c.jpeg"><br><br>  Yah, kami telah menemukan cara menonaktifkan fungsionalitas.  Sekarang mari kita lihat bagaimana membuat fungsionalitas default, cara membuat labu.  Di layar ini, layanan prediksi tujuan kami.  Layanan ini menggunakan AI pintar untuk memprediksi pengguna tujuan terbaik baginya saat ini.  Dan jika AI sudah lelah, maka kami menggunakan perilaku default dan menawarkan pengguna untuk meninggalkan Moskow. <br><br>  Mari kita lihat bagaimana ini bekerja dalam praktiknya. <br><br><img src="https://habrastorage.org/webt/rl/mn/ns/rlmnnsuc1yuabspgykb7gbp66g0.jpeg"><br><br>  Kami memiliki klien, ia menghubungi layanan tujuan dan mendapatkan kesalahan. <br><br><img src="https://habrastorage.org/webt/n2/xz/ss/n2xzsswp3s3f3hqyli4itiwalrg.jpeg"><br><br>  Sekarang ada dua situasi yang mungkin.  Situasi pertama, jika kegagalan itu tunggal, hanya satu permintaan yang gagal.  Dalam hal ini, kami hanya melakukan kesalahan kepada klien, ia akan membuat permintaan ulang dan mendapatkan tujuan favoritnya. <br><br>  Tetapi jika kegagalannya masif, kami menghidupkan labu dan pengguna mendapatkan perilaku default. <br><br><img src="https://habrastorage.org/webt/aa/cc/wg/aaccwgxqymnx_tv_bx7wecp280a.jpeg"><br><br>  Tapi perilaku keras seperti itu jauh lebih mudah untuk diterapkan, dan labu ini sangat andal, sehingga memungkinkan kita untuk bekerja bahkan ketika AI gagal.  Jika kita tahu bahwa pengguna sering melakukan perjalanan ke bandara, maka kita tidak akan melihat penurunan signifikan dalam kehidupan pengguna. <br><br><img src="https://habrastorage.org/webt/8b/ba/ub/8bbaubspczecbmr19soymzichkw.jpeg"><br><br>  Sekalipun mode degradasi dihidupkan, labu dihidupkan, tetapi pengguna menghubungi layanan dan menerima respons yang berhasil, maka kami menggunakan jawaban ini, bukan labu.  Dan perilaku ini - ketika dalam kasus jawaban kita menggunakannya, dan dalam kasus kesalahan kita menggunakan labu - kita sebut mode fallback. <br><br><img src="https://habrastorage.org/webt/xh/be/d_/xhbed_whpaswh3kcm266bb3nvgu.jpeg"><br><br>  Tidak ada kesalahan - respons yang berhasil.  Ada kesalahan - labu.  Kami mengatakan bahwa mundur telah dihidupkan. <br><br>  Saya memilah apa yang bisa dilakukan dengan layanan yang rusak.  Anda dapat mematikannya, atau menghidupkan labu.  Sekarang mari kita beralih ke bagian kedua dan melihat bagaimana cara mendiagnosis. <br><br>  Kami memiliki dua pertanyaan besar yang perlu dijawab.  Yang pertama adalah ketika Anda harus mematikan layanan dan menyalakan labu.  Yang kedua adalah ketika Anda harus mematikan labu dan menyalakan layanan kembali.  Sebelum kita dapat menjawab pertanyaan-pertanyaan ini, kita perlu mengklarifikasi satu hal. <br><br><img src="https://habrastorage.org/webt/oa/v-/aj/oav-ajs4vulerqj0l-kejssr3os.jpeg"><br><br>  Dalam sistem kompleks yang berinteraksi dengan sejumlah besar agen, selalu ada beberapa latar belakang kesalahan.  Pada slide ini kita melihat jadwal panggilan nyata ke salah satu layanan kami.  Beberapa ribu RPS melakukannya, kami mendapatkan sedikit kesalahan kurang dari 1%.  Ini adalah skala logaritmik. <br><br>  Kesalahan bisa disebabkan oleh berbagai hal.  Mungkin ini adalah semacam proses internal, memperbarui semacam database atau hanya proses latar belakang.  Mungkin pelanggan pergi dengan permintaan yang salah, tetapi faktanya tetap: kami akan selalu memiliki latar belakang kesalahan.  Mari kita ambil dan lanjutkan. <br><br><img src="https://habrastorage.org/webt/zt/5x/af/zt5xafqrsvrpgh7btzw3wquwhz0.jpeg"><br><br>  Jadi, kami menggunakan solusi berdasarkan statistik.  Kami memiliki basis data khusus tempat kami menyimpan statistik, menyimpan jumlah kueri yang berhasil, jumlah kueri dengan kesalahan, dan kueri yang menyertakan fallback.  Kami mengambil dan mengumpulkan statistik pada layanan kami selama periode waktu tertentu dengan jendela geser.  Ketika proporsi permintaan dengan kesalahan di jendela geser ini melebihi ambang tertentu, kami mengaktifkan fallback.  Dan ketika jumlah kesalahan menjadi kurang dari ambang, maka kita matikan. <br><br>  Perhatikan area yang dipilih.  Pada 19:01 kesalahan pertama mulai muncul, tetapi sejauh ini bagian mereka cukup kecil, dan sampai 19:02 kami tidak termasuk fallback.  Pada pukul 19:02 ambang batas terlampaui, kami mengaktifkan fallback.  Pada 19:08 proses sebaliknya: kesalahan berakhir, tetapi untuk beberapa waktu kami telah mundur diaktifkan, karena ambang batas masih terlampaui di jendela geser kami.  Pada 19:09 kami mematikan fallback. <br><br>  Kami tahu kapan harus mematikan layanan.  Penting untuk menjawab pertanyaan kedua: kapan harus menyalakannya.  Sederhana: kami menggunakan solusi yang sama berdasarkan statistik. <br><br><img src="https://habrastorage.org/webt/cf/6i/_g/cf6i_gshfqjz-f-_ozsm-5dschc.jpeg"><br><br>  Penting bahwa kita tidak menghapus beban dari layanan, bahkan jika kita mengaktifkan mode degradasi.  Inilah yang memungkinkan kami untuk terus menerima statistik bahkan jika kami menunjukkan kepada pengguna labu.  Dengan demikian, kita dapat menentukan bahwa kesalahan sudah selesai, layanan diperbaiki.  Jadi, Anda dapat mengaktifkannya kembali hingga penuh. <br><br><img src="https://habrastorage.org/webt/_y/oy/40/_yoy405yondy4eeajs-w9izowsk.jpeg"><br><br>  Ketika kita berbicara tentang degradasi, kita tidak bisa mengatakan tentang pemantauan.  Pemantauan yang baik adalah separuh keberhasilan, separuh jalan ke shutdown otomatis atau degradasi otomatis.  Penting bagi kita untuk memahami masalah apa yang terjadi dengan layanan kita, apa sifat kesalahan itu dan seberapa sering mereka terjadi.  Dan mungkin pada tahap pertama kita bahkan tidak memerlukan pemutus sirkuit.  Sederhananya, jika lampu pemantauan menyala, kita dapat menghidupkan dan mematikan layanan secara manual.  Ketika lampu pemantauan padam, kami menghidupkan layanan. <br><br>  Jika kita melakukan degradasi otomatis, saklar otomatis, maka penting untuk melakukan pemantauan pada fallback itu sendiri.  Jika sistem degradasi bekerja dengan cukup baik, maka pengguna, pada kenyataannya, mungkin tidak memperhatikan sama sekali bahwa ada sesuatu yang rusak di dalam kita.  Kita sendiri dapat, jika tidak ada pengawasan, tidak menyadarinya.  Penting untuk memantau fallback, penting untuk memahami kapan dihidupkan, ketika dimatikan, sehingga statistik tersedia dan kita dapat memahami berapa lama fungsi tidak bekerja, apakah backend kita semakin buruk atau lebih baik dari waktu ke waktu, tergantung pada berapa banyak waktu kita berpikir fallback . <br><br>  Semuanya dengan bagian utama. <br><br>  Pada akhirnya, saya ingin memberi tahu Anda beberapa nuansa yang harus kami hadapi ketika kami mengembangkan sistem degradasi otomatis di Yandex.Taxi. <br><br><img src="https://habrastorage.org/webt/21/ur/00/21ur007sv9i3fawffu1c1capo4i.jpeg"><br><br>  Hal pertama yang harus Anda perhatikan adalah konsistensi.  Jika Anda melakukan degradasi otomatis untuk layanan tertentu, penting bahwa layanan merespons secara konsisten untuk semua pelanggannya.  Jika Anda memiliki dua klien yang menggunakan layanan ini, penting bahwa jawaban untuk dua klien ini jika terjadi degradasi konsisten.  Dan jika Anda memiliki layanan yang terlibat dalam beberapa proses panjang, Anda perlu memahami: mungkin pada awal dan akhir proses layanan akan bekerja dengan benar, dan di suatu tempat di mundur tengah akan diaktifkan. <br><br>  Kedengarannya rumit, tapi mari kita coba jelaskan dengan sebuah contoh.  Mungkin itu akan menjadi lebih jelas. <br><br><img src="https://habrastorage.org/webt/vb/mz/tu/vbmztuwstwtzxbm_-nz48jwi68m.jpeg"><br><br>  Inilah obrolan kami antara pengemudi dan penumpang.  Cara termudah untuk menurunkannya adalah dengan menonaktifkannya.  Bayangkan saja obrolan untuk pengemudi rusak.  Apa yang akan terjadi  Klien akan menulis ke obrolan, tetapi pengemudi tidak akan melihat pesan.  Mereka mungkin akan sangat tidak bahagia, akan bersumpah pada aplikasi kita ketika mereka bertemu satu sama lain.  Dalam hal ini, penting bahwa obrolan dihidupkan pada saat yang sama atau dimatikan pada saat yang sama untuk semua peserta dalam obrolan.  Inilah yang saya sebut konsistensi. <br><br><img src="https://habrastorage.org/webt/ib/si/wa/ibsiwas6avgxafxsndgmxm5e2pg.jpeg"><br><br>  Nuansa kedua menyangkut fakta bahwa aplikasi Yandex.Taxi kami didistribusikan secara geografis: taksi dapat dipesan di Moskow, Krasnoyarsk, atau Helsinki.  Ini harus diperhitungkan bahkan ketika mengembangkan sistem degradasi.  Bayangkan kami memiliki banyak permintaan yang berhasil dan sangat sedikit permintaan dengan kesalahan.  Tampaknya ini adalah situasi normal, latar belakang kesalahan selalu ada.  Tetapi Anda dapat melihat gambar yang sama secara berbeda. <br><br>  Anda dapat melihat bahwa layanan ini tidak berfungsi di Mytishchi dan Anda harus mengaktifkan cadangan untuk pengguna ini.  Kesimpulannya adalah: Anda perlu membangun statistik yang tepat.  Bagi kami, sebagai layanan yang didistribusikan secara geografis, ini juga berarti bahwa kami perlu membuat statistik berdasarkan kota.  Jika kami membuat statistik dengan benar, kami akan segera melihat bahwa sebagian besar permintaan dari Mytishchi terputus, dan mengaktifkan fallback khusus untuk pengguna dari Mytishchi.  Dan untuk semua pengguna lain, kami akan terus bekerja dalam mode normal, karena bagi mereka layanan bekerja dengan benar. <br><br><img src="https://habrastorage.org/webt/in/y1/3n/iny13ni3cyni0noprsmqqk3rnsk.jpeg"><br><br>  Mungkin untuk layanan lain akan ada kondisi dan nuansa lain yang berbeda. <br><br>  Layanan kami menjadi lebih kompleks.  Seringkali mereka bergantung pada dunia luar, yang tidak dapat kita prediksi.  Oleh karena itu, penting untuk menulis tidak hanya layanan yang berfungsi dengan baik, tetapi juga layanan yang sangat baik.  Jika Anda mempelajari sesuatu yang baru, maka beri tahu kolega, bagikan.  Suka, bagikan, kirim ulang.  Degradasi dengan benar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438606/">https://habr.com/ru/post/id438606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438596/index.html">Menyimpan data pengguna setelah pemuatan ulang halaman</a></li>
<li><a href="../id438598/index.html">Bereaksi & BEM - kolaborasi resmi. Bagian sejarah</a></li>
<li><a href="../id438600/index.html">SciPy, input dan output dalam MATLAB</a></li>
<li><a href="../id438602/index.html">Kami membongkar protokol pesan pager POCSAG, bagian 1</a></li>
<li><a href="../id438604/index.html">Bitrix dalam banyak Nginx + PHP-FPM, mengatur CNC, serta cache komposit dengan umpan balik melalui nginx. Konfigurasi yang dimodifikasi</a></li>
<li><a href="../id438610/index.html">Templat Figma Responsif: Membuat Komponen Desain yang Fleksibel untuk Navigasi Seluler iOS</a></li>
<li><a href="../id438614/index.html">Apa itu animasi idle berkualitas? Pengembang membagikan contoh favorit mereka.</a></li>
<li><a href="../id438618/index.html">Membuat proyektor laser teks DIY</a></li>
<li><a href="../id438620/index.html">Path saya sebagai Pemula</a></li>
<li><a href="../id438622/index.html">Bonsai: mesin wiki keluarga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>