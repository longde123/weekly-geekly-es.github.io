<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÑ üßëüèΩ üåê So funktioniert Headless Chrome ‚óΩÔ∏è üö£üèæ ü•ä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aus dem Namen geht bereits hervor, dass ein kopfloser Browser etwas ohne Kopf ist. Im Kontext eines Frontends ist es ein unverzichtbares Werkzeug f√ºr ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert Headless Chrome</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421137/">  Aus dem Namen geht bereits hervor, dass ein kopfloser Browser etwas ohne Kopf ist.  Im Kontext eines Frontends ist es ein unverzichtbares Werkzeug f√ºr einen Entwickler, mit dem Sie den Code testen, die Qualit√§t und √úbereinstimmung mit dem Layout √ºberpr√ºfen k√∂nnen.  Vitaliy Slobodin von Frontend Conf entschied, dass es notwendig sei, das Ger√§t dieses Tools n√§her kennenzulernen. <br><br>  Unter den Schnittkomponenten und Funktionen von Headless Chrome finden Sie interessante Szenarien f√ºr die Verwendung von Headless Chrome.  Der zweite Teil √ºber Puppeteer ist eine praktische Node.js-Bibliothek zum Verwalten des Headless-Modus in Google Chrome und Chromium. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher:</strong> Vitaliy Slobodin - ein ehemaliger Entwickler von PhantomJS - derjenige, der es geschlossen und begraben hat.  Manchmal hilft es Konstantin Tokarev ( <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">annulen</a></u> ) in der "wiederbelebten" Version von QtWebKit - dem QtWebKit, in dem ES6, Flexbox und viele andere moderne Standards unterst√ºtzt werden. <br><br>  Vitaliy liebt es, Browser zu erkunden, sich in seiner Freizeit mit WebKit, Chrome usw. zu besch√§ftigen und vieles mehr.  Wir werden heute √ºber Browser sprechen, n√§mlich √ºber kopflose Browser und ihre gesamte Geisterfamilie. <a name="habracut"></a><br><br><h2>  <strong>Was ist ein kopfloser Browser?</strong> <br></h2><br>  Schon aus dem Namen geht hervor, dass dies etwas ohne Kopf ist.  In einem Browserkontext bedeutet dies Folgendes. <br><br><ol><li>  Es gibt <strong>keine echte Wiedergabe des Inhalts</strong> , das hei√üt, es <strong>zeichnet</strong> alles in Erinnerung. </li><li> Aus diesem Grund wird <strong>weniger Speicherplatz ben√∂tigt</strong> , da keine Bilder oder Gigabyte-PNGs gezeichnet werden m√ºssen, die mit einer Bombe in das Backend eingef√ºgt werden sollen. </li><li>  Es <strong>funktioniert schneller,</strong> da nichts auf dem realen Bildschirm gerendert werden muss. </li><li>  Hat eine <strong>Programmierschnittstelle f√ºr die Verwaltung</strong> .  Sie fragen - er hat keine Schnittstelle, Schaltfl√§chen, Fenster?  Wie geht man damit um?  Daher verf√ºgt es nat√ºrlich √ºber eine Schnittstelle f√ºr die Verwaltung. </li><li>  Eine wichtige Eigenschaft ist die <strong>M√∂glichkeit, auf einem nackten Linux-Server zu installieren</strong> .  Dies ist erforderlich, damit Sie bei einem frisch installierten Ubuntu oder Red Hat einfach die Bin√§rdatei l√∂schen oder das Paket dort ablegen k√∂nnen und der Browser sofort funktioniert.  Es wird kein Schamanismus oder Voodoo-Magie ben√∂tigt. </li></ol><br>  Dies ist ein typischer WebKit-basierter Browser.  Sie k√∂nnen die Komponenten nicht erfassen - dies ist nur ein visuelles Bild. <br><br><img src="https://habrastorage.org/webt/un/7p/zj/un7pzjwjsn1a3psu2augn59jmj0.jpeg"><br><br>  Wir interessieren uns nur f√ºr die oberste Komponente der Browser-Benutzeroberfl√§che.  Dies ist dieselbe Benutzeroberfl√§che - Fenster, Men√ºs, Popup-Benachrichtigungen und alles andere. <br><br><img src="https://habrastorage.org/webt/14/ds/oa/14dsoabrnydhu5hb6iovu_gd2m8.jpeg"><br><br>  So sieht der kopflose Browser aus.  Beachten Sie den Unterschied?  Wir entfernen die Benutzeroberfl√§che vollst√§ndig.  Er ist nicht mehr.  <strong>Es bleibt nur der Browser √ºbrig</strong> . <br><br>  Heute werden wir √ºber Headless Chrome () sprechen.  Was ist der Unterschied zwischen ihnen?  In der Tat ist Chrome eine Markenversion von Chromium, die propriet√§re Codecs, den gleichen H.264, die Integration mit Google-Diensten und alles andere enth√§lt.  Chromium ist nur eine Open Source-Implementierung. <br><br><img src="https://habrastorage.org/webt/ti/14/-e/ti14-etgpuf8lm5euapnu1qk3rs.jpeg"><br><br>  Geburtsdatum von Headless Chrome: 2016.  Wenn Sie auf ihn sto√üen, k√∂nnen Sie mir eine knifflige Frage stellen: ‚ÄûWie, ich erinnere mich an die Nachrichten von 2017?‚Äú  Tatsache ist, dass ein Team von Ingenieuren von Google die PhantomJS-Entwickler bereits 2016 kontaktierte, als sie gerade mit der Implementierung des Headless-Modus in Chrome begannen.  Wir haben ganze Google Docks geschrieben, wie wir die Oberfl√§che implementieren und so weiter.  Dann wollte Google eine Schnittstelle voll kompatibel mit PhantomJS machen.  Erst dann kam das Ingenieurteam zu der Entscheidung, eine solche Kompatibilit√§t nicht zu tun. <br><br>  Wir werden sp√§ter √ºber die Verwaltungsschnittstelle (API) sprechen, bei der es sich um das Chrome DevTools-Protokoll handelt, und sehen, was Sie damit tun k√∂nnen. <br><br>  Dieser Artikel basiert auf dem Prinzip der Puppenspielerpyramide (vom englischen Puppenspieler).  Ein guter Name wird gew√§hlt - der Puppenspieler ist derjenige, der alle anderen kontrolliert! <br><br><img src="https://habrastorage.org/webt/4y/2i/lq/4y2ilqrqu3fxx8lrinrjp90zgfq.jpeg"><br><br>  An der Basis der Pyramide befindet sich Headless Chrome - Headless Chrome - was ist das? <br><br><h2>  <strong>Kopfloses Chrom</strong> <br></h2><br><img src="https://habrastorage.org/webt/tx/id/ql/txidqlimkcdam_vcyah-fu4vlk0.jpeg"><br><br>  In der Mitte - Headless Browser - das gleiche Chrom oder Chrome (normalerweise Chrom).  Es hat die sogenannten Renderer (RENDERER) - Prozesse, die den Inhalt der Seite (Ihres Fensters) zeichnen.  Dar√ºber hinaus ben√∂tigt jede Registerkarte einen eigenen Renderer. Wenn Sie also viele Registerkarten √∂ffnen, startet Chrome so viele Prozesse zum Rendern. <br><br>  Hinzu kommt Ihre Bewerbung.  Wenn wir Chromium oder Headless Chrome verwenden, befindet sich Chrome dar√ºber oder eine Anwendung, in die Sie es einbetten k√∂nnen.  Das n√§chstgelegene Analogon kann Steam genannt werden.  Jeder wei√ü, dass Steam im Wesentlichen nur ein Browser f√ºr die Steam-Website ist.  Er ist nat√ºrlich nicht kopflos, aber diesem Schema √§hnlich. <br><br>  Es gibt zwei M√∂glichkeiten, kopfloses Chrome in Ihre Anwendung einzubetten (oder zu verwenden): <br><br><ol><li>  Standard, wenn Sie <strong>Puppenspieler</strong> nehmen und Headless Chrome verwenden. <br></li><li>  Wenn Sie die <strong>Headless-Bibliothekskomponente verwenden</strong> , <strong>dh</strong> eine Bibliothek, die den Headless-Modus implementiert und in Ihre Anwendung einbettet, z. B. in C ++. <br></li></ol><br>  Sie fragen sich vielleicht, warum C ++ im Frontend ist?  Die Antwort ist die DevTools C ++ API.  Sie k√∂nnen die Funktionen von Headless Chrome auf verschiedene Arten implementieren und verwenden.  Wenn Sie Puppeteer verwenden, erfolgt die Kommunikation mit einem Headless-Browser √ºber Web-Sockets.  Wenn Sie die Headless-Bibliothek in eine Desktop-Anwendung einbetten, verwenden Sie die native Schnittstelle, die in C ++ geschrieben ist. <br><br>  Abgesehen davon haben Sie noch weitere Dinge, darunter: <br><br><ul><li>  <strong>Benutzerdefiniertes Netzwerk</strong> - Benutzerdefinierte Implementierung der Interaktion mit dem Netzwerk.  Angenommen, Sie arbeiten in einer Bank oder einer Regierungsbeh√∂rde, die aus drei Buchstaben besteht und mit "F" beginnt und ein sehr kniffliges Authentifizierungs- oder Autorisierungsprotokoll verwendet, das von Browsern nicht unterst√ºtzt wird.  Daher ben√∂tigen Sie m√∂glicherweise einen benutzerdefinierten Handler f√ºr Ihr Netzwerk.  Sie k√∂nnen einfach Ihre bereits implementierte Bibliothek nehmen und in Chrome verwenden. </li><li>  <strong>Mojo-Module</strong> .  Das n√§chste Analogon zu Mojo sind die nativen Ordner in Node.js zu Ihren in C ++ geschriebenen nativen Bibliotheken.  Mojo macht dasselbe - Sie nehmen Ihre native Bibliothek, schreiben eine Mojo-Oberfl√§che daf√ºr und k√∂nnen dann die Methoden Ihrer nativen Bibliothek in Ihrem Browser aufrufen. </li></ul><br><h3>  Chromkomponenten <br></h3><br><img src="https://habrastorage.org/webt/zh/-x/jf/zh-xjfbpq4mjz2ntcwr_tjriuhe.jpeg"><br><br>  Wieder h√∂re ich eine knifflige Frage: ‚ÄûWarum brauche ich dieses schreckliche Schema?  Ich schreibe unter (geben Sie den Namen Ihres Lieblings-Frameworks ein). ‚Äú <br><br><blockquote>  Ich glaube, dass ein Entwickler wissen sollte, wie sein Tool funktioniert.  Wenn Sie unter React schreiben, sollten Sie wissen, wie React funktioniert.  Wenn Sie unter Angular schreiben, sollten Sie wissen, was Angular unter der Haube hat. <br></blockquote><br>  Denn bei etwas, zum Beispiel einem schwerwiegenden Fehler oder einem sehr schwerwiegenden Fehler in der Produktion, muss man sich mit den "Eingeweiden" auseinandersetzen, und man kann sich dort einfach verlaufen - wo, was und wie.  Wenn Sie beispielsweise Tests schreiben oder Headless Chrome verwenden, k√∂nnen auch einige seiner seltsamen Verhaltensweisen und Fehler auftreten.  Daher werde ich Ihnen kurz sagen, welche Chromium-Komponenten enthalten sind.  Wenn Sie eine gro√üe Stapelverfolgung sehen, wissen Sie bereits, wie Sie graben und wie Sie sie √ºberhaupt reparieren k√∂nnen. <br><br>  Die unterste Ebene der <strong>Plattformebene</strong> .  Seine Komponenten: <br><br><ul><li>  <strong>Mit Ozone</strong> , dem abstrakten Fenstermanager in Chrome, interagiert der Fenstermanager des Betriebssystems.  Unter Linux ist es entweder ein X-Server oder Wayland.  Unter Windows ist es ein Windows-Fenstermanager. </li><li>  <strong>Scheduler</strong> ist derselbe Scheduler, ohne den wir nirgendwo sind, da wir alle wissen, dass Chrome eine Multiprozessanwendung ist und wir irgendwie alle Threads, Prozesse und alles andere aufl√∂sen m√ºssen. </li><li>  <strong>Netz</strong> - Der Browser sollte immer eine Komponente f√ºr die Arbeit mit dem Netzwerk haben, z. B. zum Parsen von HTTP, Erstellen von Headern, Bearbeiten usw. </li></ul><br>  Die <strong>Content-Ebene</strong> ist die gr√∂√üte Komponente von Chrome.  Es beinhaltet: <br><br><ul><li>  <strong>Blink</strong> ist eine WebCore-basierte Web-Engine von WebKit.  Es kann HTML als Zeichenfolge verwenden, analysieren, JavaScript ausf√ºhren - und das war's.  Er wei√ü nicht mehr, wie man etwas macht: weder mit dem Netzwerk arbeiten noch zeichnen - all dies geschieht zus√§tzlich zu Blink. <br>  Blink enth√§lt: eine stark modifizierte Version von WebCore - eine Web-Engine f√ºr die Arbeit mit HTML und CSS;  V8 (JavaScript-Engine);  sowie eine API f√ºr alle in Chrome verwendeten Erweiterungen, z. B. einen Werbeblocker.  Es enth√§lt auch das DevTools-Protokoll. <br></li><li>  <strong>Die Inhalts-API</strong> ist eine Schnittstelle, mit der Sie alle Funktionen der Web-Engine ganz einfach nutzen k√∂nnen.  Da es in Blink so viele Dinge gibt (wahrscheinlich mehr als eine Million Schnittstellen), ben√∂tigen Sie eine Inhalts-API, um nicht in all diesen Methoden und Funktionen verloren zu gehen.  Sie geben HTML ein, die Engine verarbeitet es automatisch, analysiert das DOM, erstellt CSS OM, f√ºhrt JavaScript aus, f√ºhrt Timer, Handler und alles andere aus. <br></li></ul><br>  Ebene ohne Kopf - Ebene ohne Browser: Kopf ohne Ebene: <br><br><ul><li>  <strong>Kopflose Bibliothek</strong> . </li><li>  <strong>Embedder-API-</strong> Schnittstelle zum Einbetten der Headless-Bibliothek in die Anwendung. </li><li>  <strong>Die Client-API</strong> ist eine Schnittstelle, die Puppeteer verwendet. </li></ul><br>  <strong>Anwendungsschicht Anwendungsschicht</strong> : <br><br><ul><li>  Ihre Anwendung ( <strong>Embedding App</strong> ); </li><li>  Gadgets, zum Beispiel <strong>Headless Shell</strong> . </li></ul><br>  Lassen Sie uns jetzt etwas h√∂her aus den Tiefen aufsteigen, aktivieren - jetzt geht das Frontend. <br><br><img src="https://habrastorage.org/webt/_p/p6/10/_pp610df2doffm9nfysj-62ioea.jpeg"><br><br><h3>  Chrome DevTools-Protokoll <br></h3><br>  Wir sind alle auf das Chrome DevTools-Protokoll gesto√üen, weil wir das Entwicklerfenster in Chrome oder den Remote-Debugger verwenden - dieselben Entwicklungstools.  Wenn Sie die Entwicklertools remote ausf√ºhren, erfolgt die Kommunikation mit dem Browser √ºber das DevTools-Protokoll.  Wenn Sie den Debugger installieren, lesen Sie die Codeabdeckung, verwenden Sie die Geolokalisierung oder etwas anderes - all dies wird mit DevTools gesteuert. <br><br><img src="https://habrastorage.org/webt/qe/wy/2b/qewy2b3vwphvwanus0zqqnnxeq4.jpeg"><br><br>  Tats√§chlich verf√ºgt das DevTools-Protokoll selbst √ºber eine Vielzahl von Methoden.  Ihr Entwicklertool hat keinen Zugriff, wahrscheinlich auf 80% von ihnen.  Wirklich, Sie k√∂nnen dort alles tun! <br><br>  Mal sehen, worum es in diesem Protokoll geht.  In der Tat ist es sehr einfach.  Es hat 2 Komponenten: <br><br><ol><li>  DevTools-Ziel - die Registerkarte, die Sie untersuchen; <br></li><li>  DevTools-Client - Nehmen wir an, dies ist ein Entwicklerpanel, das remote gestartet wird. <br></li></ol><br><img src="https://habrastorage.org/webt/-a/t8/ch/-at8chx2k1wsarzbzqhxtftflay.jpeg"><br><br>  Sie kommunizieren mit einfachem JSON: <br><br><ul><li>  Es gibt eine Kennung f√ºr den Befehl, den Namen der auszuf√ºhrenden Methode und einige Parameter. </li><li>  Wir senden eine Anfrage und erhalten eine Antwort, die ebenfalls sehr einfach aussieht: eine Kennung, die ben√∂tigt wird, weil alle Befehle, die mit dem Protokoll ausgef√ºhrt werden, asynchron sind.  Damit wir immer vergleichen k√∂nnen, welche Antwort auf welches Team wir erhalten haben, ben√∂tigen wir eine Kennung. </li><li>  Es gibt ein Ergebnis.  In unserem Fall handelt es sich um ein Ergebnisobjekt mit den folgenden Attributen: <strong>Typ:</strong> <strong>"Nummer",</strong> <strong>Wert:</strong> <strong>2,</strong> <strong>Beschreibung:</strong> <strong>"2"</strong> , es wurde keine Ausnahme ausgel√∂st: <strong>wasThrown:</strong> <strong>false.</strong> <br></li></ul><br>  Unter anderem kann Ihre Registerkarte Ereignisse an Sie zur√ºcksenden.  Angenommen, wenn ein Ereignis auf einer Seite aufgetreten ist oder eine Ausnahme auf einer Seite aufgetreten ist, erhalten Sie √ºber dieses Protokoll eine Benachrichtigung. <br><br><img src="https://habrastorage.org/webt/-f/nc/8g/-fnc8gvu6h9dy5p5ovh3wf0v6ua.jpeg"><br><br><img src="https://habrastorage.org/webt/h0/tx/ud/h0txudupxhjb8brbckihbe7wzum.jpeg"><br><br><h2>  <strong>Puppenspieler</strong> <br></h2><br>  Sie k√∂nnen Puppeteer mit Ihrem bevorzugten Paketmanager installieren - sei es Garn, npm oder einem anderen. <br><br>  Die Verwendung ist ebenfalls einfach - fordern Sie es einfach in Ihrem Node.js-Skript an, und Sie k√∂nnen es bereits verwenden. <br><br><img src="https://habrastorage.org/webt/pi/ia/or/piiaoriro3hvbrm_yhvd1h-scq4.jpeg"><br><br>  √úber den Link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://try-puppeteer.appspot.com k√∂nnen</a> Sie ein Skript direkt auf der Site schreiben, ausf√ºhren und das Ergebnis direkt im Browser abrufen.  All dies wird mit Headless Chrome implementiert. <br><br>  Betrachten Sie das einfachste Skript unter Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch() ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'http://devconf.ru/'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.emulateMedia(<span class="hljs-string"><span class="hljs-string">'screen'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.pdf({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'./devconf.pdf, printBackground: true }); await browser.close() ; })();</span></span></code> </pre> <br>  Hier √∂ffnen wir einfach die Seite und drucken sie als PDF aus.  Sehen wir uns die Funktionsweise dieses Skripts in Echtzeit an: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Alles wird cool sein, aber es ist nicht klar, was drin ist.  Nat√ºrlich haben wir einen kopflosen Browser, aber wir sehen nichts.  Daher hat Puppenspieler eine spezielle Flagge namens kopflos: false: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({ <span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre><br>  Es ist erforderlich, den Headless-Browser im Headful-Modus zu starten, wenn Sie ein Fenster sehen und in Echtzeit sehen k√∂nnen, was mit Ihrer Seite passiert, dh wie Ihr Skript mit Ihrer Seite interagiert. <br><br><img src="https://habrastorage.org/webt/qz/oo/ie/qzooiejebek5gqaww2gw9tv0sgc.jpeg"><br><br>  Dies sieht genauso aus, wenn wir dieses Flag hinzuf√ºgen.  Links erscheint ein Browserfenster - deutlicher. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Vorteile des Puppenspielers:</strong> <br><br>  + Dies ist die Node.js-Bibliothek f√ºr Chrome Headless. <br>  + Unterst√ºtzung f√ºr √§ltere Versionen von Node.js&gt; = 6. <br>  + Einfache Installation. <br>  + High-Level-API f√ºr die Verwaltung dieser gesamten riesigen Maschine. <br><br>  Headless Chrome l√§sst sich einfach und ohne Systemintervention installieren.  Bei der ersten Installation l√§dt Puppeteer die Version von Chromium herunter und installiert sie direkt im Ordner node_modules, speziell f√ºr Ihre Architektur und Ihr Betriebssystem.  Sie m√ºssen nichts extra herunterladen, dies geschieht automatisch.  Sie k√∂nnen auch Ihre Lieblingsversion von Chrome verwenden, die auf Ihrem System installiert ist.  Sie k√∂nnen dies auch tun - Puppeteer bietet Ihnen eine solche API. <br><br>  Leider gibt es auch Nachteile, wenn wir nur die Grundinstallation nehmen. <br><br>  <strong>Nachteile Puppenspieler</strong> : <br><br>  - <strong>Keine Funktionen der obersten Ebene</strong> : Synchronisation von Lesezeichen und Passw√∂rtern;  Profilunterst√ºtzung;  Hardwarebeschleunigung etc. <br>  - <strong>Software-Rendering</strong> ist das wichtigste Minus.  Alle Berechnungen und Renderings finden auf Ihrer CPU statt.  Aber hier werden uns die Google-Ingenieure bald √ºberraschen - die Arbeiten zur Implementierung der Hardwarebeschleunigung sind bereits im Gange.  Schon jetzt k√∂nnen Sie versuchen, es zu benutzen, wenn Sie mutig und mutig sind. <br>  - Bis vor kurzem gab es keine Unterst√ºtzung f√ºr Erweiterungen - jetzt gibt es!  Wenn Sie ein schlauer Entwickler sind, k√∂nnen Sie Ihren bevorzugten AdBlock verwenden, angeben, wie Puppeteer ihn verwenden soll, und alle Anzeigen werden blockiert. <br>  - <strong>Keine Audio / Video-Unterst√ºtzung</strong> .  Denn nun, warum Headless-Browser Audio und Video. <br><br>  <strong>Was kann Puppenspieler:</strong> <br><br><ul><li>  Isolationssitzungen. </li><li>  Virtuelle Timer. </li><li>  Abfangen von Netzwerkanforderungen. </li></ul><br>  Und ein paar coole Dinge, die ich etwas weiter zeigen werde. <br><br><h4>  Sitzungsisolation <br></h4><br>  Was ist es, womit wird es gegessen und werden wir nicht ersticken?  - Nicht ersticken! <br><br>  Die Sitzungsisolation ist ein <strong>separates ‚ÄûRepository‚Äú f√ºr jede Registerkarte</strong> .  Wenn Sie Puppeteer starten, k√∂nnen Sie eine neue Seite erstellen und jede neue Seite kann ein eigenes Repository haben, einschlie√ülich: <br><br><ul><li>  kocht <br></li><li>  lokaler Speicher; <br></li><li>  Cache. <br></li></ul><br>  Alle Seiten werden unabh√§ngig voneinander leben.  Dies ist beispielsweise erforderlich, um die Atomizit√§t der Tests aufrechtzuerhalten. <br><br>  Die Sitzungsisolation <strong>spart Ressourcen und Zeit beim Starten paralleler Sitzungen</strong> .  Angenommen, Sie testen eine Site, die im Entwicklungsmodus erstellt wird, dh das Bundle wird nicht minimiert und wiegt 20 MB.  Wenn Sie es nur zwischenspeichern m√∂chten, k√∂nnen Sie Puppeteer anweisen, einen Cache zu verwenden, der allen erstellten Seiten gemeinsam ist. Dieses Bundle wird zwischengespeichert. <br><br>  Sie k√∂nnen <strong>Sitzungen f√ºr die sp√§tere Verwendung serialisieren</strong> .  Sie schreiben einen Test, der eine bestimmte Aktion auf Ihrer Site √ºberpr√ºft.  Sie haben jedoch ein Problem - die Website muss autorisiert werden.  Sie werden nicht st√§ndig in jedem Test f√ºr die Autorisierung auf der Website hinzuf√ºgen.  Mit Puppeteer k√∂nnen Sie sich einmal bei der Site anmelden und diese Sitzung in Zukunft wiederverwenden. <br><br><h4>  Virtuelle Timer <br></h4><br>  M√∂glicherweise verwenden Sie bereits virtuelle Timer.  Wenn Sie den Schieberegler in einem Entwicklertool verschoben haben, das die Animation beschleunigt oder verlangsamt (und danach nat√ºrlich Ihre H√§nde gewaschen hat!), Haben Sie in diesem Moment virtuelle Timer im Browser verwendet. <br><br>  Der Browser kann virtuelle Timer anstelle von realen verwenden, um die <strong>Zeit vorw√§rts</strong> zu <strong>scrollen</strong> , um das Laden der Seite zu beschleunigen oder die Animation abzuschlie√üen.  Angenommen, Sie haben den gleichen Test, gehen zur Hauptseite und dort die Animation f√ºr 30 Sekunden.  Es ist f√ºr niemanden von Vorteil, den Test die ganze Zeit warten zu lassen.  Daher k√∂nnen Sie die Animation einfach beschleunigen, sodass sie beim Laden der Seite sofort abgeschlossen wird und Ihr Test fortgesetzt wird. <br><br>  Sie k√∂nnen <strong>die Zeit anhalten, w√§hrend die Netzwerkanforderung ausgef√ºhrt wird</strong> .  Sie testen beispielsweise die Reaktion Ihrer Anwendung, wenn die Ausf√ºhrung einer Anforderung, die an das Backend gesendet wurde, sehr lange dauert oder mit einem Fehler zur√ºckgegeben wird.  Sie k√∂nnen die Zeit anhalten - Puppenspieler erlaubt es. <br><br>  Auf der Folie unten gibt es eine weitere Option: <strong>Stoppen Sie den</strong> Renderer <strong>und fahren Sie fort</strong> .  Im experimentellen Modus konnte der Browser angewiesen werden, nicht zu rendern, und sp√§ter, falls erforderlich, einen Screenshot anfordern.  Dann w√ºrde kopfloses Chrome schnell alles rendern, einen Screenshot geben und wieder aufh√∂ren, etwas zu zeichnen.  Leider ist es den Entwicklern bereits gelungen, das Funktionsprinzip dieser API zu √§ndern, und es gibt keine solche Funktion mehr. <br><br>  Eine schematische Ansicht der virtuellen Timer unten. <br><br><img src="https://habrastorage.org/webt/dy/zm/bu/dyzmbucfttmfjlbsdkpmlk6bypq.jpeg"><br><br>  Die oberste Zeile hat zwei regul√§re Timer: Der erste startet in der ersten Zeiteinheit und l√§uft in einer Zeiteinheit, der zweite startet in der dritten Zeiteinheit und l√§uft in drei Zeiteinheiten. <br><br>  Timer beschleunigen - sie starten nacheinander.  Wenn wir sie anhalten, haben wir eine Zeitspanne, nach der alle Timer starten. <br><br>  Betrachten Sie dies als Beispiel.  Unten finden Sie einen abgeschnittenen Code, der im Wesentlichen nur die Animationsseite von codepen.io l√§dt und wartet: <br><br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https ://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page.goto(url, { waitUnitl: 'load' }); // # 2 })();</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese</a> Demonstration der Implementierung w√§hrend der Pr√§sentation ist nur eine Animation. <br><br>  Unter Verwendung des Chrome DevTools-Protokolls senden wir jetzt eine Methode namens Animation.setPlaybackRate. √úbergeben Sie ihr eine Wiedergaberate mit dem Wert 12 als Parameter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page._client.send('Animation.setPlaybackRate', { playbackRate: 12 }); // # 3 await page.goto(url, { waitUntil: 'load' }); // # 2</span></span></code> </pre><br>  Wir laden den gleichen Link und die Animashka begann viel schneller zu arbeiten.  Dies liegt an der Tatsache, dass wir einen virtuellen Timer verwendet und die Wiedergabe von Animationen um das 12-fache beschleunigt haben. <br><br>  Lassen Sie uns jetzt ein Experiment durchf√ºhren - PlaybackRate: 0 √ºbergeben - und sehen, was passiert.  Und hier wird dies sein: Es gibt √ºberhaupt keine Animation, es wird nicht abgespielt.  Null- und negative Werte unterbrechen einfach die gesamte Animation vollst√§ndig. <br><br><h4>  Arbeiten Sie mit Netzwerkanforderungen <br></h4><br>  Sie k√∂nnen <strong>Netzwerkanforderungen abfangen,</strong> indem Sie das folgende Flag setzen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.setRequestlnterception(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  In diesem Modus wird ein zus√§tzliches Ereignis angezeigt, das ausgel√∂st wird, wenn eine Netzwerkanforderung gesendet oder empfangen wird. <br><br>  Sie k√∂nnen <strong>die Anfrage im laufenden Betrieb √§ndern</strong> .  Dies bedeutet, dass Sie den gesamten Inhalt (Text) und die √úberschriften vollst√§ndig √§ndern, die Anforderung √ºberpr√ºfen und sogar abbrechen k√∂nnen. <br><br>  Dies ist erforderlich, um die <strong>Autorisierung oder Authentifizierung zu verarbeiten</strong> , einschlie√ülich der Basisauthentifizierung √ºber HTTP. <br><br>  Sie k√∂nnen auch <strong>Codeabdeckung (JS / CSS) durchf√ºhren</strong> .  Mit Puppeteer k√∂nnen Sie all dies automatisieren.  Wir alle kennen Dienstprogramme, die eine Seite laden, zeigen k√∂nnen, welche Klassen darin verwendet werden usw.  Aber sind wir mit ihnen zufrieden?  Ich denke nicht. <br><br><blockquote>  Der Browser wei√ü besser, welche Selektoren und Klassen verwendet werden - es ist ein Browser!  Er wei√ü immer, welches JavaScript ausgef√ºhrt wird, welches nicht, welches CSS verwendet wird, welches nicht. <br></blockquote><br>  Das Chrome DevTools-Protokoll hilft dabei: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all ( [ page.coverage.startJSCoverage(), page.coverage.startCSSCoverage() ]); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [jsCoverage, cssCoverage] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>,all([ page.coverage.stopJSCoverage(), page.coverage.stopCSSCoverage() ]):</code> </pre><br>  In den ersten beiden Zeilen starten wir eine relativ neue Funktion, mit der Sie die Codeabdeckung ermitteln k√∂nnen.  F√ºhren Sie JS und CSS aus, gehen Sie zu einer Seite und sagen Sie - Stopp - und wir k√∂nnen die Ergebnisse sehen.  Und dies sind keine imagin√§ren Ergebnisse, sondern solche, die der Browser aufgrund der Engine sieht. <br><br>  Unter anderem gibt es bereits ein Plugin, das f√ºr Puppenspieler alles nach Istanbul exportiert. <br><br>  Oben in der Puppenspieler-Pyramide befindet sich ein Skript, das Sie auf Node.js geschrieben haben - es ist wie der Pate in allen unteren Punkten. <br><br><img src="https://habrastorage.org/webt/gx/j6/xl/gxj6xlxcpfwiuekgcszpnijrzf8.jpeg"><br><br>  Aber ... "im d√§nischen K√∂nigreich ist nicht alles ruhig ..." - wie William Shakespeare schrieb. <br><br><h2>  <strong>Was ist los mit kopflosen Browsern?</strong> <br></h2><br>  Headless-Browser haben Probleme, obwohl all ihre coolen Funktionen so viel k√∂nnen. <br><br><h4>  Unterschied beim Rendern von Seiten auf verschiedenen Plattformen <br></h4><br>  Ich liebe diesen Artikel wirklich und rede st√§ndig dar√ºber.  Schauen wir uns dieses Bild an. <br><br><img src="https://habrastorage.org/webt/62/r2/rj/62r2rjsc0ggbgpedb5lhp_tceki.jpeg"><br><br>  Hier ist eine regul√§re Seite mit einfachem Text: rechts - Rendern in Chrome unter Linux, links - unter Windows.  Diejenigen, die mit Screenshots testen, wissen, dass immer ein Wert festgelegt wird, der als "Fehlerquote" bezeichnet wird und bestimmt, wann der Screenshot als identisch angesehen wird und wann nicht. <br><br>  Tats√§chlich besteht das Problem darin, dass unabh√§ngig davon, wie Sie versuchen, diesen Schwellenwert festzulegen, der Fehler immer √ºber diese Linie hinausgeht und Sie immer noch falsch positive Ergebnisse erhalten.  Dies liegt daran, dass alle Seiten und sogar Web-Schriftarten auf allen drei Plattformen unterschiedlich gerendert werden - unter Windows nach einem Algorithmus, unter MacOS anders, unter Linux im Allgemeinen einem Zoo.  <strong>Sie k√∂nnen nicht einfach Screenshots erstellen und testen</strong> . <br><br>  Sie werden sagen: "Ich brauche nur eine Referenzmaschine, auf der ich all diese Tests ausf√ºhren und Screenshots vergleichen kann."  Tats√§chlich ist dies jedoch √§u√üerst unpraktisch, da Sie auf CI warten m√ºssen und hier auf Ihrem Computer lokal √ºberpr√ºfen m√∂chten, ob Sie etwas kaputt gemacht haben.  Wenn Sie Referenz-Screenshots auf einem Linux-Computer und einen Mac haben, werden falsche Ergebnisse angezeigt. <br><br><blockquote>  Deshalb sage ich, dass man √ºberhaupt nicht mit Screenshots testen sollte - vergiss es. <br></blockquote><br>  √úbrigens, wenn Sie noch mit Screenshots testen m√∂chten, gibt es einen wunderbaren Artikel von Roman Dvornov: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unit-Test mit Screenshots: Durchbrechen der Schallmauer</a> ‚Äú.  Das ist reine Krimis. <br><br><h4>  Schl√∂sser <br></h4><br>  Viele gro√üe Inhaltsanbieter m√∂gen es nicht, wenn Sie kratzen oder ihre Inhalte auf illegale Weise erhalten.  Stellen Sie sich vor, ich bin ein bedeutender Inhaltsanbieter und m√∂chte dasselbe Spiel mit Ihnen spielen.  Es gibt zwei GET-Anforderungen in zwei verschiedenen Browsern. <br><img src="https://habrastorage.org/webt/ku/ys/5e/kuys5eq81wzsqfci9kpddrd-ahm.jpeg"><br><br>  K√∂nnen Sie sich vorstellen, wo Chrome hier ist?  Die Option "beides" wird nicht akzeptiert - Chrome ist nur eine.  H√∂chstwahrscheinlich k√∂nnen Sie diese Frage nicht beantworten, und ich als wichtiger Inhaltsanbieter kann: rechts - PhantomJS und links - Chrome. <br><img src="https://habrastorage.org/webt/l8/vc/lt/l8vcltt3bh-ccdysbg3azvqjxxe.jpeg"><br><br>  Ich kann den Punkt erreichen, an dem ich Ihre Browser erkennen werde (was genau Chrome oder FireFox ist), indem ich die Reihenfolge der HTTP-Header in Ihren Anforderungen anpasse.  Wenn der Host zuerst geht - ich wei√ü ganz genau - ist dies Chrome.  Dann kann ich nicht vergleichen.  Ja, nat√ºrlich gibt es komplexere Algorithmen - wir √ºberpr√ºfen nicht nur die Reihenfolge, sondern auch die Werte usw.  usw.  Aber es ist wichtig, dass ich Ihre √úberschriften besetzen, √ºberpr√ºfen kann, wer Sie sind, und Sie dann einfach blockieren oder nicht blockieren kann. <br><br><h4>  Einige Funktionen k√∂nnen nicht implementiert werden (Flash) <br></h4><br>  Haben Sie jemals vertieft, direkt Hardcore, Flash in Browsern studiert?  Irgendwie habe ich reingeschaut - dann habe ich sechs Monate lang nicht geschlafen. <br><br>  Wir alle erinnern uns, wie wir YouTube gesehen haben, als es noch Flash gab: Das Video dreht sich, alles ist in Ordnung.  In dem Moment, in dem ein eingebettetes Objekt auf einer Seite wie Flash erstellt wird, fordert es immer ein echtes Fenster von Ihrem Betriebssystem an.  Das hei√üt, zus√§tzlich zu Ihrem Browserfenster gab es ein weiteres Fenster Ihres Betriebssystems im Flash YouTube-Fenster.  Flash kann nur funktionieren, wenn Sie ihm ein echtes Fenster geben - nicht nur ein echtes Fenster, sondern ein Fenster, das auf Ihrem Bildschirm sichtbar ist.  Daher k√∂nnen einige Funktionen in Headless-Browsern, einschlie√ülich Flash, nicht implementiert werden. <br><br><h4>  Vollautomatisierung und Bots <br></h4><br>  Wie ich bereits sagte, haben gro√üe Inhaltsanbieter gro√üe Angst, wenn Sie Spinnen oder Grabbings schreiben, die einfach Informationen stehlen, die gegen eine Geb√ºhr bereitgestellt werden. <br><br>  Es werden verschiedene Tricks angewendet.  Es gibt Artikel dar√ºber, wie man kopflose Browser immer noch erkennt.  Ich kann sagen, dass <strong>Sie keine kopflosen Browser erkennen k√∂nnen</strong> .  Alle dort beschriebenen Methoden werden umgangen.  Zum Beispiel gab es Erkennungsmethoden mit Canvas.  Ich erinnere mich, dass es sogar ein Skript gab, das beobachtete, wie sich die Maus √ºber den Bildschirm bewegte und die Leinwand f√ºllte.  Wir sind Menschen und bewegen die Maus ziemlich langsam, und Headless Chrome ist viel schneller.  Das Skript hat verstanden, dass sich Canvas zu schnell f√ºllt - was bedeutet, dass es sich h√∂chstwahrscheinlich um kopfloses Chrome handelt.  Wir haben dies auch umgangen, nur das Verlangsamen des Browsers ist kein Problem. <br><br><h4>  Es gibt keine Standard-API (Einzel-API) <br></h4><br>  Wenn Sie kopflose Implementierungen in anderen Browsern gesehen haben - sei es Safari oder FireFox -, wird alles mithilfe der Webdriver-API implementiert.  Chrome verf√ºgt √ºber das Chrome DevTools-Protokoll.  In Edge ist √ºberhaupt nichts klar - was da ist, was nicht. <br><br><h4>  WebGL? <br></h4><br>  Die Leute fragen auch nach WebGL im Headless-Modus.  √úber diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link k√∂nnen</a> Sie auf den Google Chrome Bug Tracker zugreifen.  Dort stimmen Entwickler aktiv f√ºr die Implementierung des Headless-Modus f√ºr WebGL, und schon kann er etwas zeichnen.  Sie werden jetzt einfach durch Hardware-Rendering eingeschr√§nkt.  Sobald die Implementierung des Hardware-Renderings abgeschlossen ist, ist WebGL automatisch verf√ºgbar, dh es kann etwas im Hintergrund getan werden. <br><br>  Aber nicht alles ist so schlimm! <br><br>  Wir haben einen zweiten Player auf dem Markt - am 11. Mai 2018 gab es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuigkeiten,</a> dass Microsoft in seinem Edge-Browser beschlossen hat, fast dasselbe Protokoll zu implementieren, das in Google Chrome verwendet wird.  Sie haben speziell ein Konsortium gegr√ºndet, in dem sie ein Protokoll diskutieren, das sie auf einen Industriestandard bringen m√∂chten, damit Sie Ihr Skript unter Edge, Chrome und FireFox ausf√ºhren k√∂nnen. <br><br>  Aber es gibt ein "aber" - Microsoft Edge hat leider keinen Headless-Modus.  Sie haben eine Stimmabgabe, in der die Leute schreiben: "Gib uns einen kopflosen Modus!"  - aber sie schweigen.  Wahrscheinlich etwas im Verborgenen s√§gen. <br><br><h2>  <strong>TODO (Fazit)</strong> <br></h2><br>  Ich habe das alles gesagt, damit Sie zu Ihrem Manager oder, wenn Sie ein Manager sind, zum Entwickler kommen und sagen k√∂nnen: ‚ÄûDas war's!  <strong>Wir wollen kein Selen mehr - gib uns Puppenspieler!</strong>  Wir werden es testen. "  In diesem Fall werde ich mich freuen. <br><br>  Aber wenn Sie wie ich Browser mit Puppeteer lernen, Fehler aktiv posten oder eine Pull-Anfrage senden k√∂nnen, werde ich mich noch mehr freuen.  Dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool</a> in OpenSource liegt auf GitHub und ist in Node.js geschrieben. Sie k√∂nnen es einfach ausleihen und dazu beitragen. <br><br>  Der Fall mit Puppeteer ist insofern einzigartig, als in Google zwei Teams arbeiten: eines befasst sich speziell mit Puppeteer, das andere mit Headless-Modus.  Wenn ein Benutzer einen Fehler findet und auf GitHub dar√ºber schreibt, geht der Fehler nicht in Puppeteer, sondern in Headless Chrome an den Befehl Headless Chrome.  Wenn sie es dort beheben, wird Puppenspieler sehr schnell aktualisiert.  Dies f√ºhrt zu einem einzigen √ñkosystem, wenn die Community zur Verbesserung des Browsers beitr√§gt. <br><br>  Daher fordere ich Sie dringend auf, zur Verbesserung des Tools beizutragen, das nicht nur von Ihnen, sondern auch von anderen Entwicklern und Testern verwendet wird. <br><br>  Kontaktdaten: <br><br><ul><li>  github.com/vitallium </li><li>  vk.com/vitallium </li><li>  twitter.com/vitalliumm </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf Moscow</a> - Eine Fachkonferenz von Front-End-Entwicklern findet <strong>am 4. und 5. Oktober in Moskau</strong> im Infospace statt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Liste der</a> akzeptierten Berichte wurde bereits auf der Konferenzwebsite ver√∂ffentlicht. <br><br>  In unserem Newsletter f√ºhren wir regelm√§√üig thematische √úberpr√ºfungen von Reden durch, sprechen √ºber die ver√∂ffentlichten Transkripte und zuk√ºnftige Ereignisse - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">melden Sie sich</a> an, um die Nachrichten zuerst zu erhalten. <br><br>  Und dies ist ein Link zu unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Youtube-Kanal</a> im Frontend, der alle Reden enth√§lt, die sich auf die Entwicklung des Client-Teils der Projekte beziehen. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421137/">https://habr.com/ru/post/de421137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421127/index.html">Skillbox Friday Webinare: Design & Entwickler</a></li>
<li><a href="../de421129/index.html">So reduzieren Sie die Code√ºberpr√ºfung von zwei Wochen auf mehrere Stunden. Die Erfahrung des Yandex.Market-Teams</a></li>
<li><a href="../de421131/index.html">Kritische Sicherheitsanf√§lligkeit von 1Cloud-Servern</a></li>
<li><a href="../de421133/index.html">LINKa. Papiertastatur. Extra gro√üe Kn√∂pfe</a></li>
<li><a href="../de421135/index.html">Au / Ni / MgO: W√§rme√ºbertragung im Nanoma√üstab</a></li>
<li><a href="../de421139/index.html">Frontend Conf - k√ºmmert sich um den Benutzer</a></li>
<li><a href="../de421141/index.html">Mutationsanalyse oder wie man Tests testet</a></li>
<li><a href="../de421143/index.html">Aurora Labs S-Titanium Pro Mini-Metall-3D-Drucker</a></li>
<li><a href="../de421147/index.html">Monster nach den Ferien: AMD Threadripper 2990WX 32-Core und 2950X 16-Core</a></li>
<li><a href="../de421149/index.html">Ein paar Worte zu Farbverl√§ufen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>