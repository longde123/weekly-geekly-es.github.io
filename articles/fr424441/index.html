<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍯 🥤 🍕 Nouveautés du premier CTP de SQL Server 2019 👩🏾‍🚀 🍉 🧓🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La première édition du CTP de SQL Server 2019 a été présentée le 24 septembre, et permettez-moi de dire qu'elle regorge de toutes sortes d'amélioratio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouveautés du premier CTP de SQL Server 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424441/">  La première édition du CTP de SQL Server 2019 a été présentée le 24 septembre, et permettez-moi de dire qu'elle regorge de toutes sortes d'améliorations et de nouvelles fonctionnalités (dont beaucoup peuvent être trouvées dans le formulaire d'aperçu dans la base de données Azure SQL).  J'ai eu une occasion exceptionnelle de l'apprendre un peu plus tôt, ce qui m'a permis d'approfondir ma compréhension des changements, même superficiellement.  Vous pouvez également lire les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernières publications de l'équipe SQL Server</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation mise à jour</a> . <br><br>  Sans entrer dans les détails, je vais discuter des nouvelles fonctionnalités du noyau suivantes: performances, dépannage, sécurité, disponibilité et développement.  Pour le moment, j'ai un peu plus de détails que d'autres, et certains d'entre eux sont déjà prêts pour publication.  Je reviendrai sur cette section, ainsi que sur de nombreux autres articles et documentation, et je les publierai.  Je m'empresse de vous informer qu'il ne s'agit pas d'une revue complète, mais seulement d'une partie des fonctionnalités que j'ai réussi à «toucher», jusqu'au CTP 2.0.  Il y a encore beaucoup à dire. <br><a name="habracut"></a><br><h2>  Performances </h2><br><h4>  Variables du tableau: construction d'un plan différé </h4><br>  Les variables du tableau ont une mauvaise réputation, principalement dans le domaine de l'estimation des coûts.  Par défaut, SQL Server suppose qu'une variable de table ne peut contenir qu'une seule ligne, ce qui conduit parfois à un choix de plan inadéquat lorsque la variable contiendra plusieurs fois plus de lignes.  OPTION (RECOMPILE) est généralement utilisé comme solution de contournement, mais cela nécessite des modifications de code et il est inutile, par rapport aux ressources, d'effectuer une reconstruction à chaque fois, alors que le nombre de lignes est le plus souvent le même.  Pour émuler la reconstruction, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">indicateur de trace 2453 a</a> été introduit, mais il nécessite également un lancement avec l'indicateur et ne fonctionne que lorsqu'un changement significatif des lignes se produit. <br><br>  Au niveau de compatibilité 150, une construction différée est effectuée si des variables de table sont présentes et que le plan de requête n'est pas créé tant que la variable de table n'est pas remplie une fois.  Le coût sera estimé sur la base des résultats de la première utilisation de la variable de table, sans reconstruction supplémentaire.  Il s'agit d'un compromis entre la reconstruction constante pour obtenir le coût exact et l'absence totale de reconstruction à coût constant 1. Si le nombre de lignes reste relativement constant, alors c'est un bon indicateur (et encore mieux si le nombre dépasse 1), mais peut être moins rentable si il y a une grande variation dans le nombre de lignes. <br><br>  J'ai présenté une analyse plus approfondie dans un article récent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Variables tabulaires: construction différée dans SQL Server</a> , et Brent Ozar en a également parlé dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Variables tabulaires rapides (et nouveaux problèmes d'analyse des paramètres)</a> . <br><br><h4>  Commentaires sur l'allocation de mémoire en mode chaîne </h4><br>  SQL Server 2017 a des commentaires d'allocation de mémoire par lots, qui sont décrits en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Essentiellement, pour toute allocation de mémoire associée à un plan de requête qui inclut des instructions en mode batch, SQL Server évaluera la mémoire utilisée par la requête et la comparera avec la mémoire demandée.  Si la mémoire demandée est trop petite ou trop importante, ce qui entraînera des vidanges dans tempdb ou un gaspillage de mémoire, au prochain démarrage, la mémoire allouée pour le plan de requête correspondant sera ajustée.  Ce comportement réduira le volume alloué et augmentera la concurrence, ou l'augmentera, pour améliorer les performances. <br><br>  Nous obtenons maintenant le même comportement pour les requêtes en mode chaîne, sous le niveau de compatibilité 150. Si la requête a été forcée de fusionner les données sur le disque, alors pour les lancements ultérieurs, la mémoire allouée sera augmentée.  Si à la fin de la demande, la moitié de la mémoire requise était supérieure à celle allouée, alors pour les demandes suivantes, elle sera ajustée au fond.  Bretn Ozar décrit cela plus en détail dans son article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allocation de mémoire conditionnelle</a> . <br><br><h4>  Mode batch pour le stockage ligne par ligne </h4><br>  À partir de SQL Server 2012, l'interrogation des tables avec des index de colonne a bénéficié d'une amélioration des performances du mode batch.  Les améliorations des performances sont dues à un processeur de requêtes qui effectue un traitement par lots plutôt que par ligne.  Les lignes sont également traitées par le noyau de stockage dans des packages, ce qui évite les instructions d'échange simultané.  Paul White ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@SQL_Kiwi</a> ) m'a rappelé que si vous utilisez une table vide avec stockage de colonnes pour rendre possible les opérations par lots, les lignes traitées seront collectées en paquets par une instruction invisible.  Cependant, cette béquille peut annuler toute amélioration reçue du traitement par lots.  Certaines informations à ce sujet figurent dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réponse à Stack Exchange</a> . <br><br>  Au niveau de compatibilité 150, SQL Server 2019 sélectionnera automatiquement le mode de traitement par lots dans certains cas, même en l'absence d'index de colonne.  Vous pourriez penser que pourquoi ne pas simplement créer un index de colonne et un chapeau?  Ou continuer à utiliser la béquille mentionnée ci-dessus?  Cette approche a également été étendue aux objets traditionnels avec stockage de lignes, car les index de colonnes, pour plusieurs raisons, ne sont pas toujours possibles, y compris les limitations fonctionnelles (par exemple, les déclencheurs), la surcharge lors des opérations de mise à jour ou de suppression très chargées et le manque de prise en charge de fabricants tiers.  Et rien de bon ne peut être attendu de cette béquille. <br>  J'ai créé une table très simple avec 10 millions de lignes et un index cluster sur une colonne entière et j'ai exécuté cette requête: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sa5, sa2, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(i1), <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(i2), <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.FactTable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i1 &gt; <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sa5, sa2 <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sa5, sa2;</code> </pre> <br>  Le plan montre clairement les recherches d'index cluster et la concurrence, mais pas un mot sur l'index de colonne (comme le montre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SentryOne Plan Explorer</a> ): <br><br><img src="https://habrastorage.org/webt/se/cp/6u/secp6uhnmrnslv_estaiqavexbm.png"><br><br>  Mais si vous creusez un peu plus profondément, vous pouvez voir que presque tous les opérateurs ont été exécutés en mode batch, même le tri et les calculs scalaires: <br><br><img src="https://habrastorage.org/webt/0t/uu/lf/0tuulfjwod55k5fufwksdyvauae.png"><br><br>  Vous pouvez désactiver cette fonctionnalité en restant à un niveau de compatibilité inférieur en modifiant la configuration de la base de données ou en utilisant l'invite DISALLOW_BATCH_MODE dans la requête: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">OPTION</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> HINT (<span class="hljs-string"><span class="hljs-string">'DISALLOW_BATCH_MODE'</span></span>));</code> </pre> <br>  Dans ce cas, un opérateur d'échange supplémentaire apparaît, tous les opérateurs sont exécutés en mode ligne par ligne et le temps d'exécution de la requête est presque triplé. <br><br><img src="https://habrastorage.org/webt/0n/v9/k9/0nv9k9ihqq1_jprzfth_o3wwrqs.png"><br><br>  À un certain niveau, vous pouvez le voir dans le diagramme, mais dans l'arborescence des détails du plan, vous pouvez également voir l'influence d'une condition de sélection qui ne peut pas exclure des lignes jusqu'à ce que le tri soit effectué: <br><br><img src="https://habrastorage.org/webt/ek/p6/6c/ekp66cg3v8b1nfezgsyspmxgkbc.png"><br><br>  Le choix du mode batch n'est pas toujours une bonne étape - l'heuristique incluse dans l'algorithme de prise de décision prend en compte le nombre de lignes, les types d'opérateurs proposés et les bénéfices attendus du mode batch. <br><br><h4>  <font color="#004d71">APPROX_COUNT_DISTINCT</font> </h4><br>  Cette nouvelle fonction d'agrégation est destinée aux scénarios d'entreposage de données et est l'équivalent de COUNT (DISTINCT ()).  Cependant, au lieu d'effectuer des tris coûteux pour déterminer la quantité réelle, la nouvelle fonction s'appuie sur des statistiques pour obtenir des données relativement précises.  Vous devez comprendre que l'erreur se situe à moins de 2% du montant exact, et dans 97% des cas qui sont la norme pour les analyses de haut niveau, ce sont les valeurs affichées sur les indicateurs ou utilisées pour des estimations rapides. <br><br>  Sur mon système, j'ai créé une table avec des colonnes entières qui comprenait des valeurs uniques dans la plage de 100 à 1 000 000 et des colonnes de lignes, avec des valeurs uniques dans la plage de 100 à 100 000. Elle n'avait pas d'index à l'exception de la clé primaire en cluster dans la première colonne entière.  Voici les résultats de l'exécution de COUNT (DISTINCT ()) et APPROX_COUNT_DISTINCT () sur ces colonnes, à partir desquelles vous pouvez voir de légères différences (mais toujours à moins de 2%): <br><br><img src="https://habrastorage.org/webt/ou/a5/1x/oua51xwiabvnyltf75s-pjtqdn0.png"><br><br>  Le gain est énorme s'il y a des limitations de mémoire, ce qui s'applique à la plupart d'entre nous.  Si vous regardez les plans de requête, dans ce cas particulier, vous pouvez voir une énorme différence dans la consommation de mémoire par l'opérateur de correspondance de hachage: <br><br><img src="https://habrastorage.org/webt/xk/tl/sn/xktlsnekpwpu--xaebgb_ndkcn8.png"><br><br>  Notez que vous ne remarquerez généralement des améliorations significatives des performances que si vous êtes déjà lié à la mémoire.  Sur mon système, l'exécution a duré un peu plus longtemps en raison de l'utilisation élevée du processeur de la nouvelle fonctionnalité: <br><br><img src="https://habrastorage.org/webt/d9/nl/n8/d9nln84mrqh-kfmumdca_u8tt8u.png"><br><br>  Peut-être que la différence serait plus importante si j'avais des tables plus grandes, moins de mémoire disponible pour SQL Server, une concurrence plus élevée ou une combinaison des éléments ci-dessus. <br><br><h4>  <font color="#004d71">Conseils pour utiliser le niveau de compatibilité dans une requête</font> </h4><br>  Avez-vous une requête spéciale qui fonctionne mieux sous un certain niveau de compatibilité, différente de la base de données actuelle?  Cela est désormais possible grâce à de nouveaux conseils de requête prenant en charge six niveaux de compatibilité différents et cinq modèles différents pour estimer le nombre d'éléments.  Voici les niveaux de compatibilité disponibles, un exemple de syntaxe et un modèle de niveau de compatibilité utilisé dans chaque cas.  Voyez comment cela affecte les notes, même pour les vues système: <br><br><img src="https://habrastorage.org/webt/gn/0n/g1/gn0ng1ar9z_cxpi7mt8_kaiqkmu.png"><br><br>  En bref: il n'est plus nécessaire de se souvenir des indicateurs de trace ou de se demander si vous devez vous soucier de savoir si le correctif TF 4199 pour l'optimiseur de requête est distribué ou s'il a été annulé par un autre service pack.  Notez que ces conseils supplémentaires ont également été récemment ajoutés pour SQL Server 2017 dans la mise à jour cumulative # 10 (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le blog de Pedro Lopez pour</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> détails).  Vous pouvez voir tous les conseils disponibles avec la commande suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_exec_valid_use_hints;</code> </pre> <br>  Mais n'oubliez pas que les conseils sont une mesure exceptionnelle, ils sont souvent adaptés pour sortir d'une situation difficile, mais ne doivent pas être planifiés pour une utilisation à long terme, car leur comportement peut changer avec les mises à jour ultérieures. <br><br><h2>  <font color="#c30">Dépannage</font> </h2><br><h4>  <font color="#004d71">Profilage par défaut simplifié</font> </h4><br>  La compréhension de cette amélioration nécessite quelques points à retenir.  SQL Server 2014 a introduit la vue DMV sys.dm_exec_query_profiles, qui permet à l'utilisateur exécutant la requête de collecter des informations de diagnostic sur toutes les instructions dans toutes les parties de la requête.  Les informations collectées deviennent disponibles après la fin de la requête et vous permettent de déterminer quels opérateurs ont réellement dépensé les principales ressources et pourquoi.  Tout utilisateur qui n'a pas répondu à une demande spécifique pouvait recevoir ces données pour toute session dans laquelle l'instruction STATISTICS XML ou STATISTICS PROFILE était incluse, ou pour toutes les sessions, à l'aide de l'événement étendu query_post_execution_showplan, bien que cet événement, en particulier, puisse affecter les performances globales. <br><br>  Dans Management Studio 2016, une fonctionnalité a été ajoutée qui vous permet d'afficher les flux de données passant par le plan de requête en temps réel sur la base des informations collectées à partir de DMV, ce qui le rend encore plus puissant pour le dépannage.  Plan Explorer offre également la possibilité de visualiser les données passant par la requête, à la fois en temps réel et en mode lecture. <br><br>  À partir de SQL Server 2016 Service Pack 1 (SP1), vous pouvez également activer une version allégée de la collecte de ces données pour toutes les sessions à l'aide de l'indicateur de trace 7412 ou de la propriété avancée query_thread_profile, qui vous permet d'obtenir immédiatement des informations à jour sur n'importe quelle session, sans avoir besoin de quoi que ce soit l'inclure explicitement (en particulier, les éléments qui affectent négativement les performances).  Ceci est décrit plus en détail sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog de Pedro Lopez</a> . <br><br>  Dans SQL Server 2019, cette fonctionnalité est activée par défaut, vous n'avez donc pas besoin d'exécuter de sessions avec des événements étendus ou d'utiliser des indicateurs de trace et des instructions STATISTICS dans une requête.  Il suffit de regarder les données du DMV à tout moment pour toutes les sessions simultanées.  Mais il est possible de désactiver ce mode à l'aide de LIGHTWEIGHT_QUERY_PROFILING, cependant, cette syntaxe ne fonctionne pas dans CTP 2.0 et sera corrigée dans les éditions futures. <br><br><h4>  <font color="#004d71">Les statistiques d'index de colonnes en cluster sont désormais disponibles dans les bases de données clonées</font> </h4><br>  Dans les versions actuelles de SQL Server, lors du clonage d'une base de données, seules les statistiques d'objets d'origine des index de colonnes en cluster sont utilisées, à l'exclusion des mises à jour apportées à la table après sa création.  Si vous utilisez un clone pour configurer des requêtes et d'autres tests de performances, qui sont basés sur des puissances nominales, ces exemples peuvent ne pas fonctionner.  Parikshit Savyani a décrit les limitations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de cette publication</a> et a fourni une solution temporaire - avant de créer le clone, vous devez créer un script qui exécute DBCC SHOW_STATISTICS ... AVEC STATS_STREAM pour chaque objet.  C'est cher et, bien sûr, facile à oublier. <br><br>  Dans SQL Server 2019, ces statistiques mises à jour seront automatiquement disponibles dans le clone, vous pouvez donc tester divers scénarios de requête et obtenir des plans objectifs basés sur des statistiques réelles, sans exécuter manuellement STATS_STREAM pour toutes les tables. <br><br><h4>  <font color="#004d71">Prévision de compression pour le stockage des colonnes</font> </h4><br>  Dans les versions actuelles, la procédure sys.sp_estimate_data_compression_savings a la vérification suivante: <br><br><pre> <code class="sql hljs">if (@data_compression not in ('NONE', 'ROW', 'PAGE'))</code> </pre> <br>  Cela signifie qu'il vous permet de vérifier la compression d'une ligne ou d'une page (ou de voir le résultat de la suppression de la compression actuelle).  Dans SQL Server 2019, cette vérification ressemble maintenant à ceci: <br><br><pre> <code class="sql hljs">if (@data_compression not in ('NONE', 'ROW', 'PAGE', 'COLUMNSTORE', 'COLUMNSTORE_ARCHIVE'))</code> </pre> <br>  C'est une excellente nouvelle car cela vous permet de prédire approximativement l'effet de l'ajout d'un index de colonne à une table qui ne l'a pas, ou de convertir des tables ou des partitions dans un format de stockage de colonne encore plus compressé, sans avoir à restaurer la table sur un autre système.  J'avais une table avec 10 millions de lignes, pour laquelle j'ai effectué une procédure stockée avec chacun des cinq paramètres: <br><br><pre> <code class="sql hljs">EXEC sys.sp_estimate_data_compression_savings @schema_name = N'dbo', @object_name = N'FactTable', @index_id = NULL, @partition_number = NULL, @data_compression = N'NONE'; <span class="hljs-comment"><span class="hljs-comment">-- repeat for ROW, PAGE, COLUMNSTORE, COLUMNSTORE_ARCHIVE</span></span></code> </pre> <br>  Résultats: <br><br><img src="https://habrastorage.org/webt/d6/xu/uy/d6xuuythndwrwogn22ljt83w8y4.png"><br><br>  Comme pour les autres types de compression, la précision dépend entièrement des lignes disponibles et de la représentativité du reste des données.  Cependant, c'est un moyen assez puissant pour obtenir des résultats prévisibles sans trop de difficulté. <br><br><h4>  <font color="#004d71">Nouvelle fonctionnalité pour obtenir des informations sur la page</font> </h4><br>  Pendant longtemps, DBCC PAGE et DBCC IND ont été utilisés pour collecter des informations sur les pages contenant une section, un index ou une table.  Mais ils ne sont pas documentés et ne sont pas pris en charge, et il peut être fastidieux d'automatiser la solution des tâches associées à plusieurs index ou pages. <br><br>  Plus tard, une fonction d'administration dynamique (DMF) sys.dm_db_database_page_allocations est apparue, qui renvoie un ensemble représentant toutes les pages de l'objet spécifié.  Encore non documenté et présentant des failles qui peuvent devenir un vrai problème sur les grands tableaux: même pour obtenir des informations sur une page, il faut lire toute la structure, ce qui peut être assez cher. <br><br>  Dans SQL Server 2019, un autre DMF est apparu - sys.dm_db_page_info.  Il retourne essentiellement toutes les informations de la page, sans les frais généraux de la distribution DMF.  Cependant, pour utiliser la fonction dans les versions actuelles, vous devez connaître à l'avance le numéro de la page que vous recherchez.  Peut-être que cette mesure a été prise intentionnellement, car  c'est le seul moyen de garantir les performances.  Donc, si vous essayez d'identifier toutes les pages d'un index ou d'une table, vous devez toujours utiliser la distribution DMF.  Dans le prochain article, je décrirai cette question plus en détail. <br><br><h2>  <font color="#c30">La sécurité</font> </h2><br><h4>  <font color="#004d71">Cryptage permanent à l'aide d'un environnement sécurisé (enclave)</font> </h4><br>  À l'heure actuelle, le chiffrement permanent protège les données sensibles lors de la transmission et en mémoire par chiffrement / déchiffrement à chaque extrémité du processus.  Malheureusement, cela conduit souvent à de sérieuses limitations lors de l'utilisation des données, telles que l'impossibilité d'effectuer des calculs et du filtrage, vous devez donc transférer l'ensemble des données du côté client pour effectuer, par exemple, une recherche par plage. <br><br>  Un environnement sécurisé (enclave) est une zone de mémoire protégée où de tels calculs et filtrages peuvent être délégués (Windows utilise la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sécurité basée</a> sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">virtualisation</a> ) - les données restent cryptées dans le noyau, mais peuvent être décryptées en toute sécurité ou cryptées dans un environnement sécurisé.  Il vous suffit d'ajouter le paramètre ENCLAVE_COMPUTATIONS à la clé primaire à l'aide de SSMS, par exemple, en cochant la case "Autoriser les calculs dans un environnement sécurisé": <br><br><img src="https://habrastorage.org/webt/do/ia/tp/doiatpb0ne_kpxgb5pbdep8ua5m.png"><br><br>  Maintenant, vous pouvez chiffrer les données presque instantanément, par rapport à l'ancienne méthode (dans laquelle l'assistant, la cmdlet Set-SqlColumnEncyption ou votre application, devrait récupérer complètement l'ensemble de la base de données, le chiffrer et le renvoyer): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.Patients <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> SSN <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- currently not encrypted! ENCRYPTED WITH ( COLUMN_ENCRYPTION_KEY = ColumnEncryptionKeyName, ENCRYPTION_TYPE = Randomized, ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256' ) NOT NULL;</span></span></code> </pre> <br>  Je pense que pour de nombreuses organisations, cette amélioration sera la principale nouvelle, mais dans le CTP actuel, certains de ces sous-systèmes sont toujours en cours d'amélioration, ils sont donc désactivés par défaut, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> vous pouvez voir comment les activer. <br><br><h4>  <font color="#004d71">Gestion des certificats dans Configuration Manager</font> </h4><br>  La gestion des certificats SSL et TLS a toujours été difficile et de nombreuses personnes ont été obligées de faire le travail fastidieux de créer leurs propres scripts pour déployer et maintenir leurs certificats d'entreprise.  Le gestionnaire de configuration mis à jour pour SQL Server 2019 vous aidera à afficher et à vérifier rapidement les certificats de n'importe quelle instance, à trouver les certificats qui expirent bientôt et à synchroniser les déploiements de certificats entre toutes les réplications du groupe de disponibilité ou tous les nœuds de l'instance de cluster de basculement. <br><br>  Je n'ai pas essayé toutes ces opérations, mais elles devraient fonctionner pour les versions précédentes de SQL Server si la gestion provient de SQL Server 2019 Configuration Manager. <br><br><h4>  <font color="#004d71">Classification et audit des données intégrés</font> </h4><br>  L'équipe de développement SQL Server a ajouté la possibilité de classer les données dans SSMS 17.5, vous permettant d'identifier toutes les colonnes qui peuvent contenir des informations sensibles ou contredire diverses normes (HIPAA, SOX, PCI et GDPR, bien sûr).  L'assistant utilise un algorithme qui propose des colonnes qui sont censées causer des problèmes, mais vous pouvez soit ajuster sa phrase en supprimant ces colonnes de la liste, soit ajouter la vôtre.  Pour stocker la classification, des propriétés avancées sont utilisées;  Le rapport SSMS intégré utilise les mêmes informations pour afficher ses données.  En dehors du rapport, ces propriétés ne sont pas si évidentes. <br><br>  SQL Server 2019 a introduit une nouvelle instruction pour ces métadonnées, déjà disponible dans la base de données Azure SQL, et appelée ADD SENSITIVITY CLASSIFICATION.  Il vous permet de faire la même chose que l'assistant dans SSMS, mais les informations ne sont plus stockées dans la propriété étendue et tout accès à ces données est automatiquement affiché dans l'audit comme une nouvelle colonne XML data_sensitivity_information.  Il contient tous les types d'informations qui ont été affectés lors de l'audit. <br><br>  À titre d'exemple rapide, supposons que j'ai une table pour les entrepreneurs externes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.Contractors ( FirstName sysname, LastName sysname, SSN <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>), HourlyRate <span class="hljs-built_in"><span class="hljs-built_in">decimal</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) );</code> </pre> <br>  En regardant une telle structure, il devient clair que les quatre colonnes sont soit potentiellement vulnérables aux fuites, soit devraient être accessibles uniquement à un cercle restreint de personnes.  Ici, vous pouvez vous débrouiller avec des autorisations, mais au moins vous devez vous concentrer sur elles.  Ainsi, nous pouvons classer ces colonnes de différentes manières: <br><br><pre> <code class="sql hljs">ADD SENSITIVITY CLASSIFICATION TO dbo.Contractors.FirstName, dbo.Contractors.LastName <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (LABEL = <span class="hljs-string"><span class="hljs-string">'Confidential â€“ GDPR'</span></span>, INFORMATION_TYPE = <span class="hljs-string"><span class="hljs-string">'Personal Info'</span></span>); ADD SENSITIVITY CLASSIFICATION TO dbo.Contractors.SSN <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (LABEL = <span class="hljs-string"><span class="hljs-string">'Highly Confidential'</span></span>, INFORMATION_TYPE = <span class="hljs-string"><span class="hljs-string">'National ID'</span></span>); ADD SENSITIVITY CLASSIFICATION TO dbo.Contractors.HourlyRate <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (LABEL = <span class="hljs-string"><span class="hljs-string">'Highly Confidential'</span></span>, INFORMATION_TYPE = <span class="hljs-string"><span class="hljs-string">'Financial'</span></span>);</code> </pre> <br>  Maintenant, au lieu de regarder sys.extended_properties, vous pouvez les voir dans sys.sensitivity_classifications: <br><br><img src="https://habrastorage.org/webt/xs/4u/bx/xs4ubxognfau0yxlbl_g8caqujm.png"><br><br>  Et si nous effectuons un échantillonnage d'audit (ou DML) pour ce tableau, nous n'avons pas besoin de changer quoi que ce soit spécifiquement;  après avoir créé la classification, <code>SELECT *</code> enregistrera dans le journal d'audit un enregistrement de ce type d'informations dans une nouvelle colonne data_sensitivity_information: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attributes</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attribute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Confidential - GDPR"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">information_type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Personal Info"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attribute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Highly Confidential"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">information_type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"National ID"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attribute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Highly Confidential"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">information_type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Financial"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attributes</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Bien sûr, cela ne résout pas tous les problèmes de conformité aux normes, mais cela peut donner un réel avantage.  L'utilisation de l'assistant pour identifier automatiquement les colonnes et traduire les appels sp_addextendedproperty en commandes ADD SENSITIVITY CLASSIFICATION peut grandement simplifier la tâche de conformité aux normes.  Plus tard, j'écrirai un article séparé à ce sujet. <br><br>  Vous pouvez également automatiser la création (ou la mise à jour) des autorisations en fonction de l'étiquette dans les métadonnées - la création d'un script SQL dynamique qui interdit l'accès à toutes les colonnes confidentielles (GDPR), qui vous permettra de gérer les utilisateurs, les groupes ou les rôlesb.  Je travaillerai sur cette question à l'avenir. <br><br><h2>  <font color="#c30">La disponibilité</font> </h2><br><h4>  <font color="#004d71">Création d'indices renouvelables en temps réel</font> </h4><br>  Dans SQL Server 2017, il est devenu possible de suspendre et de reprendre la reconstruction de l'index en temps réel, ce qui peut être très utile si vous devez modifier le nombre de processeurs utilisés, continuer à partir du moment de la suspension après une panne, ou simplement combler l'écart entre les fenêtres de service.  J'ai parlé de cette fonctionnalité dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> . <br><br>  Dans SQL Server 2019, vous pouvez utiliser la même syntaxe pour créer des index en temps réel, suspendre et continuer, ainsi que pour limiter le temps d'exécution (définir le temps de pause): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar(blat) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">RESUMABLE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, MAX_DURATION = <span class="hljs-number"><span class="hljs-number">10</span></span> MINUTES);</code> </pre> <br>  Si cette requête fonctionne trop longtemps, alors pour faire une pause, vous pouvez exécuter ALTER INDEX dans une autre session (même si l'index n'existe pas encore physiquement): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar PAUSE;</code> </pre> <br>  Dans les versions actuelles, le degré de parallélisme lors du renouvellement ne peut pas être réduit, comme c'est le cas pour la reconstruction.  Lorsque vous essayez de réduire le DOP: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar <span class="hljs-keyword"><span class="hljs-keyword">RESUME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MAXDOP = <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Nous obtenons ce qui suit: <br><br><pre> <code class="hljs pgsql">Msg <span class="hljs-number"><span class="hljs-number">10666</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, State <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">Line</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Cannot resume <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> required DOP <span class="hljs-number"><span class="hljs-number">4</span></span> (DOP operation was started <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> available. Please ensure sufficient DOP <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> available <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span> existing <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> try again. The <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> has been terminated.</code> </pre> <br>  En fait, si vous essayez de le faire, puis exécutez la commande sans paramètres supplémentaires, vous obtiendrez la même erreur, au moins sur les versions actuelles.  Je pense que la tentative de renouvellement a été enregistrée quelque part et que le système a voulu la réutiliser.  Pour continuer, vous devez spécifier la valeur DOP correcte (ou supérieure): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar <span class="hljs-keyword"><span class="hljs-keyword">RESUME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MAXDOP = <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Pour être clair: vous pouvez augmenter le DOP lors de la reprise d'une création d'index interrompue, mais pas la diminuer. <br><br>  Un avantage supplémentaire de tout cela est que vous pouvez configurer la création et / ou le renouvellement d'index en temps réel comme mode par défaut à l'aide des clauses ELEVATE_ONLINE et ELEVATE_RESUMABLE pour la nouvelle base de données. <br><br><h4>  <font color="#004d71">Création / reconstruction en temps réel d'index de colonnes en cluster</font> </h4><br>  En plus de la création d'index renouvelables, nous avons également la possibilité de créer ou de reconstruire des index de colonnes en cluster en temps réel.  Il s'agit d'un changement important, qui vous permet de ne plus consacrer le temps des fenêtres de service à la maintenance de ces indices ou (pour plus de certitude) de convertir les indices de ligne en colonne: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.splunge ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> CLUSTERED <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.splunge(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CLUSTERED COLUMNSTORE <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.splunge <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (DROP_EXISTING = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un avertissement: si un index cluster traditionnel existant a été créé en temps réel, sa conversion en index de colonne cluster n'est également possible que dans ce mode. </font><font style="vertical-align: inherit;">Si elle fait partie de la clé primaire, intégrée ou non ...</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.splunge ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_Splunge PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); GO <span class="hljs-comment"><span class="hljs-comment">-- or after the fact -- ALTER TABLE dbo.splunge ADD CONSTRAINT PK_Splunge PRIMARY KEY CLUSTERED(id);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous obtenons l'erreur suivante: </font></font><br><br><pre> <code class="hljs pgsql">Msg <span class="hljs-number"><span class="hljs-number">1907</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> Cannot recreate <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'PK_Splunge'</span></span>. The <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> definition does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> match the <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> being enforced <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the existing <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez d'abord supprimer la contrainte afin de la convertir en un index de colonne en cluster, mais ces deux opérations peuvent être effectuées en temps réel: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.splunge <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>); GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CLUSTERED COLUMNSTORE <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.splunge <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela fonctionne, mais les grandes tables sont susceptibles de prendre plus de temps que si la clé primaire était implémentée en tant qu'index cluster unique. </font><font style="vertical-align: inherit;">Je ne peux pas dire avec certitude s'il s'agit d'une restriction intentionnelle ou simplement d'une limitation du CTP actuel.</font></font><br><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rediriger une connexion de réplication d'un serveur secondaire vers un serveur principal </font></font><br></font> </h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette fonction vous permet de configurer la redirection sans écouter, vous pouvez donc basculer la connexion vers le serveur principal, même si le secondaire est directement spécifié dans la chaîne de connexion. </font><font style="vertical-align: inherit;">Cette fonction peut être utilisée lorsque la technologie de clustering ne prend pas en charge l'écoute, lors de l'utilisation d'AG sans cluster ou lorsqu'il existe un schéma de redirection complexe dans un scénario avec plusieurs sous-réseaux. </font><font style="vertical-align: inherit;">Cela empêchera la connexion, par exemple, d'essayer d'écrire des opérations de réplication en mode lecture seule (et des échecs, respectivement).</font></font><br><br><h2>  <font color="#c30">Développement</font> </h2><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctions supplémentaires du graphique</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les relations graphiques prennent désormais en charge l'instruction MERGE pour un nœud ou des tables de limites à l'aide de prédicats MERGE; </font><font style="vertical-align: inherit;">Désormais, un opérateur peut mettre à jour une arête existante ou en insérer une nouvelle. </font><font style="vertical-align: inherit;">La nouvelle restriction de bord vous permet de déterminer quels nœuds le bord peut se connecter.</font></font><br><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utf-8</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Server 2012 a ajouté la prise en charge d'UTF-16 et de caractères supplémentaires en définissant le tri en spécifiant un nom avec le suffixe _SC, tel que Latin1_General_100_CI_AI_SC, pour utiliser les colonnes Unicode (nchar / nvarchar). Dans SQL Server 2017, vous pouvez importer et exporter des données UTF-8 depuis et vers ces colonnes à l'aide d'outils tels que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BCP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BULK INSERT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans SQL Server 2019, il existe de nouvelles options de classement pour prendre en charge la rétention forcée des données UTF-8 dans leur forme d'origine. </font><font style="vertical-align: inherit;">Vous pouvez donc facilement créer des colonnes char ou varchar et stocker correctement les données UTF-8 en utilisant le nouveau classement avec le suffixe _SC_UTF8, comme Latin1_General_100_CI_AI_SC_UTF8. </font><font style="vertical-align: inherit;">Cela peut aider à améliorer la compatibilité avec les applications externes et les SGBD, sans coût de traitement et de stockage de nvarchar.</font></font><br><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oeuf de Pâques que j'ai trouvé</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour autant que je m'en souvienne, les utilisateurs de SQL Server se plaignent de ce vague message d'erreur: </font></font><br><br><pre> <code class="hljs vbscript">Msg <span class="hljs-number"><span class="hljs-number">8152</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> binary data would be truncated.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans les versions CTP que j'ai expérimentées, un message d'erreur intéressant a été remarqué qui n'était pas là avant: </font></font><br><br><pre> <code class="hljs pgsql">Msg <span class="hljs-number"><span class="hljs-number">2628</span></span> String <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> binary data would be truncated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'%.*ls'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">'%.*ls'</span></span>. Truncated <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-string"><span class="hljs-string">'%.*ls'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne pense pas que quelque chose d'autre soit nécessaire ici; c'est une grande amélioration (quoique très tardive) qui promet de faire plaisir à beaucoup. Cependant, cette fonctionnalité ne sera pas disponible dans CTP 2.0; Je vous donne juste l'occasion de regarder un peu en avant. Brent Ozar a répertorié tous les nouveaux messages qu'il a trouvés dans le CTP actuel et les a assaisonnés de quelques commentaires utiles dans son article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sys.messages: trouver des fonctionnalités supplémentaires</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  <font color="#c30">Conclusion</font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Server 2019 offre de bonnes fonctionnalités supplémentaires qui aideront à améliorer le travail avec votre plate-forme de base de données relationnelle préférée, et il y a un certain nombre de changements dont je n'ai pas parlé. Mémoire économe en énergie, clustering pour les services d'apprentissage automatique, réplication et transactions distribuées sur Linux, Kubernetes, connecteurs pour Oracle / Teradata / MongoDB, les réplications synchrones AG ont augmenté pour prendre en charge Java (la mise en œuvre est similaire à Python / R) et, tout aussi important, un nouveau saut, intitulé Big Data Cluster. Pour utiliser certaines de ces fonctionnalités, vous devez vous inscrire en utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce formulaire EAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Livre à paraître de Bob Ward, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pro SQL Server sur Linux - Incluant le déploiement basé sur conteneur avec Docker et Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, peut donner quelques indices sur un certain nombre d'autres choses qui arriveront bientôt. </font><font style="vertical-align: inherit;">Et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette publication de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brent Ozar parle d'un éventuel correctif à venir pour une fonction scalaire définie par l'utilisateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais même dans ce premier CTP public, il y a quelque chose d'important pour presque tout le monde, et je vous invite à l'essayer vous-même!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424441/">https://habr.com/ru/post/fr424441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424429/index.html">Science, Art et Son: 4 projets impressionnants</a></li>
<li><a href="../fr424431/index.html">Valve dévoile le classement des contrôleurs de jeux Steam</a></li>
<li><a href="../fr424433/index.html">Pourquoi les pirates Mikrotik et comment j'ai caché 100 000. RouterOS d'un botnet</a></li>
<li><a href="../fr424435/index.html">Zoo de forage pétrolier: mettre les choses en ordre</a></li>
<li><a href="../fr424437/index.html">Orme. Confortable et maladroit. Json.Encoder et Json.Decoder</a></li>
<li><a href="../fr424443/index.html">Vivaldi 2.0 en notre faveur</a></li>
<li><a href="../fr424445/index.html">La traduction par Neil Ford des microservices en tant qu'architecture évolutive</a></li>
<li><a href="../fr424447/index.html">Lisp parfumé avec Pascal ou le langage de programmation 8501st</a></li>
<li><a href="../fr424453/index.html">Apprenez OpenGL. Leçon 6.2 - Rendu basé sur la physique. Sources de lumière analytiques</a></li>
<li><a href="../fr424455/index.html">Intel Optane - maintenant 1,5 téraoctets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>