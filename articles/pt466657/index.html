<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÄ üë©üèª ü§∏üèΩ Detalhes din√¢micos: jogos secretos do compilador, vazamento de mem√≥ria, nuances de desempenho üèòÔ∏è üßöüèæ üàÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preliminares 

 Considere o seguinte c√≥digo: 



//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C91...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detalhes din√¢micos: jogos secretos do compilador, vazamento de mem√≥ria, nuances de desempenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466657/"><h2>  Preliminares </h2><br><br>  Considere o seguinte c√≥digo: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  A assinatura do m√©todo <i>Marshal.FinalReleaseComObject</i> √© a seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalReleaseComObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object o</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br>  Criamos um objeto COM simples, fazemos algum trabalho e o liberamos imediatamente.  Parece que o que poderia dar errado?  Sim, criar um objeto dentro de um loop infinito n√£o √© uma boa pr√°tica, mas o <i>GC</i> far√° todo o trabalho sujo.  A realidade √© um pouco diferente: <br><br><img src="https://habrastorage.org/webt/mt/xo/rx/mtxorxomorvksyskqgtn3b3z7_g.png"><br><br>  Para entender por que a mem√≥ria vaza, voc√™ precisa entender como a <i>din√¢mica</i> funciona.  J√° existem v√°rios artigos sobre esse assunto em Habr√©, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> , mas eles n√£o entram em detalhes de implementa√ß√£o, portanto, conduziremos nossa pr√≥pria pesquisa. <br><br><a name="habracut"></a><br><br>  Primeiro, examinaremos em detalhes o mecanismo de trabalho <i>din√¢mico</i> , reduziremos o conhecimento adquirido em uma √∫nica imagem e, no final, discutiremos as raz√µes desse vazamento e como evit√°-lo.  Antes de mergulhar no c√≥digo, vamos esclarecer os dados de origem: qual combina√ß√£o de fatores leva ao vazamento? <br><br><h2>  Os experimentos </h2><br><br>  Talvez criar muitos objetos <i>COM nativos</i> seja uma m√° id√©ia em si?  Vamos verificar: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); }</span></span></code> </pre> <br><br>  Tudo est√° bem desta vez: <br><br><img src="https://habrastorage.org/webt/l2/x4/01/l2x401f_4vsbrysnx1zctwoyfjk.png"><br><br>  Vamos voltar √† vers√£o original do c√≥digo, mas altere o tipo de objeto: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any managed type include managed COM var type = typeof(int); while (true) { dynamic com = Activator.CreateInstance(type); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  E, novamente, sem surpresas: <br><br><img src="https://habrastorage.org/webt/09/lm/bv/09lmbvpiklt9lo43b1fv9wzhdhu.png"><br><br>  Vamos tentar a terceira op√ß√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject((object) com); }</span></span></code> </pre> <br><br>  Bem, agora, definitivamente devemos ter o mesmo comportamento!  Hein?  N√£o :( <br><br><img src="https://habrastorage.org/webt/uu/2p/l1/uu2pl1_xtrmpc4kuuy3mwdh_7la.png"><br><br>  Uma imagem semelhante ser√° se voc√™ declarar com como um <i>objeto</i> ou se trabalhar com o <i>COM gerenciado</i> .  Resuma os resultados experimentais: <br><br><ol><li>  Instanciar objetos <i>COM nativos</i> por si s√≥ n√£o leva a vazamentos - o <i>GC</i> lida com √™xito com a limpeza de mem√≥ria </li><li>  Ao trabalhar com qualquer classe <i>gerenciada</i> , n√£o ocorrem vazamentos </li><li>  Ao converter explicitamente um objeto para outro, tudo est√° bem tamb√©m </li></ol><br><br>  Olhando para o futuro, podemos adicionar o fato de que trabalhar com objetos <i>din√¢micos</i> (chamar m√©todos ou trabalhar com propriedades) por si s√≥ tamb√©m n√£o causa vazamentos.  A conclus√£o sugere-se: um vazamento de mem√≥ria ocorre quando passamos um objeto <i>din√¢mico</i> (sem convers√£o "manual") contendo <i>COM nativo</i> , como par√¢metro de m√©todo. <br><br><h2>  Precisamos ir mais fundo </h2><br><br>  √â hora de lembrar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que √©</a> essa <i>din√¢mica</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Refer√™ncia r√°pida</b> <div class="spoiler_text"><blockquote>  O C # 4.0 fornece um novo tipo de <b>din√¢mica</b> .  Esse tipo evita a verifica√ß√£o de tipo est√°tico pelo compilador.  Na maioria dos casos, funciona como um tipo de <b>objeto</b> .  Em tempo de compila√ß√£o, sup√µe-se que um elemento declarado como <b>din√¢mico</b> suporte qualquer opera√ß√£o.  Isso significa que voc√™ n√£o precisa pensar sobre a origem do objeto - a partir da API COM, uma linguagem din√¢mica como o IronPython, usando reflex√£o ou de outro lugar.  Al√©m disso, se o c√≥digo for inv√°lido, ser√£o gerados erros em tempo de execu√ß√£o. <br><br>  Por exemplo, se o m√©todo <b>exampleMethod1</b> no c√≥digo a seguir tiver exatamente um par√¢metro, o compilador reconhecer√° que a primeira chamada para o <b>m√©todo ec.exampleMethod1 (10, 4)</b> √© inv√°lida porque cont√©m dois par√¢metros.  Isso resultar√° em um erro de compila√ß√£o.  A segunda chamada de m√©todo, <b>dynamic_ec.exampleMethod1 (10, 4)</b> n√£o <b>√©</b> verificada pelo compilador, pois <b>dynamic_ec √©</b> declarado como <b>din√¢mico</b> , portanto.  n√£o haver√° erros de compila√ß√£o.  No entanto, o erro n√£o passar√° despercebido para sempre - ser√° detectado em tempo de execu√ß√£o. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ExampleClass ec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleClass(); <span class="hljs-comment"><span class="hljs-comment">//      ,  exampleMethod1    . //ec.exampleMethod1(10, 4); dynamic dynamic_ec = new ExampleClass(); //      ,  //      dynamic_ec.exampleMethod1(10, 4); //        ,  //  ,      dynamic_ec.someMethod("some argument", 7, null); dynamic_ec.nonexistentMethod(); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br></blockquote><br></div></div><br><br>  O c√≥digo que usa vari√°veis <i>din√¢micas</i> sofre altera√ß√µes significativas durante a compila√ß√£o.  Este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); Marshal.FinalReleaseComObject(com);</code> </pre> <br><br>  Transforma-se no seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(typeFromClsid); <span class="hljs-comment"><span class="hljs-comment">// ISSUE: reference to a compiler-generated field if (Foo.o__0.p__0 == null) { // ISSUE: reference to a compiler-generated field Foo.o__0.p__0 = CallSite&lt;Action&lt;CallSite, Type, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "FinalReleaseComObject", (IEnumerable&lt;Type&gt;) null, typeof (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null) })); } // ISSUE: reference to a compiler-generated field // ISSUE: reference to a compiler-generated field Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, typeof (Marshal), instance);</span></span></code> </pre> <br><br>  Onde <b>o__0</b> √© a classe est√°tica gerada e <b>p__0</b> √© o campo est√°tico nela: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">o__0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite&lt;Action&lt;CallSite, Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; p__0; }</code> </pre> <br><br>  <i>Nota: para cada intera√ß√£o com <i>din√¢mica</i> , um campo CallSite √© criado.</i>  <i>Isso, como veremos mais adiante, √© necess√°rio para otimizar o desempenho</i> <br><br>  Observe que nenhuma men√ß√£o √† <i>din√¢mica</i> √© deixada - nosso objeto agora est√° armazenado em uma vari√°vel do tipo <i>objeto</i> .  Vamos percorrer o c√≥digo gerado.  Primeiro, √© criada uma liga√ß√£o, que descreve o que e o que estamos fazendo: <br><br><pre> <code class="cs hljs">Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"FinalReleaseComObject"</span></span>, (IEnumerable&lt;Type&gt;) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })</code> </pre> <br><br>  Esta √© uma descri√ß√£o da nossa opera√ß√£o din√¢mica.  Deixe-me lembr√°-lo de que passamos uma vari√°vel <i>din√¢mica</i> para o m√©todo <i>FinalReleaseComObject</i> . <br><br><ul><li>  CSharpBinderFlags.ResultDiscarded - o resultado da execu√ß√£o do m√©todo n√£o √© usado no futuro </li><li>  "FinalReleaseComObject" - o nome do m√©todo chamado </li><li>  typeof (Foo) - contexto de opera√ß√£o;  o tipo de chamada </li></ul><br><br>  <b>CSharpArgumentInfo</b> - descri√ß√£o dos par√¢metros de liga√ß√£o.  No nosso caso: <br><br><ul><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null) - descri√ß√£o do primeiro par√¢metro - a classe Marshal: √© est√°tica e seu tipo deve ser considerado durante a liga√ß√£o </li><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.None, (string) null) - descri√ß√£o do par√¢metro do m√©todo, normalmente n√£o h√° informa√ß√µes adicionais. </li></ul><br><br>  Se n√£o se tratava de chamar um m√©todo, mas de, por exemplo, chamar uma propriedade de um objeto <i>din√¢mico</i> , haveria apenas um <b>CSharpArgumentInfo</b> que descreve o pr√≥prio objeto <i>din√¢mico</i> . <br><br>  <b>CallSite</b> √© um inv√≥lucro sobre uma express√£o din√¢mica.  Ele cont√©m dois campos importantes para n√≥s: <br><br><ul><li>  Atualiza√ß√£o p√∫blica T </li><li>  p√∫blico T Target </li></ul><br><br>  A partir do c√≥digo gerado, fica claro que, quando qualquer opera√ß√£o √© executada, o <b>Target</b> √© chamado com par√¢metros que a descrevem: <br><br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Marshal), instance);</code> </pre> <br><br>  Em conjunto com o <b>CSharpArgumentInfo</b> descrito acima <b>,</b> esse c√≥digo significa o seguinte: voc√™ precisa chamar o m√©todo FinalReleaseComObject na classe est√°tica Marshal com o par√¢metro de inst√¢ncia  No momento da primeira chamada, o mesmo delegado √© armazenado no <b>Target</b> e no <b>Update</b> .  O delegado da <b>atualiza√ß√£o</b> √© respons√°vel por duas tarefas importantes: <br><br><ol><li>  Vincular uma opera√ß√£o din√¢mica a est√°tica (o pr√≥prio mecanismo de licita√ß√£o est√° al√©m do escopo deste artigo) </li><li>  Forma√ß√£o de cache </li></ol><br><br>  Estamos interessados ‚Äã‚Äãno segundo ponto.  Deve-se notar aqui que, ao trabalhar com um objeto din√¢mico, precisamos verificar a validade da opera√ß√£o a cada vez.  Essa √© uma tarefa que consome muitos recursos, ent√£o quero armazenar em cache os resultados dessas verifica√ß√µes.  No que diz respeito √† chamada de um m√©todo com um par√¢metro, precisamos lembrar o seguinte: <br><br><ol><li>  O tipo no qual o m√©todo √© chamado </li><li>  O tipo de objeto transmitido pelo par√¢metro (para garantir que ele possa ser convertido para o tipo do par√¢metro) </li><li>  A opera√ß√£o √© v√°lida </li></ol><br><br>  Ent√£o, ao chamar <b>Target</b> novamente, n√£o precisamos executar liga√ß√µes relativamente caras: basta comparar os tipos e, se corresponderem, chamar a fun√ß√£o objetivo.  Para resolver esse problema, um <i>ExpressionTree</i> √© criado para cada opera√ß√£o din√¢mica, que armazena as <i>restri√ß√µes</i> e a <i>fun√ß√£o objetivo</i> √† qual a express√£o din√¢mica foi vinculada. <br><br>  Esta fun√ß√£o pode ser de dois tipos: <br><br><ul><li>  <i>Erro de liga√ß√£o</i> : por exemplo, um m√©todo √© chamado em um objeto <i>din√¢mico</i> que n√£o existe ou um objeto <i>din√¢mico</i> n√£o pode ser convertido no tipo de par√¢metro para o qual √© passado: √© necess√°rio lan√ßar uma exce√ß√£o como <i>Microsoft.CSharp.RuntimeBinderException: 'NoSuchMember'</i> </li><li>  O desafio √© legal: basta executar a a√ß√£o necess√°ria </li></ul><br><br>  Essa <i>ExpressionTree</i> √© formada durante a execu√ß√£o <b>do</b> delegado <b>Update</b> e armazenada no <b>Target</b> .  <b>Alvo</b> - cache <i>L0</i> , falaremos mais sobre o cache mais tarde. <br><br>  Portanto, o <b>Target</b> armazena o √∫ltimo <i>ExpressionTree</i> gerado pelo delegado <b>Update</b> .  Vamos ver como essa <i>regra se</i> parece com um exemplo de um tipo <i>gerenciado</i> passado para o m√©todo <i>Boo</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> instance = Activator.CreateInstance(type); Boo(instance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso ($arg1 TypeEqual Int32)), returnUnamedLabel_0 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  O bloco mais importante para n√≥s: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32)</code> </pre> <br><br>  <i>$$ arg0</i> e <i>$$ arg1</i> s√£o os par√¢metros com os quais o <b>Target</b> √© chamado: <br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;);</code> </pre> <br><br>  Traduzido para humano, isso significa o seguinte: <br><br>  J√° verificamos que, se o primeiro par√¢metro for do tipo <i>Foo</i> e o segundo for <i>Int32</i> , voc√™ poder√° chamar com seguran√ßa o <i>Boo ((objeto) $$ arg1)</i> . <br><br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) }</span></span></code> </pre> <br><br>  <i>Nota: no caso de um erro de liga√ß√£o, o bloco Label1 se parece com isso:</i> <br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Throw .New Microsoft.CSharp.RuntimeBinderException("NoSuchMember")</span></span></code> </pre> <br><br>  Essas verifica√ß√µes s√£o chamadas de <b>restri√ß√µes</b> .  <b>Existem</b> dois tipos de <b>restri√ß√µes</b> : por tipo de objeto e por inst√¢ncia espec√≠fica do objeto (o objeto deve ser exatamente o mesmo).  Se pelo menos uma das restri√ß√µes falhar, teremos que verificar novamente a express√£o din√¢mica quanto √† validade, para isso chamaremos o delegado de <b>Atualiza√ß√£o</b> .  De acordo com o esquema j√° conhecido, ele executar√° a liga√ß√£o com novos tipos e salvar√° o novo <i>ExpressionTree</i> no <b>Target</b> . <br><br><h2>  Cache </h2><br><br>  J√° descobrimos que o <b>destino</b> √© um <b>cache L0</b> .  Cada vez que o <b>Target</b> √© chamado, a primeira coisa a fazer √© passar pelas restri√ß√µes j√° armazenadas nele.  Se as restri√ß√µes falharem e uma nova liga√ß√£o for gerada, a regra antiga ser√° simultaneamente para <b>L1</b> e <b>L2</b> .  No futuro, quando voc√™ perder o cache <i>L0</i> , as regras de <i>L1</i> e <i>L2</i> ser√£o pesquisadas at√© encontrar uma adequada. <br><br><ul><li>  <i>L1</i> : As √∫ltimas dez regras que deixaram <i>L0</i> (armazenadas diretamente no <i>CallSite</i> ) </li><li>  <i>L2</i> : As √∫ltimas 128 regras criadas usando uma inst√¢ncia espec√≠fica do fich√°rio (que √© <i>CallSiteBinder</i> , exclusiva para cada <i>CallSite</i> ) </li></ul><br><br>  Agora, finalmente, podemos adicionar esses detalhes em um √∫nico todo e descrever na forma de um algoritmo o que acontece quando <i>Foo.Bar (someDynamicObject) √© chamado</i> : <br><br>  1. √â criado um fich√°rio que lembra o contexto e o m√©todo chamado no n√≠vel de suas assinaturas <br><br>  2. Na primeira vez que a opera√ß√£o √© chamada, <i>ExpressionTree</i> √© criado, que armazena: <br>  2.1 <b>Limita√ß√µes</b> .  Nesse caso, haver√° duas restri√ß√µes no tipo de par√¢metros de liga√ß√£o atuais <br>  2.2 <b>Fun√ß√£o objetivo</b> : ou <i>lan√ßar alguma exce√ß√£o</i> (neste caso, √© imposs√≠vel, pois qualquer <i>din√¢mica</i> levar√° com sucesso ao objeto) ou uma chamada ao m√©todo <i>Bar</i> <br><br>  3. Compile e execute o ExpressionTree resultante <br><br>  4. Quando voc√™ recorda a opera√ß√£o, duas op√ß√µes s√£o poss√≠veis: <br>  4.1 <b>Limita√ß√µes trabalhadas</b> : basta chamar <i>Bar</i> <br>  4.2 As <b>limita√ß√µes n√£o funcionaram</b> : repita a etapa 2 para novos par√¢metros de liga√ß√£o <br><br>  Portanto, com o exemplo do tipo <i>Gerenciado</i> , ficou aproximadamente claro como a <i>din√¢mica</i> funciona por dentro.  No caso descrito, nunca perderemos o cache, pois os tipos s√£o sempre os mesmos *, portanto, <b>Update ser√°</b> chamado exatamente uma vez quando o <i>CallSite for</i> inicializado.  Ent√£o, para cada chamada, apenas restri√ß√µes ser√£o verificadas e a fun√ß√£o objetivo ser√° chamada imediatamente.  Isso est√° de acordo com nossas observa√ß√µes da mem√≥ria: sem c√°lculo - sem vazamentos. <br><br>  <i>* Por esse motivo, o compilador gera seus CallSites para cada um: a probabilidade de perder o cache L0 √© extremamente reduzida</i> <br><br>  √â hora de descobrir como esse esquema difere no caso de objetos <i>COM nativos</i> .  Vamos dar uma olhada no <i>ExpressionTree</i> : <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 }) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.__ComObject)$$arg1); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso {var Param_0; ... }), returnUnamedLabel_1 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Pode-se ver que a diferen√ßa est√° apenas na segunda restri√ß√£o: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 })</code> </pre> <br><br>  Se, no caso do c√≥digo <i>gerenciado</i> , tiv√©ssemos duas restri√ß√µes no tipo de objetos, aqui vemos que a segunda restri√ß√£o verifica a equival√™ncia de inst√¢ncias por meio de <i>WeakReference</i> . <br><br>  <i>Nota: A restri√ß√£o de inst√¢ncia, al√©m dos objetos COM, tamb√©m √© usada para o TransparentProxy</i> <br><br>  Na pr√°tica, com base no nosso conhecimento da opera√ß√£o do cache, isso significa que toda vez que recriarmos um objeto <i>COM</i> em um loop, perderemos o cache <i>L0</i> (e <i>L1 / L2</i> tamb√©m, porque as regras antigas com links ser√£o armazenadas l√° para inst√¢ncias antigas).  A primeira suposi√ß√£o que voc√™ pergunta na cabe√ßa √© que o cache de regras est√° fluindo.  Mas o c√≥digo √© bem simples e est√° tudo bem: as regras antigas s√£o exclu√≠das corretamente.  Ao mesmo tempo, o uso de <i>WeakReference</i> no <i>ExpressionTree</i> n√£o impede que o <i>GC</i> <i>colete</i> objetos desnecess√°rios. <br><br>  <i>O mecanismo para salvar regras no cache L1:</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxRules = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T newRule</span></span></span><span class="hljs-function">)</span></span> { T[] rules = Rules; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { newRule }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } T[] temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules.Length &lt; (MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[rules.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, rules.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[MaxRules]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>); } temp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newRule; Rules = temp; }</code> </pre> <br><br>  Ent√£o, qual √© o problema?  Vamos tentar esclarecer a hip√≥tese: um vazamento de mem√≥ria ocorre em algum lugar ao vincular um objeto <i>COM</i> . <br><br><h2>  Experi√™ncias, parte 2 </h2><br><br>  Novamente, vamos passar de conclus√µes especulativas para experimentos.  Primeiro, vamos repetir o que o compilador faz por n√≥s: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); var autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "Boo", null, typeof(Foo), new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }); var callSite = CallSite&lt;Action&lt;CallSite, Foo, object&gt;&gt;.Create(autogeneratedBinder); while (true) { object instance = Activator.CreateInstance(comType); callSite.Target(callSite, this, instance); }</span></span></code> </pre> <br><br>  Verificamos: <br><br><img src="https://habrastorage.org/webt/bf/-u/k6/bf-uk6jtzrfh8_pyzaagi0p8cr4.png"><br><br>  O vazamento foi preservado.  Justo.  Mas qual o motivo?  Depois de estudar o c√≥digo dos fich√°rios (que deixamos entre colchetes), fica claro que a √∫nica coisa que afeta o tipo de nosso objeto √© a op√ß√£o de restri√ß√£o.  Talvez isso n√£o seja uma quest√£o de objetos <i>COM</i> , mas um fich√°rio?  N√£o h√° muitas op√ß√µes, vamos provocar v√°rias liga√ß√µes para o tipo <i>gerenciado</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"Boo"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Foo), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callSite = CallSite&lt;Action&lt;CallSite, Foo, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(autogeneratedBinder); callSite.Target(callSite, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, instance); }</code> </pre> <br><br><img src="https://habrastorage.org/webt/-y/an/hj/-yanhjj9jkmqr8bl2adf9rvjsvs.png"><br><br>  Uau!  Parece que o pegamos.  O problema n√£o √© de todo com o <i>objeto COM</i> , como nos pareceu inicialmente, apenas por causa das limita√ß√µes da inst√¢ncia, este √© o √∫nico caso em que a liga√ß√£o ocorre muitas vezes dentro do nosso loop.  Em todos os outros casos, peguei o <i>cache L0</i> e vinculei uma vez. <br><br><h2>  Conclus√µes </h2><br><br><h3>  Vazamento de mem√≥ria </h3><br><br>  Se voc√™ trabalha com vari√°veis <i>din√¢micas</i> que cont√™m <i>COM nativo</i> ou <i>TransparentProxy</i> , nunca as passe como par√¢metros de m√©todo.  Se voc√™ ainda precisar fazer isso, use a convers√£o expl√≠cita para <i>objetar</i> e o compilador ficar√° para tr√°s. <br><br>  <b>Errado</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject(com);</span></span></code> </pre> <br><br>  <b>Corretamente</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject((object) com);</span></span></code> </pre><br><br>  Como precau√ß√£o adicional, tente instanciar esses objetos o mais raramente poss√≠vel.  Real para todas as vers√µes do <i>.NET Framework</i> .  (Por enquanto) n√£o √© muito relevante para.  <i>NET Core</i> , pois n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h√° suporte para</a> objetos <i>COM din√¢micos</i> . <br><br><h3>  Desempenho </h3><br><br>  √â do seu interesse que as falhas de cache ocorram o mais raramente poss√≠vel, pois nesse caso n√£o h√° necessidade de encontrar uma regra adequada nos caches de alto n√≠vel.  As falhas no cache <i>L0</i> ocorrer√£o principalmente no caso de uma incompatibilidade do tipo de objeto <i>din√¢mico</i> com as restri√ß√µes preservadas. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = GetSomeObject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//:      //:         }</span></span></code> </pre> <br><br>  No entanto, na pr√°tica, voc√™ provavelmente n√£o notar√° a diferen√ßa no desempenho, a menos que o n√∫mero de chamadas para essa fun√ß√£o seja medido em milh√µes ou se a variabilidade de tipos n√£o for extraordinariamente grande.  Os custos em caso de <i>perda</i> no cache <i>L0</i> s√£o tais, <i>N</i> √© o n√∫mero de tipos: <br><br><ul><li>  <i>N</i> &lt;10.  Se voc√™ errar, repita apenas as regras de cache <i>L1</i> existentes </li><li>  10 &lt; <i>N &lt;128</i> .  Enumera√ß√£o de cache <i>L1</i> e <i>L2</i> (m√°ximo de 10 e <i>N</i> itera√ß√µes).  Criando e preenchendo uma matriz de 10 elementos </li><li>  <i>N</i> &gt; 128.  Repita o cache <i>L1</i> e <i>L2</i> .  Crie e preencha matrizes de 10 e 128 elementos.  Se voc√™ perder o cache <i>L2</i> , volte a ligar </li></ul><br><br>  No segundo e terceiro casos, a carga no GC aumentar√°. <br><br><h2>  Conclus√£o </h2><br><br>  Infelizmente, n√£o encontramos um motivo real para o vazamento de mem√≥ria, isso exigir√° um estudo separado do fich√°rio.  Felizmente, o <i>WinDbg</i> fornece uma dica para uma investiga√ß√£o mais aprofundada: algo ruim acontece no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DLR</a> .  A primeira coluna √© o n√∫mero de objetos <br><br><img src="https://habrastorage.org/webt/n_/6g/xf/n_6gxf7etpsj2fg17odfa0varvy.png"><br><br><h2>  B√¥nus </h2><br><br>  <b>Por que a convers√£o de <i>objetos</i> evita explicitamente um vazamento?</b> <br>  Qualquer tipo pode ser convertido em <i>objeto</i> , portanto, a opera√ß√£o deixa de ser din√¢mica. <br><br>  <b>Por que n√£o h√° vazamentos ao trabalhar com campos e m√©todos de um objeto COM?</b> <br>  √â assim que o <i>ExpressionTree se</i> parece com o acesso ao campo: <br><br><pre> <code class="cs hljs">.If ( .Call System.Dynamic.ComObject.IsComObject($$arg0) ) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Dynamic GetMember ComMarks(.Call System.Dynamic2.ComObject.ObjectToComObject($$arg0)) } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466657/">https://habr.com/ru/post/pt466657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466643/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel n¬∫ 314 (de 2 a 8 de setembro)</a></li>
<li><a href="../pt466647/index.html">Telefone para um cavalo e orquestra sem pianista. Como elaborar tarefas esportivas no front-end</a></li>
<li><a href="../pt466649/index.html">Fim de semana em carro el√©trico</a></li>
<li><a href="../pt466651/index.html">Escolhendo entre XML e SQL para rolar scripts LiquiBase usando Java / Spring / H2 como exemplo</a></li>
<li><a href="../pt466653/index.html">Depurando jogos para NES: como isso acontece hoje</a></li>
<li><a href="../pt466659/index.html">Revis√£o do Kubecost para economizar dinheiro no Kubernetes nas nuvens</a></li>
<li><a href="../pt466661/index.html">Mestrado a Dist√¢ncia no Exterior: Notas Antes da Tese</a></li>
<li><a href="../pt466663/index.html">Experimentos simples com o microcontrolador STM32F103 (Blue Tablet)</a></li>
<li><a href="../pt466665/index.html">Estouro de CSS e perda de dados</a></li>
<li><a href="../pt466667/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 379 (2 a 8 de setembro de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>