<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📞 🗿 ✌🏽 KVM (di bawah) VDI dengan mesin virtual satu kali menggunakan bash 👨‍👩‍👧 🔝 👧🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk siapa artikel ini? 
 Artikel ini mungkin menarik bagi administrator sistem yang dihadapkan dengan tugas menciptakan layanan pekerjaan "satu kali...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>KVM (di bawah) VDI dengan mesin virtual satu kali menggunakan bash</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462203/"><h4>  Untuk siapa artikel ini? </h4><br>  Artikel ini mungkin menarik bagi administrator sistem yang dihadapkan dengan tugas menciptakan layanan pekerjaan "satu kali". <br><br><h4>  Prolog </h4><br>  Departemen dukungan TI dari perusahaan muda yang berkembang secara dinamis dengan jaringan regional kecil diminta untuk mengatur "stasiun layanan mandiri" untuk digunakan oleh klien eksternal mereka.  Data stasiun seharusnya digunakan untuk pendaftaran di portal eksternal perusahaan, mengunduh data dari perangkat eksternal, dan bekerja dengan portal pemerintah. <br><br>  Aspek penting adalah kenyataan bahwa sebagian besar perangkat lunak "diasah" untuk MS Windows (misalnya, "Deklarasi"), dan meskipun ada gerakan menuju format terbuka, MS Office tetap menjadi standar dominan dalam pertukaran dokumen elektronik.  Dengan demikian, kami tidak dapat menolak MS Windows saat memecahkan masalah ini. <br><a name="habracut"></a><br>  Masalah utama adalah kemungkinan mengumpulkan berbagai data dari sesi pengguna, yang dapat menyebabkan kebocoran ke pihak ketiga.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situasi ini telah mengecewakan MFC</a> .  Tetapi tidak seperti MFC (lembaga otonom negara) semu-yudisial, organisasi non-negara akan dihukum lebih banyak karena kekurangan tersebut.  Masalah kritis berikutnya adalah persyaratan untuk bekerja dengan media penyimpanan eksternal, yang, dengan segala cara, akan ada banyak malware jahat.  Kemungkinan masuknya malware dari Internet dianggap kecil kemungkinannya karena pembatasan akses ke Internet melalui daftar putih alamat. Karyawan dari departemen lain bergabung dalam mengerjakan persyaratan, membuat persyaratan dan keinginan mereka, persyaratan akhir tampak sebagai berikut: <br><br>  <b>Persyaratan IS</b> <br><br><ul><li>  Setelah digunakan, semua data pengguna (termasuk file sementara dan kunci registri) harus dihapus. </li><li>  Semua proses yang diluncurkan oleh pengguna harus diselesaikan pada akhir pekerjaan. </li><li>  Akses internet melalui daftar alamat putih. </li><li>  Batasan pada kemampuan untuk menjalankan kode pihak ketiga. </li><li>  Jika sesi idle selama lebih dari 5 menit, sesi harus diakhiri secara otomatis, stasiun harus melakukan pembersihan. </li></ul><br>  <b>Persyaratan pelanggan</b> <br><br><ul><li>  Jumlah stasiun klien per cabang tidak lebih dari 4. </li><li>  Waktu tunggu minimum untuk kesiapan sistem, mulai dari saat "duduk di kursi" hingga mulai bekerja dengan perangkat lunak klien. </li><li>  Kemampuan untuk menghubungkan perangkat periferal (pemindai, flash drive) secara langsung dari situs instalasi "stasiun swalayan." </li><li>  Keinginan pelanggan </li><li>  Peragaan materi iklan (gambar) pada saat penutupan kompleks. </li></ul><cut></cut><br><h4>  Tepung kreativitas </h4><br>  Setelah bermain cukup dengan Windows livecd, kami sampai pada kesimpulan dengan suara bulat bahwa solusi yang dihasilkan tidak memenuhi setidaknya 3 poin kritis.  Mereka dimuat untuk waktu yang lama, atau tidak cukup hidup, atau kustomisasi mereka dikaitkan dengan rasa sakit liar.  Mungkin kami mencari dengan buruk, dan Anda dapat menyarankan satu set beberapa alat, saya akan berterima kasih. <br><br>  Lebih jauh kami mulai melihat ke arah VDI, tetapi untuk tugas ini, sebagian besar solusi terlalu mahal atau membutuhkan perhatian.  Dan saya ingin alat sederhana dengan jumlah minimal sihir, sebagian besar masalah yang dapat diselesaikan dengan hanya me-reboot / memulai kembali layanan.  Untungnya, kami memiliki peralatan server, kelas low-end di cabang-cabang, dari layanan yang dinonaktifkan, yang dapat kami gunakan untuk basis teknologi. <br><br>  Apa hasilnya?  Tapi saya tidak akan bisa memberi tahu Anda apa yang terjadi pada akhirnya, karena NDA, tetapi dalam proses pencarian, kami mengembangkan skema menarik yang menunjukkan dirinya dengan baik dalam tes laboratorium, meskipun tidak masuk ke seri. <br><br>  Beberapa penafian: penulis tidak mengklaim bahwa solusi yang diusulkan sepenuhnya menyelesaikan semua tugas dan melakukannya secara sukarela dan dengan lagu tersebut.  Penulis setuju sebelumnya dengan pernyataan bahwa Sein Englishe sprache adalah zehr schlecht.  Karena solusi tidak lagi berkembang, Anda tidak dapat mengandalkan perbaikan bug atau perubahan fungsionalitas, semuanya ada di tangan Anda.  Penulis berasumsi bahwa Anda setidaknya sedikit terbiasa dengan KVM dan membaca artikel ulasan tentang protokol Spice, dan Anda bekerja sedikit dengan Centos atau distribusi GNU Linux lainnya. <br><br>  Pada artikel ini, saya ingin menganalisis tulang punggung dari solusi yang dihasilkan, yaitu interaksi klien dan server dan esensi dari proses pada siklus hidup mesin virtual dalam kerangka solusi yang dimaksud.  Jika artikel itu akan menarik bagi publik, saya akan menjelaskan detail penerapan gambar langsung untuk membuat klien tipis berdasarkan Fedora dan menceritakan tentang detail penyetelan mesin virtual dan server KVM untuk mengoptimalkan kinerja dan keamanan. <br><br>  Jika Anda mengambil kertas berwarna, <br>  Cat, kuas dan lem, <br>  Dan ketangkasan sedikit lebih ... <br>  Anda dapat membuat seratus rubel! <br><br><h4>  Skema dan deskripsi bangku tes </h4><br><img src="https://habrastorage.org/webt/pu/tu/rk/puturkaiwqcpbp4wld7ezdk_lcw.png"><br><br>  Semua peralatan terletak di dalam jaringan cabang, hanya saluran Internet yang mati.  Secara historis, sudah ada server proxy, tidak ada yang luar biasa.  Tetapi ada di atasnya, antara lain, bahwa lalu lintas dari mesin virtual akan disaring (abbr. VM nanti dalam teks).  Tidak ada yang mencegah menempatkan layanan ini di server KVM, satu-satunya hal yang perlu Anda perhatikan adalah bagaimana beban dari itu pada subsistem disk berubah. <br><br>  Stasiun Klien - pada kenyataannya, "stasiun swalayan", "ujung depan" dari layanan kami.  Adalah nettop dari Lenovo IdeaCentre.  Apa gunanya unit ini?  Ya, hampir semua orang, terutama senang dengan sejumlah besar konektor USB dan pembaca kartu di panel depan.  Dalam skema kami, kartu SD dengan perlindungan penulisan perangkat keras dimasukkan ke dalam pembaca kartu, di mana gambar langsung yang dimodifikasi dari Fedora 28 direkam. Tentu saja, monitor, keyboard, dan mouse terhubung ke nettop. <br><br>  Switch - saklar perangkat keras biasa-biasa saja dari tingkat kedua, ada di ruang server dan berkedip dengan lampu.  Itu tidak terhubung ke jaringan apa pun kecuali jaringan "stasiun swalayan". <br><br>  KVM_Server adalah inti dari rangkaian, dalam tes bangku dari Core 2 Quad Q9650 dengan 8 GB RAM, dengan percaya diri menarik 3 mesin virtual Windows 10 pada dirinya sendiri.  Subsistem disk - adaptec 3405 2 drive Raid 1 + SSD.  Dalam uji coba lapangan Xeon 1220, SSD LSI 9260 + yang lebih serius dengan mudah menarik 5-6 VM.  Kami akan mendapatkan server dari layanan pensiunan, tidak akan ada banyak biaya modal.  Sistem virtualisasi KVM dengan pool_Vm pool mesin virtual digunakan pada server ini. <br><br>  Vm adalah mesin virtual, backend dari layanan kami.  Ini adalah pekerjaan pengguna. <br><br>  Enp5s0 adalah antarmuka jaringan yang melihat ke arah jaringan "stasiun swalayan", dhcpd, ntpd, httpd secara langsung, dan xinetd mendengarkan port "sinyal". <br><br>  Lo0 adalah loopback pseudo-interface.  Standar <br><br>  Spice_console - Suatu hal yang sangat menarik, faktanya adalah bahwa, tidak seperti RDP klasik, ketika Anda memutar bundel protokol KVM + Spice, entitas tambahan muncul - port konsol mesin virtual.  Faktanya, dengan menghubungkan ke port TCP ini, kita mendapatkan konsol Vm, tanpa perlu terhubung ke Vm melalui antarmuka jaringannya.  Semua interaksi dengan Vm untuk transmisi sinyal, server mengambil alih.  Fungsi analog terdekat adalah IPKVM.  Yaitu  Gambar monitor VM ditransfer ke port ini, data pergerakan mouse ditransmisikan ke sana, dan (paling penting) interaksi melalui protokol Spice memungkinkan Anda mengarahkan perangkat USB ke mesin virtual, seolah-olah perangkat ini terhubung ke Vm sendiri.  Diuji untuk flash drive, scanner, webcam. <br><br>  Kartu jaringan Vnet0, virbr0 dan virtual Vm membentuk jaringan mesin virtual. <br><br><h4>  Bagaimana cara kerjanya </h4><br>  Dari Stasiun Klien <br><br>  Stasiun klien melakukan booting dalam mode grafis dari gambar langsung yang dimodifikasi dari Fedora 28, menerima alamat ip oleh dhcp dari ruang alamat jaringan 169.254.24.0/24.  Selama proses boot, aturan firewall dibuat yang memungkinkan koneksi ke port server "sinyal" dan "rempah-rempah".  Setelah pengunduhan selesai, stasiun menunggu otorisasi dari pengguna Klien.  Setelah otorisasi pengguna, manajer desktop "openbox" diluncurkan dan script autostart autostart dijalankan atas nama pengguna yang berwenang.  Antara lain, skrip autorun menjalankan skrip remote.sh. <br><br><div class="spoiler">  <b class="spoiler_title">$ HOME / .config / openbox / scripts / remote.sh</b> <div class="spoiler_text"><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh server_ip=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "server_ip" \ |/usr/bin/cut -d "=" -f2) vdi_signal_port=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "vdi_signal_port" \ |/usr/bin/cut -d "=" -f2) vdi_spice_port=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "vdi_spice_port" \ |/usr/bin/cut -d "=" -f2) animation_folder=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "animation_folder" \ |/usr/bin/cut -d "=" -f2) process=/usr/bin/remote-viewer while true do if [ -z `/usr/bin/pidof feh` ] then /usr/bin/echo $animation_folder /usr/bin/feh -N -x -D1 $animation_folder &amp; else /usr/bin/echo fi /usr/bin/nc -i 1 $server_ip $vdi_signal_port |while read line do if /usr/bin/echo "$line" |/usr/bin/grep "RULE ADDED, CONNECT NOW!" then /usr/bin/killall feh pid_process=$($process "spice://$server_ip:$vdi_spice_port" \ "--spice-disable-audio" "--spice-disable-effects=animation" \ "--spice-preferred-compression=auto-glz" "-k" \ "--kiosk-quit=on-disconnect" | /bin/echo $!) /usr/bin/wait $pid_process /usr/bin/killall -u $USER exit else /usr/bin/echo $line &gt;&gt; /var/log/remote.log fi done done</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/client.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs">server_ip=169.254.24.1 vdi_signal_port=5905 vdi_spice_port=5906 animation_folder=/usr/share/backgrounds/animation background_folder=/usr/share/backgrounds2/fedora-workstation</code> </pre><br></div></div><br>  Deskripsi variabel file client.conf <br>  server_ip - address KVM_Server <br>  vdi_signal_port - port KVM_Server tempat xinetd "duduk" <br>  vdi_spice_port - port jaringan KVM_Server, dari mana permintaan koneksi akan dialihkan dari klien remote-viewer ke port rempah-rempah dari Vm yang dipilih (detail di bawah) <br>  animation_folder - folder tempat pengambilan gambar untuk animasi omong kosong demonstrasi <br>  background_folder - folder tempat pengambilan gambar untuk presentasi siaga.  Lebih lanjut tentang animasi di bagian artikel selanjutnya. <br><br>  Script remote.sh mengambil pengaturan dari file konfigurasi /etc/client.conf dan menggunakan nc untuk terhubung ke port "vdi_signal_port" dari server KVM dan menerima aliran data dari server, di antaranya ia mengharapkan string "ATURAN DITAMBAHKAN, TERHUBUNG SEKARANG".  Ketika baris yang diinginkan diterima, proses remote-viewer dimulai dalam mode kios, membangun koneksi ke port server “vdi_spice_port”.  Eksekusi skrip ditangguhkan hingga akhir eksekusi remote-viewer. <br><br>  Remote-viewer menghubungkan ke port "vdi_spice_port", karena pengalihan di sisi server, sampai ke port "spice_console" dari antarmuka lo0 yaitu  ke konsol mesin virtual dan pekerjaan pengguna dilakukan secara langsung.  Sambil menunggu koneksi, pengguna ditampilkan animasi omong kosong, dalam bentuk tayangan slide file jpeg, jalur ke direktori dengan gambar ditentukan oleh nilai variabel animation_folder dari file konfigurasi. <br><br>  Jika koneksi ke port "spice_console" dari mesin virtual terputus, yang menandakan shutdown / reboot mesin virtual (yaitu, akhir sebenarnya dari sesi pengguna), semua proses yang berjalan atas nama pengguna yang sah diakhiri, yang mengarah ke restart lightdm dan kembali ke layar otorisasi . <br><br><h4>  Dari sisi Server KVM </h4><br>  Pada port "sinyal" kartu jaringan, enp5s0 sedang menunggu koneksi xinetd.  Setelah menyambungkan ke port "sinyal", xinetd menjalankan skrip vm_manager.sh tanpa meneruskan parameter input apa pun ke sana dan mengalihkan hasil skrip ke sesi nc di Stasiun Klien. <br><br><div class="spoiler">  <b class="spoiler_title">/etc/xinetd.d/test-server</b> <div class="spoiler_text"><pre> <code class="bash hljs">service vdi_signal { port = 5905 socket_type = stream protocol = tcp <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> = no user = root server = /home/admin/scripts_vdi_new/vm_manager.sh }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_manager.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/sh #&lt;SET LOCAL VARIABLES FOR SCRIPT&gt;# SRV_SCRIPTS_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_scripts_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR" export SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR SRV_POOL_SIZE=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_pool_size" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_POOL_SIZE=$SRV_POOL_SIZE" export "SRV_POOL_SIZE=$SRV_POOL_SIZE" SRV_START_PORT_POOL=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_start_port_pool" |/usr/bin/cut -d "=" -f2) /usr/bin/echo SRV_START_PORT_POOL=$SRV_START_PORT_POOL export SRV_START_PORT_POOL=$SRV_START_PORT_POOL SRV_TMP_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_tmp_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_TMP_DIR=$SRV_TMP_DIR" export SRV_TMP_DIR=$SRV_TMP_DIR date=$(/usr/bin/date) #&lt;/SET LOCAL VARIABLES FOR SCRIPT&gt;# /usr/bin/echo "# $date START EXECUTE VM_MANAGER.SH #" make_connect_to_vm() { #&lt;READING CLEAR.LIST AND CHECK PORT FOR NETWORK STATE&gt;# /usr/bin/echo "READING CLEAN.LIST AND CHECK PORT STATE" #&lt;CHECK FOR NO ONE PORT IN CLEAR.LIST&gt;# if [ -z `/usr/bin/cat $SRV_TMP_DIR/clear.list` ] then /usr/bin/echo "NO AVALIBLE PORTS IN CLEAN.LIST FOUND" /usr/bin/echo "Will try to make housekeeper, and create new vm" make_housekeeper else #&lt;MINIMUN ONE PORT IN CLEAR.LIST FOUND&gt;# /usr/bin/cat $SRV_TMP_DIR/clear.list |while read line do clear_vm_port=$(($line)) /bin/echo "FOUND PORT $clear_vm_port IN CLEAN.LIST. TRY NETSTAT" \ "CHECK FOR PORT=$clear_vm_port" #&lt;NETSTAT LISTEN CHECK FOR PORT FROM CLEAN.LIST&gt;# if /usr/bin/netstat -lnt |/usr/bin/grep ":$clear_vm_port" &gt; /dev/null then /bin/echo "$clear_vm_port IS LISTEN" #&lt;PORT IS LISTEN. CHECK FOR IS CONNECTED NOW&gt;# if /usr/bin/netstat -nt |/usr/bin/grep ":$clear_vm_port" \ |/usr/bin/grep "ESTABLISHED" &gt; /dev/null then #&lt;PORT LISTEN AND ALREADY CONNECTED! MOVE PORT FROM CLEAR.LIST # TO WASTE.LIST&gt;# /bin/echo "$clear_vm_port IS ALREADY CONNECTED, MOVE PORT TO WASTE.LIST" /usr/bin/sed -i "/$clear_vm_port/d" $SRV_TMP_DIR/clear.list /usr/bin/echo $clear_vm_port &gt;&gt; $SRV_TMP_DIR/waste.list else #&lt;PORT LISTEN AND NO ONE CONNECT NOW. MOVE PORT FROM CLEAR.LIST TO # CONN_WAIT.LIST AND CREATE IPTABLES RULES&gt;## /usr/bin/echo "OK, $clear_vm_port IS NOT ALREADY CONNECTED" /usr/bin/sed -i "/$clear_vm_port/d" $SRV_TMP_DIR/clear.list /usr/bin/echo $clear_vm_port &gt;&gt; $SRV_TMP_DIR/conn_wait.list $SRV_SCRIPTS_DIR/vm_connect.sh $clear_vm_port #&lt;TRY TO CLEAN VM IN WASTE.LIST AND CREATE NEW WM&gt;# /bin/echo "TRY TO CLEAN VM IN WASTE.LIST AND CREATE NEW VM" make_housekeeper /usr/bin/echo "# $date STOP EXECUTE VM_MANAGER.SH#" exit fi else #&lt;PORT IS NOT A LISTEN. MOVE PORT FROM CLEAR.LIST TO WASTE.LIST&gt;# /bin/echo " "$clear_vm_port" is NOT LISTEN. REMOVE PORT FROM CLEAR.LIST" /usr/bin/sed -i "/$clear_vm_port/d" $SRV_TMP_DIR/clear.list /usr/bin/echo $clear_vm_port &gt;&gt; $SRV_TMP_DIR/waste.list make_housekeeper fi done fi } make_housekeeper() { /usr/bin/echo "=Execute housekeeper=" /usr/bin/cat $SRV_TMP_DIR/waste.list |while read line do /usr/bin/echo "$line" if /usr/bin/netstat -lnt |/usr/bin/grep ":$line" &gt; /dev/null then /bin/echo "port_alive, vm is running" if /usr/bin/netstat -nt |/usr/bin/grep ":$line" \ |/usr/bin/grep "ESTABLISHED" &gt; /dev/null then /bin/echo "port_in_use can't delete vm!!!" else /bin/echo "port_not in use. Deleting vm" /usr/bin/sed -i "/$line/d" $SRV_TMP_DIR/waste.list /usr/bin/echo $line &gt;&gt; $SRV_TMP_DIR/recycle.list $SRV_SCRIPTS_DIR/vm_delete.sh $line fi else /usr/bin/echo "posible vm is already off. Deleting vm" /usr/bin/echo "MOVE VM IN OFF STATE $line FROM WASTE.LIST TO" \ "RECYCLE.LIST AND DELETE VM" /usr/bin/sed -i "/$line/d" $SRV_TMP_DIR/waste.list /usr/bin/echo $line &gt;&gt; $SRV_TMP_DIR/recycle.list $SRV_SCRIPTS_DIR/vm_delete.sh "$line" fi done create_clear_vm } create_clear_vm() { /usr/bin/echo "=Create new VM=" while [ $SRV_POOL_SIZE -gt 0 ] do new_vm_port=$(($SRV_START_PORT_POOL+$SRV_POOL_SIZE)) /usr/bin/echo "new_vm_port=$new_vm_port" if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/clear.list &gt; /dev/null then /usr/bin/echo "$new_vm_port port is already defined in clear.list" else if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/waste.list &gt; /dev/null then /usr/bin/echo "$new_vm_port port is already defined in waste.list" else if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/recycle.list &gt; /dev/null then /usr/bin/echo "$new_vm_port PORT IS ALREADY DEFINED IN RECYCLE LIST" else if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/conn_wait.list &gt; /dev/null then /usr/bin/echo "$new_vm_port PORT IS ALREADY DEFINED IN CONN_WAIT LIST" else /usr/bin/echo "PORT IN NOT DEFINED IN NO ONE LIST WILL CREATE" \ "VM ON PORT $new_vm_port" /usr/bin/echo $new_vm_port &gt;&gt; $SRV_TMP_DIR/recycle.list $SRV_SCRIPTS_DIR/vm_create.sh $new_vm_port fi fi fi fi SRV_POOL_SIZE=$(($SRV_POOL_SIZE-1)) done /usr/bin/echo "# $date STOP EXECUTE VM_MANAGER.SH #" } make_connect_to_vm |/usr/bin/tee -a /var/log/vm_manager.log</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/vm_manager.conf</b> <div class="spoiler_text">  srv_scripts_dir = / home / admin / scripts_vdi_new <br>  srv_pool_size = 4 <br>  srv_start_port_pool = 5920 <br>  srv_tmp_dir = / tmp / vm_state <br>  base_host = win10_2 <br>  input_iface = enp5s0 <br>  vdi_spice_port = 5906 <br>  count_conn_tryes = 10 <br></div></div><br><br>  Deskripsi variabel dari file konfigurasi vm_manager.conf <br>  srv_scripts_dir - folder lokasi skrip vm_manager.sh, vm_connect.sh, vm_delete.sh, vm_create.sh, vm_clear.sh <br>  srv_pool_size - Ukuran kolam Vm <br>  srv_start_port_pool - port awal, setelah itu port rempah dari konsol mesin virtual akan dimulai <br>  srv_tmp_dir - folder untuk file sementara <br>  base_host - base Vm (gambar emas) dari mana klon Vm akan dibuat ke dalam kumpulan <br>  input_iface - antarmuka jaringan server, mencari ke Stasiun Klien <br>  vdi_spice_port - port jaringan server dari mana permintaan koneksi akan dialihkan dari klien remote-viewer ke port rempah-rempah dari Vm yang dipilih <br>  count_conn_tryes - timer tunggu, setelah itu dianggap bahwa koneksi ke Vm belum terjadi (untuk detail, lihat vm_connect.sh) <br><br>  Skrip vm_manager.sh membaca file konfigurasi dari file vm_manager.conf, mengevaluasi keadaan mesin virtual dalam kumpulan berdasarkan beberapa parameter, yaitu: berapa banyak VM yang digunakan, apakah ada VM bersih yang bebas.  Untuk melakukan ini, ia membaca file clear.list yang berisi nomor port “spice_console” dari mesin virtual “baru dibuat” (lihat siklus pembuatan VM di bawah) dan memeriksa koneksi yang terjalin dengannya.  Jika port dengan koneksi jaringan yang ada terdeteksi (yang seharusnya tidak boleh), peringatan ditampilkan dan port ditransfer ke waste.list Ketika port pertama ditemukan dari file clear.list yang saat ini tidak ada koneksi, vm_manager.sh memanggil skrip dan pass vm_connect.sh dia sebagai parameter nomor port ini. <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_connect.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh date=$(/usr/bin/date) /usr/bin/echo "#" "$date" "START EXECUTE VM_CONNECT.SH#" #&lt;SET LOCAL VARIABLES FOR SCRIPT&gt;# free_port="$1" input_iface=$(/usr/bin/cat /etc/vm_manager.conf |/usr/bin/grep "input_iface" \ |/usr/bin/cut -d "=" -f2) /usr/bin/echo "input_iface=$input_iface" vdi_spice_port=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "vdi_spice_port" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "vdi_spice_port=$vdi_spice_port" count_conn_tryes=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "count_conn_tryes" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "count_conn_tryes=$count_conn_tryes" #&lt;/SET LOCAL VARIABLES FOR SCRIPT&gt;# #&lt;CREATE IPTABLES RULES AND SEND SIGNAL TO CONNECT&gt;# /usr/bin/echo "create rule for port" $free_port /usr/sbin/iptables -I INPUT -i $input_iface -p tcp -m tcp --dport \ $free_port -j ACCEPT /usr/sbin/iptables -I OUTPUT -o $input_iface -p tcp -m tcp --sport \ $free_port -j ACCEPT /usr/sbin/iptables -t nat -I PREROUTING -p tcp -i $input_iface --dport \ $vdi_spice_port -j DNAT --to-destination 127.0.0.1:$free_port /usr/bin/echo "RULE ADDED, CONNECT NOW!" #&lt;/CREATE IPTABLES RULES AND SEND SIGNAL TO CONNECT&gt;# #&lt;WAIT CONNECT ESTABLISHED AND ACTIVATE CONNECT TIMER&gt;# while [ $count_conn_tryes -gt 0 ] do if /usr/bin/netstat -nt |/usr/bin/grep ":$free_port" \ |/usr/bin/grep "ESTABLISHED" &gt; /dev/null then /bin/echo "$free_port NOW in use!!!" /usr/bin/sleep 1s /usr/sbin/iptables -t nat -D PREROUTING -p tcp -i $input_iface --dport \ $vdi_spice_port -j DNAT --to-destination 127.0.0.1:$free_port /usr/sbin/iptables -D INPUT -i $input_iface -p tcp -m tcp --dport \ $free_port -j ACCEPT /usr/sbin/iptables -D OUTPUT -o $input_iface -p tcp -m tcp --sport \ $free_port -j ACCEPT /usr/bin/sed -i "/$free_port/d" $SRV_TMP_DIR/conn_wait.list /usr/bin/echo $free_port &gt;&gt; $SRV_TMP_DIR/waste.list return else /usr/bin/echo "$free_port NOT IN USE" /usr/bin/echo "RULE ADDED, CONNECT NOW!" /usr/bin/sleep 1s fi count_conn_tryes=$((count_conn_tryes-1)) done #&lt;/WAIT CONNECT ESTABLISED AND ACTIVATE CONNECT TIMER&gt;# #&lt;IF COUNT HAS EXPIRED. REMOVE IPTABLES RULE AND REVERT \ # VM TO CLEAR.LIST&gt;# /usr/bin/echo "REVERT IPTABLES RULE AND REVERT VM TO CLEAN \ LIST $free_port" /usr/sbin/iptables -t nat -D PREROUTING -p tcp -i $input_iface --dport \ $vdi_spice_port -j DNAT --to-destination 127.0.0.1:$free_port /usr/sbin/iptables -D INPUT -i $input_iface -p tcp -m tcp --dport $free_port \ -j ACCEPT /usr/sbin/iptables -D OUTPUT -o $input_iface -p tcp -m tcp --sport \ $free_port -j ACCEPT /usr/bin/sed -i "/$free_port/d" $SRV_TMP_DIR/conn_wait.list /usr/bin/echo $free_port &gt;&gt; $SRV_TMP_DIR/clear.list #&lt;/COUNT HAS EXPIRED. REMOVE IPTABLES RULE AND REVERT VM \ #TO CLEAR.LIST&gt;# /usr/bin/echo "#" "$date" "END EXECUTE VM_CONNECT.SH#" # Attention! Must Be! sysctl net.ipv4.conf.all.route_localnet=1</span></span></code> </pre><br></div></div><br>  Skrip vm_connect.sh memperkenalkan aturan firewall yang membuat pengalihan "vdi_spice_port" dari port server dari antarmuka enp5s0 ke "port konsol rempah-rempah" dari VM yang terletak di antarmuka server lo0, dilewatkan sebagai parameter startup.  Port ditransfer ke conn_wait.list, VM dianggap koneksi tertunda.  Baris ATURAN TAMBAH, HUBUNGKAN SEKARANG dikirimkan ke sesi Stasiun Klien pada port "sinyal" server, yang diharapkan oleh skrip remote.sh yang berjalan di atasnya.  Siklus menunggu koneksi dimulai dengan jumlah upaya yang ditentukan oleh nilai variabel "count_conn_tryes" dari file konfigurasi.  Setiap detik dalam sesi nc, string "ATURAN TAMBAH, HUBUNGKAN SEKARANG" akan diberikan dan koneksi yang dibuat ke port "spice_console" akan diperiksa. <br><br>  Jika koneksi gagal untuk jumlah upaya yang ditetapkan, port spice_console ditransfer kembali ke clear.list Eksekusi vm_connect.sh selesai, eksekusi vm_manager.sh dilanjutkan, yang memulai siklus pembersihan. <br><br>  Jika Stasiun Klien terhubung ke port spice_console pada antarmuka lo0, aturan firewall yang membuat pengalihan antara port server spice dan port spice_console dihapus dan koneksi lebih lanjut dipelihara oleh mekanisme untuk menentukan status firewall.  Jika koneksi terputus, menghubungkan kembali ke port spice_console akan gagal.  Port spice_console ditransfer ke waste.list, VM dianggap kotor dan tidak dapat kembali ke kumpulan mesin virtual bersih tanpa melalui pembersihan.  Eksekusi vm_connect.sh selesai, eksekusi vm_manager.sh dilanjutkan, yang memulai siklus pembersihan. <br><br>  Siklus pembersihan dimulai dengan melihat file waste.list, di mana nomor spice_console port mesin virtual yang koneksi dibuat ditransfer.  Kehadiran koneksi aktif ditentukan pada setiap port spice_console dari daftar.  Jika tidak ada koneksi, dianggap bahwa mesin virtual tidak lagi digunakan dan port ditransfer ke recycle.list dan proses menghapus mesin virtual (lihat di bawah) di mana port milik ini dimulai.  Jika koneksi jaringan aktif terdeteksi pada port, diasumsikan bahwa mesin virtual sedang digunakan, tidak ada tindakan yang diambil untuk itu.  Jika port tidak disadap, diasumsikan bahwa VM dimatikan dan tidak lagi diperlukan.  Port ditransfer ke recycle.list dan proses menghapus mesin virtual dimulai.  Untuk melakukan ini, skrip vm_delete.sh dipanggil, yang nomor "spice_console" ditransfer ke port VM sebagai parameter, yang harus dihapus. <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_delete.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #&lt;Set local VARIABLES&gt;# port_to_delete="$1" date=$(/usr/bin/date) #&lt;/Set local VARIABLES&gt;# /usr/bin/echo "# $date START EXECUTE VM_DELETE.SH#" /usr/bin/echo "TRY DELETE VM ON PORT: $vm_port" #&lt;VM NAME SETUP&gt;# vm_name_part1=$(/usr/bin/cat /etc/vm_manager.conf |/usr/bin/grep 'base_host' \ |/usr/bin/cut -d'=' -f2) vm_name=$(/usr/bin/echo "$vm_name_part1""-""$port_to_delete") #&lt;/VM NAME SETUP&gt;# #&lt;SHUTDOWN AND DELETE VM&gt;# /usr/bin/virsh destroy $vm_name /usr/bin/virsh undefine $vm_name /usr/bin/rm -f /var/lib/libvirt/images_write/$vm_name.qcow2 /usr/bin/sed -i "/$port_to_delete/d" $SRV_TMP_DIR/recycle.list #&lt;/SHUTDOWN AND DELETE VM&gt;# /usr/bin/echo "VM ON PORT $vm_port HAS BEEN DELETE AND REMOVE" \ "FROM RECYCLE.LIST. EXIT FROM VM_DELETE.SH" /usr/bin/echo "# $date STOP EXECUTE VM_DELETE.SH#" exit</span></span></code> </pre><br></div></div><br>  Menghapus mesin virtual adalah operasi yang cukup sepele, skrip vm_delete.sh menentukan nama mesin virtual yang memiliki port yang dilewati sebagai parameter startup.  VM terpaksa berhenti, VM dihapus dari hypervisor, hard disk virtual VM ini dihapus.  Port spice_console dihapus dari recycle.list.  Eksekusi vm_delete.sh berakhir, eksekusi resume vm_manager.sh <br><br>  Script vm_manager.sh, di akhir operasi untuk membersihkan mesin virtual yang tidak perlu dari daftar waste.list, memulai siklus pembuatan mesin virtual di kumpulan. <br><br>  Proses dimulai dengan penentuan port spice_console yang tersedia untuk hosting.  Untuk melakukan ini, berdasarkan pada parameter file konfigurasi "srv_start_port_pool" yang menetapkan port awal untuk kumpulan "spice_console" dari mesin virtual dan parameter "srv_pool_size", yang menentukan batas jumlah mesin virtual, semua varian port yang mungkin diuraikan secara berurutan.  Untuk setiap port tertentu, ia dicari di clear.list, waste.list, conn_wait.list, recycle.list.  Jika port ditemukan di salah satu file ini, port tersebut dianggap sibuk dan dilewati.  Jika port tidak ditemukan dalam file yang ditentukan, itu dimasukkan ke file recycle.list dan proses pembuatan mesin virtual baru dimulai.  Untuk melakukan ini, skrip vm_create.sh dipanggil ke mana nomor spice_console port tempat Anda ingin membuat VM dilewatkan sebagai parameter. <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_create.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh /usr/bin/echo "#" "$date" "START RUNNING VM_CREATE.SH#" new_vm_port=$1 date=$(/usr/bin/date) a=0 /usr/bin/echo SRV_TMP_DIR=$SRV_TMP_DIR #&lt;SET LOCAL VARIABLES FOR SCRIPT&gt;# base_host=$(/usr/bin/cat /etc/vm_manager.conf |/usr/bin/grep "base_host" \ |/usr/bin/cut -d "=" -f2) /usr/bin/echo "base_host=$base_host" #&lt;/SET LOCAL VARIABLES FOR SCRIPT&gt;# hdd_image_locate() { /bin/echo "Run STEP 1 - hdd_image_locate" hdd_base_image=$(/usr/bin/virsh dumpxml $base_host \ |/usr/bin/grep "source file" |/usr/bin/grep "qcow2" |/usr/bin/head -n 1 \ |/usr/bin/cut -d "'" -f2) if [ -z "$hdd_base_image" ] then /bin/echo "base hdd image not found!" else /usr/bin/echo "hdd_base_image found is a $hdd_base_image. Run next step 2" #&lt; CHECK FOR SNAPSHOT ON BASE HDD &gt;# if [ 0 -eq `/usr/bin/qemu-img info "$hdd_base_image" | /usr/bin/grep -c "Snapshot"` ] then /usr/bin/echo "base image haven't snapshot, run NEXT STEP 3" else /usr/bin/echo "base hdd image have a snapshot, can't use this image" exit fi #&lt;/ CHECK FOR SNAPSHOT ON BASE HDD &gt;# #&lt; CHECK FOR HDD IMAGE IS LINK CLONE &gt;# if [ 0 -eq `/usr/bin/qemu-img info "$hdd_base_image" |/usr/bin/grep -c "backing file" then /usr/bin/echo "base image is not a linked clone, NEXT STEP 4" /usr/bin/echo "Base image check complete!" else /usr/bin/echo "base hdd image is a linked clone, can't use this image" exit fi fi #&lt;/ CHECK FOR HDD IMAGE IS LINK CLONE &gt;# cloning } cloning() { # &lt;Step_1 turn the base VM off &gt;# /usr/bin/virsh shutdown $base_host &gt; /dev/null 2&gt;&amp;1 # &lt;/Step_1 turn the base VM off &gt;# #&lt;Create_vm_config&gt;# /usr/bin/echo "Free port for Spice VM is $new_vm_port" #&lt;Setup_name_for_new_VM&gt;# new_vm_name=$(/bin/echo $base_host"-"$new_vm_port) #&lt;/Setup_name_for_new_VM&gt;# #&lt;Make_base_config_as_clone_base_VM&gt;# /usr/bin/virsh dumpxml $base_host &gt; $SRV_TMP_DIR/$new_vm_name.xml #&lt;Make_base_config_as_clone_base_VM&gt;# ##&lt;Setup_New_VM_Name_in_config&gt;## /usr/bin/sed -i "s%&lt;name&gt;$base_host&lt;/name&gt;%&lt;name&gt;$new_vm_name&lt;/name&gt;%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/Setup_New_VM_Name_in_config&gt;# #&lt;UUID Changing&gt;# old_uuid=$(/usr/bin/cat $SRV_TMP_DIR/$new_vm_name.xml |/usr/bin/grep "&lt;uuid&gt;") /usr/bin/echo old UUID $old_uuid new_uuid_part1=$(/usr/bin/echo "$old_uuid" |/usr/bin/cut -d "-" -f 1,2) new_uuid_part2=$(/usr/bin/echo "$old_uuid" |/usr/bin/cut -d "-" -f 4,5) new_uuid=$(/bin/echo $new_uuid_part1"-"$new_vm_port"-"$new_uuid_part2) /usr/bin/echo $new_uuid /usr/bin/sed -i "s%$old_uuid%$new_uuid%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/UUID Changing&gt;# #&lt;Spice port replace&gt;# old_spice_port=$(/usr/bin/cat $SRV_TMP_DIR/$new_vm_name.xml \ |/usr/bin/grep "graphics type='spice' port=") /bin/echo old spice port $old_spice_port new_spice_port=$(/usr/bin/echo "&lt;graphics type='spice' port='$new_vm_port' autoport='no' listen='127.0.0.1'&gt;") /bin/echo $new_spice_port /usr/bin/sed -i "s%$old_spice_port%$new_spice_port%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/Spice port replace&gt;# #&lt;MAC_ADDR_GENERATE&gt;# mac_new=$(/usr/bin/hexdump -n6 -e '/1 ":%02X"' /dev/random|/usr/bin/sed s/^://g) /usr/bin/echo New Mac is $mac_new #&lt;/MAC_ADDR_GENERATE&gt;# #&lt;GET OLD MAC AND REPLACE&gt;# mac_old=$(/usr/bin/cat $SRV_TMP_DIR/$new_vm_name.xml |/usr/bin/grep "mac address=") /usr/bin/echo old mac is $mac_old /usr/bin/sed -i "s%$mac_old%$mac_new%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;GET OLD MAC AND REPLACE&gt;# #&lt;new_disk_create&gt;# /usr/bin/qemu-img create -f qcow2 -b $hdd_base_image /var/lib/libvirt/images_write/$new_vm_name.qcow2 #&lt;/new_disk_create&gt;# #&lt;attach_new_disk_in_confiig&gt;# /usr/bin/echo hdd base image is $hdd_base_image /usr/bin/sed -i "s%&lt;source file='$hdd_base_image'/&gt;%&lt;source file='/var/lib/libvirt/images_write/$new_vm_name.qcow2'/&gt;%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/attach_new_disk_in_confiig&gt;# starting_vm #&lt;/Create_vm config&gt;# } starting_vm() { /usr/bin/virsh define $SRV_TMP_DIR/$new_vm_name.xml /usr/bin/virsh start $new_vm_name while [ $a -ne 1 ] do if /usr/bin/virsh list --all |/usr/bin/grep "$new_vm_name" |/usr/bin/grep "running" &gt; /dev/null 2&gt;&amp;1 then a=1 /usr/bin/sed -i "/$new_vm_port/d" $SRV_TMP_DIR/recycle.list /usr/bin/echo $new_vm_port &gt;&gt; $SRV_TMP_DIR/clear.list /usr/bin/echo "#" "$date" "VM $new_vm_name IS STARTED #" else /usr/bin/echo "#VM $new_vm_name is not ready#" a=0 /usr/bin/sleep 2s fi done /usr/bin/echo "#$date EXIT FROM VM_CREATE.SH#" exit } hdd_image_locate</span></span></code> </pre><br></div></div><br>  Proses menciptakan mesin virtual baru <br><br>  Skrip vm_create.sh membaca dari file konfigurasi nilai variabel "base_host" yang menentukan mesin virtual sampel berdasarkan dasar pembuatan klon.  Membongkar konfigurasi xml dari VM dari database hypervisor, melakukan serangkaian pemeriksaan qcow dari image disk VM dan, setelah berhasil menyelesaikan, membuat file konfigurasi xml untuk VM baru dan gambar disk "linked clone" dari VM baru.  Setelah itu, konfigurasi xml dari VM baru dimuat ke dalam basis data hypervisor dan VM dimulai.  Port spice_console ditransfer dari recycle.list ke clear.list.  Eksekusi vm_create.sh berakhir dan eksekusi vm_manager.sh berakhir. <br>  Lain kali Anda terhubung, itu dimulai dari awal. <br><br>  Untuk kasus darurat, kit ini menyertakan skrip vm_clear.sh yang secara paksa dijalankan melalui semua VM dari kumpulan dan menghapusnya dengan memberi nilai nol pada daftar.  Menyebutnya pada tahap pemuatan memungkinkan Anda memulai (di bawah) VDI dari awal. <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_clear.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/sh #set VARIABLES# SRV_SCRIPTS_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_scripts_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR" export SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR SRV_TMP_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_tmp_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_TMP_DIR=$SRV_TMP_DIR" export SRV_TMP_DIR=$SRV_TMP_DIR SRV_POOL_SIZE=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_pool_size" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_POOL_SIZE=$SRV_POOL_SIZE" SRV_START_PORT_POOL=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_start_port_pool" |/usr/bin/cut -d "=" -f2) /usr/bin/echo SRV_START_PORT_POOL=$SRV_START_PORT_POOL #Set VARIABLES# /usr/bin/echo "= Cleanup ALL VM=" /usr/bin/mkdir $SRV_TMP_DIR /usr/sbin/service iptables restart /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/clear.list /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/waste.list /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/recycle.list /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/conn_wait.list port_to_delete=$(($SRV_START_PORT_POOL+$SRV_POOL_SIZE)) while [ "$port_to_delete" -gt "$SRV_START_PORT_POOL" ] do $SRV_SCRIPTS_DIR/vm_delete.sh $port_to_delete port_to_delete=$(($port_to_delete-1)) done /usr/bin/echo "= EXIT FROM VM_CLEAR.SH="</span></span></code> </pre><br></div></div><br>  Tentang ini saya ingin mengakhiri bagian pertama dari cerita saya.  Di atas harus cukup bagi administrator sistem untuk mencoba underVDI dalam bisnis.  Jika komunitas menemukan topik ini menarik, pada bagian kedua saya akan berbicara tentang modifikasi livecd Fedora dan transformasinya menjadi kios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462203/">https://habr.com/ru/post/id462203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462181/index.html">Aturan untuk komunikasi yang efektif dalam obrolan grup</a></li>
<li><a href="../id462185/index.html">Revolusi telah berakhir. Apakah ada alternatif untuk baterai lithium-ion?</a></li>
<li><a href="../id462189/index.html">Mengetsa data dengan travajs</a></li>
<li><a href="../id462191/index.html">Museum DataArt: A Tour of Italy Utara</a></li>
<li><a href="../id462197/index.html">Kiat tentang cara membebaskan pikiran Anda dan meningkatkan kreativitas Anda</a></li>
<li><a href="../id462205/index.html">Memenangkan PHDays 9 Standoff: Kronik tim True0xA3</a></li>
<li><a href="../id462209/index.html">Solusi VideoConference Polycom. Kenangan 6 tahun kemudian ... Tahap 2. Bagian 1. RMX1500</a></li>
<li><a href="../id462213/index.html">Belajar dan bekerja: pengalaman sarjana di Fakultas Teknologi Informasi dan Pemrograman</a></li>
<li><a href="../id462221/index.html">Betapa kecewanya saya di Google Play</a></li>
<li><a href="../id462227/index.html">Moskow, 9 Agustus - Cerita Backend 4.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>