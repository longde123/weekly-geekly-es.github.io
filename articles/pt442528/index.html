<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚úàÔ∏è üê≠ üóø Como fazer o jogo funcionar a 60fps üß§ üë©üèª‚Äçüöí üë©üèø‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine o problema: voc√™ tem um jogo e precisa trabalhar a 60 qps em um monitor de 60 Hz. Seu computador √© r√°pido o suficiente para renderizar e atual...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como fazer o jogo funcionar a 60fps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Imagine o problema: voc√™ tem um jogo e precisa trabalhar a 60 qps em um monitor de 60 Hz.  Seu computador √© r√°pido o suficiente para renderizar e atualizar para ocupar uma quantidade insignificante de tempo, ent√£o voc√™ ativa o vsync e escreve este loop do jogo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Muito f√°cil!  Agora o jogo funciona a 60fps e tudo corre como um rel√≥gio.  Feito.  Obrigado por ler este post. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Bem, obviamente, nem tudo √© t√£o bom.  E se algu√©m tiver um computador fraco que n√£o consiga processar o jogo a uma velocidade suficiente para fornecer 60fps?  E se algu√©m comprou um desses novos e legais monitores de 144 hertz?  E se ele desativasse o vsync nas configura√ß√µes do driver? <br><a name="habracut"></a><br>  Voc√™ pode pensar: preciso medir o tempo em algum lugar e fornecer uma atualiza√ß√£o com a frequ√™ncia correta.  Isso √© bastante simples - apenas acumule tempo em cada ciclo e atualize sempre que exceder o limite em 1/60 de segundo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Feito, em nenhum lugar mais f√°cil.  De fato, existem v√°rios jogos nos quais o c√≥digo parece essencialmente dessa maneira.  Mas isso est√° errado.  Isso √© adequado para ajustar hor√°rios, mas leva a problemas com movimentos bruscos (gagueira) e outras incompatibilidades.  Esse problema √© muito comum: os quadros n√£o s√£o exibidos exatamente 1/60 de segundo;  mesmo quando o vsync est√° ativado, sempre h√° um pouco de ru√≠do no momento em que s√£o exibidos (e na precis√£o do temporizador do SO).  Portanto, haver√° situa√ß√µes em que voc√™ renderiza um quadro, e o jogo acredita que o tempo para a atualiza√ß√£o ainda n√£o chegou (porque a bateria est√° ficando uma fra√ß√£o min√∫scula), por isso apenas repete o mesmo quadro novamente, mas agora o jogo est√° atrasado para o quadro, dobrando atualiza√ß√£o.  Aqui est√° a contra√ß√£o! <br><br>  No Google, voc√™ pode encontrar v√°rias solu√ß√µes prontas para eliminar essa contra√ß√£o.  Por exemplo, um jogo pode usar uma vari√°vel em vez de uma etapa constante e simplesmente abandonar completamente as baterias no c√≥digo de temporiza√ß√£o.  Ou voc√™ pode implementar uma etapa de tempo constante com um renderizador interpolador, descrito em um artigo bastante famoso " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> ", de Glenn Fielder.  Ou voc√™ pode refazer o c√≥digo do timer para que ele fique um pouco mais flex√≠vel, conforme descrito na publica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Frame Timing Issues</a> do Slick Entertainment (infelizmente este blog n√£o est√° mais l√°). <br><br><hr><br><h3>  Tempos difusos </h3><br>  O m√©todo Slick Entertainment com "tempos nebulosos" no meu mecanismo foi o mais f√°cil de implementar, porque n√£o exigia altera√ß√µes na l√≥gica e na renderiza√ß√£o do jogo.  Ent√£o, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">The End is Nigh,</a> eu o usei.  Bastava inseri-lo no motor.  De fato, ele simplesmente permite que o jogo seja atualizado "um pouco mais cedo" para evitar problemas com diferen√ßas de tempo.  Se o jogo incluir vsync, ele permitir√° que voc√™ use o vsync como o cron√¥metro principal do jogo e forne√ßa uma imagem suave. <br><br>  √â assim que o c√≥digo de atualiza√ß√£o fica agora (o jogo "pode ‚Äã‚Äãfuncionar" a 62 qps, mas ainda √© processado a cada passo como se funcionasse a 60 qps. N√£o entendo por que limit√°-lo para que os valores da bateria n√£o caiam abaixo de 0, mas sem este c√≥digo n√£o funciona).  Voc√™ pode interpretar da seguinte maneira: "o jogo √© atualizado com uma etapa fixa, se renderizado no intervalo de 60fps a 62fps": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Se o vsync estiver ativado, ele essencialmente permitir√° que o jogo funcione com um tom fixo, que corresponde √† taxa de atualiza√ß√£o do monitor e fornece uma imagem suave.  O principal problema aqui √© que, quando o vsync est√° desativado, o jogo funciona um <i>pouco</i> mais r√°pido, mas a diferen√ßa √© t√£o insignificante que ningu√©m notar√°. <br><br>  Corredores de velocidade.  Os Speedrunners perceber√£o.  Logo ap√≥s o lan√ßamento do jogo, eles notaram que algumas pessoas nas listas de recordes de speedran tinham tempos de viagem mais baixos, mas acabou sendo melhor que outros.  E a raz√£o imediata para isso foi o tempo pouco claro e a desconex√£o do vsync no jogo (ou monitores de 144 Hz).  Portanto, ficou √≥bvio que voc√™ precisa desativar essa imprecis√£o ao desconectar o vsync. <br><br>  Ah, mas ainda n√£o podemos verificar se o vsync est√° desativado.  N√£o h√° chamadas para isso no sistema operacional e, embora possamos solicitar ao aplicativo para ativar ou desativar o vsync, na verdade, ele √© completamente dependente do sistema operacional e do driver gr√°fico.  A √∫nica coisa que pode ser feita √© renderizar v√°rios quadros, tentar medir o tempo de execu√ß√£o dessa tarefa e comparar se eles levam o mesmo tempo.  Foi exatamente o que fiz para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">The End is Nigh</a> .  Se o jogo n√£o incluir vsync com uma frequ√™ncia de 60 Hz, ele voltar√° ao temporizador de quadros original com "60 fps estritos".  Al√©m disso, adicionei um par√¢metro ao arquivo de configura√ß√£o que for√ßa o jogo a n√£o usar imprecis√£o (principalmente para corredores de velocidade que precisam de tempo preciso) e adicionei um manipulador de timer exato no jogo para eles, o que permite o uso do auto-splitter (este √© um script que funciona com um timer de tempo at√¥mico). <br><br>  Alguns usu√°rios ainda se queixavam dos movimentos ocasionais de quadros individuais, mas pareciam t√£o raros que podiam ser explicados por eventos do SO ou por outros motivos externos.  N√£o √© grande coisa.  Certo? <br><br>  Observando meu c√≥digo de timer recentemente, notei algo estranho.  A bateria foi deslocada, cada quadro demorou um pouco mais de 1/60 segundo, ent√£o, de tempos em tempos, o jogo pensava que era tarde para o quadro e realizava uma atualiza√ß√£o dupla.  Aconteceu que meu monitor funciona com uma frequ√™ncia de 59,94 Hz, e n√£o 60 Hz.  Isso significava que a cada 1000 quadros, ele precisava realizar uma atualiza√ß√£o dupla para "recuperar o atraso".  No entanto, isso √© muito simples de corrigir - basta alterar o intervalo de frequ√™ncias de quadros permitidas (n√£o de 60 para 62, mas de 59 para 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  O problema descrito acima com o vsync desconectado e os monitores de alta frequ√™ncia ainda persiste, e a mesma solu√ß√£o se aplica a ele (revers√£o para timer estrito se o monitor <i>n√£o</i> estiver sincronizado com o vsync em 60). <br><br>  Mas como voc√™ sabe se esta √© a solu√ß√£o certa?  Como garantir que funcione corretamente em todas as combina√ß√µes de computadores com diferentes tipos de monitores, com e sem o vsync ativado e assim por diante?  √â muito dif√≠cil acompanhar todos esses problemas de timer na cabe√ßa e entender o que causa a dessincroniza√ß√£o, loops estranhos e similares. <br><br><h3>  Simulador de monitor </h3><br>  Tentando encontrar uma solu√ß√£o confi√°vel para o "problema do monitor de 59,94 hertz", percebi que n√£o podia apenas executar verifica√ß√µes de tentativa e erro, na esperan√ßa de encontrar uma solu√ß√£o confi√°vel.  Eu precisava de uma maneira conveniente de testar diferentes tentativas de escrever um cron√¥metro de alta qualidade e de uma maneira f√°cil de verificar se isso causa uma sacudida ou uma mudan√ßa de hor√°rio em diferentes configura√ß√µes de monitores. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">O Monitor Simulator</a> aparece em cena.  Este √© o c√≥digo "sujo e r√°pido" que escrevi, simulando a "opera√ß√£o do monitor" e essencialmente mostrando-me v√°rios n√∫meros que d√£o uma id√©ia da estabilidade de cada timer testado. <br><br>  Por exemplo, para o cron√¥metro mais simples, os seguintes valores s√£o exibidos desde o in√≠cio do artigo: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Primeiro, o c√≥digo exibe para cada vsync emulado o n√∫mero do n√∫mero de "atualiza√ß√µes" no ciclo do jogo ap√≥s o vsync anterior.  Quaisquer valores diferentes de 1 s√≥lido levam a uma imagem tremida.  No final, o c√≥digo exibe as estat√≠sticas acumuladas. <br><br>  Ao usar o "temporizador difuso" (com um intervalo de 60 a 62 fps) em um monitor 59,94-Hertz, o c√≥digo exibe o seguinte: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  O movimento do quadro √© muito raro, portanto pode ser dif√≠cil perceber com um n√∫mero igual a 1. Mas as estat√≠sticas exibidas mostram claramente que o jogo realizou v√°rias atualiza√ß√µes duplas aqui, o que leva ao movimento.  Na vers√£o fixa (com um intervalo de 59‚Äì61 fps), h√° 0 atualiza√ß√µes ignoradas ou duplas. <br><br>  Voc√™ tamb√©m pode desativar o vsync.  O restante dos dados estat√≠sticos se torna sem import√¢ncia, mas isso me mostra claramente a magnitude da ‚Äúmudan√ßa de hor√°rio‚Äù (a mudan√ßa de hor√°rio do sistema em rela√ß√£o a onde deveria estar o hor√°rio do jogo). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  √â por isso que, quando o vsync est√° desativado, voc√™ precisa mudar para um cron√¥metro r√≠gido, caso contr√°rio, essas discrep√¢ncias se acumulam com o tempo. <br><br>  Se eu definir o tempo de renderiza√ß√£o para .02 (ou seja, "√© necess√°rio mais do que um quadro" para renderizar), ent√£o terei uma contra√ß√£o.  Idealmente, o padr√£o do jogo deve parecer 202020202020, mas √© um pouco desigual. <br><br>  Nessa situa√ß√£o, esse cron√¥metro se comporta um pouco melhor que o anterior, mas fica mais confuso e mais dif√≠cil descobrir como e por que ele funciona.  Mas eu posso colocar os testes neste simulador e verificar como eles se comportam, e voc√™ pode descobrir os motivos mais tarde.  Tentativa e erro, beb√™! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>‚Äì<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Voc√™ pode baixar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">um simulador de monitor</a> e verificar independentemente diferentes m√©todos de c√°lculo de tempo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">Envie-me um e-mail</a> se encontrar algo melhor. <br><br>  N√£o estou 100% satisfeito com minha decis√£o (ainda √© necess√°rio um hack com "reconhecimento vsync" e podem ocorrer ocasional espasmos durante a dessincroniza√ß√£o), mas acredito que seja quase t√£o bom quanto uma tentativa de implementar um ciclo de jogo com uma etapa fixa.  Parte desse problema surge porque √© muito dif√≠cil determinar os par√¢metros do que √© considerado "aceit√°vel" aqui.  A principal dificuldade est√° na troca entre mudan√ßa de hor√°rio e quadros duplos / ignorados.  Se voc√™ executar um jogo de 60 Hz em um monitor PAL de 50 Hz ... qual ser√° a decis√£o certa?  Voc√™ quer empurr√µes selvagens ou jogabilidade visivelmente mais lenta?  Ambas as op√ß√µes parecem ruins. <br><br><h3>  Renderiza√ß√£o separada </h3><br>  Nos m√©todos anteriores, descrevi o que eu chamo de "renderiza√ß√£o de lockstep".  O jogo atualiza seu estado, depois √© renderizado e, ao renderizar, sempre exibe o estado mais recente do jogo.  Renderiza√ß√£o e atualiza√ß√£o s√£o conectadas juntas. <br><br>  Mas voc√™ pode separ√°-los.  √â exatamente isso que o m√©todo descrito na postagem " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">faz</a> .  N√£o vou me repetir, voc√™ definitivamente deveria ler este post.  Este (como eu o entendo) √© o "padr√£o da ind√∫stria" usado em jogos e mecanismos AAA como Unity e Unreal (no entanto, em jogos ativos 2D intensos, eles geralmente preferem usar uma etapa fixa (passo em falso), porque √†s vezes a precis√£o que oferece a voc√™ este m√©todo). <br><br>  Mas se descrevermos brevemente o post de Glenn, ele simplesmente descrever√° o m√©todo de atualiza√ß√£o com uma taxa de quadros fixa, mas ao renderizar, a interpola√ß√£o √© realizada entre o estado "atual" e o "anterior" do jogo, e o valor atual da bateria √© usado como o valor de interpola√ß√£o.  Com esse m√©todo, voc√™ pode renderizar a qualquer taxa de quadros e atualizar o jogo a qualquer frequ√™ncia, e a imagem ser√° sempre suave.  Sem empurr√µes, funciona universalmente. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Ent√£o, elementar.  O problema est√° resolvido. <br><br>  Agora voc√™ s√≥ precisa ter certeza de que o jogo pode renderizar os estados interpolados ... mas espere um minuto, na verdade n√£o √© nada f√°cil.  No post de Glenn, sup√µe-se simplesmente que isso pode ser feito.  √â f√°cil o suficiente para armazenar em cache a posi√ß√£o anterior do objeto do jogo e interpolar seus movimentos, mas o estado do jogo √© muito mais que isso.  √â necess√°rio levar em conta o estado da anima√ß√£o, a cria√ß√£o e destrui√ß√£o de objetos e um monte de coisas. <br><br>  Al√©m disso, na l√≥gica do jogo, voc√™ precisa considerar se o objeto √© teleportado ou se precisa ser movido sem problemas para que o interpolador n√£o fa√ßa suposi√ß√µes falsas sobre o caminho feito pelo objeto de jogo para sua posi√ß√£o atual.  O caos real pode ocorrer com as curvas, especialmente se em um quadro a curva de um objeto puder mudar em mais de 180 graus.  E como processar corretamente objetos criados e destru√≠dos? <br><br>  No momento, estou apenas trabalhando nessa tarefa no meu mecanismo.  Na verdade, eu apenas interpolo os movimentos e deixo tudo o que √©.  Voc√™ n√£o notar√° espasmos se o objeto n√£o se mover suavemente, portanto, pular os quadros de anima√ß√£o e sincronizar a cria√ß√£o / destrui√ß√£o do objeto em um quadro n√£o se tornar√° um problema se todo o resto for executado sem problemas. <br><br>  No entanto, √© estranho que, de fato, esse m√©todo processe o jogo em um estado atrasado em 1 estado do jogo, de onde a simula√ß√£o est√° agora localizada.  Isso √© discreto, mas pode ser conectado a outras fontes de atrasos, por exemplo, atrasos de entrada e taxas de atualiza√ß√£o de monitores, para aqueles que precisam de uma jogabilidade mais responsiva (estou falando de voc√™, corredores de velocidade) provavelmente preferem usar o locktep no jogo. <br><br>  No meu motor, eu apenas dou uma escolha.  Se voc√™ possui um monitor de 60 hertz e um computador r√°pido, √© melhor usar o lockstep com o vsync ativado.  Se o monitor tiver uma taxa de atualiza√ß√£o n√£o padr√£o ou o computador fraco n√£o conseguir renderizar constantemente 60 quadros por segundo, ative a interpola√ß√£o de quadros.  Quero chamar essa op√ß√£o de "desbloquear taxa de quadros", mas as pessoas podem pensar que isso significa simplesmente "ativar esta op√ß√£o se voc√™ tiver um bom computador".  No entanto, esse problema pode ser resolvido mais tarde. <br><br>  Na verdade, existe <i>um</i> m√©todo para contornar esse problema. <br><br><h3>  Atualiza√ß√µes de etapa de tempo vari√°vel </h3><br>  Muitas pessoas me perguntaram por que n√£o apenas atualizar o jogo com um intervalo de tempo vari√°vel, e os programadores te√≥ricos costumam dizer: "se o jogo foi escrito CORRETAMENTE, voc√™ pode simplesmente atualiz√°-lo com um intervalo de tempo arbitr√°rio". <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  Sem esquisitices com hor√°rios.  Nenhuma renderiza√ß√£o de interpola√ß√£o estranha.  Tudo √© simples, tudo funciona. <br><br>  Ent√£o, elementar.  O problema est√° resolvido.  E agora para sempre!  √â imposs√≠vel alcan√ßar um resultado melhor! <br><br>  Agora, √© simples o suficiente para fazer a l√≥gica do jogo funcionar com uma etapa de tempo arbitr√°ria.  √â simples, basta substituir todo esse c√≥digo: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  sobre isso: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  e substitua o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  sobre isso: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  e substitua o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  sobre isso: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... ent√£o espere <br><br>  De onde veio tudo isso? <br><br>  A √∫ltima parte √© literalmente copiada do c√≥digo auxiliar do meu motor, que executa "um movimento realmente correto, independente da taxa de quadros com velocidade que limita o atrito".  H√° um pouco de lixo nele (essas multiplica√ß√µes e divis√µes por 60).  Mas esta √© a vers√£o ‚Äúcorreta‚Äù do c√≥digo com uma etapa de tempo vari√°vel para o fragmento anterior.  Eu descobri isso por mais de uma hora com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">Wolfram Alpha</a> . <br><br>  Agora eles podem me perguntar por que n√£o fazer assim: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  E, embora pare√ßa funcionar, √© realmente errado faz√™-lo.  Voc√™ pode verificar voc√™ mesmo.  Execute duas atualiza√ß√µes com deltaTime = 1 e, em seguida, execute uma atualiza√ß√£o com deltaTime = 2, e os resultados ser√£o diferentes.  Normalmente, nos esfor√ßamos para que o jogo funcione em conjunto, para que tais discrep√¢ncias n√£o sejam bem-vindas.  Provavelmente, essa √© uma solu√ß√£o boa o suficiente, se voc√™ tiver certeza de que deltaTime √© sempre aproximadamente igual a um valor, mas precisar√° escrever um c√≥digo para garantir que as atualiza√ß√µes sejam executadas com uma frequ√™ncia constante e ... sim.  Est√° certo, agora estamos tentando fazer tudo "CORRETAMENTE". <br><br>  Se um peda√ßo t√£o pequeno de c√≥digo se desdobra em c√°lculos matem√°ticos monstruosos, imagine padr√µes de movimento mais complexos nos quais muitos objetos em intera√ß√£o participam, e assim por diante.  Agora voc√™ pode ver claramente que a solu√ß√£o "certa" √© irrealiz√°vel.  O m√°ximo que podemos alcan√ßar √© uma "aproxima√ß√£o aproximada".  Vamos esquecer isso por enquanto e supor que realmente tenhamos uma vers√£o "realmente correta" das fun√ß√µes de movimento.  √ìtimo, certo? <br><br>  Na verdade n√£o.  Aqui est√° um exemplo real do problema que tive com isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">Bombernauts</a> .  Um jogador pode pular cerca de 1 pe√ßa e o jogo ocorre em uma grade de blocos em 1 pe√ßa.  Para pousar em um bloco, as pernas do personagem devem subir acima da superf√≠cie superior do bloco. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Mas como o reconhecimento de colis√µes aqui √© realizado com uma etapa discreta, se o jogo funcionar com uma taxa de quadros baixa, √†s vezes as pernas n√£o alcan√ßar√£o a superf√≠cie do ladrilho, embora tenham seguido a mesma curva de movimento e, em vez de levantar, o jogador escorregar√° da parede. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  Obviamente, esse problema √© solucion√°vel.  Mas ilustra os tipos de problemas que encontramos ao tentar implementar corretamente o trabalho do ciclo do jogo com uma etapa de tempo vari√°vel.  Perdemos coer√™ncia e determinismo, por isso teremos de nos livrar das fun√ß√µes de reprodu√ß√£o do jogo gravando as informa√ß√µes do jogador, o multiplayer determin√≠stico e similares.  Para jogos 2D r√°pidos baseados em reflexos, a consist√™ncia √© extremamente importante (e ol√° novamente para acelerar os corredores). <br><br>  Se voc√™ tentar ajustar as etapas de tempo para que n√£o sejam muito grandes nem muito pequenas, voc√™ perder√° a principal vantagem obtida com a etapa de tempo vari√°vel e poder√° usar com seguran√ßa os outros dois m√©todos descritos aqui.  O jogo n√£o vale a pena.  Muito esfor√ßo extra ser√° colocado na l√≥gica do jogo (implementando a matem√°tica correta do movimento), e muitas v√≠timas ser√£o necess√°rias na √°rea de determinismo e consist√™ncia.  Eu usaria esse m√©todo apenas para um jogo de ritmo musical (no qual as equa√ß√µes de movimento s√£o simples e exigem m√°xima capacidade de resposta e suavidade).  Em todos os outros casos, escolherei uma atualiza√ß√£o fixa. <br><br><hr><br><h3>  Conclus√£o </h3><br>  Agora voc√™ sabe como fazer o jogo funcionar a uma frequ√™ncia constante de 60fps.  Isso √© trivialmente simples e ningu√©m mais deve ter problemas com isso.  N√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h√° outros problemas que</a> complicam esta tarefa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442528/">https://habr.com/ru/post/pt442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442518/index.html">As 10 melhores t√©cnicas de hackers na Web em 2018</a></li>
<li><a href="../pt442520/index.html">Case. Economizando 300 000 p. por m√™s em publicidade contextual</a></li>
<li><a href="../pt442522/index.html">RL Intuitivo (Aprendizagem por Refor√ßo): Introdu√ß√£o ao Crit√©rio de Atores de Vantagem (A2C)</a></li>
<li><a href="../pt442524/index.html">Como aumentar a seguran√ßa nos sistemas de identifica√ß√£o pessoal e controle de acesso</a></li>
<li><a href="../pt442526/index.html">A hist√≥ria dos toca-fitas sovi√©ticos (parte dois): o boom do Walkmen, um gadget para a KGB e gravadores</a></li>
<li><a href="../pt442530/index.html">Wireshark 3.0.0: revis√£o de inova√ß√µes</a></li>
<li><a href="../pt442532/index.html">Gravadores de v√≠deo para vigil√¢ncia por v√≠deo - gratuitamente</a></li>
<li><a href="../pt442534/index.html">Revis√£o da Sprint: Merda a √≥tima</a></li>
<li><a href="../pt442536/index.html">Conectando caixas de correio externas ao Zimbra</a></li>
<li><a href="../pt442542/index.html">SmartMail Conf: Primeira confer√™ncia de correio de aprendizado de m√°quina Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>