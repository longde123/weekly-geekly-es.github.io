<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛱️ ✖️ ✳️ Présentation de werf 1.0 stable: qu'est-ce que GitOps a à voir avec lui, son statut et ses plans 💫 👨🏼‍💼 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="werf est un utilitaire CLI open source GitOps pour la création et la livraison d'applications à Kubernetes. werf prend en charge l'assemblage d'images...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Présentation de werf 1.0 stable: qu'est-ce que GitOps a à voir avec lui, son statut et ses plans</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/481306/"><img src="https://habrastorage.org/webt/3x/gd/dm/3xgddmaqs9o_1evxjgalmlsczzo.png"><br><br>  <a href="https://werf.io/">werf</a> est un utilitaire CLI <a href="https://github.com/flant/werf">open source</a> GitOps pour la création et la livraison d'applications à Kubernetes.  werf prend en charge l'assemblage d'images d'application à l'aide de Dockerfile ou de son propre collecteur intégré (basé sur la syntaxe YAML, avec le support Ansible et la reconstruction incrémentielle basée sur Git).  Le format de configuration compatible avec Helm est utilisé pour fournir l'application.  Le code d'application, la configuration des images collectées et la configuration de déploiement de l'application sont stockés dans un référentiel Git. <br><br>  La <a href="">version stable</a> tant attendue <a href="">1.0</a> est la version de base de l'utilitaire complétée par des fonctions <i>(le numéro de version exact de la première version stable est 1.0.6)</i> .  Dans la version de base, werf prend en charge le cycle complet de livraison et de maintenance des applications.  Cela inclut l'assemblage d'images d'application, le déploiement sur Kubernetes et le nettoyage des images inutilisées. <a name="habracut"></a><br><br>  Il est important que dans la version 1.0, toutes les opérations sur un projet ( <code>build</code> , <code>deploy</code> , <code>cleanup</code> ) doivent être effectuées à partir d'un seul hôte.  Cela signifie qu'un travailleur fixe doit être utilisé dans le système CI.  Dans le même temps, il n'y a pas de restrictions sur le parallélisme des tâches: werf résout complètement ce problème.  Vous pouvez également répartir différents projets entre différents travailleurs. <br><br>  Dans cet article dédié à la sortie, nous allons voir de plus près ce que cette version fournit et ne fournit pas, ainsi que nos plans pour les futures versions.  Mais nous commencerons par comprendre la compréhension du terme «GitOps» et le rôle de werf dans les processus d'intégration continue et de livraison d'applications (CI / CD). <br><br><h2>  Pourquoi Werf est GitOps </h2><br>  Alors, que voulons-nous dire par GitOps et quels sont les domaines couverts? <br><br>  Le terme «GitOps» a été inventé par Weaveworks il y a environ 2,5 ans, et nous avons récemment <a href="https://habr.com/ru/company/flant/blog/458878/">traduit</a> un article de ses auteurs qui révèle l'essence de ce nouveau phénomène pour le blog.  À notre avis, l'idée principale et la signification principale de GitOps est que <b>Git est une «source unique de vérité»</b> .  Magasins Git: <br><br><ul><li>  code d'application </li><li>  toutes les dépendances; </li><li>  des informations sur la collecte des conteneurs; </li><li>  des informations sur la façon de déployer sur Kubernetes; </li><li>  et autres </li></ul><br>  Et puis il y a «quelque chose» qui fait que la <b>réalité change en fonction des changements de Git</b> .  Cette approche peut être mise en œuvre non seulement en installant un opérateur dans Kubernetes qui surveille Git, mais également en utilisant un utilitaire de console qui peut être appelé à partir de n'importe quel système CI.  De plus, de notre point de vue, l'approche avec l'utilitaire CLI n'impose pas de restrictions inutiles: nous pouvons faire du CI avec n'importe quel outil et avec un certain nombre de nuances, en appelant un utilitaire CLI qui synchronise la «réalité» (c'est-à-dire Kubernetes) avec l'état de Git . <br><br>  werf fournit une interface CLI de haut niveau avec des commandes de base pour la création et la publication d'images, la livraison d'applications et le nettoyage d'images: <code>werf build-and-publish</code> , <code>werf deploy</code> , <code>werf dismiss</code> , <code>werf cleanup</code> .  On suppose que ces commandes très basiques sont intégrées dans un système CI particulier et fournissent la synchronisation nécessaire avec la réalité.  De plus, werf fournit également une interface CLI de bas niveau pour gérer divers sous-systèmes - voir les <a href="https://ru.werf.io/documentation/cli/management/stages/build.html">commandes de gestion de bas niveau</a> dans la documentation. <br><br>  Peu importe que le CI / CD intégré fonctionne selon le modèle push ou pull <i>(en savoir plus <a href="https://habr.com/ru/company/flant/blog/456754/">ici</a> )</i> , car <b>werf peut être intégré à n'importe quel modèle</b> .  Dans le même temps, werf ferme des problèmes tels que le travail avec des utilitaires de bas niveau séparés tels que <code>git</code> , <code>docker</code> et kubernetes api-server, étant la «partie manquante» pour la configuration d'une application CI / CD unifiée. <br><br><h2>  Qu'est-ce que werf 1.0 stable </h2><br><h3>  1. Assemblage, publication et nettoyage des images </h3><br>  Si votre application nécessite la création d'images Docker, alors en utilisant werf 1.0, vous pouvez: <br><br><ul><li>  décrire les règles d'assemblage des images (vous pouvez en avoir plusieurs) dans une seule configuration <code>werf.yaml</code> ; </li><li>  Collectez des images et publiez-les dans le Docker Registry </li><li>  nettoyer périodiquement le Docker Registry pour les politiques personnalisées. </li></ul><br>  werf prend en charge <b>deux façons de décrire l'assembly</b> : connexion de <code>werf.yaml</code> <b>Dockerfiles existants</b> et instructions pour <b>le collecteur Stapel</b> .  Construire avec Stapel a ses avantages: une reconstruction incrémentielle plus rapide lors du changement de code d'application dans Git, l'utilisation de la syntaxe Ansible pour l'assemblage, etc.  Vous pouvez en <a href="https://ru.werf.io/documentation/reference/build_process.html">savoir</a> plus sur ce collecteur et cette syntaxe <a href="https://ru.werf.io/documentation/reference/build_process.html">dans la documentation</a> , et un exemple de son utilisation est présenté dans le <a href="https://ru.werf.io/documentation/guides/advanced_build/first_application.html">manuel</a> . <br><br>  Différents schémas de balisage / versioning des images collectées sont disponibles en référence aux validations, branches et balises Git. <br><br>  L'assemblage d'images est une étape facultative du déploiement d'applications et peut être ignoré en l'absence de vos propres images assemblées. <br><br><h3>  2. Stage de stockage sur un seul hôte </h3><br>  werf introduit le concept de stockage des étapes.  Les principales commandes werf utilisent le stockage par étapes comme suit: <br><br><ul><li>  Enregistrer les résultats de l'assemblage - images Docker dans le magasin de scène </li><li>  utiliser les images du magasin de scène comme cache pour la reconstruction et l'assemblage de nouvelles images; </li><li>  utiliser le référentiel pour obtenir des informations sur les images collectées pour leur utilisation ultérieure (par exemple, lors de la livraison d'une application à Kubernetes). </li></ul><br>  Lors du déploiement d'une seule application, un stockage en une seule étape doit être utilisé pour toutes les équipes (assemblage, publication, nettoyage d'image, déploiement d'application). <br><br>  Dans la version 1.0, seul le stockage hôte local peut agir comme un stockage d'étape (le paramètre correspondant pour les commandes est: <code>--stages-storage=:local</code> ).  Lors de l'utilisation <code>:local</code> étapes <code>:local</code> sont stockées sur disque.  La conséquence de ceci: <b>werf 1.0</b> ne peut être utilisé que <b>sur un seul hôte pour</b> organiser le déploiement d'une <b>seule application</b> .  Cet hôte doit enregistrer les données entre les lancements de commandes pour que werf fonctionne correctement. <br><br>  Dans la version 1.0, il n'y a pas de prise en charge pour le stockage des étapes dans le stockage externe, avec lequel vous pouvez organiser un assembly distribué.  Cependant, une telle fonction apparaîtra dans les futures versions de werf <i>(voir ci-dessous pour plus de détails)</i> . <br><br><h3>  3. Déployez l'application et vérifiez la disponibilité </h3><br>  Pour déployer l'application, l'utilisateur décrit le graphique dans un format compatible avec Helm: un ensemble de manifestes Kubernetes et de paramètres de modèle. <br><br>  werf lance l'application dans Kubernetes et garantit qu'il démarre et fonctionne avant de terminer le processus de déploiement de l'application.  Cela inclut la sortie des journaux des composants et la réponse instantanée aux erreurs de déploiement en cas de problème - la commande de déploiement tombera avec un code différent de zéro.  Ainsi, lorsque vous utilisez werf rollout dans CI / CD, <b>nous obtenons des commentaires adéquats du logiciel</b> : si l'application a été téléchargée ou non, et suffisamment d'informations pour déboguer et résoudre les problèmes (sans avoir à exécuter d'autres utilitaires pour trouver des problèmes comme <code>kubectl</code> ). <br><br>  werf est entièrement compatible avec les installations existantes de Helm 2, mais werf présente plusieurs avantages.  Par exemple, en tant que mécanisme de mise à jour des ressources, Kubernetes utilise des <a href="https://ru.werf.io/documentation/reference/deploy_process/resources_update_methods_and_adoption.html">correctifs de fusion à 3 voies</a> et il est également possible de recevoir des commentaires lorsque l'application est livrée au cluster.  Une liste complète des différences est décrite sur <a href="https://ru.werf.io/documentation/reference/deploy_process/differences_with_helm.html">cette page</a> . <br><br><h3>  4. La relation des images collectées avec le processus de livraison de l'application </h3><br>  werf intègre les images collectées dans un seul système, le processus de balisage et de versioning avec le processus de livraison de l'application à Kubernetes.  Les images collectées par werf peuvent être utilisées dans les modèles de description des ressources Kubernetes. <br><br>  C'est grâce à ces fonctions que nous pouvons dire que <b>werf fournit une interface de niveau supérieur</b> à Helm, Docker et à d'autres constructeurs et utilitaires pour un déploiement séparé.  Cette interface vous permet d'intégrer simplement werf dans n'importe quel système CI / CD existant et de ne pas résoudre les problèmes de combinaison de tous les composants utilisés - il se charge de cette tâche. <br><br><h3>  5. Intégration avec les systèmes CI / CD existants </h3><br>  Dans la version 1.0, l'intégration automatique n'est disponible qu'avec <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">le système GitLab CI</a> .  Pour ce faire, la commande <code>werf ci-env</code> est fournie.  Il reçoit les informations nécessaires du système CI / CD et configure automatiquement werf pour fonctionner correctement dans l'environnement CI. <br><br>  Vous pouvez en savoir plus sur le fonctionnement de l'intégration avec n'importe quel système CI / CD dans les manuels ( <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/overview.html">revue</a> , <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">spécificités de GitLab CI</a> , <a href="https://ru.werf.io/documentation/guides/unsupported_ci_cd_integration.html">intégration avec d'autres systèmes</a> ). <br><br><h3>  6. Développement multiplateforme pour Linux, Windows et macOS </h3><br>  werf 1.0 est un fichier binaire lié statiquement qui fonctionne indépendamment avec les versions Docker et Helm.  Dépendances externes sur le système hôte: <br><br><ul><li>  Démon Docker local </li><li>  utilitaire git. </li></ul><br>  werf peut fonctionner sur n'importe quel système d'exploitation et environnement GNU / Linux, Windows ou macOS.  De plus, le résultat de l'assemblage sera le même quel que soit le système utilisé: même signature des étapes de cache, même remplissage des étapes, quel que soit le système où cette étape a été collectée.  Des modifications dans la configuration pour travailler dans différents systèmes ne sont pas non plus nécessaires. <br><br>  Ainsi, werf 1.0 fournit des outils multiplateformes pour créer et fournir des applications à Kubernetes. <br><br>  Il convient également de noter ici que werf collecte des images Docker standard pour travailler dans un environnement Linux, mais les <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">conteneurs Windows</a> ne <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">sont</a> pas pris en charge dans la version 1.0. <br><br><h3>  7. Couvrir la fonctionnalité avec des tests </h3><br>  Actuellement, 60% du code werf est couvert par des tests d'intégration e2e et des tests unitaires. <br><br>  werf est testé sur tous les systèmes d'exploitation pris en charge (Linux, Windows et macOS) à l'aide des actions GitHub pour organiser leur lancement.  Certains détails des tests sont également disponibles sur <a href="https://codeclimate.com/github/flant/werf">Code Climate</a> . <br><br><h3>  8. Versioning werf </h3><br>  À l'heure actuelle, par la sortie de la version 1.0, <a href="https://github.com/flant/werf/releases">environ 700 versions</a> ont été effectuées dans le projet. <br><br>  werf utilise un système de libération avancé avec des canaux de stabilité: <i>alpha</i> , <i>bêta</i> , <i>ea (accès anticipé)</i> , <i>stable</i> et <i>solide</i> comme le <i>roc</i> .  Cette publication est programmée pour coïncider avec la sortie de la première version 1.0 sur le canal <i>stable</i> .  Les modifications instables de la version passent d'abord par une chaîne de canaux et finissent finalement par être <i>solides</i> .  Les versions sont souvent effectuées (parfois plusieurs par jour) et les modifications sont livrées en continu en «petites portions». <br><br>  Les canaux de stabilité et de nombreuses versions fréquentes vous permettent d'obtenir un retour d'information continu sur les nouveaux changements, la possibilité de les annuler rapidement et d'assurer généralement une grande stabilité du logiciel et en même temps une vitesse acceptable de son développement. <br><br>  Le point important est que lors du basculement entre les versions 1.0-&gt; 1.1, 1.1-&gt; 1.2, des modifications de werf sont possibles qui nécessitent une intervention manuelle de l'utilisateur (cela peut être un script de migration ou simplement des instructions pour une exécution manuelle décrites dans la version).  La mise à jour des versions à l'intérieur de 1.0 (1.0.1, 1.0.2, ... 1.0.6-alpha.1, 1.0.6-beta.2, etc.) garantit que de telles modifications manuelles ne sont pas nécessaires. <br><br>  Vous pouvez en savoir plus sur la promesse de compatibilité descendante <a href="https://github.com/flant/werf">ici</a> . <br><br><h2>  Plans supplémentaires </h2><br>  Voici à quoi ressemblent les principaux domaines de travail des futures versions et les termes approximatifs de leur implémentation: <br><br><h3>  1. Développement local et déploiement d'applications avec werf </h3><br>  L'objectif principal est de réaliser une configuration unifiée unique pour déployer des applications à la fois localement et en production, sans actions complexes, hors de la boîte. <br><br>  Werf a également besoin d'un mode de fonctionnement dans lequel il sera commode de modifier le code de l'application et de recevoir instantanément les commentaires d'une application qui fonctionne pour le débogage. <br><br>  <i>Version 1.1, janvier-février 2020</i> <br><br><h3>  2. Balisage basé sur le contenu </h3><br>  Marquage des images lors de leur publication, uniquement sur la base du contenu de cette image.  Contrairement aux modes avec liaison aux validations Git, ce mode supprimera complètement les reconstructions inutiles.  Git-commit-id n'est pas un identifiant universel pour le contenu de l'arbre de travail (bien qu'il en dépende). <br><br>  Dans le cas où le code d'application n'a pas changé, mais qu'une nouvelle validation a été effectuée, le mode de marquage actuel pour les validations Git créera une image avec un nouveau nom lors de sa publication.  Cela entraînera également une restauration des ressources utilisant cette image dans Kubernetes.  En même temps, le contenu de l'image elle-même n'a pas changé. <br><br>  Pour résoudre ces problèmes, werf introduira un nouveau type de balisage basé sur les calculs des sommes de contrôle du <b>contenu</b> de l'application - le balisage basé sur le <b>contenu</b> . <br><br>  <i>Version 1.1, février-mars 2020</i> <br><br><h3>  3. La transition vers Helm 3 </h3><br>  Il comprend la transition vers la nouvelle base de code <a href="https://habr.com/ru/company/flant/news/t/475722/">Helm 3</a> et un moyen éprouvé et pratique de migrer les installations existantes. <br><br>  <i>Version 1.1, février-mars 2020</i> <br><br><h3>  4. Assemblage parallèle d'images </h3><br>  À l'heure actuelle, werf 1.0 collecte séquentiellement toutes les étapes des images et des artefacts déclarés dans <code>werf.yaml</code> .  Nécessite la possibilité de paralléliser le processus d'assemblage de la scène. <br><br>  <i>Version: 1.1, janvier-février 2020</i> <br><br><h3>  5. Assemblage distribué d'images </h3><br>  Pour le moment, werf 1.0 ne peut être utilisé que sur un seul hôte dédié <i>(voir le point ci-dessus sur le stockage de la scène sur un seul hôte)</i> . <br><br>  Pour ouvrir les possibilités d'un assemblage distribué, lorsque l'assembly est lancé sur plusieurs hôtes et que ces hôtes ne maintiennent pas leur état entre les assemblys (coureurs temporaires), werf doit implémenter la possibilité d'utiliser le Docker Registry comme référentiel d'étape. <br><br>  Auparavant, lorsque le projet werf s'appelait également dapp, il avait une telle opportunité.  Cependant, nous avons rencontré un certain nombre de problèmes qui doivent être pris en compte lors de l'implémentation de cette fonction dans werf. <br><br>  <i>Version 1.2: mars-avril 2020</i> <br><br><h3>  6. Jsonnet pour décrire la configuration de Kubernetes </h3><br>  werf prendra en charge la description de la configuration de Kubernetes au format <a href="https://jsonnet.org/">Jsonnet</a> .  Dans le même temps, werf restera compatible avec Helm et il sera possible de sélectionner un format de description. <br><br>  La raison en est le fait que les modèles de langage Go, selon de nombreuses personnes, ont un seuil d'entrée élevé, et l'intelligibilité du code de ces modèles souffre également. <br><br>  D'autres options pour l'implémentation des systèmes de description de configuration de Kubernetes (comme Kustomize) sont également à l'étude. <br><br>  <i>Version 1.1: janvier-février 2020</i> <br><br><h3>  7. Travailler à l'intérieur de Kubernetes </h3><br>  Objectif: Assurer l'assemblage des images et la livraison des applications à l'aide de runners dans Kubernetes.  C'est-à-dire  l'assemblage de nouvelles images, leur publication, leur nettoyage et leur déploiement peuvent se faire directement à partir des modules Kubernetes. <br><br>  Pour réaliser cette fonctionnalité, vous devez d'abord pouvoir créer des images de manière distribuée <i>(voir le paragraphe ci-dessus)</i> . <br><br>  Il nécessite également la prise en charge du mode de fonctionnement de génération sans le démon Docker (c'est-à-dire une génération de type <i>Kaniko</i> ou une <i>génération d'espace utilisateur</i> ). <br><br>  werf prendra en charge les versions de Kubernetes non seulement avec le Dockerfile, mais aussi avec son générateur Stapel avec des reconstructions incrémentielles. <br><br>  <i>Version 1.2: avril-mai 2020</i> <br><br><h3>  8. Autre </h3><br>  Il est également prévu: <br><br><ul><li>  Mise à niveau de la version d'Ansible et possibilité d'utiliser différentes versions d'Ansible; </li><li>  soutien aux rôles ansibles; </li><li>  prise en charge des étapes d'assemblage arbitraires dans Stapel (actuellement, werf prend en charge un ensemble statique d'étapes: <code>beforeInstall</code> , <code>install</code> , <code>beforeSetup</code> , <code>setup</code> ); </li><li>  amélioration de la syntaxe <code>werf.yaml</code> , passage à <code>configVersion: 2</code> (associé, entre autres, aux deux points précédents), prise en charge de la spécification OpenAPI; </li><li>  Prise en charge de Git LFS dans Stapel pour le stockage de fichiers volumineux dans Git; </li><li>  amélioration des mécanismes de nettoyage des images (les défauts non critiques dans la version actuelle sont associés aux images non déclarées dans la configuration <code>werf.yaml</code> dans la branche principale principale - ces images seront supprimées par un nettoyage périodique); </li><li>  un travail plus correct avec l'espace de noms Kubernetes partagé, lorsque plusieurs applications sont déployées dans un même espace de noms; </li><li>  restauration automatique de l'application vers la dernière version de travail en cas d'échec du déploiement. </li></ul><br><h2>  Total </h2><br>  Je serai bref en résumant.  Nous sommes: <br><br><ul><li>  longtemps marché jusqu'à l'avènement de la version 1.0; </li><li>  a pris en compte beaucoup d'expérience réelle; </li><li>  Nous présentons pour utilisation un utilitaire éprouvé avec des fonctionnalités stables, vérifié par des dizaines de milliers de déploiements. </li></ul><br>  La sortie de la version 1.0 marque le début d'une nouvelle phase de développement de werf, au sein de laquelle de nouvelles fonctionnalités fondamentales seront ajoutées.  Suivez l'actualité!  Et rejoignez également <a href="https://t.me/werf_ru">le canal tg werf_ru</a> , dans la vie duquel participent à la fois les développeurs werf directs, ainsi que nos ingénieurs et utilisateurs de l'utilitaire en dehors de la société Flant. <br><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://habr.com/ru/company/flant/news/t/478716/">Werf a de la documentation en russe</a> »; </li><li>  Une série de notes sur les innovations dans werf: <br><ul><li>  « <a href="https://habr.com/ru/company/flant/blog/476646/">Fusion à 3 voies dans werf: déploiement dans Kubernetes avec Helm« sous stéroïdes »</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/468049/">Utilisation de werf pour déployer des graphiques Helm complexes</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/465131/">Prise en charge de monorepo et multirepo dans werf et qu'est-ce que le Docker Registry a à voir avec cela</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/463613/">Vous pouvez maintenant assembler des images Docker en werf en utilisant le Dockerfile habituel</a> »; </li></ul></li><li>  « <a href="https://habr.com/ru/company/flant/blog/460351/">Werf est notre outil CI / CD à Kubernetes (revue et rapport vidéo)</a> »; </li><li>  « <a href="https://habr.com/ru/company/flant/blog/458878/">Qu'est-ce que GitOps?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481306/">https://habr.com/ru/post/fr481306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481290/index.html">COMMENT / Paramètres réseau et VLAN sur un serveur Hetzner et Mikrotik dédié</a></li>
<li><a href="../fr481294/index.html">10 meilleurs outils d'automatisation de test de logiciels</a></li>
<li><a href="../fr481296/index.html">Comment écrire du code qui sera réutilisé</a></li>
<li><a href="../fr481302/index.html">"À propos, oui pas un cluster" ou comme nous avons importé un SGBD</a></li>
<li><a href="../fr481304/index.html">Tri du drapeau américain</a></li>
<li><a href="../fr481312/index.html">Cadeaux perdus du Père Noël: annonce d'une quête informatique pour le 6 janvier</a></li>
<li><a href="../fr481314/index.html">Plateforme DIY Crawler pour robots et divertissement</a></li>
<li><a href="../fr481316/index.html">Rédaction d'un blog sur les microservices - Partie 4 Post Service</a></li>
<li><a href="../fr481318/index.html">Hacking avec Unicode (sur l'exemple de GitHub)</a></li>
<li><a href="../fr481320/index.html">Quatre innovations technologiques remodèlent les soins de santé dès maintenant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>