<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçå üöÄ üïñ Elegir la estructura de datos correcta en Swift üí∞ üòµ üë®üèª‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola de nuevo Antes de partir para el fin de semana, queremos compartir con ustedes una traducci√≥n del material que se prepar√≥ espec√≠ficamente para el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elegir la estructura de datos correcta en Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/468239/">  <i>Hola de nuevo</i>  <i>Antes de partir para el fin de semana, queremos compartir con ustedes una traducci√≥n del material que se prepar√≥ espec√≠ficamente para el curso b√°sico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Desarrollador iOS"</a> .</i> <br><br><img src="https://habrastorage.org/webt/hu/wa/i0/huwai0itmfwakcyvain6xjf2jlm.png"><br><hr><br>  Decidir qu√© estructura de datos usar para representar un conjunto de valores dado es a menudo mucho m√°s dif√≠cil de lo que parece.  Dado que cada tipo de estructura de datos est√° optimizado para un cierto n√∫mero de casos de uso, elegir el ajuste adecuado para cada conjunto de datos a menudo puede tener un gran impacto en el rendimiento de nuestro c√≥digo. <a name="habracut"></a><br><br>  La biblioteca est√°ndar de Swift viene con tres estructuras de datos principales: <code>Array</code> , <code>Dictionary</code> y <code>Set</code> , cada una de las cuales tiene su propio conjunto de optimizaciones, ventajas y desventajas.  Veamos algunas de sus caracter√≠sticas, as√≠ como los casos en los que podr√≠amos tener que ir m√°s all√° de la biblioteca est√°ndar para encontrar la estructura de datos correcta para nuestros prop√≥sitos. <br><br><h3>  Linealidad de matriz </h3><br>  <code>Array</code> es probablemente una de las estructuras de datos m√°s utilizadas en Swift, y existen buenas razones para ello.  Almacena sus elementos secuencialmente, se clasifican f√°cilmente de una manera predecible, y cualquier valor puede almacenarse en √©l: desde estructuras hasta instancias de clases y otras colecciones. <br><br>  Por ejemplo, aqu√≠ usamos una matriz para almacenar una colecci√≥n de formas colocadas en un <code>Canvas</code> en una aplicaci√≥n de dibujo.  Luego, cuando necesitamos renderizar el lienzo en una imagen, simplemente pasamos por la matriz para dibujar cada elemento usando <code>DrawingContext</code> , de la siguiente manera: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: [<span class="hljs-type"><span class="hljs-type">Shape</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } }</code> </pre> <br>  Cuando se trata de la representaci√≥n secuencial de todas nuestras formas, como hicimos anteriormente, la matriz se adapta perfectamente.  Las matrices no solo almacenan sus elementos de una manera muy eficiente, sino que tambi√©n tienen un orden de clasificaci√≥n garantizado, que proporciona un orden de representaci√≥n predecible sin tener que realizar ning√∫n trabajo adicional. <br><br>  Sin embargo, como todas las dem√°s estructuras de datos, las matrices tienen sus inconvenientes.  En nuestro caso, encontraremos uno de sus inconvenientes cuando queramos eliminar formas del lienzo.  Dado que los elementos de la matriz se almacenan por √≠ndice, siempre necesitamos encontrar primero con qu√© √≠ndice est√° asociada la figura antes de poder eliminarla: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.firstIndex(of: shape) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) } }</code> </pre> <br>  Al principio, el c√≥digo anterior puede no parecer tan problem√°tico, pero puede convertirse en un cuello de botella de rendimiento para cualquier lienzo que contenga una gran cantidad de formas, ya que <code>firstIndex</code> es lineal (O (N)) en t√©rminos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complejidad temporal</a> . <br><br>  Aunque podemos evitar esta limitaci√≥n cuando usamos nuestro tipo de Canvas.  Por ejemplo, siempre haciendo referencia a cifras por √≠ndice, y no por valor o ID, esto har√≠a que nuestro c√≥digo sea m√°s complejo y fr√°gil, ya que siempre tendr√≠amos que estar seguros de que nuestros √≠ndices no caducan cuando el lienzo con el que estamos trabajando cambiar√° <br><br><h3>  Conjuntos de velocidad </h3><br>  En cambio, veamos si podemos optimizar el <code>Canvas</code> s√≠ cambiando su estructura de datos subyacente.  Teniendo en cuenta el problema anterior, una de nuestras ideas iniciales podr√≠a ser utilizar <code>Set</code> (sets) en lugar de <code>Array</code> .  Como ya discutimos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El poder de los conjuntos en Swift</a> , una de las ventajas significativas de los conjuntos sobre las matrices es que tanto la inserci√≥n como la eliminaci√≥n siempre se pueden realizar en un tiempo constante (O (1)), ya que los elementos se almacenan por valor hash, no por √≠ndice. <br><br>  Al actualizar <code>Canvas</code> para usar conjuntos, obtenemos lo siguiente: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: <span class="hljs-type"><span class="hljs-type">Set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { shapes.remove(shape) } }</code> </pre> <br>  Una vez m√°s, el c√≥digo anterior puede verse bien, e incluso se compila sin problemas.  Sin embargo, aunque resolvimos el problema de eliminaci√≥n, tambi√©n perdimos nuestro orden de representaci√≥n estable, porque, a diferencia de las matrices, los conjuntos no nos dan un orden de clasificaci√≥n garantizado, que es un obst√°culo en esta situaci√≥n, ya que parece que dibujaremos formas personalizadas en Al azar <br><br><h3>  √çndices de indexaci√≥n </h3><br>  Sigamos experimentando.  Ahora veamos si podemos optimizar el <code>Canvas</code> introduciendo un <code>Dictionary</code> , que nos permite buscar el √≠ndice de cualquier forma en funci√≥n de su ID.  Comenzaremos cambiando el nivel de acceso de nuestra matriz de <code>shapes</code> a <code>private</code> para que podamos controlar la inserci√≥n de elementos utilizando el nuevo m√©todo de <code>add</code> .  Y cada vez que se agrega una nueva figura, tambi√©n agregamos su √≠ndice a nuestro diccionario: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> indexes[shape.id] = index shapes.append(shape) } }</code> </pre> <br>  Como ahora siempre sabemos en qu√© √≠ndice se almacena una figura determinada, podemos realizar r√°pidamente la eliminaci√≥n en tiempo constante, como cuando se usa un conjunto: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = indexes[shape.id] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) indexes[shape.id] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Sin embargo, hay un error bastante grave en nuestra nueva implementaci√≥n de <code>Canvas</code> .  Cada vez que eliminamos una forma, invalidamos todos los √≠ndices que son m√°s altos que el que acabamos de eliminar, ya que cada uno de estos elementos se mover√° un paso al comienzo de la matriz.  Podr√≠amos resolver este problema ajustando estos √≠ndices despu√©s de cada eliminaci√≥n, pero esto nuevamente nos llevar√≠a de vuelta al territorio O (N), que tratamos de evitar desde el principio. <br><br>  Nuestra √∫ltima implementaci√≥n tiene sus m√©ritos.  En general, usar una combinaci√≥n de dos estructuras de datos puede ser una gran idea en tales situaciones, ya que a menudo podemos usar las fortalezas de una estructura de datos para compensar las deficiencias de la otra, y viceversa. <br><br>  Entonces, intentemos nuevamente con una combinaci√≥n diferente, pero esta vez comencemos considerando nuestros <i>requisitos reales</i> : <br><br><ul><li>  Necesitamos inserciones y eliminaciones para tener una complejidad de tiempo constante, y deber√≠a ser posible eliminar la figura sin conocer su √≠ndice base. </li><li>  Necesitamos un orden de clasificaci√≥n garantizado para poder mantener un orden de representaci√≥n estable. </li></ul><br>  Al observar los requisitos anteriores, resulta que aunque necesitamos un orden de clasificaci√≥n estable, en realidad no necesitamos √≠ndices.  Esto har√≠a que la lista vinculada sea perfecta para nuestro caso de uso. <br><br>  Las listas vinculadas consisten en nodos, donde cada nodo contiene un enlace (o enlace) al siguiente nodo de la lista, lo que significa que se puede ordenar de una manera predecible, sin la necesidad de actualizaciones de √≠ndice cuando se elimina un elemento.  Sin embargo, la biblioteca est√°ndar de Swift (hasta ahora) no contiene un tipo de lista vinculada, por lo que si queremos usarla, primero debemos crearla. <br><br><h3>  Crea una lista vinculada </h3><br>  Comencemos declarando una estructura de <code>List</code> que rastrear√° el primer y √∫ltimo nodo de nuestra lista.  Haremos que estas dos propiedades sean de solo lectura fuera de nuestro tipo para garantizar la coherencia de los datos: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  A continuaci√≥n, creemos nuestro tipo de nodo (nodo), que crearemos una clase, porque queremos poder referirnos a los nodos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por referencia y no por valor</a> .  Nuestra lista estar√° doblemente conectada, lo que significa que cada nodo contendr√° un enlace tanto a su pr√≥ximo vecino como al anterior.  Cada nodo tambi√©n almacenar√° un valor, como este: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } }</code> </pre> <br><blockquote>  La raz√≥n por la que debilitamos la propiedad anterior es para evitar los bucles de retenci√≥n que aparecer√≠an si mantuvi√©ramos enlaces fuertes en ambas direcciones.  Para obtener m√°s informaci√≥n sobre c√≥mo evitar los ciclos de retenci√≥n, consulte el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Administraci√≥n de memoria"</a> . </blockquote>  Esto es en realidad todo el c√≥digo que necesitamos para que los valores se puedan almacenar en nuestra lista vinculada.  Pero esta es solo la primera parte del rompecabezas, como en cualquier otra colecci√≥n, tambi√©n queremos poder iterar sobre √©l y cambiar su contenido.  Comencemos con las iteraciones que, gracias al dise√±o Swift muy orientado al protocolo, se pueden implementar f√°cilmente al garantizar el cumplimiento del protocolo <code>Sequence</code> e implementar el m√©todo <code>makeIterator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    ,    : let value = node?.value node = node?.next return value } } }</span></span></code> </pre> <br><blockquote>  Dado que la iteraci√≥n anterior es muy simple, utilizamos la biblioteca est√°ndar <code>AnyIterator</code> para evitar la necesidad de implementar un tipo de iterador personalizado.  Para escenarios m√°s complejos, se puede implementar agregando una coincidencia a <code>IteratorProtocol</code> . </blockquote>  A continuaci√≥n, agreguemos una API para modificar nuestra lista vinculada, comenzando con las inserciones.  Ampliaremos la <code>List</code> con el m√©todo <code>append</code> , que agrega un nuevo nodo para el valor insertado y luego devuelve este nodo, de esta manera: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: Value)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(value: value) node.previous = lastNode lastNode?.next = node lastNode = node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { firstNode = node } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } }</code> </pre> <br><blockquote>  Arriba, usamos el atributo <code>@discardableResult</code> , que le dice al compilador que no genere ninguna advertencia si no se utiliz√≥ el resultado de llamar a nuestro m√©todo, ya que no siempre estamos interesados ‚Äã‚Äãen el nodo que se cre√≥. </blockquote>  Dado que las listas vinculadas no se basan en √≠ndices, sino en mantener una cadena de valores a trav√©s de enlaces, la implementaci√≥n de eliminaciones es solo una cuesti√≥n de actualizar los siguientes y anteriores vecinos de los nodos remotos para que apunten entre s√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node)</span></span></span></span> { node.previous?.next = node.next node.next?.previous = node.previous <span class="hljs-comment"><span class="hljs-comment">//  ¬´ ¬ª,        ,    : if firstNode === node { firstNode = node.next } if lastNode === node { lastNode = node.previous } } }</span></span></code> </pre> <br>  Con base en lo anterior, la versi√≥n inicial de nuestra Lista est√° completa y estamos listos para verificarla en acci√≥n.  Actualicemos el lienzo para usar nuestra nueva lista, as√≠ como un diccionario que nos permita encontrar r√°pidamente qu√© nodo coincide con una ID de forma dada: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;.<span class="hljs-type"><span class="hljs-type">Node</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { nodes[shape.id] = shapes.append(shape) } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = nodes.removeValue(forKey: shape.id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(node) } }</code> </pre> <br>  Ahora tenemos inserciones y eliminaciones r√°pidas, y un orden de clasificaci√≥n predecible, sin la necesidad de agregar complejidad adicional al proceso de llamada, ¬°es genial!  Y, dado que nuestra nueva Lista es un tipo completamente universal, ahora podemos usarla siempre que necesitemos almacenar valores sin un √≠ndice de forma lineal. <br><br><h3>  Conclusi√≥n </h3><br>  A pesar de que las estructuras de datos son tan fundamentales que se pueden encontrar en todo tipo de lenguajes de programaci√≥n, la decisi√≥n sobre cu√°l usar en cada situaci√≥n espec√≠fica puede requerir una cantidad significativa de pensamiento, prueba y experimentaci√≥n, especialmente si queremos para que nuestro c√≥digo siga siendo efectivo a medida que crece el conjunto de datos. <br><br>  Tambi√©n es muy probable que la estructura de datos adecuada para cada situaci√≥n espec√≠fica pueda cambiar con el tiempo a medida que cambian nuestros requisitos, y a veces usar una combinaci√≥n de varias estructuras de datos, y no solo una, puede ser una forma de lograr las caracter√≠sticas de rendimiento requeridas. <br><br>  Continuaremos explorando el mundo de las estructuras de datos en los siguientes art√≠culos, enfoc√°ndonos en aquellos que a√∫n no est√°n implementados en la biblioteca est√°ndar.  Como con tantas otras cosas, a veces necesitamos expandir nuestro pensamiento m√°s all√° de Swift para elegir la estructura de datos correcta para cada situaci√≥n. <br><br>  Puede encontrarme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Twitter</a> o enviarme un correo electr√≥nico si tiene alguna pregunta, comentario o comentario. <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468239/">https://habr.com/ru/post/468239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468229/index.html">Una nota sobre vac√≠o en JavaScript y TypeScript</a></li>
<li><a href="../468231/index.html">¬øEs la seguridad en AEM un problema de plataforma o implementaci√≥n?</a></li>
<li><a href="../468233/index.html">La forma de escribir comprobando 4 millones de l√≠neas de c√≥digo Python. Parte 1</a></li>
<li><a href="../468235/index.html">La forma de escribir comprobando 4 millones de l√≠neas de c√≥digo Python. Parte 2</a></li>
<li><a href="../468237/index.html">La forma de escribir comprobando 4 millones de l√≠neas de c√≥digo Python. Parte 3</a></li>
<li><a href="../468241/index.html">TR-069 en Mikrotik. Prueba de Freeacs como un servidor de autoconfiguraci√≥n para RouterOS</a></li>
<li><a href="../468245/index.html">No necesitamos correcciones de traducci√≥n: nuestro traductor sabe mejor c√≥mo se debe traducir</a></li>
<li><a href="../468251/index.html">No hay futuro</a></li>
<li><a href="../468253/index.html">Control deslizante de imagen simple en CSS y Javascript</a></li>
<li><a href="../468259/index.html">Cinco aspectos destacados de la Helm Summit 2019 en Amsterdam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>