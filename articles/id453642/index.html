<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 👩🏽‍🎨 🐛 Parser cerdas untuk nomor yang ditulis dengan kata-kata 🤸🏽 👇🏻 🍖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 Selamat siang, para pembaca yang budiman. Pada artikel ini saya akan berbicara tentang bagaimana mengurai angka yang ditulis dalam kata-kat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parser cerdas untuk nomor yang ditulis dengan kata-kata</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453642/"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Prolog </h1><br><p>  Selamat siang, para pembaca yang budiman.  Pada artikel ini saya akan berbicara tentang bagaimana mengurai angka yang ditulis dalam kata-kata dalam bahasa Rusia. </p><br><p>  Smart parser ini memungkinkan untuk mengekstraksi angka dari teks dengan kesalahan yang dibuat sebagai akibat dari input yang salah atau sebagai hasil dari pengenalan optik teks dari suatu gambar (OCR). </p><br><p>  Untuk yang malas: <br>  Tautan ke proyek github: <a href="">tautan</a> . </p><br><a name="habracut"></a><br><h1>  Dari algoritma ke hasil </h1><br><p>  Bagian ini akan menjelaskan algoritma yang digunakan.  Perhatian, banyak surat! </p><br><h2>  Pernyataan masalah </h2><br><p> Di tempat kerja, saya perlu mengenali teks dari dokumen cetak yang difoto dengan kamera smartphone / tablet.  Karena perjanjian non-pengungkapan, saya tidak bisa memberikan contoh foto, tetapi intinya adalah dokumen memiliki tabel di mana indikator tertentu ditulis dalam angka dan kata-kata, dan data ini harus dibaca.  Parsing teks dalam kata-kata diperlukan sebagai alat validasi tambahan untuk memastikan bahwa nomor tersebut dikenali dengan benar.  Tapi, seperti yang Anda tahu, OCR tidak menjamin pengenalan teks yang akurat.  Misalnya, angka dua puluh, yang ditulis dengan kata-kata, dapat dikenali sebagai "dvupat" atau bahkan sebagai "dvupat".  Hal ini diperlukan untuk memperhitungkan hal ini dan mengekstraksi jumlah informasi maksimum, mengevaluasi besarnya kesalahan yang mungkin terjadi. </p><br><p>  <b>Catatan</b>  Untuk pengenalan teks, saya menggunakan tesseract 4. Untuk .NET, tidak ada paket NuGet siap pakai dari versi keempat, jadi saya membuat satu dari cabang proyek utama, yang dapat berguna: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Genesis.Tesseract4</a> . </p><br><br><h2>  Algoritma parsing angka dasar </h2><br><p>  Mari kita mulai dengan yang sederhana, yaitu dengan algoritma pengenalan teks yang ditulis dalam kata-kata, sejauh ini tanpa kesalahan.  Jika Anda tertarik untuk parsing pintar, lewati bagian ini. </p><br><p>  Saya tidak terlalu bagus dalam googling, jadi saya tidak segera menemukan algoritma yang sudah jadi untuk menyelesaikan masalah ini.  Namun, ini bahkan menjadi lebih baik, karena  sebuah algoritma yang ditemukan oleh kami sendiri memberi lebih banyak ruang untuk pengkodean.  Dan tugas itu sendiri ternyata menarik. </p><br><p>  Jadi, mari kita ambil sejumlah kecil, misalnya, “seratus dua puluh tiga”.  Ini terdiri dari tiga kata ( <i>token</i> ), yang masing-masing sesuai dengan angka, semua angka ini diringkas: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  Sejauh ini, semuanya sederhana, tetapi kami menggali lebih dalam, misalnya, pertimbangkan angka "dua ratus dua belas ribu seratus lima." </p><br> <code>"    " = ( + ) ×  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  Seperti yang dapat Anda lihat, ketika ada ribuan jumlahnya (serta jutaan dan derajat ribuan lainnya), jumlahnya dibagi menjadi beberapa bagian yang terdiri dari sejumlah kecil lokal, dalam contoh di atas - 212, dan sebuah faktor (1000).  Mungkin ada beberapa fragmen seperti itu, tetapi mereka semua pergi dalam urutan pengganda, misalnya, seribu atau seribu tidak dapat mengikuti seribu.  Ini juga berlaku untuk bagian-bagian dalam jumlah kecil, karena ratusan tidak dapat mengikuti ratusan dan puluhan, sehingga entri "seratus lima ratus" tidak benar.  Kami akan menyebut karakteristik yang menghubungkan dua token dari jenis yang sama <i>level</i> , misalnya, token "seratus" dan "tiga ratus" memiliki satu level, dan itu lebih besar daripada token "fifty". </p><br><p>  Dari pertimbangan ini, lahirlah gagasan tentang algoritma.  Mari kita tuliskan semua token yang mungkin ( <i>sampel</i> ), yang masing-masingnya akan kita tentukan angka, serta dua parameter - level dan tanda pengali. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token </th><th>  Nomor </th><th>  Level </th><th>  Pengganda? </th></tr><tr><td>  nol <br></td><td>  0 <br></td><td>  1 <br></td><td>  tidak <br></td></tr><tr><td>  tunggal / tunggal <br></td><td>  1 <br></td><td>  1 <br></td><td>  tidak <br></td></tr><tr><td>  dua / dua <br></td><td>  2 <br></td><td>  1 <br></td><td>  tidak <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  1 <br></td><td>  tidak <br></td></tr><tr><td>  sembilan belas <br></td><td>  19 <br></td><td>  1 <br></td><td>  tidak <br></td></tr><tr><td>  dua puluh <br></td><td>  20 <br></td><td>  2 <br></td><td>  tidak <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  tidak <br></td></tr><tr><td>  sembilan puluh <br></td><td>  90 <br></td><td>  2 <br></td><td>  tidak <br></td></tr><tr><td>  seratus <br></td><td>  100 <br></td><td>  3 <br></td><td>  tidak <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  tidak <br></td></tr><tr><td>  sembilan ratus <br></td><td>  900 <br></td><td>  3 <br></td><td>  tidak <br></td></tr><tr><td>  ribu / ribuan / ribu <br></td><td>  1.000 <br></td><td>  4 <br></td><td>  iya <br></td></tr><tr><td>  juta / juta / juta <br></td><td>  1.000.000 <br></td><td>  5 <br></td><td>  iya <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  iya <br></td></tr><tr><td>  kuadriliun / kuadriliun / kuadriliun <br></td><td>  1.000.000.000.000.000.000 <br></td><td>  8 <br></td><td>  iya <br></td></tr></tbody></table></div><br><p>  Bahkan, Anda dapat menambahkan token lain ke tabel ini, termasuk untuk bahasa asing, tapi jangan lupa bahwa di beberapa negara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">digunakan sistem penamaan yang</a> panjang, bukan pendek. </p><br><p>  Sekarang mari kita beralih ke parsing.  Kami akan mendapatkan empat jumlah: </p><br><ol><li>  <i>Tingkat global</i> (globalLevel).  Mengindikasikan level pengganda terakhir.  Awalnya tidak terdefinisi dan perlu untuk kontrol.  Jika kita menemukan token pengali yang levelnya lebih besar atau sama dengan global, maka ini adalah kesalahan. </li><li>  <i>Nilai global</i> (globalValue).  Total adder, di mana hasilnya adalah hasil dari mengalikan jumlah dan faktor lokal. </li><li>  <i>Tingkat lokal</i> ( <i>tingkat lokal</i> ).  Menunjukkan level apa yang dimiliki token terakhir.  Awalnya tidak terdefinisi, bekerja serupa dengan level global, tetapi direset setelah ditemukannya pengali. </li><li>  <i>Nilai lokal</i> ( <i>Nilai lokal</i> )  Penambah token yang tidak multiplier, yaitu  nomor hingga 999. </li></ol><br><p>  Algoritma adalah sebagai berikut: </p><br><ol><li>  Pisahkan string menjadi token menggunakan "\ s +" biasa. </li><li>  Kami mengambil token berikutnya, kami mendapatkan informasi tentang hal itu dari sampel. </li><li>  Jika ini adalah pengganda: <br><ul><li>  Jika level global diatur, maka kami memastikan bahwa levelnya lebih besar atau sama dengan level token.  Jika tidak, ini adalah kesalahan, angkanya salah. </li><li>  Setel level global ke level token saat ini. </li><li>  Lipat gandakan nilai token dengan nilai lokal dan tambahkan hasilnya ke nilai global. </li><li>  Kami menghapus nilai dan level lokal. </li></ul></li><li>  Jika ini bukan pengganda: <br><ul><li>  Jika level lokal diatur, maka kami memastikan bahwa levelnya lebih besar atau sama dengan level token.  Jika tidak, ini adalah kesalahan, angkanya salah. </li><li>  Setel level lokal ke level token saat ini. </li><li>  Tambahkan nilai token ke nilai lokal. </li></ul></li><li>  Kami mengembalikan hasilnya sebagai jumlah nilai global dan lokal. </li></ol><br><p>  Contoh pekerjaan untuk angka "dua juta dua ratus dua belas ribu seratus delapan puluh lima." </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  tingkat lokal <br></th><th>  nilai lokal <br></th></tr><tr><td></td><td>  - <br></td><td>  - <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  dua <br></td><td>  - <br></td><td>  - <br></td><td>  1 <br></td><td>  2 <br></td></tr><tr><td>  juta <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  dua ratus <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  dua belas <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  1 <br></td><td>  212 <br></td></tr><tr><td>  ribuan <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  seratus <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  delapan puluh <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  lima <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  1 <br></td><td>  185 <br></td></tr></tbody></table></div><p>  Hasilnya akan menjadi 2.212.185. </p><br><h2>  Penguraian pintar </h2><br><p>  Algoritma ini dapat digunakan untuk mengimplementasikan perbandingan lain, dan tidak hanya untuk parsing angka, untuk alasan ini saya akan mencoba menggambarkannya lebih terinci. </p><br><p>  Dengan parsing nomor yang ditulis dengan benar tahu.  Sekarang mari kita berpikir tentang kesalahan apa yang bisa terjadi jika angka yang diperoleh sebagai akibat dari OCR tidak ditulis dengan benar.  Saya tidak mempertimbangkan opsi lain, tetapi Anda dapat memodifikasi algoritme untuk tugas tertentu. </p><br><p>  Saya telah mengidentifikasi tiga jenis kesalahan yang saya temui dalam proses kerja: </p><br><ol><li>  Ganti karakter dengan orang lain dengan gaya yang mirip.  Misalnya, huruf "c" untuk beberapa alasan diganti dengan "p", dan "n" oleh "dan" dan sebaliknya.  Saat menggunakan tesseract versi ketiga, dimungkinkan untuk mengganti huruf "o" dengan nol.  Kesalahan ini, begitu saja, adalah yang paling umum, dan memerlukan penyetelan untuk pustaka pengenalan tertentu.  Jadi, prinsip kerja tesseract versi 3 dan 4 memiliki perbedaan utama, oleh karena itu kesalahan akan berbeda. <br></li><li>  Token bergabung.  Kata-kata dapat bergabung bersama (belum bertemu sebaliknya).  Dalam kombinasi dengan kesalahan pertama, itu menghasilkan frase iblis seperti "ganda."  Mari kita coba menjelekkan monster seperti itu juga. <br></li><li>  Noise - karakter dan frasa kiri dalam teks.  Sayangnya, ada sedikit yang bisa dilakukan saat ini, tetapi ada prospek ketika mengumpulkan statistik yang cukup signifikan. <br></li></ol><br><p>  Pada saat yang sama, algoritma parsing yang dijelaskan di atas hampir tidak berubah, perbedaan utamanya adalah memecah string menjadi token. </p><br><p>  Tapi mari kita mulai dengan mengumpulkan beberapa statistik tentang penggunaan huruf dalam token.  Dari 33 huruf bahasa Rusia, hanya 20 yang digunakan saat menulis bilangan bulat non-negatif, sebut saja mereka <i>huruf baik</i> : </p><br> <code></code> <br> <br><p>  13 sisanya, masing-masing, akan disebut <i>huruf buruk</i> .  Ukuran maksimum token adalah 12 karakter (13 saat menghitung hingga kuadriliun).  Substring yang lebih panjang dari nilai ini harus dibagi. </p><br><p>  Untuk membandingkan string dan token, saya memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Wagner-Fisher</a> , meskipun saya menyebutnya nama Levenshtein dalam kode.  Saya tidak memerlukan instruksi editorial, jadi saya menerapkan versi algoritma yang ramah memori.  Saya harus mengakui bahwa implementasi algoritma ini ternyata menjadi tugas yang lebih sulit daripada parser itu sendiri. </p><br><p>  Program pendidikan kecil: jarak Levenshtein adalah kasus khusus dari algoritma Wagner-Fisher, ketika biaya memasukkan, menghapus, dan mengganti karakter bersifat statis.  Ini tidak begitu dalam tugas kita.  Jelas, jika kita menemukan huruf yang buruk dalam substring, maka perlu diganti dengan huruf yang baik, tetapi mengganti yang baik dengan yang buruk sangat tidak diinginkan.  Secara umum, itu tidak mungkin, tetapi situasinya tergantung pada tugas tertentu. </p><br><p>  Untuk menjelaskan biaya memasukkan, menghapus, dan mengganti karakter, saya membuat tabel seperti ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke tabel dengan bobot</a> .  Meskipun diisi dengan tiga metode P (jenis kelamin, jari, langit-langit), tetapi jika Anda mengisinya dengan data berdasarkan statistik OCR, Anda dapat secara signifikan meningkatkan kualitas pengenalan angka.  Kode pustaka berisi file sumber daya NumeralLevenshteinData.txt, di mana Anda dapat memasukkan data dari tabel serupa menggunakan Ctrl + A, Ctrl + C dan Ctrl + V. </p><br><p>  Jika karakter non-tabel ditemukan dalam teks, misalnya, nol, maka biaya memasukkannya sama dengan nilai maksimum dari tabel, dan biaya menghapus dan mengganti sama dengan minimum, sehingga algoritme lebih mungkin untuk mengganti nol dengan huruf "o", dan jika Anda menggunakan versi ketiga dari tesseract , maka masuk akal untuk menambahkan nol pada tabel dan menuliskan harga minimum untuk menggantinya dengan huruf "o". </p><br><p>  Jadi, kami menyiapkan data untuk algoritma Wagner-Fisher, mari kita buat perubahan pada algoritma untuk memecah string menjadi token.  Untuk melakukan ini, kami akan menjalani analisis tambahan dari setiap token, tetapi sebelum itu kami akan memperluas informasi tentang token dengan karakteristik berikut: </p><br><ul><li>  <i>Tingkat kesalahan</i>  Angka nyata dari 0 (tidak ada kesalahan) hingga 1 (token tidak benar), yang berarti seberapa baik token dibandingkan dengan sampel. <br></li><li>  <i>Tanda menggunakan token</i> .  Saat mengurai string dengan puing-puing yang diselingi, sebagian token akan dibuang, karena atribut ini tidak akan ditetapkan.  Dalam hal ini, nilai kesalahan total akan dianggap sebagai rata-rata aritmatika dari kesalahan token yang digunakan. <br></li></ul><br><p>  Algoritma Analisis Token: </p><br><ol><li>  Kami mencoba menemukan token di tabel apa adanya.  Jika kami menemukan - semuanya baik-baik saja, kembalikan. </li><li>  Jika tidak, buat daftar opsi yang memungkinkan: </li><li><p>  Kami mencoba mencocokkan token dengan sampel menggunakan algoritma Wagner-Fisher.  Opsi ini terdiri dari satu token (sampel dipetakan) dan kesalahannya sama dengan jarak terbaik dibagi dengan panjang sampel. </p><br>  <b>Contoh:</b> token "nol" dibandingkan dengan sampel "nol", sedangkan jaraknya 0,5, karena  biaya penggantian huruf buruk "y" dengan "o" yang baik adalah 0,5.  Total kesalahan untuk token ini adalah 0,5 / 4 = 0,125. <br></li><li><p>  Jika substring cukup besar (saya punya 6 karakter), kami mencoba membaginya menjadi dua bagian dengan setidaknya 3 karakter di masing-masing.  Untuk string 6 karakter akan ada satu divisi: 3 + 3 karakter.  Untuk string 7 karakter - sudah ada dua opsi, 3 + 4 dan 4 + 3, dll.  Untuk setiap opsi, kami memanggil fungsi analisis token yang sama secara rekursif, kami memasukkan opsi yang diterima ke dalam daftar. </p><br><p>  Agar tidak mati dalam rekursi, kami menentukan tingkat kegagalan maksimum.  Selain itu, opsi yang diperoleh sebagai hasil pembagian secara artifisial terdegradasi dengan jumlah tertentu (opsi, secara default 0,1), sehingga opsi perbandingan langsung lebih bernilai.  Saya harus menambahkan operasi ini, karena  subteps dari tipe "ganda" berhasil dibagi menjadi token "dua" dan "lima", dan tidak dikurangi menjadi "dua puluh".  Sayangnya, ini adalah fitur dari bahasa Rusia. </p><br><p>  <b>Contoh:</b> token "ganda" memiliki perbandingan langsung dengan sampel "dua puluh", kesalahan 0,25.  Selain itu, opsi terbaik untuk membagi adalah "dua" + "lima" dengan biaya 0,25 (mengganti "a" dengan "i"), secara artifisial memburuk menjadi 0,35, akibatnya token "dua puluh" lebih disukai. </p><br></li><li>  Setelah mengkompilasi semua opsi, kami memilih yang terbaik dengan jumlah kesalahan minimum yang berpartisipasi di dalamnya.  Hasilnya dikembalikan. </li></ol><br><p>  Selain itu, verifikasi token dimasukkan ke dalam algoritma pembuatan nomor utama sehingga kesalahan mereka tidak melebihi nilai tertentu (opsi, default 0,67).  Dengan ini, kami menyaring kemungkinan sampah, meskipun tidak terlalu berhasil. </p><br><h2>  Algoritma singkatnya bagi mereka yang terlalu malas untuk membaca teks di atas </h2><br><p>  Kami membagi string input, yang merupakan angka dalam kata, menjadi substring menggunakan \ s + keteraturan, lalu kami mencoba mencocokkan setiap substring dengan token sampel atau membaginya menjadi substring yang lebih kecil, memilih hasil terbaik.  Sebagai hasilnya, kita mendapatkan satu set token dengan mana kita menghasilkan angka, dan nilai kesalahan diambil sebagai rata-rata aritmatika dari kesalahan di antara token yang digunakan dalam generasi. </p><br><h2>  Mempertajam suatu algoritma untuk tugas tertentu </h2><br><p>  Dalam tugas saya, angkanya non-negatif dan relatif kecil, jadi saya akan mengecualikan token yang tidak perlu dari "juta" dan lebih tinggi.  Untuk ujian, pembaca yang budiman, sebaliknya, saya menambahkan token jargon tambahan, yang memungkinkan string parsing seperti "lima potong", "memotong dua ratus" dan bahkan "tiga stolnik dan dua keping emas".  Ini lucu, tetapi bahkan tidak memerlukan perubahan pada algoritma. </p><br><h2>  Perbaikan lebih lanjut </h2><br><p>  Algoritma yang ada memiliki kekurangan: </p><br><ol><li>  <b>Kontrol Kasus.</b>  String "dua ribu" dan "dua ribu" akan dikenali dengan nol kesalahan sebagai 2000. Dalam tugas saya, kontrol kasus tidak diperlukan, bahkan berbahaya, tetapi jika Anda memerlukan fungsi seperti itu, ini diselesaikan dengan memperkenalkan bendera tambahan dalam token yang bertanggung jawab untuk kasus token berikutnya. . <br></li><li>  <b>Angka negatif.</b>  Token minus tambahan diperkenalkan dengan pemrosesan khusus.  Tidak ada yang rumit, tetapi jangan lupa bahwa huruf "y" buruk dan tidak muncul dalam angka, Anda perlu mengubah karakteristik bobotnya atau berharap tidak berubah selama proses OCR. <br></li><li>  <b>Angka pecahan.</b>  Ini diselesaikan dengan mengganti tipe panjang dengan token ganda dan memperkenalkan "persepuluh", "seperseratus", dll ... Jangan lupa untuk merevisi skala surat. <br></li><li>  <b>Pengakuan angka yang dimasukkan oleh pengguna.</b>  Karena  saat memasukkan teks secara manual, kami paling sering membuat kesalahan yang berkaitan dengan mengedit ulang siVMolov, Anda harus menambahkan operasi ini ke algoritma Wagner-Fisher. <br></li><li>  <b>Dukungan untuk bahasa lain.</b>  Kami memperkenalkan token baru, memperluas tabel bobot. <br></li><li>  <b>Penanganan sampah.</b>  Dalam beberapa dokumen, data dicetak, kualitas gambar mungkin buruk, sel mungkin klise kosong.  Dalam hal ini, sampah yang perlu dibersihkan entah bagaimana masuk ke jalur.  Yang terbaik yang bisa saya tawarkan saat ini adalah melakukan pra-proses dokumen sebelum OCR.  Menghapus garis-garis tabel dan mengisinya dengan warna yang dekat dengan warna ruang kosong sel banyak membantu saya.  Ini tidak menyelesaikan semua masalah, tetapi meningkatkan kualitas pengenalan teks dari dokumen di mana tabel memiliki kelengkungan karena memar dokumen atau fotografer yang bengkok.  Idealnya, Anda harus memutar sel itu sendiri dan mengenalinya secara terpisah, jika Anda, tentu saja, memiliki meja sama sekali. <br></li></ol><br><h1>  Jadi apa intinya? </h1><br><p>  Proyek ini memiliki contoh aplikasi konsol yang berjalan melalui file samples.txt dengan contoh untuk parser.  Berikut ini adalah screenshot dari hasilnya: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png"><br><br><p>  Saya menagih Anda untuk mengevaluasi hasilnya, tetapi bagi saya, itu tidak buruk.  Kesalahan untuk contoh pengakuan nyata tidak melebihi 0,25, meskipun saya belum menjalankan seluruh set dokumen yang tersedia, mungkin tidak semuanya akan lancar di sana. </p><br><p>  Adapun bagian terakhir, saya selalu bertanya-tanya berapa banyak ini "dofiga".  Juga, program itu sendiri memberikan jawaban yang memadai untuk berapa banyak yang diperlukan (saya tidak menggunakan, tapi tetap saja) dan bahkan secara akurat menentukan arti dari kata lama Rusia "kegelapan."  Dan ya, kesimpulannya belum termasuk ukuran lain bahwa pendidikan tidak diperbolehkan untuk menambahkan, tetapi program percaya bahwa itu sama dengan seribu =) </p><br><h1>  Beberapa kata tentang perpustakaan </h1><br><p>  Awalnya, rencana saya tidak termasuk pembuatan perpustakaan, saya memutuskan untuk mendesainnya secara eksklusif untuk Habr.  Saya mencoba untuk meletakkan kode, tetapi jika Anda menggunakannya, buatlah garpu atau salinan  kemungkinan besar Anda tidak perlu jargon dan token lain yang termasuk dalam contoh. </p><br><p>  Pustaka itu sendiri ditulis di bawah .NET Standart 2.0 dan C # 7.x, dan algoritme mudah diterjemahkan ke bahasa lain. </p><br><p>  Dalam hal kemungkinan perluasan perpustakaan, saya akan menambahkan komposisi komponen penting dari pengurai angka dalam kata-kata (Genesis.CV.NumberUtils namespace): </p><br><ul><li>  RussianNumber.cs - langsung parser </li><li>  RussianNumber.Data.cs - file dengan deskripsi token </li><li>  RussianNumber.ToString.cs - konverter angka ke teks dalam kata-kata </li><li>  RussianNumberParserOptions.cs - opsi parser </li><li>  NumeralLevenshtein.cs - implementasi algoritma Wagner-Fisher </li><li>  NumeralLevenshteinData.txt - sumber daya, data bobot surat </li></ul><br><p>  Penggunaan: </p><br><ul><li>  RussianNumber.ToString (value) - mengonversi angka menjadi teks </li><li>  RussianNumber.Parse (value, [options]) - mengonversi teks menjadi angka </li></ul><br><h1>  Kesimpulan </h1><br><p>  Saya benar-benar berharap artikel itu tidak terasa membosankan bagi Anda meskipun ada banyak teks.  Baru-baru ini, saya telah menemukan banyak topik yang berkaitan dengan visi komputer, tentang yang ada sesuatu untuk diceritakan, jadi saya ingin tahu pendapat tentang format artikel ini.  Apa yang pantas ditambahkan atau, sebaliknya, dihilangkan?  Apa yang lebih menarik bagi Anda, pembaca, algoritma itu sendiri atau fragmen kode? </p><br><p>  Apakah Anda suka artikelnya?  Lihat yang lain: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan serialisasi JavaScript JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengisi templat teks dengan data berbasis model.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi .NET menggunakan fungsi bytecode dinamis (IL)</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453642/">https://habr.com/ru/post/id453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453618/index.html">Bagaimana kami bekerja dengan ide-ide dan bagaimana LANBIX lahir</a></li>
<li><a href="../id453622/index.html">Programmer Chip G-Shield: Menulis Sertifikat Digital ke Chips pada Tahap Produksi</a></li>
<li><a href="../id453626/index.html">Petualangan di aliran yang terpisah. Laporan Yandex</a></li>
<li><a href="../id453628/index.html">Apa yang akan Anda bayar dalam 20 tahun?</a></li>
<li><a href="../id453634/index.html">Alfa Bank School of System Analysis</a></li>
<li><a href="../id453644/index.html">Wawancara - 10 pertanyaan tentang Swift. Bagian 3</a></li>
<li><a href="../id453646/index.html">Normalisasi data dalam database terdistribusi, layanan mikro dan ERP</a></li>
<li><a href="../id453650/index.html">Inti perangkat lunak dari infrastruktur cyber on-board pemogokan pemogokan terpadu F-35</a></li>
<li><a href="../id453652/index.html">LogRock: Menguji melalui Logging</a></li>
<li><a href="../id453656/index.html">Web statis: kembali ke dasar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>