<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õëÔ∏è üë©üèø‚Äç‚öñÔ∏è ü•Ñ Layanan Cloud Amazon dan Analisis Portofolio Investasi üïì üìã üë©üèº‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, ada volatilitas tinggi di pasar saham, ketika, misalnya, sebuah makalah yang stabil dari sebuah perusahaan terkenal dapat kehilangan be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Layanan Cloud Amazon dan Analisis Portofolio Investasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426027/">  Baru-baru ini, ada volatilitas tinggi di pasar saham, ketika, misalnya, sebuah makalah yang stabil dari sebuah perusahaan terkenal dapat kehilangan beberapa persen sekaligus pada berita sanksi terhadap manajemennya atau sebaliknya melambung ke langit pada laporan positif dan harapan investor tentang dividen super-menguntungkan. <br><br>  Bagaimana menentukan apakah kepemilikan sekuritas tertentu telah menghasilkan pendapatan atau hanya kerugian dan kekecewaan? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(Sumber)</a> <br><br>  Dalam artikel ini saya akan memberi tahu Anda bagaimana mengidentifikasi dan memvisualisasikan hasil keuangan yang disesuaikan untuk efek. <br><br>  Dengan menggunakan contoh pelaporan klien Membuka Pialang, kami akan mempertimbangkan penguraian dan konsolidasi laporan pialang untuk pasar saham, membangun arsitektur sistem pelaporan awan dengan analisis sederhana dan nyaman selanjutnya di AWS Quicksight. <br><a name="habracut"></a><br><h2>  Deskripsi tugas </h2><br>  Banyak pelatihan dan pelajaran pelatihan memberi tahu kami tentang perlunya jurnal trader, di mana semua parameter transaksi dicatat untuk analisis lebih lanjut dan merangkum hasil dari strategi perdagangan.  Saya setuju bahwa pendekatan ini untuk bekerja di Bursa memungkinkan Anda mendisiplinkan seorang pedagang, meningkatkan kesadarannya, tetapi juga dapat membuat Anda lelah dari proses yang membosankan. <br><br>  Saya akui bahwa pada awalnya saya berusaha dengan hati-hati mengikuti saran penjurnalan, dengan cermat menuliskan setiap transaksi dengan parameter-parameternya dalam tabel Excel, membuat beberapa laporan, bagan ringkasan, merencanakan transaksi di masa depan, tetapi ... Saya segera bosan dengan semuanya. <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa menyimpan jurnal trader secara manual tidak nyaman</b> <div class="spoiler_text"><ul><li>  pengisian jurnal secara manual (bahkan menggunakan otomatisasi parsial, dalam bentuk pembongkaran transaksi harian dari terminal perdagangan) dengan cepat ban; </li><li>  ada risiko tinggi kesalahan atau kesalahan ketik dengan entri manual; </li><li>  mungkin terjadi bahwa pedagang aktif menjadi investor pasif dan dia kembali ke majalah ini semakin sedikit, dan kemudian sepenuhnya melupakannya (kasus saya);  baik dan akhirnya </li><li>  kita dapat memprogram, mengapa tidak mengambil keuntungan dari ini dan mengotomatisasi seluruh proses?  Jadi, ayo pergi! </li></ul></div></div><br>  Seringkali, perusahaan pialang adalah organisasi teknologi tinggi yang memberikan analisis analitik berkualitas tinggi kepada hampir semua kliennya tentang hampir semua masalah.  Adalah adil untuk mengatakan bahwa pelaporan ini menjadi semakin baik dengan setiap pembaruan, tetapi bahkan yang paling canggih sekalipun mungkin tidak memiliki penyesuaian dan konsolidasi yang ingin dilihat oleh pelanggan yang ingin tahu dan ingin tahu. <br><br>  Misalnya, Pialang Pembukaan memungkinkan Anda untuk menerima laporan pialang dalam format XML di akun pribadi Anda, tetapi jika Anda memiliki IIA dan akun pialang biasa di Moscow Stock Exchange (MOEX), ini akan menjadi dua laporan yang berbeda, dan jika Anda memiliki akun lain di St. Petersburg Stock Exchange (SPB), maka dua yang pertama akan menambah satu lagi. <br><br>  Secara total, untuk mendapatkan jurnal konsolidasi investor, perlu untuk memproses tiga file dalam format XML. <br><br>  Laporan yang disebutkan di atas tentang MOEX dan SPB sedikit berbeda dalam formatnya, yang perlu dipertimbangkan dalam proses penerapan pemetaan data. <br><br><h2>  Arsitektur sistem dalam pengembangan </h2><br>  Diagram di bawah ini menunjukkan model arsitektur sistem yang sedang dikembangkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2>  Implementasi Parser </h2><br>  Kami akan menerima laporan pada ketiga akun di Akun Pribadi untuk periode maksimum yang mungkin (dapat dibagi menjadi beberapa laporan untuk setiap tahun), menyimpannya dalam format XML dan menempatkannya dalam satu folder.  Sebagai data uji untuk penelitian ini, kami akan menggunakan portofolio klien fiktif, tetapi dengan parameter sedekat mungkin dengan realitas pasar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br>  Misalkan investor Mr X sedang dipertimbangkan memiliki portofolio kecil dari lima sekuritas: <br><br><ol><li>  Laporan pertukaran SPB akan memiliki dua makalah: Apple dan Microsoft; </li><li>  Laporan tentang pertukaran MOEX (broker) berisi satu makalah: FGC UES; </li><li>  Laporan di MOEX Exchange (IIS) berisi dua sekuritas: MMK dan OFZ 24019; </li></ol><br>  Menurut lima sekuritas kami, mungkin ada transaksi pembelian / penjualan, pembayaran dividen dan kupon, harga dapat berubah, dll.  Kami ingin melihat situasi saat ini, yaitu: hasil keuangan, dengan memperhitungkan semua pembayaran, transaksi, dan nilai pasar saat ini. <br><br>  Dan di sini Python berperan, kami membaca informasi dari semua laporan menjadi satu array: <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote>  Untuk analitik, dari laporan kami memerlukan beberapa entitas, yaitu: <br><br><ul><li>  Posisi sekuritas dalam portofolio; </li><li>  Kesepakatan akhir; </li><li>  Operasi non-perdagangan dan pergerakan akun lainnya; </li><li>  Harga rata-rata posisi terbuka </li></ul></blockquote>  Untuk menyiapkan sampel, kami akan menggunakan empat kamus untuk menggambarkan set di atas. <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br>  Beberapa kata tentang kamus ini. <br><br><div class="spoiler">  <b class="spoiler_title">Kamus Dict_stocks</b> <div class="spoiler_text">  Kamus dict_stocks diperlukan untuk menyimpan informasi umum tentang portofolio: <br><br><ul><li>  Nama kertas (stock_name); </li><li>  Nama akun (SPB, MOEX BROK, MOEX IIS) (akun); </li><li>  Mata uang yang digunakan untuk penyelesaian pada makalah ini (mata uang); </li><li>  Nilai saat ini (pada saat menghasilkan laporan di Pialang Pembukaan Akun Pribadi) (current_cost).  Di sini saya ingin mencatat bahwa untuk pelanggan yang terlalu menuntut, dimungkinkan untuk melakukan perbaikan tambahan di masa depan dan menggunakan tanda terima dinamis dari kutipan keamanan dari terminal perdagangan atau dari situs web pertukaran yang sesuai; </li><li>  Nilai posisi keamanan saat ini pada saat laporan dihasilkan (current_cost_rub) <br>  Demikian pula dengan item di atas, di sini Anda juga bisa mendapatkan kurs Bank Sentral pada saat ini atau kurs, sesuka Anda. </li><li>  Saldo surat berharga saat ini (saldo) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Kamus dict_deals</b> <div class="spoiler_text">  Kamus dict_deals diperlukan untuk menyimpan informasi berikut tentang transaksi yang diselesaikan: <br><br><ul><li>  Nama kertas (stock_name); </li><li>  Nama akun (SPB, MOEX BROK, MOEX IIS) (akun); </li><li>  Tanggal transaksi, mis.  T0 (date_oper); </li><li>  Jenis operasi (type_oper); </li><li>  Volume sekuritas yang berpartisipasi dalam transaksi (kuantitas); </li><li>  Harga di mana transaksi dilakukan (harga); </li><li>  Mata uang tempat transaksi dilakukan (mata uang); </li><li>  Komisi pialang untuk transaksi (pialang); </li><li>  Hasil keuangan dari transaksi (hasil) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Kamus Dict_flows</b> <div class="spoiler_text">  Kamus dict_flows mencerminkan pergerakan dana pada akun klien dan digunakan untuk menyimpan informasi berikut: <br><br><ul><li>  Nama kertas (stock_name); </li><li>  Nama akun (SPB, MOEX BROK, MOEX IIS) (akun); </li><li>  Tanggal transaksi, mis.  T0 (date_oper); </li><li>  Jenis operasi (type_oper).  Ini dapat mengambil beberapa nilai: div, NKD, pajak; </li><li>  Mata uang tempat transaksi dilakukan (mata uang); </li><li>  Hasil keuangan dari operasi (hasil) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Kamus dict_avg_harga</b> <div class="spoiler_text">  Kamus dict_avg_price diperlukan untuk informasi akuntansi dengan harga pembelian rata-rata untuk setiap makalah: <br><br><ul><li>  Nama kertas (stock_name); </li><li>  Nama akun (SPB, MOEX BROK, MOEX IIS) (akun); </li><li>  Harga rata-rata posisi terbuka (avg_open_price) </li></ul></div></div><br>  Kami memproses berbagai dokumen XML dan mengisi kamus-kamus ini dengan data yang sesuai: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br>  Semua pemrosesan melewati loop atas semua data XML dari laporan.  Informasi tentang platform perdagangan, kode klien sama di semua laporan, sehingga Anda dapat dengan aman mengekstraknya dari tag yang sama tanpa menggunakan pemetaan. <br><br>  Tetapi kemudian kita harus menggunakan desain khusus yang akan memberikan alias yang diperlukan untuk tag berdasarkan laporan (SPB atau MOEX), karena  identik dalam sifat data dalam laporan ini disebut berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Tandai perbedaan</b> <div class="spoiler_text"><ul><li>  Komisi broker transaksi dalam laporan SBP terletak pada tag <b>broker</b> , dan dalam laporan <b>MOEX</b> - <b>broker_commission</b> ; </li><li>  Tanggal transaksi akun non-perdagangan dalam laporan SPB adalah tanggal <b>operasi</b> , dan dalam MOEX, itu adalah tanggal <b>operasi</b> , dll. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Contoh Pemetaan Tag</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  Fungsi get_allias mengembalikan nama tag yang diperlukan untuk diproses, dengan mengambil nama platform perdagangan sebagai input: <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi Get_allias</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br>  Fungsi get_briefcase bertanggung jawab untuk memproses informasi tentang status portofolio klien: <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi Get_briefcase</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Selanjutnya, fungsi get_deals mengambil informasi tentang transaksi: <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi Get_deals</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Selain memproses array dengan informasi tentang parameter transaksi, harga rata-rata posisi terbuka dan direalisasikan oleh PNL menggunakan metode FIFO juga dihitung di sini.  Kelas PnlSnapshot bertanggung jawab untuk perhitungan ini, untuk pembuatan yang dengan modifikasi kecil kode yang disajikan di sini diambil sebagai dasar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perhitungan P&amp;L</a> <br><br>  Dan akhirnya, yang paling sulit untuk diterapkan adalah fungsi mendapatkan informasi tentang operasi non-perdagangan - <b>get_nontrade_operation</b> .  Kompleksitasnya terletak pada kenyataan bahwa dalam blok laporan yang digunakan untuk operasi non-perdagangan, tidak ada informasi yang jelas tentang jenis transaksi dan keamanan yang terikat operasi ini. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh tujuan pembayaran untuk operasi non-perdagangan</b> <div class="spoiler_text">  Pembayaran dividen atau akumulasi pendapatan kupon dapat diindikasikan sebagai berikut: <br><br><ol><li>  Pembayaran klien pendapatan &lt;777777&gt; <font color="#cc0000">dividen</font> &lt; <font color="#cc0000">APPLE</font> INC-ao&gt; -&gt; pembayaran dividen dari laporan SPB; </li><li>  Pembayaran klien pendapatan &lt;777777&gt; <font color="#cc0000">dividen</font> &lt; <font color="#cc0000">MICROSOFT</font> COM-any&gt; </li><li>  Pembayaran pendapatan pelanggan 777777i (NKD 2 <font color="#cc0000">OFZ 24019</font> ) memotong pajak 0,00 rubel -&gt; pembayaran kupon dari laporan MOEX; </li><li>  Pembayaran pendapatan kepada klien 777777 <font color="#cc0000">dividen FGC UES -</font> pajak pemotongan XX.XX rubel -&gt; pembayaran dividen dari laporan MOEX.  dll. </li></ol></div></div><br>  Karenanya, akan sulit dilakukan tanpa ekspresi reguler, jadi kami akan menggunakannya sepenuhnya.  Sisi lain dari masalah ini adalah bahwa nama perusahaan tidak selalu bertepatan dengan nama dalam portofolio atau dalam transaksi dalam tujuan pembayaran.  Oleh karena itu, nama yang diterima penerbit dari tujuan pembayaran harus dikorelasikan dengan kamus.  Sebagai kamus, kami akan menggunakan berbagai penawaran, karena  ada daftar perusahaan terlengkap. <br><br>  Fungsi <b>get_company_from_str</b> mengambil nama penerbit dari komentar: <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi Get_company_from_str</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br>  Fungsi <b>get_company_from_briefcase</b> mengarahkan nama perusahaan ke kamus jika menemukan kecocokan di antara perusahaan yang berpartisipasi dalam transaksi: <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi Get_company_from_briefcase</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br>  Dan akhirnya, fungsi terakhir mengumpulkan data pada operasi non-perdagangan adalah <b>get_nontrade_operation</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi get_nontrade_operation</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br>  Hasil pengumpulan data dari laporan adalah tiga DataFrames, yang kira-kira sebagai berikut: <br><br><ol><li>  DataFrame dengan informasi harga rata-rata posisi terbuka: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li>  Menangani DataFrame: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li>  DataFrame dengan informasi tentang operasi non-perdagangan: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br>  Jadi, yang harus kita lakukan adalah melakukan penyatuan eksternal dari tabel transaksi dengan tabel informasi portofolio: <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br>  Dan akhirnya, bagian terakhir dari pemrosesan array data adalah penggabungan array data yang diperoleh pada langkah sebelumnya dengan DataFrame untuk transaksi non-perdagangan. <br>  Hasil pekerjaan yang dilakukan adalah satu meja datar besar dengan semua informasi yang diperlukan untuk analisis: <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br>  Kumpulan data yang dihasilkan (Laporan Akhir) dari DataFrame mudah diunggah ke CSV dan kemudian dapat digunakan untuk analisis terperinci dalam sistem BI apa pun. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2>  Unggah dan proses data dalam AWS </h2><br>  Kemajuan tidak berhenti dan sekarang layanan cloud dan model komputasi tanpa server mendapatkan popularitas besar dalam pemrosesan dan penyimpanan data.  Ini sebagian besar disebabkan oleh kesederhanaan dan murahnya pendekatan ini, ketika Anda tidak perlu membeli peralatan mahal untuk membangun arsitektur sistem untuk komputasi kompleks atau memproses data besar, tetapi Anda hanya menyewa daya di cloud untuk waktu yang Anda butuhkan dan menggunakan sumber daya yang diperlukan dengan cukup cepat dengan biaya yang relatif kecil untuk biaya yang relatif kecil . <br><br>  Salah satu penyedia cloud terbesar dan paling terkenal di pasar adalah Amazon.  Mari kita lihat contoh lingkungan Amazon Web Services (AWS) untuk membangun sistem analitis untuk memproses data pada portofolio investasi kami. <br><br>  AWS memiliki banyak pilihan alat, tetapi kami akan menggunakan yang berikut ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon S3</a> - penyimpanan objek, yang memungkinkan Anda menyimpan informasi dalam jumlah hampir tak terbatas; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS Glue</a> - layanan cloud ETL paling kuat yang dapat dengan sendirinya menentukan struktur dan menghasilkan kode ETL dari data sumber yang diberikan; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon Athena</a> , layanan query SQL online tanpa server, memungkinkan Anda untuk dengan cepat menganalisis data dari S3 tanpa banyak persiapan.  Dia juga memiliki akses ke metadata yang dipersiapkan AWS Glue, yang memungkinkan Anda untuk mengakses data segera setelah melewati ETL; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon QuickSight</a> - BI-service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serverless</a> , Anda dapat membangun visualisasi, laporan analitis "on the fly", dll. </li></ul><br>  Dokumentasi Amazon baik-baik saja, khususnya, ada artikel bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik Terbaik Saat Menggunakan Athena dengan AWS Glue</a> , yang menjelaskan cara membuat dan menggunakan tabel dan data menggunakan AWS Glue.  Mari kita manfaatkan ide-ide utama artikel ini dan menerapkannya untuk membuat arsitektur kita sendiri dari sistem pelaporan analitis. <br><br>  File CSV yang disiapkan oleh pengurai laporan kami akan ditambahkan ke bucket S3.  Direncanakan bahwa folder yang sesuai pada S3 akan diisi ulang setiap hari Sabtu - pada akhir minggu perdagangan, sehingga Anda tidak dapat melakukannya tanpa partisi data berdasarkan tanggal pembentukan dan pemrosesan laporan. <br>  Selain mengoptimalkan operasi kueri SQL ke data tersebut, pendekatan ini akan memungkinkan kami untuk melakukan analisis tambahan, misalnya, untuk mendapatkan dinamika perubahan dalam hasil keuangan untuk setiap makalah, dll. <br><br><div class="spoiler">  <b class="spoiler_title">Bekerja dengan Amazon S3</b> <div class="spoiler_text"><ul><li>  Buat ember di S3, sebut saja "report-parser"; </li><li>  Dalam ember ini "report-parser" membuat folder bernama "my_trader_diary"; </li><li>  Dalam direktori "my_trader_diary" buat direktori dengan tanggal laporan saat ini, misalnya, "date_report = 2018-10-01" dan tempatkan file CSV di dalamnya; </li><li>  Hanya demi percobaan dan pemahaman partisi yang lebih baik, kami akan membuat dua direktori lagi: "date_report = 2018-09-27" dan "date_report = 2018-10-08".  Kami memasukkan file CSV yang sama di dalamnya; </li><li>  "S3-parser" bucket S3 terakhir harus seperti yang ditunjukkan pada gambar di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Bekerja dengan Lem AWS</b> <div class="spoiler_text">  Pada umumnya, Anda hanya dapat melakukan Amazon Athena untuk membuat tabel eksternal dari data yang ada pada S3, tetapi AWS Glue adalah alat yang lebih fleksibel dan nyaman untuk ini. <br><br><ul><li>  Kami masuk ke AWS Glue dan membuat Crawler baru, yang akan mengumpulkan satu tabel dari file CSV terpisah dengan melaporkan tanggal: <br><ul><li>  Tetapkan nama Crawler baru; </li><li>  Kami menunjukkan repositori dari mana mendapatkan data (s3: // report-parser / my_trader_diary /) </li><li>  Kami memilih atau membuat peran IAM baru yang akan memiliki akses untuk meluncurkan Crawler dan akses ke sumber daya yang ditentukan pada S3; </li><li>  Selanjutnya, Anda perlu mengatur frekuensi mulai.  Kami menetapkan permintaan untuk saat ini, tetapi di masa depan, saya pikir ini akan berubah dan peluncuran akan menjadi mingguan; </li><li>  Simpan dan tunggu Crawler dibuat. </li></ul></li><li>  Ketika Perayap memasuki status Siap, mulai saja! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li>  Setelah berfungsi, tabel my_trader_diary baru akan muncul di AWS Glue: Database -&gt; tab Tables: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br>  Pertimbangkan tabel yang dihasilkan secara lebih detail. <br>  Jika Anda mengklik nama tabel yang dibuat, maka kami akan pergi ke halaman dengan deskripsi metadata.  Di bagian bawah ada tata letak tabel dan yang terbaru adalah kolom yang tidak ada dalam file CSV sumber - date_report.  Kolom ini dibuat oleh AWS Glue secara otomatis berdasarkan definisi bagian dari sumber data (dalam Bucket S3, kami secara khusus menamai folder date_report = YYYY-MM-DD, yang memungkinkan kami untuk menggunakannya sebagai bagian yang dipisahkan oleh tanggal). <br><br><div class="spoiler">  <b class="spoiler_title">Partisi tabel</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br>  Pada halaman yang sama di sudut kanan atas terdapat tombol Lihat partisi, dengan mengklik di mana kita dapat melihat bagian mana yang dihasilkan tabel kita terdiri dari: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2>  Analisis data </h2><br>  Setelah kami mengunggah data yang diunggah, kami dapat dengan mudah mulai menganalisisnya.  Untuk memulai, pertimbangkan kemampuan Amazon Athena sebagai cara termudah dan tercepat untuk melakukan kueri analitik.  Untuk melakukan ini, pergi ke layanan Amazon Athena, pilih database yang kami butuhkan (finansial) dan tulis kode SQL berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br>  Permintaan ini akan menampilkan kepada kami hasil keuangan bersih untuk setiap keamanan untuk semua tanggal pelaporan.  Karena  kami mengunduh laporan yang sama tiga kali untuk tanggal yang berbeda, hasilnya tidak akan berubah, yang, tentu saja, di pasar nyata akan berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br>  Tetapi bagaimana jika kita ingin memvisualisasikan data yang diterima dalam bentuk tabel atau diagram yang fleksibel?  Di sini Amazon QuickSight datang untuk menyelamatkan, dengan bantuan yang Anda dapat mengkonfigurasi analisis fleksibel hampir secepat menulis query SQL.  Kami akan pergi ke layanan Amazon QuickSight (jika Anda belum mendaftar di sana, maka pendaftaran diperlukan). <br><br>  Klik pada tombol Analisis baru -&gt; Dataset baru dan di jendela yang muncul pilih sumber untuk dataset, klik pada Athena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br>  Kami akan datang dengan nama untuk sumber data kami, misalnya, "PNL_analisis" dan klik tombol "Buat sumber data". <br><br>  Selanjutnya, jendela Choose your table open, di mana Anda perlu memilih database dan tabel sumber data.  Kami memilih database - keuangan, dan tabel di dalamnya: my_traider_diary.  Secara default, seluruh tabel digunakan, tetapi jika Anda memilih "Gunakan SQL kustom", Anda dapat menyesuaikan dan menyempurnakan sampel data yang Anda butuhkan.  Sebagai contoh, kami menggunakan seluruh tabel dan klik tombol Edit / Pratinjau Data. <br><br>  Halaman baru akan terbuka di mana Anda dapat membuat pengaturan tambahan dan memproses data yang ada. <br><br>  Sekarang kita perlu menambahkan bidang terhitung tambahan ke dataset kami: kuartal dan tahun operasi.  Pembaca yang penuh perhatian mungkin memperhatikan bahwa manipulasi seperti itu lebih mudah dilakukan di sisi parser sebelum menyimpan Laporan Akhir ke CSV.  Tidak diragukan lagi, tujuan saya sekarang adalah untuk menunjukkan kemampuan dan fleksibilitas pengaturan sistem BI dengan cepat.  Kami terus membuat bidang terhitung dengan mengklik tombol "Bidang baru". <br><br><div class="spoiler">  <b class="spoiler_title">Buat bidang baru</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br>  Untuk menyoroti tahun operasi dan kuartal, rumus sederhana digunakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">Mengisi rumus untuk bidang baru</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br>  Ketika bidang terhitung telah berhasil dibuat dan ditambahkan ke pilihan, berikan nama ke dataset kami, misalnya, "my_pnl_analyze" dan klik tombol "Simpan dan visualisasikan". <br><br>  Setelah itu, kami mentransfer ke papan utama Amazon QuickSight dan hal pertama yang perlu kami lakukan adalah menyiapkan filter untuk tanggal laporan (dengan mempertimbangkan bahwa data yang sama dikumpulkan dari tiga bagian).  Pilih tanggal pelaporan 2018-10-01 dan klik tombol Terapkan dan buka tab Visualisasikan. <br><br><div class="spoiler">  <b class="spoiler_title">Pengaturan filter</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat memvisualisasikan hasil portofolio di pesawat apa pun, misalnya, untuk setiap keamanan di dalam akun perdagangan, dan dibagi pada gilirannya dengan mata uang (karena hasilnya tidak sebanding dalam mata uang yang berbeda) dan jenis operasi. </font><font style="vertical-align: inherit;">Mari kita mulai dengan alat paling kuat dari BI - tabel pivot. </font><font style="vertical-align: inherit;">Untuk menghemat ruang dan menampilkan fleksibilitas, saya meletakkan mata uang dalam kontrol terpisah (analog slice di MS Excel)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel di atas menunjukkan bahwa jika seorang investor memutuskan untuk menjual semua saham FGC UES sekarang, ia dengan demikian akan mencatat kerugian, seperti </font><font style="vertical-align: inherit;">Dividen dibayarkan dalam jumlah 1.509,91 p. </font><font style="vertical-align: inherit;">mereka tidak menanggung biayanya (1.763,36 rubel - perbedaan nilai tukar negatif dan 174 rubel - pajak penghasilan pribadi atas dividen). </font><font style="vertical-align: inherit;">Masuk akal untuk menunggu dan menunggu waktu yang lebih baik di Exchange.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grafik berikut adalah bagan batang: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sekarang kita akan membentuk tabel yang akan menunjukkan kepada kita berapa banyak kita berinvestasi di masing-masing kertas, berapa hari itu dalam portofolio kita dan berapa profitabilitas untuk seluruh periode kepemilikan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan dua bidang terhitung baru: sum_investment dan count_days.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah sum_investment</font></font></b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       ‚Äì     (    ‚Äì 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang count_days</font></font></b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tabel final disajikan pada tangkapan layar di bawah ini: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulan dan Ringkasan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami telah memeriksa dengan Anda implementasi parser laporan dan metode untuk menganalisis data yang disiapkan olehnya ‚Äúon the fly‚Äù menggunakan layanan Amazon. Kami juga menyentuh beberapa aspek bisnis dan fundamental dari analisis portofolio investasi, seperti topik ini hampir sangat besar dan agak sulit untuk memasangnya dalam satu artikel, saya pikir masuk akal untuk meletakkannya di publikasi terpisah atau bahkan serangkaian publikasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapun penggunaan alat pemrosesan pelaporan broker dan pendekatan serta algoritma yang terlibat di dalamnya, mereka dapat digunakan (dengan modifikasi yang sesuai) untuk memproses pelaporan broker lain. Bagaimanapun, jika Anda berencana untuk menyesuaikan kode dengan kebutuhan Anda, saya siap memberikan beberapa tips, jadi jangan ragu untuk bertanya - saya pasti akan mencoba menjawabnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya yakin bahwa sistem ini akan menemukan aplikasinya dan akan memiliki pengembangan lebih lanjut. Misalnya, direncanakan untuk menambah perhitungan PNL lengkap untuk portofolio, akuntansi penyimpanan dan biaya lainnya (misalnya, untuk menarik dana), serta membayar obligasi, dll. ... Bidang yang dihitung pada sisi Quicksight digunakan untuk tujuan demonstrasi, dalam versi pengurai berikutnya, semua kolom tambahan ini akan porting ke Python dan akan dihitung pada sisi parser.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai seorang arsitek dan pelanggan bisnis utama dari solusi ini, saya melihat peningkatan lebih lanjut sebagai berikut: well, saya tidak ingin secara manual meminta laporan XML ini setiap waktu! </font><font style="vertical-align: inherit;">Tentu saja, tidak ada kemungkinan lain sejauh ini, tetapi API Broker dengan transfer token dan rentang pengambilan sampel akan ideal untuk menerima pelaporan mentah mingguan. </font><font style="vertical-align: inherit;">Pemrosesan otomatis penuh selanjutnya di sisi Amazon: mulai dari memicu pekerjaan ETL pada AWS Glue hingga mendapatkan hasil yang sudah jadi dalam bentuk grafik dan tabel di Amazon QuickSight akan memungkinkan Anda untuk mengotomatiskan proses sepenuhnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode sumber lengkap dapat ditemukan di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">repositori GitHub</font></a><font style="vertical-align: inherit;"> saya</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426027/">https://habr.com/ru/post/id426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426017/index.html">Cara mengurangi jumlah percobaan pada hewan</a></li>
<li><a href="../id426019/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 5</a></li>
<li><a href="../id426021/index.html">libgdx dan perasaan</a></li>
<li><a href="../id426023/index.html">Buka pelajaran "Laboratorium Virtual di Vagrant"</a></li>
<li><a href="../id426025/index.html">Menggunakan metode ofensif untuk memperkaya Threat Intelligence</a></li>
<li><a href="../id426029/index.html">Apakah Anda menyerah dan ingin berhenti dari tugas itu? Seperti inilah pelatihan pengembang yang efektif</a></li>
<li><a href="../id426031/index.html">Khawatir tentang kecerdasan buatan yang mengambil alih dunia mungkin didasarkan pada asumsi yang tidak ilmiah</a></li>
<li><a href="../id426033/index.html">Titans matematika berbenturan dengan bukti epik hipotesis abc</a></li>
<li><a href="../id426039/index.html">Peluncuran darurat "Soyuz MS-10" (kru diselamatkan, disiarkan)</a></li>
<li><a href="../id426041/index.html">Solusi simbolik dari persamaan diferensial linear dan sistem dengan metode transformasi Laplace menggunakan SymPy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>