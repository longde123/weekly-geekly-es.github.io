<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏼 👇🏾 😕 Handbuch zur Android-Anwendungsarchitektur ⛹🏿 💼 👩🏿‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die kostenlose Übersetzung von "Guide to App Architecture" von JetPack . Ich bitte Sie, alle Kommentare zur Übersetz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Handbuch zur Android-Anwendungsarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456256/">  Hallo Habr!  Ich präsentiere Ihnen die kostenlose Übersetzung von "Guide to App Architecture" von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JetPack</a> .  Ich bitte Sie, alle Kommentare zur Übersetzung in den Kommentaren zu hinterlassen, und sie werden behoben.  Auch Kommentare von Personen, die die vorgestellte Architektur mit Empfehlungen für ihre Verwendung verwendet haben, sind für alle nützlich. <br><br>  Dieses Handbuch behandelt Best Practices und empfohlene Architekturen zum Erstellen robuster Anwendungen.  Diese Seite setzt eine grundlegende Einführung in das Android Framework voraus.  Wenn Sie mit der Entwicklung von Android-Apps noch nicht vertraut sind, lesen Sie zunächst unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklerhandbücher</a> , um mehr über die in diesem Handbuch genannten Konzepte zu erfahren.  Wenn Sie sich für Anwendungsarchitektur interessieren und sich mit den Materialien in diesem Handbuch in Bezug auf die Programmierung auf Kotlin vertraut machen möchten, lesen Sie den Udacity-Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Entwickeln von Anwendungen für Android mit Kotlin“</a> . <br><br><h2>  Mobile App Benutzererfahrung </h2><br>  In den meisten Fällen haben Desktopanwendungen einen einzigen Einstiegspunkt vom Desktop oder Launcher und werden dann als einzelner monolithischer Prozess ausgeführt.  Android-Anwendungen haben eine viel komplexere Struktur.  Eine typische Android-Anwendung enthält mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungskomponenten</a> , darunter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivitäten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragmente</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienste</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ContentProvider</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BroadcastReceiver</a> . <br><br>  Sie deklarieren alle oder einige dieser Anwendungskomponenten im Anwendungsmanifest.  Android verwendet diese Datei dann, um zu entscheiden, wie Ihre Anwendung in die allgemeine Benutzeroberfläche des Geräts integriert werden soll.  Da eine gut geschriebene Android-Anwendung mehrere Komponenten enthält und Benutzer häufig in kurzer Zeit mit mehreren Anwendungen interagieren, müssen sich Anwendungen an verschiedene Arten von Workflows und benutzergesteuerten Aufgaben anpassen. <br><a name="habracut"></a><br>  Überlegen Sie beispielsweise, was passiert, wenn Sie ein Foto in Ihrer bevorzugten Social Media-Anwendung freigeben: <br><br><ol><li>  Die Anwendung löst die Absicht der Kamera aus.  Android startet eine Kameraanwendung, um die Anfrage zu verarbeiten.  Im Moment hat der Benutzer die Anwendung für soziale Netzwerke verlassen, und seine Erfahrung als Benutzer ist einwandfrei. </li><li>  Eine Kameraanwendung kann andere Absichten auslösen, z. B. das Starten einer Dateiauswahl, mit der möglicherweise eine andere Anwendung gestartet wird. </li><li>  Am Ende kehrt der Benutzer zur Anwendung für soziale Netzwerke zurück und teilt das Foto. </li></ol><br>  Der Benutzer kann jederzeit durch einen Anruf oder eine Benachrichtigung unterbrochen werden.  Nach der mit diesem Interrupt verbundenen Aktion erwartet der Benutzer, dass er diesen Fotofreigabeprozess zurückgeben und fortsetzen kann.  Dieses Anwendungswechselverhalten ist auf Mobilgeräten üblich, daher muss Ihre Anwendung diese Punkte (Aufgaben) korrekt behandeln. <br><br>  Denken Sie daran, dass die Ressourcen mobiler Geräte ebenfalls begrenzt sind. Daher kann das Betriebssystem jederzeit einige Anwendungsprozesse zerstören, um Speicherplatz für neue freizugeben. <br><br>  Unter den Bedingungen dieser Umgebung können die Komponenten Ihrer Anwendung einzeln und nicht in der richtigen Reihenfolge gestartet werden, und das Betriebssystem oder der Benutzer können sie jederzeit zerstören.  Da diese Ereignisse nicht unter Ihrer Kontrolle stehen, <b>sollten Sie keine Daten oder Zustände in Ihren Anwendungskomponenten speichern</b> und Ihre Anwendungskomponenten sollten nicht voneinander abhängig sein. <br><br><h2>  Allgemeine architektonische Prinzipien </h2><br>  Wie sollten Sie Ihre Anwendung entwickeln, wenn Sie keine Anwendungskomponenten zum Speichern von Daten und Anwendungsstatus verwenden sollten? <br><br><h3>  Aufteilung der Verantwortung </h3><br>  Das wichtigste Prinzip ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Aufteilung der Verantwortlichkeiten</a> .  Ein häufiger Fehler ist, wenn Sie Ihren gesamten Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivität</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragment</a> schreiben.  Dies sind Benutzeroberflächenklassen, die nur eine Logik enthalten sollten, die die Interaktion der Benutzeroberfläche und des Betriebssystems verarbeitet.  Indem Sie die Verantwortung in diesen Klassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(SRPs)</a> so weit wie möglich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teilen</a> , können Sie viele der Probleme vermeiden, die mit dem Anwendungslebenszyklus verbunden sind. <br><br><h3>  Steuerung der Benutzeroberfläche vom Modell </h3><br>  Ein weiteres wichtiges Prinzip ist, dass Sie <b>Ihre Benutzeroberfläche von einem Modell</b> aus <b>steuern</b> müssen, vorzugsweise von einem permanenten Modell aus.  Modelle sind die Komponenten, die für die Verarbeitung der Daten für die Anwendung verantwortlich sind.  Sie sind unabhängig von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">View-</a> Objekten und Anwendungskomponenten und daher nicht vom Anwendungslebenszyklus und den damit verbundenen Problemen betroffen. <br><br>  Ein permanentes Modell ist aus folgenden Gründen ideal: <br><br><ul><li>  Ihre Benutzer verlieren keine Daten, wenn das Android-Betriebssystem Ihre Anwendung zerstört, um Ressourcen freizugeben. </li><li>  Ihre Anwendung funktioniert weiterhin, wenn die Netzwerkverbindung instabil oder nicht verfügbar ist. </li></ul><br>  Durch die Organisation der Grundlage Ihrer Anwendung in Modellklassen mit einer klar definierten Verantwortung für das Datenmanagement wird Ihre Anwendung testbarer und unterstützbarer. <br><br><h2>  Empfohlene Anwendungsarchitektur </h2><br>  In diesem Abschnitt wird gezeigt, wie Sie eine Anwendung mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturkomponenten</a> strukturieren und in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End-</a> to- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End-Nutzungsszenario arbeiten</a> . <br><br>  <i><b>Hinweis</b></i>  <i>Es ist nicht möglich, Anwendungen zu schreiben, die für jedes Szenario am besten geeignet sind.</i>  <i>Die empfohlene Architektur ist jedoch ein guter Ausgangspunkt für die meisten Situationen und Workflows.</i>  <i>Wenn Sie bereits eine gute Möglichkeit haben, Android-Anwendungen zu schreiben, die den allgemeinen Architekturprinzipien entsprechen, sollten Sie diese nicht ändern.</i> <br><br>  Stellen Sie sich vor, wir erstellen eine Benutzeroberfläche, in der ein Benutzerprofil angezeigt wird.  Wir verwenden eine private API und eine REST-API, um Profildaten abzurufen. <br><br><h3>  Rückblick </h3><br>  Betrachten Sie zunächst das Interaktionsschema der Module der Architektur der fertigen Anwendung: <br><br><img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br><br>  Bitte beachten Sie, dass jede Komponente nur eine Ebene darunter von der Komponente abhängt.  Beispielsweise hängen Aktivität und Fragmente nur vom Ansichtsmodell ab.  Repository ist die einzige Klasse, die von vielen anderen Klassen abhängt.  In diesem Beispiel hängt der Speicher von einem persistenten Datenmodell und einer internen Remote-Datenquelle ab. <br><br>  Dieses Entwurfsmuster schafft eine konsistente und angenehme Benutzererfahrung.  Unabhängig davon, ob der Benutzer einige Minuten nach dem Schließen oder einige Tage später zur Anwendung zurückkehrt, werden ihm sofort Benutzerinformationen angezeigt, dass die Anwendung lokal gespeichert ist.  Wenn diese Daten nicht mehr aktuell sind, aktualisiert das Anwendungsspeichermodul die Daten im Hintergrund. <br><br><h3>  Erstellen Sie eine Benutzeroberfläche </h3><br>  Die Benutzeroberfläche besteht aus dem Fragment <code>UserProfileFragment</code> und der entsprechenden <code>user_profile_layout.xml</code> . <br><br>  Zur Verwaltung der Benutzeroberfläche muss unser Datenmodell die folgenden Datenelemente enthalten: <br><br><ul><li>  <b>Benutzer-ID:</b> Benutzer-ID.  Die beste Lösung besteht darin, diese Informationen mit den Argumenten des Fragments an das Fragment zu übergeben.  Wenn das Android-Betriebssystem unseren Prozess zerstört, werden diese Informationen gespeichert, sodass die Kennung beim nächsten Start unserer Anwendung verfügbar ist. </li><li>  <b>Benutzerobjekt:</b> Eine Datenklasse, die Benutzerinformationen enthält. </li></ul><br>  Wir verwenden ein <code>UserProfileViewModel</code> das auf einer Komponente der ViewModel-Architektur basiert, um diese Informationen zu speichern. <br><br>  <i><u>Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ViewModel-</a> Objekt stellt Daten für eine bestimmte Benutzeroberflächenkomponente bereit, z. B. ein Fragment oder eine Aktivität, und enthält eine Geschäftsdatenverarbeitungslogik für die Interaktion mit dem Modell.</u></i>  <i><u>Beispielsweise kann das <b>ViewModel</b> andere Komponenten aufrufen, um Daten zu laden, und Benutzeranforderungen für Datenänderungen weiterleiten.</u></i>  <i><u><b>ViewModel</b> kennt die Komponenten der Benutzeroberfläche nicht und ist daher nicht von Konfigurationsänderungen betroffen, z. B. der Neuerstellung von Aktivitäten beim Drehen des Geräts.</u></i> <br><br>  Jetzt haben wir die folgenden Dateien identifiziert: <br><br><ul><li>  <code>user_profile.xml</code> : Definiertes Layout der Benutzeroberfläche. </li><li>  <code>UserProfileFragment</code> : beschreibt einen Benutzeroberflächen-Controller, der für die Anzeige von Informationen für den Benutzer verantwortlich ist. </li><li>  <code>UserProfileViewModel</code> : Eine Klasse, die dafür verantwortlich ist, Daten für die Anzeige in <code>UserProfileFragment</code> und auf Benutzerinteraktionen zu reagieren. </li></ul><br>  Die folgenden Codefragmente zeigen den ursprünglichen Inhalt dieser Dateien.  (Die Layoutdatei ist der Einfachheit halber weggelassen.) <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : User = TODO() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel: UserProfileViewModel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> viewModels() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span>: View { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }</code> </pre> <br>  Wie verbinden wir diese Codemodule, nachdem wir sie haben?  Nachdem das Benutzerfeld in der UserProfileViewModel-Klasse festgelegt wurde, benötigen wir eine Möglichkeit, die Benutzeroberfläche zu informieren. <br><br>  <i><b>Hinweis</b></i>  <i>Mit SavedStateHandle kann das ViewModel auf den gespeicherten Status und die Argumente des zugeordneten Fragments oder der zugeordneten Aktion zugreifen.</i> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateVMFactory(this) } ... )</span></span></code> </pre> <br>  Jetzt müssen wir unser Fragment informieren, wenn das Benutzerobjekt empfangen wird.  Hier wird die Komponente der LiveData-Architektur angezeigt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LiveData</a> ist ein beobachtbarer Dateninhaber.  Andere Komponenten in Ihrer Anwendung können Änderungen an Objekten mithilfe dieses Halters verfolgen, ohne explizite und harte Abhängigkeitspfade zwischen ihnen zu erstellen.  Die LiveData-Komponente berücksichtigt auch den Lebenszyklusstatus der Komponenten Ihrer Anwendung, z. B. Aktivitäten, Fragmente und Dienste, und enthält eine Bereinigungslogik, um Objektverluste und übermäßigen Speicherverbrauch zu verhindern. <br><br>  <i>Hinweis</i>  <i>Wenn Sie bereits Bibliotheken wie RxJava oder Agera verwenden, können Sie diese anstelle von LiveData weiterhin verwenden.</i>  <i>Stellen Sie jedoch bei Verwendung von Bibliotheken und ähnlichen Ansätzen sicher, dass Sie den Lebenszyklus Ihrer Anwendung ordnungsgemäß handhaben.</i>  <i>Stellen Sie insbesondere sicher, dass Sie Ihre Datenströme anhalten, wenn der zugeordnete LifecycleOwner gestoppt wird, und diese Streams zerstören, wenn der zugeordnete LifecycleOwner zerstört wurde.</i>  <i>Sie können auch das Artefakt android.arch.lifecycle: Jetstreams hinzufügen, um LiveData mit einer anderen Jetstream-Bibliothek wie RxJava2 zu verwenden.</i> <br><br>  Um die LiveData-Komponente in unsere Anwendung aufzunehmen, ändern wir den <code>UserProfileViewModel</code> in <code>UserProfileViewModel</code> in LiveData.  <code>UserProfileFragment</code> jetzt über <code>UserProfileFragment</code> informiert.  Da dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LiveData-</a> Feld den Lebenszyklus unterstützt, werden Links automatisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelöscht</a> , wenn sie nicht mehr benötigt werden. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span></span>( savedStateHandle: SavedStateHandle ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = TODO() }</code> </pre> <br>  Jetzt ändern wir das <code>UserProfileFragment</code> , um die Daten im <code>ViewModel</code> zu beobachten und die Benutzeroberfläche entsprechend den Änderungen zu aktualisieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { <span class="hljs-comment"><span class="hljs-comment">//  UI } }</span></span></code> </pre> <br>  Jedes Mal, wenn die Benutzerprofildaten aktualisiert werden, wird der Rückruf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onChanged ()</a> aufgerufen und die Benutzeroberfläche aktualisiert. <br><br>  Wenn Sie mit anderen Bibliotheken vertraut sind, die beobachtbare Rückrufe verwenden, haben Sie möglicherweise festgestellt, dass wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onStop ()</a> -Methode des Fragments nicht neu definiert haben, um die Beobachtung der Daten zu beenden.  Dieser Schritt ist für LiveData optional, da er den Lebenszyklus unterstützt. Dies bedeutet, dass der Rückruf <code>onChanged()</code> nicht aufgerufen wird, wenn sich das Fragment in einem inaktiven Zustand befindet.  Das heißt, er hat einen Aufruf von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onStart () erhalten</a> , aber noch keinen <code>onStop()</code> ) erhalten.  LiveData entfernt den Beobachter auch automatisch, wenn die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onDestroy ()</a> -Methode für das Fragment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgerufen wird</a> . <br><br>  Wir haben keine Logik hinzugefügt, um Konfigurationsänderungen zu behandeln, z. B. das Drehen des Gerätebildschirms durch den Benutzer.  <code>UserProfileViewModel</code> automatisch wiederhergestellt, wenn die Konfiguration geändert wird. Sobald ein neues Fragment erstellt wird, erhält es dieselbe <code>ViewModel</code> Instanz und der Rückruf wird sofort unter Verwendung der aktuellen Daten aufgerufen.  Da <code>ViewModel</code> Objekte so konzipiert sind, dass sie die entsprechenden <code>View</code> Objekte überleben, die sie aktualisieren, sollten Sie keine direkten Verweise auf <code>View</code> Objekte in Ihre ViewModel-Implementierung aufnehmen.  Weitere Informationen zur Lebensdauer des <code>ViewModel</code> im Lebenszyklus der Komponenten der Benutzeroberfläche (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ViewModel-Lebenszyklus).</a> <br><br><h3>  Datenabruf </h3><br>  Wie können wir Benutzerprofildaten <code>UserProfileViewModel</code> , <code>UserProfileFragment</code> wir LiveData verwendet haben, um <code>UserProfileViewModel</code> mit UserProfileFragment zu verbinden? <br><br>  In diesem Beispiel wird davon ausgegangen, dass unser Backend eine REST-API bereitstellt.  Wir verwenden die Retrofit-Bibliothek, um auf unser Backend zuzugreifen. Sie können jedoch auch eine andere Bibliothek verwenden, die denselben Zweck erfüllt. <br><br>  Hier ist unsere Definition eines <code>Webservice</code> , der auf unser Backend verweist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Webservice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> declares an HTTP GET request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Path</span></span></span><span class="hljs-comment">("user") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> path */</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/users/{user}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Path(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"user"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;User&gt; }</code> </pre> <br>  Eine erste Idee für die Implementierung eines <code>ViewModel</code> könnte darin bestehen, den <code>Webservice</code> aufzurufen, um die Daten abzurufen und diese Daten unserem <code>LiveData</code> Objekt <code>LiveData</code> .  Dieses Design funktioniert, aber die Verwendung macht es schwieriger, unsere Anwendung zu warten, wenn sie wächst.  Dies gibt der <code>UserProfileViewModel</code> Klasse zu viel Verantwortung, was gegen das Prinzip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Interessentrennung</a> verstößt.  Darüber hinaus ist der Bereich des ViewModel dem Lebenszyklus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivität</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragment zugeordnet.</a> Dies bedeutet, dass Daten vom <code>Webservice</code> verloren gehen, wenn der Lebenszyklus des zugeordneten Benutzeroberflächenobjekts endet.  Dieses Verhalten führt zu einer unerwünschten Benutzererfahrung. <br><br>  Stattdessen delegiert unser <code>ViewModel</code> den Prozess des Abrufs von Daten an ein neues Speichermodul. <br><br>  <u><i><b>Repository-</b> Module verarbeiten Datenoperationen.</i></u>  <u><i>Sie bieten eine saubere API, damit der Rest der Anwendung diese Daten problemlos abrufen kann.</i></u>  <u><i>Sie wissen, woher sie die Daten beziehen und welche API-Aufrufe beim Aktualisieren der Daten ausgeführt werden müssen.</i></u>  <u><i>Sie können sich Repositorys als Vermittler zwischen verschiedenen Datenquellen vorstellen, z. B. persistenten Modellen, Webdiensten und Caches.</i></u> <br><br>  Unsere <code>UserRepository</code> Klasse, die im folgenden <code>UserRepository</code> gezeigt wird, verwendet eine Instanz von <code>WebService</code> , um Benutzerdaten abzurufen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> webservice: Webservice = TODO() <span class="hljs-comment"><span class="hljs-comment">// ... fun getUser(userId: String): LiveData&lt;User&gt; { //    .    . val data = MutableLiveData&lt;User&gt;() webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br>  Obwohl das Speichermodul unnötig erscheint, dient es einem wichtigen Zweck: Es abstrahiert Datenquellen vom Rest der Anwendung.  Jetzt weiß unser <code>UserProfileViewModel</code> nicht, wie Daten abgerufen werden sollen, sodass wir Präsentationsmodelle mit Daten aus verschiedenen Datenextraktionsimplementierungen bereitstellen können. <br><br>  <b>Hinweis</b>  Der Einfachheit halber haben wir den Fall von Netzwerkfehlern übersehen.  Eine alternative Implementierung, die Fehler und den Download-Status aufdeckt, finden Sie im Anhang: Offenlegung des Netzwerkstatus. <br><br>  <b>Verwalten von Abhängigkeiten zwischen Komponenten</b> <br><br>  Die <code>UserRepository</code> genannte <code>UserRepository</code> Klasse benötigt eine Instanz von <code>Webservice</code> , um Benutzerdaten abzurufen.  Er könnte nur eine Instanz erstellen, muss dafür aber auch die Abhängigkeiten der <code>Webservice</code> Klasse kennen.  Darüber hinaus ist <code>UserRepository</code> wahrscheinlich nicht die einzige Klasse, die einen Webdienst benötigt.  In dieser Situation müssen wir den Code duplizieren, da jede Klasse, die einen Link zum <code>Webservice</code> benötigt, wissen muss, wie er und seine Abhängigkeiten erstellt werden.  Wenn jede Klasse einen neuen <code>WebService</code> , kann unsere Anwendung sehr ressourcenintensiv werden. <br><br>  Um dieses Problem zu lösen, können Sie die folgenden Entwurfsmuster verwenden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abhängigkeitsinjektion (DI)</a> .  Mit der Abhängigkeitsinjektion können Klassen ihre Abhängigkeiten definieren, ohne sie zu erstellen.  Zur Laufzeit ist eine andere Klasse für die Bereitstellung dieser Abhängigkeiten verantwortlich.  Wir empfehlen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dagger 2-</a> Bibliothek für die Implementierung der Abhängigkeitsinjektion in Android-Anwendungen.  Dolch 2 erstellt automatisch Objekte unter Umgehung des Abhängigkeitsbaums und bietet Garantien zur Kompilierungszeit für Abhängigkeiten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Service Location) Service</a> Locator: Die Service Locator-Vorlage bietet eine Registrierung, in der Klassen ihre Abhängigkeiten abrufen können, anstatt sie zu erstellen. </li></ul><br>  Das Implementieren einer Dienstregistrierung ist einfacher als die Verwendung von DI. Wenn Sie DI noch nicht kennen, verwenden Sie stattdessen die Vorlage: Dienstort. <br><br>  Mit diesen Vorlagen können Sie Ihren Code skalieren, da sie eindeutige Vorlagen zum Verwalten von Abhängigkeiten enthalten, ohne den Code zu duplizieren oder zu komplizieren.  Darüber hinaus können Sie mit diesen Vorlagen schnell zwischen Test- und Produktionsimplementierungen für die Datenerfassung wechseln. <br><br>  Unsere Beispielanwendung verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dolch 2</a> , um die Abhängigkeiten des <code>Webservice</code> Objekts zu verwalten. <br><br><h3>  Verbinden Sie ViewModel und Storage </h3><br>  Jetzt ändern wir unser <code>UserProfileViewModel</code> , um das <code>UserRepository</code> Objekt zu verwenden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( savedStateHandle: SavedStateHandle, userRepository: UserRepository ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = userRepository.getUser(userId) }</code> </pre> <br><h3>  Caching </h3><br>  Die <code>UserRepository</code> Implementierung abstrahiert den Aufruf des <code>Webservice</code> Objekts. Da sie jedoch nur auf einer Datenquelle basiert, ist sie nicht sehr flexibel. <br><br>  Das Hauptproblem bei der Implementierung von <code>UserRepository</code> besteht darin, dass diese Daten nach dem Empfang von Daten aus unserem Backend nirgendwo gespeichert werden.  Wenn der Benutzer <code>UserProfileFragment</code> verlässt und dann zu ihm zurückkehrt, muss unsere Anwendung die Daten abrufen, auch wenn sie sich nicht geändert haben. <br><br>  Dieses Design ist aus folgenden Gründen nicht optimal: <br><br><ul><li>  Es verbraucht wertvolle Verkehrsressourcen. </li><li>  Dadurch wartet der Benutzer auf den Abschluss einer neuen Anforderung. </li></ul><br>  Um diese Mängel zu <code>UserRepository</code> , fügen wir unserem <code>UserRepository</code> eine neue Datenquelle <code>UserRepository</code> , die <code>User</code> im Speicher zwischenspeichert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Dagger,        . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val userCache: UserCache ) { fun getUser(userId: String): LiveData&lt;User&gt; { val cached = userCache.get(userId) if (cached != null) { return cached } val data = MutableLiveData&lt;User&gt;() userCache.put(userId, data) //     ,  ,  . //      . webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br><h3>  Persistente Daten </h3><br>  Wenn der Benutzer in unserer aktuellen Implementierung das Gerät dreht oder das Gerät verlässt und sofort zur Anwendung zurückkehrt, wird die vorhandene Benutzeroberfläche sofort sichtbar, da der Speicher Daten aus unserem Cache im Speicher abruft. <br><br>  Was passiert jedoch, wenn ein Benutzer die Anwendung verlässt und einige Stunden nach Abschluss des Vorgangs durch das Android-Betriebssystem zurückkehrt?  Basierend auf unserer aktuellen Implementierung in dieser Situation müssen wir erneut Daten aus dem Netzwerk abrufen.  Dieser Upgrade-Prozess ist nicht nur eine schlechte Benutzererfahrung.  Es ist auch verschwenderisch, weil es wertvolle mobile Daten verbraucht. <br><br>  Sie können dieses Problem lösen, indem Sie Webanfragen zwischenspeichern. Dies führt jedoch zu einem neuen Schlüsselproblem: Was passiert, wenn dieselben Benutzerdaten in einer Anfrage eines anderen Typs angezeigt werden, z. B. beim Empfang einer Freundesliste?  Die Anwendung zeigt widersprüchliche Daten an, was bestenfalls verwirrend ist.  Beispielsweise kann unsere Anwendung zwei verschiedene Versionen der Daten desselben Benutzers anzeigen, wenn der Benutzer zu unterschiedlichen Zeiten eine Freundschaftslistenanforderung und eine Einzelbenutzeranforderung gesendet hat.  Unsere Anwendung müsste herausfinden, wie diese widersprüchlichen Daten kombiniert werden können. <br><br>  Der richtige Weg, um mit dieser Situation umzugehen, ist die Verwendung eines konstanten Modells.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Room</a> Permanent Data Library (DB) hilft uns dabei. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Room</a> ist eine Objektzuordnungsbibliothek, die die lokale Datenspeicherung mit einem Mindeststandardcode bereitstellt.  Zur Kompilierungszeit wird jede Abfrage auf Übereinstimmung mit Ihrem Datenschema überprüft, sodass fehlerhafte SQL-Abfragen zu Fehlern beim Kompilieren führen und nicht zur Laufzeit abstürzen.  Raumzusammenfassungen von einigen grundlegenden Implementierungsdetails von SQL-Rohtabellen und -Abfragen.  Außerdem können Sie Änderungen an Datenbankdaten, einschließlich Sammlungen und Verbindungsanforderungen, beobachten und solche Änderungen mithilfe von LiveData-Objekten offenlegen.  Es werden sogar explizit Ausführungsbeschränkungen definiert, die häufig auftretende Threading-Probleme lösen, z. B. den Zugriff auf den Speicher im Haupt-Thread. <br><br>  <i><b>Hinweis</b></i>  <i>Wenn Ihre Anwendung bereits eine andere Lösung verwendet, z. B. ORM (SQLite Object Relational Mapping), müssen Sie die vorhandene Lösung nicht durch Room ersetzen.</i>  <i>Wenn Sie jedoch eine neue Anwendung schreiben oder eine vorhandene Anwendung neu organisieren, empfehlen wir, Room zum Speichern Ihrer Anwendungsdaten zu verwenden.</i>  <i>So können Sie die Abstraktion der Bibliothek und die Abfragevalidierung nutzen.</i> <br><br>  Um Room nutzen zu können, müssen wir unser lokales Layout definieren.  Zuerst fügen wir die Annotation <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Entity</a></code> zu unserer <code>User</code> und <code>@PrimaryKey</code> Annotation <code>@PrimaryKey</code> im Feld Klassen- <code>id</code> .  Diese Anmerkungen markieren <code>User</code> als Tabelle in unserer Datenbank und <code>id</code> als Primärschlüssel der Tabelle: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String )</code> </pre> <br>  Anschließend erstellen wir die Datenbankklasse, indem wir <code>RoomDatabase</code> für unsere Anwendung implementieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>()</code> </pre> <br>  Beachten Sie, dass <code>UserDatabase</code> abstrakt ist.  Die Raumbibliothek bietet automatisch eine Implementierung davon.  Weitere Informationen finden Sie in der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Room</a> . <br><br>  Jetzt brauchen wir eine Möglichkeit, Benutzerdaten in die Datenbank einzufügen.  Für diese Aufgabe erstellen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Datenzugriffsobjekt (DAO)</a> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = REPLACE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: LiveData&lt;User&gt; }</code> </pre> <br>  Beachten Sie, dass die Lademethode ein Objekt vom Typ LiveData zurückgibt.  Room weiß, wann die Datenbank geändert wird, und benachrichtigt automatisch alle aktiven Beobachter über Datenänderungen.  Da Room <i>LiveData verwendet</i> , ist dieser Vorgang effizient.  Daten werden nur aktualisiert, wenn mindestens ein Beobachter aktiv ist. <br><br>  <i><b>Hinweis: Der</b> Raum prüft auf Ungültigmachung aufgrund von Tabellenänderungen. Dies bedeutet, dass falsch positive Benachrichtigungen gesendet werden können.</i> <br><br>  Nachdem wir unsere <code>UserDao</code> Klasse definiert haben, <code>UserDao</code> wir auf das DAO aus unserer Datenbankklasse: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: UserDao }</code> </pre> <br>  Jetzt können wir unser <code>UserRepository</code> so ändern, dass es die <code>UserRepository</code> enthält: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val executor: Executor, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { refreshUser(userId) //   LiveData    . return userDao.load(userId) } private fun refreshUser(userId: String) { //    . executor.execute { // ,      . val userExists = userDao.hasUser(FRESH_TIMEOUT) if (!userExists) { //  . val response = webservice.getUser(userId).execute() //    . //   .  LiveData  , //        . userDao.save(response.body()!!) } } } companion object { val FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(1) } }</span></span></code> </pre> <br>  Bitte beachten Sie, dass wir unser <code>UserProfileViewModel</code> oder <code>UserProfileFragment</code> nicht ändern <code>UserProfileViewModel</code> , auch wenn wir die Datenquelle in <code>UserRepository</code> <code>UserProfileFragment</code> .  Dieses kleine Update zeigt die Flexibilität unserer Anwendungsarchitektur.  Es eignet sich auch hervorragend zum Testen, da wir ein gefälschtes <code>UserRepository</code> und gleichzeitig unser Produktions- <code>UserProfileViewModel</code> testen können. <br><br>  Wenn Benutzer innerhalb weniger Tage zurückkehren, zeigt eine Anwendung, die diese Architektur verwendet, wahrscheinlich veraltete Informationen an, bis das Repository aktualisierte Informationen erhält.  Abhängig von Ihrem Anwendungsfall werden möglicherweise keine veralteten Informationen angezeigt.  Stattdessen können Sie <i>Platzhalterdaten</i> anzeigen, die Dummy-Werte anzeigen und anzeigen, dass Ihre Anwendung gerade aktuelle Informationen lädt und lädt. <br><br>  <b>Die einzige Quelle der Wahrheit</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Regel geben verschiedene REST-API-Endpunkte dieselben Daten zurück. Wenn unser Backend beispielsweise über einen anderen Endpunkt verfügt, der eine Liste von Freunden zurückgibt, kann dasselbe Benutzerobjekt von zwei verschiedenen API-Endpunkten stammen, möglicherweise sogar mit unterschiedlichen Detaillierungsgraden. Wenn wir </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Antwort von der Anforderung </font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unverändert zurückgeben, ohne die Konsistenz zu überprüfen, können unsere Benutzeroberflächen verwirrende Informationen anzeigen, da die Version und das Format der Daten aus dem Speicher vom zuletzt aufgerufenen Endpunkt abhängen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichert </font><font style="vertical-align: inherit;">unsere Implementierung </font><font style="vertical-align: inherit;">Webdienstantworten in einer Datenbank. Änderungen an der Datenbank lösen dann Rückrufe für aktive </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte aus </font><font style="vertical-align: inherit;">. Mit diesem Modell,</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Datenbank ist die einzige Quelle der Wahrheit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und andere Teile der Anwendung greifen über unsere darauf zu </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unabhängig davon, ob Sie einen Festplatten-Cache verwenden, empfehlen wir, dass Ihr Repository die Datenquelle als einzige Wahrheitsquelle für den Rest Ihrer Anwendung identifiziert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betriebsfortschritt anzeigen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einigen Anwendungsfällen, z. B. beim Pull-to-Refresh, ist es wichtig, dass die Benutzeroberfläche dem Benutzer anzeigt, dass gerade ein Netzwerkvorgang ausgeführt wird. </font><font style="vertical-align: inherit;">Es wird empfohlen, die Benutzeroberflächenaktion von den tatsächlichen Daten zu trennen, da die Daten aus verschiedenen Gründen aktualisiert werden können. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise eine Liste mit Freunden erhalten, kann derselbe Benutzer programmgesteuert erneut ausgewählt werden, was zu einer Aktualisierung von LiveData führt. </font><font style="vertical-align: inherit;">Aus Sicht der Benutzeroberfläche ist die Tatsache, dass eine Anfrage im Flug ist, nur ein weiterer Datenpunkt, ähnlich wie bei jedem anderen Datenelement im Objekt selbst </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können eine der folgenden Strategien verwenden, um den vereinbarten Datenaktualisierungsstatus in der Benutzeroberfläche anzuzeigen, unabhängig davon, woher die Datenaktualisierungsanforderung stammt: </font></font><br><br><ul><li>  <code>getUser ()</code> ,      <code>LiveData</code> .         .  ,   NetworkBoundResource   GitHub <a href="">android-Architecture-components</a> . </li><li>       <code>UserRepository</code> ,      .    ,              ,         ,   pull-to-refresh. </li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Abschnitt über die Trennung von Interessen haben wir erwähnt, dass einer der Hauptvorteile der Befolgung dieses Prinzips die Testbarkeit ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die folgende Liste zeigt, wie Sie jedes Codemodul anhand unseres erweiterten Beispiels testen:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzeroberfläche und Interaktion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Verwenden Sie das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android UI Test Toolkit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der beste Weg, um diesen Test zu erstellen, ist die Verwendung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espresso-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie können ein Fragment erstellen und es mit einem Layout versehen </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da das Fragment nur mit verknüpft </font><font style="vertical-align: inherit;">ist, reicht es </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aus,</font></a><font style="vertical-align: inherit;"> nur diese Klasse zu </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verspotten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(zu imitieren)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Benutzeroberfläche Ihrer Anwendung vollständig zu testen.</font></font></li><li> <b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JUnit</a> .      , <code>UserRepository</code> . </li><li> <b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code> .      : <br><br><ul><li>     -. </li><li>      . </li><li>     ,     . </li></ul><br></li><li>   <code>Webservice</code> ,  <code>UserDao</code>  ,             . </li><li> <b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        … <br><br> <i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SupportSQLiteOpenHelper</a></b> .     ,      SQLite     SQLite   .</i> </li><li> <b>-:</b>         .   ,  -,      .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/square/ok">MockWebServer</a> ,          . </li><li> <b> :</b>     maven    .    <code>androidx.arch.core</code> :    JUnit: <br><br><ul><li> <code>InstantTaskExecutorRule:</code>            . </li><li> <code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </li></ul><br></li></ul><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Programmierung ist ein kreatives Feld, und die Erstellung von Android-Anwendungen ist keine Ausnahme. Es gibt viele Möglichkeiten, das Problem zu lösen, sei es das Übertragen von Daten zwischen mehreren Aktionen oder Fragmenten, das Abrufen gelöschter Daten und das lokale Speichern offline oder eine beliebige Anzahl anderer häufiger Szenarien, auf die nicht triviale Anwendungen stoßen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die folgenden Empfehlungen nicht erforderlich sind, zeigt unsere Erfahrung, dass ihre Implementierung Ihre Codebasis auf lange Sicht zuverlässiger, testbarer und unterstützter macht: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie es, die Einstiegspunkte Ihrer Anwendung - wie Aktionen, Dienste und Rundfunkempfänger - als Datenquellen festzulegen.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen müssen sie nur mit anderen Komponenten koordinieren, um eine Teilmenge der Daten zu diesem Einstiegspunkt zu erhalten. Jede Komponente der Anwendung ist von kurzer Dauer, abhängig von der Interaktion des Benutzers mit seinem Gerät und dem allgemeinen aktuellen Status des Systems. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie klare Verantwortungsbereiche zwischen den verschiedenen Modulen Ihrer Anwendung.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verteilen Sie beispielsweise keinen Code, der Daten aus dem Netzwerk herunterlädt, an mehrere Klassen oder Pakete in Ihrer Codebasis. Definieren Sie in ähnlicher Weise nicht mehrere nicht miteinander verbundene Verantwortlichkeiten wie Daten-Caching und Datenbindung in derselben Klasse. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belichten Sie jedes Modul so wenig wie möglich.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widerstehen Sie der Versuchung, ein "nur ein" Etikett zu erstellen, das die Details einer internen Implementierung aus einem Modul enthüllt. Sie können kurzfristig etwas Zeit gewinnen, aber dann werden Sie viele Male eine technische Verschuldung erleiden, wenn sich Ihre Codebasis entwickelt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlegen Sie, wie Sie jedes Modul einzeln testbar machen können.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine gut definierte API zum Abrufen von Daten aus dem Netzwerk erleichtert beispielsweise das Testen eines Moduls, das diese Daten in einer lokalen Datenbank speichert. Wenn Sie stattdessen die Logik dieser beiden Module an einem Ort mischen oder Ihren Netzwerkcode in der Codebasis verteilen, wird das Testen viel schwieriger - in einigen Fällen sogar unmöglich. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konzentrieren Sie sich auf den einzigartigen Kern Ihrer Anwendung, um sich von anderen Anwendungen abzuheben.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfinden Sie das Rad nicht neu, indem Sie immer wieder dasselbe Muster schreiben. Konzentrieren Sie stattdessen Ihre Zeit und Energie auf das, was Ihre Anwendung einzigartig macht, und lassen Sie die Komponenten der Android-Architektur und anderer empfohlener Bibliotheken mit einem sich wiederholenden Muster fertig werden. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewahren Sie so viele relevante und aktuelle Daten wie möglich auf.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So können Benutzer die Funktionalität Ihrer Anwendung nutzen, auch wenn ihr Gerät offline ist. Denken Sie daran, dass nicht alle Benutzer eine konstante Hochgeschwindigkeitsverbindung verwenden. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie eine einzelne Datenquelle als einzig wahre Quelle fest.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wann immer Ihre Anwendung Zugriff auf diese Daten benötigt, sollte sie immer aus dieser einzigen Quelle der Wahrheit stammen.</font></font><br><br><h3> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachtrag: Offenlegung des Netzwerkstatus</font></font></u> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im obigen Abschnitt der empfohlenen Anwendungsarchitektur haben wir Netzwerkfehler und Startzustände übersprungen, um Codefragmente zu vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt wird gezeigt, wie der Netzwerkstatus mithilfe der Ressourcenklasse angezeigt wird, die sowohl Daten als auch deren Status kapselt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Codefragment enthält eine Beispielimplementierung</font></font><code>Resource:</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         . sealed class Resource&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Success&lt;T&gt;(data: T) : Resource&lt;T&gt;(data) class Loading&lt;T&gt;(data: T? = null) : Resource&lt;T&gt;(data) class Error&lt;T&gt;(message: String, data: T? = null) : Resource&lt;T&gt;(data, message) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Herunterladen von Daten aus dem Netzwerk beim Anzeigen einer Kopie dieser Daten gängige Praxis ist, ist es hilfreich, eine Hilfsklasse zu erstellen, die an mehreren Stellen wiederverwendet werden kann. In diesem Beispiel erstellen wir eine Klasse mit dem Namen </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Diagramm zeigt den Entscheidungsbaum für </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es beginnt mit der Beobachtung der Datenbank für die Ressource. Wenn ein Datensatz zum ersten Mal aus der Datenbank heruntergeladen wird, wird </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überprüft, ob das Ergebnis zum Senden gut genug ist oder ob es aus dem Netzwerk abgerufen werden muss. Bitte beachten Sie, dass beide Situationen gleichzeitig auftreten können, da Sie wahrscheinlich zwischengespeicherte Daten anzeigen möchten, wenn Sie sie aus dem Netzwerk aktualisieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Netzwerkaufruf erfolgreich ist, speichert er die Antwort in der Datenbank und initialisiert den Stream neu. Bei einem Netzwerkanforderungsfehler wird </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Fehler direkt </font><font style="vertical-align: inherit;">gesendet </font><font style="vertical-align: inherit;">. </font></font><br><br> <code><b>.</b>             .       ,       .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass das Verlassen einer Datenbank zum Senden von Änderungen die Verwendung verwandter Nebenwirkungen erfordert. Dies ist nicht sehr gut, da das undefinierte Verhalten dieser Nebenwirkungen auftreten kann, wenn die Datenbank die Änderungen nicht sendet, weil sich die Daten nicht geändert haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie auch keine vom Netzwerk empfangenen Ergebnisse, da dies gegen das Prinzip einer einzigen Wahrheitsquelle verstößt. </font><font style="vertical-align: inherit;">Am Ende ist es möglich, dass die Datenbank Trigger enthält, die Datenwerte während des Speichervorgangs ändern. </font><font style="vertical-align: inherit;">Senden Sie in ähnlicher Weise nicht "ERFOLG" ohne neue Daten, da der Client dann die falsche Version der Daten erhält. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Codefragment zeigt die offene API, die von der Klasse </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für ihre Unterklassen </font><font style="vertical-align: inherit;">bereitgestellt wird </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ResultType:   . // RequestType:   API. abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; { //      API   . @WorkerThread protected abstract fun saveCallResult(item: RequestType) //      ,  ,    //     . @MainThread protected abstract fun shouldFetch(data: ResultType?): Boolean //        . @MainThread protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt; //     API. @MainThread protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; // ,    .   //    ,    . protected open fun onFetchFailed() {} //   LiveData,  , //    . fun asLiveData(): LiveData&lt;ResultType&gt; = TODO() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie die folgenden wichtigen Details der Klassendefinition: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es definiert zwei Typparameter, </font></font><code>ResultType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>RequestType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da der von der API zurückgegebene Datentyp möglicherweise nicht dem lokal verwendeten Datentyp entspricht.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es verwendet eine Klasse </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Netzwerkanforderungen. </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist ein einfacher Wrapper für eine Klasse </font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Antworten in Instanzen konvertiert </font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vollständige Implementierung der Klasse wird </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Teil des </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekts für </font><a href=""><font style="vertical-align: inherit;">Android-Architektur-Komponenten</font></a><font style="vertical-align: inherit;"> angezeigt </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung können wir damit unsere festplatten- und netzwerkgebundenen Implementierungen </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in die Klasse </font><font style="vertical-align: inherit;">schreiben </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger2,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { return object : NetworkBoundResource&lt;User, User&gt;() { override fun saveCallResult(item: User) { userDao.save(item) } override fun shouldFetch(data: User?): Boolean { return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)) } override fun loadFromDb(): LiveData&lt;User&gt; { return userDao.load(userId) } override fun createCall(): LiveData&lt;ApiResponse&lt;User&gt;&gt; { return webservice.getUser(userId) } }.asLiveData() } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456256/">https://habr.com/ru/post/de456256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456240/index.html">Chatbot-Entwicklung (Laravel + Botman)</a></li>
<li><a href="../de456242/index.html">Ein bisschen mehr über Multitasking in Mikrocontrollern</a></li>
<li><a href="../de456246/index.html">Nullelement</a></li>
<li><a href="../de456248/index.html">Wie ich gefangen habe: vor Stilen für ein Fokuselement</a></li>
<li><a href="../de456250/index.html">Anwendungslokalisierung und RTL-Unterstützung. Bericht Yandex.Taxi</a></li>
<li><a href="../de456258/index.html">Frei wie ein Wind und frei wie ein Bier Übersetzung von "Frei wie in Freiheit" ins Russische unter der GNU FDL 1.3 Lizenz</a></li>
<li><a href="../de456260/index.html">Fair Economy Talk</a></li>
<li><a href="../de456262/index.html">Software Defined Radio - wie funktioniert es? Teil 9</a></li>
<li><a href="../de456264/index.html">Erstellen Sie Android-Binärdateien mit Source und Android NDK. Wir pumpen das Screencap-Dienstprogramm auf</a></li>
<li><a href="../de456266/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 302 (vom 10. bis 16. Juni)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>