<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèº üëáüèæ üòï Handbuch zur Android-Anwendungsarchitektur ‚õπüèø üíº üë©üèø‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die kostenlose √úbersetzung von "Guide to App Architecture" von JetPack . Ich bitte Sie, alle Kommentare zur √úbersetz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Handbuch zur Android-Anwendungsarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456256/">  Hallo Habr!  Ich pr√§sentiere Ihnen die kostenlose √úbersetzung von "Guide to App Architecture" von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JetPack</a> .  Ich bitte Sie, alle Kommentare zur √úbersetzung in den Kommentaren zu hinterlassen, und sie werden behoben.  Auch Kommentare von Personen, die die vorgestellte Architektur mit Empfehlungen f√ºr ihre Verwendung verwendet haben, sind f√ºr alle n√ºtzlich. <br><br>  Dieses Handbuch behandelt Best Practices und empfohlene Architekturen zum Erstellen robuster Anwendungen.  Diese Seite setzt eine grundlegende Einf√ºhrung in das Android Framework voraus.  Wenn Sie mit der Entwicklung von Android-Apps noch nicht vertraut sind, lesen Sie zun√§chst unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklerhandb√ºcher</a> , um mehr √ºber die in diesem Handbuch genannten Konzepte zu erfahren.  Wenn Sie sich f√ºr Anwendungsarchitektur interessieren und sich mit den Materialien in diesem Handbuch in Bezug auf die Programmierung auf Kotlin vertraut machen m√∂chten, lesen Sie den Udacity-Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEntwickeln von Anwendungen f√ºr Android mit Kotlin‚Äú</a> . <br><br><h2>  Mobile App Benutzererfahrung </h2><br>  In den meisten F√§llen haben Desktopanwendungen einen einzigen Einstiegspunkt vom Desktop oder Launcher und werden dann als einzelner monolithischer Prozess ausgef√ºhrt.  Android-Anwendungen haben eine viel komplexere Struktur.  Eine typische Android-Anwendung enth√§lt mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungskomponenten</a> , darunter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivit√§ten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragmente</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienste</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ContentProvider</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BroadcastReceiver</a> . <br><br>  Sie deklarieren alle oder einige dieser Anwendungskomponenten im Anwendungsmanifest.  Android verwendet diese Datei dann, um zu entscheiden, wie Ihre Anwendung in die allgemeine Benutzeroberfl√§che des Ger√§ts integriert werden soll.  Da eine gut geschriebene Android-Anwendung mehrere Komponenten enth√§lt und Benutzer h√§ufig in kurzer Zeit mit mehreren Anwendungen interagieren, m√ºssen sich Anwendungen an verschiedene Arten von Workflows und benutzergesteuerten Aufgaben anpassen. <br><a name="habracut"></a><br>  √úberlegen Sie beispielsweise, was passiert, wenn Sie ein Foto in Ihrer bevorzugten Social Media-Anwendung freigeben: <br><br><ol><li>  Die Anwendung l√∂st die Absicht der Kamera aus.  Android startet eine Kameraanwendung, um die Anfrage zu verarbeiten.  Im Moment hat der Benutzer die Anwendung f√ºr soziale Netzwerke verlassen, und seine Erfahrung als Benutzer ist einwandfrei. </li><li>  Eine Kameraanwendung kann andere Absichten ausl√∂sen, z. B. das Starten einer Dateiauswahl, mit der m√∂glicherweise eine andere Anwendung gestartet wird. </li><li>  Am Ende kehrt der Benutzer zur Anwendung f√ºr soziale Netzwerke zur√ºck und teilt das Foto. </li></ol><br>  Der Benutzer kann jederzeit durch einen Anruf oder eine Benachrichtigung unterbrochen werden.  Nach der mit diesem Interrupt verbundenen Aktion erwartet der Benutzer, dass er diesen Fotofreigabeprozess zur√ºckgeben und fortsetzen kann.  Dieses Anwendungswechselverhalten ist auf Mobilger√§ten √ºblich, daher muss Ihre Anwendung diese Punkte (Aufgaben) korrekt behandeln. <br><br>  Denken Sie daran, dass die Ressourcen mobiler Ger√§te ebenfalls begrenzt sind. Daher kann das Betriebssystem jederzeit einige Anwendungsprozesse zerst√∂ren, um Speicherplatz f√ºr neue freizugeben. <br><br>  Unter den Bedingungen dieser Umgebung k√∂nnen die Komponenten Ihrer Anwendung einzeln und nicht in der richtigen Reihenfolge gestartet werden, und das Betriebssystem oder der Benutzer k√∂nnen sie jederzeit zerst√∂ren.  Da diese Ereignisse nicht unter Ihrer Kontrolle stehen, <b>sollten Sie keine Daten oder Zust√§nde in Ihren Anwendungskomponenten speichern</b> und Ihre Anwendungskomponenten sollten nicht voneinander abh√§ngig sein. <br><br><h2>  Allgemeine architektonische Prinzipien </h2><br>  Wie sollten Sie Ihre Anwendung entwickeln, wenn Sie keine Anwendungskomponenten zum Speichern von Daten und Anwendungsstatus verwenden sollten? <br><br><h3>  Aufteilung der Verantwortung </h3><br>  Das wichtigste Prinzip ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Aufteilung der Verantwortlichkeiten</a> .  Ein h√§ufiger Fehler ist, wenn Sie Ihren gesamten Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivit√§t</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragment</a> schreiben.  Dies sind Benutzeroberfl√§chenklassen, die nur eine Logik enthalten sollten, die die Interaktion der Benutzeroberfl√§che und des Betriebssystems verarbeitet.  Indem Sie die Verantwortung in diesen Klassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(SRPs)</a> so weit wie m√∂glich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teilen</a> , k√∂nnen Sie viele der Probleme vermeiden, die mit dem Anwendungslebenszyklus verbunden sind. <br><br><h3>  Steuerung der Benutzeroberfl√§che vom Modell </h3><br>  Ein weiteres wichtiges Prinzip ist, dass Sie <b>Ihre Benutzeroberfl√§che von einem Modell</b> aus <b>steuern</b> m√ºssen, vorzugsweise von einem permanenten Modell aus.  Modelle sind die Komponenten, die f√ºr die Verarbeitung der Daten f√ºr die Anwendung verantwortlich sind.  Sie sind unabh√§ngig von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">View-</a> Objekten und Anwendungskomponenten und daher nicht vom Anwendungslebenszyklus und den damit verbundenen Problemen betroffen. <br><br>  Ein permanentes Modell ist aus folgenden Gr√ºnden ideal: <br><br><ul><li>  Ihre Benutzer verlieren keine Daten, wenn das Android-Betriebssystem Ihre Anwendung zerst√∂rt, um Ressourcen freizugeben. </li><li>  Ihre Anwendung funktioniert weiterhin, wenn die Netzwerkverbindung instabil oder nicht verf√ºgbar ist. </li></ul><br>  Durch die Organisation der Grundlage Ihrer Anwendung in Modellklassen mit einer klar definierten Verantwortung f√ºr das Datenmanagement wird Ihre Anwendung testbarer und unterst√ºtzbarer. <br><br><h2>  Empfohlene Anwendungsarchitektur </h2><br>  In diesem Abschnitt wird gezeigt, wie Sie eine Anwendung mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturkomponenten</a> strukturieren und in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End-</a> to- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End-Nutzungsszenario arbeiten</a> . <br><br>  <i><b>Hinweis</b></i>  <i>Es ist nicht m√∂glich, Anwendungen zu schreiben, die f√ºr jedes Szenario am besten geeignet sind.</i>  <i>Die empfohlene Architektur ist jedoch ein guter Ausgangspunkt f√ºr die meisten Situationen und Workflows.</i>  <i>Wenn Sie bereits eine gute M√∂glichkeit haben, Android-Anwendungen zu schreiben, die den allgemeinen Architekturprinzipien entsprechen, sollten Sie diese nicht √§ndern.</i> <br><br>  Stellen Sie sich vor, wir erstellen eine Benutzeroberfl√§che, in der ein Benutzerprofil angezeigt wird.  Wir verwenden eine private API und eine REST-API, um Profildaten abzurufen. <br><br><h3>  R√ºckblick </h3><br>  Betrachten Sie zun√§chst das Interaktionsschema der Module der Architektur der fertigen Anwendung: <br><br><img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br><br>  Bitte beachten Sie, dass jede Komponente nur eine Ebene darunter von der Komponente abh√§ngt.  Beispielsweise h√§ngen Aktivit√§t und Fragmente nur vom Ansichtsmodell ab.  Repository ist die einzige Klasse, die von vielen anderen Klassen abh√§ngt.  In diesem Beispiel h√§ngt der Speicher von einem persistenten Datenmodell und einer internen Remote-Datenquelle ab. <br><br>  Dieses Entwurfsmuster schafft eine konsistente und angenehme Benutzererfahrung.  Unabh√§ngig davon, ob der Benutzer einige Minuten nach dem Schlie√üen oder einige Tage sp√§ter zur Anwendung zur√ºckkehrt, werden ihm sofort Benutzerinformationen angezeigt, dass die Anwendung lokal gespeichert ist.  Wenn diese Daten nicht mehr aktuell sind, aktualisiert das Anwendungsspeichermodul die Daten im Hintergrund. <br><br><h3>  Erstellen Sie eine Benutzeroberfl√§che </h3><br>  Die Benutzeroberfl√§che besteht aus dem Fragment <code>UserProfileFragment</code> und der entsprechenden <code>user_profile_layout.xml</code> . <br><br>  Zur Verwaltung der Benutzeroberfl√§che muss unser Datenmodell die folgenden Datenelemente enthalten: <br><br><ul><li>  <b>Benutzer-ID:</b> Benutzer-ID.  Die beste L√∂sung besteht darin, diese Informationen mit den Argumenten des Fragments an das Fragment zu √ºbergeben.  Wenn das Android-Betriebssystem unseren Prozess zerst√∂rt, werden diese Informationen gespeichert, sodass die Kennung beim n√§chsten Start unserer Anwendung verf√ºgbar ist. </li><li>  <b>Benutzerobjekt:</b> Eine Datenklasse, die Benutzerinformationen enth√§lt. </li></ul><br>  Wir verwenden ein <code>UserProfileViewModel</code> das auf einer Komponente der ViewModel-Architektur basiert, um diese Informationen zu speichern. <br><br>  <i><u>Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ViewModel-</a> Objekt stellt Daten f√ºr eine bestimmte Benutzeroberfl√§chenkomponente bereit, z. B. ein Fragment oder eine Aktivit√§t, und enth√§lt eine Gesch√§ftsdatenverarbeitungslogik f√ºr die Interaktion mit dem Modell.</u></i>  <i><u>Beispielsweise kann das <b>ViewModel</b> andere Komponenten aufrufen, um Daten zu laden, und Benutzeranforderungen f√ºr Daten√§nderungen weiterleiten.</u></i>  <i><u><b>ViewModel</b> kennt die Komponenten der Benutzeroberfl√§che nicht und ist daher nicht von Konfigurations√§nderungen betroffen, z. B. der Neuerstellung von Aktivit√§ten beim Drehen des Ger√§ts.</u></i> <br><br>  Jetzt haben wir die folgenden Dateien identifiziert: <br><br><ul><li>  <code>user_profile.xml</code> : Definiertes Layout der Benutzeroberfl√§che. </li><li>  <code>UserProfileFragment</code> : beschreibt einen Benutzeroberfl√§chen-Controller, der f√ºr die Anzeige von Informationen f√ºr den Benutzer verantwortlich ist. </li><li>  <code>UserProfileViewModel</code> : Eine Klasse, die daf√ºr verantwortlich ist, Daten f√ºr die Anzeige in <code>UserProfileFragment</code> und auf Benutzerinteraktionen zu reagieren. </li></ul><br>  Die folgenden Codefragmente zeigen den urspr√ºnglichen Inhalt dieser Dateien.  (Die Layoutdatei ist der Einfachheit halber weggelassen.) <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : User = TODO() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel: UserProfileViewModel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> viewModels() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span>: View { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }</code> </pre> <br>  Wie verbinden wir diese Codemodule, nachdem wir sie haben?  Nachdem das Benutzerfeld in der UserProfileViewModel-Klasse festgelegt wurde, ben√∂tigen wir eine M√∂glichkeit, die Benutzeroberfl√§che zu informieren. <br><br>  <i><b>Hinweis</b></i>  <i>Mit SavedStateHandle kann das ViewModel auf den gespeicherten Status und die Argumente des zugeordneten Fragments oder der zugeordneten Aktion zugreifen.</i> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateVMFactory(this) } ... )</span></span></code> </pre> <br>  Jetzt m√ºssen wir unser Fragment informieren, wenn das Benutzerobjekt empfangen wird.  Hier wird die Komponente der LiveData-Architektur angezeigt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LiveData</a> ist ein beobachtbarer Dateninhaber.  Andere Komponenten in Ihrer Anwendung k√∂nnen √Ñnderungen an Objekten mithilfe dieses Halters verfolgen, ohne explizite und harte Abh√§ngigkeitspfade zwischen ihnen zu erstellen.  Die LiveData-Komponente ber√ºcksichtigt auch den Lebenszyklusstatus der Komponenten Ihrer Anwendung, z. B. Aktivit√§ten, Fragmente und Dienste, und enth√§lt eine Bereinigungslogik, um Objektverluste und √ºberm√§√üigen Speicherverbrauch zu verhindern. <br><br>  <i>Hinweis</i>  <i>Wenn Sie bereits Bibliotheken wie RxJava oder Agera verwenden, k√∂nnen Sie diese anstelle von LiveData weiterhin verwenden.</i>  <i>Stellen Sie jedoch bei Verwendung von Bibliotheken und √§hnlichen Ans√§tzen sicher, dass Sie den Lebenszyklus Ihrer Anwendung ordnungsgem√§√ü handhaben.</i>  <i>Stellen Sie insbesondere sicher, dass Sie Ihre Datenstr√∂me anhalten, wenn der zugeordnete LifecycleOwner gestoppt wird, und diese Streams zerst√∂ren, wenn der zugeordnete LifecycleOwner zerst√∂rt wurde.</i>  <i>Sie k√∂nnen auch das Artefakt android.arch.lifecycle: Jetstreams hinzuf√ºgen, um LiveData mit einer anderen Jetstream-Bibliothek wie RxJava2 zu verwenden.</i> <br><br>  Um die LiveData-Komponente in unsere Anwendung aufzunehmen, √§ndern wir den <code>UserProfileViewModel</code> in <code>UserProfileViewModel</code> in LiveData.  <code>UserProfileFragment</code> jetzt √ºber <code>UserProfileFragment</code> informiert.  Da dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LiveData-</a> Feld den Lebenszyklus unterst√ºtzt, werden Links automatisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gel√∂scht</a> , wenn sie nicht mehr ben√∂tigt werden. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span></span>( savedStateHandle: SavedStateHandle ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = TODO() }</code> </pre> <br>  Jetzt √§ndern wir das <code>UserProfileFragment</code> , um die Daten im <code>ViewModel</code> zu beobachten und die Benutzeroberfl√§che entsprechend den √Ñnderungen zu aktualisieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { <span class="hljs-comment"><span class="hljs-comment">//  UI } }</span></span></code> </pre> <br>  Jedes Mal, wenn die Benutzerprofildaten aktualisiert werden, wird der R√ºckruf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onChanged ()</a> aufgerufen und die Benutzeroberfl√§che aktualisiert. <br><br>  Wenn Sie mit anderen Bibliotheken vertraut sind, die beobachtbare R√ºckrufe verwenden, haben Sie m√∂glicherweise festgestellt, dass wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onStop ()</a> -Methode des Fragments nicht neu definiert haben, um die Beobachtung der Daten zu beenden.  Dieser Schritt ist f√ºr LiveData optional, da er den Lebenszyklus unterst√ºtzt. Dies bedeutet, dass der R√ºckruf <code>onChanged()</code> nicht aufgerufen wird, wenn sich das Fragment in einem inaktiven Zustand befindet.  Das hei√üt, er hat einen Aufruf von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onStart () erhalten</a> , aber noch keinen <code>onStop()</code> ) erhalten.  LiveData entfernt den Beobachter auch automatisch, wenn die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">onDestroy ()</a> -Methode f√ºr das Fragment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgerufen wird</a> . <br><br>  Wir haben keine Logik hinzugef√ºgt, um Konfigurations√§nderungen zu behandeln, z. B. das Drehen des Ger√§tebildschirms durch den Benutzer.  <code>UserProfileViewModel</code> automatisch wiederhergestellt, wenn die Konfiguration ge√§ndert wird. Sobald ein neues Fragment erstellt wird, erh√§lt es dieselbe <code>ViewModel</code> Instanz und der R√ºckruf wird sofort unter Verwendung der aktuellen Daten aufgerufen.  Da <code>ViewModel</code> Objekte so konzipiert sind, dass sie die entsprechenden <code>View</code> Objekte √ºberleben, die sie aktualisieren, sollten Sie keine direkten Verweise auf <code>View</code> Objekte in Ihre ViewModel-Implementierung aufnehmen.  Weitere Informationen zur Lebensdauer des <code>ViewModel</code> im Lebenszyklus der Komponenten der Benutzeroberfl√§che (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ViewModel-Lebenszyklus).</a> <br><br><h3>  Datenabruf </h3><br>  Wie k√∂nnen wir Benutzerprofildaten <code>UserProfileViewModel</code> , <code>UserProfileFragment</code> wir LiveData verwendet haben, um <code>UserProfileViewModel</code> mit UserProfileFragment zu verbinden? <br><br>  In diesem Beispiel wird davon ausgegangen, dass unser Backend eine REST-API bereitstellt.  Wir verwenden die Retrofit-Bibliothek, um auf unser Backend zuzugreifen. Sie k√∂nnen jedoch auch eine andere Bibliothek verwenden, die denselben Zweck erf√ºllt. <br><br>  Hier ist unsere Definition eines <code>Webservice</code> , der auf unser Backend verweist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Webservice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> declares an HTTP GET request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Path</span></span></span><span class="hljs-comment">("user") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> path */</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/users/{user}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Path(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"user"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;User&gt; }</code> </pre> <br>  Eine erste Idee f√ºr die Implementierung eines <code>ViewModel</code> k√∂nnte darin bestehen, den <code>Webservice</code> aufzurufen, um die Daten abzurufen und diese Daten unserem <code>LiveData</code> Objekt <code>LiveData</code> .  Dieses Design funktioniert, aber die Verwendung macht es schwieriger, unsere Anwendung zu warten, wenn sie w√§chst.  Dies gibt der <code>UserProfileViewModel</code> Klasse zu viel Verantwortung, was gegen das Prinzip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Interessentrennung</a> verst√∂√üt.  Dar√ºber hinaus ist der Bereich des ViewModel dem Lebenszyklus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktivit√§t</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fragment zugeordnet.</a> Dies bedeutet, dass Daten vom <code>Webservice</code> verloren gehen, wenn der Lebenszyklus des zugeordneten Benutzeroberfl√§chenobjekts endet.  Dieses Verhalten f√ºhrt zu einer unerw√ºnschten Benutzererfahrung. <br><br>  Stattdessen delegiert unser <code>ViewModel</code> den Prozess des Abrufs von Daten an ein neues Speichermodul. <br><br>  <u><i><b>Repository-</b> Module verarbeiten Datenoperationen.</i></u>  <u><i>Sie bieten eine saubere API, damit der Rest der Anwendung diese Daten problemlos abrufen kann.</i></u>  <u><i>Sie wissen, woher sie die Daten beziehen und welche API-Aufrufe beim Aktualisieren der Daten ausgef√ºhrt werden m√ºssen.</i></u>  <u><i>Sie k√∂nnen sich Repositorys als Vermittler zwischen verschiedenen Datenquellen vorstellen, z. B. persistenten Modellen, Webdiensten und Caches.</i></u> <br><br>  Unsere <code>UserRepository</code> Klasse, die im folgenden <code>UserRepository</code> gezeigt wird, verwendet eine Instanz von <code>WebService</code> , um Benutzerdaten abzurufen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> webservice: Webservice = TODO() <span class="hljs-comment"><span class="hljs-comment">// ... fun getUser(userId: String): LiveData&lt;User&gt; { //    .    . val data = MutableLiveData&lt;User&gt;() webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br>  Obwohl das Speichermodul unn√∂tig erscheint, dient es einem wichtigen Zweck: Es abstrahiert Datenquellen vom Rest der Anwendung.  Jetzt wei√ü unser <code>UserProfileViewModel</code> nicht, wie Daten abgerufen werden sollen, sodass wir Pr√§sentationsmodelle mit Daten aus verschiedenen Datenextraktionsimplementierungen bereitstellen k√∂nnen. <br><br>  <b>Hinweis</b>  Der Einfachheit halber haben wir den Fall von Netzwerkfehlern √ºbersehen.  Eine alternative Implementierung, die Fehler und den Download-Status aufdeckt, finden Sie im Anhang: Offenlegung des Netzwerkstatus. <br><br>  <b>Verwalten von Abh√§ngigkeiten zwischen Komponenten</b> <br><br>  Die <code>UserRepository</code> genannte <code>UserRepository</code> Klasse ben√∂tigt eine Instanz von <code>Webservice</code> , um Benutzerdaten abzurufen.  Er k√∂nnte nur eine Instanz erstellen, muss daf√ºr aber auch die Abh√§ngigkeiten der <code>Webservice</code> Klasse kennen.  Dar√ºber hinaus ist <code>UserRepository</code> wahrscheinlich nicht die einzige Klasse, die einen Webdienst ben√∂tigt.  In dieser Situation m√ºssen wir den Code duplizieren, da jede Klasse, die einen Link zum <code>Webservice</code> ben√∂tigt, wissen muss, wie er und seine Abh√§ngigkeiten erstellt werden.  Wenn jede Klasse einen neuen <code>WebService</code> , kann unsere Anwendung sehr ressourcenintensiv werden. <br><br>  Um dieses Problem zu l√∂sen, k√∂nnen Sie die folgenden Entwurfsmuster verwenden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abh√§ngigkeitsinjektion (DI)</a> .  Mit der Abh√§ngigkeitsinjektion k√∂nnen Klassen ihre Abh√§ngigkeiten definieren, ohne sie zu erstellen.  Zur Laufzeit ist eine andere Klasse f√ºr die Bereitstellung dieser Abh√§ngigkeiten verantwortlich.  Wir empfehlen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dagger 2-</a> Bibliothek f√ºr die Implementierung der Abh√§ngigkeitsinjektion in Android-Anwendungen.  Dolch 2 erstellt automatisch Objekte unter Umgehung des Abh√§ngigkeitsbaums und bietet Garantien zur Kompilierungszeit f√ºr Abh√§ngigkeiten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Service Location) Service</a> Locator: Die Service Locator-Vorlage bietet eine Registrierung, in der Klassen ihre Abh√§ngigkeiten abrufen k√∂nnen, anstatt sie zu erstellen. </li></ul><br>  Das Implementieren einer Dienstregistrierung ist einfacher als die Verwendung von DI. Wenn Sie DI noch nicht kennen, verwenden Sie stattdessen die Vorlage: Dienstort. <br><br>  Mit diesen Vorlagen k√∂nnen Sie Ihren Code skalieren, da sie eindeutige Vorlagen zum Verwalten von Abh√§ngigkeiten enthalten, ohne den Code zu duplizieren oder zu komplizieren.  Dar√ºber hinaus k√∂nnen Sie mit diesen Vorlagen schnell zwischen Test- und Produktionsimplementierungen f√ºr die Datenerfassung wechseln. <br><br>  Unsere Beispielanwendung verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dolch 2</a> , um die Abh√§ngigkeiten des <code>Webservice</code> Objekts zu verwalten. <br><br><h3>  Verbinden Sie ViewModel und Storage </h3><br>  Jetzt √§ndern wir unser <code>UserProfileViewModel</code> , um das <code>UserRepository</code> Objekt zu verwenden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( savedStateHandle: SavedStateHandle, userRepository: UserRepository ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = userRepository.getUser(userId) }</code> </pre> <br><h3>  Caching </h3><br>  Die <code>UserRepository</code> Implementierung abstrahiert den Aufruf des <code>Webservice</code> Objekts. Da sie jedoch nur auf einer Datenquelle basiert, ist sie nicht sehr flexibel. <br><br>  Das Hauptproblem bei der Implementierung von <code>UserRepository</code> besteht darin, dass diese Daten nach dem Empfang von Daten aus unserem Backend nirgendwo gespeichert werden.  Wenn der Benutzer <code>UserProfileFragment</code> verl√§sst und dann zu ihm zur√ºckkehrt, muss unsere Anwendung die Daten abrufen, auch wenn sie sich nicht ge√§ndert haben. <br><br>  Dieses Design ist aus folgenden Gr√ºnden nicht optimal: <br><br><ul><li>  Es verbraucht wertvolle Verkehrsressourcen. </li><li>  Dadurch wartet der Benutzer auf den Abschluss einer neuen Anforderung. </li></ul><br>  Um diese M√§ngel zu <code>UserRepository</code> , f√ºgen wir unserem <code>UserRepository</code> eine neue Datenquelle <code>UserRepository</code> , die <code>User</code> im Speicher zwischenspeichert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Dagger,        . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val userCache: UserCache ) { fun getUser(userId: String): LiveData&lt;User&gt; { val cached = userCache.get(userId) if (cached != null) { return cached } val data = MutableLiveData&lt;User&gt;() userCache.put(userId, data) //     ,  ,  . //      . webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br><h3>  Persistente Daten </h3><br>  Wenn der Benutzer in unserer aktuellen Implementierung das Ger√§t dreht oder das Ger√§t verl√§sst und sofort zur Anwendung zur√ºckkehrt, wird die vorhandene Benutzeroberfl√§che sofort sichtbar, da der Speicher Daten aus unserem Cache im Speicher abruft. <br><br>  Was passiert jedoch, wenn ein Benutzer die Anwendung verl√§sst und einige Stunden nach Abschluss des Vorgangs durch das Android-Betriebssystem zur√ºckkehrt?  Basierend auf unserer aktuellen Implementierung in dieser Situation m√ºssen wir erneut Daten aus dem Netzwerk abrufen.  Dieser Upgrade-Prozess ist nicht nur eine schlechte Benutzererfahrung.  Es ist auch verschwenderisch, weil es wertvolle mobile Daten verbraucht. <br><br>  Sie k√∂nnen dieses Problem l√∂sen, indem Sie Webanfragen zwischenspeichern. Dies f√ºhrt jedoch zu einem neuen Schl√ºsselproblem: Was passiert, wenn dieselben Benutzerdaten in einer Anfrage eines anderen Typs angezeigt werden, z. B. beim Empfang einer Freundesliste?  Die Anwendung zeigt widerspr√ºchliche Daten an, was bestenfalls verwirrend ist.  Beispielsweise kann unsere Anwendung zwei verschiedene Versionen der Daten desselben Benutzers anzeigen, wenn der Benutzer zu unterschiedlichen Zeiten eine Freundschaftslistenanforderung und eine Einzelbenutzeranforderung gesendet hat.  Unsere Anwendung m√ºsste herausfinden, wie diese widerspr√ºchlichen Daten kombiniert werden k√∂nnen. <br><br>  Der richtige Weg, um mit dieser Situation umzugehen, ist die Verwendung eines konstanten Modells.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Room</a> Permanent Data Library (DB) hilft uns dabei. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Room</a> ist eine Objektzuordnungsbibliothek, die die lokale Datenspeicherung mit einem Mindeststandardcode bereitstellt.  Zur Kompilierungszeit wird jede Abfrage auf √úbereinstimmung mit Ihrem Datenschema √ºberpr√ºft, sodass fehlerhafte SQL-Abfragen zu Fehlern beim Kompilieren f√ºhren und nicht zur Laufzeit abst√ºrzen.  Raumzusammenfassungen von einigen grundlegenden Implementierungsdetails von SQL-Rohtabellen und -Abfragen.  Au√üerdem k√∂nnen Sie √Ñnderungen an Datenbankdaten, einschlie√ülich Sammlungen und Verbindungsanforderungen, beobachten und solche √Ñnderungen mithilfe von LiveData-Objekten offenlegen.  Es werden sogar explizit Ausf√ºhrungsbeschr√§nkungen definiert, die h√§ufig auftretende Threading-Probleme l√∂sen, z. B. den Zugriff auf den Speicher im Haupt-Thread. <br><br>  <i><b>Hinweis</b></i>  <i>Wenn Ihre Anwendung bereits eine andere L√∂sung verwendet, z. B. ORM (SQLite Object Relational Mapping), m√ºssen Sie die vorhandene L√∂sung nicht durch Room ersetzen.</i>  <i>Wenn Sie jedoch eine neue Anwendung schreiben oder eine vorhandene Anwendung neu organisieren, empfehlen wir, Room zum Speichern Ihrer Anwendungsdaten zu verwenden.</i>  <i>So k√∂nnen Sie die Abstraktion der Bibliothek und die Abfragevalidierung nutzen.</i> <br><br>  Um Room nutzen zu k√∂nnen, m√ºssen wir unser lokales Layout definieren.  Zuerst f√ºgen wir die Annotation <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Entity</a></code> zu unserer <code>User</code> und <code>@PrimaryKey</code> Annotation <code>@PrimaryKey</code> im Feld Klassen- <code>id</code> .  Diese Anmerkungen markieren <code>User</code> als Tabelle in unserer Datenbank und <code>id</code> als Prim√§rschl√ºssel der Tabelle: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String )</code> </pre> <br>  Anschlie√üend erstellen wir die Datenbankklasse, indem wir <code>RoomDatabase</code> f√ºr unsere Anwendung implementieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>()</code> </pre> <br>  Beachten Sie, dass <code>UserDatabase</code> abstrakt ist.  Die Raumbibliothek bietet automatisch eine Implementierung davon.  Weitere Informationen finden Sie in der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Room</a> . <br><br>  Jetzt brauchen wir eine M√∂glichkeit, Benutzerdaten in die Datenbank einzuf√ºgen.  F√ºr diese Aufgabe erstellen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Datenzugriffsobjekt (DAO)</a> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = REPLACE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: LiveData&lt;User&gt; }</code> </pre> <br>  Beachten Sie, dass die Lademethode ein Objekt vom Typ LiveData zur√ºckgibt.  Room wei√ü, wann die Datenbank ge√§ndert wird, und benachrichtigt automatisch alle aktiven Beobachter √ºber Daten√§nderungen.  Da Room <i>LiveData verwendet</i> , ist dieser Vorgang effizient.  Daten werden nur aktualisiert, wenn mindestens ein Beobachter aktiv ist. <br><br>  <i><b>Hinweis: Der</b> Raum pr√ºft auf Ung√ºltigmachung aufgrund von Tabellen√§nderungen. Dies bedeutet, dass falsch positive Benachrichtigungen gesendet werden k√∂nnen.</i> <br><br>  Nachdem wir unsere <code>UserDao</code> Klasse definiert haben, <code>UserDao</code> wir auf das DAO aus unserer Datenbankklasse: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: UserDao }</code> </pre> <br>  Jetzt k√∂nnen wir unser <code>UserRepository</code> so √§ndern, dass es die <code>UserRepository</code> enth√§lt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val executor: Executor, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { refreshUser(userId) //   LiveData    . return userDao.load(userId) } private fun refreshUser(userId: String) { //    . executor.execute { // ,      . val userExists = userDao.hasUser(FRESH_TIMEOUT) if (!userExists) { //  . val response = webservice.getUser(userId).execute() //    . //   .  LiveData  , //        . userDao.save(response.body()!!) } } } companion object { val FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(1) } }</span></span></code> </pre> <br>  Bitte beachten Sie, dass wir unser <code>UserProfileViewModel</code> oder <code>UserProfileFragment</code> nicht √§ndern <code>UserProfileViewModel</code> , auch wenn wir die Datenquelle in <code>UserRepository</code> <code>UserProfileFragment</code> .  Dieses kleine Update zeigt die Flexibilit√§t unserer Anwendungsarchitektur.  Es eignet sich auch hervorragend zum Testen, da wir ein gef√§lschtes <code>UserRepository</code> und gleichzeitig unser Produktions- <code>UserProfileViewModel</code> testen k√∂nnen. <br><br>  Wenn Benutzer innerhalb weniger Tage zur√ºckkehren, zeigt eine Anwendung, die diese Architektur verwendet, wahrscheinlich veraltete Informationen an, bis das Repository aktualisierte Informationen erh√§lt.  Abh√§ngig von Ihrem Anwendungsfall werden m√∂glicherweise keine veralteten Informationen angezeigt.  Stattdessen k√∂nnen Sie <i>Platzhalterdaten</i> anzeigen, die Dummy-Werte anzeigen und anzeigen, dass Ihre Anwendung gerade aktuelle Informationen l√§dt und l√§dt. <br><br>  <b>Die einzige Quelle der Wahrheit</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Regel geben verschiedene REST-API-Endpunkte dieselben Daten zur√ºck. Wenn unser Backend beispielsweise √ºber einen anderen Endpunkt verf√ºgt, der eine Liste von Freunden zur√ºckgibt, kann dasselbe Benutzerobjekt von zwei verschiedenen API-Endpunkten stammen, m√∂glicherweise sogar mit unterschiedlichen Detaillierungsgraden. Wenn wir </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Antwort von der Anforderung </font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unver√§ndert zur√ºckgeben, ohne die Konsistenz zu √ºberpr√ºfen, k√∂nnen unsere Benutzeroberfl√§chen verwirrende Informationen anzeigen, da die Version und das Format der Daten aus dem Speicher vom zuletzt aufgerufenen Endpunkt abh√§ngen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichert </font><font style="vertical-align: inherit;">unsere Implementierung </font><font style="vertical-align: inherit;">Webdienstantworten in einer Datenbank. √Ñnderungen an der Datenbank l√∂sen dann R√ºckrufe f√ºr aktive </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte aus </font><font style="vertical-align: inherit;">. Mit diesem Modell,</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Datenbank ist die einzige Quelle der Wahrheit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und andere Teile der Anwendung greifen √ºber unsere darauf zu </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unabh√§ngig davon, ob Sie einen Festplatten-Cache verwenden, empfehlen wir, dass Ihr Repository die Datenquelle als einzige Wahrheitsquelle f√ºr den Rest Ihrer Anwendung identifiziert.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betriebsfortschritt anzeigen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einigen Anwendungsf√§llen, z. B. beim Pull-to-Refresh, ist es wichtig, dass die Benutzeroberfl√§che dem Benutzer anzeigt, dass gerade ein Netzwerkvorgang ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Es wird empfohlen, die Benutzeroberfl√§chenaktion von den tats√§chlichen Daten zu trennen, da die Daten aus verschiedenen Gr√ºnden aktualisiert werden k√∂nnen. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise eine Liste mit Freunden erhalten, kann derselbe Benutzer programmgesteuert erneut ausgew√§hlt werden, was zu einer Aktualisierung von LiveData f√ºhrt. </font><font style="vertical-align: inherit;">Aus Sicht der Benutzeroberfl√§che ist die Tatsache, dass eine Anfrage im Flug ist, nur ein weiterer Datenpunkt, √§hnlich wie bei jedem anderen Datenelement im Objekt selbst </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen eine der folgenden Strategien verwenden, um den vereinbarten Datenaktualisierungsstatus in der Benutzeroberfl√§che anzuzeigen, unabh√§ngig davon, woher die Datenaktualisierungsanforderung stammt: </font></font><br><br><ul><li>  <code>getUser ()</code> ,      <code>LiveData</code> .         .  ,   NetworkBoundResource   GitHub <a href="">android-Architecture-components</a> . </li><li>       <code>UserRepository</code> ,      .    ,              ,         ,   pull-to-refresh. </li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Abschnitt √ºber die Trennung von Interessen haben wir erw√§hnt, dass einer der Hauptvorteile der Befolgung dieses Prinzips die Testbarkeit ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die folgende Liste zeigt, wie Sie jedes Codemodul anhand unseres erweiterten Beispiels testen:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzeroberfl√§che und Interaktion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Verwenden Sie das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android UI Test Toolkit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der beste Weg, um diesen Test zu erstellen, ist die Verwendung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espresso-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie k√∂nnen ein Fragment erstellen und es mit einem Layout versehen </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da das Fragment nur mit verkn√ºpft </font><font style="vertical-align: inherit;">ist, reicht es </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aus,</font></a><font style="vertical-align: inherit;"> nur diese Klasse zu </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verspotten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(zu imitieren)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Benutzeroberfl√§che Ihrer Anwendung vollst√§ndig zu testen.</font></font></li><li> <b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JUnit</a> .      , <code>UserRepository</code> . </li><li> <b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code> .      : <br><br><ul><li>     -. </li><li>      . </li><li>     ,     . </li></ul><br></li><li>   <code>Webservice</code> ,  <code>UserDao</code>  ,             . </li><li> <b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        ‚Ä¶ <br><br> <i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SupportSQLiteOpenHelper</a></b> .     ,      SQLite     SQLite   .</i> </li><li> <b>-:</b>         .   ,  -,      .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/square/ok">MockWebServer</a> ,          . </li><li> <b> :</b>     maven    .    <code>androidx.arch.core</code> :    JUnit: <br><br><ul><li> <code>InstantTaskExecutorRule:</code>            . </li><li> <code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </li></ul><br></li></ul><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Programmierung ist ein kreatives Feld, und die Erstellung von Android-Anwendungen ist keine Ausnahme. Es gibt viele M√∂glichkeiten, das Problem zu l√∂sen, sei es das √úbertragen von Daten zwischen mehreren Aktionen oder Fragmenten, das Abrufen gel√∂schter Daten und das lokale Speichern offline oder eine beliebige Anzahl anderer h√§ufiger Szenarien, auf die nicht triviale Anwendungen sto√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die folgenden Empfehlungen nicht erforderlich sind, zeigt unsere Erfahrung, dass ihre Implementierung Ihre Codebasis auf lange Sicht zuverl√§ssiger, testbarer und unterst√ºtzter macht: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie es, die Einstiegspunkte Ihrer Anwendung - wie Aktionen, Dienste und Rundfunkempf√§nger - als Datenquellen festzulegen.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen m√ºssen sie nur mit anderen Komponenten koordinieren, um eine Teilmenge der Daten zu diesem Einstiegspunkt zu erhalten. Jede Komponente der Anwendung ist von kurzer Dauer, abh√§ngig von der Interaktion des Benutzers mit seinem Ger√§t und dem allgemeinen aktuellen Status des Systems. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie klare Verantwortungsbereiche zwischen den verschiedenen Modulen Ihrer Anwendung.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verteilen Sie beispielsweise keinen Code, der Daten aus dem Netzwerk herunterl√§dt, an mehrere Klassen oder Pakete in Ihrer Codebasis. Definieren Sie in √§hnlicher Weise nicht mehrere nicht miteinander verbundene Verantwortlichkeiten wie Daten-Caching und Datenbindung in derselben Klasse. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belichten Sie jedes Modul so wenig wie m√∂glich.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widerstehen Sie der Versuchung, ein "nur ein" Etikett zu erstellen, das die Details einer internen Implementierung aus einem Modul enth√ºllt. Sie k√∂nnen kurzfristig etwas Zeit gewinnen, aber dann werden Sie viele Male eine technische Verschuldung erleiden, wenn sich Ihre Codebasis entwickelt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlegen Sie, wie Sie jedes Modul einzeln testbar machen k√∂nnen.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine gut definierte API zum Abrufen von Daten aus dem Netzwerk erleichtert beispielsweise das Testen eines Moduls, das diese Daten in einer lokalen Datenbank speichert. Wenn Sie stattdessen die Logik dieser beiden Module an einem Ort mischen oder Ihren Netzwerkcode in der Codebasis verteilen, wird das Testen viel schwieriger - in einigen F√§llen sogar unm√∂glich. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konzentrieren Sie sich auf den einzigartigen Kern Ihrer Anwendung, um sich von anderen Anwendungen abzuheben.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfinden Sie das Rad nicht neu, indem Sie immer wieder dasselbe Muster schreiben. Konzentrieren Sie stattdessen Ihre Zeit und Energie auf das, was Ihre Anwendung einzigartig macht, und lassen Sie die Komponenten der Android-Architektur und anderer empfohlener Bibliotheken mit einem sich wiederholenden Muster fertig werden. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewahren Sie so viele relevante und aktuelle Daten wie m√∂glich auf.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So k√∂nnen Benutzer die Funktionalit√§t Ihrer Anwendung nutzen, auch wenn ihr Ger√§t offline ist. Denken Sie daran, dass nicht alle Benutzer eine konstante Hochgeschwindigkeitsverbindung verwenden. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie eine einzelne Datenquelle als einzig wahre Quelle fest.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wann immer Ihre Anwendung Zugriff auf diese Daten ben√∂tigt, sollte sie immer aus dieser einzigen Quelle der Wahrheit stammen.</font></font><br><br><h3> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachtrag: Offenlegung des Netzwerkstatus</font></font></u> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im obigen Abschnitt der empfohlenen Anwendungsarchitektur haben wir Netzwerkfehler und Startzust√§nde √ºbersprungen, um Codefragmente zu vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt wird gezeigt, wie der Netzwerkstatus mithilfe der Ressourcenklasse angezeigt wird, die sowohl Daten als auch deren Status kapselt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Codefragment enth√§lt eine Beispielimplementierung</font></font><code>Resource:</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         . sealed class Resource&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Success&lt;T&gt;(data: T) : Resource&lt;T&gt;(data) class Loading&lt;T&gt;(data: T? = null) : Resource&lt;T&gt;(data) class Error&lt;T&gt;(message: String, data: T? = null) : Resource&lt;T&gt;(data, message) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Herunterladen von Daten aus dem Netzwerk beim Anzeigen einer Kopie dieser Daten g√§ngige Praxis ist, ist es hilfreich, eine Hilfsklasse zu erstellen, die an mehreren Stellen wiederverwendet werden kann. In diesem Beispiel erstellen wir eine Klasse mit dem Namen </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Diagramm zeigt den Entscheidungsbaum f√ºr </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es beginnt mit der Beobachtung der Datenbank f√ºr die Ressource. Wenn ein Datensatz zum ersten Mal aus der Datenbank heruntergeladen wird, wird </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºberpr√ºft, ob das Ergebnis zum Senden gut genug ist oder ob es aus dem Netzwerk abgerufen werden muss. Bitte beachten Sie, dass beide Situationen gleichzeitig auftreten k√∂nnen, da Sie wahrscheinlich zwischengespeicherte Daten anzeigen m√∂chten, wenn Sie sie aus dem Netzwerk aktualisieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Netzwerkaufruf erfolgreich ist, speichert er die Antwort in der Datenbank und initialisiert den Stream neu. Bei einem Netzwerkanforderungsfehler wird </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Fehler direkt </font><font style="vertical-align: inherit;">gesendet </font><font style="vertical-align: inherit;">. </font></font><br><br> <code><b>.</b>             .       ,       .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass das Verlassen einer Datenbank zum Senden von √Ñnderungen die Verwendung verwandter Nebenwirkungen erfordert. Dies ist nicht sehr gut, da das undefinierte Verhalten dieser Nebenwirkungen auftreten kann, wenn die Datenbank die √Ñnderungen nicht sendet, weil sich die Daten nicht ge√§ndert haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie auch keine vom Netzwerk empfangenen Ergebnisse, da dies gegen das Prinzip einer einzigen Wahrheitsquelle verst√∂√üt. </font><font style="vertical-align: inherit;">Am Ende ist es m√∂glich, dass die Datenbank Trigger enth√§lt, die Datenwerte w√§hrend des Speichervorgangs √§ndern. </font><font style="vertical-align: inherit;">Senden Sie in √§hnlicher Weise nicht "ERFOLG" ohne neue Daten, da der Client dann die falsche Version der Daten erh√§lt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Codefragment zeigt die offene API, die von der Klasse </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr ihre Unterklassen </font><font style="vertical-align: inherit;">bereitgestellt wird </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ResultType:   . // RequestType:   API. abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; { //      API   . @WorkerThread protected abstract fun saveCallResult(item: RequestType) //      ,  ,    //     . @MainThread protected abstract fun shouldFetch(data: ResultType?): Boolean //        . @MainThread protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt; //     API. @MainThread protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; // ,    .   //    ,    . protected open fun onFetchFailed() {} //   LiveData,  , //    . fun asLiveData(): LiveData&lt;ResultType&gt; = TODO() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie die folgenden wichtigen Details der Klassendefinition: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es definiert zwei Typparameter, </font></font><code>ResultType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>RequestType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da der von der API zur√ºckgegebene Datentyp m√∂glicherweise nicht dem lokal verwendeten Datentyp entspricht.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es verwendet eine Klasse </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Netzwerkanforderungen. </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist ein einfacher Wrapper f√ºr eine Klasse </font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Antworten in Instanzen konvertiert </font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die vollst√§ndige Implementierung der Klasse wird </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Teil des </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekts f√ºr </font><a href=""><font style="vertical-align: inherit;">Android-Architektur-Komponenten</font></a><font style="vertical-align: inherit;"> angezeigt </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung k√∂nnen wir damit unsere festplatten- und netzwerkgebundenen Implementierungen </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in die Klasse </font><font style="vertical-align: inherit;">schreiben </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger2,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { return object : NetworkBoundResource&lt;User, User&gt;() { override fun saveCallResult(item: User) { userDao.save(item) } override fun shouldFetch(data: User?): Boolean { return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)) } override fun loadFromDb(): LiveData&lt;User&gt; { return userDao.load(userId) } override fun createCall(): LiveData&lt;ApiResponse&lt;User&gt;&gt; { return webservice.getUser(userId) } }.asLiveData() } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456256/">https://habr.com/ru/post/de456256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456240/index.html">Chatbot-Entwicklung (Laravel + Botman)</a></li>
<li><a href="../de456242/index.html">Ein bisschen mehr √ºber Multitasking in Mikrocontrollern</a></li>
<li><a href="../de456246/index.html">Nullelement</a></li>
<li><a href="../de456248/index.html">Wie ich gefangen habe: vor Stilen f√ºr ein Fokuselement</a></li>
<li><a href="../de456250/index.html">Anwendungslokalisierung und RTL-Unterst√ºtzung. Bericht Yandex.Taxi</a></li>
<li><a href="../de456258/index.html">Frei wie ein Wind und frei wie ein Bier √úbersetzung von "Frei wie in Freiheit" ins Russische unter der GNU FDL 1.3 Lizenz</a></li>
<li><a href="../de456260/index.html">Fair Economy Talk</a></li>
<li><a href="../de456262/index.html">Software Defined Radio - wie funktioniert es? Teil 9</a></li>
<li><a href="../de456264/index.html">Erstellen Sie Android-Bin√§rdateien mit Source und Android NDK. Wir pumpen das Screencap-Dienstprogramm auf</a></li>
<li><a href="../de456266/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 302 (vom 10. bis 16. Juni)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>