<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💐 💻 🔌 Indeks dalam PostgreSQL - 4 (Btree) 👨🏿‍🏫 🧑🏽 🛌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah membahas mesin pengindeksan PostgreSQL dan antarmuka metode akses , serta indeks hash , salah satu metode akses. Kami sekarang akan mempert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 4 (Btree)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/443284/">  Kami telah membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka metode akses</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> , salah satu metode akses.  Kami sekarang akan mempertimbangkan B-tree, indeks yang paling tradisional dan banyak digunakan.  Artikel ini besar, jadi bersabarlah. <br><br><h1>  Btree </h1><br><h2>  Struktur </h2><br>  Jenis indeks B-tree, diimplementasikan sebagai metode akses "btree", cocok untuk data yang dapat diurutkan.  Dengan kata lain, operator "lebih besar", "lebih besar atau sama", "kurang", "kurang atau sama", dan "sama" harus ditentukan untuk tipe data.  Perhatikan bahwa data yang sama terkadang dapat diurutkan secara berbeda, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membawa kita kembali</a> ke konsep keluarga operator. <br><a name="habracut"></a><br>  Seperti biasa, baris indeks B-tree dikemas ke dalam halaman.  Di halaman daun, baris ini berisi data yang akan diindeks (kunci) dan referensi ke baris tabel (TIDs).  Di halaman internal, setiap baris referensi halaman anak indeks dan berisi nilai minimal di halaman ini. <br><br>  Pohon-B memiliki beberapa sifat penting: <br><br><ul><li>  Pohon-B seimbang, yaitu, setiap halaman daun dipisahkan dari akar dengan jumlah halaman internal yang sama.  Karena itu, mencari nilai apa pun membutuhkan waktu yang sama. <br></li><li>  Pohon-B adalah multi-cabang, yaitu, setiap halaman (biasanya 8 KB) berisi banyak (ratusan) TUT.  Akibatnya, kedalaman pohon-B cukup kecil, sebenarnya hingga 4-5 untuk tabel yang sangat besar. <br></li><li>  Data dalam indeks diurutkan dalam urutan nondecreasing (baik antara halaman dan di dalam setiap halaman), dan halaman tingkat yang sama terhubung satu sama lain dengan daftar dua arah.  Oleh karena itu, kita bisa mendapatkan kumpulan data yang diurutkan hanya dengan daftar jalan satu atau arah lainnya tanpa kembali ke root setiap kali. <br></li></ul><br>  Di bawah ini adalah contoh sederhana dari indeks pada satu bidang dengan kunci integer. <br><br><img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br><br>  Halaman pertama indeks adalah metapage, yang mereferensikan root indeks.  Node internal terletak di bawah root, dan halaman daun berada di baris paling bawah.  Panah bawah mewakili referensi dari node daun ke baris tabel (TIDs). <br><br><h3>  Cari berdasarkan kesetaraan </h3><br>  Mari pertimbangkan pencarian nilai dalam pohon berdasarkan kondisi " <em>indexed-field</em> = <em>ekspresi</em> ".  Katakanlah, kami tertarik pada kunci 49. <br><br><img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br><br>  Pencarian dimulai dengan simpul akar, dan kita perlu menentukan ke mana dari simpul anak untuk diturunkan.  Menyadari kunci-kunci di simpul akar (4, 32, 64), oleh karena itu kami mencari tahu kisaran nilai dalam simpul anak.  Karena 32 ≤ 49 &lt;64, kita perlu turun ke simpul anak kedua.  Selanjutnya, proses yang sama diulang secara rekursif sampai kita mencapai simpul daun dari mana TIDs yang dibutuhkan dapat diperoleh. <br><br>  Pada kenyataannya, sejumlah rincian mempersulit proses yang tampaknya sederhana ini.  Misalnya, indeks dapat berisi kunci yang tidak unik dan ada begitu banyak nilai yang sama sehingga tidak cocok dengan satu halaman.  Kembali ke contoh kita, tampaknya kita harus turun dari simpul internal atas referensi ke nilai 49. Tapi, seperti yang jelas dari gambar, dengan cara ini kita akan melewati salah satu dari "49" kunci di halaman daun sebelumnya .  Oleh karena itu, setelah kami menemukan kunci yang persis sama di halaman internal, kami harus turun satu posisi ke kiri dan kemudian mencari melalui baris indeks dari level yang mendasarinya dari kiri ke kanan untuk mencari kunci yang dicari. <br><br>  (Komplikasi lain adalah bahwa selama pencarian proses lain dapat mengubah data: pohon dapat dibangun kembali, halaman dapat dibagi menjadi dua, dll. Semua algoritma direkayasa untuk operasi bersamaan ini untuk tidak saling mengganggu satu sama lain dan tidak menyebabkan kunci tambahan sedapat mungkin. Tapi kami akan menghindari memperluas ini.) <br><br><h3>  Cari berdasarkan ketidaksetaraan </h3><br>  Saat mencari dengan kondisi " <em>bidang-indeks</em> ≤ <em>ekspresi</em> " (atau " <em>bidang-indeks</em> ≥ <em>ekspresi</em> "), pertama-tama kita menemukan nilai (jika ada) dalam indeks dengan kondisi kesetaraan " <em>indeks-bidang</em> = <em>ekspresi</em> " dan kemudian berjalan melalui halaman daun dalam arah yang sesuai sampai akhir. <br><br>  Angka tersebut menggambarkan proses ini untuk n ≤ 35: <br><br><img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br><br>  Operator "lebih besar" dan "kurang" didukung dengan cara yang sama, kecuali bahwa nilai yang awalnya ditemukan harus diturunkan. <br><br><h3>  Cari berdasarkan rentang </h3><br>  Saat mencari berdasarkan rentang " <em>ekspresi1</em> ≤ <em>bidang terindeks</em> ≤ <em>ekspresi2</em> ", kami menemukan nilai berdasarkan kondisi " <em>bidang terindeks</em> = <em>ekspresi1</em> ", dan kemudian terus berjalan melalui halaman daun sementara kondisi " <em>bidang terindeks</em> ≤ <em>ekspresi2</em> " terpenuhi;  atau sebaliknya: mulai dengan ekspresi kedua dan berjalan ke arah yang berlawanan sampai kita mencapai ekspresi pertama. <br><br>  Gambar menunjukkan proses ini untuk kondisi 23 ≤ n ≤ 64: <br><br><img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br><br><h2>  Contoh </h2><br>  Mari kita lihat contoh seperti apa rencana kueri.  Seperti biasa, kami menggunakan database demo, dan kali ini kami akan mempertimbangkan tabel pesawat.  Ini berisi sedikitnya sembilan baris, dan perencana akan memilih untuk tidak menggunakan indeks karena seluruh tabel cocok dengan satu halaman.  Tetapi tabel ini menarik bagi kita untuk tujuan ilustrasi. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts;</code> </pre> <pre> <code class="plaintext hljs"> aircraft_code | model | range ---------------+---------------------+------- 773 | Boeing 777-300 | 11100 763 | Boeing 767-300 | 7900 SU9 | Sukhoi SuperJet-100 | 3000 320 | Airbus A320-200 | 5700 321 | Airbus A321-200 | 5600 319 | Airbus A319-100 | 6700 733 | Boeing 737-300 | 4200 CN1 | Cessna 208 Caravan | 1200 CR2 | Bombardier CRJ-200 | 2700 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range); demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  (Atau secara eksplisit, "buat indeks pada pesawat menggunakan btree (range)", tapi itu adalah B-tree yang dibangun secara default.) <br><br>  Cari berdasarkan kesetaraan: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range = <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range = 3000) (2 rows)</code> </pre><br>  Cari berdasarkan ketidaksetaraan: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range &lt; 3000) (2 rows)</code> </pre><br>  Dan dengan rentang: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000)) (2 rows)</code> </pre><br><h2>  Menyortir </h2><br>  Sekali lagi mari kita tekankan poin bahwa dengan segala jenis pemindaian (indeks, hanya indeks, atau bitmap), metode akses "btree" mengembalikan data yang dipesan, yang dapat kita lihat dengan jelas pada gambar di atas. <br><br>  Oleh karena itu, jika tabel memiliki indeks pada kondisi pengurutan, pengoptimal akan mempertimbangkan kedua opsi: pemindaian indeks dari tabel, yang dengan mudah mengembalikan data yang diurutkan, dan pemindaian berurutan dari tabel dengan pengurutan selanjutnya dari hasil. <br><br><h3>  Sortir pesanan </h3><br>  Saat membuat indeks, kami dapat secara eksplisit menentukan urutan pengurutan.  Misalnya, kami dapat membuat indeks berdasarkan rentang penerbangan dengan cara ini khususnya: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>);</code> </pre><br>  Dalam hal ini, nilai yang lebih besar akan muncul di pohon di sebelah kiri, sedangkan nilai yang lebih kecil akan muncul di sebelah kanan.  Mengapa ini bisa diperlukan jika kita bisa berjalan melalui nilai yang diindeks di kedua arah? <br><br>  Tujuannya adalah indeks multi-kolom.  Mari kita buat tampilan untuk menunjukkan model pesawat dengan divisi konvensional menjadi pesawat jarak pendek, menengah, dan panjang: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> model, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v;</code> </pre><pre> <code class="plaintext hljs"> model | class ---------------------+------- Boeing 777-300 | 3 Boeing 767-300 | 2 Sukhoi SuperJet-100 | 1 Airbus A320-200 | 2 Airbus A321-200 | 2 Airbus A319-100 | 2 Boeing 737-300 | 2 Cessna 208 Caravan | 1 Bombardier CRJ-200 | 1 (9 rows)</code> </pre><br>  Dan mari kita buat indeks (menggunakan ekspresi): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), model);</code> </pre><br>  Sekarang kita dapat menggunakan indeks ini untuk mendapatkan data yang diurutkan berdasarkan kedua kolom dalam urutan menaik: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 1 | Bombardier CRJ-200 1 | Cessna 208 Caravan 1 | Sukhoi SuperJet-100 2 | Airbus A319-100 2 | Airbus A320-200 2 | Airbus A321-200 2 | Boeing 737-300 2 | Boeing 767-300 3 | Boeing 777-300 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Demikian pula, kita dapat melakukan kueri untuk mengurutkan data dalam urutan menurun: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 3 | Boeing 777-300 2 | Boeing 767-300 2 | Boeing 737-300 2 | Airbus A321-200 2 | Airbus A320-200 2 | Airbus A319-100 1 | Sukhoi SuperJet-100 1 | Cessna 208 Caravan 1 | Bombardier CRJ-200 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan BACKWARD using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Namun, kami tidak dapat menggunakan indeks ini untuk mendapatkan data yang diurutkan berdasarkan satu kolom dalam urutan menurun dan oleh kolom lainnya dalam urutan naik.  Ini akan membutuhkan pengurutan secara terpisah: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------- Sort Sort Key: (CASE ... END), aircrafts.model DESC -&gt; Seq Scan on aircrafts (3 rows)</code> </pre><br>  (Perhatikan bahwa, sebagai upaya terakhir, perencana memilih pemindaian berurutan terlepas dari pengaturan "enable_seqscan = off" yang dibuat sebelumnya. Ini karena sebenarnya pengaturan ini tidak melarang pemindaian tabel, tetapi hanya menetapkan biaya astronomisnya - silakan lihat paket dengan "Biaya pada".) <br><br>  Untuk membuat kueri ini menggunakan indeks, yang terakhir harus dibangun dengan arah pengurutan yang diperlukan: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> aircrafts_case_asc_model_desc_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts (1 row)</code> </pre><br><h3>  Urutan kolom </h3><br>  Masalah lain yang muncul saat menggunakan indeks multi-kolom adalah urutan kolom daftar dalam indeks.  Untuk B-tree, urutan ini sangat penting: data di dalam halaman akan diurutkan berdasarkan bidang pertama, kemudian oleh yang kedua, dan seterusnya. <br><br>  Kami dapat mewakili indeks yang kami buat pada interval interval dan model dengan cara simbolis sebagai berikut: <br><br><img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br><br>  Sebenarnya indeks sekecil itu pasti cocok untuk satu halaman root.  Dalam gambar, itu sengaja didistribusikan di antara beberapa halaman untuk kejelasan. <br><br>  Jelas dari bagan ini bahwa pencarian berdasarkan predikat seperti "class = 3" (pencarian hanya oleh bidang pertama) atau "class = 3 dan model = 'Boeing 777-300'" (pencarian oleh kedua bidang) akan bekerja secara efisien. <br><br>  Namun, pencarian dengan predikat "model = 'Boeing 777-300'" akan jauh lebih efisien: dimulai dengan root, kita tidak dapat menentukan ke mana simpul anak akan diturunkan, oleh karena itu, kita harus turun ke mereka semua.  Ini tidak berarti bahwa indeks seperti ini tidak dapat digunakan - efisiensinya menjadi masalah.  Sebagai contoh, jika kita memiliki tiga kelas pesawat dan banyak sekali model di setiap kelas, kita harus melihat sekitar sepertiga dari indeks dan ini mungkin lebih efisien daripada pemindaian tabel penuh ... atau tidak. <br><br>  Namun, jika kita membuat indeks seperti ini: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( model, (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>));</code> </pre><br>  urutan bidang akan berubah: <br><br><img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br><br>  Dengan indeks ini, pencarian dengan predikat "model = 'Boeing 777-300'" akan bekerja secara efisien, tetapi pencarian dengan predikat "class = 3" tidak akan. <br><br><h3>  Nulls </h3><br>  Metode akses "Btree" mengindeks NULL dan mendukung pencarian berdasarkan ketentuan IS NULL dan NOT NOT NULL. <br><br>  Mari kita perhatikan tabel penerbangan, tempat NULL terjadi: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (actual_arrival IS NULL) -&gt; Bitmap Index Scan on flights_actual_arrival_idx Index Cond: (actual_arrival IS NULL) (4 rows)</code> </pre><br>  NULL terletak di satu atau ujung node daun tergantung pada bagaimana indeks dibuat (NULLS FIRST atau NULLS LAST).  Ini penting jika kueri menyertakan pengurutan: indeks dapat digunakan jika perintah SELECT menentukan urutan NULL yang sama dalam klausa ORDER BY sebagai urutan yang ditentukan untuk indeks yang dibuat (NULLS FIRST atau NULLS LAST). <br><br>  Dalam contoh berikut, pesanan ini sama, oleh karena itu, kami dapat menggunakan indeks: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS LAST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using flights_actual_arrival_idx on flights (1 row)</code> </pre><br>  Dan di sini pesanan ini berbeda, dan pengoptimal memilih pemindaian berurutan dengan pengurutan berikutnya: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------- Sort Sort Key: actual_arrival NULLS FIRST -&gt; Seq Scan on flights (3 rows)</code> </pre><br>  Untuk menggunakan indeks, itu harus dibuat dengan NULL yang terletak di awal: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_nulls_first_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using flights_nulls_first_idx on flights (1 row)</code> </pre><br>  Masalah seperti ini tentu saja disebabkan oleh NULL yang tidak dapat disortir, yaitu, hasil perbandingan untuk NULL dan nilai lainnya tidak terdefinisi: <br><br><pre> <code class="pgsql hljs">demo=# \pset <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- NULL (1 row)</code> </pre><br>  Ini bertentangan dengan konsep B-tree dan tidak cocok dengan pola umum.  Namun, NULL memainkan peran penting dalam basis data sehingga kami selalu harus membuat pengecualian untuknya. <br><br>  Karena NULLs dapat diindeks, dimungkinkan untuk menggunakan indeks bahkan tanpa persyaratan apa pun yang dikenakan pada tabel (karena indeks berisi informasi tentang semua baris tabel pasti).  Ini mungkin masuk akal jika permintaan memerlukan pemesanan data dan indeks memastikan pesanan diperlukan.  Dalam hal ini, perencana lebih suka memilih akses indeks untuk menghemat penyortiran terpisah. <br><br><h2>  Properti </h2><br>  Mari kita lihat properti dari metode akses "btree" (pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah disediakan</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- btree | can_order | t btree | can_unique | t btree | can_multi_col | t btree | can_exclude | t</code> </pre><br>  Seperti yang telah kita lihat, B-tree dapat memesan data dan mendukung keunikan - dan ini adalah satu-satunya metode akses untuk memberi kami properti seperti ini.  Indeks multikolom juga diizinkan, tetapi metode akses lainnya (meskipun tidak semuanya) juga dapat mendukung indeks tersebut.  Kami akan membahas dukungan batasan EXCLUDE lain kali, dan bukan tanpa alasan. <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | t</code> </pre><br>  Metode akses "Btree" mendukung kedua teknik untuk mendapatkan nilai: pemindaian indeks, serta pemindaian bitmap.  Dan seperti yang bisa kita lihat, metode akses dapat berjalan melalui pohon baik "maju" dan "mundur". <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | t desc | f nulls_first | f nulls_last | t orderable | t distance_orderable | f returnable | t search_array | t search_nulls | t</code> </pre><br>  Empat properti pertama dari layer ini menjelaskan bagaimana tepatnya nilai-nilai kolom tertentu tertentu dipesan.  Dalam contoh ini, nilai diurutkan dalam urutan naik ("asc") dan NULL diberikan terakhir ("nulls_last").  Tetapi seperti yang telah kita lihat, kombinasi lain dimungkinkan. <br><br>  Properti "Search_array" menunjukkan dukungan ekspresi seperti ini oleh indeks: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aircraft_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'733'</span></span>,<span class="hljs-string"><span class="hljs-string">'763'</span></span>,<span class="hljs-string"><span class="hljs-string">'773'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_pkey on aircrafts Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[])) (2 rows)</code> </pre><br>  Properti "Dapat dikembalikan" menunjukkan dukungan pemindaian hanya indeks, yang masuk akal karena barisan indeks menyimpan sendiri nilai yang diindeks (misalnya, tidak seperti dalam indeks hash).  Di sini masuk akal untuk mengatakan beberapa kata tentang meliputi indeks berdasarkan B-tree. <br><br><h3>  Indeks unik dengan baris tambahan </h3><br>  Seperti yang kita bahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , indeks penutup adalah indeks yang menyimpan semua nilai yang diperlukan untuk kueri, akses ke tabel itu sendiri tidak diperlukan (hampir).  Indeks unik dapat secara spesifik mencakup. <br><br>  Tetapi mari kita asumsikan bahwa kita ingin menambahkan kolom tambahan yang diperlukan untuk kueri ke indeks unik.  Namun, keunikan dari nilai-nilai komposit tersebut tidak menjamin keunikan kunci, dan kemudian diperlukan dua indeks pada kolom yang sama: satu unik untuk mendukung kendala integritas dan satu lagi untuk digunakan sebagai penutup.  Ini tentu saja tidak efisien. <br><br>  Di perusahaan kami Anastasiya Lubennikova <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">lubennikovaav</a> meningkatkan metode "btree" sehingga kolom tambahan yang tidak unik dapat dimasukkan dalam indeks yang unik.  Kami berharap, tambalan ini akan diadopsi oleh komunitas untuk menjadi bagian dari PostgreSQL, tetapi ini tidak akan terjadi pada awal versi 10. Saat ini, tambalan ini tersedia dalam Pro Standard 9.5+, dan inilah yang terlihat seperti. <br><br><blockquote>  Sebenarnya tambalan ini dilakukan untuk PostgreSQL 11. <br></blockquote><br>  Mari kita perhatikan tabel pemesanan: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Dalam tabel ini, kunci utama (book_ref, kode pemesanan) disediakan oleh indeks "btree" biasa.  Mari kita buat indeks unik baru dengan kolom tambahan: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bookings(book_ref) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span> (book_date);</code> </pre><br>  Sekarang kami mengganti indeks yang ada dengan yang baru (dalam transaksi, untuk menerapkan semua perubahan secara bersamaan): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> bookings_pkey <span class="hljs-keyword"><span class="hljs-keyword">cascade</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> tickets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign key</span></span> (book_ref) <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> bookings (book_ref); demo=# <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>;</code> </pre><br>  Inilah yang kami dapatkan: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Sekarang satu dan indeks yang sama berfungsi sebagai unik dan berfungsi sebagai indeks penutup untuk permintaan ini, misalnya: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> book_ref, book_date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'059FC4'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Index Only Scan using bookings_pkey2 on bookings Index Cond: (book_ref = '059FC4'::bpchar) (2 rows)</code> </pre><br><h2>  Pembuatan indeks </h2><br>  Sudah terkenal, namun tidak kalah pentingnya, bahwa untuk tabel ukuran besar, lebih baik memuat data di sana tanpa indeks dan membuat indeks yang diperlukan nanti.  Ini tidak hanya lebih cepat, tetapi kemungkinan besar indeks akan memiliki ukuran lebih kecil. <br><br>  Masalahnya adalah bahwa penciptaan indeks "btree" menggunakan proses yang lebih efisien daripada penyisipan nilai-nilai baris ke pohon.  Secara kasar, semua data yang tersedia di tabel diurutkan, dan halaman daun dari data ini dibuat.  Kemudian halaman internal "dibangun di atas" basis ini sampai seluruh piramida menyatu ke root. <br><br>  Kecepatan proses ini tergantung pada ukuran RAM yang tersedia, yang dibatasi oleh parameter "maintenance_work_mem".  Jadi, meningkatkan nilai parameter dapat mempercepat proses.  Untuk indeks unik, memori ukuran "work_mem" dialokasikan di samping "maintenance_work_mem". <br><br><h3>  Semantik perbandingan </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali</a> kami menyebutkan bahwa PostgreSQL perlu tahu fungsi hash mana yang membutuhkan nilai dari tipe yang berbeda dan bahwa asosiasi ini disimpan dalam metode akses "hash".  Demikian juga, sistem harus mencari cara untuk memesan nilai.  Ini diperlukan untuk pengurutan, pengelompokan (kadang-kadang), gabung bergabung, dan sebagainya.  PostgreSQL tidak mengikat dirinya sendiri ke nama operator (seperti&gt;, &lt;, =) karena pengguna dapat menentukan tipe data mereka sendiri dan memberikan nama yang berbeda kepada operator yang sesuai.  Keluarga operator yang digunakan oleh metode akses "btree" mendefinisikan nama operator sebagai gantinya. <br><br>  Misalnya, operator perbandingan ini digunakan dalam keluarga operator "bool_ops": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'bool_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> amopstrategy;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator | amopstrategy ---------------------+-------------- &lt;(boolean,boolean) | 1 &lt;=(boolean,boolean) | 2 =(boolean,boolean) | 3 &gt;=(boolean,boolean) | 4 &gt;(boolean,boolean) | 5 (5 rows)</code> </pre><br>  Di sini kita dapat melihat lima operator pembanding, tetapi seperti yang telah disebutkan, kita tidak boleh mengandalkan nama mereka.  Untuk mengetahui perbandingan yang dilakukan masing-masing operator, konsep strategi diperkenalkan.  Lima strategi didefinisikan untuk menggambarkan semantik operator: <br><br><ul><li>  1 - kurang </li><li>  2 - kurang atau sama </li><li>  3 - sama </li><li>  4 - lebih besar atau sama </li><li>  5 - lebih besar </li></ul><br>  Beberapa keluarga operator dapat berisi beberapa operator yang menerapkan satu strategi.  Misalnya, keluarga operator "integer_ops" berisi operator berikut untuk strategi 1: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'integer_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopstrategy = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator ---------------------- &lt;(integer,bigint) &lt;(smallint,smallint) &lt;(integer,integer) &lt;(bigint,bigint) &lt;(bigint,integer) &lt;(smallint,integer) &lt;(integer,smallint) &lt;(smallint,bigint) &lt;(bigint,smallint) (9 rows)</code> </pre><br>  Berkat ini, pengoptimal dapat menghindari gips saat membandingkan nilai berbagai jenis yang terkandung dalam satu keluarga operator. <br><br><h3>  Dukungan indeks untuk tipe data baru </h3><br>  Dokumentasi menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> pembuatan tipe data baru untuk bilangan kompleks dan kelas operator untuk mengurutkan nilai tipe ini.  Contoh ini menggunakan bahasa C, yang benar-benar masuk akal ketika kecepatan sangat penting.  Tapi tidak ada yang menghalangi kita menggunakan SQL murni untuk percobaan yang sama hanya untuk mencoba dan lebih memahami semantik perbandingan. <br><br>  Mari kita buat tipe komposit baru dengan dua bidang: bagian nyata dan imajiner. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (re <span class="hljs-type"><span class="hljs-type">float</span></span>, im <span class="hljs-type"><span class="hljs-type">float</span></span>);</code> </pre><br>  Kita bisa membuat tabel dengan bidang tipe baru dan menambahkan beberapa nilai ke tabel: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> numbers(x complex); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ((<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">10.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre><br>  Sekarang muncul pertanyaan: bagaimana cara memesan bilangan kompleks jika tidak ada hubungan urutan didefinisikan untuk mereka dalam arti matematika? <br><br>  Ternyata, operator perbandingan sudah ditentukan untuk kami: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (0,10) (1,1) (1,3) (3 rows)</code> </pre><br>  Secara default, pengurutan adalah komponen untuk jenis komposit: bidang pertama dibandingkan, lalu bidang kedua, dan seterusnya, kira-kira sama dengan cara string teks dibandingkan karakter per karakter.  Tetapi kita dapat mendefinisikan urutan yang berbeda.  Sebagai contoh, bilangan kompleks dapat diperlakukan sebagai vektor dan dipesan oleh modulus (panjang), yang dihitung sebagai akar kuadrat dari jumlah kuadrat dari koordinat (teorema Pythagoras ').  Untuk mendefinisikan urutan seperti itu, mari kita buat fungsi bantu yang menghitung modulus: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> modulus(a complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> sqrt(a.re*a.re + a.im*a.im); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Sekarang kita akan secara sistematis menentukan fungsi untuk semua lima operator pembanding yang menggunakan fungsi bantu ini: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_lt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_le(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_eq(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) = modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_ge(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_gt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Dan kami akan membuat operator yang sesuai.  Untuk mengilustrasikan bahwa mereka tidak perlu dipanggil "&gt;", "&lt;", dan seterusnya, mari kita beri mereka nama "aneh". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #=#(leftarg=complex, rightarg=complex, procedure=complex_eq); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt);</code> </pre><br>  Pada titik ini, kita dapat membandingkan angka: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>)::complex #&lt;# (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>)::complex;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Selain lima operator, metode akses "btree" memerlukan satu fungsi lagi (berlebihan tetapi nyaman) untuk didefinisikan: harus mengembalikan -1, 0, atau 1 jika nilai pertama kurang dari, sama dengan, atau lebih besar dari yang kedua satu.  Fungsi bantu ini disebut dukungan.  Metode akses lain dapat memerlukan pendefinisian fungsi pendukung lainnya. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_cmp(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">case</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">-1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">else</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">end</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Sekarang kita siap untuk membuat kelas operator (dan keluarga operator dengan nama yang sama akan dibuat secara otomatis): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> complex_ops <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> btree <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> #&lt;#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> #&lt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> #=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> #&gt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> #&gt;#, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> complex_cmp(complex,complex);</code> </pre><br>  Sekarang penyortiran berfungsi seperti yang diinginkan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (1,1) (1,3) (0,10) (3 rows)</code> </pre><br>  Dan itu pasti akan didukung oleh indeks "btree". <br><br>  Untuk melengkapi gambar, Anda bisa mendapatkan fungsi dukungan menggunakan kueri ini: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amp.amprocnum, amp.amproc, amp.amproclefttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, amp.amprocrighttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opfamily opf, pg_am am, pg_amproc amp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'complex_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amp.amprocfamily = opf.oid;</code> </pre><pre> <code class="plaintext hljs"> amprocnum | amproc | amproclefttype | amprocrighttype -----------+-------------+----------------+----------------- 1 | complex_cmp | complex | complex (1 row)</code> </pre><br><h2>  Internal </h2><br>  Kita dapat menjelajahi struktur internal B-tree menggunakan ekstensi "pageinspect". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Indeks metapage: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_metap(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> magic | version | root | level | fastroot | fastlevel --------+---------+------+-------+----------+----------- 340322 | 2 | 164 | 2 | 164 | 2 (1 row)</code> </pre><br>  Yang paling menarik di sini adalah level indeks: indeks pada dua kolom untuk sebuah tabel dengan satu juta baris diperlukan hanya 2 level (tidak termasuk root). <br><br>  Informasi statistik pada blok 164 (root): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, live_items, dead_items, avg_item_size, page_size, free_size <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_stats(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>);</code> </pre><pre> <code class="plaintext hljs"> type | live_items | dead_items | avg_item_size | page_size | free_size ------+------------+------------+---------------+-----------+----------- r | 33 | 0 | 31 | 8192 | 6984 (1 row)</code> </pre><br>  Dan data di blok (bidang "data", yang di sini dikorbankan untuk lebar layar, berisi nilai kunci pengindeksan dalam representasi biner): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> itemoffset, ctid, itemlen, left(data,<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid | itemlen | data ------------+---------+---------+---------------------------------------------------------- 1 | (3,1) | 8 | 2 | (163,1) | 32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00 3 | (323,1) | 32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00 4 | (482,1) | 32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00 5 | (641,1) | 32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00 (5 rows)</code> </pre><br>  Elemen pertama berkaitan dengan teknik dan menentukan batas atas semua elemen dalam blok (detail implementasi yang tidak kami diskusikan), sedangkan data itu sendiri dimulai dengan elemen kedua.  Jelas bahwa simpul anak paling kiri adalah blok 163, diikuti oleh blok 323, dan seterusnya.  Mereka, pada gilirannya, dapat dieksplorasi menggunakan fungsi yang sama. <br><br>  Sekarang, mengikuti tradisi yang baik, masuk akal untuk membaca dokumentasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">README</a> , dan kode sumber. <br><br>  Namun satu ekstensi yang berpotensi lebih bermanfaat adalah " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">amcheck</a> ", yang akan dimasukkan dalam PostgreSQL 10, dan untuk versi yang lebih rendah Anda bisa mendapatkannya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> .  Ekstensi ini memeriksa konsistensi logis dari data dalam B-tree dan memungkinkan kami untuk mendeteksi kesalahan sebelumnya. <br><blockquote>  Itu benar, "amcheck" adalah bagian dari PostgreSQL mulai dari versi 10. <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443284/">https://habr.com/ru/post/id443284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443274/index.html">Kompilasi berita industri game dari 8 Maret hingga Minggu</a></li>
<li><a href="../id443276/index.html">Penjadwal Permintaan Kejutan di Database PostgreSQL</a></li>
<li><a href="../id443278/index.html">Coinbase crypto-exchange kehilangan pengguna karena pembelian startup untuk pembuat spyware dari Tim Peretasan</a></li>
<li><a href="../id443280/index.html">Kisah bagaimana saya merakit home theater 120 inci dari pipa, tali, layar lipat dan beludru hitam</a></li>
<li><a href="../id443282/index.html">Apa yang harus kita bangun dengan blockchain?</a></li>
<li><a href="../id443286/index.html">TDMS Fairway. Mekanisme pengisian otomatis untuk prasasti utama pada gambar dan detail dokumen</a></li>
<li><a href="../id443290/index.html">Zen Erlang [dan Elixir - sekitar. penerjemah]</a></li>
<li><a href="../id443294/index.html">Apa yang diizinkan oleh Jupyter?</a></li>
<li><a href="../id443298/index.html">Pengisian nirkabel. Bagaimana cara kerjanya dalam praktik</a></li>
<li><a href="../id443300/index.html">Bagaimana perkembangannya di United Traders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>