<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏿 🐢 🧖🏻 Suchen Sie nach ähnlichen Vorfällen und Ansprüchen. Metriken und Optimierung 👨🏼‍💼 💍 🙌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel habe ich über unsere Suchmaschine für ähnliche Anwendungen gesprochen . Nach dem Start erhielten wir die ersten Bewertungen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suchen Sie nach ähnlichen Vorfällen und Ansprüchen. Metriken und Optimierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472772/"><p>  In einem früheren Artikel habe ich über unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchmaschine für ähnliche Anwendungen gesprochen</a> .  Nach dem Start erhielten wir die ersten Bewertungen.  Analysten mochten und empfahlen einige Empfehlungen, andere nicht. </p><br><p>  Um weiterzumachen und bessere Modelle zu finden, musste zunächst die Leistung des aktuellen Modells bewertet werden.  Es war auch notwendig, Kriterien auszuwählen, anhand derer die beiden Modelle miteinander verglichen werden konnten. </p><br><p>  Unter dem Schnitt werde ich sprechen über: </p><br><ul><li>  Feedback zu Empfehlungen sammeln </li><li>  Entwicklung von Metriken zur Bewertung der Qualität von Empfehlungen </li><li>  Erstellen eines Modelloptimierungszyklus </li><li>  erhielt Einblicke und ein neues Modell </li></ul><a name="habracut"></a><br><h2 id="sbor-otzyvov">  Feedback-Sammlung </h2><br><p>  Es wäre ideal, explizites Feedback von Analysten einzuholen: Wie relevant ist die Empfehlung für jeden der vorgeschlagenen Vorfälle?  Auf diese Weise können wir die aktuelle Situation verstehen und das System auf der Grundlage quantitativer Indikatoren weiter verbessern. </p><br><p>  Es wurde beschlossen, Bewertungen in einem äußerst einfachen Format zu sammeln: </p><br><ul><li>  Anzahl der Vorfälle, die wir analysieren </li><li>  empfohlene Vorfallsnummer </li><li>  Empfehlungsbewertung: gut / schlecht </li></ul><br><p>  Die "Abstimmung" (ein kleines Projekt, das GET-Anfragen mit Parametern akzeptierte und die Informationen in eine Datei legte) wurde direkt in den Empfehlungsblock eingefügt, sodass Analysten ihr Feedback sofort hinterlassen können, indem sie einfach auf einen der Links klicken: "gut" oder "schlecht". </p><br><p>  Zusätzlich wurde für eine nachträgliche Überprüfung der Empfehlung eine sehr einfache Lösung gefunden: </p><br><ul><li>  Für einen großen Teil der historischen Daten wurde ein Modell gestartet. </li><li>  Die gesammelten Empfehlungen wurden in Form mehrerer eigenständiger HTML-Dateien präsentiert, in denen dieselbe "Abstimmung" verwendet wurde. </li><li>  Die vorbereiteten Dateien wurden den Analysten ausgehändigt, um die Ergebnisse für 50 bis 100 Vorfälle anzuzeigen. </li></ul><br><p>  So war es möglich, Daten zu über 4000 Paaren von Vorfallempfehlungen zu sammeln. </p><br><h2 id="pervichnyy-analiz-otzyvov">  Erste Überprüfungsanalyse </h2><br><p>  Die anfänglichen Kennzahlen waren „so lala“ - der Anteil der „guten“ Empfehlungen betrug laut Kollegen nur etwa 25%. </p><br><p>  Die Hauptprobleme des ersten Modells: </p><br><ol><li>  Vorfälle mit „neuen“ Problemen erhielten irrelevante Empfehlungen vom System.  Es stellte sich heraus, dass das System mangels Übereinstimmungen im Inhalt der Beschwerde Vorfälle in der Nähe der Abteilung des kontaktierenden Mitarbeiters auswählte. </li><li>  Empfehlungen für einen Vorfall auf einem System treffen Vorfälle auf anderen Systemen.  Die in der Berufung verwendeten Wörter waren ähnlich, beschrieben jedoch die Probleme anderer Systeme und waren unterschiedlich. </li></ol><br><p>  Mögliche Möglichkeiten zur Verbesserung der Qualität der Empfehlungen wurden ausgewählt: </p><br><ul><li>  Anpassung der Zusammensetzung und des Gewichts der Behandlungsattribute, die im endgültigen Vektor enthalten sind </li><li> Auswahl der Vektorisierungseinstellungen <code>TfidfVectorizer</code> </li><li>  Auswahl des "Grenzabstands" der Empfehlungen </li></ul><br><h2 id="vyrabotka-kriteriev-kachestva-i-metodiki-ocenki">  Entwicklung von Qualitätskriterien und Bewertungsmethoden </h2><br><p>  Um nach einer verbesserten Version des Modells zu suchen, muss das Prinzip der Bewertung der Qualität der Modellergebnisse festgelegt werden.  Auf diese Weise können Sie zwei Modelle quantitativ vergleichen und das beste auswählen. </p><br><h3 id="chto-mozhno-poluchit-iz-sobrannyh-otzyvov">  Was kann aus den gesammelten Bewertungen erhalten werden </h3><br><p>  Wir haben viele Tupel der Form: "Vorfall", "Empfohlener Vorfall", "Bewertung der Empfehlung". </p><br><ul><li>  "Empfehlungsbewertung" ( <strong>v</strong> ) - wird binär gesetzt: "Gut" |  Schlecht (1 / -1); </li><li>  "Incident" und "Recommended Incident" sind einfach Incident-Nummern.  Auf ihnen finden Sie den Vorfall in der Datenbank. </li></ul><br><p>  Mit solchen Daten können Sie berechnen: </p><br><ul><li>  <code>n_inc_total</code> - Die Gesamtzahl der Vorfälle, für die Empfehlungen <code>n_inc_total</code> </li><li>  <code>n_inc_good</code> - Die Anzahl der Vorfälle, für die es „gute“ Empfehlungen gibt </li><li>  <code>avg_inc_good</code> - Die durchschnittliche Anzahl „guter“ Empfehlungen für Vorfälle </li><li>  <code>n_rec_total</code> - Gesamtzahl der Empfehlungen </li><li>  <code>n_rec_good</code> - Die Gesamtzahl der "guten" Empfehlungen </li><li>  <code>pct_inc_good</code> - Anteil der Vorfälle, für die es „gute“ Empfehlungen gibt <br> <code>pct_inc_good = n_inc_good / n_inc_total</code> </li> <li>  <code>pct_rec_good</code> - Gesamtanteil der "guten" Empfehlungen <br> <code>pct_rec_good = n_rec_good / n_rec_total</code> </li> </ul><br><p>  Diese Indikatoren, die auf der Grundlage von Schätzungen der Benutzer berechnet werden, können als „Basisindikatoren“ des ursprünglichen Modells betrachtet werden.  Damit werden wir ähnliche Indikatoren für neue Versionen des Modells vergleichen. </p><br><p>  Nehmen Sie alle einzigartigen "Vorfälle" von <strong>m</strong> und fahren Sie sie durch das neue Modell. </p><br><p>  Als Ergebnis erhalten wir viele <strong>m *</strong> Tupel: "Incident", "Recommended Incident", "Distance". <br>  Hier ist "Entfernung" die in NearestNeighbor definierte Metrik.  In unserem Modell ist dies der Kosinusabstand.  Der Wert "0" entspricht der vollständigen Übereinstimmung von Vektoren. </p><br><h3 id="podbor-rasstoyaniya-otsechki">  Auswahl des "Grenzabstands" </h3><br><p>  Wenn wir den Satz von Empfehlungen <strong>m * mit</strong> Informationen über die wahre Schätzung von <strong>v</strong> aus dem anfänglichen Satz von Schätzungen von <strong>m</strong> ergänzen, erhalten wir die Entsprechung zwischen dem Abstand <strong>d</strong> und der wahren Schätzung von <strong>v</strong> für dieses Modell. </p><br><p>  Mit der Menge ( <strong>d</strong> , <strong>v</strong> ) ist es möglich, den optimalen Grenzwert <strong>t</strong> zu wählen, der für d &lt;= t die Empfehlung "gut" und für d&gt; t - "schlecht" ist.  Die Auswahl von t kann erreicht werden, indem der einfachste binäre Klassifikator <code>v = -1 if d&gt;t else 1</code> optimiert wird, <code>v = -1 if d&gt;t else 1</code> Bezug auf den Hyperparameter t ist, und beispielsweise AUC ROC als Metrik verwendet wird. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     class BinarizerClassifier(Binarizer): def transform(self, x): return np.array([-1 if _x &gt; self.threshold else 1 for _x in np.array(x, dtype=float)]).reshape(-1, 1) def predict_proba(self, x): z = self.transform(x) return np.array([[0 if _x &gt; 0 else 1, 1 if _x &gt; 0 else 0] for _x in z.ravel()]) def predict(self, x): return self.transform(x) # #   : # -  , # -    m* # -   (d,v)  z_data_for_t # #   t b = BinarizerClassifier() z_x = z_data_for_t[['distance']] z_y = z_data_for_t['TYPE'] cv = GridSearchCV(b, param_grid={'threshold': np.arange(0.1, 0.7, 0.01)}, scoring='roc_auc', cv=5, iid=False, n_jobs=-1) cv.fit(z_x, z_y) score = cv.best_score_ t = cv.best_params_['threshold'] best_b = cv.best_estimator_</span></span></code> </pre> <br><p>  Der erhaltene <strong>t-</strong> Wert kann zum Filtern von Empfehlungen verwendet werden. </p><br><p>  Natürlich kann dieser Ansatz immer noch die "schlechten" Empfehlungen überspringen und die "guten" abschneiden.  Daher zeigen wir zu diesem Zeitpunkt immer die "Top 5" -Empfehlungen an, markieren jedoch speziell diejenigen, die als "gut" gelten, unter Berücksichtigung des gefundenen <strong>t</strong> . <br>  Alternative: Wenn mindestens eine „gute“ Empfehlung gefunden wird, wird nur „gut“ angezeigt.  Andernfalls zeigen Sie alle verfügbaren an (auch - "Top N"). </p><br><h3 id="predpolozhenie-dlya-sravneniya-modeley">  Annahme zum Modellvergleich </h3><br><p>  Für Trainingsmodelle wird der gleiche Vorfallfall verwendet. <br>  Angenommen, wenn zuvor eine „gute“ Empfehlung gefunden wurde, sollte das neue Modell auch eine „gute“ Empfehlung für denselben Vorfall finden.  Insbesondere kann das neue Modell die gleichen „guten“ Empfehlungen finden wie das alte.  Mit dem neuen Modell erwarten wir jedoch, dass die Anzahl der "schlechten" Empfehlungen geringer wird. </p><br><p>  Unter Berücksichtigung der gleichen Indikatoren für die Empfehlungen <strong>m * des</strong> neuen Modells können sie dann mit den entsprechenden Indikatoren für <strong>m</strong> verglichen werden.  Basierend auf dem Vergleich können Sie das beste Modell auswählen. </p><br><p>  Es gibt zwei Möglichkeiten, die „guten“ Empfehlungen für die Menge <strong>m *</strong> zu berücksichtigen: </p><br><ol><li>  basierend auf dem gefundenen <strong>t</strong> : Betrachten Sie, dass alle Empfehlungen von <strong>m *</strong> mit <strong>d</strong> &lt; <strong>t</strong> „gut“ sind, und berücksichtigen Sie sie bei der Berechnung der Metriken </li><li>  Wählen Sie auf der Grundlage der entsprechenden wahren Schätzungen aus der Menge <strong>m</strong> : Wählen Sie aus den Empfehlungen <strong>m *</strong> nur diejenigen aus, für die es eine wahre Schätzung in <strong>m gibt</strong> , und verwerfen Sie den Rest. </li></ol><br><p>  Im ersten Fall sollten die "absoluten" Indikatoren ( <code>n_inc_good</code> , <code>n_rec_good</code> ) des neuen Modells größer sein als für das Basismodell.  Im zweiten Fall sollten sich die Indikatoren den Indikatoren des Basismodells nähern. <br>  Das Problem der zweiten Methode: Wenn das neue Modell besser als das ursprüngliche ist und etwas bisher Unbekanntes findet, wird eine solche Empfehlung bei der Berechnung nicht berücksichtigt. </p><br><h3 id="vybor-parametrov-sravneniya-modeley">  Wählen Sie Modellvergleichsoptionen </h3><br><p>  Bei der Auswahl eines neuen Modells möchte ich, dass sich die Indikatoren im Vergleich zum vorhandenen Modell verbessern: </p><br><ul><li>  durchschnittliche Anzahl „guter“ Empfehlungen pro Vorfall ( <code>avg_inc_good</code> ) </li><li>  Anzahl der Vorfälle, für die es „gute“ Empfehlungen gibt ( <code>n_inc_good</code> ). </li></ul><br><p>  Zum Vergleich mit dem ursprünglichen Modell werden wir die Beziehungen dieser Parameter des neuen Modells und des Originals verwenden.  Wenn also das Verhältnis des Parameters des neuen Modells zum alten mehr als 1 beträgt, ist das neue Modell besser. </p><br><pre> <code class="plaintext hljs">benchmark_agv_inc_good = avg_inc_good* / avg_inc_good benchmark_n_inc_good = n_inc_good* / n_inc_good</code> </pre> <br><p>  Um die Auswahl zu vereinfachen, ist es besser, einen einzelnen Parameter zu verwenden.  Wir nehmen das harmonische Mittel einzelner relativer Indikatoren und verwenden es als einziges zusammengesetztes Qualitätskriterium für das neue Modell. </p><br><pre> <code class="plaintext hljs">composite = 2 / ( 1/benchmark_agv_inc_good + 1/benchmark_n_inc_good)</code> </pre> <br><h2 id="novaya-model-i-ee-optimizaciya">  Neues Modell und seine Optimierung </h2><br><p>  Fügen Sie für das neue Modell im endgültigen Vektor, der den Vorfall darstellt, die Komponenten hinzu, die für den "Vorfallbereich" verantwortlich sind (eines von mehreren Systemen, die von unserem Team gewartet werden). <br>  Informationen über die Einheit und den Standort des Mitarbeiters, der den Vorfall erstellt hat, werden ebenfalls in einer separaten Vektorkomponente abgelegt.  Alle Komponenten haben ihr Gewicht im endgültigen Vektor. </p><br><pre> <code class="python hljs">p = Pipeline( steps=[ (<span class="hljs-string"><span class="hljs-string">'grp'</span></span>, ColumnTransformer( transformers=[ (<span class="hljs-string"><span class="hljs-string">'text'</span></span>, Pipeline(steps=[ (<span class="hljs-string"><span class="hljs-string">'pp'</span></span>, CommentsTextTransformer(n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>)), (<span class="hljs-string"><span class="hljs-string">"tfidf"</span></span>, TfidfVectorizer(stop_words=get_stop_words(), ngram_range=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), max_features=<span class="hljs-number"><span class="hljs-number">10000</span></span>, min_df=<span class="hljs-number"><span class="hljs-number">0</span></span>)) ]), [<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, <span class="hljs-string"><span class="hljs-string">'comments'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'area'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'area'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'dept'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_department'</span></span>] ), (<span class="hljs-string"><span class="hljs-string">'loc'</span></span>, OneHotEncoder(handle_unknown=<span class="hljs-string"><span class="hljs-string">'ignore'</span></span>), [<span class="hljs-string"><span class="hljs-string">'u_impacted_location'</span></span>] ) ], transformer_weights={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span> )), (<span class="hljs-string"><span class="hljs-string">'norm'</span></span>, Normalizer()), (<span class="hljs-string"><span class="hljs-string">"nn"</span></span>, NearestNeighborsTransformer(n_neighbors=<span class="hljs-number"><span class="hljs-number">10</span></span>, metric=<span class="hljs-string"><span class="hljs-string">'cosine'</span></span>)) ], memory=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Es wird erwartet, dass Modellhyperparameter Modellziele beeinflussen.  In der ausgewählten Modellarchitektur werden wir als Hyperparameter betrachten: </p><br><ul><li>  TF-IDF-Vektorisierungsparameter - verwendete n-Gramm (ngram_range), Wörterbuchgröße (max_features), Mindestlaufzeit (min_df) </li><li>  Komponentenbeitrag zum endgültigen Vektor - Transformatorgewichte. </li></ul><br><p>  Die Anfangswerte der Textvektorisierungs-Hyperparameter stammen aus dem vorherigen Modell.  Die anfänglichen Komponentengewichte werden basierend auf Expertenurteilen ausgewählt. </p><br><h3 id="cikl-podbora-parametrov">  Parameterauswahlzyklus </h3><br><p>  Wie man vergleicht, die Fehlzündungsstufe auswählt und Modelle untereinander vergleicht, wurde bereits ermittelt.  Jetzt können wir mit der Optimierung durch Auswahl der Hyperparameter fortfahren. </p><br><p><img src="https://habrastorage.org/webt/zy/zy/kb/zyzykbygrls9ca0bjscn3usfqby.png" alt="Optimierungszyklus"></p><br><pre> <code class="python hljs">param_grid = { <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__ngram_range'</span></span>: [(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__max_features'</span></span>: [<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__text__tfidf__min_df'</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>, <span class="hljs-number"><span class="hljs-number">0.0005</span></span>, <span class="hljs-number"><span class="hljs-number">0.001</span></span>], <span class="hljs-string"><span class="hljs-string">'grp__transformer_weights'</span></span>: [{<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'text'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'dept'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">'loc'</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span>}], } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ParameterGrid(param_grid=param_grid): p.set_params(**param) p.fit(x) ...</code> </pre> <br><h3 id="rezultaty-optimizacii">  Optimierungsergebnisse </h3><br><p>  Die Tabelle zeigt die Ergebnisse von Experimenten, bei denen interessante Ergebnisse erzielt wurden - Top 5 der besten und schlechtesten Werte für kontrollierte Indikatoren. </p><br><p><img src="https://habrastorage.org/webt/bi/l2/tj/bil2tj8dbqexqtezwmxealh3imq.png"></p><br><p>  Die Zellen mit Indikatoren in der Tabelle sind gekennzeichnet als: </p><br><ul><li>  Dunkelgrün ist der beste Indikator unter allen Experimenten </li><li>  hellgrün - Indikatorwert ist in den Top-5 </li><li>  dunkelrot - der schlechteste Indikator unter allen Experimenten </li><li>  blassrot - der Indikator ist in der schlechtesten 5 </li></ul><br><p>  Der beste zusammengesetzte Indikator wurde für ein Modell mit Parametern erhalten: </p><br><pre> <code class="plaintext hljs">ngram_range = (1,2) min_df = 0.0001 max_features = 20000 transformer_weights = {'text': 1, 'area': 1, 'dept': 0.1, 'loc': 0.1}</code> </pre> <br><p>  Ein Modell mit diesen Parametern zeigte eine Verbesserung des zusammengesetzten Indikators im Vergleich zum ursprünglichen Modell um 24%. </p><br><h2 id="nekotorye-nablyudeniya-i-vyvody">  Einige Beobachtungen und Schlussfolgerungen </h2><br><p>  Nach den Optimierungsergebnissen: </p><br><ol><li><p>  Die Verwendung von Trigrammen ( <code>ngram_range = (1,3)</code> ) scheint nicht gerechtfertigt zu sein.  Sie blasen das Wörterbuch auf und erhöhen die Genauigkeit im Vergleich zu Bigrams geringfügig. </p><br></li><li><p>  Ein interessantes Verhalten beim <code>ngram_range = (2,2)</code> eines Wörterbuchs mit nur <code>ngram_range = (2,2)</code> ( <code>ngram_range = (2,2)</code> ): Die "Genauigkeit" von Empfehlungen nimmt zu und die Anzahl der gefundenen Empfehlungen nimmt ab.  Genau wie eine Präzisions- / Rückrufbalance in Klassifikatoren.  Ein ähnliches Verhalten wird bei der Auswahl des Grenzwerts <strong>t beobachtet</strong> - für die Bigramme sind ein engerer Grenzkegel und eine bessere Trennung von „guten“ und „schlechten“ Empfehlungen charakteristisch. </p><br></li><li><p>  Der Parameter min_df ungleich Null erhöht zusammen mit Bigrams die Genauigkeit der Empfehlungen.  Sie basieren auf Begriffen, die mindestens mehrmals vorkommen.  Wenn der Parameter zunimmt, beginnt das Wörterbuch schnell zu schrumpfen.  Bei kleinen Stichproben wie in unserem Fall ist es wahrscheinlich verständlicher, mit der Anzahl der Dokumente (ganzzahliger Wert min_df) zu arbeiten als mit dem Bruchteil der Dokumente (Bruchwert min_df), der den Begriff enthält. </p><br></li><li><p>  Gute Ergebnisse werden erzielt, wenn das für die "Region" verantwortliche Ereignisattribut im endgültigen Vektor mit einer Gewichtung enthalten ist, die der Textkomponente entspricht oder dieser nahe kommt.  Niedrige Werte führen zu einem Anstieg des Anteils "schlechter" Empfehlungen, da ähnliche Wörter in Dokumenten aus anderen Bereichen gefunden werden.  Die Anzeichen für den Standort des Kunden wirken sich in unserem Fall jedoch nicht so gut auf die Ergebnisse der Empfehlungen aus. </p><br></li></ol><br><p>  Einige neue Ideen sind aufgetaucht: </p><br><ul><li>  Fügen Sie eine Zeitkomponente hinzu, damit kürzlich aufgetretene Vorfälle Vorrang vor ähnlichen Vorfällen haben. </li><li>  Sehen Sie, wie sich die Einführung des Parameters max_df auswirkt - obwohl bei tf-idf zu allgemeine Wörter für den Korpus per Definition kein signifikantes Gewicht haben sollten. </li><li>  Versuchen Sie schließlich andere Möglichkeiten zur Vektorisierung von Inhalten, z. B. basierend auf Wort-zu-Vektor oder basierend auf der Faltung von tf-idf-Ansichten mithilfe von Netzwerken. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472772/">https://habr.com/ru/post/de472772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472760/index.html">Reduzieren Sie die Rechenzeit von einigen Jahren auf Minuten. Quantenmaschinelles Lernen verstehen</a></li>
<li><a href="../de472762/index.html">Technische Analyse des checkm8-Exploits</a></li>
<li><a href="../de472766/index.html">Parametrierung aus Datei in py.test</a></li>
<li><a href="../de472768/index.html">So stellen Sie ein, entlassen und kehren vom Management zur Entwicklung zurück: Video von Badoo Techleads Meetup # 5</a></li>
<li><a href="../de472770/index.html">Schnittstellenorganisation in Unity mit UI Canvas</a></li>
<li><a href="../de472776/index.html">Backup Teil 7: Schlussfolgerungen</a></li>
<li><a href="../de472778/index.html">5 Möglichkeiten, den Raspberry Pi zu verwenden</a></li>
<li><a href="../de472780/index.html">Warum Freunde meiden oder wie ich alle meine Vorteile verloren habe?</a></li>
<li><a href="../de472782/index.html">Warum 3D-Kopfschmerzen / Teil 8 Defokussierung und die Zukunft von 3D</a></li>
<li><a href="../de472790/index.html">Antiquitäten: i-Mate Jasjar, ein Kommunikator für Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>