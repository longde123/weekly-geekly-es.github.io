<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ∑Ô∏è üåπ ‚≠ïÔ∏è Membuat plugin untuk Clang Static Analyzer untuk mencari bilangan bulat bilangan bulat üòÆ üõåüèº üöÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis Artikel: 0x64rem 
 Entri 


 Setahun setengah yang lalu, saya memiliki ide untuk mewujudkan phaser saya sebagai bagian dari tesis di universit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat plugin untuk Clang Static Analyzer untuk mencari bilangan bulat bilangan bulat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/473412/"><p><img src="https://habrastorage.org/getpro/habr/post_images/e69/d01/efb/e69d01efbeff395f19dbb543055a5493.jpg" title="gbr. 1"></p><br><p>  <em>Penulis Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">0x64rem</a></em> </p><br><h2 id="vstuplenie">  Entri </h2><br><p>  Setahun setengah yang lalu, saya memiliki ide untuk mewujudkan phaser saya sebagai bagian dari tesis di universitas.  Saya mulai mempelajari materi tentang grafik aliran kontrol, grafik aliran data, eksekusi simbolis, dll.  Selanjutnya datang pencarian alat, contoh perpustakaan yang berbeda (Angr, Triton, Pin, Z3).  Tidak ada yang konkrit terjadi pada akhirnya, sampai musim panas ini saya pergi ke program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Digital Security</a> 's Summer of Hack 2019, di mana saya ditawari perpanjangan Clang Static Analyzer sebagai tema untuk proyek tersebut.  Tampaknya bagi saya bahwa topik ini akan membantu saya meletakkan pengetahuan teoretis saya di rak, mulai menerapkan sesuatu yang substansial dan mendapatkan rekomendasi dari mentor yang berpengalaman.  Selanjutnya, saya akan memberi tahu Anda bagaimana proses penulisan plug-in berjalan dan menjelaskan jalan pikiran saya selama bulan magang. </p><a name="habracut"></a><br><h2 id="clang-static-analyzer">  Bunyi analisa statis </h2><br><p>  Untuk pengembangan, Clang menyediakan tiga opsi antarmuka untuk interaksi: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LibClang</a> adalah antarmuka C tingkat tinggi yang memungkinkan Anda berinteraksi dengan AST, tetapi tidak sepenuhnya.  Pilihan yang baik jika Anda memerlukan interaksi dengan bahasa lain (misalnya, implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">binding</a> ) atau antarmuka yang stabil. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dentang Plugin</a> - perpustakaan dinamis dipanggil pada waktu kompilasi.  Memungkinkan Anda memanipulasi AST sepenuhnya. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LibTooling</a> - perpustakaan untuk membuat alat terpisah berdasarkan Dentang.  Juga memberikan akses penuh untuk berinteraksi dengan AST.  Kode yang dihasilkan dapat dijalankan di luar lingkungan build dari proyek yang diperiksa. </li></ul><br><p>  Karena kami akan memperluas kemampuan Clang Static Analyzer, kami memilih implementasi plugin.  Anda dapat menulis kode untuk plugin dalam C ++ atau Python. </p><br><p>  Untuk yang terakhir, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengikat</a> yang memungkinkan Anda untuk mem-parsing kode sumber, beralih di atas simpul dari pohon sintaksis abstrak yang dihasilkan, juga memiliki akses ke properti dari node dan dapat memetakan node ke garis kode sumber.  Set seperti itu cocok untuk pemeriksa sederhana.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori llvm untuk</a> lebih jelasnya. </p><br><p>  Tugas saya memerlukan analisis rinci kode, sehingga C ++ dipilih untuk pengembangan.  Berikutnya adalah pengantar alat. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clang Staic Analyzer</a> (selanjutnya disebut CSA) adalah alat untuk analisis statis kode C / C ++ / Objective-C, berdasarkan pada eksekusi simbolik.  Analyzer dapat dipanggil melalui frontend Dentang dengan menambahkan flag -cc1 dan -analyze ke perintah build, atau melalui binar scan-build yang terpisah.  Selain analisis itu sendiri, CSA memungkinkan untuk menghasilkan laporan html visual. </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,      clang' clang -cc1 --help #  CSA  ‚Ññ1 clang++ -cc1 -x c++ -load path/to/Checker.so -analyze -analyzer-checker=test.Me -analyzer-config $BUILD_OPTIONS Checker.cpp</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#  CSA  ‚Ññ2 scan-build -load-plugin path/to/Checker.so -enable-checker test.Me $BUILD_COMMAND</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#       DivideZero clang++ -cc1 -analyze -analyzer-checker=core.DivideZero -o reports div-by-zero-test.cpp</span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/6dd/b8e/302/6ddb8e302c62b6cc58c4533a894d49e9.jpg" alt=" " title="gbr. 2"></p><br><p>  CSA memiliki pustaka yang sangat baik untuk parsing kode sumber menggunakan AST (Abstract Syntax Tree), CFG (Control Flow Graph).  Dari struktur Anda dapat melihat lebih lanjut deklarasi variabel, jenisnya, penggunaan operator biner dan unary, Anda bisa mendapatkan ekspresi simbolik, dll.  Plugin saya akan menggunakan fungsionalitas kelas AST, pilihan ini akan dibenarkan lebih lanjut.  Berikut ini adalah daftar kelas yang digunakan dalam implementasi plugin, daftar ini akan membantu untuk mendapatkan pemahaman utama tentang fitur CSA: </p><br><ul><li><p>  Stmt - ini termasuk operasi biner. </p><br></li><li><p>  Deklarasi - deklarasi variabel. </p><br></li><li><p>  Expr - menyimpan bagian kiri, kanan ekspresi, tipenya. </p><br></li><li><p>  ASTContext - informasi tentang pohon, simpul saat ini. </p><br></li><li><p>  Manajer sumber - informasi tentang kode aktual yang sesuai dengan bagian pohon. </p><br></li><li><p>  RecursiveASTVisitor, ASTMatcher - kelas untuk melintasi pohon. </p><br><p>  Saya ulangi bahwa CSA memberi pengembang kesempatan untuk memeriksa secara terperinci struktur kode, dan kelas yang tercantum di atas hanya sebagian kecil dari yang tersedia.  Saya merekomendasikan untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> versi Dentang Anda jika Anda tidak tahu cara mengekstrak data apa pun;  kemungkinan besar, sesuatu yang cocok telah ditulis. </p><br></li></ul><br><h2 id="poisk-celochislennyh-perepolneniy">  Pencarian Overflow Integer </h2><br><p>  Untuk mulai mengimplementasikan plugin, Anda harus memilih tugas yang akan diselesaikan.  Untuk kasus ini, situs web llvm menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar pemeriksa potensial</a> , Anda juga dapat memodifikasi pemeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alpha</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stabil</a> .  Selama peninjauan kode checker yang tersedia, menjadi jelas bahwa untuk pengembangan libclang yang lebih sukses, lebih baik menulis checker Anda dari awal, jadi pilihan dibuat dari daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ide yang belum direalisasi</a> .  Akibatnya, opsi dipilih untuk membuat checker untuk deteksi overflow integer.  Dentang sudah memiliki fungsi untuk mencegah kerentanan ini (flag -ftrapv, -fwrapv dan sejenisnya ditunjukkan untuk penggunaannya), itu dibangun ke dalam kompiler, dan knalpot seperti itu dituangkan ke dalam peringatan, dan tidak sering terlihat di sana.  Masih ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UBSan</a> , tetapi ini adalah pembersih, tidak semua orang menggunakannya, dan metode ini adalah tentang mengidentifikasi masalah saat runtime, dan plug-in CSA bekerja pada waktu kompilasi, menganalisis sumber. </p><br><p>  Berikutnya adalah kumpulan materi tentang kerentanan yang dipilih.  Integer overflow digunakan untuk sesuatu yang sederhana dan tidak serius.  Faktanya, kerentanan itu menghibur dan dapat memiliki konsekuensi yang mengesankan. <br>  Integer overflows adalah jenis kerentanan yang dapat menghasilkan data tipe integer dalam kode yang mengambil nilai yang tidak diharapkan.  Overflow - jika variabel menjadi lebih besar dari yang dimaksudkan, Underflow - kurang dari tipe aslinya.  Kesalahan tersebut dapat muncul baik karena programmer, dan karena kompiler. </p><br><p>  Dalam C ++, selama operasi perbandingan aritmatika, nilai integer dilemparkan ke tipe yang sama, lebih sering ke yang lebih besar dalam hal kedalaman bit.  Dan hantu seperti itu terjadi di mana-mana dan terus-menerus, mereka bisa eksplisit atau implisit.  Ada beberapa aturan dimana hantu terjadi [1]: </p><br><ul><li>  Mengonversi dari yang sudah ditandatangani ke jenis dengan yang sudah ditandatangani, tetapi lebih besar: cukup tambahkan pesanan tinggi. </li><li>  Mengonversi bilangan bulat yang ditandatangani menjadi bilangan bulat yang tidak ditandatangani dengan kapasitas yang sama: negatif dikonversi menjadi positif dan mengambil makna baru.  Contoh kesalahan serupa di DirectFB adalah <a href="">CVE-2014-2977</a> . </li><li>  Mengonversi bilangan bulat yang ditandatangani menjadi bilangan bulat tak bertanda dari kapasitas bit yang lebih besar: pertama, kapasitas bit akan berkembang, kemudian jika jumlahnya negatif, maka akan salah mengubah nilainya.  Misalnya: 0xff (-1) menjadi 0xffffffff. </li><li>  Integer unsigned dengan tanda kapasitas bit yang sama: angka dapat mengubah nilainya, tergantung pada nilai bit tinggi. </li><li>  Integer yang tidak ditandatangani dengan integer dengan tanda kapasitas yang lebih besar: pertama, kapasitas nomor yang tidak ditandatangani meningkat, kemudian konversi ke yang ditandatangani. </li><li>  Turun konversi: bit hanya terpotong.  Ini dapat membuat nilai yang tidak ditandatangani negatif dan seterusnya.  Contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerentanan</a> seperti itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di PHP</a> . </li></ul><br><p>  Yaitu  pemicu untuk kerentanan dapat berupa input pengguna yang tidak aman, aritmatika salah, konversi tipe yang salah yang disebabkan oleh programmer atau kompiler selama optimasi.  Opsi bom waktu juga dimungkinkan, ketika sepotong kode tidak berbahaya dengan satu versi kompiler, tetapi dengan dirilisnya algoritma optimasi baru "meledak" dan menyebabkan perilaku yang tidak terduga.  Dalam sejarah, sudah ada kasus seperti itu dengan kelas SafeInt (sangat ironis) [5, 6.5.2]. </p><br><p>  Integer overflows membuka vektor lebar: adalah mungkin untuk memaksa eksekusi untuk mengambil jalur yang berbeda (jika overflow mempengaruhi pernyataan bersyarat), menyebabkan buffer overflow.  Untuk kejelasan, Anda dapat membiasakan diri dengan CVE tertentu, lihat penyebabnya, konsekuensinya.  Secara alami, lebih baik mencari integer overflow pada produk-produk open source, sehingga Anda tidak hanya membaca deskripsi, tetapi juga melihat kodenya. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2019-3560</a> - Integer overflow di Fizz (sebuah proyek yang mengimplementasikan TLS untuk Facebook) dapat mengeksploitasi kerentanan DoS menggunakan paket jaringan yang sempit. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2018-14618</a> - Buffer overflow di Curl disebabkan oleh integer overflow karena panjang kata sandi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2018-6092</a> - Pada sistem 32-bit, kerentanan di WebAssembly untuk Chrome memungkinkan RCE diimplementasikan melalui halaman HTML khusus. </li></ul><br><p>  Agar tidak menemukan kembali roda, kode untuk mendeteksi bilangan bulat bilangan bulat di penganalisa statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CppCheck</a> dipertimbangkan.  Pendekatannya adalah sebagai berikut: </p><br><ol><li>  Menentukan apakah ekspresi adalah operator biner. </li><li>  Jika ya, maka periksa untuk melihat apakah kedua argumen bertipe integer. </li><li>  Tentukan ukuran jenis. </li><li>  Periksa dengan perhitungan apakah nilai dapat melampaui batas maksimum atau minimum. <br>  Tetapi pada tahap ini tidak memberikan kejelasan.  Ternyata banyak cerita yang berbeda, dan dari sistematisasi informasi ini menjadi lebih sulit.  Segala sesuatu di tempatnya menempatkan daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE</a> .  Secara total, ada 9 jenis integer overflow yang dialokasikan di situs: <br><ul><li>  190 - integer oveflow </li><li>  191 - integer underflow </li><li>  192 - galat coertion integer </li><li>  193 - off-by-one </li><li>  194 - Ekstensi Tanda Tidak Terduga </li><li>  195 - Ditandatangani ke Kesalahan Konversi yang Tidak Ditandatangani </li><li>  196 - Tidak ditandatangani ke Kesalahan Konversi yang Ditandatangani </li><li>  197 - Kesalahan Numeric Truncation </li><li>  198 - Penggunaan Pemesanan Byte Salah </li></ul></li></ol><br><p>  Kami mempertimbangkan alasan untuk setiap opsi dan memahami bahwa luapan terjadi dengan gips eksplisit / implisit yang salah.  Dan karena  setiap gips ditampilkan dalam struktur pohon sintaksis abstrak, kami akan menggunakan AST untuk analisis.  Pada gambar di bawah (Gbr. 3), dapat dilihat bahwa setiap operasi yang menyebabkan gips di pohon adalah node yang terpisah, dan, berkeliaran di sekitar pohon, kita dapat memeriksa semua konversi jenis berdasarkan pada tabel dengan transformasi yang dapat menyebabkan kesalahan. </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Tanda tangan g </th><th>  Tanda l </th><th>  Tanda e </th><th>  Tidak ditandatangani g </th><th>  Tidak ditandatangani l </th><th>  Tidak ditandatangani e </th></tr></thead><tbody><tr><td>  Tanda tangan </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><td>  Tidak ditandatangani </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  + </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e72/315/acb/e72315acbeaf57dcf7ea2f85670fe4e0.jpg" title="gbr. 3"></p><br><p>  Lebih khusus, algoritma terdengar seperti ini: kita berkeliling Cast dan melihat IntegralCast (konversi integer).  Jika Anda menemukan simpul yang cocok, lihat keturunan mencari operasi biner atau Decl (deklarasi variabel).  Dalam kasus pertama, Anda perlu memeriksa tanda dan kedalaman bit yang digunakan operasi biner.  Dalam kasus kedua, bandingkan hanya jenis deklarasi. </p><br><h2 id="realizaciya-chekera">  Implementasi pemeriksa </h2><br><p>  Mari kita mulai implementasi.  Kami membutuhkan kerangka untuk pemeriksa, yang bisa berupa perpustakaan yang berdiri sendiri, atau dapat dirakit sebagai bagian dari Dentang.  Dalam kode, perbedaannya akan kecil.  Jika Anda sudah berencana untuk menulis plugin Anda sendiri, saya sarankan Anda segera membaca pdf kecil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Dentang Analisis Statis: Panduan Pengembang Pemeriksa"</a> , hal-hal dasar dijelaskan dengan baik di sana, meskipun sesuatu mungkin tidak relevan lagi, perpustakaan diperbarui secara teratur, tetapi Anda raih segera. </p><br><p>  Jika Anda ingin menambahkan checker ke rakitan dentang Anda, maka Anda perlu: </p><br><ol><li><p>  Tulis pemeriksa itu sendiri dengan kira-kira konten berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { //       string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void ento::registerSuperChecker(CheckerManager &amp;mgr) { auto checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    //       ,  stand-alone    . AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); SuperChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   }</span></span></code> </pre> <br></li><li><p>  Kemudian, dalam kode sumber Dentang, Anda perlu mengubah file <code>CMakeLists.txt</code> dan <code>Checkers.td</code> .  Tinggal di sekitar sini <code>${llvm-source-path}/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt</code> <br>  dan di sini <code>${llvm-source-path}/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td</code> . <br>  Di bagian pertama, Anda hanya perlu menambahkan nama file dengan kode, di bagian kedua Anda perlu menambahkan deskripsi struktural: </p><br><pre> <code class="cpp hljs"> #Checkers.td def SuperChecker : Checker&lt;<span class="hljs-string"><span class="hljs-string">"SuperChecker"</span></span>&gt;, HelpText&lt;<span class="hljs-string"><span class="hljs-string">"test checker"</span></span>&gt;, Documentation&lt;HasDocumentation&gt;;</code> </pre> <br></li></ol><br><p>  Jika tidak jelas, maka dalam file <code>Checkers.td</code> ada cukup banyak contoh bagaimana dan apa yang harus dilakukan. </p><br><p>  Kemungkinan besar Anda tidak akan ingin membangun kembali Dentang, dan Anda akan menggunakan opsi dengan perakitan perpustakaan (jadi / dll).  Maka dalam kode pemeriksa haruslah sesuatu seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void initializationFunction(CheckerManager &amp;mgr){ SuperChecker *checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); TestChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   } extern "C" void clang_registerCheckers (CheckerRegistry &amp;registry) { registry.addChecker(&amp;initializationFunction, "test.Me", "SuperChecker description", "doc_link"); } extern "C" const char clang_analyzerAPIVersionString [] = "8.0.1";</span></span></code> </pre> <br><p>  Selanjutnya, kumpulkan kode Anda, Anda dapat menulis skrip Anda sendiri untuk perakitan, tetapi jika Anda memiliki masalah dengan ini (seperti penulis :)), maka Anda dapat menggunakan Makefile dalam kode sumber dentang dan membuat perintah clangStaticAnalyzerCheckers dengan cara yang aneh. </p><br><p>  Selanjutnya, hubungi pemeriksa: </p><br><ul><li><p>  untuk checker bawaan </p><br><pre> <code class="bash hljs">clang++ -cc1 -analyze -analyzer-checker=core.DivideZero test.cpp</code> </pre> <br></li><li><p>  untuk eksternal </p><br><pre> <code class="bash hljs">clang++ -cc1 -load <span class="hljs-variable"><span class="hljs-variable">${PATH_TO_CHECKER}</span></span>/SuperChecker.so -analyze -analyzer-checker=test.Me -analyzer-config test.Me:UsrInp1=<span class="hljs-string"><span class="hljs-string">"foo"</span></span> test.Me:Inp1=<span class="hljs-string"><span class="hljs-string">"bar"</span></span> -analyzer-config test.Me:Inp2=123 test.cpp</code> </pre> <br><p>  Pada tahap ini, kita sudah memiliki semacam hasil (Gbr. 4), tetapi kode tertulis hanya dapat mendeteksi potensi luapan.  Dan itu berarti sejumlah besar positif palsu. </p><br></li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac1/79d/29b/ac179d29b330efd513343fdd5f9a2ddd.jpg" title="gbr. 4"></p><br><p>  Untuk memperbaikinya, kita dapat: </p><br><ul><li>  Berkeliling grafik bolak-balik dan memeriksa nilai-nilai spesifik dari variabel untuk kasus-kasus di mana kita memiliki potensi meluap. </li><li>  Selama AST traversal, segera simpan nilai-nilai spesifik untuk variabel dan periksa bila perlu. </li><li>  Gunakan analisis noda. </li></ul><br><p>  Untuk memperkuat argumen lebih lanjut, perlu disebutkan bahwa ketika menganalisis Dentang, semua file yang ditentukan dalam arahan <code>#include</code> juga menguraikan, sebagai akibatnya, ukuran AST yang dihasilkan meningkat.  Akibatnya, dari opsi yang diusulkan, hanya satu yang rasional mengenai tugas tertentu: </p><br><ul><li>  Pertama, dibutuhkan banyak waktu untuk menyelesaikannya.  Berjalan di pohon, mencari dan menghitung semua yang Anda butuhkan akan memakan waktu lama, akan sulit untuk menganalisis proyek besar dengan kode seperti itu.  Untuk berjalan pohon dalam kode, kita akan menggunakan <code>clang::RecursiveASTVisitor</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas</a> , yang melakukan pencarian kedalaman rekursif.  Perkiraan waktu dari pendekatan ini adalah <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7cf317fbe3965ae3164f28c1f6858696adb23f4" title="peringkat kesulitan">  , di mana V adalah himpunan simpul, dan E adalah himpunan tepi grafik. </li><li>  Yang kedua - Anda tentu dapat menyimpan, tetapi kami tidak tahu apa yang akan kami butuhkan dan apa yang tidak.  Selain itu, struktur pohon itu sendiri, yang kami gunakan dalam analisis, membutuhkan banyak memori, jadi menghabiskan sumber daya semacam itu untuk hal lain adalah ide yang buruk. </li><li>  Ketiga adalah ide yang bagus, untuk metode ini Anda dapat menemukan cukup banyak penelitian dan contoh.  Namun dalam CSA tidak ada noda yang siap.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemeriksa</a> , yang kemudian ditambahkan ke daftar pemeriksa alfa (alpha.security.taint.TaintPropagation) dalam sumber, dijelaskan dalam file <code>GenericTaintChecker.cpp</code> .  Pemeriksa itu baik, tetapi hanya cocok untuk fungsi I / O tidak aman yang diketahui dari C, itu hanya "menandai" variabel yang merupakan argumen atau hasil dari fungsi berbahaya.  Selain opsi yang dijelaskan, ada baiknya mempertimbangkan variabel global, bidang kelas, dll, untuk mengembalikan model "distribusi" dengan benar. </li></ul><br><p>  Waktu yang tersisa untuk magang dihabiskan dengan membaca <code>GenericTaintChecker.cpp</code> dan mencoba membuatnya kembali sesuai dengan kebutuhan Anda.  Itu tidak berhasil dengan sukses pada akhir istilah, tetapi tetap tugas untuk perbaikan sudah di luar lingkup pelatihan di DSec.  Juga selama pengembangan menjadi jelas bahwa mengidentifikasi fungsi berbahaya adalah tugas yang terpisah, tidak selalu tempat berbahaya dalam proyek berasal dari beberapa fungsi standar, oleh karena itu bendera ditambahkan ke pemeriksa untuk menunjukkan daftar fungsi yang akan dianggap "diracuni" / "ditandai" selama analisis noda. <br>  Selain itu, pemeriksaan ditambahkan untuk menentukan apakah variabel adalah bidang bit.  Dengan alat CSA standar, ukuran ditentukan berdasarkan tipe, dan jika kita bekerja dengan bidang bit, maka ukurannya akan memiliki nilai tipe bit dari seluruh bidang, dan bukan jumlah bit yang ditentukan dalam deklarasi variabel. </p><br><h2 id="chto-v-itoge">  Apa hasilnya? </h2><br><p>  Saat ini, checker sederhana telah diterapkan yang hanya dapat memperingatkan potensi kelebihan integer.  Kelas yang dimodifikasi untuk analisis noda, yang masih memiliki banyak pekerjaan yang harus dilakukan.  Setelah itu, Anda perlu menggunakan SMT untuk menentukan luapan.  Untuk ini, pemecah SMT Z3 cocok, yang ditambahkan ke rakitan Dentang dalam versi 5.0.0 (dilihat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan rilis</a> ).  Untuk menggunakan solver, Clang perlu dibangun dengan opsi <code>CLANG_ANALYZER_BUILD_Z3=ON</code> , dan ketika plug-in CSA dipanggil langsung, <code>-Xanalyzer -analyzer-constraints=z3</code> dikirimkan. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori Hasil GitHub</a> </p><br><h2 id="ssylki">  Referensi: </h2><br><ol><li><p>  Howard M., Leblanc D., Viega J. "24 Dosa Keamanan Komputer" </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Menulis Checker dalam 24 Jam</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dentang Analisis Statis: Panduan Pengembang Pemeriksa</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manual pengembangan pemeriksa CSA</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dietz W. et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami integer overflow dalam C / C ++</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473412/">https://habr.com/ru/post/id473412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473394/index.html">Kalian semua berbohong! Tentang Periklanan CRM</a></li>
<li><a href="../id473396/index.html">Kami membutuhkan bitrix lain</a></li>
<li><a href="../id473400/index.html">Teknologi Text-to-Speech berkualitas tinggi, ringan dan mudah beradaptasi menggunakan LPCNet</a></li>
<li><a href="../id473406/index.html">Gratis maraton "Ilmu Data dan AI: ajari mesin untuk menulis skrip untuk seri"</a></li>
<li><a href="../id473408/index.html">Debugging kebocoran memori tersembunyi di Ruby</a></li>
<li><a href="../id473416/index.html">Program Konferensi ZeroNights 2019</a></li>
<li><a href="../id473418/index.html">OSCP - Keamanan Ofensif</a></li>
<li><a href="../id473420/index.html">Kami membuka musim pertemuan PHP di Nizhny Novgorod pada 2 November</a></li>
<li><a href="../id473424/index.html">ARM mengumumkan solusi grafis Mali-G57 Valhall dan Mali-D37, neuroprosesor Ethos-N57 dan N37</a></li>
<li><a href="../id473426/index.html">Otomatisasi Pengujian Akhir-2-End dari sistem informasi terintegrasi. Bagian 1. Organisasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>