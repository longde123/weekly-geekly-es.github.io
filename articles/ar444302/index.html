<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏻 🙌🏾 🏤 تطور بنية نظام التجارة والمقاصة في بورصة موسكو. الجزء 2 ⚠️ ❤️ 📮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذا هو استمرار لقصة طويلة حول طريقنا الشائك إلى إنشاء نظام قوي ومحمّل بدرجة كبيرة يضمن تشغيل البورصة. الجزء الأول هنا . 

 خطأ غامض 
 بعد العديد من ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تطور بنية نظام التجارة والمقاصة في بورصة موسكو. الجزء 2</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/moex/blog/444302/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/fj/7h/zk/fj7hzkntltigzuhy-4zrisejpyu.jpeg"><br><br>  هذا هو استمرار لقصة طويلة حول طريقنا الشائك إلى إنشاء نظام قوي ومحمّل بدرجة كبيرة يضمن تشغيل البورصة.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء الأول هنا</a> . <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  خطأ غامض </h2><br>  بعد العديد من الاختبارات ، تم تشغيل نظام التداول والمقاصة المحدّث ، وواجهنا مشكلة كان من الصواب أن نكتب قصة تحريرية صوفية فيها. <br><br>  بعد وقت قصير من البدء على الخادم الرئيسي ، تمت معالجة إحدى المعاملات بخطأ.  في الوقت نفسه ، كان كل شيء بالترتيب على خادم النسخ الاحتياطي.  اتضح أن العملية الحسابية البسيطة لحساب الأس على الخادم الرئيسي أعطت نتيجة سلبية من حجة صالحة!  استمرت عمليات المسح ، وفي سجل SSE2 وجدوا فرقًا في وحدة البت الواحدة ، وهي المسؤولة عن التقريب عند العمل بأرقام الفاصلة العائمة. <br><br>  لقد كتبوا أداة اختبار بسيطة لحساب الأس مع مجموعة تقريب البتات.  اتضح أنه في إصدار RedHat Linux الذي استخدمناه ، كان هناك خلل في العمل مع دالة رياضية عندما تم إدراج البت الخاطئ.  أبلغنا بذلك إلى RedHat ، بعد فترة من الوقت تلقينا رقعة منها ولفناها.  لم يعد الخطأ قد حدث ، لكن لم يتضح من أين أتت هذه القطعة؟  كانت وظيفة <code>fesetround</code> من C هي المسؤولة عنها ، وقد قمنا بتحليل الكود الخاص بنا بعناية بحثًا عن الخطأ المزعوم: فحص جميع الحالات المحتملة ؛  النظر في جميع الوظائف التي تستخدم التقريب ؛  حاول لعب جلسة فاشلة ؛  تستخدم مترجمين مختلفين مع خيارات مختلفة ؛  يستخدم تحليل ثابت وديناميكي. <br><br>  لا يمكن العثور على سبب الخطأ. <br><br>  ثم بدأوا في التحقق من الأجهزة: لقد أجروا اختبارات تحميل المعالجات ؛  فحص ذاكرة الوصول العشوائي.  حتى ركض الاختبارات لسيناريو من غير المرجح للغاية لخطأ متعدد بت في خلية واحدة.  ولكن دون جدوى. <br><br>  في النهاية ، استقروا على نظريات عالم الفيزياء عالية الطاقة: طار بعض الجسيمات عالية الطاقة إلى مركز البيانات الخاص بنا ، واخترق جدار الجسم ، وضرب المعالج وتسبب في مزلاج الزناد في نفس الوقت.  هذه النظرية السخيفة كانت تسمى "النيوترينو".  إذا كنت بعيدًا عن فيزياء الجسيمات الأولية: بالكاد تتفاعل النيوتريونات مع العالم الخارجي ، وبالتأكيد لن تكون قادرة على التأثير على المعالج. <br><br>  نظرًا لأنه لم يكن من الممكن العثور على سبب الفشل ، فقط في حالة استبعاد الخادم "المتأخر" عن التشغيل. <br><br>  بعد مرور بعض الوقت ، بدأنا في تحسين نظام الاستعداد الساخن: قدمنا ​​ما يسمى "الاحتياطيات الدافئة" (النسخ المتماثلة غير المتزامنة).  لقد تلقوا مجموعة من المعاملات التي قد تكون في مراكز بيانات مختلفة ، ولكن دافئ لا يدعم التفاعل النشط مع خوادم أخرى. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/4fd/67f/61c4fd67f72a529370bcc7a792ae946e.png"><br><br>  لماذا تم ذلك؟  في حالة فشل خادم النسخ الاحتياطي ، يصبح الربط الحار بالخادم الرئيسي هو النسخة الاحتياطية الجديدة.  هذا ، بعد الفشل ، لا يبقى النظام حتى نهاية جلسة التداول مع خادم رئيسي واحد. <br><br>  وعندما تم اختبار الإصدار الجديد من النظام ودخوله حيز التنفيذ ، حدث خطأ في التقريب مرة أخرى.  علاوة على ذلك ، مع زيادة عدد الخوادم الدافئة ، بدأ الخطأ في الظهور مرات أكثر.  في هذه الحالة ، لم يكن لدى البائع أي شيء ، حيث لا يوجد دليل ملموس. <br><br>  أثناء التحليل التالي للوضع ، نشأت النظرية أن المشكلة يمكن أن تكون مرتبطة بنظام التشغيل.  لقد كتبنا برنامجًا بسيطًا يستدعي الدالة <code>fesetround</code> في حلقة لا نهاية لها ، يتذكر الحالة الحالية <code>fesetround</code> أثناء النوم ، ويتم ذلك في العديد من الخيوط المتنافسة.  بعد تحديد معلمات السكون وعدد الخيوط ، بدأنا في إعادة إنتاج فشل البت بشكل مستقر بعد حوالي 5 دقائق من الأداة.  ومع ذلك ، كان ريد هات الدعم غير قادر على إنتاجه.  أظهر اختبار خوادمنا الأخرى أن الخوادم التي لها معالجات معينة فقط هي التي تتأثر.  في الوقت نفسه ، حل الانتقال إلى نواة جديدة المشكلة.  في النهاية ، استبدلنا نظام التشغيل فقط ، وظل السبب الحقيقي لهذا الخطأ غير واضح. <br><br>  وفجأة ، ظهرت مقالة في العام الماضي عن حبري بعنوان " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كيف وجدت خللًا في معالجات Intel Skylake</a> ".  كان الموقف الموصوف فيه مشابهاً للغاية لحالنا ، لكن المؤلف تقدم أكثر في التحقيق وقدم نظرية مفادها أن الخطأ كان في الرمز الصغير.  وعند تحديث نواة Linux ، يقوم المصنعون أيضًا بتحديث الرمز الصغير. <br><br><h2 style=";text-align:right;direction:rtl">  مزيد من التطوير للنظام </h2><br>  على الرغم من أننا تخلصنا من الخطأ ، إلا أن هذه القصة جعلتنا نعيد النظر في بنية النظام مرة أخرى.  بعد كل شيء ، لم نكن محمية من تكرار هذه الأخطاء. <br><br>  شكلت المبادئ التالية الأساس لمزيد من التحسينات لنظام النسخ الاحتياطي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا يمكنك الوثوق بأي شخص.  خوادم قد لا تعمل بشكل صحيح. </li><li style=";text-align:right;direction:rtl">  أغلبية التكرار. </li><li style=";text-align:right;direction:rtl">  بناء التوافق.  كمكمل منطقي لتكرار الأغلبية. </li><li style=";text-align:right;direction:rtl">  الفشل المزدوج ممكن. </li><li style=";text-align:right;direction:rtl">  حيوية.  يجب ألا يكون مخطط قطع الغيار الساخن الجديد أسوأ من المخطط السابق.  يجب أن تتم التجارة بسلاسة حتى آخر خادم. </li><li style=";text-align:right;direction:rtl">  زيادة طفيفة في التأخير.  أي توقف يستتبع خسائر مالية ضخمة. </li><li style=";text-align:right;direction:rtl">  الحد الأدنى من تفاعل الشبكة بحيث يكون التأخير منخفضًا قدر الإمكان. </li><li style=";text-align:right;direction:rtl">  حدد خادم رئيسي جديد في ثوان. </li></ul><br>  لم يناسبنا أي من الحلول المتاحة في السوق ، ولم يكن بروتوكول Raft في بدايته ، لذا قمنا بإنشاء الحل الخاص بنا. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/bc0/73e/d50bc073e4a2bbb805b724d0040b18f9.png"><br><br><h2 style=";text-align:right;direction:rtl">  اتصال الشبكة </h2><br>  بالإضافة إلى نظام النسخ الاحتياطي ، بدأنا في تحديث اتصال الشبكة.  كان نظام الإدخال / الإخراج الفرعي العديد من العمليات ، والتي أثرت في أسوأ الأحوال على الارتعاش والتأخير.  نظرًا لوجود مئات العمليات التي تعالج اتصالات TCP ، فقد اضطررنا إلى التبديل بينها باستمرار ، وعلى نطاق القياس الجزئي ، هذه عملية طويلة إلى حد ما.  ولكن الجزء الأسوأ هو أنه عندما تتلقى عملية ما حزمة من أجل المعالجة ، فقد أرسلتها إلى قائمة انتظار SystemV واحدة ، ثم انتظرت الأحداث من قائمة انتظار SystemV أخرى.  ومع ذلك ، مع وجود عدد كبير من العقد ، يمثل وصول حزمة TCP جديدة في عملية واحدة واستلام البيانات في قائمة انتظار في حدثين آخرين منافسين لنظام التشغيل.  في هذه الحالة ، إذا لم تكن هناك معالجات فعلية متاحة لكلتا المهمتين ، فستتم معالجة واحدة ، والثاني في قائمة انتظار الانتظار.  من المستحيل التنبؤ بالعواقب. <br><br>  في مثل هذه الحالات ، يمكنك تطبيق التحكم في أولوية العمليات الديناميكية ، ولكن هذا سيتطلب استخدام مكالمات النظام كثيفة الاستخدام للموارد.  نتيجة لذلك ، تحولنا إلى مؤشر ترابط واحد باستخدام epoll الكلاسيكية ، مما أدى إلى زيادة كبيرة في السرعة وتقليل وقت معالجة المعاملة.  لقد تخلصنا أيضًا من بعض عمليات تفاعل الشبكة والتفاعل من خلال SystemV ، حيث قللنا كثيرًا من عدد مكالمات النظام وبدأنا نتحكم في أولويات العمليات.  باستخدام نظام إدخال / إخراج فرعي واحد فقط ، كان من الممكن حفظ حوالي 8-17 ميكروثانية ، اعتمادًا على السيناريو.  منذ ذلك الحين تم تطبيق هذا المخطط المفرد بدون تغيير ، دفق epoll واحد بهامش يكفي لخدمة جميع الاتصالات. <br><br><h2 style=";text-align:right;direction:rtl">  معالجة المعاملات </h2><br>  يتطلب الحمل المتزايد على نظامنا تحديث جميع مكوناته تقريبًا.  ولكن لسوء الحظ ، فإن الركود في الزيادة في سرعة ساعة المعالج في السنوات الأخيرة لم يعد يسمح لنا بتوسيع نطاق العمليات "المباشرة".  لذلك ، قررنا تقسيم عملية Engine إلى ثلاثة مستويات ، أكثرها تحميلًا هو نظام التحقق من المخاطر ، الذي يقيم مدى توفر الأموال في الحسابات وإنشاء المعاملات بنفسها.  لكن يمكن أن يكون المال بعملات مختلفة ، وكان من الضروري معرفة مبدأ تقسيم معالجة الطلبات. <br><br>  الحل المنطقي هو تقسيم العملة: يتاجر خادم واحد بالدولار ، وآخر بالجنيه ، ويورو ثالث.  ولكن إذا تم ، مع مثل هذا المخطط ، إرسال معاملتين لشراء عملات مختلفة ، فستكون هناك مشكلة في محافظ غير متزامنة.  والمزامنة صعبة ومكلفة.  لذلك ، سيكون من الصحيح أن تتقاسم بشكل منفصل على محافظ وبشكل منفصل على الأدوات.  بالمناسبة ، في معظم التبادلات الغربية ، مهمة التحقق من المخاطر ليست حادة مثل مهمتنا ، لذلك يتم ذلك في أغلب الأحيان دون اتصال بالإنترنت.  نحن بحاجة لتنفيذ فحص عبر الإنترنت. <br><br>  دعونا توضيح مع مثال.  يريد التاجر شراء 30 دولارًا ، ويذهب الطلب للتحقق من صحة المعاملة: نتحقق مما إذا كان هذا التاجر مسموحًا به في وضع التداول هذا ، وما إذا كان لديه الحقوق اللازمة.  إذا كان كل شيء على ما يرام ، فسيذهب الطلب إلى نظام التحقق من المخاطر ، أي  للتحقق من كفاية الأموال لإتمام الصفقة.  هناك ملاحظة أن المبلغ المطلوب محظور حاليًا.  علاوة على ذلك ، يتم إعادة توجيه الطلب إلى نظام التداول ، الذي يوافق أو لا يوافق على هذه الصفقة.  دعنا نقول الموافقة على الصفقة - ثم يشير نظام التحقق من المخاطر إلى أن الأموال قد تم فتحها وأن الروبل يتم تحويلها إلى دولارات. <br><br>  بشكل عام ، يحتوي نظام التحقق من المخاطر على خوارزميات معقدة وينفذ عددًا كبيرًا من العمليات الحسابية الكثيفة الاستخدام للموارد ، ولا يتحقق فقط من "رصيد الحساب" ، كما قد يبدو للوهلة الأولى. <br><br>  عندما بدأنا تقسيم عملية Engine إلى مستويات ، واجهنا مشكلة: الشفرة التي كانت متاحة في ذلك الوقت في مراحل التحقق والتحقق تستخدم بنشاط نفس صفيف البيانات ، الأمر الذي تطلب إعادة كتابة قاعدة الشفرة بأكملها.  نتيجة لذلك ، استعارنا منهجية لمعالجة الإرشادات من المعالجات الحديثة: يتم تقسيم كل منها إلى مراحل صغيرة ويتم تنفيذ العديد من الإجراءات بشكل متوازٍ في دورة واحدة. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40f/d5b/011/40fd5b0119fef43d909ce33abc898ff8.png"><br><br>  بعد تعديل بسيط للشفرة ، أنشأنا خط أنابيب للمعالجة المتوازية للمعاملات ، حيث تم تقسيم المعاملة إلى 4 مراحل من خط الأنابيب: تفاعل الشبكة ، والتحقق من صحة ، وتنفيذ ، ونشر النتيجة <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/90f/55b/dd690f55b9be4e03a50a9ecb3930c746.png"><br><br>  النظر في مثال.  لدينا نظامين للمعالجة ، مسلسل ومتوازي.  تصل المعاملة الأولى ، وفي كلا النظامين ، يتم التحقق من الصحة.  ثم تصل المعاملة الثانية: في نظام مواز ، يتم نقلها على الفور إلى العمل ، وفي نظام متسلسل يتم وضعها في قائمة الانتظار في انتظار أول معاملة تمر بمرحلة المعالجة الحالية.  أي أن الميزة الرئيسية لخطوط الأنابيب هي أننا نقوم بمعالجة قائمة انتظار المعاملات بشكل أسرع. <br><br>  لذلك حصلنا على نظام ASTS +. <br><br>  صحيح ، مع الناقلات ، أيضا ، ليس كل شيء على نحو سلس جدا.  لنفترض أن لدينا معاملة تؤثر على صفائف البيانات في معاملة مجاورة ، فهذا موقف مثالي للتبادل.  لا يمكن تنفيذ هذه المعاملة في خط الأنابيب ، لأنها يمكن أن تؤثر على الآخرين.  يُطلق على هذا الموقف "خطر البيانات" ، وتتم معالجة هذه المعاملات ببساطة بشكل منفصل: عندما تتوقف المعاملات "السريعة" في نهاية قائمة الانتظار ، يعالج خط الأنابيب ، ويقوم النظام بمعالجة المعاملة "البطيئة" ثم يبدأ تشغيل خط الأنابيب مرة أخرى.  لحسن الحظ ، فإن حصة هذه المعاملات في إجمالي التدفق صغيرة جدًا ، لذا فإن خط الأنابيب نادراً ما يتوقف بحيث لا يؤثر على الأداء الكلي. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e0/131/de5/0e0131de5df810723111aba61853dd77.png"><br><br>  ثم بدأنا في حل مشكلة مزامنة ثلاثة خيوط للتنفيذ.  نتيجة لذلك ، تم إنشاء نظام يعتمد على مخزن مؤقت دائري مع خلايا ذات حجم ثابت.  في هذا النظام ، كل شيء يخضع لسرعة المعالجة ، لا يتم نسخ البيانات. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  جميع حزم الشبكة الواردة تدخل في مرحلة التخصيص. </li><li style=";text-align:right;direction:rtl">  نضعها في صفيف ونضع علامة على أنها متاحة للمرحلة الأولى. </li><li style=";text-align:right;direction:rtl">  وجاءت الصفقة الثانية ، وهي متاحة مرة أخرى للمرحلة رقم 1. </li><li style=";text-align:right;direction:rtl">  يشاهد تدفق المعالجة الأول المعاملات المتوفرة ، ويقوم بمعالجتها ، وينقلها إلى المرحلة التالية من تدفق المعالجة الثاني. </li><li style=";text-align:right;direction:rtl">  ثم تقوم بمعالجة المعاملة الأولى وتحديد الخلية المقابلة بالعلامة <code>deleted</code> - وهي الآن متوفرة للاستخدام الجديد. </li></ul><br>  وبالتالي ، تتم معالجة قائمة الانتظار بأكملها. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/172/d67/3a8172d67dad9c45dc21448dfb74e135.png"><br><br>  معالجة كل مرحلة تأخذ وحدات أو عشرات من ميكروثانية.  وإذا كنت تستخدم أنظمة مزامنة نظام التشغيل القياسية ، فسوف نفقد المزيد من الوقت في المزامنة نفسها.  لذلك ، بدأنا في استخدام spinlock.  ومع ذلك ، هذه نغمة سيئة للغاية في نظام الوقت الفعلي ، وتوصي RedHat بشدة بعدم القيام بذلك ، لذلك نستخدم spinlock لمدة 100 مللي ثانية ، ثم ننتقل إلى وضع إشارة لاستبعاد احتمال حدوث حالة توقف تام. <br><br>  نتيجة لذلك ، حققنا أداءً بلغ حوالي 8 ملايين معاملة في الثانية.  وبعد شهرين فقط ، في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقال</a> حول LMAX Disruptor ، رأوا وصفًا لدائرة لها نفس الوظيفة. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b31/498/732/b31498732113050fe76ed4dee7c9c82e.png"><br><br>  الآن في مرحلة واحدة يمكن أن يكون هناك العديد من خيوط التنفيذ.  تمت معالجة جميع المعاملات بدورها ، بالترتيب المستلم.  ونتيجة لذلك ، ارتفع أداء الذروة من 18 ألف إلى 50 ألف معاملة في الثانية. <br><br><h2 style=";text-align:right;direction:rtl">  نظام إدارة مخاطر الصرف </h2><br>  لا يوجد حد للكمال ، وسرعان ما بدأنا في التحديث مرة أخرى: في إطار ASTS + ، بدأنا في نقل أنظمة إدارة المخاطر وعمليات التسوية إلى مكونات مستقلة.  قمنا بتطوير بنية حديثة مرنة ونموذج خطر هرمي جديد ، حاولنا حيثما أمكن استخدام فئة <code>fixed_point</code> بدلاً من <code>double</code> . <br><br>  ولكن على الفور نشأت المشكلة: كيفية مزامنة كل منطق العمل الذي كان يعمل لسنوات عديدة ونقله إلى النظام الجديد؟  نتيجة لذلك ، كان يجب التخلي عن النسخة الأولى من النموذج الأولي للنظام الجديد.  تعتمد النسخة الثانية ، التي تعمل حاليًا في الإنتاج ، على نفس الكود الذي يعمل في جزء التداول وفي المخاطرة.  أثناء التطوير ، كان أصعب شيء هو دمج git بين الإصدارين.  يقوم زميلنا Evgeny Mazurenok بإجراء هذه العملية كل أسبوع ولعن لفترة طويلة جدًا في كل مرة. <br><br>  عند اختيار نظام جديد ، كان علينا على الفور حل مشكلة التفاعل.  عند اختيار ناقل البيانات ، كان من الضروري ضمان غضب مستقر والحد الأدنى من التأخير.  لهذا ، فإن شبكة InfiniBand RDMA هي الأنسب: متوسط ​​وقت المعالجة أقل 4 مرات من شبكات Ethernet ذات 10 جيجا.  لكن الفرق الحقيقي كان في النسب المئوية - 99 و 99.9. <br><br>  بالطبع ، لدى InfiniBand صعوباتها الخاصة.  أولاً ، API آخر هو ibverbs بدلاً من المقابس.  ثانياً ، لا توجد حلول المراسلة مفتوحة المصدر على نطاق واسع تقريبًا.  لقد حاولنا إنشاء النموذج الأولي الخاص بنا ، ولكن تبين أنه صعب للغاية ، لذلك اخترنا حلاً تجاريًا - Confinity Low Latency Messaging (المعروف سابقًا باسم IBM MQ LLM). <br><br>  ثم نشأت مشكلة الفصل الصحيح لنظام المخاطر.  إذا قمت فقط بإخراج محرك المخاطر ولم تقم بإنشاء عقدة وسيطة ، فيمكن خلط المعاملات من مصدرين. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41c/b59/4c9/41cb594c970d774c5715a43f43d3f29b.png"><br><br>  تشتمل حلول Ultra Low Latency المزعومة على وضع إعادة ترتيب: يمكن ترتيب المعاملات من مصدرين بالترتيب الصحيح عند الاستلام ، ويتحقق ذلك باستخدام قناة منفصلة لتبادل المعلومات حول التسلسل.  لكننا لا نطبق هذا الوضع بعد: إنه يعقد العملية برمتها ، وفي بعض الحلول لا يتم دعمه على الإطلاق.  بالإضافة إلى ذلك ، يجب تعيين كل معاملة الطوابع الزمنية المناسبة ، وفي مخططنا يصعب للغاية تنفيذ هذه الآلية بشكل صحيح.  لذلك ، استخدمنا المخطط الكلاسيكي مع وسيط الرسائل ، أي مع موزع يقوم بتوزيع الرسائل بين Risk Engine. <br><br>  كانت المشكلة الثانية متعلقة بوصول العميل: إذا كان هناك العديد من بوابات المخاطرة ، فيجب على العميل الاتصال بكل منها ، ولهذا يتعين عليك إجراء تغييرات على طبقة العميل.  لقد أردنا الابتعاد عن هذا في هذه المرحلة ، لذلك في خطة بوابة المخاطر الحالية يعالجون دفق البيانات بأكمله.  هذا يحد بشدة من الحد الأقصى للإنتاجية ، ولكن يبسط تكامل النظام إلى حد كبير. <br><br><h2 style=";text-align:right;direction:rtl">  تكرار </h2><br>  لا ينبغي أن يكون لنظامنا نقطة فشل واحدة ، أي أنه يجب تكرار جميع المكونات ، بما في ذلك وسيط الرسائل.  لقد قمنا بحل هذه المشكلة باستخدام نظام CLLM: فهو يحتوي على مجموعة RCMS يمكن أن يعمل فيها مرسلان في وضع السيد والعبد ، وعندما يفشل أحدهما ، ينتقل النظام تلقائيًا إلى الآخر. <br><br><h2 style=";text-align:right;direction:rtl">  العمل مع مركز بيانات النسخ الاحتياطي </h2><br>  تم تحسين InfiniBand للعمل كشبكة محلية ، أي لتوصيل معدات تركيب الحامل ، وليس هناك طريقة لوضع شبكة InfiniBand بين مركزين للبيانات موزعين جغرافياً.  لذلك ، قمنا بتطبيق جسر / مرسل يصل إلى مخزن الرسائل عبر شبكات إيثرنت العادية وينقل جميع المعاملات إلى شبكة IB الثانية.  عندما تحتاج إلى ترحيل من مركز البيانات ، يمكننا اختيار مركز البيانات الذي سيعمل معه الآن. <br><br><h2 style=";text-align:right;direction:rtl">  النتائج </h2><br>  كل ما سبق لم يتم في وقت واحد ، فقد تطلب الأمر عدة تكرارات لتطوير بنية جديدة.  لقد أنشأنا النموذج الأولي خلال شهر واحد ، لكن الأمر استغرق أكثر من عامين لإنهاء حالة العمل.  لقد حاولنا تحقيق أفضل حل وسط بين زيادة مدة معالجة المعاملات وزيادة موثوقية النظام. <br><br>  منذ أن تم تحديث النظام بشكل كبير ، قمنا بتنفيذ استعادة البيانات من مصدرين مستقلين.  إذا لم يعمل مخزن الرسائل لسبب ما بشكل صحيح ، فيمكنك أخذ سجل المعاملات من مصدر ثانٍ - من Risk Engine.  يتم احترام هذا المبدأ في جميع أنحاء النظام. <br><br>  من بين أشياء أخرى ، تمكنا من الحفاظ على واجهة برمجة تطبيقات العميل بحيث لا يحتاج الوسطاء أو أي شخص آخر إلى تغيير كبير في الهيكل الجديد.  اضطررت إلى تغيير بعض الواجهات ، لكنني لم أكن بحاجة إلى إجراء تغييرات كبيرة على نموذج العمل. <br><br>  أطلقنا على الإصدار الحالي من برنامجنا Rebus - كاختصار لاثنين من أبرز الابتكارات في الهندسة المعمارية ، و Risk Engine و BUS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/179/4f2/bf5/1794f2bf5eb87f3ab59df9d9e0d829d8.png"><br><br>  في البداية ، أردنا إبراز جزء المقاصة فقط ، لكن النتيجة كانت نظام توزيع ضخم.  الآن يمكن للعملاء التفاعل مع بوابة التجارة ، أو مع المقاصة ، أو مع الاثنين معا. <br><br>  ما حققناه في النهاية: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/6e7/d8d/2d46e7d8d73032984b0c5ecb8bc1e9e1.png"><br><br>  انخفاض مستوى التأخير.  مع حجم صغير من المعاملات ، يعمل النظام بنفس الطريقة التي يعمل بها الإصدار السابق ، ولكن في نفس الوقت يتحمل عبء أعلى بكثير. <br><br>  زادت ذروة الإنتاجية من 50 ألف إلى 180 ألف معاملة في الثانية.  هناك دفق إضافي من المعلومات يعيق المزيد من النمو. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هناك طريقتان لمزيد من التحسين: مطابقة التوازي وتغيير مخطط العمل مع Gateway. </font><font style="vertical-align: inherit;">تعمل جميع العبّارات الآن وفقًا لنظام النسخ المتماثل ، والذي يتوقف عند هذا التحميل عن العمل بشكل طبيعي. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في النهاية ، يمكنني تقديم بعض النصائح لأولئك الذين يطورون أنظمة المؤسسة:</font></font><br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كن مستعدا للأسوأ في كل وقت. </font><font style="vertical-align: inherit;">المشاكل تأتي دائما بشكل غير متوقع.</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من المستحيل عادة إعادة إنشاء العمارة بسرعة. </font><font style="vertical-align: inherit;">خاصة إذا كنت بحاجة إلى تحقيق أقصى قدر من الموثوقية في مجموعة متنوعة من المؤشرات. </font><font style="vertical-align: inherit;">لمزيد من العقد ، هناك حاجة إلى مزيد من الموارد للحصول على الدعم.</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> جميع الحلول الخاصة والملكية تتطلب موارد إضافية للبحث والدعم والدعم. </font></font></li><li style=";text-align:right;direction:rtl">          ,      . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar444302/">https://habr.com/ru/post/ar444302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar444290/index.html">أساسيات البرمجة التفاعلية باستخدام RxJS. الجزء 2. المشغلين والأنابيب</a></li>
<li><a href="../ar444294/index.html">كيف يعمل الطيران التجاري في روسيا (مراكز FBO)</a></li>
<li><a href="../ar444296/index.html">6 موارد وخدمات مفيدة للمهاجرين المحتملين إلى الولايات المتحدة الأمريكية وألمانيا وكندا</a></li>
<li><a href="../ar444298/index.html">يقول العلماء إن بإمكانهم إعادة تشكيل الديناصورات الحية لمدة 5 سنوات</a></li>
<li><a href="../ar444300/index.html">تطور بنية نظام التجارة والمقاصة في بورصة موسكو. الجزء 1</a></li>
<li><a href="../ar444304/index.html">Huawei و Nutanix تعلنان عن شراكة HCI</a></li>
<li><a href="../ar444306/index.html">الجنس والحب والعلاقات من خلال منظور العمارة microservice</a></li>
<li><a href="../ar444308/index.html">أخبار صناعة اللعبة (11-18 مارس 2019)</a></li>
<li><a href="../ar444312/index.html">تثبيت ReactOS من عصا USB</a></li>
<li><a href="../ar444314/index.html">صمام يبدأ القتال السلبي غير متصل الاستعراضات</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>