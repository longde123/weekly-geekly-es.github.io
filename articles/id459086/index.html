<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑üèª üíà üòí Distribusi statis objek FreeRTOS üëù üö¢ üîÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Secara default, semua objek dalam sistem FreeRTOS didistribusikan secara dinamis - antrian, semaphore, timer, tugas (utas), dan mutex. Programmer hany...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distribusi statis objek FreeRTOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459086/">  Secara default, semua objek dalam sistem FreeRTOS didistribusikan secara dinamis - antrian, semaphore, timer, tugas (utas), dan mutex.  Programmer hanya melihat "heap" - area di mana memori dialokasikan secara dinamis atas permintaan suatu program atau sistem, dan apa yang terjadi di dalamnya tidak jelas.  Berapa yang tersisa?  Tidak dikenal  Apakah ada yang lebih dari yang Anda butuhkan?  Siapa tahu  Secara pribadi, saya lebih suka menyelesaikan masalah mengatur memori bahkan pada tahap penulisan firmware, tanpa membawa kesalahan runtime ketika memori tiba-tiba berakhir. <br><br>  Artikel ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelanjutan</a> logis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemarin</a> tentang distribusi statis objek dalam memori mikrokontroler, hanya sekarang dalam kaitannya dengan objek FreeRTOS.  Hari ini kita akan belajar bagaimana menempatkan objek FreeRTOS secara statis, yang akan memungkinkan kita untuk lebih jelas memahami apa yang terjadi dalam RAM mikrokontroler, bagaimana tepatnya objek kita berada dan seberapa banyak mereka menempati. <br><br>  Tetapi hanya dengan mengambil dan mulai menempatkan objek FreeRTOS secara statis tidak memerlukan banyak kecerdasan - dimulai dengan versi 9.0, FreeRTOS menyediakan fungsi untuk membuat objek yang ditempatkan secara statis.  Fungsi-fungsi tersebut memiliki akhiran Statis dalam nama dan fungsi-fungsi ini memiliki dokumentasi yang sangat baik dengan contoh.  Kami akan menulis pembungkus C ++ yang nyaman dan indah di atas fungsi FreeRTOS yang tidak hanya akan menempatkan objek secara statis, tetapi juga menyembunyikan semua jeroan ayam itik, serta menyediakan antarmuka yang lebih nyaman. <br><br>  Artikel ini ditujukan untuk programmer pemula, tetapi yang sudah terbiasa dengan dasar-dasar FreeRTOS dan primitif sinkronisasi program multithreaded.  Ayo pergi. <br><a name="habracut"></a><br>  FreeRTOS adalah sistem operasi untuk mikrokontroler.  Baiklah, ok, bukan OS lengkap, tapi perpustakaan yang memungkinkan Anda menjalankan beberapa tugas secara paralel.  FreeRTOS juga memungkinkan tugas untuk bertukar pesan melalui antrian pesan, menggunakan penghitung waktu, dan menyinkronkan tugas menggunakan semaphore dan mutex. <br><br>  Menurut pendapat saya, firmware apa pun di mana Anda perlu secara bersamaan melakukan dua (atau lebih) tugas dapat diselesaikan dengan lebih mudah dan lebih elegan jika Anda menggunakan FreeRTOS.  Misalnya, baca bacaan dari sensor lambat dan pada saat yang sama melayani tampilan.  Hanya agar tanpa rem, sedangkan sensornya terbaca.  Secara umum, harus punya!  Saya sangat merekomendasikan untuk belajar. <br><br>  Seperti yang saya katakan dan tulis dalam artikel sebelumnya, saya tidak terlalu suka pendekatan membuat objek secara dinamis jika kita tahu jumlah dan ukurannya pada tahap kompilasi.  Jika objek seperti itu ditempatkan secara statis, maka kita bisa mendapatkan gambaran alokasi memori yang lebih jelas dan lebih mudah dipahami dalam mikrokontroler, dan karenanya menghindari kejutan ketika memori tiba-tiba berakhir. <br><br>  Kami akan mempertimbangkan masalah organisasi memori FreeRTOS menggunakan papan BluePill pada mikrokontroler STM32F103C8T6 sebagai contoh.  Agar tidak khawatir tentang kompiler dan sistem build, kami akan bekerja di lingkungan ArduinoIDE, memasang dukungan untuk board ini.  Ada beberapa implementasi Arduino untuk STM32 - pada prinsipnya, semua akan dilakukan.  Saya telah menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stm32duino</a> sesuai dengan instruksi dari proyek Readme.md, sebuah bootloader sebagaimana disebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini</a> .  FreeRTOS versi 10.0 diinstal melalui manajer perpustakaan ArduinoIDE.  Kompiler - gcc 8.2 <br><br>  Kami akan datang dengan tugas eksperimental kecil.  Mungkin tidak ada banyak arti praktis dalam tugas ini, tetapi semua primitif sinkronisasi yang ada di FreeRTOS akan digunakan.  Sesuatu seperti ini: <br><br><ul><li>  2 tugas (utas) bekerja secara paralel </li><li>  timer juga berfungsi, yang dari waktu ke waktu mengirim pemberitahuan ke tugas pertama menggunakan semafor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam mode menunggu sinyal</a> </li><li>  tugas pertama, setelah menerima pemberitahuan dari timer, mengirim pesan (nomor acak) ke tugas kedua melalui antrian </li><li>  yang kedua, setelah menerima pesan, mencetaknya ke konsol </li><li>  biarkan tugas pertama juga mencetak sesuatu ke konsol, dan agar mereka tidak melawan konsol akan dilindungi oleh mutex. </li><li>  ukuran antrian bisa terbatas pada satu elemen, tetapi untuk membuatnya lebih menarik, kami menempatkan 1000 </li></ul><br>  Implementasi standar (sesuai dengan dokumentasi dan tutorial) mungkin terlihat seperti ini. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;STM32FreeRTOS.h&gt; TimerHandle_t xTimer; xSemaphoreHandle xSemaphore; xSemaphoreHandle xMutex; xQueueHandle xQueue; void vTimerCallback(TimerHandle_t pxTimer) { xSemaphoreGive(xSemaphore); } void vTask1(void *) { while(1) { xSemaphoreTake(xSemaphore, portMAX_DELAY); int value = random(1000); xQueueSend(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println("Test"); xSemaphoreGive(xMutex); } } void vTask2(void *) { while(1) { int value; xQueueReceive(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println(value); xSemaphoreGive(xMutex); } } void setup() { Serial.begin(9600); vSemaphoreCreateBinary(xSemaphore); xQueue = xQueueCreate(1000, sizeof(int)); xMutex = xSemaphoreCreateMutex(); xTimer = xTimerCreate("Timer", 1000, pdTRUE, NULL, vTimerCallback); xTimerStart(xTimer, 0); xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); vTaskStartScheduler(); } void loop() {}</span></span></span></span></code> </pre> <br>  Mari kita lihat apa yang terjadi dalam memori mikrokontroler, jika Anda mengkompilasi kode tersebut.  Secara default, semua objek FreeRTOS ditempatkan dalam memori dinamis.  FreeRTOS menyediakan sebanyak 5 implementasi manajer memori yang sulit untuk diimplementasikan, tetapi secara umum mereka memiliki tugas yang sama - untuk memotong potongan memori untuk kebutuhan FreeRTOS dan pengguna.  Potongan dipotong baik dari tumpukan umum mikrokontroler (menggunakan malloc) atau menggunakan tumpukan terpisah mereka sendiri.  Jenis tumpukan apa yang digunakan untuk kita tidak penting - lagi pula, kita tidak bisa melihat ke dalam tumpukan itu. <br><br>  Sebagai contoh, untuk tumpukan nama FreeRTOS akan terlihat seperti ini (keluaran dari utilitas objdump) <br><br><pre> <code class="plaintext hljs">... 200009dc l O .bss 00002000 ucHeap ...</code> </pre><br>  Yaitu  kita melihat satu bagian besar, di mana semua objek FreeRTOS dipotong - semafor, mutex, timer, antrian, dan bahkan tugas itu sendiri.  2 poin terakhir sangat penting.  Bergantung pada jumlah elemen, antrian bisa sangat besar, dan tugas dijamin akan memakan banyak ruang karena tumpukan, yang juga dialokasikan bersama dengan tugas. <br><br>  Ya, ini adalah minus dari multitasking - setiap tugas akan memiliki tumpukan sendiri.  Selain itu, tumpukan harus cukup besar sehingga tidak hanya berisi panggilan dan variabel lokal dari tugas itu sendiri, tetapi juga tumpukan interupsi, jika ini terjadi.  Nah, karena gangguan dapat terjadi kapan saja, maka setiap tugas harus memiliki cadangan di tumpukan jika terjadi gangguan.  Selain itu, mikrokontroler CortexM dapat memiliki interupsi bersarang, sehingga tumpukan harus cukup besar untuk mengakomodasi semua interupsi jika terjadi secara bersamaan. <br><br>  Ukuran tumpukan tugas diatur saat membuat tugas dengan parameter fungsi xTaskCreate.  Ukuran stack tidak boleh kurang dari parameter configMINIMAL_STACK_SIZE (ditentukan dalam file konfigurasi FreeRTOSConfig.h) - ini adalah cadangan yang sama untuk interupsi.  Ukuran heap diatur oleh parameter configTOTAL_HEAP_SIZE dan dalam hal ini adalah 8kb. <br><br><div class="spoiler">  <b class="spoiler_title">Sekarang coba tebak apakah semua benda kita akan muat di tumpukan 8kb?</b>  <b class="spoiler_title">Dan beberapa benda?</b>  <b class="spoiler_title">Dan beberapa tugas lagi?</b> <div class="spoiler_text">  Dengan pengaturan FreeRTOS tertentu, semua objek tidak muat di heap.  Dan kelihatannya seperti ini: programnya tidak berfungsi.  Yaitu  semuanya dikompilasi, dituangkan, tetapi kemudian mikrokontroler hanya hang dan hanya itu.  Dan coba tebak bahwa masalahnya persis ukuran tumpukan.  Saya harus menambah banyak menjadi 12kb. <br></div></div><br>  Berhenti, apa saja variabel xTimer, xQueue, xSemaphore, dan xMutex?  Bukankah mereka menggambarkan benda yang kita butuhkan?  Tidak, ini hanya handle - pointer ke struktur (buram) tertentu, yang menggambarkan objek sinkronisasi itu sendiri <br><br><pre> <code class="plaintext hljs">200009cc g O .bss 00000004 xTimer 200009d0 g O .bss 00000004 xSemaphore 200009cc g O .bss 00000004 xQueue 200009d4 g O .bss 00000004 xMutex</code> </pre><br>  Seperti yang telah saya sebutkan, saya mengusulkan untuk memperbaiki semua kekacauan ini dengan cara yang sama seperti pada artikel sebelumnya - kami akan mendistribusikan semua objek kami secara statis pada tahap kompilasi.  Fungsi distribusi statis menjadi tersedia jika parameter configSUPPORT_STATIC_ALLOCATION diatur ke 1 dalam file konfigurasi FreeRTOS. <br><br>  Mari kita mulai dengan garis.  Berikut adalah cara dokumentasi tentang FreeRTOS menawarkan untuk mengalokasikan antrian <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMessage</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucMessageID; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucData[ <span class="hljs-number"><span class="hljs-number">20</span></span> ]; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUEUE_LENGTH 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ITEM_SIZE sizeof( uint32_t ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// xQueueBuffer will hold the queue structure. StaticQueue_t xQueueBuffer; // ucQueueStorage will hold the items posted to the queue. Must be at least // [(queue length) * ( queue item size)] bytes long. uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // Create a queue capable of containing 10 uint32_t values. xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold. ITEM_SIZE // The size of each item in the queue &amp;( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue. &amp;xQueueBuffer ); // The buffer that will hold the queue structure. // The queue is guaranteed to be created successfully as no dynamic memory // allocation is used. Therefore xQueue1 is now a handle to a valid queue. // ... Rest of task code. }</span></span></span></span></code> </pre> <br>  Dalam contoh ini, antrian dijelaskan oleh tiga variabel: <br><br><ul><li>  Array ucQueueStorage adalah tempat elemen antrian akan ditempatkan.  Ukuran antrian ditetapkan oleh pengguna untuk setiap antrian secara terpisah. </li><li>  Struktur xQueueBuffer - di sini menampilkan deskripsi dan status antrian, ukuran saat ini, daftar tugas yang tertunda, serta atribut dan bidang lain yang diperlukan oleh FreeRTOS untuk bekerja dengan antrian.  Nama untuk variabel, menurut pendapat saya, tidak sepenuhnya berhasil, di FreeRTOS sendiri hal ini disebut QueueDefinition (deskripsi antrian). </li><li>  Variabel xQueue1 adalah pengidentifikasi antrian (pegangan).  Semua fungsi manajemen antrian, serta beberapa yang lain (misalnya, fungsi internal untuk bekerja dengan pengatur waktu, semaphore, dan mutex) menerima pegangan seperti itu.  Sebenarnya, ini hanya sebuah penunjuk ke QueueDefinition, tetapi kami tidak tahu ini (seolah-olah), dan oleh karena itu pegangan harus ditarik secara terpisah. </li></ul><br>  Untuk melakukan seperti pada contoh, tentu saja, tidak akan menjadi masalah.  Namun secara pribadi, saya tidak ingin memiliki sebanyak 3 variabel per entitas.  Kelas yang dapat merangkumnya sudah memintanya.  Hanya satu masalah - ukuran setiap antrian dapat bervariasi.  Di satu tempat Anda membutuhkan antrian yang lebih besar, di tempat lain beberapa elemen sudah cukup.  Karena kami ingin mengantri secara statis, kami harus menentukan ukuran ini pada waktu kompilasi.  Anda dapat menggunakan templat untuk ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t x QueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } };</code> </pre> <br>  Pada saat yang sama, fungsi mengirim dan menerima pesan, yang langsung nyaman bagi kami, juga menetap di kelas ini. <br><br>  Antrian akan dinyatakan sebagai variabel global, sesuatu seperti ini <br><br><pre> <code class="cpp hljs">Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue;</code> </pre> <br>  Pengiriman pesan <br><br><pre> <code class="cpp hljs"> xQueue.send(value);</code> </pre> <br>  Terima pesan <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value);</code> </pre><br>  Sekarang mari kita berurusan dengan semaphores.  Dan meskipun secara teknis (di dalam FreeRTOS) semaphore dan mutex diimplementasikan melalui antrian, secara semantik ini adalah 3 primitif berbeda.  Oleh karena itu, kami akan mengimplementasikannya dalam kelas yang terpisah. <br><br>  Implementasi kelas semaphore akan sangat sepele - hanya menyimpan beberapa variabel dan mendeklarasikan beberapa fungsi. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } };</code> </pre> <br>  Deklarasi semafor <br><br><pre> <code class="cpp hljs">Sema xSema;</code> </pre> <br>  Menangkap semaphore <br><br><pre> <code class="cpp hljs"> xSema.take();</code> </pre> <br>  Rilis Semaphore <br><br><pre> <code class="cpp hljs"> xSema.give();</code> </pre> <br>  Sekarang mutex <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } };</code> </pre> <br>  Seperti yang Anda lihat, kelas mutex hampir identik dengan kelas semaphore.  Tetapi seperti yang saya katakan secara semantik, ini adalah entitas yang berbeda.  Selain itu, antarmuka dari kelas-kelas ini tidak lengkap, dan mereka akan berkembang ke arah yang sama sekali berbeda.  Jadi, metode giveFromISR () dan takeFromISR () dapat ditambahkan ke semaphore untuk bekerja dengan semaphore dalam interrupt, sementara mutex hanya memiliki metode tryLock () yang ditambahkan - ia tidak memiliki operasi lain secara semantik. <br><br><div class="spoiler">  <b class="spoiler_title">Saya harap Anda tahu perbedaan antara semaphore biner dan mutex.</b> <div class="spoiler_text">  Saya selalu menanyakan pertanyaan ini saat wawancara dan, sayangnya, 90% kandidat tidak memahami perbedaan ini.  Bahkan, semafor dapat ditangkap dan dilepaskan dari utas yang berbeda.  Di atas, saya menyebutkan mode semafor sinyal-tunggu ketika satu utas mengirim sinyal (panggilan memberi ()), dan yang lainnya menunggu sinyal (dengan fungsi take ()). <br><br>  Mutex, sebaliknya, hanya bisa dilepaskan dari aliran yang sama (tugas) yang menangkapnya.  Saya tidak yakin FreeRTOS memonitor ini, tetapi beberapa sistem operasi (misalnya, Linux) mengikuti ini dengan sangat ketat. </div></div><br>  Mutex dapat digunakan dalam gaya C, mis.  langsung memanggil kunci () / membuka kunci ().  Tetapi karena kita menulis dalam C ++, kita dapat mengambil keuntungan dari pesona RAII dan menulis pembungkus yang lebih nyaman yang akan menangkap dan melepaskan mutex itu sendiri. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } };</code> </pre> <br>  Saat meninggalkan ruang lingkup, mutex akan dibebaskan secara otomatis. <br><br>  Ini sangat nyaman jika ada beberapa pintu keluar dari fungsi dan Anda tidak perlu terus mengingat kebutuhan akan sumber daya gratis. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } <span class="hljs-comment"><span class="hljs-comment">// mutex will be unlocked here</span></span></code> </pre> <br>  Sekarang giliran timer. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } };</code> </pre> <br>  Secara umum, semua yang ada di sini mirip dengan kelas-kelas sebelumnya, saya tidak akan membahas secara rinci.  Mungkin API menyisakan banyak yang diinginkan, baik, atau setidaknya membutuhkan ekspansi.  Tetapi tujuan saya adalah untuk menunjukkan prinsip, dan tidak membawanya ke keadaan produksi siap. <br><br>  Dan akhirnya, tugasnya.  Setiap tugas memiliki tumpukan dan harus ditempatkan di memori terlebih dahulu.  Kami akan menggunakan teknik yang sama seperti dengan antrian - kami akan menulis kelas templat <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } };</code> </pre> <br>  Karena objek tugas sekarang dinyatakan sebagai variabel global, mereka akan diinisialisasi sebagai variabel global - sebelum memanggil main ().  Ini berarti bahwa parameter yang ditransfer ke tugas juga harus diketahui pada tahap ini.  Nuansa ini harus diperhitungkan jika dalam kasus Anda sesuatu dilewatkan yang perlu dihitung sebelum membuat tugas (saya hanya punya NULL di sana).  Jika ini masih tidak sesuai dengan Anda, pertimbangkan opsi dengan variabel statis lokal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari artikel sebelumnya</a> . <br><br>  Kompilasi dan dapatkan kesalahan: <br><br><pre> <code class="plaintext hljs">tasks.c:(.text.vTaskStartScheduler+0x10): undefined reference to `vApplicationGetIdleTaskMemory' timers.c:(.text.xTimerCreateTimerTask+0x1a): undefined reference to `vApplicationGetTimerTaskMemory'</code> </pre> <br>  Ini masalahnya.  Setiap OS memiliki tugas khusus - Idle Task (tugas default, tugas tidak melakukan apa-apa).  Sistem operasi melakukan tugas ini jika semua tugas lain tidak dapat dilakukan (misalnya, tidur, atau menunggu sesuatu).  Secara umum, ini adalah tugas yang paling umum, hanya dengan prioritas terendah.  Tetapi di sini ia dibuat di dalam kernel FreeRTOS dan kami tidak dapat memengaruhi pembuatannya.  Tetapi karena kami mulai menempatkan tugas secara statis, kami perlu memberi tahu OS di mana Anda ingin menempatkan unit kontrol dan tumpukan tugas ini.  Itulah tujuan FreeRTOS dan meminta kami untuk mendefinisikan fungsi khusus vApplicationGetIdleTaskMemory (). <br><br>  Situasi serupa terjadi pada tugas pengatur waktu.  Pengatur waktu dalam sistem FreeRTOS tidak hidup sendiri - tugas khusus berputar di OS, yang melayani pengatur waktu ini.  Dan tugas ini juga membutuhkan blok kontrol dan tumpukan.  Dan seperti itu, OS meminta kami untuk menunjukkan di mana mereka menggunakan fungsi vApplicationGetTimerTaskMemory (). <br><br>  Fungsi-fungsi itu sendiri sepele dan hanya mengembalikan pointer yang sesuai ke objek yang dialokasikan secara statis. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> <br>  Mari kita lihat apa yang kita dapat. <br><br><div class="spoiler">  <b class="spoiler_title">Saya akan menyembunyikan kode pembantu di bawah spoiler, Anda baru saja melihatnya</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t xQueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xMutexControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } }; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> </div></div><br><br>  Kode untuk seluruh program. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Timer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pdTRUE, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vTimerCallback)</span></span></span></span>; Sema xSema; Mutex xMutex; Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue; Task&lt;configMINIMAL_STACK_SIZE&gt; task1(vTask1, <span class="hljs-string"><span class="hljs-string">"Task 1"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); Task&lt;configMINIMAL_STACK_SIZE&gt; task2(vTask2, <span class="hljs-string"><span class="hljs-string">"Task 2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTimerCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimerHandle_t pxTimer)</span></span></span><span class="hljs-function"> </span></span>{ xSema.give(); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { xSema.take(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = random(<span class="hljs-number"><span class="hljs-number">1000</span></span>); xQueue.send(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); xTimer.start(); vTaskStartScheduler(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br>  Anda dapat membongkar biner yang dihasilkan dan melihat apa dan bagaimana lokasinya (output dari objdump sedikit diwarnai untuk keterbacaan yang lebih baik): <br><br><pre> <code class="plaintext hljs">0x200000b0 .bss 512 vApplicationGetIdleTaskMemory::Idle_Stack 0x200002b0 .bss 92 vApplicationGetIdleTaskMemory::Idle_TCB 0x2000030c .bss 1024 vApplicationGetTimerTaskMemory::Timer_Stack 0x2000070c .bss 92 vApplicationGetTimerTaskMemory::Timer_TCB 0x200009c8 .bss 608 task1 0x20000c28 .bss 608 task2 0x20000e88 .bss 84 xMutex 0x20000edc .bss 4084 xQueue 0x20001ed0 .bss 84 xSema 0x20001f24 .bss 48 xTimer</code> </pre> <br>  Tujuan tercapai - sekarang semuanya dalam tampilan penuh.  Setiap objek terlihat dan ukurannya dapat dipahami (well, kecuali bahwa objek majemuk dari jenis Tugas mempertimbangkan semua suku cadangnya dalam satu bagian).  Statistik kompiler juga sangat akurat dan kali ini sangat berguna. <br><br><pre> <code class="plaintext hljs">Sketch uses 20,800 bytes (15%) of program storage space. Maximum is 131,072 bytes. Global variables use 9,332 bytes (45%) of dynamic memory, leaving 11,148 bytes for local variables. Maximum is 20,480 bytes.</code> </pre> <br><h2>  Kesimpulan </h2><br>  Meskipun FreeRTOS memungkinkan Anda untuk membuat dan menghapus tugas, antrian, semafor, dan mutex dengan cepat, dalam banyak kasus ini tidak perlu.  Sebagai aturan, itu sudah cukup untuk membuat semua objek di mulai sekali dan mereka akan bekerja sampai reboot berikutnya.  Dan ini adalah alasan yang baik untuk mendistribusikan benda-benda seperti itu secara statis pada tahap kompilasi.  Sebagai hasilnya, kita mendapatkan pemahaman yang jelas tentang memori yang ditempati oleh objek kita, di mana yang terletak dan berapa banyak memori yang tersisa. <br><br>  Jelas bahwa metode yang diusulkan hanya cocok untuk menempatkan objek yang masa pakainya sebanding dengan masa pakai seluruh aplikasi.  Jika tidak, Anda harus menggunakan memori dinamis. <br><br>  Selain penempatan statis objek FreeRTOS, kami juga menulis pembungkus yang nyaman di atas primitif FreeRTOS, yang memungkinkan kami untuk menyederhanakan kode klien dan juga merangkum <br><br>  Antarmuka dapat disederhanakan jika perlu (misalnya, tidak memeriksa kode kembali, atau tidak menggunakan batas waktu).  Perlu juga dicatat bahwa implementasinya tidak lengkap - saya tidak repot dengan implementasi semua metode yang mungkin untuk mengirim dan menerima pesan melalui antrian (misalnya, dari interupsi, mengirim ke awal atau akhir antrian), saya tidak mengimplementasikan primitif sinkronisasi dari interupsi, menghitung (non-biner) semaphore, dan masih banyak lagi. <br><br>  Saya terlalu malas untuk membawa kode ini ke "take and use" state, saya hanya ingin menunjukkan idenya.  Tapi siapa yang butuh perpustakaan siap pakai, saya baru saja menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan frt</a> .  Semua yang ada di dalamnya praktis sama, hanya diingatkan.  Ya, antarmuka sedikit berbeda. <br><br>  Contoh dari artikel ada di <a href="">sini</a> . <br><br>  Terima kasih semua telah membaca artikel ini sampai akhir.  Saya akan senang menerima kritik yang membangun.  Ini juga akan menarik bagi saya untuk membahas nuansa dalam komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459086/">https://habr.com/ru/post/id459086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459074/index.html">Petty little joy # 7: three untuk harga satu konsol animasi, algoritma dan debugging</a></li>
<li><a href="../id459078/index.html">CERN beralih ke perangkat lunak sumber terbuka - mengapa?</a></li>
<li><a href="../id459080/index.html">Fitur HttpUrlConnection dari java.net</a></li>
<li><a href="../id459082/index.html">Siapa eidetik, bagaimana ingatan salah bekerja, dan tiga mitos populer tentang ingatan</a></li>
<li><a href="../id459084/index.html">Sedikit tentang Google Home Hub, atau bagaimana saya membeli bingkai foto seharga 130 Euro</a></li>
<li><a href="../id459088/index.html">Metode segmentasi titik dalam Point Clouds</a></li>
<li><a href="../id459090/index.html">Bawa pengalaman pengembangan Linux Anda di Windows ke level berikutnya dengan WSL dan Visual Studio Code Remote</a></li>
<li><a href="../id459092/index.html">X.Spectator - pemantauan negara dalam .NET</a></li>
<li><a href="../id459094/index.html">C # atau Java? TypeScript atau JavaScript? Pembelajaran berbasis mesin klasifikasi bahasa pemrograman</a></li>
<li><a href="../id459098/index.html">Registry Paket GitHub akan mendukung paket Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>