<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💯 🎞️ 🐩 Nous écrivons un traducteur simple en Lisp - III 🆑 🧑🏽‍🤝‍🧑🏼 👨‍❤️‍👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article précédent 

 Erreurs, erreurs, erreurs ... 
 Un bon programme doit être protégé contre les erreurs des utilisateurs. C'est absolument certain....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous écrivons un traducteur simple en Lisp - III</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423663/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article précédent</a> <br><br><h3>  Erreurs, erreurs, erreurs ... </h3><br>  Un bon programme doit être protégé contre les erreurs des utilisateurs.  C'est absolument certain.  Les erreurs doivent être traitées, et encore mieux prévenues (prévenir vaut toujours mieux que guérir!).  Voltige - construisez donc un dialogue avec l'utilisateur afin que ce dernier ne puisse tout simplement pas se tromper. <br><a name="habracut"></a><br>  Par exemple, si l'utilisateur doit entrer un entier positif dans le champ de saisie, alors, bien sûr, vous pouvez analyser la réponse, et si vous trouvez des caractères non numériques, donner un avertissement et demander à l'utilisateur de répéter la saisie.  Mais il vaut mieux interdire tout simplement la saisie de caractères non numériques! <br><br>  Malheureusement, une telle technique ne peut pas toujours être appliquée.  En particulier, la variété des modèles venant à l'entrée du traducteur est trop grande pour simplement «couper les mauvais» en définissant le masque de saisie. <br><br>  Une personne a le privilège de faire des erreurs et le traducteur doit, en cas de saisie de constructions linguistiques incorrectes, donner un diagnostic clair et, si possible, continuer d'analyser le texte source pour identifier toutes les erreurs.  L'utilisateur ne l'aimera probablement pas vraiment si le traducteur détecte les erreurs «une à la fois».  Et il est absolument inacceptable de reconnaître une situation dans laquelle le programme se bloque avec un message d'erreur système. <br>  Dans cet article, nous allons passer en revue le code développé précédemment de manière critique et essayer d'empêcher (traiter) les erreurs possibles. <br><br>  Commençons par la première fonction de démarrage.  Que fait-elle?  Elle prend le nom du fichier d'entrée, l'ouvre et traite ligne par ligne.  Pour de tels programmes, le scénario d'interaction avec l'utilisateur est déjà «réglé» - il peut être considéré comme canonique: <br><br><ul><li>  Si le nom de fichier n'est pas spécifié, appelez la boîte de dialogue standard «Ouvrir»; </li><li>  Si l'utilisateur a cliqué sur le bouton «refuser» dans la boîte de dialogue «Ouvrir» - arrêtez; </li><li>  Vérifiez si le fichier avec le nom donné / entré existe.  S'il n'existe pas, émettez un message et quittez; </li><li>  Si le fichier spécifié existe, traitez-le. </li></ul><br>  Notre version de la procédure de démarrage ne satisfait pas ce scénario.  En fait, regardez le code ci-dessous: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* …) <span class="hljs-comment"><span class="hljs-comment">;;      (when (zerop (strLen fname)) (setq fname (sysGetOpenName (sysHome) "-|*.mbs"))) (let ((fi (gensym 'fi))) (filOpen fi fname _INPUT) (loop (let ((curr-proc (action-proc fi))) (when *flagerr* (return t)) (when (filEOF fi) (return t)) (eval curr-proc))) (filClose fi)) (when *flagerr* (printsline "****   ")))</span></span></code> </pre> <br>  La réponse négative de l'utilisateur n'est pas analysée, donc si le bouton "rejeter" est enfoncé, le programme "plantera".  L'existence du fichier n'est pas non plus analysée.  Malheureusement, cette faille ne se limite pas aux lacunes.  Évidemment, si la procédure mini-basique est la dernière du fichier d'entrée, l'analyse de la fin du fichier provoquera la rupture du cycle avant que la fonction générée ne soit chargée dans l'environnement Lisp. <br><br>  Corrigez ces défauts: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* … ) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">when</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*))</code> </pre><br>  Si le nom de fichier est spécifié et que le fichier existe, le traitement est effectué.  Sinon, l'un des messages est imprimé: «Le fichier n'existe pas» ou «Nom de fichier omis». <br>  Les actions suivantes sont exécutées séquentiellement dans le corps de la boucle principale: <br><br><ul><li>  La fonction action-proc est remplie.  Le résultat de son travail est stocké dans la variable locale curr-proc; </li><li>  Si le drapeau * flagerr * est levé, la boucle se rompt; </li><li>  Si la fonction action-proc a renvoyé un résultat non vide, la fonction générée est chargée dans l'environnement Lisp; </li><li>  Si la fin du fichier est atteinte, la boucle se rompt également. </li></ul><br>  Le code semblait être meilleur ... Mais une autre faille sérieuse est restée non résolue - une fois le traitement de la procédure contenant une ou plusieurs erreurs terminé, la boucle principale sera rompue et le programme se terminera sans regarder la partie de l'année d'origine située derrière la procédure avec des erreurs.  C'est mauvais - je voudrais que le traducteur produise toutes les erreurs qui peuvent être détectées à chaque démarrage. <br><br>  Pour corriger ce défaut, introduisons la variable globale «compteur d'erreurs», tout en traitant la procédure avec des erreurs, nous allons augmenter ce compteur.  Et l'indicateur d'erreur sera réinitialisé après le traitement de chaque procédure: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* …) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filCloseAll</span></span>) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *errcount*))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">not</span></span> *flagerr*)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*errcount*))</code> </pre><br>  Maintenant, la fonction de démarrage fonctionnera de manière acceptable.  Assurons-nous de cela.  Créez le fichier source suivant: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> bla-bla end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> bla-bla-bla print x end_proc</code> </pre><br>  Et «laissez passer» grâce à notre traducteur.  Nous obtenons: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0007</span></span> bla-bla ****  (BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0008</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-number"><span class="hljs-number">0010</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0011 * 0012 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0013</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0014</span></span> input x <span class="hljs-number"><span class="hljs-number">0015</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0016</span></span> print y <span class="hljs-number"><span class="hljs-number">0017</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-number"><span class="hljs-number">0019</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0020 * 0021 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0022</span></span> bla-bla-bla ****  (BLA - BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0023</span></span> print x <span class="hljs-number"><span class="hljs-number">0024</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0025</span></span> ****   </code> </pre><br>  Nous supposons que nous avons géré la fonction de démarrage.  Mais le «travail sur les bugs» ne fait que commencer.  Regardons la syntaxe de cette partie du langage que nous avons déjà implémentée. <br><br>  L'erreur de syntaxe la plus courante que les gens font le plus souvent est probablement une structure de crochets incorrecte (déséquilibrée ou dans le mauvais ordre entre parenthèses).  Rappelez-vous ce qui arrive à une ligne de code source pour un mini-programme de base après sa lecture.  La chaîne est analysée (divisée en jetons), puis la liste des jetons est traduite sous forme de liste interne.  Dans la liste des jetons, les parenthèses sont des jetons distincts et nous ne vérifions pas leur solde.  Cela pourrait être fait comme une fonction distincte, mais la liste des jetons est transmise à l'entrée de la fonction d'entrée, qui traduit la liste des lignes dans la liste Lisp.  Si une expression de chaîne incorrecte est transmise à l'entrée de la fonction d'entrée, la fonction renvoie une erreur. <br><br>  Gérons cette erreur. <br><br>  Dans HomeLisp, une construction est utilisée pour gérer les erreurs (essayez Expression-1 sauf Expression-1).  Cela fonctionne comme suit: <br><br><ul><li>  Une tentative est faite pour calculer l'expression-1.  Si la tentative réussit, le résultat du calcul est renvoyé comme résultat de l'ensemble du formulaire d'essai; </li><li>  Si une erreur se produit, alors l'expression-2 est calculée.  Dans le même temps, une fonction système sans paramètres (message d'erreur) est disponible, qui renvoie le texte du message d'erreur. </li></ul><br>  Sur la base de ce qui précède, le transfert vers le formulaire de liste peut être effectué comme suit: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  En cas d'erreur de conversion, un message système sera émis et, par conséquent, une liste d'un élément sera renvoyée - la ligne de code d'origine.  De plus, cette liste tombera (comme la prochaine déclaration) dans la procédure action-proc.  Et, bien sûr, il ne sera pas reconnu.  Cela générera un autre message d'erreur et le compilateur continuera de fonctionner.  Nous allons préparer le code source suivant et essayer de le traduire: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> print x end_proc</code> </pre><br>  On obtient le résultat attendu: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"y=(x^2))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0007</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0008</span></span> * <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0010 * 0011 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0012</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0013</span></span> input x <span class="hljs-number"><span class="hljs-number">0014</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0015</span></span> print y <span class="hljs-number"><span class="hljs-number">0016</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0017</span></span> * <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0019 * 0020 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0021</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"x=3+)x^2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0022</span></span> print x <span class="hljs-number"><span class="hljs-number">0023</span></span> end_proc ****   </code> </pre><br>  Jetons maintenant un regard critique sur le code qui convertit les expressions arithmétiques en notation de préfixe.  Ce code ne contient aucun moyen de corriger les erreurs utilisateur.  Malheureusement, ces erreurs peuvent être considérables.  Corrigeons cette erreur.  Pour commencer, essayons de traduire un code complètement innocent (en apparence): <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=6 y=-x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y end_proc</code> </pre><br>  L'émission se terminera par la «chute» du traducteur!  Une chute entraînera l'opérateur y = -x.  Quelle est la question?  Dans un moins unaire!  En convertissant une formule d'une forme infixe en une forme préfixée, nous ne pensions pas en quelque sorte que moins «à deux faces» - il y a un moins binaire (un signe d'opération), et il y a un moins unaire (signe d'un nombre).  Notre analyseur ne connaît pas cette différence - il considère que tous les inconvénients sont binaires ... Que faire maintenant?  Afin de ne pas détruire le code déjà fonctionnel, transformons tous les inconvénients unaires en binaires.  Comment?  Mais très simple.  Il est bien évident que le moins unaire ne «vit» que dans de telles constructions: <br><br>  "(-Quelque chose" <br>  "&gt; -Quelque chose" <br>  "&lt;-Quelque chose" <br>  "= Quelque chose" <br>  Eh bien, au tout début de la formule, il peut aussi se rencontrer.  Par conséquent, si, avant de pénétrer en jetons, nous effectuons les remplacements suivants: <br><br>  "(-Quelque chose" =&gt; "(0-quelque chose" <br>  "&gt; -Quelque chose" =&gt; "&gt; 0-quelque chose" <br>  "&lt;-Quelque chose" =&gt; "&lt;0-quelque chose" <br>  "= Quelque chose" =&gt; "= 0 quelque chose" <br><br>  et si la formule commence par un moins, nous attribuons zéro au début de la formule, alors tous les moins deviendront binaires et l'erreur sera éliminée radicalement.  Appelons la fonction qui effectuera la conversion au-dessus du nom prepro.  Voici à quoi cela pourrait ressembler: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> prepro (<span class="hljs-name"><span class="hljs-name">s</span></span>) (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">s0</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> s <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> s) s)) (<span class="hljs-name"><span class="hljs-name">s1</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s0 <span class="hljs-string"><span class="hljs-string">"(-"</span></span> <span class="hljs-string"><span class="hljs-string">"(0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s2</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s1 <span class="hljs-string"><span class="hljs-string">"=-"</span></span> <span class="hljs-string"><span class="hljs-string">"=0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s3</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s2 <span class="hljs-string"><span class="hljs-string">"&gt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s4</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s3 <span class="hljs-string"><span class="hljs-string">"&lt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;0-"</span></span>))) s4))</code> </pre><br>  Aucun commentaire spécial n'est requis ici.  Mais notre simple analyseur a un autre problème qui n'est pas tout à fait évident à première vue - les doubles signes des opérations.  Lorsque vous travaillez avec des formules, les signes «&gt;» et «=» côte à côte signifient une opération «&gt; =» (et doivent être un seul jeton!).  L'analyseur ne veut pas savoir cela - il fera de chacun des signes un jeton distinct.  Vous pouvez faire face à ce problème en consultant la liste des jetons reçus, et si les caractères correspondants sont côte à côte, en les combinant.  Nous nommons la fonction qui effectuera l'union sous le nom de «postpro».  Voici le code d'une éventuelle implémentation: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> postpro (<span class="hljs-name"><span class="hljs-name">lex-list</span></span>) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)) lex-list) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">c1</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> lex-list)) (<span class="hljs-name"><span class="hljs-name">c2</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> lex-list))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"="</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"!"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"/"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> c1 (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)))))))))</code> </pre><br>  De plus, comme nous le voyons, rien de spécial.  Mais maintenant, la fonction finale de la traduction de l'opérateur dans le formulaire de liste interne ressemblera à ceci: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> (<span class="hljs-name"><span class="hljs-name">prepro</span></span> txt) <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>))) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  Jetons maintenant un regard critique sur la fonction inf2ipn.  Quelles erreurs des utilisateurs peuvent le «blâmer»?  Nous avons déjà supprimé le déséquilibre des crochets ci-dessus.  Quoi de plus?  Deux signes d'opération ou deux opérandes, debout dans une rangée.  On pourrait analyser cela dans le code inf2ipn (et ceux qui le souhaitent peuvent le faire par eux-mêmes).  Mais nous «interceptons» ces erreurs au stade de la conversion de la formule du SCR en préfixe.  Et nous allons (juste au cas où) nous allons attraper toutes les erreurs qui peuvent survenir dans le processus de conversion de la formule d'infixe en préfixe.  Le meilleur endroit pour cela est la fonction wrapper i2p.  Maintenant, cela pourrait ressembler à ceci: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> i2p (<span class="hljs-name"><span class="hljs-name">f</span></span>) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> f)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  Et maintenant, nous allons empêcher l'apparition dans les formules de deux signes d'opération ou de deux opérandes d'affilée.  L'article précédent décrivait un algorithme pour traduire une formule d'un SCR en un préfixe.  Un signe de l'achèvement correct de cet algorithme est qu'à la dernière étape, la pile doit contenir une seule valeur.  Si ce n'est pas le cas, alors une erreur a été commise.  Et une autre situation erronée se produit dans le cas où la fonction est appelée avec le mauvais nombre (plus ou moins) de paramètres.  Ces situations doivent être «prises»: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> ipn2pref (<span class="hljs-name"><span class="hljs-name">f</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> f) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s)) (<span class="hljs-name"><span class="hljs-name">car</span></span> s) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>))) ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) ((<span class="hljs-name"><span class="hljs-name">is-op</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">ar</span></span> (<span class="hljs-name"><span class="hljs-name">arity</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> s) ar) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))))) ((<span class="hljs-name"><span class="hljs-name">atom</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">car</span></span> s)) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s))))))</code> </pre><br>  Jetons maintenant un «regard critique» sur le gestionnaire d'instructions proc.  Nous avons clairement raté deux points.  La première chose à faire est de ne pas oublier lors du traitement de la procédure de calculer son arité (le nombre d'arguments) et de modifier la variable globale * oplist * en conséquence.  Et la seconde est que les fonctions que nous générons ne renvoient pas la bonne valeur!  Plus précisément, du fait des fonctions générées par notre traducteur, la valeur du dernier formulaire calculé avant le retour sera restituée.  Pour garantir le retour de la valeur souhaitée, je propose de transférer la variable de résultat depuis Pascal.  Maintenant, si nécessaire, retournez la valeur souhaitée, il suffit que l'utilisateur attribue la valeur souhaitée à cette variable avant de quitter la fonction, et lors de la génération du corps de la fonction, nous devons insérer le résultat du nom dans le corps de la fonction avec la dernière expression.  Tout cela amène la fonction action-proc à: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> '((result <span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">length</span></span> proc-parm)) *oplist*))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) '=) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">action-set</span></span> stmt))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) (<span class="hljs-name"><span class="hljs-name">if</span></span> proc-name `(defun ,proc-name ,proc-parm (let ,lv ,@body result)) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  Nous nous arrêterons ici pour le moment (même si nous rencontrerons toujours des problèmes, et le code devra être finalisé; mais c'est le lot du programmeur ...) Et maintenant, nous allons considérer deux améliorations de notre langage qui sont appropriées à apporter dès maintenant. <br><br><h3>  Améliorations mineures ... </h3><br>  Dans un article précédent, j'ai écrit qu'il n'est pas pratique pour un programmeur si dans une langue un opérateur occupe exactement une ligne.  Il est nécessaire de fournir la possibilité d'écrire des instructions volumineuses sur plusieurs lignes.  Implémentons cela.  Ce n'est pas du tout difficile à faire.  Dans la procédure getLine, nous allons créer une variable locale dans laquelle nous accumulerons le texte lu (à condition que ce ne soit pas un commentaire et se termine par quelques caractères «_». Dès qu'une ligne significative avec une fin différente est fixée, nous renvoyons la valeur accumulée en tant que valeur. Voici le code: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> stri) <span class="hljs-number"><span class="hljs-number">2</span></span>)))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">return</span></span> res))))))</code> </pre><br>  Et la dernière amélioration.  Dans de nombreux langages de programmation, vous pouvez utiliser des opérandes logiques dans des expressions arithmétiques (qui dans ce cas sont calculées à zéro ou à un).  Cela donne au langage une expressivité supplémentaire et, soit dit en passant, est tout à fait conforme à l'esprit de base.  Dans notre mini-BASIC, une tentative de calcul de cette expression, par exemple, est: <br><br><pre> <code class="hljs lisp">z=(<span class="hljs-name"><span class="hljs-name">x&gt;y</span></span>)*5+(<span class="hljs-name"><span class="hljs-name">x&lt;=y</span></span>)*10</code> </pre><br>  provoquera une erreur d'exécution.  Et cela est compréhensible: en Lisp, l'expression (&gt; xy) est calculée à Nil ou T. Mais Nil / T ne peut pas être multiplié par 5 ... Cependant, ce problème est facile à aider.  Écrivons quelques macros simples qui remplacent le résultat des expressions de comparaison par 0/1 (au lieu de Nil / T): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $== (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $/= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre><br>  Maintenant, jetez un œil à la ligne de la fonction ipn2pref qui effectue le traitement de l'opération.  Voici la ligne: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  Ici (voiture f) est le nom de l'opération.  Écrivons une petite fonction pour remplacer les codes de comparaison: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> chng-comp (<span class="hljs-name"><span class="hljs-name">op</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">member</span></span> op '(= == /= &lt;&gt; &gt; &lt; &gt;= &lt;=)) (<span class="hljs-name"><span class="hljs-name">implode</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> '$ (<span class="hljs-name"><span class="hljs-name">explode</span></span> op))) op))</code> </pre><br>  La fonction vérifie si son argument est une opération de comparaison et, si nécessaire, ajoute le caractère «$» au début.  Maintenant, appelez-le au bon endroit de la fonction ipn2pref: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">chng-comp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  Quel sera le résultat?  Les opérations de comparaison seront remplacées par des appels à la macro correspondante et toutes les autres opérations ne changeront pas.  Si vous traduisez cette fonction: <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=1 y=2 result=(x&gt;y)*5+(x&lt;=y)*10 end_proc</code> </pre><br>  puis appelez-le, nous obtenons le résultat attendu. <br><br>  C'est tout pour aujourd'hui. <br><br>  Le code de cet article se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>ici.</b></a> <br>  À suivre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423663/">https://habr.com/ru/post/fr423663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423647/index.html">Créer un réseau neuronal simple</a></li>
<li><a href="../fr423649/index.html">"Kubernetes à tous les domaines!" - Entretien avec le comité de programme de la conférence DevOops</a></li>
<li><a href="../fr423651/index.html">Nous invitons tout le monde au hackathon SmartMail Hack: À propos de Bienvenue</a></li>
<li><a href="../fr423653/index.html">PsRealVehicle, ou plug-in Open Source Tank Physics dans Armored Warfare: Assault</a></li>
<li><a href="../fr423657/index.html">Je ne respecte pas l'encapsulation ou l'utilisation d'un autre type de table de méthodes pour appeler rapidement des méthodes privées</a></li>
<li><a href="../fr423667/index.html">L'histoire des premiers jeux vidéo à microprocesseur</a></li>
<li><a href="../fr423671/index.html">Les rivaux de Tesla reçoivent un investissement d'un milliard de dollars de l'Arabie saoudite</a></li>
<li><a href="../fr423673/index.html">Risques liés au développement de logiciels</a></li>
<li><a href="../fr423677/index.html">Pilotes Jetpack: Frankie West</a></li>
<li><a href="../fr423679/index.html">Une tâche avec un gratte-ciel et des œufs - pas la poubelle de Newton?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>