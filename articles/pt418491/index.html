<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 🤛🏿 🧑🏾‍🤝‍🧑🏼 Resistência à automação de teste 👦 🐟 🕺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apesar de as tecnologias de teste de unidade existirem há 30 anos (Kent Beck escreveu o artigo "Simple Smalltalk Testing: With Patterns" em 1989), nem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resistência à automação de teste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418491/"><p>  Apesar de as tecnologias de teste de unidade existirem há 30 anos (Kent Beck escreveu o artigo "Simple Smalltalk Testing: With Patterns" em 1989), nem todos os programadores são donos dessa tecnologia e nem todas as empresas fizeram do teste automático uma parte de sua cultura corporativa. .  Mesmo apesar das vantagens óbvias dos testes automáticos, a resistência comportamental ainda é bastante forte.  Quem tentou implementar testes automatizados sabe que sempre há alguma razão para que isso não possa ser feito. </p><br><p>  Da minha experiência pessoal em implementar métodos de programação confiáveis ​​em minha empresa, nas empresas que consultei, comunicando em conferências e também de fontes publicamente disponíveis, formulei objeções e resistências típicas que impedem a implementação de uma cultura de teste automático. </p><br><p>  Agrupei todas as objeções em uma pirâmide de programação confiável, que inclui quatro níveis: <a name="habracut"></a></p><br><ul><li>  <strong>A cultura profissional</strong> (o mais alto nível, a base da programação confiável) é um conjunto de normas, regras não escritas, crenças dos funcionários que o guiam em seu trabalho.  Por exemplo: “O envio de código descoberto por testes para o repositório é ruim”, “Silenciar os erros encontrados no código é uma pena”. </li><li>  <strong>Gestão</strong> são os procedimentos, políticas, regras adotadas pela organização, bem como a vontade (decisão) dos líderes.  Por exemplo: “Cada função de aplicativo desenvolvida deve passar um código de revisão.  Sem exceções! </li><li>  <strong>Métodos</strong> são abordagens científicas, métodos para resolver um problema específico.  Por exemplo: "Se a função do aplicativo for difícil de testar, você precisará aumentar a testabilidade do aplicativo aplicando o modelo de injeção de dependência". </li><li>  <strong>Tecnologias</strong> (o nível mais baixo) são linguagens de programação, bibliotecas, estruturas, ferramentas.  Por exemplo, JUnit, Selenium, XCTest e assim por diante. </li></ul><br><p><img src="https://habrastorage.org/webt/ky/wa/ev/kywaevzql1sl53klb8pzmazzwcm.png"></p><br><p>  Por que essa divisão é necessária?  Como o problema de um nível é resolvido por métodos do mesmo nível ou por métodos de nível superior.  Por exemplo, se não é habitual que uma organização escreva testes automáticos (o problema da cultura profissional), esse problema não pode ser resolvido descrevendo o processo de negócios de teste em detalhes (nível "gerenciamento") ou instalando uma estrutura moderna (nível "tecnologia").  Eu garanto que em uma semana ninguém fará testes, apesar do processo comercial aprovado. </p><br><h2 id="vozrazheniya-kulturnogo-urovnya">  Objeções culturais </h2><br><h3 id="moi-programmy-ne-lomayutsya-ya-ne-vizhu-nuzhdy-v-testirovanii">  “Meus programas não quebram.  Não vejo a necessidade de testar. " </h3><br><p>  Eu ouvi essa afirmação de iniciantes ou programadores excessivamente confiantes. <br>  Obviamente, uma vez que uma função escrita não possa ser interrompida por si mesma.  Mas aqui é importante entender que, com o tempo, o programa pode exigir suporte, a introdução de novas funções ou acréscimos às funções existentes.  A complexidade dos programas - o número de classes e as dependências entre elas - é bastante grande e, eventualmente, depois de criar outra nova função ou melhorar uma existente, um erro ocorrerá mais cedo ou mais tarde.  Um teste automático detectaria essa regressão. </p><br><p>  Além disso, muitas vezes essa objeção pode ser ouvida por programadores iniciantes que não têm nenhum conceito de teste.  Por exemplo, apenas falhas são consideradas uma avaria, não erros funcionais. </p><br><p>  Em uma das entrevistas que conduzi, ocorreu o seguinte diálogo: </p><br><p>  - Você tem as habilidades de teste automático? <br>  - Não, eu escrevi programas simples, não havia nada para quebrar. <br>  - Qual é a sua motivação para mudar de emprego? <br>  Quero escrever aplicações complexas. </p><br><p>  Eu sei muito bem como isso acaba.  O programador tem a confiança de desenvolver um programa mais complexo, mas ele não conhece os métodos de teste automático, não pode testar a aplicação qualitativamente e não consegue lidar com a escala do projeto, o que levará à interrupção do projeto, custo excessivo de desenvolvimento e perda de reputação.  Porque eu pessoalmente gerenciei projetos, onde não consegui lidar com a escala do projeto e falhei exatamente por causa da falta de testes automáticos. </p><br><h3 id="nezhelanie-brat-otvetstvennost-za-kachestvo-koda-za-testirovanie">  Relutância em assumir a responsabilidade pela qualidade do código, pelos testes. </h3><br><p>  Os testes automatizados são a única fonte de informações operacionais e objetivas sobre a verdadeira qualidade de um produto de software.  Em outras palavras, o programador sempre tem um supervisor nas costas, que pode reportar à gerência a qualquer momento o quão bem o programador faz seu trabalho.  Os testes automatizados permitem vincular a produtividade do trabalho não com tickets fechados no Jira, mas com a verdadeira qualidade do produto de software.  E aqui você já precisa pensar em como escrever de maneira confiável, para que todas as próximas alterações no código não quebrem as funções existentes.  Para que cada nova função funcione não apenas no script, quando tudo estiver bem, mas também processe corretamente os erros. </p><br><p>  Responsabilidade é o compromisso voluntário de garantir um resultado positivo do trabalho.  O funcionário aceita essa obrigação em virtude de seu caráter e educação.  Infelizmente, devido à crise cultural e profissional, nem todo programador está pronto para assumir essas obrigações. </p><br><h3 id="pishite-srazu-pravilno-bez-oshibok">  "Escreva agora mesmo sem erros" </h3><br><p>  Pessoas que não estão familiarizadas com o funcionamento do desenvolvimento de software podem ter uma atitude negativa em relação aos desenvolvedores que mencionam algum tipo de erro. </p><br><p>  - Vamos cobrir o aplicativo com testes automáticos. <br>  Porque? <br>  - Para garantir que tudo funcione corretamente e que não haja erros. <br>  - Você escreve com erros?  Você tem baixa qualificação?  Escreva imediatamente sem erros. <br>  "Sim, mas todo mundo comete erros ..." <br>  - Mas a empresa XYZ disse a um amigo que eles têm os principais programadores que escrevem sem erros! </p><br><p>  Assim, é difícil "vender" o desenvolvimento de testes para clientes que não são tecnicamente esclarecidos.  Como resultado, o gerenciamento é forçado a desenvolver um projeto sem testes automáticos, o que leva a problemas conhecidos. </p><br><h2 id="vozrazheniya-na-urovne-menedzhmenta">  Objeções de gerenciamento </h2><br><h3 id="c-testami-programmu-pisat-v-dva-raza-dolshe-my-ne-ulozhimsya-v-sroki">  “Com testes, escrever um programa é duas vezes maior.  Não cumpriremos os prazos. ” </h3><br><p>  À primeira vista, esta tese parece justa.  É realmente necessário gastar tempo do programador escrevendo testes.  Porém, programadores e gerenciamento não levam em consideração que o tempo total de desenvolvimento do produto inclui não apenas programação, mas também depuração e suporte, além do enorme custo do teste de regressão manual após as correções. </p><br><p>  Testes automatizados têm várias funções: </p><br><ol><li>  <strong>Verificando</strong> . <br>  1.1  Os testes verificam se o objeto de teste está funcionando corretamente. <br>  1.2  Os testes verificam a qualidade do trabalho do programador: se a tarefa está resolvida, se existem efeitos colaterais na forma de regressões. </li><li>  <strong>Diagnosticando</strong> .  Os testes de diagnóstico podem reduzir significativamente o tempo para procurar um defeito.  Os testes permitem determinar a localização do erro com precisão para a classe e método e, às vezes, com precisão para a linha de código. </li><li>  <strong>Automatizando</strong> .  Os testes permitem inserir rápida e facilmente o objeto de teste no estado desejado para depuração. </li><li>  <strong>Documentação</strong> . <br>  4.1  Os testes de aceitação registram os requisitos do cliente para o produto que está sendo desenvolvido. <br>  4.2  Os testes mostram exemplos de uso do componente desenvolvido, reduzindo assim o tempo gasto no estudo do trabalho do sistema por outro programador. </li></ol><br><p>  Em uma das organizações que consultei, o gerente resistiu à introdução de uma cultura de teste automático: </p><br><p>  - Mas afinal, escrevendo testes há muito tempo!  Não cumpriremos os prazos! <br>  - Você tem erros que procura e corrige há muito tempo? <br>  - Sim, existem alguns. <br>  - Qual é o caso mais difícil? <br>  - Pesquisamos um erro por 80 horas. <br>  - 80 horas são duas semanas de trabalho do programador.  Se você passasse uma semana inteira testando a automação, economizaria meses em diagnosticar e depurar seu aplicativo! </p><br><p>  Nossa organização tem o postulado: "Com testes, escrever um programa é duas vezes mais rápido!"  e este postulado não é discutido.  Somente o coeficiente 2 é discutido - às vezes existem 3 e 4. E alguns projetos simplesmente não podem ser concluídos sem testes automáticos competentes (veja o projeto sobrecarregado). </p><br><h3 id="u-nas-uzhe-est-otdel-ruchnogo-testirovaniya-pust-oni-i-testiruyut">  "Já temos um departamento de testes manuais, deixe-os testar." </h3><br><p>  À primeira vista, a separação de especializações em teste e programação parece lógica. </p><br><p>  Mas vejamos as desvantagens do teste manual: </p><br><ul><li>  É muito caro </li><li>  Demora muito tempo.  Por exemplo: o script de teste para o testador de aplicativo móvel "Cinema Online" dura 40 horas.  E isso é apenas para uma plataforma!  Se você precisar testar o aplicativo no iPhone, iPad, Apple TV, Android, Fire TV, precisará gastar 40 × 6 = 240 horas de tempo de trabalho, isto é, um mês e meio, o que é inaceitável para curtos ciclos de desenvolvimento. </li><li>  O teste manual está sujeito a erros humanos comuns - não fornece um resultado objetivo e verdadeiro. </li></ul><br><p>  Além disso, alguns tipos de testes não podem ser executados dentro de um tempo razoável, porque o número de combinações de formatos e vários scripts de teste é muito grande.  Por exemplo: </p><br><ol><li>  Função para importar arquivos CSV. </li><li>  Analisadores para documentos de texto. </li><li>  Instrumentos financeiros. </li></ol><br><h2 id="vozrazheniya-na-urovne-metodov">  Objeções no nível do método </h2><br><h3 id="neznanie-metodov-avtomaticheskogo-testirovaniya">  Ignorância de métodos de teste automático. </h3><br><p>  Devido à crise na educação, não há disciplinas de teste automático em nenhum lugar nas universidades.  Existem muito poucos cursos em escolas comerciais de TI.  E os cursos existentes são superficiais e de baixa qualidade.  Portanto, muitas vezes encontrei um estupor entre os programadores: eles não sabem como testar aplicativos não triviais (mais difícil que 2 + 2 = 4). </p><br><p>  De fato, a ciência dos testes é bastante extensa.  Por exemplo, nem todo programador responderá imediatamente às perguntas: a) o que é testabilidade?  b) o que é controlabilidade e observabilidade?  c) quais padrões de design melhoram a testabilidade do aplicativo?  E assim por diante </p><br><h3 id="programmisty-ne-znayut-chto-oni-pishut-kak-ono-vyglyadit-kakie-budut-funkcii-i-interfeysy">  Os programadores não sabem o que escrevem, como fica, quais funções e interfaces serão. </h3><br><p>  É muito difícil testar o que não está claro como parece.  Em outras palavras, sem os requisitos predefinidos para o aplicativo, o programador não pode entender o que é esperado dele. </p><br><p>  A peculiaridade de alguns projetos é que eles são desenvolvidos usando a tecnologia Produto Mínimo Viável, que em outras palavras pode ser descrita da seguinte forma: “Vamos fazer pelo menos algo pelo tempo mínimo e pelo orçamento mínimo”, e o programador é considerado pelo cliente ou gerência como analista, designer, arquiteto, programador e testador em uma garrafa.  Com essa abordagem, exclui-se o estágio formal de criação de um sistema de software: a definição da lógica de negócios, domínio, interfaces de componentes, bem como a organização interna do relacionamento entre eles.  Não há arquitetura formalizada, nem interfaces, nem processos de negócios prescritos - não está claro o que testar, através de quais interfaces e qual é o resultado esperado. </p><br><h3 id="netestoprigodnyy-kod">  Código inapropriado. </h3><br><p>  A testabilidade é uma propriedade do projeto que diz com que facilidade pode ser testada.  A adequação do teste é determinada por duas outras propriedades: controlabilidade e observabilidade.  Gerenciabilidade - uma propriedade que determina como é fácil inserir um aplicativo no estado desejado para teste (atender às pré-condições).  Observabilidade - com que facilidade é possível considerar o estado após o teste, compará-lo com o esperado. </p><br><p>  Por exemplo, a autenticação de dois fatores usando o SMS é muito difícil de testar automaticamente, porque a função de receber SMS está fora do escopo do ambiente de teste automatizado.  Esse sistema é inadequado. </p><br><p>  Diante de um sistema inadequado, o programador desiste e evita testar esse sistema. </p><br><h3 id="podgotovka-testovyh-dannyh">  Preparação de dados de teste. </h3><br><p>  Uma das resistências não óbvias é a preparação de dados e padrões de teste.  Por exemplo: o estado inicial do banco de dados no qual o teste é realizado.  A preparação dos dados de teste pode levar muito tempo e trabalho rotineiro, portanto esse trabalho é considerado ingrato e desinteressante entre os programadores. </p><br><p>  Solução: </p><br><ul><li>  desenvolvimento de valores e exemplos de referência na fase de desenvolvimento de testes de aceitação - eles também ajudarão a resolver conflitos com o cliente na fase de aceitação do trabalho; </li><li>  desenvolvimento de valores de referência na fase de projeto do sistema.  Por exemplo, solicitações e respostas HTTP padrão - ajudarão a integrar mais facilmente o cliente e o servidor; </li><li>  desenvolvimento de procedimentos especiais para montagem de bancos de dados, nos quais o estado necessário do banco de dados é criado automaticamente e não manualmente </li><li>  uso do modelo Mãe do Objeto [Fowler, Schuh, Peter e Stephanie Punke.  "Facilitando a criação de objetos de teste no XP."  XP Universe.  2003], que ajuda a alocar e inicializar facilmente objetos no estado requerido. </li></ul><br><h3 id="obsluzhivanie-testov">  Serviço de teste. </h3><br><p>  Durante o desenvolvimento de um projeto, os requisitos para ele (esclarecimento, mudança) podem mudar.  Ou refatoração interna pode ocorrer, o que levará a uma alteração nas interfaces de classe.  Com a mudança nos requisitos, os critérios de aceitação de uma função específica também serão alterados e, com eles, os testes.  Em algum momento, o programador pode se recusar a prestar serviços de manutenção aos testes - ou seja, mantê-los atualizados. </p><br><p>  Solução: </p><br><ul><li>  usando o modelo “adaptador” para dissociar a lógica do teste da interface que está sendo testada; </li><li>  uso de testes de alto nível (pepino, pepino, quando e quando); </li><li>  veja a solução para resistência "preparação de dados de teste". </li></ul><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Não há dúvida de que o software deve ser confiável: exceda as expectativas do cliente.  Testes automatizados não são o único, mas importante componente no desenvolvimento de software confiável. </p><br><p>  Formulei objeções e obstáculos típicos à implementação de testes automáticos, que encontrei pessoalmente em minha organização e nas organizações que consultei. </p><br><p>  O artigo descreve apenas problemas e mal toca em maneiras de resolvê-los.  Em geral, a estratégia para resolver esses problemas me parece assim: </p><br><ol><li>  Formação e promoção de uma nova cultura de design de TI, que é confiabilidade, orgulho e responsabilidade pessoal pelo resultado. </li><li>  Desenvolvimento de novos padrões elevados para teste de código. </li><li>  Desenvolvimento e implementação de cursos de treinamento. </li><li>  A introdução de motivação na carreira de programadores e gerentes, ligada à qualidade dos produtos de software em desenvolvimento, bem como às habilidades de teste automático. </li></ol><br><p>  O mais importante que consegui entender é que os problemas estão em diferentes níveis: tecnológico, metodológico, gerencial e cultural.  E eles precisam ser abordados em níveis apropriados.  É muito difícil implementar testes automatizados se o programador não for treinado em métodos de design adequados para teste ou se o gerenciamento não suportar uma cultura de programação confiável na organização. </p><br><p>  Serei grato por exemplos de sua prática de quão fácil ou difícil foi implementar testes automatizados em sua organização.  Que problemas você enfrentou?  Como você os resolveu? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418491/">https://habr.com/ru/post/pt418491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418481/index.html">A vida em Israel - alguns momentos relacionados à TI</a></li>
<li><a href="../pt418483/index.html">Como compactar o carregador de inicialização do STM8 para tamanho 8 bytes na memória FLASH</a></li>
<li><a href="../pt418485/index.html">Breaking Bad 3 - Atravesse o Forester escuro</a></li>
<li><a href="../pt418487/index.html">Sobre o trabalho na Alemanha</a></li>
<li><a href="../pt418489/index.html">Obras-primas da construção mundial de colunas: evolução de um padrão de três vias, estúdio cult da JBL</a></li>
<li><a href="../pt418493/index.html">Bluetooth História em primeira pessoa</a></li>
<li><a href="../pt418497/index.html">"Eu não te reconheço em maquiagem" (c)</a></li>
<li><a href="../pt418499/index.html">Experiência de atualização clássica do SAMBA no Debian 8</a></li>
<li><a href="../pt418501/index.html">Vítimas do RGPD: quem já parou de trabalhar devido a nova regulamentação de dados pessoais</a></li>
<li><a href="../pt418503/index.html">Após 2020, o Reino Unido adquirirá o primeiro espaçoporto - na Escócia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>