<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèø üé§ üçù Funktionales Denken. Teil 7 ‚ôéÔ∏è ü§∑üèæ üõÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir setzen unsere Artikelserie zur funktionalen Programmierung in F # fort. Heute haben wir ein sehr interessantes Thema: die Definition von Funktione...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Wir setzen unsere Artikelserie zur funktionalen Programmierung in F # fort.  Heute haben wir ein sehr interessantes Thema: die Definition von Funktionen.  Lassen Sie uns unter anderem √ºber anonyme Funktionen, Funktionen ohne Parameter, rekursive Funktionen, Kombinatoren und vieles mehr sprechen.  Schau unter die Katze! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºnfter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sechster Teil</a></strong> <a name="habracut"></a></li></ul><br><h1>  Funktionsdefinition </h1><br><p>  Wir wissen bereits, wie man regul√§re Funktionen mit der "let" -Syntax erstellt: </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  In diesem Artikel werden einige andere M√∂glichkeiten zum Erstellen von Funktionen sowie Tipps zu deren Definition vorgestellt. </p><br><h2>  Anonyme Funktionen (Lambdas) </h2><br><p>  Wenn Sie mit Lambdas in anderen Sprachen vertraut sind, werden Ihnen die folgenden Abs√§tze bekannt vorkommen.  Anonyme Funktionen (oder ‚ÄûLambda-Ausdr√ºcke‚Äú) sind wie folgt definiert: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Im Vergleich zu Lambdas aus C # gibt es zwei Unterschiede: </p><br><ul><li>  Lambdas sollten mit dem Schl√ºsselwort <code>fun</code> , das in C # nicht erforderlich ist </li><li>  Es wird ein einzelner Pfeil verwendet <code>-&gt;</code> anstelle von double <code>=&gt;</code> von C #. </li></ul><br><p>  Lambda-Definition der Additionsfunktion: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Gleiche Funktion in traditioneller Form: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambdas werden h√§ufig in Form kleiner Ausdr√ºcke verwendet oder wenn kein Wunsch besteht, eine separate Funktion f√ºr einen Ausdruck zu definieren.  Wie Sie bereits gesehen haben, ist dies bei der Arbeit mit Listen keine Seltenheit. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Beachten Sie, dass um Lambdas herum Klammern verwendet werden m√ºssen. </p><br><p>  Lambdas werden auch verwendet, wenn eine deutlich andere Funktion ben√∂tigt wird.  Zum Beispiel kann der zuvor diskutierte " <code>adderGenerator</code> ", den wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor besprochen haben,</a> mit Lambdas umgeschrieben werden. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  Die Lambda-Version ist etwas l√§nger, macht aber sofort deutlich, dass eine Zwischenfunktion zur√ºckgegeben wird. </p><br><p>  Lambdas k√∂nnen verschachtelt werden.  Ein weiteres Beispiel f√ºr eine <code>adderGenerator</code> Definition, diesmal nur f√ºr Lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Ist Ihnen klar, dass alle drei Definitionen gleichwertig sind? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Wenn nicht, lesen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel √ºber Curry erneut</a> .  Dies ist sehr wichtig f√ºr das Verst√§ndnis! </p><br><h2>  Mustervergleich </h2><br><p>  Wenn eine Funktion definiert ist, ist es m√∂glich, Parameter explizit an sie zu √ºbergeben, wie in den obigen Beispielen, aber es ist auch m√∂glich, direkt im Parameterabschnitt mit einer Vorlage zu vergleichen.  Mit anderen Worten, der Parameterabschnitt kann Muster (√ºbereinstimmende Muster) und nicht nur Bezeichner enthalten! </p><br><p>  Das folgende Beispiel zeigt die Verwendung von Mustern in einer Funktionsdefinition: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Diese Art des Vergleichs kann nur stattfinden, wenn die Entsprechung immer entscheidbar ist.  Beispielsweise k√∂nnen Sie Unionstypen und -listen auf diese Weise nicht abgleichen, da einige F√§lle nicht abgeglichen werden k√∂nnen. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  Der Compiler warnt vor unvollst√§ndigem Abgleich (eine leere Liste f√ºhrt zu einem Laufzeitfehler am Eingang dieser Funktion). </p><br><h2>  H√§ufiger Fehler: Tupel vs.  viele Parameter </h2><br><p>  Wenn Sie aus einer C-√§hnlichen Sprache stammen, kann das als einziges Argument der Funktion verwendete Tupel schmerzhaft einer Multiparameterfunktion √§hneln.  Das ist aber nicht dasselbe!  Wie ich bereits erw√§hnt habe, ist dies, wenn Sie ein Komma sehen, h√∂chstwahrscheinlich ein Tupel.  Parameter werden durch Leerzeichen getrennt. </p><br><p>  Verwirrungsbeispiel: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  Die erste Definition, " <code>addTwoParams</code> ", verwendet zwei Parameter, die durch ein Leerzeichen getrennt sind. </li><li>  Die zweite Definition, " <code>addTuple</code> ", verwendet einen Parameter.  Dieser Parameter bindet "x" und "y" aus dem Tupel und summiert sie. </li><li>  Die dritte Definition, " <code>addConfusingTuple</code> ", verwendet einen Parameter wie " <code>addTuple</code> ", aber der Trick besteht darin, dass dieses Tupel entpackt (an das Muster angepasst) und als Teil der Parameterdefinition mithilfe des Mustervergleichs gebunden wird.  Hinter den Kulissen geschieht alles genauso wie in <code>addTuple</code> . </li></ul><br><p>  Schauen wir uns die Signaturen an (schauen Sie sie sich immer an, wenn Sie sich bei etwas nicht sicher sind). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  Und jetzt hier: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Hier sehen wir einen Fehler im zweiten Aufruf. </p><br><p>  Erstens behandelt der Compiler <code>(1,2)</code> als verallgemeinertes Tupel des Formulars <code>('a * 'b)</code> , das er als ersten Parameter an <code>addTwoParams</code> zu √ºbergeben <code>addTwoParams</code> .  Danach beschwert er sich, dass der erwartete erste Parameter <code>addTwoParams</code> nicht <code>int</code> , sondern versucht wurde, ein Tupel zu √ºbergeben. </p><br><p>  Verwenden Sie ein Komma, um ein Tupel zu erstellen! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  Und umgekehrt, wenn Sie mehrere Argumente an eine Funktion √ºbergeben, die auf ein Tupel wartet, erhalten Sie auch einen unverst√§ndlichen Fehler. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Diesmal entschied der Compiler, dass <code>addConfusingTuple</code> nach <code>addConfusingTuple</code> zwei Argumenten als Curry verwendet werden sollte.  Und der Eintrag " <code>addConfusingTuple 1</code> " ist eine Teilanwendung und sollte eine Zwischenfunktion zur√ºckgeben.  Der Versuch, diese Zwischenfunktion mit dem Parameter "2" aufzurufen, l√∂st einen Fehler aus, weil  Es gibt keine Zwischenfunktion!  Wir sehen den gleichen Fehler wie im Kapitel √ºber Currying, in dem wir Probleme mit zu vielen Parametern besprochen haben. </p><br><h3>  Warum nicht Tupel als Parameter verwenden? </h3><br><p>  Die obige Diskussion der Tupel zeigt eine andere M√∂glichkeit, Funktionen mit vielen Parametern zu definieren: Anstatt sie separat zu √ºbergeben, k√∂nnen alle Parameter zu einer Struktur zusammengefasst werden.  Im folgenden Beispiel verwendet die Funktion einen einzelnen Parameter - ein Tupel aus drei Elementen. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Es ist zu beachten, dass sich die Signatur von der Signatur einer Funktion mit drei Parametern unterscheidet.  Es gibt nur einen Pfeil, einen Parameter und Sternchen, die auf das Tupel zeigen <code>(int*int*int)</code> . </p><br><p>  Wann m√ºssen Argumente mit separaten Parametern eingereicht werden und wann ein Tupel? </p><br><ul><li>  Wenn Tupel an sich bedeutsam sind.  Beispielsweise sind dreifache Tupel f√ºr Operationen im dreidimensionalen Raum bequemer als drei separate Koordinaten. </li><li>  Manchmal werden Tupel verwendet, um Daten, die zusammen gespeichert werden m√ºssen, in einer einzigen Struktur zu kombinieren.  Beispielsweise geben <code>TryParse</code> Methoden aus der .NET-Bibliothek das Ergebnis und eine boolesche Variable als Tupel zur√ºck.  Um jedoch eine gro√üe Menge verwandter Daten zu speichern, ist es besser, eine Klasse oder einen Datensatz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datensatz)</a> zu definieren. </li></ul><br><h3>  Sonderfall: .NET Library Tupel und Funktionen </h3><br><p>  Beim Aufrufen von .NET-Bibliotheken sind Kommas sehr h√§ufig! </p><br><p>  Sie alle akzeptieren Tupel und die Aufrufe sehen genauso aus wie in C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  Der Grund daf√ºr ist, dass die Funktionen von klassischem .NET nicht aktuell sind und nicht teilweise angewendet werden k√∂nnen.  <em>Alle</em> Parameter m√ºssen <em>immer</em> sofort √ºbertragen werden, und der naheliegendste Weg ist die Verwendung eines Tupels. </p><br><p>  Beachten Sie, dass diese Aufrufe nur wie das √úbertragen von Tupeln aussehen. Dies ist jedoch ein Sonderfall.  Sie k√∂nnen keine echten Tupel an solche Funktionen √ºbergeben: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Wenn Sie .NET-Funktionen teilweise anwenden m√∂chten, schreiben Sie einfach Wrapper dar√ºber, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor</a> oder wie unten gezeigt: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Anleitung zur Auswahl einzelner und gruppierter Parameter </h2><br><p>  Die Diskussion von Tupeln f√ºhrt zu einem allgemeineren Thema: Wann sollten Parameter getrennt und wann gruppiert werden? </p><br><p>  Sie sollten darauf achten, wie sich F # in dieser Hinsicht von C # unterscheidet.  In C # werden <em>immer</em> <em>alle</em> Parameter √ºbergeben, so dass diese Frage dort nicht einmal auftaucht!  Aufgrund der teilweisen Anwendung in F # k√∂nnen nur einige der Parameter dargestellt werden. Daher muss zwischen dem Fall, in dem die Parameter kombiniert werden sollen, und dem Fall, in dem sie unabh√§ngig sind, unterschieden werden. </p><br><p>  Allgemeine Empfehlungen zum Strukturieren von Parametern beim Entwerfen eigener Funktionen. </p><br><ul><li>  Im allgemeinen Fall ist es immer besser, separate Parameter zu verwenden, anstatt eine Struktur zu √ºbergeben, sei es ein Tupel oder ein Datensatz.  Dies erm√∂glicht ein flexibleres Verhalten, beispielsweise eine teilweise Anwendung. </li><li>  Wenn jedoch eine Gruppe von Parametern gleichzeitig √ºbergeben werden <em>muss,</em> sollte eine Art Gruppierungsmechanismus verwendet werden. </li></ul><br><p>  Mit anderen Worten, wenn Sie eine Funktion entwickeln, fragen Sie sich: "Kann ich diesen Parameter separat angeben?"  Wenn die Antwort Nein lautet, sollten die Parameter gruppiert werden. </p><br><p>  Schauen wir uns einige Beispiele an: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Stellen Sie schlie√ülich sicher, dass die Reihenfolge der Parameter bei der Teilanwendung hilfreich ist (siehe Handbuch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Warum habe ich <code>aName</code> in der letzten Funktion <code>myCredentials</code> vor <code>aName</code> ? </p><br><h2>  Funktionen ohne Parameter </h2><br><p>  Manchmal ben√∂tigen Sie m√∂glicherweise eine Funktion, die keine Parameter akzeptiert.  Zum Beispiel ben√∂tigen Sie die Funktion "Hallo Welt", die mehrfach aufgerufen werden kann.  Wie im vorherigen Abschnitt gezeigt, funktioniert die naive Definition nicht. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Dies kann jedoch behoben werden, indem der Funktion ein Einheitsparameter hinzugef√ºgt oder ein Lambda verwendet wird. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Danach sollte die Funktion immer mit dem Argument <code>unit</code> aufgerufen <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  Was passiert ziemlich oft bei der Interaktion mit .NET-Bibliotheken: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Denken Sie daran, rufen Sie sie mit <code>unit</code> ! </p><br><h2>  Neue Operatoren definieren </h2><br><p>  Sie k√∂nnen Funktionen mit einem oder mehreren Operatorzeichen definieren (eine Liste der Zeichen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Sie m√ºssen Zeichen um Klammern setzen, um Funktionen zu definieren. </p><br><p>  Operatoren, die mit <code>*</code> ben√∂tigen ein Leerzeichen zwischen der Klammer und <code>*</code> , weil  in F # <code>(*</code> fungiert als Anfang eines Kommentars (wie <code>/*...*/</code> in C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Einmal definiert, kann eine neue Funktion auf die √ºbliche Weise verwendet werden, wenn sie in Klammern gesetzt ist: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Wenn die Funktion mit zwei Parametern verwendet wird, k√∂nnen Sie den Infix-Operator-Datensatz ohne Klammern verwenden. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  Sie k√∂nnen auch Pr√§fixoperatoren definieren, die mit beginnen <code>!</code>  oder <code>~</code> (mit einigen Einschr√§nkungen siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  In F # ist das Definieren von Anweisungen eine ziemlich h√§ufige Operation, und viele Bibliotheken exportieren Anweisungen mit Namen wie <code>&gt;=&gt;</code> und <code>&lt;*&gt;</code> . </p><br><h2>  Punktfreier Stil </h2><br><p>  Wir haben bereits viele Beispiele f√ºr Funktionen gesehen, denen die neuesten Parameter fehlten, um das Chaos zu verringern.  Dieser Stil wird als <strong>punktfreier Stil</strong> oder <strong>stillschweigende Programmierung bezeichnet</strong> . </p><br><p>  Hier einige Beispiele: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Dieser Stil hat seine Vor- und Nachteile. </p><br><p>  Einer der Vorteile besteht darin, dass der Schwerpunkt auf der Zusammensetzung von Funktionen h√∂herer Ordnung liegt, anstatt sich mit Objekten auf niedriger Ebene zu besch√§ftigen.  Zum Beispiel ist " <code>(+) 1 &gt;&gt; (*) 2</code> " eine explizite Addition, gefolgt von einer Multiplikation.  Und " <code>List.reduce (+)</code> " macht deutlich, dass der Additionsvorgang unabh√§ngig von den <code>List.reduce (+)</code> wichtig ist. </p><br><p>  Ein sinnloser Stil erm√∂glicht es Ihnen, sich auf den grundlegenden Algorithmus zu konzentrieren und gemeinsame Merkmale im Code zu identifizieren.  Die oben verwendete " <code>reduce</code> " -Funktion ist ein gutes Beispiel.  Dieses Thema wird in einer geplanten Reihe zur Listenverarbeitung behandelt. </p><br><p>  Andererseits kann eine √ºberm√§√üige Verwendung eines solchen Stils den Code verdecken.  Explizite Parameter dienen als Dokumentation und ihre Namen (z. B. "Liste") erleichtern das Verst√§ndnis der Funktionsweise der Funktion. </p><br><p>  Wie alles in der Programmierung ist die beste Empfehlung, den Ansatz zu bevorzugen, der die gr√∂√üte Klarheit bietet. </p><br><h2>  Kombinatoren </h2><br><p>  " <strong>Kombinatoren</strong> " werden Funktionen genannt, deren Ergebnis nur von ihren Parametern abh√§ngt.  Dies bedeutet, dass keine Abh√§ngigkeit von der Au√üenwelt besteht und insbesondere keine anderen Funktionen oder globalen Werte diese beeinflussen k√∂nnen. </p><br><p>  In der Praxis bedeutet dies, dass kombinatorische Funktionen durch eine Kombination ihrer Parameter auf verschiedene Weise begrenzt werden. </p><br><p>  Wir haben bereits mehrere Kombinatoren gesehen: einen Rohr- und einen Kompositionsoperator.  Wenn Sie sich ihre Definitionen ansehen, ist es klar, dass sie die Parameter nur auf verschiedene Arten neu anordnen. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Andererseits sind Funktionen wie "printf", obwohl primitiv, keine Kombinatoren, da sie von der Au√üenwelt (E / A) abh√§ngig sind. </p><br><h3>  Kombinatorische V√∂gel </h3><br><p>  Kombinatoren sind die Grundlage eines ganzen Abschnitts der Logik (nat√ºrlich "kombinatorische Logik" genannt), der viele Jahre vor Computern und Programmiersprachen erfunden wurde.  Die kombinatorische Logik hat einen sehr gro√üen Einfluss auf die funktionale Programmierung. </p><br><p>  Um mehr √ºber Kombinatoren und kombinatorische Logik zu erfahren, empfehle ich Raymond Smullyans Buch "To Mock a Mockingbird".  Darin erkl√§rt er andere Kombinatoren und gibt ihnen phantasievoll <a href="">Vogelnamen</a> .  Hier sind einige Beispiele f√ºr Standardkombinatoren und ihre Vogelnamen: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Die Buchstabennamen sind Standard, sodass Sie den K-Kombinator an jeden weiterleiten k√∂nnen, der mit dieser Terminologie vertraut ist. </p><br><p>  Es stellt sich heraus, dass viele g√§ngige Programmiermuster durch diese Standardkombinatoren dargestellt werden k√∂nnen.  Zum Beispiel ist Turmfalke ein h√§ufiges Muster in der flie√üenden Benutzeroberfl√§che, in dem Sie etwas tun, aber das urspr√ºngliche Objekt zur√ºckgeben.  Thrush ist eine Pipe, Queer ist eine direkte Komposition und der Y-Kombinator leistet hervorragende Arbeit bei der Erstellung rekursiver Funktionen. </p><br><p>  Tats√§chlich gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekannten Satz,</a> dass jede berechenbare Funktion mit nur zwei grundlegenden Kombinatoren, Turmfalke und Starling, konstruiert werden kann. </p><br><h3>  Kombinatorische Bibliotheken </h3><br><p>  Kombinatorische Bibliotheken sind Bibliotheken, die viele kombinatorische Funktionen exportieren, die gemeinsam genutzt werden sollen.  Ein Benutzer einer solchen Bibliothek kann Funktionen leicht miteinander kombinieren, um noch gr√∂√üere und komplexere Funktionen wie W√ºrfel zu erhalten. </p><br><p>  Eine gut gestaltete Combiner-Bibliothek erm√∂glicht es Ihnen, sich auf Funktionen auf hoher Ebene zu konzentrieren und "Rauschen" auf niedriger Ebene zu verbergen.  Wir haben ihre Leistungsf√§higkeit bereits in mehreren Beispielen in der Reihe "Warum F # verwenden" gesehen, und das <code>List</code> Modul ist voll von solchen Funktionen. " <code>fold</code> " und " <code>map</code> " sind auch Kombinatoren, wenn Sie dar√ºber nachdenken. </p><br><p>  Ein weiterer Vorteil von Kombinatoren ist, dass sie die sicherste Art von Funktion sind.  Weil  Sie haben keine Abh√§ngigkeiten von der Au√üenwelt und k√∂nnen sich nicht √§ndern, wenn sich die globale Umgebung √§ndert.  Eine Funktion, die einen globalen Wert liest oder Bibliotheksfunktionen verwendet, kann zwischen Aufrufen unterbrochen werden, wenn sich der Kontext √§ndert.  Dies wird Kombinatoren niemals passieren. </p><br><p>  In F # stehen Kombinatorbibliotheken zum Parsen (FParsec), Erstellen von HTML, Testen von Frameworks usw. zur Verf√ºgung.  Wir werden sp√§ter in der n√§chsten Reihe Kombinatoren diskutieren und verwenden. </p><br><h2>  Rekursive Funktionen </h2><br><p>  Oft muss sich eine Funktion von ihrem K√∂rper aus auf sich selbst beziehen.  Ein klassisches Beispiel ist die Fibonacci-Funktion. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Leider kann diese Funktion nicht kompilieren: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Sie m√ºssen dem Compiler mit dem Schl√ºsselwort <code>rec</code> mitteilen, dass dies eine rekursive Funktion ist. </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Rekursive Funktionen und Datenstrukturen sind in der funktionalen Programmierung sehr verbreitet, und ich hoffe, dass ich sp√§ter eine ganze Reihe diesem Thema widmen kann. </p><br><h1>  Zus√§tzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials f√ºr F #, einschlie√ülich Materialien f√ºr diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links k√∂nnen hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # f√ºr Spa√ü und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere M√∂glichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schlie√ülich ist die F # Community sehr anf√§ngerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterst√ºtzt wird, mit Anf√§ngerr√§umen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen k√∂nnen</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li><li>  Raum #en_general im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  √úber √úbersetzungsautoren </h2><br><p>  √úbersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  √úbersetzungs- und redaktionelle √Ñnderungen wurden durch die Bem√ºhungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> f√ºr die Vorbereitung dieses Artikels zur Ver√∂ffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433398/">https://habr.com/ru/post/de433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433386/index.html">Verwendung einer Computer Vision zur Beurteilung des Fahrzeugzustands. Erleben Sie Yandex.Taxi</a></li>
<li><a href="../de433388/index.html">Formel-Fan oder warum wir Spiele spielen</a></li>
<li><a href="../de433390/index.html">Yandex hat sich dem Schutz von Linux und der IT-Branche vor Patenttrolling angeschlossen</a></li>
<li><a href="../de433392/index.html">Snom D725 IP-Telefon Bewertung</a></li>
<li><a href="../de433396/index.html">Frontend 2018: Ergebnisse des Jahres</a></li>
<li><a href="../de433400/index.html">React Tutorial Teil 2: Funktionskomponenten</a></li>
<li><a href="../de433402/index.html">Funktionales Denken. Teil 8</a></li>
<li><a href="../de433404/index.html">React Tutorial Teil 3: Komponentendateien, Projektstruktur</a></li>
<li><a href="../de433406/index.html">Funktionales Denken. Teil 9</a></li>
<li><a href="../de433408/index.html">Effiziente Speicherbehandlung in Node.js.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>