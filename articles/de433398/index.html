<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏿 🎤 🍝 Funktionales Denken. Teil 7 ♎️ 🤷🏾 🛃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir setzen unsere Artikelserie zur funktionalen Programmierung in F # fort. Heute haben wir ein sehr interessantes Thema: die Definition von Funktione...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Wir setzen unsere Artikelserie zur funktionalen Programmierung in F # fort.  Heute haben wir ein sehr interessantes Thema: die Definition von Funktionen.  Lassen Sie uns unter anderem über anonyme Funktionen, Funktionen ohne Parameter, rekursive Funktionen, Kombinatoren und vieles mehr sprechen.  Schau unter die Katze! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fünfter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sechster Teil</a></strong> <a name="habracut"></a></li></ul><br><h1>  Funktionsdefinition </h1><br><p>  Wir wissen bereits, wie man reguläre Funktionen mit der "let" -Syntax erstellt: </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  In diesem Artikel werden einige andere Möglichkeiten zum Erstellen von Funktionen sowie Tipps zu deren Definition vorgestellt. </p><br><h2>  Anonyme Funktionen (Lambdas) </h2><br><p>  Wenn Sie mit Lambdas in anderen Sprachen vertraut sind, werden Ihnen die folgenden Absätze bekannt vorkommen.  Anonyme Funktionen (oder „Lambda-Ausdrücke“) sind wie folgt definiert: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  Im Vergleich zu Lambdas aus C # gibt es zwei Unterschiede: </p><br><ul><li>  Lambdas sollten mit dem Schlüsselwort <code>fun</code> , das in C # nicht erforderlich ist </li><li>  Es wird ein einzelner Pfeil verwendet <code>-&gt;</code> anstelle von double <code>=&gt;</code> von C #. </li></ul><br><p>  Lambda-Definition der Additionsfunktion: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Gleiche Funktion in traditioneller Form: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Lambdas werden häufig in Form kleiner Ausdrücke verwendet oder wenn kein Wunsch besteht, eine separate Funktion für einen Ausdruck zu definieren.  Wie Sie bereits gesehen haben, ist dies bei der Arbeit mit Listen keine Seltenheit. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Beachten Sie, dass um Lambdas herum Klammern verwendet werden müssen. </p><br><p>  Lambdas werden auch verwendet, wenn eine deutlich andere Funktion benötigt wird.  Zum Beispiel kann der zuvor diskutierte " <code>adderGenerator</code> ", den wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor besprochen haben,</a> mit Lambdas umgeschrieben werden. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  Die Lambda-Version ist etwas länger, macht aber sofort deutlich, dass eine Zwischenfunktion zurückgegeben wird. </p><br><p>  Lambdas können verschachtelt werden.  Ein weiteres Beispiel für eine <code>adderGenerator</code> Definition, diesmal nur für Lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Ist Ihnen klar, dass alle drei Definitionen gleichwertig sind? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  Wenn nicht, lesen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel über Curry erneut</a> .  Dies ist sehr wichtig für das Verständnis! </p><br><h2>  Mustervergleich </h2><br><p>  Wenn eine Funktion definiert ist, ist es möglich, Parameter explizit an sie zu übergeben, wie in den obigen Beispielen, aber es ist auch möglich, direkt im Parameterabschnitt mit einer Vorlage zu vergleichen.  Mit anderen Worten, der Parameterabschnitt kann Muster (übereinstimmende Muster) und nicht nur Bezeichner enthalten! </p><br><p>  Das folgende Beispiel zeigt die Verwendung von Mustern in einer Funktionsdefinition: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Diese Art des Vergleichs kann nur stattfinden, wenn die Entsprechung immer entscheidbar ist.  Beispielsweise können Sie Unionstypen und -listen auf diese Weise nicht abgleichen, da einige Fälle nicht abgeglichen werden können. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  Der Compiler warnt vor unvollständigem Abgleich (eine leere Liste führt zu einem Laufzeitfehler am Eingang dieser Funktion). </p><br><h2>  Häufiger Fehler: Tupel vs.  viele Parameter </h2><br><p>  Wenn Sie aus einer C-ähnlichen Sprache stammen, kann das als einziges Argument der Funktion verwendete Tupel schmerzhaft einer Multiparameterfunktion ähneln.  Das ist aber nicht dasselbe!  Wie ich bereits erwähnt habe, ist dies, wenn Sie ein Komma sehen, höchstwahrscheinlich ein Tupel.  Parameter werden durch Leerzeichen getrennt. </p><br><p>  Verwirrungsbeispiel: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  Die erste Definition, " <code>addTwoParams</code> ", verwendet zwei Parameter, die durch ein Leerzeichen getrennt sind. </li><li>  Die zweite Definition, " <code>addTuple</code> ", verwendet einen Parameter.  Dieser Parameter bindet "x" und "y" aus dem Tupel und summiert sie. </li><li>  Die dritte Definition, " <code>addConfusingTuple</code> ", verwendet einen Parameter wie " <code>addTuple</code> ", aber der Trick besteht darin, dass dieses Tupel entpackt (an das Muster angepasst) und als Teil der Parameterdefinition mithilfe des Mustervergleichs gebunden wird.  Hinter den Kulissen geschieht alles genauso wie in <code>addTuple</code> . </li></ul><br><p>  Schauen wir uns die Signaturen an (schauen Sie sie sich immer an, wenn Sie sich bei etwas nicht sicher sind). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  Und jetzt hier: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Hier sehen wir einen Fehler im zweiten Aufruf. </p><br><p>  Erstens behandelt der Compiler <code>(1,2)</code> als verallgemeinertes Tupel des Formulars <code>('a * 'b)</code> , das er als ersten Parameter an <code>addTwoParams</code> zu übergeben <code>addTwoParams</code> .  Danach beschwert er sich, dass der erwartete erste Parameter <code>addTwoParams</code> nicht <code>int</code> , sondern versucht wurde, ein Tupel zu übergeben. </p><br><p>  Verwenden Sie ein Komma, um ein Tupel zu erstellen! </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  Und umgekehrt, wenn Sie mehrere Argumente an eine Funktion übergeben, die auf ein Tupel wartet, erhalten Sie auch einen unverständlichen Fehler. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Diesmal entschied der Compiler, dass <code>addConfusingTuple</code> nach <code>addConfusingTuple</code> zwei Argumenten als Curry verwendet werden sollte.  Und der Eintrag " <code>addConfusingTuple 1</code> " ist eine Teilanwendung und sollte eine Zwischenfunktion zurückgeben.  Der Versuch, diese Zwischenfunktion mit dem Parameter "2" aufzurufen, löst einen Fehler aus, weil  Es gibt keine Zwischenfunktion!  Wir sehen den gleichen Fehler wie im Kapitel über Currying, in dem wir Probleme mit zu vielen Parametern besprochen haben. </p><br><h3>  Warum nicht Tupel als Parameter verwenden? </h3><br><p>  Die obige Diskussion der Tupel zeigt eine andere Möglichkeit, Funktionen mit vielen Parametern zu definieren: Anstatt sie separat zu übergeben, können alle Parameter zu einer Struktur zusammengefasst werden.  Im folgenden Beispiel verwendet die Funktion einen einzelnen Parameter - ein Tupel aus drei Elementen. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Es ist zu beachten, dass sich die Signatur von der Signatur einer Funktion mit drei Parametern unterscheidet.  Es gibt nur einen Pfeil, einen Parameter und Sternchen, die auf das Tupel zeigen <code>(int*int*int)</code> . </p><br><p>  Wann müssen Argumente mit separaten Parametern eingereicht werden und wann ein Tupel? </p><br><ul><li>  Wenn Tupel an sich bedeutsam sind.  Beispielsweise sind dreifache Tupel für Operationen im dreidimensionalen Raum bequemer als drei separate Koordinaten. </li><li>  Manchmal werden Tupel verwendet, um Daten, die zusammen gespeichert werden müssen, in einer einzigen Struktur zu kombinieren.  Beispielsweise geben <code>TryParse</code> Methoden aus der .NET-Bibliothek das Ergebnis und eine boolesche Variable als Tupel zurück.  Um jedoch eine große Menge verwandter Daten zu speichern, ist es besser, eine Klasse oder einen Datensatz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datensatz)</a> zu definieren. </li></ul><br><h3>  Sonderfall: .NET Library Tupel und Funktionen </h3><br><p>  Beim Aufrufen von .NET-Bibliotheken sind Kommas sehr häufig! </p><br><p>  Sie alle akzeptieren Tupel und die Aufrufe sehen genauso aus wie in C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  Der Grund dafür ist, dass die Funktionen von klassischem .NET nicht aktuell sind und nicht teilweise angewendet werden können.  <em>Alle</em> Parameter müssen <em>immer</em> sofort übertragen werden, und der naheliegendste Weg ist die Verwendung eines Tupels. </p><br><p>  Beachten Sie, dass diese Aufrufe nur wie das Übertragen von Tupeln aussehen. Dies ist jedoch ein Sonderfall.  Sie können keine echten Tupel an solche Funktionen übergeben: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Wenn Sie .NET-Funktionen teilweise anwenden möchten, schreiben Sie einfach Wrapper darüber, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor</a> oder wie unten gezeigt: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Anleitung zur Auswahl einzelner und gruppierter Parameter </h2><br><p>  Die Diskussion von Tupeln führt zu einem allgemeineren Thema: Wann sollten Parameter getrennt und wann gruppiert werden? </p><br><p>  Sie sollten darauf achten, wie sich F # in dieser Hinsicht von C # unterscheidet.  In C # werden <em>immer</em> <em>alle</em> Parameter übergeben, so dass diese Frage dort nicht einmal auftaucht!  Aufgrund der teilweisen Anwendung in F # können nur einige der Parameter dargestellt werden. Daher muss zwischen dem Fall, in dem die Parameter kombiniert werden sollen, und dem Fall, in dem sie unabhängig sind, unterschieden werden. </p><br><p>  Allgemeine Empfehlungen zum Strukturieren von Parametern beim Entwerfen eigener Funktionen. </p><br><ul><li>  Im allgemeinen Fall ist es immer besser, separate Parameter zu verwenden, anstatt eine Struktur zu übergeben, sei es ein Tupel oder ein Datensatz.  Dies ermöglicht ein flexibleres Verhalten, beispielsweise eine teilweise Anwendung. </li><li>  Wenn jedoch eine Gruppe von Parametern gleichzeitig übergeben werden <em>muss,</em> sollte eine Art Gruppierungsmechanismus verwendet werden. </li></ul><br><p>  Mit anderen Worten, wenn Sie eine Funktion entwickeln, fragen Sie sich: "Kann ich diesen Parameter separat angeben?"  Wenn die Antwort Nein lautet, sollten die Parameter gruppiert werden. </p><br><p>  Schauen wir uns einige Beispiele an: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Stellen Sie schließlich sicher, dass die Reihenfolge der Parameter bei der Teilanwendung hilfreich ist (siehe Handbuch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Warum habe ich <code>aName</code> in der letzten Funktion <code>myCredentials</code> vor <code>aName</code> ? </p><br><h2>  Funktionen ohne Parameter </h2><br><p>  Manchmal benötigen Sie möglicherweise eine Funktion, die keine Parameter akzeptiert.  Zum Beispiel benötigen Sie die Funktion "Hallo Welt", die mehrfach aufgerufen werden kann.  Wie im vorherigen Abschnitt gezeigt, funktioniert die naive Definition nicht. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Dies kann jedoch behoben werden, indem der Funktion ein Einheitsparameter hinzugefügt oder ein Lambda verwendet wird. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Danach sollte die Funktion immer mit dem Argument <code>unit</code> aufgerufen <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  Was passiert ziemlich oft bei der Interaktion mit .NET-Bibliotheken: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Denken Sie daran, rufen Sie sie mit <code>unit</code> ! </p><br><h2>  Neue Operatoren definieren </h2><br><p>  Sie können Funktionen mit einem oder mehreren Operatorzeichen definieren (eine Liste der Zeichen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Sie müssen Zeichen um Klammern setzen, um Funktionen zu definieren. </p><br><p>  Operatoren, die mit <code>*</code> benötigen ein Leerzeichen zwischen der Klammer und <code>*</code> , weil  in F # <code>(*</code> fungiert als Anfang eines Kommentars (wie <code>/*...*/</code> in C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Einmal definiert, kann eine neue Funktion auf die übliche Weise verwendet werden, wenn sie in Klammern gesetzt ist: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Wenn die Funktion mit zwei Parametern verwendet wird, können Sie den Infix-Operator-Datensatz ohne Klammern verwenden. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  Sie können auch Präfixoperatoren definieren, die mit beginnen <code>!</code>  oder <code>~</code> (mit einigen Einschränkungen siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  In F # ist das Definieren von Anweisungen eine ziemlich häufige Operation, und viele Bibliotheken exportieren Anweisungen mit Namen wie <code>&gt;=&gt;</code> und <code>&lt;*&gt;</code> . </p><br><h2>  Punktfreier Stil </h2><br><p>  Wir haben bereits viele Beispiele für Funktionen gesehen, denen die neuesten Parameter fehlten, um das Chaos zu verringern.  Dieser Stil wird als <strong>punktfreier Stil</strong> oder <strong>stillschweigende Programmierung bezeichnet</strong> . </p><br><p>  Hier einige Beispiele: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Dieser Stil hat seine Vor- und Nachteile. </p><br><p>  Einer der Vorteile besteht darin, dass der Schwerpunkt auf der Zusammensetzung von Funktionen höherer Ordnung liegt, anstatt sich mit Objekten auf niedriger Ebene zu beschäftigen.  Zum Beispiel ist " <code>(+) 1 &gt;&gt; (*) 2</code> " eine explizite Addition, gefolgt von einer Multiplikation.  Und " <code>List.reduce (+)</code> " macht deutlich, dass der Additionsvorgang unabhängig von den <code>List.reduce (+)</code> wichtig ist. </p><br><p>  Ein sinnloser Stil ermöglicht es Ihnen, sich auf den grundlegenden Algorithmus zu konzentrieren und gemeinsame Merkmale im Code zu identifizieren.  Die oben verwendete " <code>reduce</code> " -Funktion ist ein gutes Beispiel.  Dieses Thema wird in einer geplanten Reihe zur Listenverarbeitung behandelt. </p><br><p>  Andererseits kann eine übermäßige Verwendung eines solchen Stils den Code verdecken.  Explizite Parameter dienen als Dokumentation und ihre Namen (z. B. "Liste") erleichtern das Verständnis der Funktionsweise der Funktion. </p><br><p>  Wie alles in der Programmierung ist die beste Empfehlung, den Ansatz zu bevorzugen, der die größte Klarheit bietet. </p><br><h2>  Kombinatoren </h2><br><p>  " <strong>Kombinatoren</strong> " werden Funktionen genannt, deren Ergebnis nur von ihren Parametern abhängt.  Dies bedeutet, dass keine Abhängigkeit von der Außenwelt besteht und insbesondere keine anderen Funktionen oder globalen Werte diese beeinflussen können. </p><br><p>  In der Praxis bedeutet dies, dass kombinatorische Funktionen durch eine Kombination ihrer Parameter auf verschiedene Weise begrenzt werden. </p><br><p>  Wir haben bereits mehrere Kombinatoren gesehen: einen Rohr- und einen Kompositionsoperator.  Wenn Sie sich ihre Definitionen ansehen, ist es klar, dass sie die Parameter nur auf verschiedene Arten neu anordnen. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Andererseits sind Funktionen wie "printf", obwohl primitiv, keine Kombinatoren, da sie von der Außenwelt (E / A) abhängig sind. </p><br><h3>  Kombinatorische Vögel </h3><br><p>  Kombinatoren sind die Grundlage eines ganzen Abschnitts der Logik (natürlich "kombinatorische Logik" genannt), der viele Jahre vor Computern und Programmiersprachen erfunden wurde.  Die kombinatorische Logik hat einen sehr großen Einfluss auf die funktionale Programmierung. </p><br><p>  Um mehr über Kombinatoren und kombinatorische Logik zu erfahren, empfehle ich Raymond Smullyans Buch "To Mock a Mockingbird".  Darin erklärt er andere Kombinatoren und gibt ihnen phantasievoll <a href="">Vogelnamen</a> .  Hier sind einige Beispiele für Standardkombinatoren und ihre Vogelnamen: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Die Buchstabennamen sind Standard, sodass Sie den K-Kombinator an jeden weiterleiten können, der mit dieser Terminologie vertraut ist. </p><br><p>  Es stellt sich heraus, dass viele gängige Programmiermuster durch diese Standardkombinatoren dargestellt werden können.  Zum Beispiel ist Turmfalke ein häufiges Muster in der fließenden Benutzeroberfläche, in dem Sie etwas tun, aber das ursprüngliche Objekt zurückgeben.  Thrush ist eine Pipe, Queer ist eine direkte Komposition und der Y-Kombinator leistet hervorragende Arbeit bei der Erstellung rekursiver Funktionen. </p><br><p>  Tatsächlich gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekannten Satz,</a> dass jede berechenbare Funktion mit nur zwei grundlegenden Kombinatoren, Turmfalke und Starling, konstruiert werden kann. </p><br><h3>  Kombinatorische Bibliotheken </h3><br><p>  Kombinatorische Bibliotheken sind Bibliotheken, die viele kombinatorische Funktionen exportieren, die gemeinsam genutzt werden sollen.  Ein Benutzer einer solchen Bibliothek kann Funktionen leicht miteinander kombinieren, um noch größere und komplexere Funktionen wie Würfel zu erhalten. </p><br><p>  Eine gut gestaltete Combiner-Bibliothek ermöglicht es Ihnen, sich auf Funktionen auf hoher Ebene zu konzentrieren und "Rauschen" auf niedriger Ebene zu verbergen.  Wir haben ihre Leistungsfähigkeit bereits in mehreren Beispielen in der Reihe "Warum F # verwenden" gesehen, und das <code>List</code> Modul ist voll von solchen Funktionen. " <code>fold</code> " und " <code>map</code> " sind auch Kombinatoren, wenn Sie darüber nachdenken. </p><br><p>  Ein weiterer Vorteil von Kombinatoren ist, dass sie die sicherste Art von Funktion sind.  Weil  Sie haben keine Abhängigkeiten von der Außenwelt und können sich nicht ändern, wenn sich die globale Umgebung ändert.  Eine Funktion, die einen globalen Wert liest oder Bibliotheksfunktionen verwendet, kann zwischen Aufrufen unterbrochen werden, wenn sich der Kontext ändert.  Dies wird Kombinatoren niemals passieren. </p><br><p>  In F # stehen Kombinatorbibliotheken zum Parsen (FParsec), Erstellen von HTML, Testen von Frameworks usw. zur Verfügung.  Wir werden später in der nächsten Reihe Kombinatoren diskutieren und verwenden. </p><br><h2>  Rekursive Funktionen </h2><br><p>  Oft muss sich eine Funktion von ihrem Körper aus auf sich selbst beziehen.  Ein klassisches Beispiel ist die Fibonacci-Funktion. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Leider kann diese Funktion nicht kompilieren: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Sie müssen dem Compiler mit dem Schlüsselwort <code>rec</code> mitteilen, dass dies eine rekursive Funktion ist. </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Rekursive Funktionen und Datenstrukturen sind in der funktionalen Programmierung sehr verbreitet, und ich hoffe, dass ich später eine ganze Reihe diesem Thema widmen kann. </p><br><h1>  Zusätzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials für F #, einschließlich Materialien für diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links können hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # für Spaß und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere Möglichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schließlich ist die F # Community sehr anfängerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterstützt wird, mit Anfängerräumen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen können</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li><li>  Raum #en_general im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  Über Übersetzungsautoren </h2><br><p>  Übersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Übersetzungs- und redaktionelle Änderungen wurden durch die Bemühungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> für die Vorbereitung dieses Artikels zur Veröffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433398/">https://habr.com/ru/post/de433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433386/index.html">Verwendung einer Computer Vision zur Beurteilung des Fahrzeugzustands. Erleben Sie Yandex.Taxi</a></li>
<li><a href="../de433388/index.html">Formel-Fan oder warum wir Spiele spielen</a></li>
<li><a href="../de433390/index.html">Yandex hat sich dem Schutz von Linux und der IT-Branche vor Patenttrolling angeschlossen</a></li>
<li><a href="../de433392/index.html">Snom D725 IP-Telefon Bewertung</a></li>
<li><a href="../de433396/index.html">Frontend 2018: Ergebnisse des Jahres</a></li>
<li><a href="../de433400/index.html">React Tutorial Teil 2: Funktionskomponenten</a></li>
<li><a href="../de433402/index.html">Funktionales Denken. Teil 8</a></li>
<li><a href="../de433404/index.html">React Tutorial Teil 3: Komponentendateien, Projektstruktur</a></li>
<li><a href="../de433406/index.html">Funktionales Denken. Teil 9</a></li>
<li><a href="../de433408/index.html">Effiziente Speicherbehandlung in Node.js.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>