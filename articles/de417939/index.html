<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≥Ô∏è üé≠ üî£ Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teile 4 und 5 üßòüèæ üë©üèª‚Äçüî¨ üòì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe einen pbrt-Zweig, in dem ich neue Ideen teste, interessante Ideen aus wissenschaftlichen Artikeln umsetze und im Allgemeinen alles studiere, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teile 4 und 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417939/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="Bild"></div><br>  Ich habe einen pbrt-Zweig, in dem ich neue Ideen teste, interessante Ideen aus wissenschaftlichen Artikeln umsetze und im Allgemeinen alles studiere, was normalerweise zu einer neuen Ausgabe des Buches <em>Physically Based Rendering f√ºhrt</em> .  Im Gegensatz zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> , das wir so nah wie m√∂glich an dem im Buch beschriebenen System halten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chten</a> , k√∂nnen wir in diesem Thread alles √§ndern.  Heute werden wir sehen, wie radikalere √Ñnderungen im System die Speichernutzung in der Szene mit der Insel aus dem Disney-Cartoon <em>"Moana"</em> erheblich reduzieren werden. <br><br>  Hinweis zur Methodik: In den vorherigen drei Beitr√§gen wurden alle Statistiken f√ºr die WIP-Version (Work In Progress) der Szene gemessen, mit der ich vor ihrer Ver√∂ffentlichung gearbeitet habe.  In diesem Artikel werden wir zur endg√ºltigen Version √ºbergehen, die etwas komplizierter ist. <br><br>  Beim Rendern der letzten Inselszene aus <em>Moana</em> wurden 81 GB RAM verwendet, um die Szenenbeschreibung f√ºr pbrt-v3 zu speichern.  Derzeit verbraucht pbrt-next 41 GB - ungef√§hr halb so viel.  Um dieses Ergebnis zu erzielen, reichten kleine √Ñnderungen aus, die sich auf mehrere hundert Codezeilen auswirkten. <br><a name="habracut"></a><br><h2>  Reduzierte Primitive </h2><br>  Denken Sie daran, dass in pbrt <code>Primitive</code> eine Kombination aus Geometrie, Material, Strahlungsfunktion (wenn es sich um eine Lichtquelle handelt) und Aufzeichnungen √ºber die Umgebung innerhalb und au√üerhalb der Oberfl√§che besteht.  In pbrt-v3 speichert <code>GeometricPrimitive</code> Folgendes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erw√§hnt</a> , ist <code>nullptr</code> die <code>MediumInterface</code> Zeit <code>areaLight</code> , und das <code>MediumInterface</code> enth√§lt ein Paar <code>nullptr</code> .  Deshalb habe ich in pbrt-next eine <code>Primitive</code> Option namens <code>SimplePrimitive</code> , die nur Zeiger auf Geometrie und Material speichert.  Wenn m√∂glich, wird es <code>GeometricPrimitive</code> M√∂glichkeit anstelle von <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  F√ºr nicht animierte Objektinstanzen haben wir jetzt <code>TransformedPrimitive</code> , das nur einen Zeiger auf das Grundelement und die Transformation speichert. Dadurch sparen wir etwa 500 Byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschwendeten Speicherplatz</a> , den die <code>AnimatedTransform</code> Instanz dem <code>TransformedPrimitive</code> Renderer pbrt-v3 hinzugef√ºgt hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (Es gibt <code>AnimatedPrimitive</code> f√ºr den Fall, dass Sie eine animierte Konvertierung nach pbrt-next ben√∂tigen.) <br><br>  Nach all diesen √Ñnderungen wird in Statistiken angegeben, dass unter <code>Primitive</code> nur 7,8 GB anstelle von 28,9 GB in pbrt-v3 verwendet werden.  Obwohl es gro√üartig ist, dass wir 21 GB eingespart haben, ist es nicht so sehr der R√ºckgang, den wir von fr√ºheren Sch√§tzungen erwarten konnten.  Wir werden am Ende dieses Teils auf diese Diskrepanz zur√ºckkommen. <br><br><h2>  Reduzierte Geometrie </h2><br>  Au√üerdem hat pbrt-next den von der Geometrie belegten Speicher erheblich reduziert: Der f√ºr Maschendreiecke verwendete Speicherplatz wurde von 19,4 GB auf 9,9 GB und der Speicherplatz f√ºr Kurven von 1,4 auf 1,1 GB verringert.  Etwas mehr als die H√§lfte dieser Einsparungen resultierte aus der Vereinfachung der <code>Shape</code> . <br><br>  In pbrt-v3 bringt <code>Shape</code> mehrere Mitglieder mit, die sich auf alle <code>Shape</code> Implementierungen √ºbertragen lassen. Dies sind verschiedene Aspekte, auf die in <code>Shape</code> Implementierungen bequem <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  Um zu verstehen, warum diese Elementvariablen Probleme verursachen, ist es hilfreich zu verstehen, wie Dreiecksnetze in pbrt dargestellt werden.  Erstens gibt es die <code>TriangleMesh</code> Klasse, in der die Eckpunkte und Indexpuffer f√ºr das gesamte Netz gespeichert sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Jedes Dreieck im Netz wird durch die <code>Triangle</code> , die von <code>Shape</code> erbt.  Die Idee ist, das <code>Triangle</code> so klein wie m√∂glich zu halten: Sie speichern nur einen Zeiger auf das Netz, zu dem sie geh√∂ren, und einen Zeiger auf den Versatz im Indexpuffer, an dem die Indizes seiner Scheitelpunkte beginnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  Wenn <code>Triangle</code> Implementierungen die Positionen ihrer Scheitelpunkte finden m√ºssen, f√ºhrt sie die entsprechende Indizierung durch, um sie von <code>TriangleMesh</code> . <br><br>  Das Problem mit <code>Shape</code> pbrt-v3 besteht darin, dass die darin gespeicherten Werte f√ºr alle Dreiecke des Netzes gleich sind. Es ist daher besser, sie von jedem ganzen Netz in <code>TriangleMesh</code> zu speichern und <code>Triangle</code> Zugriff auf eine einzelne Kopie der allgemeinen Werte zu gew√§hren. <br><br>  Dieses Problem wurde in pbrt-next behoben: Die Basisformklasse in pbrt-next enth√§lt keine solchen Elemente, und daher ist jedes <code>Triangle</code> 24 Byte kleiner.  Die Geometriekurve verwendet eine √§hnliche Strategie und profitiert auch von einer kompakteren <code>Shape</code> . <br><br><h2>  Geteilte Dreieckspuffer </h2><br>  Trotz der Tatsache, dass die <em>Moana</em> - <em>Inselszene</em> die Objektinstanziierung in gro√üem Umfang zur expliziten Wiederholung der Geometrie verwendet, war ich neugierig, wie oft die Wiederverwendung von Indexpuffern, Texturkoordinatenpuffern usw. f√ºr verschiedene Dreiecksnetze verwendet wird. <br><br>  Ich habe eine kleine Klasse geschrieben, die diese Puffer beim Empfang hascht und im Cache speichert, und <code>TriangleMesh</code> so ge√§ndert, dass es den Cache √ºberpr√ºft und die bereits gespeicherte Version eines ben√∂tigten redundanten Puffers verwendet.  Der Gewinn war sehr gut: Ich habe es geschafft, 4,7 GB √ºbersch√ºssiges Volumen loszuwerden, was viel mehr ist als ich erwartet hatte. <br><br><h2>  Absturz mit std :: shared_ptr </h2><br>  Nach all diesen √Ñnderungen werden in der Statistik etwa 36 GB bekannter zugeordneter Speicher angezeigt. Zu Beginn des Renderns gibt <code>top</code> die Verwendung von 53 GB an.  Angelegenheiten. <br><br>  Ich hatte Angst vor einer weiteren Reihe langsamer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Massivl√§ufe</a> , um herauszufinden, welcher zugewiesene Speicher in der Statistik fehlt, aber dann erschien ein Brief von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arseny Kapulkin</a> in meinem Posteingang.  Arseny erkl√§rte mir, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine fr√ºheren Sch√§tzungen</a> zur Speichernutzung von <code>GeometricPrimitive</code> sehr falsch waren.  Ich musste es lange herausfinden, aber dann wurde mir klar;  Vielen Dank an Arseny f√ºr den Hinweis auf den Fehler und die detaillierten Erkl√§rungen. <br><br>  Bevor ich an Arseny schrieb, stellte ich mir die Implementierung von <code>std::shared_ptr</code> wie folgt vor: In diesen Zeilen gibt es einen gemeinsamen Deskriptor, der den Referenzz√§hler und einen Zeiger auf das platzierte Objekt selbst speichert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Dann schlug ich vor, dass die Instanz <code>shared_ptr</code> nur darauf verweist und sie verwendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  Kurz gesagt, ich habe angenommen, dass <code>sizeof(shared_ptr&lt;&gt;)</code> der Gr√∂√üe des Zeigers entspricht und dass 16 Byte zus√§tzlicher Speicherplatz f√ºr jeden gemeinsam genutzten Zeiger verschwendet werden. <br><br>  Aber das ist nicht so. <br><br>  In meiner Systemimplementierung ist der allgemeine Deskriptor 32 Byte gro√ü und 16 Byte gro√ü <code>sizeof(shared_ptr&lt;&gt;)</code> .  Daher ist <code>GeometricPrimitive</code> , das haupts√§chlich aus <code>std::shared_ptr</code> , ungef√§hr doppelt so gro√ü wie meine Sch√§tzungen.  Wenn Sie sich fragen, warum dies passiert ist, erkl√§ren diese beiden Stapel√ºberlauf-Beitr√§ge die Gr√ºnde ausf√ºhrlich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> . <br><br>  In fast allen F√§llen, in denen <code>std::shared_ptr</code> in pbrt-next verwendet wird, m√ºssen sie keine gemeinsam genutzten Zeiger sein.  W√§hrend ich verr√ºcktes Hacken machte, ersetzte ich alles, was ich konnte, durch <code>std::unique_ptr</code> , das tats√§chlich die gleiche Gr√∂√üe wie ein normaler Zeiger hat.  So sieht <code>SimplePrimitive</code> jetzt beispielsweise aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  Die Belohnung erwies sich als h√∂her als erwartet: Die Speichernutzung zu Beginn des Renderns verringerte sich von 53 GB auf 41 GB - eine Einsparung von 12 GB, die vor einigen Tagen v√∂llig unerwartet war, und das Gesamtvolumen ist fast halb so hoch wie das von pbrt-v3 verwendete.  Gro√üartig! <br><br>  Im n√§chsten Teil werden wir diese Artikelserie endlich vervollst√§ndigen - untersuchen Sie die Rendergeschwindigkeit in pbrt-next und diskutieren Sie Ideen f√ºr andere M√∂glichkeiten, um den f√ºr diese Szene ben√∂tigten Speicherplatz zu reduzieren. <br><br><h2>  Teil 5 </h2><br>  Um diese Artikelserie zusammenzufassen, untersuchen wir zun√§chst die Rendergeschwindigkeit der Inselszene aus dem Disney-Cartoon <em>"Moana"</em> in pbrt-next - dem pbrt-Zweig, mit dem ich neue Ideen teste.  Wir werden radikalere √Ñnderungen vornehmen, als dies in pbrt-v3 m√∂glich ist, das dem in unserem Buch beschriebenen System entsprechen sollte.  Wir schlie√üen mit einer Diskussion der Bereiche f√ºr weitere Verbesserungen, von den einfachsten bis zu den leicht extremen. <br><br><h2>  Renderzeit </h2><br>  Pbrt-next nahm viele √Ñnderungen an den Licht√ºbertragungsalgorithmen vor, einschlie√ülich √Ñnderungen an der BSDF-Abtastung und Verbesserungen an russischen Roulette-Algorithmen.  Infolgedessen werden mehr Strahlen als pbrt-v3 verfolgt, um diese Szene zu rendern, sodass es nicht m√∂glich ist, die Ausf√ºhrungszeit dieser beiden Renderer direkt zu vergleichen.  Die Geschwindigkeit ist im Allgemeinen nahe, mit einer wichtigen Ausnahme: Beim Rendern einer Inselszene aus <em>Moana</em> (siehe unten) verbringt pbrt-v3 14,5% der Ausf√ºhrungszeit mit der Suche nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptex-</a> Texturen.  Fr√ºher schien mir das ganz normal zu sein, aber pbrt-next verbringt nur 2,2% der Ausf√ºhrungszeit.  Das alles ist furchtbar interessant. <br><br>  Nach dem Studium der Statistik erhalten wir <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  Wie wir in pbrt-v3 sehen, wird die ptex-Textur durchschnittlich alle 34 Textursuchen von der Festplatte gelesen.  In pbrt-next wird es erst nach jeweils 244 Suchvorg√§ngen ausgelesen - das hei√üt, die Festplatten-E / A hat sich um das Siebenfache verringert.  Ich schlug vor, dass dies geschieht, weil pbrt-next die Strahlendifferenzen f√ºr indirekte Strahlen berechnet und dies zu einem Zugriff auf h√∂here MIP-Ebenen von Texturen f√ºhrt, was wiederum eine st√§rker integrierte Reihe von Zugriffen auf den ptex-Textur-Cache schafft. reduziert die Anzahl der Cache-Fehlschl√§ge und damit die Anzahl der E / A-Operationen <sup>2</sup> .  Eine kurze √úberpr√ºfung best√§tigte meine Vermutung: Als die Strahldifferenz ausgeschaltet wurde, wurde die ptex-Geschwindigkeit viel schlechter. <br><br>  Die Erh√∂hung der ptex-Geschwindigkeit hat nicht nur die Kosten f√ºr Computer und E / A beeinflusst.  In einem 32-CPU-System wurde pbrt-v3 nach dem Parsen der Szenenbeschreibung nur um das 14,9-fache beschleunigt.  pbrt zeigt normalerweise eine nahezu lineare parallele Skalierung, daher hat es mich ziemlich entt√§uscht.  Aufgrund der viel geringeren Anzahl von Konflikten w√§hrend Sperren in ptex war die pbrt-next-Version in einem System mit 32 CPUs 29,2-mal schneller und in einem System mit 96 CPUs 94,9-mal schneller - wir sind wieder bei den Indikatoren, die zu uns passen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>Wurzeln aus der Moana-Inselszene, gerendert von pbrt mit einer Aufl√∂sung von 2048 x 858 bei 256 Samples pro Pixel.</i>  <i>Die gesamte Renderzeit auf einer Google Compute Engine-Instanz mit 96 virtuellen CPUs mit einer Frequenz von 2 GHz in pbrt-next betr√§gt 41 Minuten und 22 Sekunden.</i>  <i>Die Beschleunigung aufgrund von Mulithreading w√§hrend des Renderns betrug das 94,9-fache.</i>  <i>(Ich verstehe nicht ganz, was mit Bump Mapping passiert.)</i> <br><br><h2>  Arbeit f√ºr die Zukunft </h2><br>  Das Verringern des in solchen komplexen Szenen verwendeten Speicherplatzes ist eine aufregende Erfahrung: Das Speichern einiger Gigabyte mit einer kleinen √Ñnderung ist viel angenehmer als das Speichern von zehn Megabyte in einer einfacheren Szene.  Ich habe eine gute Liste von dem, was ich in Zukunft lernen m√∂chte, wenn es die Zeit erlaubt.  Hier ist eine kurze √úbersicht. <br><br><h3>  Weiter abnehmender Dreieckspufferspeicher </h3><br>  Selbst bei wiederholter Verwendung von Puffern, die dieselben Werte f√ºr mehrere Dreiecksnetze speichern, wird unter den Dreieckspuffern immer noch viel Speicher verwendet.  Hier ist eine Aufschl√ºsselung der Speichernutzung f√ºr verschiedene Arten von Dreieckspuffern in der Szene: <br><br><table><thead><tr><th>  Typ </th><th>  Die Erinnerung </th></tr></thead><tbody><tr><td>  Werbebuchungen </td><td>  2,5 GB </td></tr><tr><td>  Normal </td><td>  2,5 GB </td></tr><tr><td>  UV </td><td>  98 MB </td></tr><tr><td>  Indizes </td><td>  252 MB </td></tr></tbody></table><br>  Ich verstehe, dass mit den √ºbertragenen Scheitelpunktpositionen nichts getan werden kann, aber f√ºr andere Daten gibt es Einsparungen.  Es gibt viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arten von Darstellungen normaler Vektoren in einer speichereffizienten Form</a> , die verschiedene Kompromisse zwischen Speichergr√∂√üe / Anzahl der Berechnungen bieten.  Durch die Verwendung einer der 24-Bit- oder 32-Bit-Darstellungen wird der von den Normalen belegte Speicherplatz auf 663 MB und 864 MB reduziert, wodurch mehr als 1,5 GB RAM eingespart werden. <br><br>  In dieser Szene ist der Speicherplatz zum Speichern von Texturkoordinaten und Indexpuffern √ºberraschend gering.  Ich nehme an, dass dies aufgrund des Vorhandenseins vieler prozedural erzeugter Pflanzen in der Szene und aufgrund der Tatsache geschah, dass alle Variationen desselben Pflanzentyps dieselbe Topologie (und damit den Indexpuffer) mit Parametrisierung (und damit UV-Koordinaten) aufweisen.  Die Wiederverwendung von passenden Puffern ist wiederum sehr effizient. <br><br>  F√ºr andere Szenen kann es durchaus geeignet sein, 16-Bit-UV-Koordinaten von Texturen abzutasten oder Gleitkommawerte mit halber Genauigkeit zu verwenden, abh√§ngig von ihrem Wertebereich.  Es scheint, dass in dieser Szene alle Texturkoordinatenwerte Null oder Eins sind, was bedeutet, dass sie durch ein <em>Bit dargestellt werden k√∂nnen</em> - das hei√üt, es ist m√∂glich, den belegten Speicher um das 32-fache zu reduzieren.  Dieser Zustand ist wahrscheinlich auf die Verwendung des ptex-Formats f√ºr die Texturierung zur√ºckzuf√ºhren, wodurch UV-Atlanten √ºberfl√ºssig werden.  Angesichts der geringen Menge, die derzeit von den Texturkoordinaten belegt wird, ist die Implementierung dieser Optimierung nicht besonders notwendig. <br><br>  pbrt verwendet immer 32-Bit-Ganzzahlen f√ºr Indexpuffer.  F√ºr kleine Netze mit weniger als 256 Scheitelpunkten sind nur 8 Bit pro Index ausreichend, und f√ºr Netze mit weniger als 65.536 Scheitelpunkten k√∂nnen 16 Bit verwendet werden.  Das √Ñndern von pbrt, um es an dieses Format anzupassen, wird nicht sehr schwierig sein.  Wenn wir maximal optimieren wollten, k√∂nnten wir genau so viele Bits ausw√§hlen, wie erforderlich sind, um den erforderlichen Bereich in den Indizes darzustellen, w√§hrend der Preis darin bestehen w√ºrde, die Komplexit√§t der Ermittlung ihrer Werte zu erh√∂hen.  Trotz der Tatsache, dass jetzt nur ein Viertel Gigabyte Speicher f√ºr Scheitelpunktindizes verwendet wird, sieht diese Aufgabe im Vergleich zu anderen nicht sehr interessant aus. <br><br><h3>  Spitzenauslastung des BVH-Buildspeichers </h3><br>  Zuvor haben wir noch kein weiteres Detail der Speichernutzung besprochen: Unmittelbar vor dem Rendern tritt ein kurzfristiger Peak von 10 GB zus√§tzlich verwendetem Speicher auf.  Dies geschieht, wenn der (gro√üe) BVH der gesamten Szene erstellt wird.  Der Code zum Erstellen der BVH des pbrt-Renderers wird so geschrieben, dass er in zwei Phasen ausgef√ºhrt wird: Zun√§chst wird eine BVH mit der <a href="">traditionellen Darstellung erstellt</a> : zwei untergeordnete Zeiger auf jeden Knoten.  Nach dem Erstellen des Baums wird er in <a href="">ein speichereffizientes Schema</a> konvertiert <a href="">,</a> in dem sich das erste untergeordnete Element des Knotens direkt dahinter im Speicher befindet und der Offset zum zweiten untergeordneten Element als Ganzzahl gespeichert wird. <br><br>  Eine solche Trennung war aus Sicht der Lehramtsstudenten notwendig - es war viel einfacher, die Algorithmen zum Erstellen von BVH zu verstehen, ohne dass Chaos mit der Notwendigkeit verbunden war, den Baum w√§hrend des Bauprozesses in eine kompakte Form umzuwandeln.  Das Ergebnis ist jedoch dieser Spitzenwert bei der Speichernutzung.  Angesichts seines Einflusses auf die Szene erscheint die Beseitigung dieses Problems attraktiv. <br><br><h3>  Konvertieren Sie Zeiger in Ganzzahlen </h3><br>  In verschiedenen Datenstrukturen gibt es viele 64-Bit-Zeiger, die als 32-Bit-Ganzzahlen dargestellt werden k√∂nnen.  Beispielsweise enth√§lt jedes <code>SimplePrimitive</code> einen Zeiger auf ein <code>Material</code> .  Die meisten F√§lle von <code>Material</code> sind vielen Grundelementen in der Szene gemeinsam, und es gibt nie mehr als einige Tausend;  Daher k√∂nnen wir einen einzelnen globalen Vektorvektor aller Materialien speichern: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  und speichern Sie einfach 32-Bit-Ganzzahl-Offsets f√ºr diesen Vektor in <code>SimplePrimitive</code> , wodurch wir 4 Bytes sparen.  Der gleiche Trick kann mit einem Zeiger auf das <code>TriangleMesh</code> in jedem <code>Triangle</code> sowie an vielen anderen Stellen verwendet werden. <br><br>  Nach einer solchen √Ñnderung wird der Zugriff auf die Schilder selbst geringf√ºgig redundant sein, und das System wird f√ºr Sch√ºler, die versuchen, seine Arbeit zu verstehen, etwas weniger verst√§ndlich.  Au√üerdem ist dies wahrscheinlich der Fall, wenn es im Zusammenhang mit pbrt besser ist, die Implementierung ein wenig verst√§ndlicher zu halten, wenn auch auf Kosten einer unvollst√§ndigen Optimierung der Speichernutzung. <br><br><h3>  Unterkunft basierend auf Arenen (Bereichen) </h3><br>  F√ºr jedes einzelne <code>Triangle</code> und Primitiv wird ein separater Aufruf an <code>new</code> (eigentlich <code>make_unique</code> , aber das ist das gleiche) gemacht.  Solche Speicherzuweisungen f√ºhren zur Verwendung einer zus√§tzlichen Ressourcenabrechnung, die etwa f√ºnf Gigabyte Speicher belegt und in der Statistik nicht ber√ºcksichtigt wird.  Da die Lebensdauer all dieser Platzierungen gleich ist - bis das Rendern abgeschlossen ist - k√∂nnen wir diese zus√§tzliche Abrechnung beseitigen, indem wir sie aus dem <a href="">Speicherbereich</a> ausw√§hlen. <br><br><h3>  Khaki vtable </h3><br>  Meine letzte Idee ist schrecklich und ich entschuldige mich daf√ºr, aber sie hat mich fasziniert. <br><br>  Jedes Dreieck in der Szene hat eine zus√§tzliche Last von mindestens zwei vtable-Zeigern: einen f√ºr <code>Triangle</code> und einen f√ºr <code>SimplePrimitive</code> .  Das sind 16 Bytes.  Die <em>Moana-</em> Inselszene hat insgesamt 146 162 124 einzigartige Dreiecke, wodurch fast 2,2 GB redundante vtable-Zeiger hinzugef√ºgt werden. <br><br>  Was w√§re, wenn wir keine abstrakte Basisklasse f√ºr <code>Shape</code> und jede Geometrieimplementierung nichts erben w√ºrde?  Dies w√ºrde uns Platz auf vtable-Zeigern sparen, aber wenn wir einen Zeiger auf eine Geometrie √ºbergeben, wissen wir nat√ºrlich nicht, um welche Art von Geometrie es sich handelt, das hei√üt, es w√§re nutzlos. <br><br>  Es stellt sich heraus, dass auf modernen x86-CPUs tats√§chlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur 48 Bit 64-Bit-Zeiger verwendet werden</a> .  Daher gibt es zus√§tzliche 16 Bits, die wir ausleihen k√∂nnen, um einige Informationen zu speichern ... zum Beispiel die Geometrie, auf die wir zeigen.  Wenn wir ein wenig Arbeit hinzuf√ºgen, k√∂nnen wir auf die M√∂glichkeit zur√ºckgreifen, ein Analogon von Aufrufen virtueller Funktionen zu erstellen. <br><br>  So wird es passieren: Zuerst definieren wir eine <code>ShapeMethods</code> Struktur, die Zeiger auf Funktionen enth√§lt, wie z. B. <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Jede Geometrieimplementierung implementiert eine Einschr√§nkungsfunktion, eine Schnittfunktion usw. und empf√§ngt als erstes Argument ein Analogon <code>this</code> Zeigers: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  Wir h√§tten eine globale Tabelle mit <code>ShapeMethods</code> Strukturen, in der das <em>n-te</em> Element f√ºr einen Geometrietyp mit dem Index <em>n gilt</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Beim Erstellen von Geometrie codieren wir ihren Typ in einige der nicht verwendeten Bits des R√ºckgabezeigers.  Unter Ber√ºcksichtigung des Zeigers auf die Geometrie, deren spezifischen Aufruf wir ausf√ºhren m√∂chten, extrahieren wir diesen <code>shapeMethods</code> aus dem Zeiger und verwenden ihn als Index in <code>shapeMethods</code> , um den entsprechenden Funktionszeiger zu finden.  Im Wesentlichen w√ºrden wir vtable manuell implementieren und den Versand selbst verarbeiten.  Wenn wir dies sowohl f√ºr Geometrie als auch f√ºr Grundelemente tun w√ºrden, w√ºrden wir 16 Bytes pro <code>Triangle</code> sparen, aber gleichzeitig haben wir einen ziemlich schwierigen Weg gemacht. <br><br>  Ich nehme an, dass ein solcher Hack zur Implementierung des Managements virtueller Funktionen nicht neu ist, aber ich konnte im Internet keine Links dazu finden.  Hier ist die Wikipedia-Seite √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">markierte Zeiger</a> , aber sie befasst sich mit Dingen wie der Anzahl der Links.  Wenn Sie einen besseren Link kennen, senden Sie mir einen Brief. <br><br>  Indem ich diesen unangenehmen Hack teile, kann ich die Reihe der Beitr√§ge beenden.  Nochmals vielen Dank an Disney f√ºr die Ver√∂ffentlichung dieser Szene.  Es hat unglaublich viel Spa√ü gemacht, damit zu arbeiten.  Die Zahnr√§der in meinem Kopf drehen sich weiter. <br><br><h2>  Anmerkungen </h2><br><ol><li>  Am Ende verfolgt pbrt-next mehr Strahlen in dieser Szene als pbrt-v3, was wahrscheinlich die Zunahme der Anzahl von Suchoperationen erkl√§rt. </li><li>  Die Strahldifferenzen f√ºr indirekte Strahlen in pbrt-next werden unter Verwendung des gleichen <a href="">Hacks</a> berechnet, der in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Textur-Cache-Erweiterung</a> f√ºr pbrt-v3 verwendet wird. ,     ,        . </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417939/">https://habr.com/ru/post/de417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417929/index.html">Auszug aus dem Buch ‚ÄûEin Tag im Leben des Gehirns. Neurobiologie des Bewusstseins von morgens bis abends ‚Äú</a></li>
<li><a href="../de417931/index.html">Techniken zur Spielerbindung: Beispiele aus Spielen verschiedener Genres</a></li>
<li><a href="../de417933/index.html">Sicherheitswoche 27: Gef√§lschtes iPhone und Sicherheitspreis</a></li>
<li><a href="../de417935/index.html">Memos zu k√ºnstlicher Intelligenz, maschinellem Lernen, Deep Learning und Big Data</a></li>
<li><a href="../de417937/index.html">Machen "eiserne" Leute Software?</a></li>
<li><a href="../de417941/index.html">Wo verschwindet das Wasser im Wasserkocher?</a></li>
<li><a href="../de417943/index.html">Serverless and React 2: Handfertigkeit und kein Betrug</a></li>
<li><a href="../de417945/index.html">Welche Werkzeuge hat die Parker-Sonde?</a></li>
<li><a href="../de417947/index.html">Datenvisualisierung f√ºr Ihr Webprojekt</a></li>
<li><a href="../de417949/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so be√§ngstigend? Kapitel 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>