<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏳️ 🎭 🔣 Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teile 4 und 5 🧘🏾 👩🏻‍🔬 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe einen pbrt-Zweig, in dem ich neue Ideen teste, interessante Ideen aus wissenschaftlichen Artikeln umsetze und im Allgemeinen alles studiere, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teile 4 und 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417939/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="Bild"></div><br>  Ich habe einen pbrt-Zweig, in dem ich neue Ideen teste, interessante Ideen aus wissenschaftlichen Artikeln umsetze und im Allgemeinen alles studiere, was normalerweise zu einer neuen Ausgabe des Buches <em>Physically Based Rendering führt</em> .  Im Gegensatz zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> , das wir so nah wie möglich an dem im Buch beschriebenen System halten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">möchten</a> , können wir in diesem Thread alles ändern.  Heute werden wir sehen, wie radikalere Änderungen im System die Speichernutzung in der Szene mit der Insel aus dem Disney-Cartoon <em>"Moana"</em> erheblich reduzieren werden. <br><br>  Hinweis zur Methodik: In den vorherigen drei Beiträgen wurden alle Statistiken für die WIP-Version (Work In Progress) der Szene gemessen, mit der ich vor ihrer Veröffentlichung gearbeitet habe.  In diesem Artikel werden wir zur endgültigen Version übergehen, die etwas komplizierter ist. <br><br>  Beim Rendern der letzten Inselszene aus <em>Moana</em> wurden 81 GB RAM verwendet, um die Szenenbeschreibung für pbrt-v3 zu speichern.  Derzeit verbraucht pbrt-next 41 GB - ungefähr halb so viel.  Um dieses Ergebnis zu erzielen, reichten kleine Änderungen aus, die sich auf mehrere hundert Codezeilen auswirkten. <br><a name="habracut"></a><br><h2>  Reduzierte Primitive </h2><br>  Denken Sie daran, dass in pbrt <code>Primitive</code> eine Kombination aus Geometrie, Material, Strahlungsfunktion (wenn es sich um eine Lichtquelle handelt) und Aufzeichnungen über die Umgebung innerhalb und außerhalb der Oberfläche besteht.  In pbrt-v3 speichert <code>GeometricPrimitive</code> Folgendes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erwähnt</a> , ist <code>nullptr</code> die <code>MediumInterface</code> Zeit <code>areaLight</code> , und das <code>MediumInterface</code> enthält ein Paar <code>nullptr</code> .  Deshalb habe ich in pbrt-next eine <code>Primitive</code> Option namens <code>SimplePrimitive</code> , die nur Zeiger auf Geometrie und Material speichert.  Wenn möglich, wird es <code>GeometricPrimitive</code> Möglichkeit anstelle von <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  Für nicht animierte Objektinstanzen haben wir jetzt <code>TransformedPrimitive</code> , das nur einen Zeiger auf das Grundelement und die Transformation speichert. Dadurch sparen wir etwa 500 Byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschwendeten Speicherplatz</a> , den die <code>AnimatedTransform</code> Instanz dem <code>TransformedPrimitive</code> Renderer pbrt-v3 hinzugefügt hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (Es gibt <code>AnimatedPrimitive</code> für den Fall, dass Sie eine animierte Konvertierung nach pbrt-next benötigen.) <br><br>  Nach all diesen Änderungen wird in Statistiken angegeben, dass unter <code>Primitive</code> nur 7,8 GB anstelle von 28,9 GB in pbrt-v3 verwendet werden.  Obwohl es großartig ist, dass wir 21 GB eingespart haben, ist es nicht so sehr der Rückgang, den wir von früheren Schätzungen erwarten konnten.  Wir werden am Ende dieses Teils auf diese Diskrepanz zurückkommen. <br><br><h2>  Reduzierte Geometrie </h2><br>  Außerdem hat pbrt-next den von der Geometrie belegten Speicher erheblich reduziert: Der für Maschendreiecke verwendete Speicherplatz wurde von 19,4 GB auf 9,9 GB und der Speicherplatz für Kurven von 1,4 auf 1,1 GB verringert.  Etwas mehr als die Hälfte dieser Einsparungen resultierte aus der Vereinfachung der <code>Shape</code> . <br><br>  In pbrt-v3 bringt <code>Shape</code> mehrere Mitglieder mit, die sich auf alle <code>Shape</code> Implementierungen übertragen lassen. Dies sind verschiedene Aspekte, auf die in <code>Shape</code> Implementierungen bequem <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  Um zu verstehen, warum diese Elementvariablen Probleme verursachen, ist es hilfreich zu verstehen, wie Dreiecksnetze in pbrt dargestellt werden.  Erstens gibt es die <code>TriangleMesh</code> Klasse, in der die Eckpunkte und Indexpuffer für das gesamte Netz gespeichert sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Jedes Dreieck im Netz wird durch die <code>Triangle</code> , die von <code>Shape</code> erbt.  Die Idee ist, das <code>Triangle</code> so klein wie möglich zu halten: Sie speichern nur einen Zeiger auf das Netz, zu dem sie gehören, und einen Zeiger auf den Versatz im Indexpuffer, an dem die Indizes seiner Scheitelpunkte beginnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  Wenn <code>Triangle</code> Implementierungen die Positionen ihrer Scheitelpunkte finden müssen, führt sie die entsprechende Indizierung durch, um sie von <code>TriangleMesh</code> . <br><br>  Das Problem mit <code>Shape</code> pbrt-v3 besteht darin, dass die darin gespeicherten Werte für alle Dreiecke des Netzes gleich sind. Es ist daher besser, sie von jedem ganzen Netz in <code>TriangleMesh</code> zu speichern und <code>Triangle</code> Zugriff auf eine einzelne Kopie der allgemeinen Werte zu gewähren. <br><br>  Dieses Problem wurde in pbrt-next behoben: Die Basisformklasse in pbrt-next enthält keine solchen Elemente, und daher ist jedes <code>Triangle</code> 24 Byte kleiner.  Die Geometriekurve verwendet eine ähnliche Strategie und profitiert auch von einer kompakteren <code>Shape</code> . <br><br><h2>  Geteilte Dreieckspuffer </h2><br>  Trotz der Tatsache, dass die <em>Moana</em> - <em>Inselszene</em> die Objektinstanziierung in großem Umfang zur expliziten Wiederholung der Geometrie verwendet, war ich neugierig, wie oft die Wiederverwendung von Indexpuffern, Texturkoordinatenpuffern usw. für verschiedene Dreiecksnetze verwendet wird. <br><br>  Ich habe eine kleine Klasse geschrieben, die diese Puffer beim Empfang hascht und im Cache speichert, und <code>TriangleMesh</code> so geändert, dass es den Cache überprüft und die bereits gespeicherte Version eines benötigten redundanten Puffers verwendet.  Der Gewinn war sehr gut: Ich habe es geschafft, 4,7 GB überschüssiges Volumen loszuwerden, was viel mehr ist als ich erwartet hatte. <br><br><h2>  Absturz mit std :: shared_ptr </h2><br>  Nach all diesen Änderungen werden in der Statistik etwa 36 GB bekannter zugeordneter Speicher angezeigt. Zu Beginn des Renderns gibt <code>top</code> die Verwendung von 53 GB an.  Angelegenheiten. <br><br>  Ich hatte Angst vor einer weiteren Reihe langsamer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Massivläufe</a> , um herauszufinden, welcher zugewiesene Speicher in der Statistik fehlt, aber dann erschien ein Brief von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arseny Kapulkin</a> in meinem Posteingang.  Arseny erklärte mir, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine früheren Schätzungen</a> zur Speichernutzung von <code>GeometricPrimitive</code> sehr falsch waren.  Ich musste es lange herausfinden, aber dann wurde mir klar;  Vielen Dank an Arseny für den Hinweis auf den Fehler und die detaillierten Erklärungen. <br><br>  Bevor ich an Arseny schrieb, stellte ich mir die Implementierung von <code>std::shared_ptr</code> wie folgt vor: In diesen Zeilen gibt es einen gemeinsamen Deskriptor, der den Referenzzähler und einen Zeiger auf das platzierte Objekt selbst speichert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Dann schlug ich vor, dass die Instanz <code>shared_ptr</code> nur darauf verweist und sie verwendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  Kurz gesagt, ich habe angenommen, dass <code>sizeof(shared_ptr&lt;&gt;)</code> der Größe des Zeigers entspricht und dass 16 Byte zusätzlicher Speicherplatz für jeden gemeinsam genutzten Zeiger verschwendet werden. <br><br>  Aber das ist nicht so. <br><br>  In meiner Systemimplementierung ist der allgemeine Deskriptor 32 Byte groß und 16 Byte groß <code>sizeof(shared_ptr&lt;&gt;)</code> .  Daher ist <code>GeometricPrimitive</code> , das hauptsächlich aus <code>std::shared_ptr</code> , ungefähr doppelt so groß wie meine Schätzungen.  Wenn Sie sich fragen, warum dies passiert ist, erklären diese beiden Stapelüberlauf-Beiträge die Gründe ausführlich: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> . <br><br>  In fast allen Fällen, in denen <code>std::shared_ptr</code> in pbrt-next verwendet wird, müssen sie keine gemeinsam genutzten Zeiger sein.  Während ich verrücktes Hacken machte, ersetzte ich alles, was ich konnte, durch <code>std::unique_ptr</code> , das tatsächlich die gleiche Größe wie ein normaler Zeiger hat.  So sieht <code>SimplePrimitive</code> jetzt beispielsweise aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  Die Belohnung erwies sich als höher als erwartet: Die Speichernutzung zu Beginn des Renderns verringerte sich von 53 GB auf 41 GB - eine Einsparung von 12 GB, die vor einigen Tagen völlig unerwartet war, und das Gesamtvolumen ist fast halb so hoch wie das von pbrt-v3 verwendete.  Großartig! <br><br>  Im nächsten Teil werden wir diese Artikelserie endlich vervollständigen - untersuchen Sie die Rendergeschwindigkeit in pbrt-next und diskutieren Sie Ideen für andere Möglichkeiten, um den für diese Szene benötigten Speicherplatz zu reduzieren. <br><br><h2>  Teil 5 </h2><br>  Um diese Artikelserie zusammenzufassen, untersuchen wir zunächst die Rendergeschwindigkeit der Inselszene aus dem Disney-Cartoon <em>"Moana"</em> in pbrt-next - dem pbrt-Zweig, mit dem ich neue Ideen teste.  Wir werden radikalere Änderungen vornehmen, als dies in pbrt-v3 möglich ist, das dem in unserem Buch beschriebenen System entsprechen sollte.  Wir schließen mit einer Diskussion der Bereiche für weitere Verbesserungen, von den einfachsten bis zu den leicht extremen. <br><br><h2>  Renderzeit </h2><br>  Pbrt-next nahm viele Änderungen an den Lichtübertragungsalgorithmen vor, einschließlich Änderungen an der BSDF-Abtastung und Verbesserungen an russischen Roulette-Algorithmen.  Infolgedessen werden mehr Strahlen als pbrt-v3 verfolgt, um diese Szene zu rendern, sodass es nicht möglich ist, die Ausführungszeit dieser beiden Renderer direkt zu vergleichen.  Die Geschwindigkeit ist im Allgemeinen nahe, mit einer wichtigen Ausnahme: Beim Rendern einer Inselszene aus <em>Moana</em> (siehe unten) verbringt pbrt-v3 14,5% der Ausführungszeit mit der Suche nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptex-</a> Texturen.  Früher schien mir das ganz normal zu sein, aber pbrt-next verbringt nur 2,2% der Ausführungszeit.  Das alles ist furchtbar interessant. <br><br>  Nach dem Studium der Statistik erhalten wir <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  Wie wir in pbrt-v3 sehen, wird die ptex-Textur durchschnittlich alle 34 Textursuchen von der Festplatte gelesen.  In pbrt-next wird es erst nach jeweils 244 Suchvorgängen ausgelesen - das heißt, die Festplatten-E / A hat sich um das Siebenfache verringert.  Ich schlug vor, dass dies geschieht, weil pbrt-next die Strahlendifferenzen für indirekte Strahlen berechnet und dies zu einem Zugriff auf höhere MIP-Ebenen von Texturen führt, was wiederum eine stärker integrierte Reihe von Zugriffen auf den ptex-Textur-Cache schafft. reduziert die Anzahl der Cache-Fehlschläge und damit die Anzahl der E / A-Operationen <sup>2</sup> .  Eine kurze Überprüfung bestätigte meine Vermutung: Als die Strahldifferenz ausgeschaltet wurde, wurde die ptex-Geschwindigkeit viel schlechter. <br><br>  Die Erhöhung der ptex-Geschwindigkeit hat nicht nur die Kosten für Computer und E / A beeinflusst.  In einem 32-CPU-System wurde pbrt-v3 nach dem Parsen der Szenenbeschreibung nur um das 14,9-fache beschleunigt.  pbrt zeigt normalerweise eine nahezu lineare parallele Skalierung, daher hat es mich ziemlich enttäuscht.  Aufgrund der viel geringeren Anzahl von Konflikten während Sperren in ptex war die pbrt-next-Version in einem System mit 32 CPUs 29,2-mal schneller und in einem System mit 96 CPUs 94,9-mal schneller - wir sind wieder bei den Indikatoren, die zu uns passen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>Wurzeln aus der Moana-Inselszene, gerendert von pbrt mit einer Auflösung von 2048 x 858 bei 256 Samples pro Pixel.</i>  <i>Die gesamte Renderzeit auf einer Google Compute Engine-Instanz mit 96 virtuellen CPUs mit einer Frequenz von 2 GHz in pbrt-next beträgt 41 Minuten und 22 Sekunden.</i>  <i>Die Beschleunigung aufgrund von Mulithreading während des Renderns betrug das 94,9-fache.</i>  <i>(Ich verstehe nicht ganz, was mit Bump Mapping passiert.)</i> <br><br><h2>  Arbeit für die Zukunft </h2><br>  Das Verringern des in solchen komplexen Szenen verwendeten Speicherplatzes ist eine aufregende Erfahrung: Das Speichern einiger Gigabyte mit einer kleinen Änderung ist viel angenehmer als das Speichern von zehn Megabyte in einer einfacheren Szene.  Ich habe eine gute Liste von dem, was ich in Zukunft lernen möchte, wenn es die Zeit erlaubt.  Hier ist eine kurze Übersicht. <br><br><h3>  Weiter abnehmender Dreieckspufferspeicher </h3><br>  Selbst bei wiederholter Verwendung von Puffern, die dieselben Werte für mehrere Dreiecksnetze speichern, wird unter den Dreieckspuffern immer noch viel Speicher verwendet.  Hier ist eine Aufschlüsselung der Speichernutzung für verschiedene Arten von Dreieckspuffern in der Szene: <br><br><table><thead><tr><th>  Typ </th><th>  Die Erinnerung </th></tr></thead><tbody><tr><td>  Werbebuchungen </td><td>  2,5 GB </td></tr><tr><td>  Normal </td><td>  2,5 GB </td></tr><tr><td>  UV </td><td>  98 MB </td></tr><tr><td>  Indizes </td><td>  252 MB </td></tr></tbody></table><br>  Ich verstehe, dass mit den übertragenen Scheitelpunktpositionen nichts getan werden kann, aber für andere Daten gibt es Einsparungen.  Es gibt viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arten von Darstellungen normaler Vektoren in einer speichereffizienten Form</a> , die verschiedene Kompromisse zwischen Speichergröße / Anzahl der Berechnungen bieten.  Durch die Verwendung einer der 24-Bit- oder 32-Bit-Darstellungen wird der von den Normalen belegte Speicherplatz auf 663 MB und 864 MB reduziert, wodurch mehr als 1,5 GB RAM eingespart werden. <br><br>  In dieser Szene ist der Speicherplatz zum Speichern von Texturkoordinaten und Indexpuffern überraschend gering.  Ich nehme an, dass dies aufgrund des Vorhandenseins vieler prozedural erzeugter Pflanzen in der Szene und aufgrund der Tatsache geschah, dass alle Variationen desselben Pflanzentyps dieselbe Topologie (und damit den Indexpuffer) mit Parametrisierung (und damit UV-Koordinaten) aufweisen.  Die Wiederverwendung von passenden Puffern ist wiederum sehr effizient. <br><br>  Für andere Szenen kann es durchaus geeignet sein, 16-Bit-UV-Koordinaten von Texturen abzutasten oder Gleitkommawerte mit halber Genauigkeit zu verwenden, abhängig von ihrem Wertebereich.  Es scheint, dass in dieser Szene alle Texturkoordinatenwerte Null oder Eins sind, was bedeutet, dass sie durch ein <em>Bit dargestellt werden können</em> - das heißt, es ist möglich, den belegten Speicher um das 32-fache zu reduzieren.  Dieser Zustand ist wahrscheinlich auf die Verwendung des ptex-Formats für die Texturierung zurückzuführen, wodurch UV-Atlanten überflüssig werden.  Angesichts der geringen Menge, die derzeit von den Texturkoordinaten belegt wird, ist die Implementierung dieser Optimierung nicht besonders notwendig. <br><br>  pbrt verwendet immer 32-Bit-Ganzzahlen für Indexpuffer.  Für kleine Netze mit weniger als 256 Scheitelpunkten sind nur 8 Bit pro Index ausreichend, und für Netze mit weniger als 65.536 Scheitelpunkten können 16 Bit verwendet werden.  Das Ändern von pbrt, um es an dieses Format anzupassen, wird nicht sehr schwierig sein.  Wenn wir maximal optimieren wollten, könnten wir genau so viele Bits auswählen, wie erforderlich sind, um den erforderlichen Bereich in den Indizes darzustellen, während der Preis darin bestehen würde, die Komplexität der Ermittlung ihrer Werte zu erhöhen.  Trotz der Tatsache, dass jetzt nur ein Viertel Gigabyte Speicher für Scheitelpunktindizes verwendet wird, sieht diese Aufgabe im Vergleich zu anderen nicht sehr interessant aus. <br><br><h3>  Spitzenauslastung des BVH-Buildspeichers </h3><br>  Zuvor haben wir noch kein weiteres Detail der Speichernutzung besprochen: Unmittelbar vor dem Rendern tritt ein kurzfristiger Peak von 10 GB zusätzlich verwendetem Speicher auf.  Dies geschieht, wenn der (große) BVH der gesamten Szene erstellt wird.  Der Code zum Erstellen der BVH des pbrt-Renderers wird so geschrieben, dass er in zwei Phasen ausgeführt wird: Zunächst wird eine BVH mit der <a href="">traditionellen Darstellung erstellt</a> : zwei untergeordnete Zeiger auf jeden Knoten.  Nach dem Erstellen des Baums wird er in <a href="">ein speichereffizientes Schema</a> konvertiert <a href="">,</a> in dem sich das erste untergeordnete Element des Knotens direkt dahinter im Speicher befindet und der Offset zum zweiten untergeordneten Element als Ganzzahl gespeichert wird. <br><br>  Eine solche Trennung war aus Sicht der Lehramtsstudenten notwendig - es war viel einfacher, die Algorithmen zum Erstellen von BVH zu verstehen, ohne dass Chaos mit der Notwendigkeit verbunden war, den Baum während des Bauprozesses in eine kompakte Form umzuwandeln.  Das Ergebnis ist jedoch dieser Spitzenwert bei der Speichernutzung.  Angesichts seines Einflusses auf die Szene erscheint die Beseitigung dieses Problems attraktiv. <br><br><h3>  Konvertieren Sie Zeiger in Ganzzahlen </h3><br>  In verschiedenen Datenstrukturen gibt es viele 64-Bit-Zeiger, die als 32-Bit-Ganzzahlen dargestellt werden können.  Beispielsweise enthält jedes <code>SimplePrimitive</code> einen Zeiger auf ein <code>Material</code> .  Die meisten Fälle von <code>Material</code> sind vielen Grundelementen in der Szene gemeinsam, und es gibt nie mehr als einige Tausend;  Daher können wir einen einzelnen globalen Vektorvektor aller Materialien speichern: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  und speichern Sie einfach 32-Bit-Ganzzahl-Offsets für diesen Vektor in <code>SimplePrimitive</code> , wodurch wir 4 Bytes sparen.  Der gleiche Trick kann mit einem Zeiger auf das <code>TriangleMesh</code> in jedem <code>Triangle</code> sowie an vielen anderen Stellen verwendet werden. <br><br>  Nach einer solchen Änderung wird der Zugriff auf die Schilder selbst geringfügig redundant sein, und das System wird für Schüler, die versuchen, seine Arbeit zu verstehen, etwas weniger verständlich.  Außerdem ist dies wahrscheinlich der Fall, wenn es im Zusammenhang mit pbrt besser ist, die Implementierung ein wenig verständlicher zu halten, wenn auch auf Kosten einer unvollständigen Optimierung der Speichernutzung. <br><br><h3>  Unterkunft basierend auf Arenen (Bereichen) </h3><br>  Für jedes einzelne <code>Triangle</code> und Primitiv wird ein separater Aufruf an <code>new</code> (eigentlich <code>make_unique</code> , aber das ist das gleiche) gemacht.  Solche Speicherzuweisungen führen zur Verwendung einer zusätzlichen Ressourcenabrechnung, die etwa fünf Gigabyte Speicher belegt und in der Statistik nicht berücksichtigt wird.  Da die Lebensdauer all dieser Platzierungen gleich ist - bis das Rendern abgeschlossen ist - können wir diese zusätzliche Abrechnung beseitigen, indem wir sie aus dem <a href="">Speicherbereich</a> auswählen. <br><br><h3>  Khaki vtable </h3><br>  Meine letzte Idee ist schrecklich und ich entschuldige mich dafür, aber sie hat mich fasziniert. <br><br>  Jedes Dreieck in der Szene hat eine zusätzliche Last von mindestens zwei vtable-Zeigern: einen für <code>Triangle</code> und einen für <code>SimplePrimitive</code> .  Das sind 16 Bytes.  Die <em>Moana-</em> Inselszene hat insgesamt 146 162 124 einzigartige Dreiecke, wodurch fast 2,2 GB redundante vtable-Zeiger hinzugefügt werden. <br><br>  Was wäre, wenn wir keine abstrakte Basisklasse für <code>Shape</code> und jede Geometrieimplementierung nichts erben würde?  Dies würde uns Platz auf vtable-Zeigern sparen, aber wenn wir einen Zeiger auf eine Geometrie übergeben, wissen wir natürlich nicht, um welche Art von Geometrie es sich handelt, das heißt, es wäre nutzlos. <br><br>  Es stellt sich heraus, dass auf modernen x86-CPUs tatsächlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur 48 Bit 64-Bit-Zeiger verwendet werden</a> .  Daher gibt es zusätzliche 16 Bits, die wir ausleihen können, um einige Informationen zu speichern ... zum Beispiel die Geometrie, auf die wir zeigen.  Wenn wir ein wenig Arbeit hinzufügen, können wir auf die Möglichkeit zurückgreifen, ein Analogon von Aufrufen virtueller Funktionen zu erstellen. <br><br>  So wird es passieren: Zuerst definieren wir eine <code>ShapeMethods</code> Struktur, die Zeiger auf Funktionen enthält, wie z. B. <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Jede Geometrieimplementierung implementiert eine Einschränkungsfunktion, eine Schnittfunktion usw. und empfängt als erstes Argument ein Analogon <code>this</code> Zeigers: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  Wir hätten eine globale Tabelle mit <code>ShapeMethods</code> Strukturen, in der das <em>n-te</em> Element für einen Geometrietyp mit dem Index <em>n gilt</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Beim Erstellen von Geometrie codieren wir ihren Typ in einige der nicht verwendeten Bits des Rückgabezeigers.  Unter Berücksichtigung des Zeigers auf die Geometrie, deren spezifischen Aufruf wir ausführen möchten, extrahieren wir diesen <code>shapeMethods</code> aus dem Zeiger und verwenden ihn als Index in <code>shapeMethods</code> , um den entsprechenden Funktionszeiger zu finden.  Im Wesentlichen würden wir vtable manuell implementieren und den Versand selbst verarbeiten.  Wenn wir dies sowohl für Geometrie als auch für Grundelemente tun würden, würden wir 16 Bytes pro <code>Triangle</code> sparen, aber gleichzeitig haben wir einen ziemlich schwierigen Weg gemacht. <br><br>  Ich nehme an, dass ein solcher Hack zur Implementierung des Managements virtueller Funktionen nicht neu ist, aber ich konnte im Internet keine Links dazu finden.  Hier ist die Wikipedia-Seite über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">markierte Zeiger</a> , aber sie befasst sich mit Dingen wie der Anzahl der Links.  Wenn Sie einen besseren Link kennen, senden Sie mir einen Brief. <br><br>  Indem ich diesen unangenehmen Hack teile, kann ich die Reihe der Beiträge beenden.  Nochmals vielen Dank an Disney für die Veröffentlichung dieser Szene.  Es hat unglaublich viel Spaß gemacht, damit zu arbeiten.  Die Zahnräder in meinem Kopf drehen sich weiter. <br><br><h2>  Anmerkungen </h2><br><ol><li>  Am Ende verfolgt pbrt-next mehr Strahlen in dieser Szene als pbrt-v3, was wahrscheinlich die Zunahme der Anzahl von Suchoperationen erklärt. </li><li>  Die Strahldifferenzen für indirekte Strahlen in pbrt-next werden unter Verwendung des gleichen <a href="">Hacks</a> berechnet, der in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Textur-Cache-Erweiterung</a> für pbrt-v3 verwendet wird. ,     ,        . </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417939/">https://habr.com/ru/post/de417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417929/index.html">Auszug aus dem Buch „Ein Tag im Leben des Gehirns. Neurobiologie des Bewusstseins von morgens bis abends “</a></li>
<li><a href="../de417931/index.html">Techniken zur Spielerbindung: Beispiele aus Spielen verschiedener Genres</a></li>
<li><a href="../de417933/index.html">Sicherheitswoche 27: Gefälschtes iPhone und Sicherheitspreis</a></li>
<li><a href="../de417935/index.html">Memos zu künstlicher Intelligenz, maschinellem Lernen, Deep Learning und Big Data</a></li>
<li><a href="../de417937/index.html">Machen "eiserne" Leute Software?</a></li>
<li><a href="../de417941/index.html">Wo verschwindet das Wasser im Wasserkocher?</a></li>
<li><a href="../de417943/index.html">Serverless and React 2: Handfertigkeit und kein Betrug</a></li>
<li><a href="../de417945/index.html">Welche Werkzeuge hat die Parker-Sonde?</a></li>
<li><a href="../de417947/index.html">Datenvisualisierung für Ihr Webprojekt</a></li>
<li><a href="../de417949/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>