<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😣 🌋 💔 Indeks Bitmap di Go: kecepatan pencarian yang luar biasa 🦎 🍱 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Marko dan saya memberi ceramah di Gophercon Rusia tahun ini tentang jenis indeks yang sangat menarik yang disebut "indeks bitmap". Saya ingi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks Bitmap di Go: kecepatan pencarian yang luar biasa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Nama saya Marko dan saya memberi ceramah di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gophercon Rusia</a> tahun ini tentang jenis indeks yang sangat menarik yang disebut "indeks bitmap".  Saya ingin membaginya dengan komunitas, tidak hanya dalam format video, tetapi juga sebagai artikel.  Ini versi bahasa Inggris dan Anda bisa membaca bahasa Rusia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Selamat menikmati! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Materi tambahan, slide dan semua kode sumber dapat ditemukan di sini: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Rekaman video asli: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mari kita mulai! <br><br><h2>  Pendahuluan </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Hari ini saya akan berbicara tentang <br><br><ul><li>  Apa itu indeks. <br></li><li>  Apa itu indeks bitmap; <br></li><li>  Di mana itu digunakan.  Mengapa itu tidak digunakan di tempat yang tidak digunakan. <br></li><li>  Kita akan melihat implementasi sederhana di Go dan kemudian pergi di kompiler. <br></li><li>  Kemudian kita akan melihat implementasi yang sedikit kurang sederhana, tetapi terasa lebih cepat, dalam perakitan Go. <br></li><li>  Dan setelah itu, saya akan membahas "masalah" indeks bitmap satu per satu. <br></li><li>  Dan akhirnya, kita akan melihat solusi apa yang ada. <br></li></ul><br><h2>  Jadi apa itu indeks? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Indeks adalah struktur data berbeda yang terus diperbarui selain data utama, yang digunakan untuk mempercepat permintaan pencarian.  Tanpa indeks, pencarian akan melibatkan semua data (dalam proses yang juga dikenal sebagai "pemindaian penuh") dan proses itu memiliki kompleksitas algoritme linear.  Tetapi database biasanya mengandung data dalam jumlah besar, sehingga kompleksitas linier terlalu lambat.  Idealnya, kami ingin mencapai kecepatan kompleksitas logaritmik atau bahkan konstan. <br><br>  Ini adalah topik yang sangat besar dan kompleks yang melibatkan banyak pengorbanan, tetapi melihat ke belakang selama beberapa dekade implementasi database dan penelitian, saya berpendapat bahwa hanya ada beberapa pendekatan yang umum digunakan: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Pertama, mengurangi area pencarian dengan memotong seluruh area menjadi bagian-bagian yang lebih kecil, secara hierarkis. <br><br>  Secara umum, ini dicapai dengan menggunakan pohon.  Ini mirip dengan memiliki kotak-kotak kotak di lemari pakaian Anda.  Setiap kotak berisi bahan yang selanjutnya disortir ke dalam kotak yang lebih kecil, masing-masing untuk penggunaan tertentu.  Jika kami membutuhkan materi, kami akan lebih baik mencari kotak berlabel "materi" daripada kotak berlabel "cookie". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  Yang kedua adalah untuk menunjukkan secara tepat elemen tertentu atau grup elemen seperti pada peta hash atau indeks terbalik.  Menggunakan peta hash mirip dengan contoh sebelumnya, tetapi Anda menggunakan banyak kotak kecil yang tidak berisi kotak itu sendiri, melainkan item akhir. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  Pendekatan ketiga adalah menghilangkan kebutuhan untuk mencari sama sekali seperti pada filter bloom atau filter cuckoo.  Filter Bloom dapat langsung memberikan jawaban dan menghemat waktu untuk pencarian. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  Yang terakhir adalah mempercepat pencarian dengan memanfaatkan lebih baik kemampuan perangkat keras kami seperti dalam indeks bitmap.  Indeks Bitmap terkadang melibatkan seluruh indeks, ya, tetapi dilakukan dengan cara yang sangat efisien. <br><br>  Seperti yang sudah saya katakan, pencarian memiliki banyak pengorbanan, jadi seringkali kita akan menggunakan beberapa pendekatan untuk meningkatkan kecepatan lebih banyak atau untuk mencakup semua jenis pencarian potensial kita. <br><br>  Hari ini saya ingin berbicara tentang salah satu pendekatan yang kurang dikenal: indeks bitmap. <br><br><h2>  Tetapi siapakah saya untuk membicarakan hal ini? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Saya seorang pemimpin tim di Badoo (mungkin Anda tahu merek kami yang lain: Bumble).  Kami memiliki lebih dari 400 juta pengguna di seluruh dunia dan banyak fitur yang kami gunakan untuk mencari yang paling cocok untuk Anda!  Untuk tugas-tugas ini, kami menggunakan layanan yang dibuat khusus yang menggunakan indeks bitmap, antara lain. <br><br><h2>  Sekarang, apa itu indeks bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Seperti namanya, indeks Bitmap menggunakan bitmap alias bitet untuk mengimplementasikan indeks pencarian.  Dari sudut pandang mata burung, indeks ini terdiri dari satu atau beberapa bitmap yang mewakili entitas (misalnya orang) dan parameternya (misalnya usia, atau warna mata) dan algoritma untuk menjawab pertanyaan pencarian menggunakan operasi bitwise seperti AND, ATAU, TIDAK, dll. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Indeks Bitmap dianggap sangat berguna dan berkinerja tinggi jika Anda memiliki pencarian yang harus menggabungkan pertanyaan dengan beberapa kolom dengan kardinalitas rendah (mungkin, warna mata atau status perkawinan) versus sesuatu seperti jarak ke pusat kota yang memiliki kardinalitas tak terbatas. <br><br>  Tetapi nanti dalam artikel saya akan menunjukkan bahwa indeks bitmap bahkan bekerja dengan kolom kardinalitas tinggi. <br><br>  Mari kita lihat contoh paling sederhana dari indeks bitmap ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Bayangkan kita memiliki daftar restoran Moskow dengan karakteristik biner: <br><br><ul><li>  dekat metro <br></li><li>  memiliki parkir pribadi <br></li><li>  memiliki teras <br></li><li>  menerima pemesanan <br></li><li>  ramah vegan <br></li><li>  mahal <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Mari beri setiap restoran indeks mulai dari 0 dan alokasikan 6 bitmap (satu untuk setiap karakteristik).  Kemudian kami akan mengisi bitmap ini sesuai dengan apakah restoran tersebut memiliki karakteristik tertentu atau tidak.  Jika restoran nomor 4 memiliki teras, maka bit nomor 4 di bitmap "teras" akan ditetapkan ke 1 (0 jika tidak). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Kami sekarang memiliki indeks bitmap sesederhana mungkin yang dapat kami gunakan untuk menjawab pertanyaan seperti <br><br><ul><li>  Beri saya restoran yang ramah vegan <br></li><li>  Beri saya restoran dengan teras yang menerima pemesanan, tetapi tidak mahal <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Bagaimana?  Ayo lihat.  Pertanyaan pertama adalah yang sederhana.  Kami hanya mengambil bitmap "ramah vegan" dan mengembalikan semua indeks yang telah ditetapkan bit. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  Pertanyaan kedua sedikit lebih rumit.  Kami akan menggunakan operasi bitwise BUKAN pada bitmap "mahal" untuk mendapatkan restoran yang tidak mahal, DAN itu dengan bitmap "terima reservasi" dan DAN dengan "memiliki bitmap teras".  Bitmap yang dihasilkan akan terdiri dari restoran yang memiliki semua karakteristik ini yang kami inginkan.  Di sini kita melihat bahwa hanya Yunost yang memiliki semua karakteristik ini. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Ini mungkin terlihat sedikit teoretis tetapi jangan khawatir, kami akan segera mendapatkan kode. <br><br><h2>  Di mana indeks bitmap digunakan </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Jika Anda google "indeks bitmap", 90% dari hasilnya akan menunjuk ke Oracle DB yang memiliki indeks bitmap dasar.  Tapi, tentu saja, DBMS lain menggunakan indeks bitmap juga, bukan?  Tidak, sebenarnya tidak.  Mari kita pergi melalui tersangka biasa satu per satu. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  MySQL belum memiliki indeks bitmap, tetapi ada proposal untuk menambahkannya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ) <br></li><li>  PostgreSQL tidak memiliki indeks bitmap, tetapi mereka menggunakan bitmap sederhana dan operasi bitwise untuk menggabungkan hasil dari beberapa indeks yang berbeda. <br></li><li>  Tarantool memiliki indeks bitet dan memungkinkan pencarian yang sangat sederhana. <br></li><li>  Redis memiliki bidang bit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://redis.io/commands/bitfiel</a> d tanpa kemampuan pencarian <br></li><li>  MongoDB belum memilikinya, tetapi ada juga proposal untuk menambahkannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723)</a> <br></li><li>  Elasticsearch menggunakan bitmap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps secara</a> internal <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Tetapi ada anak laki-laki baru di blok: Pilosa.  Pilosa adalah DBMS baru yang ditulis dalam Go (perhatikan tidak ada R, itu tidak berhubungan) yang mendasarkan semuanya pada indeks bitmap.  Dan kita akan membicarakan Pilosa nanti. <br></li></ul><br><h2>  Implementasi berjalan </h2><br>  Tapi mengapa?  Mengapa indeks bitmap sangat jarang digunakan?  Sebelum menjawab pertanyaan itu, saya ingin memandu Anda melalui implementasi indeks bitmap dasar di Go. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  Bitmap direpresentasikan sebagai sepotong memori.  Dalam Go, mari kita gunakan irisan byte untuk itu. <br><br>  Kami memiliki satu bitmap per karakteristik restoran.  Setiap bit dalam bitmap mewakili apakah restoran tertentu memiliki karakteristik ini atau tidak. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  Kita membutuhkan dua fungsi pembantu.  Satu digunakan untuk mengisi bitmap secara acak, tetapi dengan probabilitas yang ditentukan untuk memiliki karakteristik.  Sebagai contoh, saya pikir ada sangat sedikit restoran yang tidak menerima reservasi dan sekitar 20% ramah vegan. <br><br>  Fungsi lain akan memberi kita daftar restoran dari bitmap. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Untuk menjawab pertanyaan "berikan saya restoran dengan teras yang menerima reservasi tetapi tidak mahal" kami akan membutuhkan dua operasi: BUKAN dan DAN. <br><br>  Kami dapat sedikit menyederhanakan kode dengan memperkenalkan operasi yang kompleks DAN TIDAK. <br><br>  Kami memiliki fungsi untuk masing-masingnya.  Kedua fungsi melewati irisan kami mengambil elemen yang sesuai dari masing-masing, melakukan operasi dan menulis hasilnya ke irisan yang dihasilkan. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  Dan sekarang kita dapat menggunakan bitmap kita dan fungsi kita untuk mendapatkan jawabannya. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  Performa tidak begitu hebat di sini meskipun fungsi kami sangat sederhana dan kami menghemat banyak alokasi dengan tidak mengembalikan irisan baru pada setiap pemanggilan fungsi. <br><br>  Setelah beberapa profil dengan pprof, saya perhatikan bahwa kompiler go melewatkan salah satu optimasi yang sangat mendasar: fungsi inlining. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Anda lihat, Go compiler secara patologis takut loop melalui irisan dan menolak untuk sebaris fungsi yang memiliki mereka. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Tapi saya tidak takut pada mereka dan bisa menipu kompiler dengan menggunakan goto untuk loop saya. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Seperti yang Anda lihat, inlining menyelamatkan kami sekitar 2 mikrodetik.  Tidak buruk! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Kemacetan lain mudah dikenali ketika Anda melihat lebih dekat pada output perakitan.  Kompilator Go menyertakan pemeriksaan rentang di loop kami.  Go adalah bahasa yang aman dan kompiler takut bahwa tiga bitmap saya mungkin memiliki panjang yang berbeda dan mungkin ada buffer overflow. <br><br>  Mari kita tenangkan kompiler dan tunjukkan bahwa semua bitmap saya memiliki panjang yang sama.  Untuk melakukan itu, kita dapat menambahkan pemeriksaan sederhana di awal fungsi. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Dengan pemeriksaan ini, kompilator go dengan senang hati akan melewati pemeriksaan rentang dan kami akan menghemat beberapa nanodetik. <br><br><h2>  Implementasi dalam perakitan </h2><br>  Baiklah, jadi kami berhasil memeras sedikit lebih banyak kinerja dengan implementasi sederhana kami, tetapi hasil ini jauh lebih buruk daripada apa yang mungkin terjadi dengan perangkat keras saat ini. <br><br>  Anda tahu, apa yang kami lakukan adalah operasi bitwise yang sangat mendasar dan CPU kami sangat efektif. <br><br>  Sayangnya, kami memberi makan CPU kami dengan potongan kerja yang sangat kecil.  Fungsi kami melakukan operasi byte demi byte.  Kita dapat dengan mudah mengubah implementasi kita agar bekerja dengan potongan 8-byte dengan menggunakan irisan uint64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Seperti yang Anda lihat di sini, kami memperoleh kinerja sekitar 8x untuk ukuran batch 8x, sehingga peningkatan kinerja cukup linier. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Tapi ini bukan akhir dari segalanya.  CPU kami memiliki kemampuan untuk bekerja dengan chunks 16-byte, 32-byte, dan bahkan dengan chunks 64-byte.  Operasi ini disebut SIMD (Single Instruction Multiple Data) dan proses penggunaan operasi CPU seperti itu disebut vektorisasi. <br><br>  Sayangnya, kompiler Go tidak terlalu baik dengan vektorisasi.  Dan satu-satunya hal yang dapat kita lakukan saat ini untuk membuat vektor kode kita adalah dengan menggunakan Go assembly dan menambahkan sendiri instruksi SIMD ini. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  Pergi perakitan adalah binatang aneh.  Anda akan berpikir bahwa perakitan adalah sesuatu yang terkait dengan arsitektur yang Anda tulis, tetapi perakitan Go lebih seperti IRL (bahasa representasi perantara): itu adalah platform-independen.  Rob Pike memberikan ceramah yang luar biasa tentang ini beberapa tahun yang lalu. <br><br>  Selain itu, Go menggunakan format plan9 yang tidak biasa yang tidak seperti format AT&amp;T dan Intel. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  Aman untuk mengatakan bahwa menulis kode assembly tidak menyenangkan. <br><br>  Beruntung bagi kami, sudah ada dua alat tingkat tinggi untuk membantu penulisan perakitan Go: PeachPy dan avo.  Kedua ini menghasilkan perakitan pergi dari kode tingkat yang lebih tinggi yang ditulis dalam Python dan Go masing-masing. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Alat-alat ini menyederhanakan hal-hal seperti alokasi register dan loop dan semuanya mengurangi kompleksitas memasuki ranah pemrograman perakitan untuk Go. <br><br>  Kami akan menggunakan menghindari untuk posting ini sehingga program kami terlihat hampir seperti kode Go biasa. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Ini adalah contoh paling sederhana dari program avo.  Kami memiliki fungsi utama () yang mendefinisikan fungsi yang disebut Tambah () yang menambahkan dua angka.  Ada fungsi pembantu untuk mendapatkan parameter berdasarkan nama dan untuk mendapatkan salah satu register umum yang tersedia.  Ada fungsi untuk setiap operasi perakitan seperti ADDQ di sini, dan ada fungsi pembantu untuk menyimpan hasil dari register ke nilai yang dihasilkan. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  Call go go akan menjalankan program avo ini dan dua file akan dibuat <br><br><ul><li>  add.s dengan kode perakitan yang dihasilkan <br></li><li>  stub.go dengan tajuk fungsi yang diperlukan untuk menghubungkan kode perakitan dan pergi kami <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Sekarang kita telah melihat apa yang dilakukan avo, mari kita lihat fungsi kita.  Saya telah mengimplementasikan versi skalar dan SIMD (vektor) dari fungsi kami. <br><br>  Mari kita lihat seperti apa versi skalar dulu. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Seperti dalam contoh sebelumnya, kita dapat meminta daftar umum dan menghindari memberi kita yang benar yang tersedia.  Kami tidak perlu melacak offset dalam byte untuk argumen kami, menghindari ini untuk kami. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Sebelumnya kami beralih dari loop ke menggunakan goto untuk alasan kinerja dan menipu kompilator.  Di sini, kami menggunakan goto (lompatan) dan label sejak awal karena loop adalah konstruksi tingkat yang lebih tinggi.  Dalam perakitan kami hanya memiliki lompatan. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  Kode lain harus cukup jelas.  Kami meniru loop dengan lompatan dan label, mengambil sebagian kecil data kami dari dua bitmap kami, menggabungkannya menggunakan salah satu operasi bitwise dan memasukkan hasilnya ke dalam bitmap yang dihasilkan. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  Ini adalah kode asm yang dihasilkan yang kami dapatkan.  Kami tidak harus menghitung offset dan ukuran (berwarna hijau), kami tidak harus berurusan dengan register tertentu (berwarna merah). <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Jika kita membandingkan implementasi ini dalam perakitan dengan yang terbaik sebelumnya yang ditulis dalam go kita akan melihat bahwa kinerjanya sama seperti yang diharapkan.  Kami tidak melakukan sesuatu yang berbeda. <br><br>  Sayangnya, kami tidak dapat memaksa Go compiler untuk menampilkan fungsi kami yang ditulis dalam asm.  Ini benar-benar tidak memiliki dukungan untuk itu dan permintaan untuk fitur ini telah ada selama beberapa waktu sekarang.  Itu sebabnya fungsi asm kecil di mana saja tidak memberikan manfaat.  Anda juga perlu menulis fungsi yang lebih besar, menggunakan paket matematika / bit baru atau melewatkan sama sekali. <br><br>  Mari kita tulis versi vektor dari fungsi kita sekarang. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  Saya memilih untuk menggunakan AVX2, jadi kita akan menggunakan potongan 32-byte.  Ini sangat mirip dengan skalar dalam struktur.  Kami memuat parameter, meminta register umum, dll. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  Salah satu perubahan berkaitan dengan fakta bahwa operasi vektor menggunakan register lebar spesifik.  Untuk 32 byte mereka memiliki awalan Y, inilah mengapa Anda melihat YMM () di sana.  Untuk 64-byte mereka akan memiliki awalan Z. <br><br>  Perbedaan lain berkaitan dengan optimasi yang saya lakukan disebut unrolling atau loop unrolling.  Saya memilih untuk membuka sebagian loop kami dan melakukan 8 operasi loop secara berurutan sebelum kembali.  Teknik ini mempercepat kode dengan mengurangi cabang-cabang yang kami miliki dan itu sangat dibatasi oleh jumlah register yang kami miliki. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  Adapun kinerja ... itu luar biasa.  Kami mendapat peningkatan 7x dibandingkan dengan yang terbaik sebelumnya.  Cukup mengesankan, bukan? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Seharusnya dimungkinkan untuk meningkatkan hasil ini lebih banyak lagi dengan menggunakan AVX512, prefetching dan mungkin bahkan dengan menggunakan kompilasi JIT (tepat pada waktunya) alih-alih pembuat rencana kueri "manual", tetapi itu akan menjadi subjek untuk posting yang sama sekali berbeda. <br><br><h2>  Masalah indeks bitmap </h2><br>  Sekarang kita telah melihat implementasi dasar dan kecepatan implementasi asm yang mengesankan, mari kita bicara tentang fakta bahwa indeks bitmap tidak banyak digunakan.  Kenapa begitu? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  Publikasi lama memberi kita tiga alasan ini.  Tetapi yang baru-baru ini dan saya berpendapat bahwa ini telah "diperbaiki" atau ditangani sekarang.  Saya tidak akan membahas banyak detail tentang hal ini di sini karena kami tidak punya banyak waktu, tetapi tentu saja layak untuk dilihat sekilas. <br><br><h2>  Masalah kardinalitas tinggi </h2><br>  Jadi, kami telah diberitahu bahwa indeks bitmap hanya layak untuk bidang kardinalitas rendah.  yaitu bidang yang memiliki beberapa nilai berbeda, seperti jenis kelamin atau warna mata.  Alasannya adalah bahwa representasi umum (satu bit per nilai berbeda) dapat menjadi cukup besar untuk nilai kardinalitas tinggi.  Dan, akibatnya, bitmap bisa menjadi besar bahkan jika jarang penduduknya. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  Kadang-kadang representasi yang berbeda dapat digunakan untuk bidang-bidang ini seperti representasi angka biner seperti yang ditunjukkan di sini, tetapi pengubah permainan terbesar adalah kompresi.  Para ilmuwan telah datang dengan algoritma kompresi yang luar biasa.  Hampir semua didasarkan pada algoritma run-length yang tersebar luas, tetapi yang lebih menakjubkan adalah kita tidak perlu mendekompres bitmap untuk melakukan operasi bitwise.  Operasi bitwise normal bekerja pada bitmap terkompresi. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  Baru-baru ini, kami telah melihat pendekatan hibrid tampak seperti "bitmap menderu".  Roaring bitmap menggunakan tiga representasi terpisah untuk bitmap: bitmap, array, dan "bit run" dan keduanya menyeimbangkan penggunaan ketiga representasi ini untuk memaksimalkan kecepatan dan meminimalkan penggunaan memori. <br><br>  Bitmap yang menderu dapat ditemukan di beberapa aplikasi yang paling banyak digunakan di luar sana dan ada implementasi untuk banyak bahasa, termasuk beberapa implementasi untuk Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Pendekatan lain yang dapat membantu bidang kardinalitas tinggi disebut binning.  Bayangkan kita memiliki bidang yang mewakili tinggi badan seseorang.  Tinggi adalah pelampung, tetapi kita tidak berpikir seperti itu.  Tidak ada yang peduli jika tinggi badan Anda 185,2 atau 185,3 cm.  Jadi kita bisa menggunakan "tempat sampah virtual" untuk memeras ketinggian yang sama ke tempat sampah yang sama: tempat sampah 1 cm, dalam hal ini.  Dan jika Anda berasumsi bahwa ada sangat sedikit orang dengan ketinggian kurang dari 50 cm, atau lebih dari 250 cm, kita dapat mengubah tinggi kita menjadi bidang dengan kira-kira 200 kardinalitas elemen, alih-alih kardinalitas yang hampir tak terbatas.  Jika perlu, kami bisa melakukan pemfilteran tambahan pada hasil nanti. <br><br><h2>  Masalah throughput tinggi </h2><br>  Alasan lain mengapa indeks bitmap buruk adalah karena mahal untuk memperbarui bitmap. <br>  Basis data melakukan pembaruan dan pencarian secara paralel, sehingga Anda harus dapat memperbarui data sementara mungkin ada ratusan utas melalui bitmap melakukan pencarian.  Kunci akan diperlukan kunci untuk mencegah ras data atau masalah konsistensi data.  Dan di mana ada satu kunci besar, ada pertikaian kunci. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Masalah ini, jika Anda memilikinya, dapat diperbaiki dengan sharding indeks Anda atau dengan memiliki versi indeks, jika sesuai. <br><br>  Sharding sangat mudah.  Anda beling mereka seperti Anda akan beling pengguna dalam database dan sekarang, bukan satu kunci, Anda memiliki beberapa kunci yang sangat mengurangi pertengkaran kunci Anda. <br><br>  Pendekatan lain yang kadang-kadang layak adalah memiliki indeks berversi.  Anda memiliki indeks yang Anda gunakan untuk pencarian dan Anda memiliki indeks yang Anda gunakan untuk menulis, untuk pembaruan.  Dan Anda menyalin dan mengalihkannya pada frekuensi rendah, misalnya 100 atau 500 ms. <br><br>  Tetapi pendekatan ini hanya layak jika aplikasi Anda dapat mentolerir indeks pencarian basi yang sedikit basi. <br>  Tentu saja, kedua pendekatan ini juga dapat digunakan bersama.  Anda dapat memiliki indeks versi yang diarding. <br><br><h2>  Kueri yang tidak sepele </h2><br>  Masalah indeks bitmap lain berkaitan dengan menggunakan indeks bitmap dengan kueri rentang.  Dan pada pandangan sekilas operasi bitwise seperti DAN dan ATAU tampaknya tidak sangat berguna untuk berbagai pertanyaan seperti "beri saya kamar hotel yang harganya 200 hingga 300 dolar semalam". <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Solusi naif dan sangat tidak efisien adalah mendapatkan hasil untuk setiap titik harga dari 200 hingga 300 dan ke ATAU hasilnya. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Pendekatan yang sedikit lebih baik adalah menggunakan binning dan menempatkan hotel kami ke dalam kisaran harga dengan kisaran lebar, katakanlah, 50 dolar.  Pendekatan ini akan mengurangi biaya pencarian kami sekitar 50x. <br><br>  Tetapi masalah ini juga dapat diselesaikan dengan sangat mudah dengan menggunakan pengkodean khusus yang memungkinkan berbagai pertanyaan dan cepat.  Dalam literatur, bitmap semacam ini disebut bitmap rentang-disandikan. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  Dalam bitmap yang dikodekan rentang, kami tidak hanya menetapkan bit tertentu untuk, katakanlah, nilai 200, tetapi atur semua bit pada 200 dan lebih tinggi.  Sama untuk 300. <br><br>  Jadi, dengan menggunakan bitmap representasi rentang-kode ini, kueri rentang dapat dijawab dengan hanya dua melewati bitmap.  Kami mendapatkan semua hotel yang harganya kurang dari, atau sama dengan, 300 dolar dan menghapus dari hasilnya semua hotel yang harganya kurang dari, atau sama dengan, 199 dolar.  Selesai <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Anda akan kagum tetapi bahkan permintaan geo dimungkinkan menggunakan bitmap.  Caranya adalah dengan menggunakan representasi seperti Google S2 atau serupa yang melingkupi koordinat dalam angka geometris yang dapat direpresentasikan sebagai tiga atau lebih garis yang diindeks.  Jika Anda menggunakan representasi seperti itu, Anda dapat mewakili kueri geo sebagai beberapa kueri rentang pada indeks garis ini. <br><br><h2>  Solusi siap </h2><br>  Yah, saya harap saya sedikit menggelitik minat Anda.  Anda sekarang memiliki satu alat lagi di bawah ikat pinggang Anda dan jika Anda perlu menerapkan sesuatu seperti ini di layanan Anda, Anda akan tahu ke mana harus mencari. <br><br>  Itu semua baik dan bagus, tetapi tidak semua orang memiliki waktu, kesabaran dan sumber daya untuk mengimplementasikan indeks bitmap sendiri terutama ketika datang ke hal-hal yang lebih maju seperti instruksi SIMD. <br><br>  Jangan takut, ada dua produk open source yang dapat membantu Anda dalam usaha Anda. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Mengaum </h2><br>  Pertama, ada perpustakaan yang sudah saya sebutkan disebut "roaring bitmap".  Pustaka ini menerapkan "wadah" menderu dan semua operasi bitwise yang Anda perlukan jika Anda ingin menerapkan indeks bitmap penuh. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Sayangnya, implementasi go tidak menggunakan SIMD, sehingga mereka memberikan kinerja yang agak lebih rendah daripada, katakanlah, implementasi C. <br><br><h2>  Pilosa </h2><br>  Produk lain adalah DBMS yang disebut Pilosa yang hanya memiliki indeks bitmap.  Ini adalah proyek baru-baru ini, tetapi belakangan ini mendapatkan banyak daya tarik. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  Pilosa menggunakan bitmap menderu di bawahnya dan memberi, menyederhanakan, atau menjelaskan hampir semua hal yang telah saya sampaikan kepada Anda hari ini: binning, bitmap yang dikodekan-range, gagasan bidang, dll. <br><br>  Mari kita lihat secara singkat contoh Pilosa yang digunakan ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  Contoh yang Anda lihat sangat mirip dengan apa yang kita lihat sebelumnya.  Kami membuat klien ke server pilosa, membuat indeks dan bidang untuk karakteristik kami.  Kami mengisi bidang dengan data acak dengan beberapa probabilitas seperti yang kami lakukan sebelumnya dan kemudian kami menjalankan permintaan pencarian kami. <br>  Anda melihat pola dasar yang sama di sini.  TIDAK mahal berpotongan atau AND-ed dengan teras dan berpotongan dengan pemesanan. <br><br>  Hasilnya seperti yang diharapkan. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  Dan terakhir, saya berharap suatu saat nanti, basis data seperti mysql dan postgresql akan mendapatkan jenis indeks baru: indeks bitmap. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Kata penutup </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  Dan jika Anda masih terjaga, saya berterima kasih untuk itu.  Kekurangan waktu berarti saya harus membaca banyak hal di postingan ini, tapi saya harap ini berguna dan bahkan mungkin menginspirasi. <br><br>  Indeks Bitmap adalah hal yang berguna untuk diketahui dan dipahami bahkan jika Anda tidak membutuhkannya sekarang.  Simpan sebagai alat lain dalam portofolio Anda. <br><br>  Selama pembicaraan saya, kami telah melihat berbagai trik kinerja yang dapat kami gunakan dan hal-hal yang sulit untuk diatasi saat ini.  Ini jelas hal-hal yang perlu diketahui oleh setiap programmer Go. <br><br>  Dan ini semua yang saya miliki untuk Anda saat ini.  Terima kasih banyak </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455608/">https://habr.com/ru/post/id455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455598/index.html">Tingkatkan segera Exim ke 4,92 - ada infeksi aktif</a></li>
<li><a href="../id455600/index.html">Platform 3DEXPERIENCE Membantu Menciptakan Transportasi Publik di Masa Depan</a></li>
<li><a href="../id455602/index.html">Browser memprovokasi crash dengan fuzzing perilaku</a></li>
<li><a href="../id455604/index.html">Dimungkinkan untuk mengelola konfigurasi Windows. Kisah sukses</a></li>
<li><a href="../id455606/index.html">Pembelajaran Mesin dan Analisis Data: Program Master di Sekolah Tinggi Ekonomi di St. Petersburg</a></li>
<li><a href="../id455610/index.html">Intel Core i7-2600K Legendaris: menguji Sandy Bridge pada 2019 (bagian 1)</a></li>
<li><a href="../id455612/index.html">Kami memikirkan karakter permainan dan dialog berdasarkan saran dari penulis dan pada contoh pendukung teori Bumi yang datar</a></li>
<li><a href="../id455614/index.html">FFI: menulis di Rust dalam program PHP</a></li>
<li><a href="../id455616/index.html">Mengapa pergi ke "Pemrograman Industri" di HSE St. Petersburg?</a></li>
<li><a href="../id455618/index.html">DevOps LEGO: bagaimana kami meletakkan pipa di atas kubus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>