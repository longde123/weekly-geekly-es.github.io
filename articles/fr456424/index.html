<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõê üÜí üèø Utreexo: compresser beaucoup de Bitcoin UTXO üöø üëàüèæ üåù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 


 Dans le r√©seau Bitcoin, tous les n≈ìuds s'accordent par consensus sur les nombreux UTXO: combien de pi√®ces sont disponibles pour les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo: compresser beaucoup de Bitcoin UTXO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Bonjour, Habr! </p><br><p>  Dans le r√©seau Bitcoin, tous les n≈ìuds s'accordent par consensus sur les nombreux UTXO: combien de pi√®ces sont disponibles pour les d√©penses, √† qui et dans quelles conditions.  Un ensemble d'UTXO est un ensemble de donn√©es qui est minimalement n√©cessaire pour un n≈ìud de validation, sans lequel un n≈ìud ne peut pas v√©rifier la validit√© des transactions entrantes et les blocs qui les contiennent. </p><br><p>  A cet √©gard, des efforts sont faits de toutes les mani√®res pour r√©duire la repr√©sentation stock√©e de cet ensemble, pour le comprimer sans perte de garanties de s√©curit√©.  Plus le volume de donn√©es stock√©es est petit, plus les exigences d'espace disque du noeud de validation sont faibles, ce qui rend le lancement du noeud de validation bon march√©, vous permet d'√©tendre le r√©seau et ainsi d'augmenter la stabilit√© du r√©seau. </p><br><p>  Dans cette note, nous couvrirons le prototype Rust d'une proposition r√©cente du co-auteur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lightning Network Paper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utreexo: un accumulateur dynamique bas√© sur le hachage optimis√© pour l'ensemble Bitcoin UTXO</a> , qui r√©duit les besoins en espace disque pour les n≈ìuds de validation. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Quel est le probl√®me? </h2><br><p>  L'un des probl√®mes √©ternels du Bitcoin √©tait son √©volutivit√©.  L'id√©e de ¬´poss√©der une banque¬ª oblige les participants au r√©seau √† garder une trace de tous les fonds disponibles √† utiliser.  Dans Bitcoin, les fonds disponibles sont exprim√©s comme un ensemble de sorties non d√©pens√©es - ensemble UTXO.  Bien que ce ne soit pas une vue tr√®s intuitive, il est avantageux en termes de performances d'impl√©mentation, par rapport √† une vue dans laquelle chaque portefeuille a un ¬´√©quilibre¬ª en tant qu'entr√©e distincte, et ajoute √©galement de la confidentialit√© (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoinJoin</a> fournit du travail). </p><br><p>  Il est important de faire la distinction entre l'historique des transactions (ce qu'on appelle une blockchain) et l'√©tat actuel du syst√®me.  L'historique des transactions de Bitcoin occupe actuellement environ 200 Go d'espace disque et continue de cro√Ætre.  Cependant, l'√©tat du syst√®me est beaucoup plus petit, environ 4 Go, et ne prend en compte que le fait que quelqu'un poss√®de actuellement des pi√®ces.  Le volume de ces donn√©es augmente √©galement avec le temps, mais √† un rythme beaucoup plus faible et tend m√™me parfois √† diminuer (voir KDPV). </p><br><p>  Les clients l√©gers (SPV) √©changent des garanties de s√©curit√© contre la possibilit√© de ne stocker aucun √©tat minimum (ensemble UTXO), √† l'exception des cl√©s priv√©es. </p><br><h2 id="utxo-i-utxo-set">  UTXO et UTXO-set </h2><br><p>  UTXO (sortie de transaction non d√©pens√©e) - sortie de transaction non d√©pens√©e, le point final du voyage de chaque satoshi transmis dans les transactions.  Les sorties non d√©pens√©es deviennent des entr√©es de nouvelles transactions et passent en m√™me temps et sont supprim√©es de l'ensemble UTXO. </p><br><p>  Les nouveaux UTXO sont toujours cr√©√©s par des transactions: </p><br><ul><li>  transactions Coinbase sans intrants: cr√©ez de nouveaux UTXO lors de l'√©mission de pi√®ces par les mineurs </li><li>  transactions conventionnelles: cr√©ez de nouveaux UTXO, tout en d√©pensant un ensemble d'UTXO existants </li></ul><br><p>  Le processus de travail avec UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  Les portefeuilles tiennent compte du nombre de pi√®ces disponibles pour les d√©penses (solde) en fonction du montant d'UTXO disponible pour ce portefeuille pour les d√©penses. </p><br><p>  Chaque n≈ìud de validateur, pour √©viter les tentatives de double d√©pense, doit suivre la collecte de <strong>tous les</strong> UTXO lors de la v√©rification de <strong>chaque</strong> transaction de <strong>chaque</strong> bloc. </p><br><p>  Le n≈ìud doit avoir une logique: </p><br><ul><li>  Ajouts √† l'ensemble UTXO </li><li>  Suppressions d√©finies par UTXO </li><li>  V√©rifie la pr√©sence d'un seul UTXO dans l'ensemble </li></ul><br><p>  Il existe des moyens de r√©duire les exigences relatives aux informations stock√©es sur l'ensemble, tout en conservant la possibilit√© d'ajouter et de supprimer des √©l√©ments, de v√©rifier et de prouver l'existence d'un √©l√©ment dans l'ensemble √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">batteries cryptographiques</a> . </p><br><h2 id="akkumulyatory-dlya-utxo">  Batteries pour UTXO </h2><br><p>  L'id√©e d'utiliser des batteries pour stocker de nombreux UTXO a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©t√© discut√©e</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©demment</a> . </p><br><p>  UTXO-set est construit √† la vol√©e, pendant le chargement initial de la cha√Æne de blocs (IBD, t√©l√©chargement de bloc initial), est stock√© en totalit√© et en permanence, tandis que son contenu change apr√®s le traitement des transactions de chaque nouveau bloc r√©seau correct.  Ce processus n√©cessite le t√©l√©chargement d'environ 200 Go de blocs de donn√©es et la v√©rification de centaines de millions de signatures num√©riques.  Une fois le processus IBD termin√©, dans le r√©sidu sec, l'ensemble UTXO occupera environ 4 Go. </p><br><p>  Cependant, lors de l'utilisation de piles, les r√®gles de consensus concernant les fonds se r√©sument √† la v√©rification et √† la g√©n√©ration de preuves cryptographiques, et le fardeau du suivi des fonds disponibles est plac√© sur les √©paules du propri√©taire de ces fonds, ce qui fournit la preuve de leur pr√©sence et de leur propri√©t√©. </p><br><p>  La batterie peut √™tre appel√©e une repr√©sentation compacte de l'ensemble.  Dans ce cas, la taille de la vue stock√©e doit √™tre constante <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">O</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-4">1</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.66ex" viewBox="0 -832 2043 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-31" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-29" x="1653" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  , ou augmenter de fa√ßon sublin√©aire par rapport √† la puissance de l'ensemble et √† la taille de l'√©l√©ment lui-m√™me, par exemple <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">O</span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">g</span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">n</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.724ex" height="2.66ex" viewBox="0 -832 4186.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6C" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6F" x="1451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-67" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-28" x="2417" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6E" x="2807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-29" x="3407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-29" x="3797" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  o√π n est la puissance de l'ensemble stock√©. </p><br><p>  Dans ce cas, l'accumulateur doit permettre de g√©n√©rer des preuves de l'inclusion d'un √©l√©ment dans l'ensemble (preuve d'inclusion) et lui permettre de v√©rifier efficacement cette preuve. </p><br><p>  Une batterie est appel√©e <strong>dynamique</strong> si elle vous permet d'ajouter des √©l√©ments et de supprimer des √©l√©ments de l'ensemble. </p><br><p>  Un exemple d'une telle batterie est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">batterie RSA propos√©e par Boneh, Bunz, Fisch en d√©cembre 2018</a> .  Une telle batterie a une taille constante de la vue stock√©e, mais n√©cessite un <em>secret partag√©</em> (configuration de confiance).  Cette exigence annule l'applicabilit√© d'un tel accumulateur pour les r√©seaux sans confiance tels que Bitcoin, car les fuites de donn√©es lors de la g√©n√©ration d'un secret peuvent permettre aux attaquants de cr√©er de fausses preuves de l'existence d'UTXO en usurpant des n≈ìuds avec un ensemble UTXO bas√© sur un tel accumulateur. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  La conception propos√©e par Thatredeus Dryja d'Utreexo vous permet de cr√©er une batterie <strong>dynamique</strong> <strong>sans</strong> configuration de confiance. </p><br><p>  Utreexo est une for√™t d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbres de Merkle</a> binaires id√©aux et est un d√©veloppement des id√©es pr√©sent√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Accumulateurs asynchrones efficaces pour pki distribu√©</a> , ajoutant la possibilit√© de supprimer des √©l√©ments de l'ensemble. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  La structure logique de la batterie </h4><br><p>  Les cellules de la batterie sont dispos√©es dans une for√™t d'arbres binaires parfaits.  Les arbres sont class√©s par hauteur.  Cette pr√©sentation a √©t√© choisie comme la plus visuelle et permet de visualiser la fusion des arbres lors des op√©rations sur la batterie. </p><br><p>  L'auteur note que puisque tous les arbres de la for√™t sont parfaits, leur hauteur est exprim√©e par la puissance de deux, tout comme n'importe quel nombre naturel peut √™tre repr√©sent√© comme la somme des puissances de deux.  Par cons√©quent, tout ensemble de feuilles peut √™tre regroup√© sous la forme d'arbres binaires et, dans tous les cas, l'ajout d'un nouvel √©l√©ment n√©cessite une connaissance <em>uniquement des n≈ìuds racine des arbres stock√©s</em> . </p><br><p>  Ainsi, la vue stock√©e de la batterie Utreexo est une liste de n≈ìuds racine (racine Merkle), <em>et non la for√™t enti√®re d'arbres</em> . </p><br><p> Imaginez la liste des √©l√©ments racine comme <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  Le type <code>Option&lt;Hash&gt;</code> optionnel indique que l'√©l√©ment racine peut √™tre manquant, ce qui signifie que l'arbre n'a pas d'arbre avec une hauteur appropri√©e. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Ajout d'√©l√©ments </h4><br><p>  Tout d'abord, nous d√©crivons la fonction <code>parent()</code> , qui reconna√Æt le n≈ìud parent pour deux √©l√©ments donn√©s. </p><br><div class="spoiler">  <b class="spoiler_title">Fonction Parent ()</b> <div class="spoiler_text"><p>  Puisque nous utilisons des arbres Merkle, le parent de chacun des deux n≈ìuds est un n≈ìud qui stocke le hachage de concat√©nation des hachages des n≈ìuds descendants: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  L'auteur note que pour emp√™cher les attaques d√©crites par Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir et S√©bastien Zimmer dans <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxi√®mes attaques de pr√©image sur les fonctions de hachage tram√©es</a> , en plus de deux hachages, vous devez ajouter de la hauteur √† l'int√©rieur de l'arbre √† la concat√©nation. </p></div></div><br><p>  Lors de l'ajout d'√©l√©ments √† la batterie, vous devez garder une trace des √©l√©ments racine qui sont modifi√©s.  En suivant le chemin de modification des √©l√©ments racine pour chaque √©l√©ment ajout√©, vous pourrez ult√©rieurement construire une preuve de la pr√©sence de ces √©l√©ments. </p><br><div class="spoiler">  <b class="spoiler_title">Suivre les modifications pendant le t√©l√©chargement</b> <div class="spoiler_text"><p>  Pour suivre les modifications apport√©es, nous d√©clarerons la structure de <code>Update</code> , qui stockera les donn√©es sur les modifications des n≈ìuds. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  Pour ajouter un √©l√©ment √† la batterie, vous avez besoin de: </p><br><ul><li>  Cr√©ez un tableau de paniers d'√©l√©ments racine <code>new_roots</code> et placez-y les √©l√©ments racine existants, un pour chaque panier: </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  Ajoutez les √©l√©ments ajout√©s (tableau d' <code>insertions</code> ) au premier panier <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  Proc√©der √† la ¬´coalescence¬ª des articles ajout√©s au premier panier avec le reste: <br><ul><li>  Pour tous les paniers contenant plus d'un article: <br><ol><li>  Nous prenons deux √©l√©ments de la fin du panier, calculons leur parent, supprimons les deux √©l√©ments </li><li>  Ajoutez le parent calcul√© au panier suivant. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  D√©placer les √©l√©ments racine des paniers vers le r√©seau de batteries r√©sultant </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Cr√©ation de preuves pour les √©l√©ments ajout√©s </h4><br><p>  La preuve de l'inclusion de l'√©l√©ment dans la batterie ( <code>Proof</code> ) sera le Merkle Path, compos√© d'une cha√Æne de <code>ProofStep</code> .  Si le chemin ne m√®ne nulle part, alors la preuve est fausse. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  En utilisant les informations obtenues pr√©c√©demment lors de l'ajout de l'√©l√©ment (structure de <code>Update</code> ), vous pouvez cr√©er la preuve que l'√©l√©ment a √©t√© ajout√© √† la batterie.  Pour ce faire, nous contournons le tableau des modifications apport√©es et ajoutons chaque √©tape au chemin de Merkle, qui servira ensuite de preuve: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Processus de preuve</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Preuve de preuve d'un article </h4><br><p>  La v√©rification de la preuve de l'inclusion de l'√©l√©ment (preuve d'inclusion) se r√©duit √† suivre le chemin de Merkle, jusqu'√† ce qu'elle m√®ne √† l'√©l√©ment racine existant: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Clairement: </p><br><div class="spoiler">  <b class="spoiler_title">Processus de v√©rification des preuves pour A</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Supprimer des √©l√©ments </h4><br><p>  Pour retirer un √©l√©ment de la batterie, vous devez fournir une preuve valide que l'√©l√©ment est l√†.  En utilisant les donn√©es de la preuve, nous pouvons calculer les nouveaux √©l√©ments racine de la batterie pour lesquels cette preuve ne sera plus vraie. </p><br><p>  L'algorithme est le suivant: </p><br><ol><li>  Comme pour l'ajout, nous organisons un ensemble de paniers vides correspondant aux arbres de Merkle avec une hauteur √©gale √† deux de l'indice du panier </li><li>  Ins√©rez des articles des √©tapes du chemin Merkle dans les paniers  l'indice du panier est √©gal au num√©ro de pas actuel </li><li>  Nous supprimons l'√©l√©ment racine auquel m√®ne le chemin de la preuve. </li><li>  Comme pour l'ajout, nous calculons les nouveaux √©l√©ments racine, en combinant les √©l√©ments des paniers par paires et en d√©pla√ßant le r√©sultat de l'union vers le panier suivant </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  Le processus de suppression de l'√©l√©ment "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Int√©gration dans un r√©seau existant </h2><br><p>  En utilisant la batterie propos√©e, les n≈ìuds peuvent refuser d'utiliser la base de donn√©es pour stocker tous les UTXO, tout en conservant la possibilit√© de changer l'ensemble UTXO.  Cependant, il y a le probl√®me de travailler avec des preuves. </p><br><p>  Nous appellerons un n≈ìud de validation qui utilise un <em>compact de</em> batterie UTXO (n≈ìud √† √©tat compact), et un validateur sans batterie - <em>plein</em> (n≈ìud complet).  L'existence de deux classes de n≈ìuds pose le probl√®me de leur int√©gration dans un m√™me r√©seau, car les n≈ìuds compacts n√©cessitent une preuve de l'existence d'UTXO, qui est d√©pens√© en transactions, mais pas les n≈ìuds complets.  Si tous les n≈ìuds du r√©seau en m√™me temps et de mani√®re coordonn√©e ne passent pas √† Utreexo, les n≈ìuds compacts seront laiss√©s pour compte et ne pourront pas travailler sur le r√©seau Bitcoin. </p><br><p>  Pour r√©soudre le probl√®me de l'int√©gration de n≈ìuds compacts dans le r√©seau, il est propos√© d'introduire une classe suppl√©mentaire de n≈ìuds - <em>ponts</em> .  Un n≈ìud de pont est un n≈ìud complet qui, entre autres, stocke la batterie Utreexo et les preuves d'inclusion pour <strong>tous les</strong> UTXO de l'ensemble UTXO.  Les ponts calculent de nouveaux hachages et mettent √† jour la batterie et les preuves √† mesure que de nouveaux blocs arrivent avec les transactions.  La prise en charge et la mise √† jour de la batterie et des preuves n'imposent pas de charge de calcul suppl√©mentaire √† ces n≈ìuds.  Les ponts sacrifient l'espace disque: maintenez l'ordre dans l'ordre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6E" x="500" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  hachage par rapport √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">g</span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">n</span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.141ex" height="2.66ex" viewBox="0 -832 2644 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-28" x="1264" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMATHI-6E" x="1654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhhMQv7z-JD0TtgBE0S1j_ZWv-FxGg#MJMAIN-29" x="2254" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  hachages pour les n≈ìuds compacts, o√π n est la puissance de l'ensemble UTXO. </p><br><h3 id="arhitektura-seti">  Architecture de r√©seau </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  Les ponts permettent d'ajouter progressivement des n≈ìuds compacts au r√©seau sans changer le logiciel des n≈ìuds existants.  Les n≈ìuds complets fonctionnent comme auparavant, r√©partissant les transactions et les blocs entre eux.  Les n≈ìuds de pont sont des n≈ìuds complets qui stockent en outre des donn√©es de batterie Utreexo et un ensemble de preuves d'inclusion pour <strong>tous les</strong> UTXO pour le moment.  Le n≈ìud de pont ne se pr√©sente pas comme tel, pr√©tendant √™tre un n≈ìud complet pour tous les n≈ìuds complets et un n≈ìud compact pour tous les n≈ìuds compacts.  Bien que les ponts relient les deux r√©seaux ensemble, en r√©alit√©, ils doivent √™tre connect√©s dans une seule direction: des n≈ìuds complets existants aux n≈ìuds compacts.  Cela est possible car le format de transaction n'a pas besoin d'√™tre modifi√© et les preuves pour UTXO pour les n≈ìuds compacts peuvent √™tre rejet√©es, de sorte que tout n≈ìud compact peut envoyer des transactions √† tous les participants du r√©seau de la m√™me mani√®re sans la participation des n≈ìuds de pont. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Nous avons examin√© la batterie Utreexo et mis en ≈ìuvre son prototype √† Rust.  Nous avons examin√© l'architecture du r√©seau, qui int√©grera les n≈ìuds bas√©s sur la batterie.  L'avantage de la capture compacte est la taille des donn√©es stock√©es, qui d√©pend logarithmiquement de la puissance de nombreux UTXO, ce qui r√©duit consid√©rablement les besoins en espace disque et les performances de stockage pour ces n≈ìuds.  L'inconv√©nient est un trafic de n≈ìuds suppl√©mentaire pour le transfert de preuves, mais les techniques d'agr√©gation de preuves (lorsqu'une preuve prouve l'existence de plusieurs √©l√©ments) et la mise en cache peuvent aider √† maintenir le trafic dans des limites acceptables. </p><br><p>  <strong>R√©f√©rences</strong> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utreexo Rust Prototype GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utreexo: un accumulateur dynamique bas√© sur le hachage optimis√© pour l'ensemble Bitcoin UTXO</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oeuvre anim√©e d'un article</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456424/">https://habr.com/ru/post/fr456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456412/index.html">Innovation controvers√©e de Yandex - connectez-vous √† votre compte via une lettre</a></li>
<li><a href="../fr456414/index.html">Protection contre les incendies dans les centres de donn√©es ou comment les donn√©es sont stock√©es</a></li>
<li><a href="../fr456416/index.html">Agile for All Book</a></li>
<li><a href="../fr456418/index.html">Une br√®ve histoire de la triche sur les jeux vid√©o</a></li>
<li><a href="../fr456422/index.html">Annonce d'une nouvelle version de Styled Components v5: Animal Grin</a></li>
<li><a href="../fr456426/index.html">BASS - un cadre pour la synth√®se automatique des signatures antivirus</a></li>
<li><a href="../fr456430/index.html">L'√©ternelle question de la dette technique</a></li>
<li><a href="../fr456432/index.html">Security Week 25: vuln√©rabilit√© d'Evernote et des centaines de boutiques en ligne pirat√©es</a></li>
<li><a href="../fr456434/index.html">Professions du futur: ¬´Qui travaillerez-vous sur Mars?¬ª</a></li>
<li><a href="../fr456436/index.html">T√¢che JS courte pour lundi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>