<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍷 💄 📶 Categorías de expresiones en C ++ 🥌 🐽 🚰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las categorías de expresiones, como lvalue y rvalue , se relacionan más con los conceptos teóricos fundamentales del lenguaje C ++ que con los aspecto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Categorías de expresiones en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Las categorías de expresiones, como <strong>lvalue</strong> y <strong>rvalue</strong> , se relacionan más con los conceptos teóricos fundamentales del lenguaje C ++ que con los aspectos prácticos de su uso.  Por esta razón, muchos programadores incluso experimentados tienen una vaga idea de lo que significan.  En este artículo intentaré explicar el significado de estos términos de la manera más simple posible, diluyendo la teoría con ejemplos prácticos.  Haré una reserva de inmediato: el artículo no pretende proporcionar la descripción más completa y rigurosa de las categorías de expresiones, para más detalles recomiendo contactar directamente a la fuente: estándar de lenguaje C ++. </p><a name="habracut"></a><br><blockquote>  El artículo contendrá muchos términos en inglés, esto se debe al hecho de que algunos de ellos son difíciles de traducir al ruso, mientras que otros se traducen en diferentes fuentes de diferentes maneras.  Por lo tanto, a menudo indicaré términos en inglés, resaltándolos <em>en cursiva</em> . </blockquote><br><h2 id="nemnogo-istorii">  Un poco de historia </h2><br><p>  Los términos <strong>lvalue</strong> y <strong>rvalue</strong> aparecieron en C. Vale la pena señalar que la confusión se estableció inicialmente en la terminología, porque se refieren a expresiones y no a valores.  Históricamente, un valor de <strong>l</strong> es lo que puede quedar del operador de asignación, y un valor de <strong>r</strong> es lo que solo puede ser <em>correcto</em> . </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  Sin embargo, tal definición simplifica y distorsiona un poco la esencia.  El estándar C89 define <strong>lvalue</strong> como un <em>localizador de objetos</em> , es decir  Un objeto con una ubicación de memoria identificable.  En consecuencia, todo lo que no se ajustaba a esta definición se incluyó en la categoría de valor. </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn se apresura al rescate </h2><br><p>  En C ++, la terminología de las categorías de expresión ha evolucionado bastante, especialmente después de la adopción del estándar C ++ 11, que introdujo los conceptos de enlaces de valor y <em>semántica de movimiento</em> .  La historia de la aparición de una nueva terminología se describe de manera interesante en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Nueva" Terminología de valor de Straustrup</a> . </p><br><p>  La nueva terminología más rigurosa se basa en 2 propiedades: </p><br><ul><li>  la presencia de identidad ( <em>identidad</em> ), es decir, algún parámetro por el cual se puede entender si dos expresiones se refieren a la misma entidad o no (por ejemplo, una dirección en la memoria); </li><li>  la capacidad de moverse ( <em>se puede mover desde</em> ): apoya la semántica del movimiento. </li></ul><br><p>  Las expresiones que expresan identidad se generalizan bajo el término <strong>glvalue</strong> ( <em>valores generalizados</em> ), las expresiones itinerantes se denominan <strong>rvalue</strong> .  Las combinaciones de estas dos propiedades han identificado 3 categorías principales de expresiones: </p><br><table><thead><tr><th></th><th>  Tener una identidad </th><th>  Desprovisto de identidad </th></tr></thead><tbody><tr><td>  <strong>No se puede mover</strong> </td><td>  lvalue </td><td>  - </td></tr><tr><td>  <strong>Puede ser movido</strong> </td><td>  xvalue </td><td>  prvalue </td></tr></tbody></table><br><p>  De hecho, el estándar C ++ 17 introdujo el concepto de <em>copia de elisión</em> , formalizando situaciones en las que el compilador puede y debe evitar copiar y mover objetos.  A este respecto, el valor <strong>prva</strong> no necesariamente se puede mover.  Detalles y ejemplos se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Sin embargo, esto no afecta la comprensión del esquema general de categorías de expresiones. </p><br><p>  En el estándar C ++ moderno, la estructura de categorías se presenta en forma de dicho esquema: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="imagen"></p><br><p>  Examinemos en términos generales las propiedades de las categorías, así como las expresiones del lenguaje que se incluyen en cada una de las categorías.  Noto de inmediato que las listas de expresiones a continuación para cada categoría no pueden considerarse completas; para obtener información más precisa y detallada, consulte directamente el Estándar C ++. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  Las expresiones en la categoría <strong>glvalue</strong> tienen las siguientes propiedades: </p><br><ul><li>  puede convertirse implícitamente en <strong>prvalue</strong> ; </li><li>  puede ser polimórfico, es decir, para ellos los conceptos de tipo estático y dinámico tienen sentido; </li><li>  no puede ser de tipo <strong>vacío</strong> : esto se deduce directamente de la propiedad de tener identidad, porque para las expresiones de tipo <strong>vacío</strong> no existe tal parámetro que los distinga entre sí; </li><li>  puede tener un <em>tipo incompleto</em> , por ejemplo, en forma de <em>declaración directa</em> (si está permitido para una expresión particular). </li></ul><br><h2 id="rvalue">  rvalue </h2><br><p>  Las expresiones en la categoría <strong>rvalue</strong> tienen las siguientes propiedades: </p><br><ul><li>  no puede obtener la dirección <strong>rvalue</strong> en la memoria; esto se deriva directamente de la falta de propiedad de identidad; </li><li>  no puede estar en el lado izquierdo de una asignación o declaración de asignación compuesta; </li><li>  se puede usar para inicializar un enlace <strong>lvalue</strong> constante o <strong>un</strong> enlace <strong>rvalue</strong> , mientras que la vida útil del objeto se extiende hasta la vida útil del enlace; </li><li>  si se usa como argumento al llamar a una función que tiene 2 versiones sobrecargadas: una acepta una referencia de valor constante y la otra una referencia de valor, luego se selecciona la versión que acepta la referencia de valor.  Es esta propiedad la que se usa para implementar la <em>semántica de movimiento</em> : </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Técnicamente, A&amp;&amp; es un valor de <strong>r</strong> y se puede usar para inicializar tanto una referencia de valor constante como una referencia de valor de <strong>r</strong> .  Pero gracias a esta propiedad, no hay ambigüedad; se acepta una opción de constructor que acepte una referencia de valor. </blockquote><br><h2 id="lvalue">  lvalue </h2><br><p>  Propiedades: </p><br><ul><li>  todas <strong>las</strong> propiedades de valor de <strong>gl</strong> (ver arriba); </li><li>  puede tomar la dirección (usando el operador unario incorporado <code>&amp;</code> ); </li><li>  los valores modificables pueden estar en el lado izquierdo del operador de asignación u operadores de asignación compuesta; </li><li>  se puede usar para inicializar una referencia a un valor <strong>l</strong> (tanto constante como no constante). </li></ul><br><p>  Las siguientes expresiones pertenecen a la categoría <strong>lvalue</strong> : </p><br><ul><li>  el nombre de una variable, función o campo de clase de cualquier tipo.  Incluso si la variable es una referencia de valor, el nombre de esta variable en la expresión es un valor; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  llamar a una función o un operador sobrecargado que devuelve una referencia de <strong>lvalue</strong> , o una expresión de conversión al tipo de una referencia de <strong>lvalue</strong> ; </li><li>  operadores de asignación incorporados, operadores de asignación compuesta ( <code>=</code> , <code>+=</code> , <code>/=</code> , etc.), pre-incremento e pre-incremento incorporado ( <code>++a</code> , <code>--b</code> ), operador de desreferencia de puntero incorporado ( <code>*p</code> ); </li><li>  operador incorporado de acceso por índice ( <code>a[n]</code> o <code>n[a]</code> ), cuando uno de los operandos es una matriz <strong>lvalue</strong> ; </li><li>  llamar a una función o una declaración sobrecargada que devuelve una referencia de valor <strong>r</strong> a una función; </li><li>  literal de cadena como <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Un literal de cadena difiere de todos los demás literales en C ++ precisamente en que es un valor <strong>l</strong> (aunque inmutable).  Por ejemplo, puede obtener su dirección: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;”Hello, world!”; //   ,   </code> </pre> <br><h2 id="prvalue">  prvalue </h2><br><p>  Propiedades: </p><br><ul><li>  todas <strong>las</strong> propiedades de valor (ver arriba); </li><li>  no puede ser polimórfico: los tipos de expresión estática y dinámica siempre coinciden; </li><li>  no puede ser de un tipo incompleto (a excepción del tipo <strong>nulo</strong> , esto se discutirá a continuación); </li><li>  no puede tener un tipo abstracto o ser una matriz de elementos de un tipo abstracto. </li></ul><br><p>  Las siguientes expresiones pertenecen a la categoría <strong>prvalue</strong> : </p><br><ul><li>  literal (excepto cadena), por ejemplo <code>42</code> , <code>true</code> o <code>nullptr</code> ; </li><li>  una llamada a función o un operador sobrecargado que devuelve una no referencia ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) o una expresión de conversión a un tipo sin referencia (por ejemplo, <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  post-incremento y post-decremento <code>b--</code> ( <code>a++</code> , <code>b--</code> ), operaciones matemáticas integradas ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> , etc.), operaciones lógicas integradas ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> , etc.), operaciones de comparación ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> , etc.), la operación integrada de tomar la dirección ( <code>&amp;a</code> ); </li><li>  <strong>este</strong> puntero </li><li>  elemento de listado; </li><li>  parámetro de plantilla atípico, si no es una clase; </li><li>  expresión lambda, por ejemplo <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> . </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Propiedades: </p><br><ul><li>  todas <strong>las</strong> propiedades de valor (ver arriba); </li><li>  todas <strong>las</strong> propiedades de valor de <strong>gl</strong> (ver arriba). </li></ul><br><p>  Ejemplos de expresiones de <strong>xvalue</strong> : </p><br><ul><li>  llamar a una función u operador incorporado que devuelve una referencia de valor <strong>r</strong> , por ejemplo <em>std :: move (x)</em> ; </li></ul><br><blockquote>  y, de hecho, para el resultado de llamar a <em>std :: move (),</em> no puede obtener una dirección en la memoria o inicializar un enlace, pero al mismo tiempo, esta expresión puede ser polimórfica: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  “XB::f()”</code> </pre> <br><ul><li>  operador incorporado de acceso por índice ( <code>a[n]</code> o <code>n[a]</code> ) cuando uno de los operandos es una matriz de <strong>valores r</strong> . </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Algunos casos especiales </h2><br><h3 id="operator-zapyataya">  Operador de coma </h3><br><p>  Para el operador de coma incorporado, la categoría de expresión siempre coincide con la categoría de expresión del segundo operando. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Expresiones vacías </h2><br><p>  Las llamadas a funciones que devuelven <strong>void</strong> , <strong>escriben</strong> expresiones de conversión en <strong>void</strong> y arrojan excepciones se consideran expresiones <strong>prvalue</strong> , pero no se pueden usar para inicializar referencias o como argumentos para funciones. </p><br><h2 id="ternarnyy-operator-sravneniya">  Operador de comparación ternario </h2><br><p>  Definición de la categoría de expresión <code>a ? b : c</code>  <code>a ? b : c</code> : el caso no es trivial, todo depende de las categorías del segundo y tercer argumento ( <code>c</code> ): </p><br><ul><li>  si <code>b</code> o <code>c</code> son de tipo <strong>void</strong> , entonces la categoría y el tipo de la expresión completa corresponden a la categoría y el tipo del otro argumento.  Si ambos argumentos son de tipo <strong>void</strong> , entonces el resultado es un <strong>valor de</strong> tipo <strong>void</strong> ; </li><li>  si <code>c</code> son <strong>valores de gl del</strong> mismo tipo, entonces el resultado es un <strong>valor de gl del</strong> mismo tipo; </li><li>  en otros casos, el resultado es prvalue. </li></ul><br><p>  Para el operador ternario, se definen una serie de reglas según las cuales se pueden aplicar conversiones implícitas a los argumentos byc, pero esto está algo más allá del <strong><em>alcance del artículo; si</em></strong> está interesado, le recomiendo <strong><em>consultar la</em></strong> sección <strong><em>Operador condicional [expr.cond]</em></strong> de la Norma. </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  Referencias a campos y métodos de clases y estructuras. </h2><br><p>  Para expresiones de la forma <code>am</code> y <code>p-&gt;m</code> (aquí estamos hablando del operador incorporado <code>-&gt;</code> ), se aplican las siguientes reglas: </p><br><ul><li>  si <code>m</code> es un elemento de enumeración o un método de clase no estático, la expresión completa se considera <strong>prvalue</strong> (aunque el enlace no se puede inicializar con dicha expresión); </li><li>  si <code>a</code> es un valor <strong>r</strong> <code>m</code> es un campo no estático de un tipo sin referencia, entonces la expresión completa pertenece a la categoría <strong>xvalue</strong> ; </li><li>  de lo contrario es un valor. </li></ul><br><p>  Para los punteros a los miembros de la clase ( <code>a.*mp</code> y <code>p-&gt;*mp</code> ), las reglas son similares: </p><br><ul><li>  si <code>mp</code> es un puntero a un método de clase, entonces toda la expresión se considera <strong>prvalue</strong> ; </li><li>  si <code>a</code> es un valor <strong>r</strong> y <code>mp</code> es un puntero a un campo de datos, entonces la expresión completa se refiere a <strong>xvalue</strong> ; </li><li>  de lo contrario es un valor. </li></ul><br><h2 id="bitovye-polya">  Campos de bits </h2><br><p>  Los campos de bits son una herramienta conveniente para la programación de bajo nivel, sin embargo, su implementación queda algo fuera de la estructura general de las categorías de expresión.  Por ejemplo, una llamada a un campo de bits parece ser un valor <strong>l</strong> , <strong>porque</strong> puede estar presente en el lado izquierdo del operador de asignación.  Al mismo tiempo, no funcionará tomar la dirección del campo de bit o inicializar un enlace no constante por ellos.  Puede inicializar una referencia constante a un campo de bits, pero se creará una copia temporal del objeto: </p><br><blockquote>  <strong><em>Campos de bits [class.bit]</em></strong> <br>  <em>Si el inicializador para una referencia de tipo const T &amp; es un valor l que se refiere a un campo de bits, la referencia está vinculada a un inicializado temporal para contener el valor del campo de bits;</em>  <em>la referencia no está vinculada directamente al campo de bits.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  En lugar de una conclusión </h2><br><p>  Como mencioné en la introducción, la descripción anterior no pretende ser completa, sino que solo da una idea general de las categorías de expresiones.  Esta vista proporcionará una mejor comprensión de los párrafos del Estándar y los mensajes de error del compilador. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441742/">https://habr.com/ru/post/441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441728/index.html">Resumiendo el concurso en línea para el juego Blotto</a></li>
<li><a href="../441732/index.html">Notas del Biorobot</a></li>
<li><a href="../441736/index.html">Automatice la conversión de archivos de Word a otros formatos.</a></li>
<li><a href="../441738/index.html">Conceptos básicos termoacústicos</a></li>
<li><a href="../441740/index.html">Habra megarating: los mejores artículos y estadísticas de Habr durante 12 años. Parte 1/2</a></li>
<li><a href="../441744/index.html">Obtener enlaces a perfiles Vk de los resultados de SearchFace usando Python (pero esto no es exacto)</a></li>
<li><a href="../441750/index.html">Proyectos en CodeFest: ¿Cómo puede sobrevivir un gerente en un mundo en constante cambio?</a></li>
<li><a href="../441752/index.html">ZTE mostró un reloj de teléfono inteligente α</a></li>
<li><a href="../441754/index.html">Kubernetes historias de éxito en producción. Parte 10: Reddit</a></li>
<li><a href="../441756/index.html">Para la plataforma rusa de PC industriales, tomaron los procesadores Baikal-T1 y el sistema operativo Alt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>