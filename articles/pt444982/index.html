<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 ⏰ 🤷🏻 Mockito e como cozinhá-lo 👩‍👦‍👦 👩🏽‍🚒 🚂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sobre o artigo 


 Aqui está outro guia para Mockito. Nele, por um lado, tentei descrever a funcionalidade dessa biblioteca para que um leitor não fam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mockito e como cozinhá-lo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444982/"><h2 id="o-state">  Sobre o artigo </h2><br><p>  Aqui está outro guia para Mockito.  Nele, por um lado, tentei descrever a funcionalidade dessa biblioteca para que um leitor não familiarizado com ela tivesse a oportunidade de usá-la imediatamente, e não apenas uma idéia geral.  Por outro lado, eu queria torná-lo compacto o suficiente e estruturado para que pudesse lê-lo rapidamente na íntegra e rapidamente encontrar nele algo uma vez lido, mas esquecido.  Em geral, este artigo, que seria útil para mim, quando me deparei com esta biblioteca e realmente não entendi como ela funciona. </p><br><p>  Suponho que possa me ser útil agora - às vezes esqueço um pouco disso, e é mais conveniente recordar o material não de acordo com a documentação oficial ou com os artigos de outras pessoas, mas com a minha própria, digamos, sinopse.  Ao mesmo tempo, tentei criar o texto para que fosse conveniente principalmente conhecer Mockito do zero e, em alguns lugares, analiso em detalhes coisas aparentemente óbvias - nem todas as quais eram óbvias para mim desde o início. </p><a name="habracut"></a><br><h2 id="soderzhanie">  Conteúdo: </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mockito: o que é e por que é necessário</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ambiente, versões e animal experimental</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zombar e espionar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciamento de comportamento</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Definir condições de chamada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Definir resultados da chamada</a> </li></ol></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chamadas de método de rastreamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Objetos simulados como valores de campo e anotações do Mockito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comportamento de reversão para sessões padrão e Mockito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que mais?</a> </li></ol><br><h2 id="mockito-chto-eto-takoe-i-zachem-nuzhno">  Mockito: o que é e por que é necessário </h2><br><p>  Em resumo, o Mockito é uma estrutura de stub. </p><br><p>  Como você sabe, ao testar o código (principalmente o teste de unidade, mas não apenas), o elemento sob teste geralmente precisa fornecer instâncias de classes que ele deve usar ao trabalhar.  No entanto, muitas vezes eles não precisam ser totalmente funcionais - pelo contrário, são obrigados a se comportar de maneira estritamente definida, para que seu comportamento seja simples e completamente previsível.  Eles são chamados de stubs.  Para obtê-los, você pode criar implementações de teste alternativas de interfaces, herdar as classes necessárias com redefinição de funcionalidade e assim por diante, mas tudo isso é bastante inconveniente, redundante e cheio de erros.  Uma solução mais conveniente em todos os sentidos são estruturas especializadas para a criação de stubs.  Um deles (e talvez o mais famoso por Java) é o Mockito. </p><br><p> O Mockito permite que você crie com uma única linha de código o chamado mock (algo como a base para o esboço desejado) de qualquer classe.  Para tal simulação, imediatamente após a criação, um determinado comportamento padrão é característico (todos os métodos retornam valores conhecidos anteriormente - geralmente isso é <code>null</code> ou <code>0</code> ).  Você pode redefinir esse comportamento da maneira que desejar, controlá-lo com o grau certo de detalhes e assim por diante.  Como resultado, o mock se torna um esboço com as propriedades necessárias.  Abaixo, discutirei em detalhes como fazer isso. </p><br><p>  Observo que o mock também pode ser criado para essas classes, cuja nova instância não é possível apenas criar, em particular, classes com construtores exclusivamente privados, como classes singleton e utilitário, e com uma configuração mínima da estrutura e enumerações. </p><br><h2 id="okruzhenie-versii-i-podopytnoe-zhivotnoe">  Ambiente, versões e animal experimental </h2><br><p>  Ao escrever este artigo, usei: </p><br><ul><li>  Mockito: 'org.mockito: mockito-core: 2.24.0' (última versão estável no momento da redação) </li><li>  TestNG: 'org.testng: testng: 6.14.3' como uma estrutura de teste </li><li>  AssertJ: 'org.assertj: assertj-core: 3.11.1' como uma ferramenta de validação </li><li>  Lombok: 'org.projectlombok: lombok: 1.18.6' (apenas por conveniência) </li><li>  Java 8 </li></ul><br><p>  Para minhas experiências desumanas, escrevi essa interface de um serviço que fornece acesso a determinados dados. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; dataToSave)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id, Supplier&lt;String&gt; calculateIfAbsent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataListByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; idList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataByRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataSearchRequest request)</span></span></span></span>; }</code> </pre> <br><p>  E este código (que seja por uma questão de ordem) da classe de solicitação passada para o último dos métodos de interface. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSearchRequest</span></span></span><span class="hljs-class"> </span></span>{ String id; Date updatedBefore; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; }</code> </pre> <br><p>  As unidades de dados são identificadas por ID e possuem mais algumas características, mas diretamente na forma em que são retornadas pelo serviço, são cadeias de caracteres e não objetos mais complexos.  Não perco nada importante, e os exemplos são mais simples e claros. </p><br><p>  Observarei imediatamente: nos exemplos abaixo, chamo diretamente os métodos substituídos dos meus objetos simulados para maior clareza, mas com testes reais a idéia não é de todo!  Neste teste, eu consistentemente faria o seguinte: </p><br><ul><li>  configurei a simulação do meu serviço, conforme necessário; </li><li>  passei (provavelmente, via construtor) para uma instância de outra classe que o utiliza (suponha que contenha algum tipo de lógica de negócios usando os dados fornecidos pelo <code>DataService</code> ), que eu realmente testaria; </li><li>  habilitou a funcionalidade da classe testada e controlou os resultados; </li><li>  se necessário, controlaria o número e a ordem das chamadas para o (s) método (s) do meu mock, que deveria ter sido chamado pela classe testada como resultado da ação anterior. </li></ul><br><h2 id="mock-i-spy">  zombar e espionar </h2><br><p>  A classe central do Mockito, através da qual é suposto acessar a maior parte da funcionalidade, é, de fato, uma classe chamada <code>Mockito</code> (há também a classe <code>BDDMockito</code> que fornece os mesmos recursos de uma forma mais adequada para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BDD</a> , mas aqui não vou me debruçar sobre isso) .  O acesso à funcionalidade é implementado através de seus métodos estáticos. </p><br><p>  Para criar uma simulação da classe <code>DataService</code> , basta fazer o seguinte: </p><br><pre> <code class="java hljs">DataService dataServiceMock = Mockito.mock(DataService.class);</code> </pre> <br><p>  Concluído - recebi uma instância da classe de que preciso.  Será aceito por qualquer método ou construtor que exija um parâmetro desse tipo (por exemplo, o construtor da classe que eu quero testar).  Mesmo que uma verificação de dependência aguarde mais tarde, ela será aprovada: não apenas a <code>instanceof DataService</code> retornará <code>true</code> , mas também o <code>dataServiceMock.getClass()</code> - ou seja, <code>DataService.class</code> .  De alguma maneira formal, distinguir programaticamente um objeto falso de um objeto comum acaba sendo uma tarefa bastante difícil, que é lógica: afinal, o primeiro se destina apenas a ser indistinguível do segundo.  No entanto, o Mockito possui uma ferramenta para isso - o método <code>Mockito.mockingDetails</code> .  Ao passar para ele um objeto arbitrário, recebo um objeto da classe <code>MockingDetails</code> .  Ele contém informações sobre o que esse objeto representa do ponto de vista do Mockito: se é falso, espião (veja abaixo), como foi usado, como foi criado e assim por diante. </p><br><p>  É digna de nota a situação em que tento criar uma simulação para a classe final ou uma instância simulada de enum ou substituir o comportamento do método final.  Nesse caso, com o comportamento padrão do Mockito, o código acima se recusa a funcionar, citando precisamente essa circunstância.  No entanto, isso pode ser alterado - basta criar no projeto (com o dispositivo padrão da árvore de diretórios do projeto) o arquivo <code>test/resources/mockito-extensions/org.mockito.plugins.MockMaker</code> e digite a linha: </p><br><pre> <code class="plaintext hljs">mock-maker-inline</code> </pre> <br><p>  Depois disso, você pode imitar as classes finais e enumerações da maneira usual, bem como substituir os métodos finais. </p><br><p>  O escárnio que eu entrei em ação é o menos característico possível: nem um único método terá efeito sobre nada, e o valor retornado será <code>null</code> para tipos de objetos e <code>0</code> para tipos primitivos.  Observe: se o método retornar uma coleção, a simulação padrão não retornará <code>null</code> , mas instâncias de coleção vazias.  Por exemplo, para <code>List</code> isso acabará sendo um <code>LinkedList</code> vazio <code>LinkedList</code> independentemente do que o método real deveria ter retornado.  Mas como os valores de matrizes, primitivas ou objetos, fico <code>null</code> .  O comportamento padrão (e não apenas) pode ser alterado usando a funcionalidade da classe <code>MockSettings</code> , mas isso raramente é necessário. </p><br><p>  De uma maneira ou de outra, na maioria dos casos, não precisarei do comportamento padrão e, na próxima seção, analisarei em detalhes como definir o que é necessário. </p><br><p>  No entanto, e se eu quiser usar um objeto de classe real com a funcionalidade disponível como um stub, redefinindo a operação de apenas parte de seus métodos?  Se estamos falando de teste de unidade, essa necessidade geralmente (mas nem sempre) indica que o projeto não está bem com o design e, em princípio, isso não é recomendado.  No entanto, há situações em que isso, por algum motivo, não pode ser evitado.  Para este caso, Mockito tem o chamado espião, "espiões".  Diferentemente das simulações, elas podem ser criadas com base na classe e no objeto final: </p><br><pre> <code class="java hljs">DataService dataServiceSpy = Mockito.spy(DataService.class); <span class="hljs-comment"><span class="hljs-comment">// or DataService dataService = new DataService(); dataServiceSpy = Mockito.spy(dataService);</span></span></code> </pre> <br><p>  Ao criar espião com base em uma classe, se seu tipo for uma interface, um objeto simulado regular será criado e, se o tipo for uma classe, o Mockito tentará criar uma instância usando o construtor padrão (sem parâmetros).  E somente se não houver esse construtor, ocorrerá um erro e o teste não funcionará. </p><br><p>  O comportamento de objetos espiões, por padrão, é idêntico ao comportamento de uma instância de classe regular, no entanto, eles me oferecem as mesmas possibilidades que objetos simulados: permitem redefinir seu comportamento e monitorar seu uso (consulte as seções a seguir).  Um ponto importante: o espião não é um invólucro em torno da instância em que foi criado!  Portanto, chamar o método espião não afetará o estado da instância original. </p><br><h2 id="upravlenie-povedeniem">  Gerenciamento de comportamento </h2><br><p>  Então, sobre como conseguir zombaria ou espionagem para fazer o que eu preciso.  Além disso, eu sempre escreverei simplesmente "zombaria" em todos os lugares - isso significa "zombaria ou espião", a menos que expressamente indicado de outra forma. </p><br><p>  Em geral, controlar o comportamento de um objeto simulado se resume a um conceito óbvio: quando um simulado foi afetado de tal maneira (isto é, tal e tal método foi chamado com tais e tais argumentos), deve responder de tal e tal maneira.  Esse conceito possui duas implementações na classe Mockito - a principal, recomendada pelos desenvolvedores para uso sempre que possível, e a alternativa, usada onde a principal não é adequada. </p><br><p>  A principal implementação é baseada no método <code>Mockito.when</code> .  Esse método usa como "parâmetro" uma chamada para o método redefinido do objeto de simulação (dessa maneira, a ação detectada é corrigida) e retorna um objeto do tipo <code>OngoingStubbing</code> , que permite chamar um dos métodos da família <code>Mockito.then...</code> (é assim que a reação a esse efeito é definida).  Todos juntos, no caso mais simples, é algo parecido com isto: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p>  Após esta operação, chamando o método <code>getAllData()</code> no objeto <code>getAllData()</code> , obtenho o objeto especificado na primeira linha da listagem. </p><br><p>  Aqui, a intuição familiar "orientada a objetos" pode causar algum tipo de mau funcionamento, portanto vale a pena insistir em mais detalhes.  Do ponto de vista da sintaxe Java, o valor passado para o método <code>when</code> como parâmetro é, obviamente, o valor retornado pelo método substituído.  Para simulação, esse é um valor vazio; para espião, esse é o valor retornado pelo método do objeto real.  Mas, graças à ação mágica "sob o capô" do Mockito, o método <code>when</code> funcionará normalmente (e não trava quando iniciado com um erro) somente se a chamada do método de objeto simulado estiver dentro dos colchetes depois de <code>when</code> . </p><br><p>  Uma ideologia semelhante geralmente funciona ao definir o comportamento de uma simulação em um Mockito: chamando um método (de um objeto ou classe simulado do <code>Mockito</code> ), tento não obter o valor retornado por ele, mas de alguma forma influenciar a possível chamada do método do objeto simulado com o qual trabalho: especificar suas fronteiras, definir o resultado, estabelecer a observação de seus desafios e assim por diante.  Parece um pouco nebuloso, admito, e na primeira colisão parece estranho, mas, depois de descobrir, você logo começa a sentir essa abordagem como completamente natural no contexto de trabalhar com stubs. </p><br><p>  Uma implementação alternativa de vincular a condição e o resultado da chamada são os métodos da família <code>Mockito.do...</code>  Esses métodos permitem definir o comportamento começando com o resultado da chamada e retornar um objeto da classe <code>Stubber</code> , com o qual você já pode definir a condição.  A mesma ligação acima feita desta maneira é assim: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.doReturn(data).when(dataService).getData()</code> </pre> <br><p>  Qual é a diferença, por que vincular através do <code>Mockito.when</code> é considerado preferível e quando você ainda precisa usar os métodos do <code>Mockito.do...</code> ?  Observe: na primeira implementação, ao definir o comportamento do método (neste caso, <code>getAllData()</code> ), a chamada para a versão que ainda não foi redefinida é executada primeiro e somente então, nas entranhas do Mockito, ocorre uma substituição.  No segundo, essa chamada não ocorre - o método <code>Stubber.when</code> passado diretamente para o método <code>Stubber.when</code> , e um objeto do mesmo tipo retornado por esse método, mas de natureza diferente, é chamado com um método substituível.  Essa diferença determina tudo.  A ligação via <code>Mockito.do...</code> não controla, no estágio de compilação, qual método redefinível chamarei e se é compatível no tipo com o valor de retorno fornecido.  Portanto, geralmente <code>Mockito.when</code> preferível - não pode haver erro com isso.  Mas pode haver casos em que eu quero evitar chamar um método substituído - para uma simulação criada recentemente, tal chamada é bastante aceitável, mas se eu já redefinir esse método ou lidar com o espião, pode ser indesejável, e lançar uma exceção não permitirá a redefinição necessária. .  E aqui a ligação através do <code>Mockito.do...</code> vem em <code>Mockito.do...</code> </p><br><p>  Outra situação em que você não pode ficar sem os métodos <code>Mockito.do...</code> está substituindo o método que retorna <code>void</code> : o parâmetro <code>Mockito.when</code> pendente não pode funcionar com esse método.  <code>Mockito.doReturn</code> aqui, mas há <code>Mockito.doThrow</code> , <code>Mockito.doAnswer</code> e, raramente, é suficiente o <code>Mockito.doNothing</code> . </p><br><p>  A seguir, analisarei um pouco mais detalhadamente como definir condições e resultados das chamadas.  Considerarei apenas a ligação através do <code>Mockito.when</code> - uma maneira alternativa é quase completamente semelhante no manuseio. </p><br><h3 id="zadanie-usloviy-vyzova">  Definir condições de chamada </h3><br><p>  O exemplo acima refere-se a um método sem parâmetros, e a condição de chamada associada é possível, uma coisa - o fato da chamada.  Assim que os parâmetros aparecem, a situação se torna mais complicada.  No mínimo, para chamar um método cujo comportamento estou definindo, preciso passar algo para ele.  Mas outra coisa é mais importante: pode ser que eu nem sempre queira obter a reação dada, mas apenas quando a chamo com parâmetros que atendem a certos requisitos.  <code>DataService</code> possui este método: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataItemById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code... }</span></span></code> </pre> <br><p>  Se eu precisar definir uma resposta para qualquer chamada para esse método, independentemente dos argumentos, devo usar o método <code>Mockito.any</code> : </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(any())) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  Se eu precisar do mock para reagir apenas a um determinado valor do argumento, você pode usar esse valor diretamente ou os métodos de <code>Mockito.eq</code> (se for uma equivalência) ou <code>Mockito.same</code> (se for necessária a comparação de links): </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// or Mockito.when(dataService.getDataItemById(Mockito.eq("idValue"))) .thenReturn("dataItem");</span></span></code> </pre> <br><p>  E se eu quiser que o argumento atenda a alguns requisitos, existem vários métodos estáticos especializados convenientes da mesma classe <code>Mockito</code> (por exemplo, as strings podem ser verificadas quanto ao conteúdo no início ou no final de uma determinada sequência de caracteres, correspondência de padrões etc.).  Há também um método geral Mockito.argThat (e seus análogos para tipos primitivos) que aceita a implementação da interface funcional ArgumentMatcher: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById( Mockito.argThat(arg -&gt; arg == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || arg.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>))) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  <code>AdditionalMatchers</code> classes <code>ArgumentMatchers</code> e <code>AdditionalMatchers</code> permitem que você trabalhe com algumas implementações úteis prontas para uso dessa interface.  Por exemplo, <code>AdditionalMatchers.or</code> e <code>AdditionalMatchers.and</code> permitem combinar outros correspondentes (nota: os métodos estáticos dessas classes não retornam instâncias dos correspondentes, mas apenas os acessam!) </p><br><p>  Para o mesmo método, você pode definir o comportamento várias vezes com requisitos diferentes para os argumentos, e todos os modelos de comportamento definidos dessa maneira agirão simultaneamente.  Obviamente, em alguns casos, eles podem se cruzar - digamos, exigirei retornar um resultado quando o valor <code>int</code> do parâmetro for menor que 5 e o outro quando o valor par for recebido.  Nessa situação, o comportamento especificado posteriormente tem precedência.  Portanto, ao definir padrões complexos de comportamento, você deve começar com os requisitos mais fracos (no limite - <code>any()</code> ) e depois passar para os mais específicos. </p><br><p>  Ao trabalhar com métodos com mais de um argumento, os requisitos especificados são combinados de acordo com o AND lógico, ou seja, para obter o resultado especificado, TODOS os argumentos devem atender ao requisito declarado.  Não encontrei uma maneira de definir uma maneira arbitrária de combiná-los, embora talvez exista. </p><br><p>  Além disso, ao especificar o comportamento de um método desse tipo, não é possível combinar os métodos estáticos do <code>Mockito</code> e a transferência direta de valores.  Use <code>Mockito.eq</code> ou <code>Mockito.same</code> . </p><br><h3 id="zadanie-rezultatov-vyzova">  Definir resultados da chamada </h3><br><p>  Depois que o método do objeto simulado é chamado, o objeto deve responder à chamada.  As principais conseqüências possíveis são retornar o resultado e lançar uma exceção, e é justamente nessas opções que o kit de ferramentas Mockito é projetado principalmente. </p><br><p>  No caso mais simples já mostrado acima, a resposta à chamada é retornar um valor.  Vou dar o código dele novamente: </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p>  Observe: você só pode retornar um objeto; não há métodos separados para primitivos.  Portanto, se o método retornar um valor primitivo, em tal situação, ocorrerá desmarcação.  Na maioria dos casos, isso não interfere, mas se o compilador pensa de outra forma, você terá que concordar de alguma forma com ele ... ou tolerar seus avisos. </p><br><p>  Lançar exceções não é mais difícil: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException());</code> </pre> <br><p>  Existe outra maneira: você pode criar um objeto de exceção e jogá-lo diretamente, ou pode fornecer ao Mockito apenas uma classe de exceção para que ele seja criado automaticamente: </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>  Nos dois casos, a sintaxe permite que você use e verifique as exceções, mas o Mockito não permitirá que você execute esse teste se o tipo de exceção não corresponder ao método que desejo forçar ao lançar essa exceção. </p><br><p>  Ao usar uma classe como parâmetro, construtores (mesmo sem parâmetros), bem como a inicialização direta do campo, são ignorados - o objeto é criado ignorando-os (afinal, isso é Mockito!), Para que todos os campos da exceção lançada sejam <code>null</code> .  Portanto, se o conteúdo da exceção for importante para você (por exemplo, algum campo de <code>type</code> que tenha um valor padrão), será necessário abandonar esse método e criar exceções manualmente. </p><br><p>  Essas opções de reação são adequadas se, em resposta a uma chamada com determinadas condições, você sempre precisar retornar um certo valor, sempre o mesmo valor do resultado ou sempre lançar a mesma exceção, e na maioria dos casos esses recursos serão suficientes.  Mas e se for necessária mais flexibilidade?  Suponha que meu método aceite uma coleção de valores e retorne outra coleção de valores associados ao primeiro para um (por exemplo, obtendo uma coleção de objetos de dados pelo conjunto de seus IDs) e eu quero usar esse objeto simulado repetidamente com diferentes conjuntos de entradas no teste dados, obtendo cada vez o resultado correspondente.  Obviamente, é possível descrever separadamente a reação a cada conjunto específico de parâmetros, mas existe uma solução mais conveniente - o método <code>Mockito.thenAnswer</code> , também <code>Mockito.then</code> como <code>Mockito.then</code> .  Ele aceita uma implementação da interface funcional <code>Answer</code> , cujo único método é receber um objeto da classe <code>InvocationOnMock</code> .  Deste último, posso solicitar os parâmetros da chamada do método (um por número ou todos de uma vez na forma de uma matriz) e agir com eles como eu quiser.  Por exemplo, você pode obter um valor correspondente a ele para cada um dos elementos da minha coleção, formar uma nova coleção a partir deles e retorná-lo (nota: o resultado desejado é simplesmente retornado e não gravado em algum campo do objeto de parâmetro, como seria de esperar): </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataByIds(Mockito.any())) .thenAnswer(invocation -&gt; invocation .&lt;List&lt;String&gt;&gt;getArgument(<span class="hljs-number"><span class="hljs-number">0</span></span>).stream() .map(id -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemA"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemB"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }) .collect(Collectors.toList()));</code> </pre> <br><p>  Ideologicamente, isso é algo como escrever um modelo de um método real: obter parâmetros, processar, retornar um resultado.          -  ,    - ,      ,     ,    mock-    . </p><br><p>     <code>Answer</code> ,     , — , <code>AnswersWithDelay</code> , <code>ReturnsElementsOf</code>  . . </p><br><p>  :  <code>InvocationOnMock</code>   —       <code>Object[]</code> ,  generic-. </p><br><p>        — <code>thenCallRealMethod</code> .    .     mock-,    spy-.   mock   ,      ,  -   <code>null</code> .  spy   <code>thenCallRealMethod</code>     spy  ;    ,     -      . </p><br><p>        <code>thenAnswer</code> :  <code>InvocationOnMock</code>   <code>callRealMethod()</code> —   ,   ""    -  . </p><br><p>    <code>OngoingStubbing</code>    <code>OngoingStubbing</code> ,  ,   ,     .            ,   .  <code>thenReturn</code>  <code>thenThrow</code>   ,  varargs.       . </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"valueA1"</span></span>, <span class="hljs-string"><span class="hljs-string">"valueA2"</span></span>) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>         <code>"valueA1</code> ,  — <code>"valueA2</code> ( ),   (  )    <code>IllegalArgumentException</code> . </p><br><h2 id="slezhenie-za-vyzovami-metodov">     </h2><br><p>        :          (mock'    ),     .   ,     :   ,          ,       .      <code>verify</code> . </p><br><p>  ,           ,  : </p><br><pre> <code class="java hljs">Mockito.verify(dataService).getDataById(Mockito.any());</code> </pre> <br><p>      ,            <code>getDataById</code> ,  ,           . ,             Mockito,      <code>when</code> ,   ,  ,         mock-. , ,  ,      <code>when</code>  , —      mock',       (. ). </p><br><p>           : </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>           <code>Mockito.times</code> ;       <code>Mockito.never</code> .    <code>Mockito.atLeast</code> (  <code>Mockito.atLeastOnce</code>   1)  <code>Mockito.atMost</code> ,       ,    <code>Mockito.only</code> , ,         mock-  (. .     ). </p><br><p>  ,         <code>Mockito</code> ,     <code>VerificationAfterDelay</code>  <code>VerificationWithTimeout</code> ,    <code>Mockito.after</code>  <code>Mockito.timeout</code> .  Por exemplo: </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.after(1000).times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>    ,    mock   ,      ,              ,       .        .   <code>after</code>  <code>timeout</code>  ,          ,    ,    —   ,     .  ,   <code>timeout</code>         —       .   <code>VerificationWithTimeout</code>   <code>never</code>  <code>atMost</code> :         . </p><br><p>  ,             <code>Mockito.any()</code> .          ,   ,     —    Mockito       ,    ,     . Mock-     ,        ,   , , : </p><br><pre> <code class="java hljs">dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"b"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).getDataById(Mockito.any()); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); Mockito.verify(dataService, Mockito.never()).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verifyNoMoreInteractions(dataService);</code> </pre> <br><p>      <code>verifyNoMoreInteractions</code> (  <code>verifyZeroInteractions</code> ) —    -  (            <code>verify</code> )    mock- —    .  :   varargs,     ,     ,         <strong> </strong> ! </p><br><p>       ,   ,      ,     .   ,    <code>InOrder</code> : </p><br><pre> <code class="java hljs">InOrder inOrder = Mockito.inOrder(dataService);</code> </pre> <br><p>     varargs;     —    mock-   ,    <code>InOrder</code>                .     <code>verify</code>    ,   <code>Mockito.verify</code> : </p><br><pre> <code class="java hljs">inOrder.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).saveData(any()); inOrder.verify(dataService).getData();</code> </pre> <br><p>       ,         <code>saveData</code> , <strong> </strong>  — <code>getData</code> .  ,   <code>InOrder</code>    ,      —     . </p><br><p>       ,   ,       — , .      -      ,    ,      —  ,     ,    .     <code>ArgumentCaptor</code>    <code>capture()</code> .  Por exemplo: </p><br><pre> <code class="java hljs">DataSearchRequest request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataSearchRequest(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(System.currentTimeMillis()), <span class="hljs-number"><span class="hljs-number">50</span></span>); dataService.getDataByRequest(request); ArgumentCaptor&lt;DataSearchRequest&gt; requestCaptor = ArgumentCaptor.forClass(DataSearchRequest.class); Mockito.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataByRequest(requestCaptor.capture()); assertThat(requestCaptor.getAllValues()).hasSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); DataSearchRequest capturedArgument = requestCaptor.getValue(); assertThat(capturedArgument.getId()).isNotNull(); assertThat(capturedArgument.getId()).isEqualTo(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>); assertThat(capturedArgument.getUpdatedBefore()).isAfterYear(<span class="hljs-number"><span class="hljs-number">1970</span></span>); assertThat(capturedArgument.getLength()).isBetween(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br><p> <code>ArgumentCaptor</code>       ,      <strong> </strong> ,   <code>ArgumentCaptor</code>  . <code>getValue()</code>    , <code>getAllValues()</code> —     .   ,         ,   . </p><br><h2 id="mock-obekty-kak-znacheniya-poley-i-annotacii-mockito"> Mock-      Mockito </h2><br><p>      ,     mock-   ,      —     <code>@Mock</code>   -       : </p><br><pre> <code class="java hljs">MockitoAnnotations.initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br><p> (  ,       mock',       ) </p><br><p>  spy   <code>@Spy</code> —     <code>@Mock</code> …   spy   ,      , ?          ,      —  spy     . </p><br><p>   <code>@Captor</code>    <code>ArgumentCaptor</code> —   , ,    . </p><br><p>   <code>@InjectMocks</code> .       -  Mockito,          .       mock-   ,   .        ,    .  -     ,     <code>null</code> ,   -     .         (      )  dependency injection. </p><br><h2 id="otkat-povedeniya-k-defoltnomu-i-sessii-mockito">       Mockito </h2><br><p>         ,  :   mock (spy, argument captor...),   ,    , .    ,  mock' —    ,    . JUnit           ,      ,    TestNG   —       . , ,   mock'    ,     ,   ,         . .  ,  ,  —  ,          . </p><br><p>   ,             mock-    .  TestNG     <code>@BeforeMethod</code> ( <code>@AfterMethod</code>  ).           mock'   ,        ,           (    JUnit —      <code>@Before</code> ). </p><br><p>   ,     , —   <code>Mockito.reset</code>  <code>Mockito.clearInvocations</code> .   varargs,      mock'.      ,    .     :     (,              )  ,   /   mock'    , —       .     ,    mock'       . .      , ,             . </p><br><p>       (,  ) —     <code>MockitoAnnotations.initMocks(this);</code>  .    ""  ,   Mockito. </p><br><p>    —     Mockito.    .     mock- ,          ( mock'      ).          ,      <code>MockitoSession</code> ,           .     TestNG: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> DataService dataService; MockitoSession session; <span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ session = Mockito.mockitoSession() .initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .startMocking(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code using the dataService field } @AfterMethod public void afterMethod() { session.finishMocking(); }</span></span></code> </pre> <br><p>  ,        —  ,  "" (,     )  ,   . </p><br><h2 id="chto-eschyo">  ? </h2><br><p>      Mockito:  mock  spy-,        .      ,       .  ,  , : </p><br><ul><li>  Mockito   mock-   <code>MockSettings</code> (      — ,   mock'    -  ); </li><li>     mock-,   <code>MockingDetails</code> ; </li><li>   <code>BDDMockito</code>   <code>Mockito</code> ; </li><li>     (    JUnit       Mockito,     ). </li></ul><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  Mockito</a> .           javadoc'  <code>Mockito</code> . </p><br><p> , ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444982/">https://habr.com/ru/post/pt444982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444972/index.html">Arquitetura de GPU Intel Gen11 e placa gráfica discreta da Intel</a></li>
<li><a href="../pt444974/index.html">Criptografia em Java. Classe MessageDigest</a></li>
<li><a href="../pt444976/index.html">Quester - Plataforma para criar e completar missões (Beta)</a></li>
<li><a href="../pt444978/index.html">Autoridades da UE multaram o Google em US $ 1,7 bilhão por bloquear anúncios de concorrentes</a></li>
<li><a href="../pt444980/index.html">Analisando um erro crítico no algoritmo de criptografia KIB SEARCHINFORM</a></li>
<li><a href="../pt444984/index.html">De onde vêm as fotos para testar os sistemas de reconhecimento facial?</a></li>
<li><a href="../pt444986/index.html">IETF aprova ACME - este é o padrão para trabalhar com certificados SSL</a></li>
<li><a href="../pt444992/index.html">Erros incorporados no sistema: seu papel nas estatísticas</a></li>
<li><a href="../pt444994/index.html">Sobre unidades e seu uso em computadores modernos</a></li>
<li><a href="../pt444996/index.html">Redis Streams como uma estrutura de dados limpa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>