<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎍 🔫 👨‍🎤 Toute la vérité sur RTOS de Colin Walls. Article # 3. Tâches et planification 📦 🤰🏿 🤙🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons examiné le multitâche, la propriété du système d'exploitation d'exécuter plusieurs programmes quasi indépendants en même temps. Avant d'exa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS de Colin Walls. Article # 3. Tâches et planification</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415329/"><img src="https://habrastorage.org/webt/_n/_m/_1/_n_m_1c68gkqkhmie1mi8yvunqm.jpeg"><br><br>  Nous avons examiné le multitâche, la propriété du système d'exploitation d'exécuter plusieurs programmes quasi indépendants en même temps.  Avant d'examiner de plus près les tâches, nous devons en traiter les termes. <br><a name="habracut"></a><br>  Articles précédents de la série: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br>  Nous utilisons le mot «tâche», bien qu'il n'ait pas de signification exacte.  D'autres termes, «flux» et «processus», sont plus spécialisés et vous devez comprendre ce qu'ils signifient et en quoi ils diffèrent. <br><br>  De nombreux RTOS utilisés dans les applications intégrées utilisent un modèle multithread.  Plusieurs threads peuvent être exécutés simultanément, occupant le même espace d'adressage: <br><br><img src="https://habrastorage.org/webt/x0/it/ox/x0itoxoxnraj0iozwghigjmtem8.jpeg"><br><br>  Cela signifie que la commutation de contexte consiste, tout d'abord, à passer d'un ensemble de registres de processeur à un autre.  C'est simple et rapide.  Le danger potentiel est que chaque thread a la capacité d'accéder à la mémoire qui appartient à d'autres threads ou au RTOS lui-même. <br><br>  Une alternative est le modèle multi-processus.  Si plusieurs processus sont en cours d'exécution, chaque processus a son propre espace d'adressage et vous ne pouvez pas accéder à la mémoire associée à d'autres processus ou RTOS: <br><br><img src="https://habrastorage.org/webt/24/wy/er/24wyer7rvordzgxzvejdo7qscqw.jpeg"><br><br>  Cela rend le changement de contexte plus difficile et plus long, car le système d'exploitation doit configurer correctement l'unité de gestion de la mémoire, le gestionnaire de mémoire (English Memory Management Unit, MMU).  Bien entendu, une telle architecture n'est possible qu'avec un processeur prenant en charge MMU.  Les processus sont pris en charge par RTOS "hautes performances" et la plupart des OS de bureau.  De plus, chaque processus peut prendre en charge la division en plusieurs threads, mais cette propriété est rarement utilisée dans les applications embarquées ordinaires. <br><br>  Si une MMU est disponible, un compromis peut être trouvé: <br><br><img src="https://habrastorage.org/webt/nv/gx/_f/nvgx_fw_fk51ihd8f3sdprngfaq.jpeg"><br><br>  De nombreux RTOS «en streaming» prennent en charge les MMU pour protéger la mémoire contre les accès non autorisés.  Ainsi, alors que la tâche est en contexte, seule une partie de son code / données et les sections nécessaires du RTOS sont «visibles»;  les blocs de mémoire restants sont désactivés et une tentative d'accès entraînera une urgence (pour les gens ordinaires) / exception (pour les programmeurs).  Cela rend le changement de contexte un peu plus difficile, mais l'application elle-même est plus sécurisée.  Ce mode peut être appelé «Mode Thread Protected» ou «Lightweight Process Mode». <br><br><h3>  <b>Planificateurs</b> </h3><br><br>  Comme nous le savons, l'illusion de l'exécution simultanée de tâches est obtenue en allouant du temps processeur pour terminer chacune des tâches.  Il s'agit de la fonction principale du noyau.  La méthode de répartition du temps entre les tâches est appelée «planification».  Scheduler - logiciel qui détermine à quelle prochaine tâche transférer le contrôle.  La logique de l'ordonnanceur et le mécanisme qui détermine quand et ce qui doit être exécuté est l'algorithme de planification.  Dans cette section, nous examinons plusieurs algorithmes de planification.  La planification des tâches est un sujet vaste et de nombreux livres y sont consacrés.  Nous fournirons le minimum nécessaire pour comprendre ce qu'un RTOS particulier peut offrir à cet égard. <br><br><h3>  <b>Run to Completion Scheduler (RTC)</b> </h3><br><br>  Le planificateur RTC (exécution complète) est très simple et consomme un minimum de ressources.  Il s'agit d'un service idéal s'il répond aux exigences de l'application.  Voici un graphique pour un système utilisant le planificateur RTC: <br><br><img src="https://habrastorage.org/webt/te/hp/dl/tehpdlu3fx1ty2ea5ji1frpyscg.jpeg"><br><br>  Le planificateur invoque à tour de rôle les fonctions de niveau supérieur de chaque tâche.  La tâche contrôle le processeur (l'interrompt) jusqu'à ce que la fonction de niveau supérieur exécute l'instruction return return.  Si le RTOS prend en charge la suspension des tâches, toutes les tâches actuellement suspendues ne sont pas exécutées.  Ce sujet est abordé dans l'article ci-dessous, voir «Suspension d'une tâche». <br><br>  Un grand avantage du planificateur RTC, en plus de la simplicité, est une pile unique et la portabilité du code (l'assemblage n'est pas requis).  L'inconvénient est que la tâche peut "prendre" le processeur, donc un développement soigneux du programme est nécessaire.  Malgré le fait que chaque fois que la tâche est exécutée depuis le début (contrairement à d'autres planificateurs qui vous permettent de démarrer le travail à partir de l'arrêt), vous pouvez obtenir plus de flexibilité à l'aide de variables "d'état" statiques qui déterminent la logique de chaque appel suivant. <br><br><h3>  <b>Scheduler Round Robin (RR)</b> </h3><br><br>  L'ordonnanceur RR ("carrousel") est similaire au RTC, mais plus flexible et donc plus complexe: <br><br><img src="https://habrastorage.org/webt/rm/ug/ut/rmugut4wxk5npcx_xzxe_ckkaro.jpeg"><br><br>  Cependant, dans le cas du planificateur RR, la tâche n'a pas besoin d'exécuter l'instruction return dans la fonction de niveau supérieur.  Elle peut libérer le processeur à tout moment en effectuant un appel RTOS.  Cet appel oblige le noyau à sauvegarder le contexte de la tâche en cours (tous les registres, y compris le pointeur de pile et le pointeur de commande) et à charger le contexte de la tâche suivante dans la file d'attente.  Dans certains RTOS, le processeur peut être libéré (mettre la tâche en pause) en prévision de la disponibilité de la ressource du noyau.  C'est plus compliqué, mais le principe est le même. <br><br>  La flexibilité de l'ordonnanceur RR est déterminée par la possibilité de continuer à effectuer des tâches à partir du moment de la suspension, sans apporter de modifications au code d'application.  Pour plus de flexibilité, vous devez payer moins de portabilité du code et une pile distincte pour chaque tâche. <br><br><h3>  <b>Planificateur de tranche de temps (TS)</b> </h3><br><br>  Scheduler TS (tranche de temps - "tranche de temps") à un niveau plus complexe que RR.  Le temps est divisé en tranches (intervalles, tranches de temps), où chaque tâche peut être effectuée dans son intervalle assigné: <br><br><img src="https://habrastorage.org/webt/eu/xa/hs/euxahs5t148pqxeqvxcydpql1ce.jpeg"><br><br>  En plus de la possibilité de libérer volontairement le processeur, la tâche peut être interrompue par un appel au planificateur exécuté par le gestionnaire d'interruption du temporisateur système.  L'idée d'attribuer une période de temps fixe à chaque tâche est très intéressante (si possible): elle est facile à comprendre et très prévisible. <br>  L'inconvénient du planificateur TS est que le pourcentage de temps CPU alloué à chaque tâche peut différer, selon que d'autres tâches sont suspendues et que d'autres parties des emplacements sont libres: <br><br><img src="https://habrastorage.org/webt/du/7e/iw/du7eiwhyms79l2ycinzsw5rc5ko.jpeg"><br><br>  Le planificateur TS peut devenir plus prévisible si des tâches en arrière-plan sont implémentées.  La tâche d'arrière-plan peut être effectuée à la place de toute tâche suspendue et prendre l'intervalle de temps lorsque la tâche est libérée (ou s'interrompt). <br><br><img src="https://habrastorage.org/webt/bf/ts/ao/bftsaoro7gnrtdepts0wcjkmr4k.jpeg"><br><br>  De toute évidence, la tâche en arrière-plan ne doit pas effectuer de travail critique, car la part du temps processeur qui lui est allouée est absolument imprévisible: elle ne peut jamais être planifiée. <br><br>  Une telle solution suppose que chaque tâche peut prédire quand elle sera à nouveau planifiée.  Par exemple, si vous avez des emplacements pour 10 ms et 10 tâches, la tâche sait que si elle est libérée, elle continuera à s'exécuter après 100 ms.  Avec cette solution, vous pouvez obtenir une configuration plus flexible des cycles de temps (temporisations) pour les tâches d'application. <br>  Le RTOS peut fournir différents créneaux horaires pour chaque tâche.  Cela offre plus de flexibilité, mais aussi aussi prévisible qu'avec une taille d'intervalle fixe.  Une autre option consiste à allouer plus d'un intervalle pour la même tâche, si vous devez augmenter la proportion du temps processeur alloué. <br><br><h3>  <b>Planificateur de priorités</b> </h3><br><br>  La plupart des RTOS prennent en charge la planification basée sur les priorités.  L'idée est simple: chaque tâche est prioritaire, et à tout moment la tâche qui a la priorité la plus élevée et est «prête» à être exécutée est transférée au processeur: <br><br><img src="https://habrastorage.org/webt/7o/uv/jd/7ouvjdnimlehr9adnmfyyjo5na4.jpeg"><br><br>  Le planificateur démarre lorsqu'un événement se produit (par exemple, une interruption ou un appel à un service de noyau spécifique) qui force une tâche avec une priorité élevée à devenir "prête".  Il y a trois circonstances dans lesquelles le planificateur commence à fonctionner: <br>  • La tâche est suspendue;  le planificateur doit planifier la tâche suivante. <br>  • Une tâche prépare une tâche de priorité plus élevée (à l'aide d'un appel API). <br>  • Un gestionnaire d'interruption (Routine de service d'interruption, ISR) prépare une tâche de priorité plus élevée.  Cela peut être un gestionnaire d'interruption pour un périphérique d'E / S ou le résultat d'une minuterie système. <br>  Le nombre de niveaux de priorité varie (de 8 à plusieurs centaines), les valeurs de seuil varient également: certains RTOS perçoivent la priorité la plus élevée comme 0, tandis que dans d'autres 0 signifie la priorité la plus faible. <br>  Certains RTOS n'autorisent qu'une seule tâche à chaque niveau de priorité;  d'autres en autorisent quelques-uns, ce qui complique grandement les structures de données associées.  De nombreux systèmes d'exploitation vous permettent de modifier les priorités des tâches au moment de l'exécution, ce qui complique encore les processus. <br><br><h3>  <b>Planificateur composite</b> </h3><br><br>  Nous avons examiné plusieurs planificateurs, cependant, de nombreux RTOS commerciaux offrent des solutions encore plus sophistiquées qui ont les caractéristiques de plusieurs algorithmes à la fois.  Par exemple, un RTOS peut prendre en charge plusieurs tâches à chaque niveau de priorité, puis utiliser TS pour partager le temps entre plusieurs tâches prédéfinies au plus haut niveau. <br><br><h3>  <b>États des tâches</b> </h3><br><br>  À un moment donné, une seule tâche est exécutée.  En plus du temps du processeur passé sur le gestionnaire d'interruption (plus à ce sujet dans l'article suivant) ou le planificateur, la tâche «en cours» est celle dont le code est en cours d'exécution et dont les données sont caractérisées par les valeurs de registre actuelles.  Il peut y avoir d'autres tâches qui sont «prêtes» pour le lancement, et elles seront prises en compte par le planificateur.  Dans un simple RTOS utilisant le planificateur RTC, RR ou TS, c'est tout.  Mais le plus souvent, et toujours avec un ordonnanceur prioritaire, les tâches peuvent également être dans un état suspendu, ce qui signifie qu'elles ne sont pas prises en compte par l'ordonnanceur jusqu'à ce qu'elles soient reprises et passent dans un état de «préparation». <br><br><h3>  <b>Suspendre une tâche</b> </h3><br><br>  La suspension d'une tâche peut être assez simple: la tâche s'arrête d'elle-même (en appelant l'API) ou une autre tâche l'interrompt.  Grâce à un autre appel d'API, une tâche suspendue peut être reprise par une autre tâche ou un gestionnaire d'interruption.  Il s'agit d'une suspension «inconditionnelle» ou «pure».  Certains systèmes d'exploitation appellent cette tâche "en veille". <br><br>  Le RTOS peut fournir à la tâche la possibilité de faire une pause (s'endormir) pendant une certaine période de temps, après quoi elle reprend (selon l'horloge du système).  Cela peut être appelé «s'endormir». <br><br>  Si le RTOS prend en charge les appels d'API «bloquants», une suspension plus sophistiquée peut être utilisée.  Un tel appel permet à la tâche de demander un service ou une ressource qu'il recevra immédiatement s'il est disponible.  Sinon, il sera suspendu jusqu'à ce qu'il devienne disponible.  Des délais d'expiration peuvent également être définis à partir desquels la tâche reprend si la ressource n'est pas disponible pendant une certaine période. <br><br><h3>  <b>Autres états de tâche</b> </h3><br><br>  De nombreux RTOS prennent en charge d'autres États, mais les concepts et définitions varient considérablement.  Par exemple, l'état est «terminé», ce qui signifie simplement que la fonction externe de la tâche est sortie (soit en renvoyant le code, soit simplement en complétant le bloc de fonction externe).  Pour que la tâche terminée puisse recommencer, elle devra probablement être réinitialisée d'une manière ou d'une autre. <br><br>  Une autre option est l'état terminé.  Ceci est similaire à une suspension complète (pure), sauf que la tâche doit être réinitialisée pour redémarrer. <br><br>  Si le RTOS prend en charge la création et la suppression dynamiques de tâches (voir l'article suivant), cela implique un autre état possible de la tâche - «supprimé». <br><br>  <i>Lorsque nous avons travaillé sur notre propre système d'exploitation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OSRV MAX en</a> temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réel</a> (articles déjà publiés à ce sujet), notre équipe a « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">découvert</a> » le blog de Colin Walls, un expert en microélectronique et firmware de Mentor Graphics.</i>  <i>Les articles semblaient intéressants, les traduisaient eux-mêmes, mais afin de ne pas "écrire sur la table", ils ont décidé de publier.</i>  <i>J'espère qu'ils vous seront également utiles.</i>  <i>Si c'est le cas, nous prévoyons de publier tous les articles traduits de la série.</i> <i><br><br></i>  <i><b>À propos de l'auteur:</b> Colin Walls travaille dans l'industrie électronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.</i>  <i>Il est maintenant ingénieur firmware chez Mentor Embedded (une division de Mentor Graphics).</i>  <i>Colin Walls intervient souvent lors de conférences et séminaires, auteur de nombreux articles techniques et de deux livres sur le firmware.</i>  <i>Vit au Royaume-Uni.</i>  <i>Blog professionnel de Colin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blogs.mentor.com/colinwalls</a> , e-mail: colin_walls@mentor.com</i> <br><br>  Les premier et deuxième articles du cycle sont affichés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415329/">https://habr.com/ru/post/fr415329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415315/index.html">Développeur Ilya Belozerov: «Le concours SAP Coder est devenu une bonne motivation pour faire de la programmation web»</a></li>
<li><a href="../fr415319/index.html">Avez-vous besoin de la blockchain? Gestion de la chaîne d'approvisionnement</a></li>
<li><a href="../fr415321/index.html">À propos de l'outil principal du développeur, analyste et gestionnaire</a></li>
<li><a href="../fr415323/index.html">Projets de fin d'études des diplômés du Technoprojet, printemps 2018</a></li>
<li><a href="../fr415327/index.html">Le théorème de Pythagore a été utilisé par les constructeurs de Stonehenge 2000 ans avant la naissance de Pythagore lui-même</a></li>
<li><a href="../fr415331/index.html">Des imprimantes de construction pour imprimeries de 5-6 étages sont produites à Yaroslavl</a></li>
<li><a href="../fr415333/index.html">Arduino - émetteur de diffusion AM micropuissant</a></li>
<li><a href="../fr415335/index.html">Tutoriel d'arrière-plan Android. Partie 5: Coroutines à Kotlin</a></li>
<li><a href="../fr415337/index.html">Comment les canaux Pusher ont déjà livré 10 000 000 000 000 de messages</a></li>
<li><a href="../fr415341/index.html">Cours d'administration PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>