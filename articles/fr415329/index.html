<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ”« ğŸ‘¨â€ğŸ¤ Toute la vÃ©ritÃ© sur RTOS de Colin Walls. Article # 3. TÃ¢ches et planification ğŸ“¦ ğŸ¤°ğŸ¿ ğŸ¤™ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons examinÃ© le multitÃ¢che, la propriÃ©tÃ© du systÃ¨me d'exploitation d'exÃ©cuter plusieurs programmes quasi indÃ©pendants en mÃªme temps. Avant d'exa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vÃ©ritÃ© sur RTOS de Colin Walls. Article # 3. TÃ¢ches et planification</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415329/"><img src="https://habrastorage.org/webt/_n/_m/_1/_n_m_1c68gkqkhmie1mi8yvunqm.jpeg"><br><br>  Nous avons examinÃ© le multitÃ¢che, la propriÃ©tÃ© du systÃ¨me d'exploitation d'exÃ©cuter plusieurs programmes quasi indÃ©pendants en mÃªme temps.  Avant d'examiner de plus prÃ¨s les tÃ¢ches, nous devons en traiter les termes. <br><a name="habracut"></a><br>  Articles prÃ©cÃ©dents de la sÃ©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps rÃ©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br>  Nous utilisons le mot Â«tÃ¢cheÂ», bien qu'il n'ait pas de signification exacte.  D'autres termes, Â«fluxÂ» et Â«processusÂ», sont plus spÃ©cialisÃ©s et vous devez comprendre ce qu'ils signifient et en quoi ils diffÃ¨rent. <br><br>  De nombreux RTOS utilisÃ©s dans les applications intÃ©grÃ©es utilisent un modÃ¨le multithread.  Plusieurs threads peuvent Ãªtre exÃ©cutÃ©s simultanÃ©ment, occupant le mÃªme espace d'adressage: <br><br><img src="https://habrastorage.org/webt/x0/it/ox/x0itoxoxnraj0iozwghigjmtem8.jpeg"><br><br>  Cela signifie que la commutation de contexte consiste, tout d'abord, Ã  passer d'un ensemble de registres de processeur Ã  un autre.  C'est simple et rapide.  Le danger potentiel est que chaque thread a la capacitÃ© d'accÃ©der Ã  la mÃ©moire qui appartient Ã  d'autres threads ou au RTOS lui-mÃªme. <br><br>  Une alternative est le modÃ¨le multi-processus.  Si plusieurs processus sont en cours d'exÃ©cution, chaque processus a son propre espace d'adressage et vous ne pouvez pas accÃ©der Ã  la mÃ©moire associÃ©e Ã  d'autres processus ou RTOS: <br><br><img src="https://habrastorage.org/webt/24/wy/er/24wyer7rvordzgxzvejdo7qscqw.jpeg"><br><br>  Cela rend le changement de contexte plus difficile et plus long, car le systÃ¨me d'exploitation doit configurer correctement l'unitÃ© de gestion de la mÃ©moire, le gestionnaire de mÃ©moire (English Memory Management Unit, MMU).  Bien entendu, une telle architecture n'est possible qu'avec un processeur prenant en charge MMU.  Les processus sont pris en charge par RTOS "hautes performances" et la plupart des OS de bureau.  De plus, chaque processus peut prendre en charge la division en plusieurs threads, mais cette propriÃ©tÃ© est rarement utilisÃ©e dans les applications embarquÃ©es ordinaires. <br><br>  Si une MMU est disponible, un compromis peut Ãªtre trouvÃ©: <br><br><img src="https://habrastorage.org/webt/nv/gx/_f/nvgx_fw_fk51ihd8f3sdprngfaq.jpeg"><br><br>  De nombreux RTOS Â«en streamingÂ» prennent en charge les MMU pour protÃ©ger la mÃ©moire contre les accÃ¨s non autorisÃ©s.  Ainsi, alors que la tÃ¢che est en contexte, seule une partie de son code / donnÃ©es et les sections nÃ©cessaires du RTOS sont Â«visiblesÂ»;  les blocs de mÃ©moire restants sont dÃ©sactivÃ©s et une tentative d'accÃ¨s entraÃ®nera une urgence (pour les gens ordinaires) / exception (pour les programmeurs).  Cela rend le changement de contexte un peu plus difficile, mais l'application elle-mÃªme est plus sÃ©curisÃ©e.  Ce mode peut Ãªtre appelÃ© Â«Mode Thread ProtectedÂ» ou Â«Lightweight Process ModeÂ». <br><br><h3>  <b>Planificateurs</b> </h3><br><br>  Comme nous le savons, l'illusion de l'exÃ©cution simultanÃ©e de tÃ¢ches est obtenue en allouant du temps processeur pour terminer chacune des tÃ¢ches.  Il s'agit de la fonction principale du noyau.  La mÃ©thode de rÃ©partition du temps entre les tÃ¢ches est appelÃ©e Â«planificationÂ».  Scheduler - logiciel qui dÃ©termine Ã  quelle prochaine tÃ¢che transfÃ©rer le contrÃ´le.  La logique de l'ordonnanceur et le mÃ©canisme qui dÃ©termine quand et ce qui doit Ãªtre exÃ©cutÃ© est l'algorithme de planification.  Dans cette section, nous examinons plusieurs algorithmes de planification.  La planification des tÃ¢ches est un sujet vaste et de nombreux livres y sont consacrÃ©s.  Nous fournirons le minimum nÃ©cessaire pour comprendre ce qu'un RTOS particulier peut offrir Ã  cet Ã©gard. <br><br><h3>  <b>Run to Completion Scheduler (RTC)</b> </h3><br><br>  Le planificateur RTC (exÃ©cution complÃ¨te) est trÃ¨s simple et consomme un minimum de ressources.  Il s'agit d'un service idÃ©al s'il rÃ©pond aux exigences de l'application.  Voici un graphique pour un systÃ¨me utilisant le planificateur RTC: <br><br><img src="https://habrastorage.org/webt/te/hp/dl/tehpdlu3fx1ty2ea5ji1frpyscg.jpeg"><br><br>  Le planificateur invoque Ã  tour de rÃ´le les fonctions de niveau supÃ©rieur de chaque tÃ¢che.  La tÃ¢che contrÃ´le le processeur (l'interrompt) jusqu'Ã  ce que la fonction de niveau supÃ©rieur exÃ©cute l'instruction return return.  Si le RTOS prend en charge la suspension des tÃ¢ches, toutes les tÃ¢ches actuellement suspendues ne sont pas exÃ©cutÃ©es.  Ce sujet est abordÃ© dans l'article ci-dessous, voir Â«Suspension d'une tÃ¢cheÂ». <br><br>  Un grand avantage du planificateur RTC, en plus de la simplicitÃ©, est une pile unique et la portabilitÃ© du code (l'assemblage n'est pas requis).  L'inconvÃ©nient est que la tÃ¢che peut "prendre" le processeur, donc un dÃ©veloppement soigneux du programme est nÃ©cessaire.  MalgrÃ© le fait que chaque fois que la tÃ¢che est exÃ©cutÃ©e depuis le dÃ©but (contrairement Ã  d'autres planificateurs qui vous permettent de dÃ©marrer le travail Ã  partir de l'arrÃªt), vous pouvez obtenir plus de flexibilitÃ© Ã  l'aide de variables "d'Ã©tat" statiques qui dÃ©terminent la logique de chaque appel suivant. <br><br><h3>  <b>Scheduler Round Robin (RR)</b> </h3><br><br>  L'ordonnanceur RR ("carrousel") est similaire au RTC, mais plus flexible et donc plus complexe: <br><br><img src="https://habrastorage.org/webt/rm/ug/ut/rmugut4wxk5npcx_xzxe_ckkaro.jpeg"><br><br>  Cependant, dans le cas du planificateur RR, la tÃ¢che n'a pas besoin d'exÃ©cuter l'instruction return dans la fonction de niveau supÃ©rieur.  Elle peut libÃ©rer le processeur Ã  tout moment en effectuant un appel RTOS.  Cet appel oblige le noyau Ã  sauvegarder le contexte de la tÃ¢che en cours (tous les registres, y compris le pointeur de pile et le pointeur de commande) et Ã  charger le contexte de la tÃ¢che suivante dans la file d'attente.  Dans certains RTOS, le processeur peut Ãªtre libÃ©rÃ© (mettre la tÃ¢che en pause) en prÃ©vision de la disponibilitÃ© de la ressource du noyau.  C'est plus compliquÃ©, mais le principe est le mÃªme. <br><br>  La flexibilitÃ© de l'ordonnanceur RR est dÃ©terminÃ©e par la possibilitÃ© de continuer Ã  effectuer des tÃ¢ches Ã  partir du moment de la suspension, sans apporter de modifications au code d'application.  Pour plus de flexibilitÃ©, vous devez payer moins de portabilitÃ© du code et une pile distincte pour chaque tÃ¢che. <br><br><h3>  <b>Planificateur de tranche de temps (TS)</b> </h3><br><br>  Scheduler TS (tranche de temps - "tranche de temps") Ã  un niveau plus complexe que RR.  Le temps est divisÃ© en tranches (intervalles, tranches de temps), oÃ¹ chaque tÃ¢che peut Ãªtre effectuÃ©e dans son intervalle assignÃ©: <br><br><img src="https://habrastorage.org/webt/eu/xa/hs/euxahs5t148pqxeqvxcydpql1ce.jpeg"><br><br>  En plus de la possibilitÃ© de libÃ©rer volontairement le processeur, la tÃ¢che peut Ãªtre interrompue par un appel au planificateur exÃ©cutÃ© par le gestionnaire d'interruption du temporisateur systÃ¨me.  L'idÃ©e d'attribuer une pÃ©riode de temps fixe Ã  chaque tÃ¢che est trÃ¨s intÃ©ressante (si possible): elle est facile Ã  comprendre et trÃ¨s prÃ©visible. <br>  L'inconvÃ©nient du planificateur TS est que le pourcentage de temps CPU allouÃ© Ã  chaque tÃ¢che peut diffÃ©rer, selon que d'autres tÃ¢ches sont suspendues et que d'autres parties des emplacements sont libres: <br><br><img src="https://habrastorage.org/webt/du/7e/iw/du7eiwhyms79l2ycinzsw5rc5ko.jpeg"><br><br>  Le planificateur TS peut devenir plus prÃ©visible si des tÃ¢ches en arriÃ¨re-plan sont implÃ©mentÃ©es.  La tÃ¢che d'arriÃ¨re-plan peut Ãªtre effectuÃ©e Ã  la place de toute tÃ¢che suspendue et prendre l'intervalle de temps lorsque la tÃ¢che est libÃ©rÃ©e (ou s'interrompt). <br><br><img src="https://habrastorage.org/webt/bf/ts/ao/bftsaoro7gnrtdepts0wcjkmr4k.jpeg"><br><br>  De toute Ã©vidence, la tÃ¢che en arriÃ¨re-plan ne doit pas effectuer de travail critique, car la part du temps processeur qui lui est allouÃ©e est absolument imprÃ©visible: elle ne peut jamais Ãªtre planifiÃ©e. <br><br>  Une telle solution suppose que chaque tÃ¢che peut prÃ©dire quand elle sera Ã  nouveau planifiÃ©e.  Par exemple, si vous avez des emplacements pour 10 ms et 10 tÃ¢ches, la tÃ¢che sait que si elle est libÃ©rÃ©e, elle continuera Ã  s'exÃ©cuter aprÃ¨s 100 ms.  Avec cette solution, vous pouvez obtenir une configuration plus flexible des cycles de temps (temporisations) pour les tÃ¢ches d'application. <br>  Le RTOS peut fournir diffÃ©rents crÃ©neaux horaires pour chaque tÃ¢che.  Cela offre plus de flexibilitÃ©, mais aussi aussi prÃ©visible qu'avec une taille d'intervalle fixe.  Une autre option consiste Ã  allouer plus d'un intervalle pour la mÃªme tÃ¢che, si vous devez augmenter la proportion du temps processeur allouÃ©. <br><br><h3>  <b>Planificateur de prioritÃ©s</b> </h3><br><br>  La plupart des RTOS prennent en charge la planification basÃ©e sur les prioritÃ©s.  L'idÃ©e est simple: chaque tÃ¢che est prioritaire, et Ã  tout moment la tÃ¢che qui a la prioritÃ© la plus Ã©levÃ©e et est Â«prÃªteÂ» Ã  Ãªtre exÃ©cutÃ©e est transfÃ©rÃ©e au processeur: <br><br><img src="https://habrastorage.org/webt/7o/uv/jd/7ouvjdnimlehr9adnmfyyjo5na4.jpeg"><br><br>  Le planificateur dÃ©marre lorsqu'un Ã©vÃ©nement se produit (par exemple, une interruption ou un appel Ã  un service de noyau spÃ©cifique) qui force une tÃ¢che avec une prioritÃ© Ã©levÃ©e Ã  devenir "prÃªte".  Il y a trois circonstances dans lesquelles le planificateur commence Ã  fonctionner: <br>  â€¢ La tÃ¢che est suspendue;  le planificateur doit planifier la tÃ¢che suivante. <br>  â€¢ Une tÃ¢che prÃ©pare une tÃ¢che de prioritÃ© plus Ã©levÃ©e (Ã  l'aide d'un appel API). <br>  â€¢ Un gestionnaire d'interruption (Routine de service d'interruption, ISR) prÃ©pare une tÃ¢che de prioritÃ© plus Ã©levÃ©e.  Cela peut Ãªtre un gestionnaire d'interruption pour un pÃ©riphÃ©rique d'E / S ou le rÃ©sultat d'une minuterie systÃ¨me. <br>  Le nombre de niveaux de prioritÃ© varie (de 8 Ã  plusieurs centaines), les valeurs de seuil varient Ã©galement: certains RTOS perÃ§oivent la prioritÃ© la plus Ã©levÃ©e comme 0, tandis que dans d'autres 0 signifie la prioritÃ© la plus faible. <br>  Certains RTOS n'autorisent qu'une seule tÃ¢che Ã  chaque niveau de prioritÃ©;  d'autres en autorisent quelques-uns, ce qui complique grandement les structures de donnÃ©es associÃ©es.  De nombreux systÃ¨mes d'exploitation vous permettent de modifier les prioritÃ©s des tÃ¢ches au moment de l'exÃ©cution, ce qui complique encore les processus. <br><br><h3>  <b>Planificateur composite</b> </h3><br><br>  Nous avons examinÃ© plusieurs planificateurs, cependant, de nombreux RTOS commerciaux offrent des solutions encore plus sophistiquÃ©es qui ont les caractÃ©ristiques de plusieurs algorithmes Ã  la fois.  Par exemple, un RTOS peut prendre en charge plusieurs tÃ¢ches Ã  chaque niveau de prioritÃ©, puis utiliser TS pour partager le temps entre plusieurs tÃ¢ches prÃ©dÃ©finies au plus haut niveau. <br><br><h3>  <b>Ã‰tats des tÃ¢ches</b> </h3><br><br>  Ã€ un moment donnÃ©, une seule tÃ¢che est exÃ©cutÃ©e.  En plus du temps du processeur passÃ© sur le gestionnaire d'interruption (plus Ã  ce sujet dans l'article suivant) ou le planificateur, la tÃ¢che Â«en coursÂ» est celle dont le code est en cours d'exÃ©cution et dont les donnÃ©es sont caractÃ©risÃ©es par les valeurs de registre actuelles.  Il peut y avoir d'autres tÃ¢ches qui sont Â«prÃªtesÂ» pour le lancement, et elles seront prises en compte par le planificateur.  Dans un simple RTOS utilisant le planificateur RTC, RR ou TS, c'est tout.  Mais le plus souvent, et toujours avec un ordonnanceur prioritaire, les tÃ¢ches peuvent Ã©galement Ãªtre dans un Ã©tat suspendu, ce qui signifie qu'elles ne sont pas prises en compte par l'ordonnanceur jusqu'Ã  ce qu'elles soient reprises et passent dans un Ã©tat de Â«prÃ©parationÂ». <br><br><h3>  <b>Suspendre une tÃ¢che</b> </h3><br><br>  La suspension d'une tÃ¢che peut Ãªtre assez simple: la tÃ¢che s'arrÃªte d'elle-mÃªme (en appelant l'API) ou une autre tÃ¢che l'interrompt.  GrÃ¢ce Ã  un autre appel d'API, une tÃ¢che suspendue peut Ãªtre reprise par une autre tÃ¢che ou un gestionnaire d'interruption.  Il s'agit d'une suspension Â«inconditionnelleÂ» ou Â«pureÂ».  Certains systÃ¨mes d'exploitation appellent cette tÃ¢che "en veille". <br><br>  Le RTOS peut fournir Ã  la tÃ¢che la possibilitÃ© de faire une pause (s'endormir) pendant une certaine pÃ©riode de temps, aprÃ¨s quoi elle reprend (selon l'horloge du systÃ¨me).  Cela peut Ãªtre appelÃ© Â«s'endormirÂ». <br><br>  Si le RTOS prend en charge les appels d'API Â«bloquantsÂ», une suspension plus sophistiquÃ©e peut Ãªtre utilisÃ©e.  Un tel appel permet Ã  la tÃ¢che de demander un service ou une ressource qu'il recevra immÃ©diatement s'il est disponible.  Sinon, il sera suspendu jusqu'Ã  ce qu'il devienne disponible.  Des dÃ©lais d'expiration peuvent Ã©galement Ãªtre dÃ©finis Ã  partir desquels la tÃ¢che reprend si la ressource n'est pas disponible pendant une certaine pÃ©riode. <br><br><h3>  <b>Autres Ã©tats de tÃ¢che</b> </h3><br><br>  De nombreux RTOS prennent en charge d'autres Ã‰tats, mais les concepts et dÃ©finitions varient considÃ©rablement.  Par exemple, l'Ã©tat est Â«terminÃ©Â», ce qui signifie simplement que la fonction externe de la tÃ¢che est sortie (soit en renvoyant le code, soit simplement en complÃ©tant le bloc de fonction externe).  Pour que la tÃ¢che terminÃ©e puisse recommencer, elle devra probablement Ãªtre rÃ©initialisÃ©e d'une maniÃ¨re ou d'une autre. <br><br>  Une autre option est l'Ã©tat terminÃ©.  Ceci est similaire Ã  une suspension complÃ¨te (pure), sauf que la tÃ¢che doit Ãªtre rÃ©initialisÃ©e pour redÃ©marrer. <br><br>  Si le RTOS prend en charge la crÃ©ation et la suppression dynamiques de tÃ¢ches (voir l'article suivant), cela implique un autre Ã©tat possible de la tÃ¢che - Â«supprimÃ©Â». <br><br>  <i>Lorsque nous avons travaillÃ© sur notre propre systÃ¨me d'exploitation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OSRV MAX en</a> temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rÃ©el</a> (articles dÃ©jÃ  publiÃ©s Ã  ce sujet), notre Ã©quipe a Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dÃ©couvert</a> Â» le blog de Colin Walls, un expert en microÃ©lectronique et firmware de Mentor Graphics.</i>  <i>Les articles semblaient intÃ©ressants, les traduisaient eux-mÃªmes, mais afin de ne pas "Ã©crire sur la table", ils ont dÃ©cidÃ© de publier.</i>  <i>J'espÃ¨re qu'ils vous seront Ã©galement utiles.</i>  <i>Si c'est le cas, nous prÃ©voyons de publier tous les articles traduits de la sÃ©rie.</i> <i><br><br></i>  <i><b>Ã€ propos de l'auteur:</b> Colin Walls travaille dans l'industrie Ã©lectronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.</i>  <i>Il est maintenant ingÃ©nieur firmware chez Mentor Embedded (une division de Mentor Graphics).</i>  <i>Colin Walls intervient souvent lors de confÃ©rences et sÃ©minaires, auteur de nombreux articles techniques et de deux livres sur le firmware.</i>  <i>Vit au Royaume-Uni.</i>  <i>Blog professionnel de Colin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blogs.mentor.com/colinwalls</a> , e-mail: colin_walls@mentor.com</i> <br><br>  Les premier et deuxiÃ¨me articles du cycle sont affichÃ©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415329/">https://habr.com/ru/post/fr415329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415315/index.html">DÃ©veloppeur Ilya Belozerov: Â«Le concours SAP Coder est devenu une bonne motivation pour faire de la programmation webÂ»</a></li>
<li><a href="../fr415319/index.html">Avez-vous besoin de la blockchain? Gestion de la chaÃ®ne d'approvisionnement</a></li>
<li><a href="../fr415321/index.html">Ã€ propos de l'outil principal du dÃ©veloppeur, analyste et gestionnaire</a></li>
<li><a href="../fr415323/index.html">Projets de fin d'Ã©tudes des diplÃ´mÃ©s du Technoprojet, printemps 2018</a></li>
<li><a href="../fr415327/index.html">Le thÃ©orÃ¨me de Pythagore a Ã©tÃ© utilisÃ© par les constructeurs de Stonehenge 2000 ans avant la naissance de Pythagore lui-mÃªme</a></li>
<li><a href="../fr415331/index.html">Des imprimantes de construction pour imprimeries de 5-6 Ã©tages sont produites Ã  Yaroslavl</a></li>
<li><a href="../fr415333/index.html">Arduino - Ã©metteur de diffusion AM micropuissant</a></li>
<li><a href="../fr415335/index.html">Tutoriel d'arriÃ¨re-plan Android. Partie 5: Coroutines Ã  Kotlin</a></li>
<li><a href="../fr415337/index.html">Comment les canaux Pusher ont dÃ©jÃ  livrÃ© 10 000 000 000 000 de messages</a></li>
<li><a href="../fr415341/index.html">Cours d'administration PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>