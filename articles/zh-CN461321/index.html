<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚽️ 🐿️ 💎 泛型和元编程模型：Go，Rust，Swift，D等 📥 😤 🈯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在某些编程领域，通常希望编写一种数据结构或算法来处理不同类型的元素。 例如，仅需要比较功能的泛型列表或排序算法。 提供了多种语言来解决此问题的各种方法：从简单地向程序员指出适当的通用函数（C，Go）到如此强大的通用系统，使它们成为图灵完整的（ Rust ， C ++ ）。 在本文中，我将讨论来自不同...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>泛型和元编程模型：Go，Rust，Swift，D等</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br> 在某些编程领域，通常希望编写一种数据结构或算法来处理不同类型的元素。 例如，仅需要比较功能的泛型列表或排序算法。 提供了多种语言来解决此问题的各种方法：从简单地向程序员指出适当的通用函数（C，Go）到如此强大的通用系统，使它们成为图灵完整的（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++</a> ）。 在本文中，我将讨论来自不同语言的通用系统及其实现。 我将首先使用没有这种系统的语言（例如C）解决问题，然后说明逐步扩展扩展如何导致其他语言的系统。 <br><a name="habracut"></a><br> 我发现泛型是一个有趣的选择，因为它们是一般元编程任务的一个简单特殊情况：编写可以生成其他程序类的程序。 作为证明，我将展示如何在通用系统空间中将三种不同且完全通用的元编程方法视为多向扩展：动态语言（如Python），过程宏系统（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Template Haskel）</a>和分阶段编译（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zig</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Terra）</a> 。 <br><br><h2> 复习 </h2><br> 我绘制了本文中描述的所有系统的框图，以便您可以介绍其内容以及这些系统如何互连： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2> 主要思想 </h2><br> 假设我们正在使用不具有通用系统的语言编写代码，并且我们想要创建一个通用堆栈数据结构的数据结构，该结构可以处理任何类型的数据。 问题在于，每个函数和类型定义仅适用于相同大小并以一种方式复制的数据，并且通常类似地工作。 <br><br> 解决此问题的方法有两种：要么确保所有数据类型在我们的结构中均以相同的方式起作用，要么对数据结构进行许多复制，并进行少量更改以使每种数据类型都能正常使用。 这些想法构成了具有泛型的两大类解决方案的基础：装箱和单态化。 <br><br> 包装意味着将所有内容连续放入统一的“盒子”中，它们的工作方式相同。 通常这样做是这样的：将数据放在堆中，并将指向它的指针放在数据结构中。 您可以指向所有将以相同方式工作的类型的指针，因此相同的代码将可用于任何类型的数据！ 但是，这导致内存消耗增加，动态搜索和高速缓存未命中。 在C语言中，这意味着您的数据结构存储<code>void*</code>指针，并且仅将数据缓存到<code>void*</code>或从其中缓存数据（如果数据不在堆中，则会将其放置在其中）。 <br><br> 单一化意味着针对我们要存储的不同类型的数据重复复制代码。 然后，每个代码实例都可以直接使用其使用的大小和数据方法，而无需动态搜索。 使用这种方法，代码可以以最快的速度运行，但是它的大小和编译时间会增加，这是因为我们重复了相同的代码，但做了很小的改动。 在C语言中，这对应于将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">整个数据结构定义为macro</a> ，随后是对每种数据类型的调用。 <br><br> 通常，在编译时，代码的编译速度更快，但是在执行过程中其性能可能会下降，而在单态化过程中，我们会生成快速代码，但是编译和优化代码的所有实例都需要更多时间。 另一个区别是，打包扩展使您可以使可执行代码更具动态性，而单态化则使您可以灵活地分隔通用代码的不同实例。 还值得注意的是，在某些大型程序中，由于生成的代码中附加指令的高速缓存中的未命中，可以抵消单态化的好处。 <br><br> 如果需要更多功能或更高的安全性，上述每种使用泛型的方案都可以朝不同的方向扩展，并且各种语言的作者都提出了非常有趣的解决方案。 例如，两种方法都可以在Rust和C＃中使用！ <br><br><h2> 包装方式 </h2><br> 让我们从Go中的基本包装示例开始： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br> 此外，打包还用于C（ <code>void*</code> ），Go（ <code>interface{}</code> ），通用Java（ <code>Object</code> ）和通用Objective-C（ <code>id</code> ）中。 <br><br><h2> 具有混搭类型的打包泛型 </h2><br> 主要包装方法有以下缺点： <br><br><ul><li> 根据语言的不同，每次读取或写入数据结构时，我们经常必须将值强制转换为正确的类型。 <br></li><li> 没有什么可以阻止我们将不同类型的元素放入结构中，这可能会引发在代码执行过程中看起来像崩溃的错误。 <br></li></ul><br> 这两个问题都可以通过在功能类型的系统中添加泛型来解决，同时以与代码执行期间相同的方式使用主打包方法。 这种方法通常称为类型擦除，因为通用系统中的类型被“覆盖”并在幕后成为一种类型（如<code>Object</code> ）。 <br><br>  Java和Objective-C从通常的包装开始，后来为了兼容起见，使用了类型混搭的通用语言工具，后来获得了使用与以前相同的集合类型，但具有通用类型的可选参数的语言工具。 考虑一下Wikipedia文章中有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java泛型</a>的示例： <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3> 具有统一性能的派生打包泛型 </h3><br>  OCaml进一步发展了统一视图的概念。 没有原始类型需要额外的包装放置（因为<code>int</code>必须转换为<code>Integer</code>才能进入Java中的<code>ArrayList</code> ），因为所有内容都已经被包装或由指针大小的整数值表示，即所有内容都适合一个机器字。 但是，当垃圾回收器查看通用结构中存储的数据时，需要将指针与数字区分开，因此数字用一位标记，放置在正确对齐的指针没有一位的位置，只剩下31或63位的范围。 <br><br>  OCaml还具有类型推断系统，因此您可以编写一个函数，如果不添加注释，则编译器将输出最合适的泛型类型，因此这些函数看起来就像是一种动态类型化的语言： <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br> 给定的类型可以称为“从类型<code>'a</code>到类型<code>'a</code>的元素列表中的一个函数”。 这意味着返回类型将与列表类型相同，并且可以是任何类型。 <br><br><h2> 介面 </h2><br> 常规包装的另一个限制是包装类型是<i>完全</i>不透明的。 对于像栈这样的数据结构来说，这不是问题，但是诸如对通用函数进行排序之类的工具需要附加的功能，例如特定于类型的比较功能。 有许多方法可以在运行时中实现并反映语言，从技术上讲，这是不同的方向，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用几种类似的方法</a>来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现相同的语言</a> 。 但是，不同语言的功能会影响其实现，只有扩展才能增强所选实现的优势。 这意味着有两种基于不同运行时方法的语言家族：虚拟方法表（vtables）和字典传输。 <br><br><h3> 接口方法表 </h3><br> 如果我们要提供特定于类型的功能，并且为了统一处理所有内容而遵循打包策略，那么只要有一个统一的方法就可以找到我们需要从对象中获取的相似功能就足够了。 这种方法被称为“虚拟方法表”（vtable，虚拟方法表），尽管没有人使用全名。 它的实现方式如下：在每个通用结构对象的零偏移处，有一个指向具有一致电路的功能指针表的指针。 在这些表中，通用代码通过以固定偏移量索引特定指针来查找指向特定类型函数的指针。 <br><br> 这是在Rust中的Go和<code>dyn trait</code>对象中实现<code>interface</code>类型的方式。 当将类型转换为要实现的接口类型时，将为该接口创建一个包装，该包装包含一个指向源对象的指针和一个指向特定于类型的函数的vtable的指针。 但这需要对指针的间接寻址和其他方案的附加级别。 因此，在Go中排序使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带有Swap方法的容器接口</a> ，并且不采用Comparable接口的分片，因为这将需要在内存中放置一个全新的接口类型分片，而不是原始分片！ <br><br><h3> 面向对象编程 </h3><br>  OOP是一种语言属性，可以充分利用虚拟类型表的功能。 像Java这样的OOP语言，没有使用vtables分隔单独的接口对象，而是在每个对象的开头插入了一个指向虚拟类型表的指针。 类似Java的语言具有继承系统和接口，可以使用这些虚拟类型对象表完全实现它们。 <br><br> 除了提供其他功能之外，将vtable嵌入每个对象还解决了需要使用间接寻址（间接）构造新接口类型的问题。 与Go不同，在Java中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，sort函数</a>可以将<code>Comparable</code>接口应用于其实现的类型。 <br><br><h3> 倒影 </h3><br> 如果您有虚拟类型的表，那么强制编译器生成其他类型信息的表将很困难，例如，字段名称，类型和位置。 这将允许使用可以查看任何其他类型的所有数据的代码访问该类型的所有数据。 此行为可用于在语言中添加“反射”，从而允许序列化和任意类型的美观显示。 反射作为打包范例的扩展，有一个缺点：为此，仅一个代码副本就足够了，但是您需要执行许多动态搜索，这会降低序列化的速度。 <br><br> 使用反射进行序列化和其他功能的语言：Java，C＃和Go。 <br><br><h3> 动态类型语言 </h3><br> 反射是一个非常强大的工具，可让您解决许多不同的元编程任务。 但是，它不允许您创建新类型或编辑有关现有值类型的信息。 如果我们添加此功能，并且默认情况下使数据访问和修改语法使用反射，那么我们将获得动态类型的语言！ 由于用于解决任何问题的有效，功能强大的反射系统，使用Python和Ruby等语言进行元编程的非凡灵活性已经出现。 <br><br> 您可以说：“但是动态语言不能那样工作，它们只是使用哈希表实现一切！” 哈希表只是用于创建具有类型信息的可编辑表的良好数据结构。 另外，某些解释器（例如CPython）也以这种方式工作。 在V8这样的高性能JIT中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有很多虚拟类型表和</a>反射信息。 在V8中，隐藏类（vtable和反射信息）和对象的结构类似于Java VM中的内容，并具有在运行时用新的虚拟类型表替换对象的功能。 这不是巧合，因为没有巧合： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V8</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建者</a>曾经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在高性能Java VM上工作</a> 。 <br><br><h3> 字典传输 </h3><br> 实现动态接口的另一种方法是将具有所需函数指针的表传输到需要它们的通用函数。 这有点类似于在调用位置构造Go形接口对象，仅在我们这种情况下，表是作为隐藏参数传递的，而不是作为现有参数之一打包成束的。 <br><br> 尽管GHC允许您使用内联和特殊化执行某种类型的单态化，但是该方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Haskell的类型类中</a>使用。  OCaml使用字典传递和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一流</a>参数的形式的显式参数，但是已经有人提议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">增加使参数隐式的能力</a> 。 <br><br><h3>  Swift中的见证表 </h3><br>  Swift的作者使用了一个有趣的解决方案：传输字典，以及将数据放在类型大小上以及如何将它们移动，复制和释放到表中，使您能够为所有类型的统一工作提供所有必要的信息，而无需打包它们。 因此，Swift可以实现泛型， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">而不会以</a>所有实体<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的统一表示形式将其泛化并放置在内存中</a> ！ 是的，您必须为动态搜索付费，这是使用打包的整个系列的典型特征，但是它可以节省用于放置在内存中的资源，内存的使用和缓存不一致。 使用标<a href="">为@inlinable</a>的函数，Swift编译器还可以在模块内部或模块之间进行特殊化（单态化）和内联泛型，从而避免上述费用。 可能使用对代码大小的影响的启发式评估。 <br><br> 它还说明了Swift如何<a href="">实现ABI稳定性</a> ，同时仍然允许您在结构中添加和重新分配字段，尽管作者提供了<code>@frozen</code>属性来拒绝动态搜索以提高性能。 <br><br><h3> 内涵类型分析 </h3><br> 还有另一种实现打包类型的接口的方法。 我们按照vtable指针的示例，将类型标识符添加到对象的特定部分，然后为每个接口方法生成函数，这些接口方法对于实现该方法的所有类型都具有较大的<code>switch</code>表达式，并将其传递给正确的特定于类型的方法。 <br><br> 我没有警告不要使用使用这种方法的语言，但是C ++编译器和Java虚拟机的行为类似，当使用基于配置文件的优化时，它们会发现调用泛型的某个位置主要适用于某些类型的对象。 编译器和VM使用对每个普通类型的检查替换调用位置，然后使用常规动态调度将这些类型静态调度为后备。 因此，分支预测算法可以预测代码将继续执行哪个分支，并将继续使用静态调用来分派指令。 <br><br><h2> 单一化 </h2><br> 这是包装的替代方法。 使用单态化，我们需要找到一种方法来为我们要使用的每种类型生成代码的多个版本。 编译器具有代码需要经历的几个表示阶段，并且从理论上讲，可以复制到任何这些阶段。 <br><br><h3> 源代码生成 </h3><br> 单一化的最简单方法是在第一个演示阶段进行复制：复制源代码！ 这样，编译器甚至不必支持泛型，并且有时这是由C和Go语言的用户完成的，而C和Go语言的编译器没有这种支持。 <br><br> 在C语言中，您可以使用预处理器，并通过使用不同的<code>#define</code>重复插入来定义宏或标头中的数据结构。  Go拥有像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">genny</a>这样的脚本，可以轻松生成代码。 <br><br> 复制源代码的缺点是，根据语言的不同，可能有必要处理众多问题和极端情况，而且，编译器会分析多次并检查类型几乎相同的代码。 同样，根据语言和工具的不同，这些方法的泛型可能很难编写和使用，好像在C宏内部，每行以反斜杠结尾，并且所有函数的类型和名称都必须手动粘贴到其标识符中以避免冲突。 <br><br><h3>  D中的字符串混合 </h3><br> 但是，代码生成有其优点，例如可以使用成熟的编程语言生成代码以及使用用户熟悉的视图。 <br><br> 某些以不同方式实现泛型的语言还使您可以为泛型系统中未考虑的更一般的元编程情况（例如，序列化）生成代码。 最容易理解的示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">D中的字符串混合</a> ，它允许使用语言的所有功能在编译中间以字符串值的形式编译D代码。 <br><br><h3>  Rust程序宏 </h3><br> 一个类似的示例，仅在编译器的一个阶段进行了表示。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust过程宏</a>将令牌流用作输入和输出，从而提供了将这些流转换为字符串（反之亦然）的实用程序。 这种方法的优点是令牌流可以存储源代码中的位置信息。 由用户编写的代码，可以将宏作为令牌直接从输入插入到周末。 如果此代码在macOS的输出中导致编译错误，则编译器将显示一条消息，并准确指向代码损坏部分的文件，行和列。 但是，如果宏生成了损坏的代码，则错误消息将指示宏调用。 例如，如果您使用一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">宏来将函数包装在记录调用中，</a>并在实现包装的函数时出错，则错误消息将直接指向文件中的错误，而不是宏所生成的代码。 <br><br><h3> 语法树宏 </h3><br> 某些语言甚至走得更远，并提供了用于在宏中使用和创建不同类型的抽象语法树的工具（抽象语法树，AST）。 示例包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Template Haskell</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nim宏</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OCaml PPX</a>和几乎所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lisp</a> 。 <br><br>  AST宏的缺点是您不想强迫用户学习大量的函数来构建AST类型以及基本语言。 在Lisp语言家族中，可以借助AST的语法和结构之间的极大简化和最大对应来解决此问题，但是，创建结构并不总是那么容易。 <br><br> 因此，在我提到的所有语言中，以一种或另一种形式都有一个“ quote”原语，您在其中提供了该语言的一段代码，并返回了语法树。 这些原语可以使用字符串插值的相似性来合并语法树的值。 这是有关模板Haskell的示例： <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> ,    ,  </a> ! <br><br><h3> 模式 </h3><br>    —        .   ++  D    ,         « ».        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C++20  «»</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      «    ». , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Terra</a>    ,   . Terra —   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     —  Swift  Haskell. <br><br>  Rust      « » (trait bounds). <code>Trait</code> —      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        —          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461321/">https://habr.com/ru/post/zh-CN461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461307/index.html">我们邀请您参加VK Hackathon2019。今年的奖金池为200万卢布。</a></li>
<li><a href="../zh-CN461309/index.html">除Kotlin之外的所有内容：Andrei Breslav谈IT，情感等方面的性别平衡</a></li>
<li><a href="../zh-CN461313/index.html">Zimbra 8.8.15 LTS发布</a></li>
<li><a href="../zh-CN461317/index.html">创建优质iOS应用程序的9条原则</a></li>
<li><a href="../zh-CN461319/index.html">游戏设计师会做什么？</a></li>
<li><a href="../zh-CN461323/index.html">波动函数崩溃算法的易于理解的解释</a></li>
<li><a href="../zh-CN461325/index.html">PHDays 9的胜利。我们分三部分分享生活技巧。 第三部分</a></li>
<li><a href="../zh-CN461327/index.html">前端危机？</a></li>
<li><a href="../zh-CN461329/index.html">自动呼吸器官分割</a></li>
<li><a href="../zh-CN461333/index.html">ITX5 mitap：直播JAVA，Kotlin魔术和番茄火种</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>