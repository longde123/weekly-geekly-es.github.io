<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏾 ☝🏽 📷 PVS-Studio静态代码分析仪可抵御零日漏洞 🙏🏽 🖕🏼 👐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="零日威胁是一个尚未发现的开发漏洞的术语。 网络犯罪分子可以利用这些漏洞，最终将影响公司的声誉。 开发人员面临的任务是最大程度地减少可能导致这种漏洞的代码中的缺陷数量。 用于识别安全漏洞的工具之一是针对C，C ++，C＃，Java的PVS-Studio静态代码分析器。 

 零日威胁 
 零日威胁是一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio静态代码分析仪可抵御零日漏洞</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477840/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/wn/yg/mo/wnygmobm1xqfcuxn4cmsqzay8lg.png" alt="PVS-Studio静态代码分析仪可抵御零日漏洞"></div><br> 零日威胁是一个尚未发现的开发漏洞的术语。 网络犯罪分子可以利用这些漏洞，最终将影响公司的声誉。 开发人员面临的任务是最大程度地减少可能导致这种漏洞的代码中的缺陷数量。 用于识别安全漏洞的工具之一是针对C，C ++，C＃，Java的PVS-Studio静态代码分析器。 <br><a name="habracut"></a><br><h2> 零日威胁 </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%258F%25D0%25B7%25D0%25B2%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BD%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B4%25D0%25BD%25D1%258F">零日威胁</a>是一个术语，用于标识开发人员允许但尚未发现的漏洞和漏洞。 在修复该漏洞之前，它可以用于访问网络，远程控制计算机，操纵数据等。 由于开发人员没有一天修复缺陷的事实，因为尚无人知道这一事实，因此该术语的名称已广为人知。 在适当的时候，诸如<a href="https://www.anti-malware.ru/news/2010-10-28/3192">Adobe</a> ， <a href="https://threatpost.ru/windows-deletebug-zero-day-allows-privilege-escalation-destruction/28888/">Windows</a> ， <a href="https://www.make-info.com/zero-day-vulnerability-in-tor/">Tor浏览器之</a>类的大公司和软件就遭受了这些漏洞的困扰。 <br><br> 一些组织很幸运，他们的脆弱性是由不打算使用它的人发现的，他们只是提供有关该问题的信息。 例如，这是使用<a href="https://securityaffairs.co/wordpress/86543/hacking/synthetic-clicks-macos-0day.html">MacOS的</a> 。 或者有一个更新，除了新功能外，还意外修复了零日威胁。 <br><br> 但是，还有其他情况。 例如，谷歌浏览器一次迫切需要修复一个<a href="https://3dnews.ru/996818">漏洞</a> ，该<a href="https://3dnews.ru/996818">漏洞</a>使攻击者可以在受害者的设备上远程执行任意代码。 <br><br> 这种威胁的问题在于不可能100％防御它，因为很难防御您尚不了解的事情。 但是，有一些方法可以减少您的项目中出现此类威胁的可能性，我们将在稍后进行讨论，但只需要一点理论即可。 <br><br><h2> 静态分析 </h2><br> 静态代码分析是由分析仪检查程序代码而不启动程序本身的过程。 静态分析可以被视为自动化的代码审查过程。 在某些情况下，静态分析的有效性优于代码审查，但不能被多个程序员视为代码审查的完整替代方案。 下面，我尝试简要概述一下代码审查和静态代码分析之间的优缺点。 <br><div class="scrollable-table"><table><tbody><tr><th> 代码审查 <br></th><th> 静态分析 <br></th></tr><tr><td> 识别简单错误和高级错误的能力 <br></td><td> 您甚至不知道这种缺陷或漏洞模式就可以找到错误。 <br></td></tr><tr><td> 改进了应用程序的体系结构，并开发了统一的编码样式。 <br></td><td> 您可能会发现在代码检查过程中难以搜索的错误（例如，错别字） <br></td></tr><tr><td> 高价 <br></td><td> 价格低于代码审查 <br></td></tr><tr><td>程序员要花很多时间。 有必要休息一下，因为注意力会很快变暗 <br></td><td> 不可避免的误报和分析仪的调整需求 <br></td></tr></tbody></table></div><h2>  CVE和CWE </h2><br> 常见漏洞和披露（CVE）是网络犯罪分子可以使用的软件错误数据库。 创建CVE是为了简化已知的软件缺陷。 大多数信息安全工具使用自己的数据库和名称，为了消除这种混乱并增加与各种工具的兼容性，MITRE在1999年创建了CVE。 但是，CVE不足以评估代码安全性。 这就需要更精确的方法，并详细说明问题，并且要比实际情况少得多。 因此，创建了满足这些要求的通用弱点枚举（CWE）库。 如果错误在CWE列表中，则很可能会导致攻击者可以利用该漏洞并进入CVE列表。 为了清楚起见，您可以查看下面的欧拉图。 <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/02/l7/ec02l74mwthliqvd97vw2cqmblq.png" alt="CVE，CWE"></div><br> 一些静态分析器可以告诉开发人员，例如，该项目使用的漏洞所在的库。 这样，您可以选择已修复了漏洞的库的较新版本，并减少由于其他人的代码而引起威胁的问题的可能性。 <br><br> 随着CVE和CWE列表的发展，许多信息安全工具已经开始提供支持，包括静态分析器。 此类分析仪可以视为SAST解​​决方案。  SAST（静态应用程序安全性测试）允许开发人员在软件开发生命周期的早期阶段就发现应用程序源代码中的漏洞。 <br><br> 在开发中使用SAST是将零日威胁的可能性降到最低的另一种选择。 分析器根据CWE对错误进行分类，可以判断隐藏在哪里的潜在漏洞。 通过更正这些错误，开发人员可以使应用程序更可靠，并减少0天威胁的可能性。 <br><br> 有各种用于静态安全测试的工具。 为了演示处理漏洞的功能，让我们关注一下<a href="https://www.viva64.com/ru/sast/">PVS-Studio</a>工具。 该分析仪发出的警告可归为CWE。 让我们看几个例子。 <br><br> 警告PVS-Studio： <a href="https://cwe.mitre.org/data/definitions/561.html">CWE-561</a> ： <a href="https://www.viva64.com/ru/w/v3021/">无效</a>代码（ <a href="https://www.viva64.com/ru/w/v3021/">V3021</a> ）。 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncodeImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrWhiteSpace(inputPath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"inputPath"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrWhiteSpace(inputPath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"outputPath"</span></span>); } .... }</code> </pre> <br> 这段代码无意中打了错字。 在两个<i>if</i>条件中，将检查同一变量。 根据生成的异常判断，在第二种情况下，应检查变量<i>outputPath</i> 。 结果，部分代码无法访问。 <br><br> 乍看之下，此类错误看起来是无害的。 但是，这种印象可能会令人误解。 考虑一个非常简单且乍看之下与<i>goto</i>运算符重复有关的无害错误。 <br><br> 一次，此错误导致iOS操作系统中的漏洞。 <br><br>  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2014-1266">CVE-2014-1266</a>漏洞说明：6.1.6之前的Apple iOS 6.x和7.0.6之前的7.x，Apple TV中的数据安全性组件中安全传输功能中的libsecurity_ssl / lib / sslKeyExchange.c中的SSLsecurityifySignedServerKeyExchange函数6.0.2之前的6.x和10.9.2之前的Apple OS X 10.9.x不会检查TLS服务器密钥交换消息中的签名，该消息允许中间人攻击者使用任意内容来欺骗SSL服务器签名步骤或省略签名步骤的私钥。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> OSStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSLVerifySignedServerKeyExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSLContext *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isRsa, SSLBuffer signedParams, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *signature, UInt16 signatureLen)</span></span></span><span class="hljs-function"> </span></span>{ OSStatus err; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; .... fail: SSLFreeBuffer(&amp;signedHashes); SSLFreeBuffer(&amp;hashCtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br> 由于两次<i>goto</i> ，还会出现代码无法到达的情况。 无论条件如何，第二条goto <i>语句</i>都将在<i>if</i>语句中执行。 这导致不进行签名验证的事实。 该函数返回0，这意味着签名无误，即使签名存在问题，程序也将从服务器接收密钥。 在传输期间加密数据需要此密钥。 <br><br> 这种简单错误的后果非常严重。 因此，没有理由争辩将此错误分类为CWE有多危险。 只需对其进行修复，从而使代码更安全。 <br><br> 顺便说一下，PVS-Studio分析仪可以很容易地检测出所描述的错误。 他会立即在此处发出两个CWE警告： <br><br><ul><li>  <a href="https://cwe.mitre.org/data/definitions/561.html">CWE-561</a> （ <a href="https://www.viva64.com/ru/w/v779/">V779</a> ）： <a href="https://www.viva64.com/ru/w/v779/">无效</a>代码 </li><li>  <a href="https://cwe.mitre.org/data/definitions/483.html">CWE-483</a> （ <a href="https://www.viva64.com/ru/w/v640/">V640</a> ）：不正确的块定界 </li></ul><br> 让我们看另一个例子。 早在2012年，人们就知道MySQL中的安全性问题，攻击者可以在其中进入MySQL数据库。 我将提供一段代码作为此原因。 <br><br>  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2012-2122">CVE-2012-2122说明</a> ：在Oracle MySQL 5.1.x（5.1.63之前），5.5.x（5.5.24之前）和5.6.x（5.6.6之前）以及MariaDB 5.1.x（5.1.62之前）中的sql / password.c，在具有memcmp功能某些实现的某些环境中运行时，在5.2.12之前的5.2.x，5.3.6之前的5.3.x和5.5.23之前的5.5.x允许远程攻击者通过重复验证以绕过身份验证来绕过身份验证错误的密码，由于返回值检查不正确，最终导致令牌比较成功。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> my_bool; <span class="hljs-function"><span class="hljs-function">my_bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_scramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scramble_arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  <i>memcmp</i>函数的返回类型<i>为int</i> ，而<i>check_scramble</i>函数的返回类型<i>为my_bool</i> ，实际上是<i>char</i> 。 结果，将<i>int</i>强制转换为<i>char</i> ，其中丢弃高位。 这导致这样的事实，即在256种情况中，大约1种情况下，只要知道用户名，就可以使用任何密码进行连接。 <br><br> 同样，即使在编写代码阶段，此CWE错误也可以消除，并防止变成CVE。 例如，PVS-Studio静态分析器生成以下警告： <a href="https://cwe.mitre.org/data/definitions/197.html">CWE-197</a> （ <a href="https://www.viva64.com/ru/w/v642/">V642</a> ）：数值截断错误。 <br><br> 在继续该主题时，我建议看一下文章“ <a href="https://www.viva64.com/ru/b/0514/">PVS-Studio如何帮助寻找漏洞？</a> ”。 <br><br><h2> 结论 </h2><br>  0天漏洞-无法保证不受保护的事物。 但是它们发生的可能性可以大大降低。 为此，可以使用专用的SAST解​​决方案，例如PVS-Studio。 如果您的项目检测到可以归为CWE的错误，则应注意并修复它们。 尽管事实上只有少数CWE会通过消除CWE错误来填充CVE列表，但您仍可以保护应用程序免受许多潜在威胁的侵害。 <br><br><h2> 网站连结 </h2><br><ol><li>  <a href="https://www.viva64.com/ru/pvs-studio-download/">下载并尝试PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0592/">PVS-Studio代码分析器中用于搜索错误和潜在漏洞的技术</a> </li><li>  <a href="https://www.viva64.com/ru/cwe/">根据常见弱点枚举（CWE）的PVS-Studio警告分类</a> </li><li>  <a href="https://www.viva64.com/ru/cert/">根据SEI CERT编码标准的PVS-Studio警告分类</a> </li></ol><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477838/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Ekaterina Nikiforova。  <a href="https://habr.com/en/company/pvs-studio/blog/477838/">PVS-Studio静态分析器作为防止零日漏洞的工具</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477840/">https://habr.com/ru/post/zh-CN477840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477824/index.html">让我们活到星期一或如何在黑色星期五生存</a></li>
<li><a href="../zh-CN477826/index.html">V2X技术概述和比较</a></li>
<li><a href="../zh-CN477832/index.html">如何与Z世代相处</a></li>
<li><a href="../zh-CN477834/index.html">构建流分析系统的原则</a></li>
<li><a href="../zh-CN477838/index.html">PVS-Studio静态分析仪作为防止零日漏洞的工具</a></li>
<li><a href="../zh-CN477842/index.html">Gennady Zelenko和Sergey Popov的故事-苏联的技术普及者</a></li>
<li><a href="../zh-CN477844/index.html">使用SAP Data Intelligence从思想到机器学习的实际应用的5个步骤</a></li>
<li><a href="../zh-CN477848/index.html">大心脏的小秘密：历史上的第一个蓝鲸心电图</a></li>
<li><a href="../zh-CN477850/index.html">React Native-解决所有问题的灵丹妙药吗？ 我们如何为Profi.ru选择跨平台工具</a></li>
<li><a href="../zh-CN477852/index.html">无毒伪善</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>