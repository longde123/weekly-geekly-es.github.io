<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌖 🤩 🎅 Namecoin区块链研究如何预测RTM网络攻击 🚔 🗻 🛩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Namecoin区块链是作为传统DNS注册服务商的替代产品而创建的，受到了审查制度和强制性域名没收的保护。 在过去的几年中，Dimnie，Shifu，RTM和Gandcrab等僵尸网络运营商已开始使用它来管理C＆C服务器的地址。 

 一方面，区块链的分散性和稳定性阻止研究人员和提供者删除此类域或控...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Namecoin区块链研究如何预测RTM网络攻击</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/460857/"><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  Namecoin区块链是作为传统DNS注册服务商的替代产品而创建的，受到了审查制度和强制性域名没收的保护。 在过去的几年中，Dimnie，Shifu，RTM和Gandcrab等僵尸网络运营商已开始使用它来管理C＆C服务器的地址。 <br><br> 一方面，区块链的分散性和稳定性阻止研究人员和提供者删除此类域或控制它们。 另一方面，基于区块链的基础架构具有体系结构功能：网络中的所有更改都是公开可用的，可用于研究和跟踪攻击者的行为。 <br><br> 本文介绍了用于在Namecoin中映射僵尸网络并进一步跟踪它们以提取新IOC的方法。 使用所描述的方法，可以编译上述僵尸网络使用的资产清单（请参阅附录）。 <br><a name="habracut"></a><br><h2> 抒情离题 </h2><br> 改变互联网的发明通常不仅解决社会问题，而且解决的技术问题也不多。 正是这些技术和服务使社区能够从侧面看一些似乎不可动摇的公理，重新思考它们，从头开始重新创建，只留下一个主意，并减少了多年来积累的传统惯例和限制。 区块链和比特币，托尔，维基百科-每个人成功的背后都是一小群热情的发烧友，他们真诚地相信他们正在使社会变得更好。 <br><br>  las，其他人经常追随他们-脱离互联网先驱者的奇怪理想，但更加实用。 他们找到<i>了</i>技术<i>的替代</i>应用程序，创作者没有想到（或不想考虑）。 这种替代应用程序处于允许的边界（并且更经常地隐藏在国外），通常在没有媒体帮助的情况下，对于大多数应用程序来说，它变成了<i>隐含的默认值</i> ，甚至是<i>唯一的</i> <i>默认值</i> 。 <br><br> 技术作为一种思想的等效以及使用最多的讨论方法可能导致社会排斥技术本身。 由于将其使用定为刑事犯罪，可以将不成熟的服务减少到边缘文化的水平或完全销毁。 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Napster</a>发生在很久以前，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BitTorrent</a>和Tor发生在不久之前，现在比特币正在发生这种情况。 <br><br> 这还不是这项工作的英雄-Namecoin。  Namecoin是一个旨在存储任意键/值对的区块链，其中最著名的是去中心化，耐审查性的DNS名称注册系统Dot-Bit。 <br><br> 在RTM僵尸网络管理小组开始使用Dot-Bit管理其C＆C服务器之后，我们对Namecoin的兴趣增加了。 在某种程度上，我们想知道-在新的C＆C服务器在Dot-Bit中注册后是否可以立即检测到它们？ 而且，如果众所周知的域的更新没有问题，那么一种方法的开发就会突然成为一项激动人心的研究任务，该方法可以使人们检测到新域与感兴趣的人之间的联系，这是一项令人激动的研究任务。 <br><br> 通常，Namecoin的研究和Dot-Bit折衷指标的收集是较早进行的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kevin Perlow</a>认为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a>最详尽。 他是第一个提请注意从Namecoin提取数据的基本可能性的人，并描述了几种启发式技术，这些技术使专家可以查找特征与特定组中知名C＆C服务器相似的域。 <br><br> 本研究中提出的方法与Kevin描述的专家索引和数据透视技术有几个显着差异。 我们开发的用于确定域所有者的启发式规则是从区块链的运作原理以及其中的交易形成原理衍生而来的，除了一般性描述外，还以严格的逻辑公式表示。 连同对旁路算法的正式描述，这使您可以自动执行IOC搜索，从而大大提高了调查的有效性。 此外，开发的算法不仅可以帮助查找研究小组曾经使用的其他名称，还可以让您跟踪由同一个人控制的新域的创建。 <br><br> 所有工作分为三章。 第一章介绍了比特币的基础知识，其代码被用作创建Namecoin的平台。  Namecoin继承了比特币中定义的许多实体，关系及其实现。 他们的理解对于进一步讨论至关重要。 <br><br> 第二章直接讨论Namecoin及其主要应用程序-Dot-Bit。 <br><br> 第三章描述了从Namecoin提取数据的建议方法，并给出了对区块链绕过算法和用于建立域之间关系的启发式规则的正式描述。 <br><br> 附录包含使用上述方法为某些僵尸网络收集的IOC，以及将帮助希望继续从事此主题研究的研究人员的参考资料和存储库列表。 <br><br><h2> 比特币201 </h2><br> 本节中的大多数信息是从Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Pavlov_dog</a> Potekhin的系列文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简而言之的比特币”中</a>收集的。 对于说俄语的读者来说，我们认为该资源是最全面，最深入的公开资料，但令人惊讶的是它易于阅读。 对比特币内部设备感兴趣的研究人员，我们敦促不要将自己限于本节给出的摘录，而应使自己熟悉本文的全文，可在应用程序中通过引用获得这些文章的全文。 下面提供的其余信息足以理解算法的描述以及在上一章中给出的用于查找Namecoin中地址之间关系的启发式规则。 <br><br> 尽管习惯上以区块和连接区块链的密码学开始有关区块链的故事，但我们将从交易开始。 <br><br><h3> 交易额 </h3><br> 如您所知，最接近比特币的类似物是一本账簿，其中记录了所有硬币交易。 但是，很奇怪的是，在比特币中，没有格式为<code>&lt;, &gt;</code>通用表，就像没有总会计师会编辑该表一样。 <br><br> 取而代之的是使用非常臭名昭著的区块链，也就是说，通常存储所有交易。 为简单起见，我们可以假定这些是以下形式的消息： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">&gt;</span></span> sent <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">amount</span></span></span><span class="hljs-tag">&gt;</span></span> BTC to <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 因此，如果您遍历整个区块链，则可以计算“属于”特定地址的硬币数量。 <br><br><h4> 输入和输出 </h4><br> 比特币网络上的实际交易比上述交易要复杂一些。 这是一个结构，其主要组成部分是输入和输出。 <br><br> 输入是您“引用”的交易。 想象一下，一次有三笔交易发送到您的地址X： <br><br><pre> <code class="json hljs">TXN_ID: <span class="hljs-number"><span class="hljs-number">123456</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">40</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">645379</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">10</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">888888</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">100</span></span> BTC</code> </pre> <br> 例如，如果您需要花费<code>45 BTC</code> ，则可以参考事务<code>888888</code>或一次参考两个事务： <code>123456</code>和<code>645379</code> 。 <br><br> 输出-字面意思是“输出”。 我们可以假设这些是交易将导致硬币“发送”到的“地址”。 也可以有几个出口；每个出口都有自己的数量。 <br><br> 在下面的图片中， <code>C</code>了一个新的事务<code>C</code> ，它引用两个输出<code>A</code>和<code>B</code> 结果，交易在输入处具有<code>0.008 BTC</code> ，然后将其分为两个输出<code>0.001 BTC</code>发送至第一个地址， <code>0.006 BTC</code>发送至第二个地址。 <br><br><img src="https://habrastorage.org/webt/hc/jj/-v/hcjj-vgrvls-t0qv4alrdutq1mm.png" alt="图片"><br><br> 一次指定多个输出的能力是非常重要的功能，因为<b>事务输出只能一次使用，并且只能整体使用</b> 。 如果您有一个<code>10 BTC</code>的传入交易，并且需要花掉8 <code>10 BTC</code> ，则只需创建一个输入和两个输出的交易：卖方<code>8 BTC</code> ，卖方<code>2 BTC</code> 。 如果您创建一个交易，其中输出的总和小于输入的总和（如图所示），则差额将发送到在区块中编写交易的矿工的地址。 <br><br><h2> 手续费 </h2><br> 投入总额与产出总额之间的差额称为“ <code>transaction fee</code> ”，即<code>transaction fee</code> 。 对于矿工来说，这是第二重要的收入来源，将交易包含在区块链中所需的时间取决于它。 这是由于以下事实：每个矿工都有一定数量的未验证交易，这些交易声称属于该区块中，并且通常，该矿工只是将它们按降序排序，从而使他们的利润最大化。 因此，佣金越高，您排队的人数就越高，付款就越快。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">协议</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正式规范中</a>描述了交易的一般视图，此处给出了最常见的特殊情况之一。 <br><br><img src="https://habrastorage.org/webt/sy/s-/g1/sys-g1dafvutkmxwetsud1urhng.png"><br><br>  <code>previous output hash</code> -我们引用的交易的标识符（哈希）。  <code>previous output index</code> -由于我们不需要引用事务本身，而是引用其输出之一，因此在此参数中，我们指示我们对哪个特定输出感兴趣。 编号从头开始。  <code>1/100000000</code>发送到出口的中本聪（ <code>1/100000000</code> BTC）数量。 它以小尾数形式记录，即<code>62 64 01 00 00 00 00 00</code>它是<code>0x016462</code>或<code>0.00091234 BTC</code> 。 <br><br> 实际上，很少使用<code>block lock time</code>和<code>sequence</code>参数。 我们对它们不感兴趣，因此我们将省略对它们目的的描述。 <br><br> 但是，在标题中带有单词<code>script</code>的参数上，我们会更详细地介绍。 <br><br><h4> 剧本 </h4><br> 比特币网络具有一种基于带有公开密钥的加密算法的机制，该机制允许您创建一个系统，在该系统中，只有密钥所有者才能使用与从该密钥获得的地址相关联的硬币。 我们将弄清楚如何在后台执行此操作。 <br><br> 首先，在比特币内部有一种称为<code>Script</code>的简单堆栈式编程语言。 这是最简单的脚本程序： <br><br><pre> <code class="xml hljs">2 3 OP_ADD 5 OP_EQUAL</code> </pre> <br> 每个指令称为<code>opcode</code> ，总共约80条，下图显示了以上程序的执行过程。 <br><br><img src="https://habrastorage.org/webt/du/p0/a9/dup0a971icbk3mhhz1k7vfsipg0.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/6k/pexz6k4icaot60gal2hc7y_iijk.png"><br><br><img src="https://habrastorage.org/webt/ie/nr/sg/ienrsgzd8tb5ncdwaxvvpzzdfku.png"><br><br><img src="https://habrastorage.org/webt/n8/zy/ve/n8zyvevbelp1wm7za8aksy-kcpi.png"><br><br><img src="https://habrastorage.org/webt/gx/aw/v_/gxawv_arrvb86zydou0zm22qhi0.png"><br><br> 在比特币<code>Script</code>用于设置一个条件，在该条件下可以花费输出，并能够确认满足条件。 条件（ <code>locking script</code> ）存储在每个出口的<code>scriptPubKey</code>字段中的事务中。 在每个输入的<code>scriptSig</code>字段中写入满足条件的确认（ <code>unlocking script</code> ）。 <br><br> 要检查使用输出的权限，您需要连接<code>unlocking script</code> + <code>locking script</code>并整体运行生成的程序。 如果执行后， <code>TRUE</code>保留在堆栈的顶部，则该事务有效。 <br><br><a name="P2PKH"></a><br><h4> 支付给公钥哈希（P2PKH） </h4><br>  <code>P2PKH</code>脚本用于大多数事务中，因此您应该了解它的工作方式。 这是它的一般视图： <br><br><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br> 自从比特币问世以来，该脚本就广为人知，它执行本章开头提到的任务-确保只有密钥所有者才能使用与从该密钥获得的地址相关的硬币。 <br><br> 这个想法是这样的：让您的朋友<code>B</code>拥有一对密钥<code>P</code> （私有）和<code>K</code> （公开）。 他使用哈希函数，从公钥获取地址<code>A</code> ，然后将该地址告知您。 接下来，您向地址<code>A</code>发送例如<code>1 BTC</code> ，并在<code>locking script</code>字段中输入以下内容： <br><br><blockquote> 只有拥有地址<code>A</code>私钥<code>A</code>才能进行此交易。 作为证明，首先在<code>unlocking script</code>输入公钥<code>K</code> ，其次使用私钥<code>P</code>交易签名<code>P</code> <br></blockquote><br> 当<code>B</code>决定使用您的交易作为输入时，他将创建自己的交易（例如<code>0.5 BTC</code> ，并且在<code>unlocking script</code>字段<code>unlocking script</code>使用私钥<code>P</code> - <code>sig</code>和公钥K- <code>PubK</code>交易<code>sig</code> 。 <br><br> 这是组合程序的执行过程： <br><br><img src="https://habrastorage.org/webt/et/zx/tw/etzxtwxr3qihzwza6e43rrymdcs.png"><br><br><img src="https://habrastorage.org/webt/yj/bs/1n/yjbs1nuol2e6ut1rp_p9iifi9z4.png"><br><br><img src="https://habrastorage.org/webt/ia/eo/kb/iaeokbdrdznakoutfhiuu2m53xu.png"><br><br><img src="https://habrastorage.org/webt/ix/zh/v2/ixzhv2l0_qhjxgn55tjung8tyng.png"><br><br><img src="https://habrastorage.org/webt/3f/ah/zf/3fahzfikukod-rbz-29tufqlry8.png"><br><br><img src="https://habrastorage.org/webt/71/gf/2h/71gf2hcsfwo7eqtvmmmmdebz0pw.png"><br><br><img src="https://habrastorage.org/webt/yk/f_/b7/ykf_b7fyo6hplbhax7wolaukqrk.png"><br><br><h2> 区块和区块链 </h2><br> 如果整个区块链都是一本书，那么各个块可以表示为记录交易的页面。 每个块都“引用”上一个块，依此类推，直到第一个块（ <code>genesis block</code> ）为止。 这就是创造区块链这种不可变性的功能的原因。 您无法采取并更改<code>#123</code>区块，以致没人注意到：区块链的设计方式是，它需要在<code>#124</code>区块，然后是<code>#125</code>区块等最顶层进行更改。 <br><br> 块结构如下所示： <br><br><img src="https://habrastorage.org/webt/bs/kp/3d/bskp3dzxovwwy4zx-s-pxzromgu.png"><br><br> 前六个参数（ <code>txn_count</code>和<code>txns</code>以外的所有参数）构成块的标题。 头哈希称为块哈希； 事务本身并不直接参与哈希。  <code>merkle_root</code>负责其不变性-如果简化，则表示该块中所有事务的哈希。 您可以在此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接上</a>阅读有关构造Merkle树的算法的更多信息。 <br><br> 名词和位与块出现的过程直接相关-挖掘。 <br><br><h3> 挖矿 </h3><br> 挖矿是比特币的关键过程，包括创建新区块并同时追求两个目标。 首先是货币供应生产。 每次矿工创建一个新区块时，他都会得到N个币，然后在某个地方花费，以此奖励他，从而将新资金投入网络。 <br><br> 第二个也是更重要的目标是控制对网络规则的遵守。 是矿工在将脚本和交易输入包括在区块中之前对其进行检查。 <br><br> 那些希望更多地了解比特币财务基础的人可以为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>提供建议。 我不会过多关注挖掘的第一个方面，而是专注于第二个方面-检查交易并在网络上启动它们。 <br><br><h3> 工作证明 </h3><br> 让你成为一名矿工。 您有10个交易要包含在该区块中。 您检查这些事务的有效性，从中形成一个块，在<code>nonce</code>字段中指定0，然后考虑块哈希。 然后将<code>nonce</code>更改为1，再次计算哈希值。 <br><br> 您的任务是找到一个<code>nonce</code> ，以使块哈希（256位数字）小于预定数字<code>N</code> 只有通过蛮力<code>nonce</code>才能搜索到这样的哈希。 因此，您想要找到随机数的速度越快，您将需要的功率就越大。 <br><br> 数字<code>N</code>恰好是该参数（也称为<code>target</code> ），网络会根据矿工的总功率对其进行调整。 如果明天开始出现块，相对而言，每三分钟， <code>N</code>会减少，将需要更多时间搜索随机数，并且<code>block time</code>将再次增加到10分钟。 反之亦然。 <br><br> 这就是基于比特币和许多其他区块链的工作量证明算法的样子。 具有明显的简单性，它具有许多重要特征： <br><br><ul><li> 创建新块是一项计算困难的任务。 同时，检查块的正确性是一个简单且几乎是瞬时的操作。 </li><li> 整个网络需要10分钟才能计算出一个新块（平均）。 每个区块链的具体时间都不同，但是最重要的是平均时间是预先设置的。 而且，该时间不取决于网络参与者的数量。 即使有一天矿工数量将增加一百倍，该算法也会更改其参数，从而使查找<code>block time</code>变得更加困难， <code>block time</code>又回到指定时间附近。 <br><br> 如上所述，挖掘过程归结为找到小于称为<code>target</code>的数字的块哈希。 在块结构中，此数字写入位字段中。 例如，对于区块<code>#277316 target</code>是<code>1903a30c</code> 。 </li></ul><br> 如上所述，挖掘过程归结为找到小于称为<code>target</code>的数字的块哈希。 在块结构中，此数字写入<code>bits</code>字段中。 例如，对于区块<code>#277316</code> <code>target</code>是<code>1903a30c</code> 。 <br><br><pre> <code class="json hljs">$ bitcoin-cli getblock <span class="hljs-number"><span class="hljs-number">0000000000000001</span></span>b<span class="hljs-number"><span class="hljs-number">6</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span>a<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>b<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">5</span></span>e<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">6</span></span>db<span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>c<span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">8</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>ef<span class="hljs-number"><span class="hljs-number">2</span></span>d<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span>b<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>b<span class="hljs-number"><span class="hljs-number">2</span></span>cc<span class="hljs-number"><span class="hljs-number">7</span></span>bdc<span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"confirmations"</span></span> : <span class="hljs-number"><span class="hljs-number">35561</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span> : <span class="hljs-number"><span class="hljs-number">218629</span></span>, <span class="hljs-attr"><span class="hljs-attr">"height"</span></span> : <span class="hljs-number"><span class="hljs-number">277316</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"merkleroot"</span></span> : <span class="hljs-string"><span class="hljs-string">"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tx"</span></span> : [<span class="hljs-string"><span class="hljs-string">"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f"</span></span>, ...], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span> : <span class="hljs-number"><span class="hljs-number">1388185914</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nonce"</span></span> : <span class="hljs-number"><span class="hljs-number">924591752</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bits"</span></span> : <span class="hljs-string"><span class="hljs-string">"1903a30c"</span></span>, // &lt;--   <span class="hljs-attr"><span class="hljs-attr">"difficulty"</span></span> : <span class="hljs-number"><span class="hljs-number">1180923195.25802612</span></span>, <span class="hljs-attr"><span class="hljs-attr">"chainwork"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000000000000000000000000000000000934695e92aaf53afa1a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previousblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nextblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"</span></span> }</code> </pre> <br> 实际上，以<code>bits</code>一次写入了两个数字：第一个字节<code>0x19</code>是指数，其余三个字节<code>0x03a30c</code>是尾数。 要从<code>bits</code>获取<code>target</code> ，您需要使用以下公式： <br><br><pre> <code class="python hljs">target = mantissa * <span class="hljs-number"><span class="hljs-number">2</span></span>^(<span class="hljs-number"><span class="hljs-number">8</span></span> * (exponent - <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br> 但是通常在所有在线阻止注册中心（例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ：//namecha.in/-Namecoin阻止注册中心）中都指定了bits。 <br><br> 是的，足够的理论。 我们上面讨论的应用于比特币的所有内容均同样适用于Namecoin-除了很小的差异外，我们将在下一部分中进行讨论。 <br><br><h2> 名币 </h2><br>  <i>Namecoin</i>是基于比特币的算法和源代码的<i>区块</i>链，其主要思想是使用分布式事务注册表方案来管理域名系统，这是传统DNS的类似物。 <br><br>  Namecoin复制主要的比特币方法（工作量证明，10分钟的块生成间隔）和数据格式，除了少量添加之外，我们将在后面讨论。 <br><br>  Namecoin域的后缀为.bit。 该区域不是由IANA分配的，也没有分配给<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特殊用途域</a>的列表。 常规DNS服务器通常会响应此类NXDOMAIN请求。 但是，存在从DNS到Namecoin的网关（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenNIC</a> ），具有Namecoin支持的公共代理，浏览器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插件</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个开源项目</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目</a>可让您启动具有Namecoin支持的自己的DNS服务器。 <br><br> 为了管理一个名称为<code>facebook.bit</code>的域名，注册<code>d/facebook</code>密钥<code>d/facebook</code>域名的Namecoin使用<code>d/facebook</code>前缀）并确定其值就足够了。  JSON格式用于设置值。 将域解析设置为IP地址<code>1.2.3.4</code>的条目如下所示： <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"ip"</span></span>: [<span class="hljs-string"><span class="hljs-string">"1.2.3.4"</span></span>]}</code> </pre> <br>  Namecoin按照<i>先到先得的</i>原则分配名称。 即使对于马克·扎克伯格本人来说，从所有者那里获取<code>facebook.bit</code>域在密码上也是不可能的。 <br><br> 实际上，没有任何限制将Namecoin的使用限制为仅管理DNS名称捆绑-IP地址。  Namecoin可用作（并用作）分布式表，以将任意键映射到值。 但是我们将专注于其使用场景，在该场景中，它代表了区块链上的替代DNS。 <br><br><h2> 域管理 </h2><br>  Namecoin使用事务存储域记录。 即，包含程序的<code>scriptPubKey</code>字段是使用事务出口的条件，我们在上一章中花了很多时间。 为了管理记录，Namecoin引入了三个新的运算符（更准确地说，是重新定义了现有的运算符）： <br><br><ul><li>  NAME_NEW </li><li>  NAME_FIRSTUPDATE </li><li>  NAME_UPDATE </li></ul><br> 从名称中可以清楚看出它们的含义，但是我们将分析它们的用途和格式。 <br><br> 您可能会注意到缺少域删除或无效运算符。 为了清除注册表中未使用的名称，网络中内置了一种机制，该机制会自动释放36,000块（约250天）内未更新的名称。 <br><br><h3>  NAME_NEW </h3><br> 第一步是宣布打算在网络上注册新名称。 为此，只需创建一个重量至少为<code>0.01 NMC</code>的特殊硬币（输出），其<code>output script</code>将如下所示： <br><br><pre> <code class="xml hljs">OP_NAMENEW <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">20</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">byte</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hash</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 为了演示，我将使用Stephen Morse进行的交易来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明他的文章</a> 。 <br><br> 因此，如果我们要宣布名称<code>d/stephenmorse</code>的注册，那么我们需要执行以下操作： <br><br><img src="https://habrastorage.org/webt/q9/br/b8/q9brb8jrft9fyzc1vc2ph0ssade.png"><br><br> 查看结果交易，您会发现两个有趣的事实。 首先，尽管事实上<code>output script</code>用Namecoin表示的，但从原始比特币的角度来看，它仍然有效。  Namecoin的创建者已经为他们的操作成功地选择了代码，以至于在比特币中，它们对应于基本上等同于写入常量堆栈的操作。  <code>NAME_NEW (0x51)</code>代码对应于<code>OP_1</code> ，后者<code>OP_1</code>堆栈1。类似的故事分别是<code>NAME_FIRSTUPDATE</code> （ <code>0x52</code>或<code>OP_2</code>放入2）和<code>NAME_UPDATE</code> （ <code>0x53</code>或<code>OP_3</code>放入3）。 因此，脚本的前两个步骤仅将两个值放在堆栈上。 下一个操作<code>OP_2DROP</code>将它们从堆栈中删除，以便进一步的<code>P2PKH</code> “从头开始”工作。 因此，尽管重新定义了某些操作，我们在比特币一章中介绍的所有脚本技巧也适用于Namecoin。 <br><br> 其次，打开特殊硬币和找零的钥匙是不同的。 尽管从技术上讲，没有什么可以阻止您重复使用相同的密钥，但是通常的做法是为每张收据生成一个新的密钥。 这样做使识别交易之间的相关性变得困难，并增加了网络中的匿名性。 <br><br> 乍看之下，与常识相反，似乎无法立即采用并注册一个名称以及一个IP地址似乎很奇怪。 这样做是为了让没人看到您要注册的名称（然后将其转售给您），因此没有人可以截获该名称。 <br><br> 例如，矿工分析网络中未确认的交易（尚未包含在任何区块中），可以创建自己的交易来注册同一域，并将其（而不是您的）包含在其区块中。 要实施此攻击，甚至不必挖掘您的块。 只需大笔费用就可以将您的交易放在网络上。 因此， <code>NAME_FIRSTUPDATE</code>两个单独的操作<code>NAME_NEW</code>和<code>NAME_FIRSTUPDATE</code> ，第二个操作只能由执行第一个操作的人执行，并且只能在<code>NAME_NEW</code>进入任何块之后<code>NAME_NEW</code> 。 <br><br> 实际上，此限制甚至更为严格： <code>NAME_FIRSTUPDATE</code>可能不早于<code>NAME_NEW</code> （大约2小时）之后的12个块。 要了解为什么此限制中的障碍不是1，不是2，不是3，而是具体为12，我们将不得不从主要故事中退后一步，弄清楚什么是<code>fork</code>和<code>51% attack</code> 。 <br><br><div class="spoiler">  <b class="spoiler_title">前叉</b> <div class="spoiler_text"> 想象一下，矿工正在寻找<code>#123456</code>区块。 大约在同一时间，他被两名矿工独立发现，其中一名住在澳大利亚，另一名住在美国。 他们每个人都开始在网络上分散其区块的版本，结果发现世界的一半拥有一个区块链，而另一半拥有另一个。 <br><br><img src="https://habrastorage.org/webt/ov/a1/yq/ova1yqiulayufd1o7z6vbmwpb0e.png"><br><br> 这可能吗？ 是的，有可能。 而且，这种情况经常发生。 在这种情况下，每个节点将继续遵守其自己的区块链版本，直到有人找到下一个区块为止。 假设新块继续绿色分支，如下图所示。 在这种情况下，那些遵循红色版本的节点会自动同步绿色版本的节点，因为该规则适用于比特币（因此适用于Namecoin）：区块链的最长版本为真。 红色版本的区块链将被简单地忘记，并为发现它的人提供奖励。 <br><br><img src="https://habrastorage.org/webt/br/le/xq/brlexqeynpgyq5qjq6u0knjla5q.png"><br><br> 当然，从理论上讲，在第二步中，情况可以重演，同时使用紫色，他们会发现另一种情况，它将延续区块链的红色版本。 第三，依此类推。 但是，即使第一个分叉的可能性很小，第二个分叉的可能性更低，依此类推。 比特币历史上最长的叉子只有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">四个街区</a> 。 因此，在某个时候，分支机构之一仍然会突破，整个网络都将继续使用它。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">51％攻击</b> <div class="spoiler_text"> 区块链中最长的链占主导地位的事实是基于名称为51％的攻击。 <br><br> 假设您是骗子，并且在商店中以<code>1000 BTC</code>购买商品。 您同意卖方的意见，并寄给他钱。 卖方检查了区块链，发现确实是这样的交易，通过了所有支票甚至进入了某个区块，例如<code>#123</code> 。 在那之后，卖方转到邮件并向您发送货物。 <br><br> 此时，您从区块<code>#122</code>开始打开采矿场并开始采矿。 如果您有足够的能力，那么您可以超越网络的其余部分并以最快的速度计数以阻止<code>#124</code> ，之后整个世界都将切换到您的区块链版本。 同时，您不会在任何区块中包含<code>1000 BTC</code>的交易，这意味着它将永远被遗忘，就好像从未被遗忘一样。          . <br><br>         ,          .      .   11   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  , ,     6  ,      0,1%    ,    10% .        ,         . ,  Namecoin      ,     20%  . <br><br>       . ,        .    ,  <code>NAME_NEW</code> ,  12 ,       <code>NAME_FIRSTUPDATE</code> . <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_FIRSTUPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该操作的目的</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是发布在中宣布的名称</font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并为其指定一个值。</font><font style="vertical-align: inherit;">为此，我需要在网络上启动事务，其输入是我在输出处生成的非常特殊的硬币</font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了确认使用它的权利，我</font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全按照我们在关于章节中研究的方案，</font><font style="vertical-align: inherit;">在输入脚本中提供了我的公钥和</font><font style="vertical-align: inherit;">由私钥对</font><font style="vertical-align: inherit;">进行的交易的签名</font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易的结果之一将是新的特殊硬币称重，就像上一个一样</font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">她的输出脚本应如下所示：</font></font><br><br><pre> <code class="xml hljs">OP_NAME_FIRSTUPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Salt</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> <code>Salt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><code>0xd5eeb22ee8117f57</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在为脚本准备的第一阶段中创建</font><font style="vertical-align: inherit;">的非常随机的数字</font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是</font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六进制</font></font><code>0x642f7374657068656e6d6f727365</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应包含一个代表规则的解析数组，通过该规则解析名称。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能包含的密钥和规则的完整列表</font><font style="vertical-align: inherit;">。第一近似是区域文件的类似物。上面的链接显示了Namecoin实体到熟悉的DNS实体的映射。其中最受欢迎的是ip（一个更高的示例）和ns（我们现在使用）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了表明该域的NS服务器，我们将</font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Value中添加一个值</font></font><code>{“ns”:[“1.2.3.4”]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但当然要使用十六进制- </font></font><code>0x7b226e73223a5b22312e322e332e34225d7d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和上次一样，用关闭硬币</font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在他的示例中，斯蒂芬故意在步骤NAME_NEW上创建了重量不完全为</font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但具有保证金</font><font style="vertical-align: inherit;">的硬币</font><font style="vertical-align: inherit;">，以便在下一步中，此保证金足以支付给矿工的佣金。</font><font style="vertical-align: inherit;">在一般情况下，交易将有一个额外的入口以确保佣金-还有一个额外的出口以进行交付。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将所有信息收集到一个事务中，然后</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其放入网络中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/nn/rt/cd/nnrtcdedqwwblvhs_wsdawyivpg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当事务进入该块时，主机将在其表中更新密钥</font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font><font style="vertical-align: inherit;">的值</font></font><code>{“ns”:[“1.2.3.4”]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，所有支持Namecoin的浏览器都将</font></font><code>stephenmorse.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过位于的DNS服务器</font><font style="vertical-align: inherit;">将域</font><font style="vertical-align: inherit;">及其子域</font><font style="vertical-align: inherit;">解析</font><font style="vertical-align: inherit;">为IP地址</font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_UPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在上一节末尾提到的带有键及其含义的“表”实际上称为</font></font><code>UTXO set (unspent transaction output)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于防止网络重复使用资金至关重要，因此在将交易添加到区块之前，矿工会检查是否使用了交易中先前指定的输入。为了加快此操作，所有未使用的输出都存储在单独的数据结构中。该结构在网络级别上不存在，但是由每个节点本地计算和存储。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成交易后</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将</font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附有钥匙值</font><font style="vertical-align: inherit;">的砝码输出到我</font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的桌子上</font></font><code>UTXO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果此输出未用于36,000个块（超过8个月，平均每个块10分钟），那么它将被视为无效，并且相应名称为免费。</font><font style="vertical-align: inherit;">在网络开始时已明确定义</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了36,000块的周期（以及中的特殊硬币的最小值</font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），并且未更改。为了扩展名称的注册以及对记录的任何更改或将其转让给另一所有者，将使用交易</font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，形成这种交易的规则与上述规则没有区别。交易的输入应为交易中获得的硬币的输出</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">需要额外的输入以确保调试。</font><font style="vertical-align: inherit;">在交易的两个输出中，一个是新硬币，其名称具有更新的值，第二个旨在转移佣金中的更改。</font><font style="vertical-align: inherit;">硬币的输出脚本格式为：</font></font><br><br><pre> <code class="xml hljs">OP_NAME_UPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与前面的情况一样，</font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-带有值的JSON（均为十六进制）。</font><font style="vertical-align: inherit;">使用P2PKH关闭出口，并将事务</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放入网络</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/ny/2t/vq/ny2tvqbgf2fhkaiebkx2b9_fdkc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总的来说，这几乎是我想讲述的有关Namecoin中名称管理的所有内容。</font><font style="vertical-align: inherit;">剩下的就是对拥有域名的成本说几句话。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 费用 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们计算一下</font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加密货币</font><font style="vertical-align: inherit;">中的名称内容</font><font style="vertical-align: inherit;">（基于Namecoin运行的DNS区域.bit的名称）的成本，并将数字转换为法定货币，可以与“常规” DNS域的成本进行比较。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，从上一节可以看出，对于交易而言，</font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域所有者</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">成本将是</font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个将附加区域的硬币，再加上矿工的佣金。对于交易，</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将以旧硬币为代价创建新硬币，此外，所有者仅支付佣金。大约8个月后，所有者将必须完成交易</font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以保留注册名称。这是第一年年底所需的成本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关Namecoin的大多数文章（包括</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Stephen Morse</font></a><font style="vertical-align: inherit;">先前引用的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）基于该网络成立头几年的数据，并声称该矿工的佣金为0.005 NMC。但此后，该委员会的中值逐渐下降，并在2019年初</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约0.0003 NMC。 NMC CSHA率对美元，相反，已经经历了几起几回的2015年水平</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">达</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约每1 NMC 0.7 $。很容易计算出，第一年.bit区域中的域的所有者将花费0.0109 NMC或0.00763美元。也许人们会更容易记住这一数额的近似货币（50戈比）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，这是与购买名称以供将来使用或抢注的方案所匹配的下限。上限呢？由于来自更新该区域的每笔交易的输入应该是来自先前区块之一的硬币，因此名称更新频率的理论最大值等于新区块出现的频率。回想一下该值的平均值是在网络启动时设置的，大约是10分钟，可以估计维护域成本的上限为15.7744 NMC或略高于$ 11。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，即使在这样一种奇妙的情况下，花钱在Namecoin中使用名称，也大约等于在最受欢迎的.com区域中拥有常规域名的第一年。如果我们将比较现实的情况与平均每天进行一次更新进行比较，则.bit区域中的名称每年将花费约8美分，这比传统DNS中最优惠的报价（不低于$ 1）便宜得多。在域名的短期使用（从几个小时到一个月）的情况下，使用Namecoin的区别已经是两个数量级。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 考虑到服务的财务吸引力以及域名所有者的匿名性，包括缺乏对普通DNS的传统“资金追踪”，很明显，为什么Namecoin已成为服务所有者的流行网络，尤其是在僵尸网络中，断开或阻止的风险增加了。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 域名币中的僵尸网络 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确实，僵尸网络运营商开始使用匿名</font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来保护其C＆C服务器</font><font style="vertical-align: inherit;">这一事实</font><font style="vertical-align: inherit;">不足为奇。另一件事更有趣-.bit僵尸网络保持活动状态多长时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“常规” DNS区域中注册的C＆C域迟早会从所有者中撤回，这迫使运营商为注册新名称和在网络上使用新的管理服务器启动新的僵尸程序集付费。根本不可能删除.bit区域中的域，从而使僵尸网络的生存期延长了几个数量级。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font><code>pationare.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2016年12月注册</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">域名</font><font style="vertical-align: inherit;">为例</font><font style="vertical-align: inherit;">。它用于控制僵尸网络</font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（分发基于著名的ZeuS构建的银行木马）。发行活动</font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与漏洞利用程序包RIG的使用相关联，并在</font><font style="vertical-align: inherit;">2016年底和2017年上半年</font><font style="vertical-align: inherit;">被各种研究人员（例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恶意软件-traffic-analysis.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）进行了</font><font style="vertical-align: inherit;">详细描述</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以假定该僵尸网络很久以前就已被破坏。但是，没有-僵尸网络的C＆C域及其网络在启动两年多之后仍处于活动状态。从下面的屏幕截图可以看出，最近一次更新是在2018年12月进行的。</font></font><br><br><img src="https://habrastorage.org/webt/9k/o9/5w/9ko95wbszt4g7fqntkxm0cnh34u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来很诱人，对吧？由于管理服务器的DNS名称保持不变，因此无需频繁更新漫游器代码并重新启动分发活动。保留IP地址后，仅保留更改主机的成本，但是也可以通过使用被入侵的Web服务器作为代理来降低这些成本，这些代理的外壳成本不到一美元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一方面，任何参与者都可以公开使用区块链中的所有交易。</font><font style="vertical-align: inherit;">正如我们在前几章中详细讨论的那样，Namecoin中的硬币不会消失而不会丢失，这意味着我们可以跟踪它们在地址之间的重新分配。</font><font style="vertical-align: inherit;">通过了解规则和限制，并考虑到Namecoin中进行了哪些交易，我们可以找到有意义的模式，在这种模式下，交易中涉及的某些地址的统一管理将变得显而易见。</font><font style="vertical-align: inherit;">在这种情况下，使用来自这些地址的硬币支付的域将具有一个共同的所有者-我们正在管理的组，该组控制僵尸网络。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将进一步发展这个想法。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 国际奥委会总征收计划 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们以RTM组的真实僵尸网络为例来描述一般搜索方案。我们将以此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">样本为</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">样本</font></a><font style="vertical-align: inherit;">被标识为</font></font><code>Win32/Spy.RTM.N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/9r/rx/tq/9rrxtqepv4ods_wcbibv-2hk9uk.png"><br><br><img src="https://habrastorage.org/webt/ps/by/dk/psbydk2cmnsifuf5cf8njpmnnvm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从上面的屏幕截图中可以看到，启动后它将尝试获取name的IP地址</font></font><code>stat-counter-4.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们</font><font style="vertical-align: inherit;">在Namecoin中</font><font style="vertical-align: inherit;">获得</font><font style="vertical-align: inherit;">有关该名称交易历史的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/ok/jj/aj/okjjajszmlcuj_8enwzkosbze6k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过单击指向操作NAME_NEW的链接来获得创建此域的交易的标识符。显然，该交易的输入地址（由其创建域）由我们感兴趣的组进行管理。他将最初的一组数据：</font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/-k/si/6n/-ksi6n9mz69t-tscu-cpyilewpa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据初始数据集，我们迭代遍历区块链，朝其增长方向（向上移动或向上移动）移动。在每个步骤的开始，我们都会获得一笔交易，在输入的某个硬币属于我们感兴趣的人。第一步，我们从初始数据集中检查交易，我们知道先验的输入硬币的所有者。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查交易是否符合启发式规则（我们将在下面公式化），该规则可确保交易结束时某个硬币（或多个硬币）与已知输入硬币属于同一个人。如果所讨论的交易满足一种或多种试探法，则这种指导性硬币将指示进一步运动的方向。花费指导性硬币的交易将是迭代的下一步。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在迭代的每个步骤中，我们都会补充参与交易的域列表以及这些域所解析到的IP地址列表。这些是妥协的历史标识符（IOC），可用于法医，以及识别战术和分组方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果所讨论的事务不满足任何试探法，则移动停止。这意味着我们不能确定地说该交易的任何输出是由我们感兴趣的人控制的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻止移动的另一种情况是输出地址缺少事务。我们会将这些地址保存在单独的未用硬币列表（UTXO）中。它们代表了整个研究的最大价值。由于我们确信这些地址是由我们感兴趣的人管理的，因此任何将来使用这些地址的交易都会生成一个新的，以前未知的IOC（域名或IP地址），该IOC尚未被分组使用。但是很有可能很快。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要绕过区块链，将其导出到数据库很方便。为此，您可以使用例如修改后的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rusty-blockparser实用程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，通过添加操作识别</font></font><code>NAME_*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，数据结构</font></font><code>Auxiliary Proof-of-Work</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和扩展导出格式</font><font style="vertical-align: inherit;">，我们在其中改进了对Namecoin的支持</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面显示了向上运动的Python伪代码。在下文中，假定区块链交易数据存储在MongoDB中。</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heuristic_result = upstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_outs: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_out <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_outs: known_addresses.add(guiding_out.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"in.id"</span></span>: guiding_out.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: upstream_movement(tx) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: utxo.add(guiding_out)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区块链绕过的第二部分是反对区块链增长的运动（向下运动或下游运动）。通常，向下移动算法与向上算法没有什么不同。移动始于原始数据集的事务。在每个步骤中，都会检查交易是否符合启发式规则（通常与向上移动的规则不同）。唯一的区别是，其成员资格被称为先验的硬币位于交易的出口处，并且启发式算法可确保同一个人在入口处拥有一个或多个硬币。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果当前交易不满足任何试探法，则向下运动也将停止。</font><font style="vertical-align: inherit;">与向上运动不同，我们不能在向导之间遇到未花费的硬币，并且在向下运动中退出递归的此选项将不起作用。</font><font style="vertical-align: inherit;">但是，与上升趋势一样，我们同时补充了名称列表和IP地址列表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向下移动的Python伪代码如下所示：</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heristic_result = downstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_ins: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_in <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_ins: known_addresses.add(guiding_in.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: guiding_in.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: downstream_movement(tx)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在考虑在沿区块链移动时将使用的启发式规则。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启发式规则 </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 共同的变化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们再次看一下事务，上面给出了其屏幕截图。</font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含用于创建新名称的资金</font><font style="vertical-align: inherit;">的地址将发送到交易输入</font><font style="vertical-align: inherit;">。对于交易</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在入口处将有两个地址-一个特殊的硬币从先前事务域和额外的资金来支付佣金的区域。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我将立即注意到，在交易方面，我们将讨论硬币和地址。尽管在某些作品中这些概念几乎被认为是等效的，但对我们而言，明确指出这些术语之间的区别非常重要，因为在研究过程中，我们将得出有关代币和地址的结论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说“硬币”，我们将表示交易产生的正余额。该硬币由生成该硬币的交易编号和出口索引标识。例如，上面考虑的交易输入处的硬币具有标识符</font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a:1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它被形成为交易的输出（索引为1）</font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像以前一样，特殊硬币将被称为面值为b的硬币</font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>locking script</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中包含带有域名的操作。我们在“域管理”部分中详细研究了此类代币的形成机制。我们将普通硬币称为任意面额的硬币，与域操作无关的硬币。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬币的主要特性是它们的不变性。任何硬币只能使用一次，并且只能全部使用。因此，在Namecoin网络上最多提及两次：创建一次，第二次花费。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说“地址”，我们是指一个标识符，该标识符唯一地标识可以打开锁定脚本的密钥对，其格式</font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以关闭位于交易输入或输出处的硬币。由于只有对应于该地址的密钥才能花费硬币，因此与地址最接近的现实世界是存放硬币（并从中花费硬币）的钱包。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管在Namecoin中地址通常也只使用两次，但并不需要接收和消费单个硬币。重用地址的事实将对我们将来有所帮助。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在比特币201一章中详细介绍了输入，输出和地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在交易的出口处形成了两个硬币。该地址</font></font><code>N2hgZoWaTKoJ7FPmLuytTow3XrCCfEj2ca</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绑定到</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">同一枚特殊硬币（称重为0.01 NMC）到达了</font><font style="vertical-align: inherit;">地址</font><font style="vertical-align: inherit;">。一个</font></font><code>NKMMLwyMw4nwGuke6vd3AuDBMP18FWRaF1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零钱</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">普通硬币被发送到</font><font style="vertical-align: inherit;">第二个地址</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是最常见的交易方案。当入口处有多个硬币时，仍然有选择，但是它们的共同特性是找零硬币总是完全相同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以猜测这样的事务对应于域信息的简单更新。使用属于一个人的一枚（很少是几枚）硬币进行更新付款。实际上，由于事务始终只有一位作者，因此它必须管理所有输入地址。没有这个，他将无法创建解锁脚本，这是使用该钱包中的硬币所必需的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，由于此操作的所有零钱都收集在一个硬币中，因此很明显，该硬币与入口处的硬币属于同一个人。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这项工作中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述了类似的比特币计划，</font><font style="vertical-align: inherit;">称为</font><font style="vertical-align: inherit;">比特币</font></font><code>one-time change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它反映了本地比特币应用程序进行交易的方法- </font></font><code>bitcoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>bitcoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一次（一次）被调用是因为这些应用程序的另一个功能。默认情况下，它们在创建的交易的输出处为硬币生成新的地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namecoin与比特币代码库一起，继承了这些应用程序的大部分代码，称为</font></font><code>namecoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>namecoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于普通硬币，我们可以安全地使用此启发式算法，而无需进行任何更改。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址重用以存储特殊硬币的统计数据表明，在大多数情况下，对于它们也遵守此规则。此类地址的重用非常少见。地址使用了不止一次，约占总数的6％；超过两倍-大约1％。基于Namecoin的目的，似乎合理的假设是，网络上大多数带有特殊硬币的交易都是简单的创建和更新操作，在此期间域所有者不会更改。因此，我们可以认为这种操作对应于将特殊硬币提取到新的先前未使用的地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们看一个带有特殊输出硬币重用地址的交易示例。为此，请进行RTM组的另一笔交易-</font></font><code>b3c7ce9ca3a689c6236b9d6df3c257c5fab6c3985187669ccf731ac42a127a11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">特殊硬币去往</font></font><br><br><img src="https://habrastorage.org/webt/em/d6/hx/emd6hxidz3xhgqny_f5e7ho5-04.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的地址</font></font><code>NDpWDEx1mBkUYywqxDTAZZeGCfUV4GkVE8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经在以前的交易中使用过。</font></font><br><br><img src="https://habrastorage.org/webt/ws/32/00/ws3200wv6hvjc1z63vt4p1hdivs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前所述，Namecoin本地客户端应用程序中的默认脚本不会导致地址重用。要将特殊硬币发送到现有地址，所有者将需要做出单独的，可选的努力，在交易形成阶段明确找出并指出退出地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么可能需要这样做？唯一提到手动指定退出地址的情况，我仅在有关</font><font style="vertical-align: inherit;">将域转让给另一个所有者</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说明中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遇到过</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/zv/8q/pe/zv8qpeblzvm4jogj-axkgmcgili.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们考虑有关交易退出时地址的进一步命运，则可以猜想是否成立。在下图中，此事务标记为亮绿色的里程碑。可以看出，</font></font><code>9e16f6be</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat-counter-4域上</font><font style="vertical-align: inherit;">的下一个交易</font><font style="vertical-align: inherit;">是使用货币地址进行的</font></font><code>NJ8xUePv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该货币地址</font><font style="vertical-align: inherit;">与“父”交易中</font><font style="vertical-align: inherit;">使用的地址</font><font style="vertical-align: inherit;">没有明确的联系。显然，该域已移交给另一个人的管理。</font></font><br><br><img src="https://habrastorage.org/webt/ue/ho/ea/uehoea2yau72ydjns-ujsixawkw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一般情况下，这可以是将域名出售给与所涉人员的活动无关的另一所有者，也可以是在一个人的帐户之间转移域名。</font><font style="vertical-align: inherit;">第二种选择是注册新域的简单性和低成本，以及组织和商标所有者对.bit区域中的域的注册缺乏明显的兴趣。</font><font style="vertical-align: inherit;">在恶意活动中发现，我们至少没有提出合理的动机来购买域名。</font><font style="vertical-align: inherit;">因此，我们认为，尽管有可能将域名转让给另一个人，但具有可重用地址以提取特殊硬币的交易表示资产重组是在一组控制的多个帐户之间进行的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们以启发式规则的形式制定上述论点，我们将其称为共同变化： </font></font><br><br><blockquote>         ,   ,       ,     . <br><br>          ,     ,    . <br><br>  ,    ,     . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图中显示了使用此规则的方案。灰色流-普通硬币，绿色-特殊硬币。指南将是交易结束后所有硬币的对面，我们通过该硬币到达该交易：所有输出均用于向上移动，所有输入均用于向下移动。</font></font><br><br><img src="https://habrastorage.org/webt/1a/bh/fo/1abhfo8tmu_v8xwuw_uk7j0mla4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们注意到这种启发式方法的几个特征。首先，双向：当我们知道入口的所有者时，它既适用于向上运动，当我们知道出口处的一个硬币的所有者时，适用于向下运动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，特殊硬币的可选可用性：尽管在不存在特殊交易的情况下，交易与更新域无关，但上面给出的有关常规硬币所有者的逻辑推理仍然有效。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用于测试事务是否符合通用更改规则的伪代码如下所示： </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = {<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: []} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tx.outs.money) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} addr = tx.outs.money[<span class="hljs-number"><span class="hljs-number">0</span></span>].address first_tx = namecoin.tx.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: addr}, sort=[(<span class="hljs-string"><span class="hljs-string">"block"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_tx.id != tx.id: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>] = tx.outs.all result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>] = tx.ins.all <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 共同支出 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面考虑的启发式方法除了具有双向性外，还具有另一个重要的特性。常见更改-启发式“无记忆”；验证结果仅由相关事务的特征确定，而不取决于其他启发式方法和累积数据的结果。对于遍历的第一次迭代来说，这种启发式对于数据集的初始填充是必不可少的。另一方面，很容易注意到其应用的局限性。例如，她将专注于包含两个或多个现金产出的交易。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为此类交易的示例，请考虑</font></font><code>db4ff4082f39d0a501508706e627f26aa92712d27b4f633ded59917d201cfae5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该交易与管理Dimnie僵尸网络的组的活动有关。</font></font><br><br><img src="https://habrastorage.org/webt/td/61/-c/td61-cbmmd7enx-0olfyjxrpcva.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过地址处理了这笔交易</font></font><code>My7Ap3nH5f4X6Us2KiUWisd77wRpMG1MDY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在先前的CC交易记录中用作登录地址。尽管他对被研究者的态度是毋庸置疑的事实，但我们不能对其他任何出入口说相同（也可以相反）。这可能是在组地址之间重新分配硬币，在这种情况下，所有地址均由我们感兴趣的人控制。还是从任何出售Namecoin代币的交易所的地址充值。或来自与所研究人员的活动无关的其他网络成员的转移。仅凭此交易的属性不可能得出确定的结论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑地址</font></font><code>N4XtLb7xpC4Zk72T8QcshKhTW17ZCyQ1j1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此交易的输入。</font><font style="vertical-align: inherit;">此地址先前已在CC交易输入时使用过（“较早”表示向下移动，意思是“未来”，“朝着区块链增长的方向”）</font></font><code>6bffc741eb66de074c09a380fb5e6bd13d4bd5205c36a76e3682674dba08461e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这使我们可以考虑将此地址由我们感兴趣的人来管理。</font><font style="vertical-align: inherit;">而且，由于已经证明，交易输入处所有硬币的密钥都是由一个人控制的（关于输出不能说），因此我们有理由相信所有其他输入也属于我们感兴趣的组。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发式公共支出的严格条件看起来非常简单：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果已知交易输入处的至少一个地址是由某个人控制的，则此交易输入处的所有其他地址都由同一人控制。</font><font style="vertical-align: inherit;">这些入口处的硬币属于同一个人。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，这种启发式仅对向下运动有意义。当朝着区块链增长的方向发展时，我们通过其中一种输入来参与正在研究的交易。在这种情况下，规则条件是自动满足的，但是没有说明事务的输出，也不允许您继续向上游移动。换句话说，这是一种单向启发式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得注意的是，这种启发式方法的第二个特点是，在此我们首先使用了由于检查以前的交易而积累的数据-由被调查者管理的地址列表。因此，如果没有任何不依赖于累积结果（例如共同变化）的主要启发式方法，则该次要启发式方法不能用于独立运动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用于测试交易是否符合通用支出规则的伪代码如下所示： </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_spending</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: tx.ins.all} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 已知地址 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在本节的框架中考虑的最后一种启发式方法是最简单的方法。</font><font style="vertical-align: inherit;">这是次要的双向启发式方法（因为它是双向的）可用于向上和向下移动。</font><font style="vertical-align: inherit;">向上运动的启发式已知地址的严格公式如下所示：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果已知交易的输入（输出）上的地址是由某个人控制的，则在该地址（从该地址花费）所接收的硬币属于同一个人。 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管启发式方法看起来像是坦率的真实性，但是此规则有助于查找硬币流中的分支和交叉点，并增加了与交易树的连接性。此外，它还可以使您不停止不属于其他启发式交易的交易。一个例子就是</font></font><code>7a35b9cb0a16b3eba92781be014555eaa4255bd17655bb00f2b3f42c3950ac69</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经提到的Dimnie僵尸网络</font><font style="vertical-align: inherit;">的交易</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/06/eg/as/06egasevdvty7quvjjvr0jrp6gy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在向上运动达到它之后，我们将无法借助共同的变化而前进，因为产出不止是一枚普通硬币。从交易的角度来看，我们无法说出输出中有多少硬币与输入中的硬币属于同一个人-要么全都一个，要么全无。由于地址的事实，使用已知的地址启发式方法可以使您继续前进</font></font><code>MwMdTb8WQvoRW9jEW5dHn9SkkCJTRn31wQ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参与了CC交易</font></font><code>cf7ac8986f9855246c6cf26df9a24aa5645cb9258bf787e034a33e75101ae1fc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该交易</font><font style="vertical-align: inherit;">创造了</font><font style="vertical-align: inherit;">在上游运动中较早遇到</font><font style="vertical-align: inherit;">的领域</font></font><code>d/sectools</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了完整起见，我们给出启发式已知地址的伪代码：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">known_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_outs(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>].append(output) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>].append(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，现在我们有了通用的绕过算法和沿着区块链移动所必需的启发法，以便我们可以将它们放在一起以从Namecoin获得一些IOC。 </font></font><br><br><h2> 走吧 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从RTM交易开始向上和向下移动</font></font><code>37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在推进区块链的过程中，我们不仅会收集IOC，还会收集满足启发式的交易本身。我们使用Sankey图表可视化交易之间的币流。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的图表太大了，无法以本文档的格式显示，因此在这里我只给出其中的一部分，这对于进一步的故事而言是必需的。</font></font><br><br><img src="https://habrastorage.org/webt/zj/jh/un/zjjhundsmnmtabrgw81hkty76nk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普通硬币流以灰色突出显示。其余颜色对应于特殊硬币的流动。为每个名称选择单独的颜色。白色里程碑对应于满足启发式条件的交易。右侧的红色里程碑是UTXO。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我要引起注意的图表元素以蓝色里程碑突出显示。这是一个悬空的条目-一种硬币，是在算法向上移动时通过交易的输入而产生的，但是创建该硬币的交易却没有遇到他。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悬空的输入表示正在研究的结构具有未连接到算法沿其移动的主干的侧分支。在所示的情况下，这是另一个独立帐户。从图中可以看出，它开始用于支付我们已经知道的域中的更改。根据这一事实，我们可以得出结论，该帐户也受调查者控制。为了使与此帐户上的操作相关联的IOC一直显示在图表上，我们将开始一个单独的向下移动，从带有悬挂条目的交易开始。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似地，在向下运动中，可能会出现悬空的出口。对于它们中的每一个，我们将从相应的交易开始进行单独的向上移动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了控制RTM僵尸网络的组的事务之外，我们还检查了控制Shifu，Dimnie和GandCrab僵尸网络的组的事务。结果，找到了以这些组的利益注册的164个域以及与这些名称相关的277个IP地址。在撰写本文时，已收集的属于这些组的UTX​​O中仍有39个硬币有效。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOC列表以及组中未使用的硬币保留在其上的Namecoin地址在附录A中给出。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际测试是几乎所有技术的挑战。到2000年代中期，维基百科已经成为一种如此受欢迎的受信任的信息源，通过更改文章的文字，可以控制舆论，起步并赚钱。服务历史上的这一时期以其巨大的修订战争而闻名-积极使用文章更正机制和多个​​交战方撤回编辑以赢得对文章内容的争议。维基百科的页面变成了国际名利场，每个人都想从字面上说出最后一句话。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一方面，他们开始与修正案之战进行斗争，制定了特殊规则，以允许在发生争议的情况下暂时排除编辑该条款的可能性-直到“讨论”部分的辩论者找到折衷的措辞。另一方面，修订战争迫使Wikipedia启动动态机制来管理管理员的资源，这使他们能够迅速参与解决最热地区的冲突。此外，该百科全书利用了引起公众关注的优势，即围绕各个文章引起的冲突，以吸引更多的参与者来编辑这些文章，并实现对特定主题的最正确，最全面的报道。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像Wikipedia一样，Namecoin可以成长并应对挑战吗？</font><font style="vertical-align: inherit;">等一下 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有折衷指标的PS表</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可在GitHub上获得</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PT专家安全中心的Alexey Goncharov </font><b><font style="vertical-align: inherit;">发布</font></b></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460857/">https://habr.com/ru/post/zh-CN460857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460845/index.html">费尔南多·科尔巴托（Fernando Corbato），您的计算机之父（和密码），享年93岁。</a></li>
<li><a href="../zh-CN460847/index.html">1230万个并发WebSocket</a></li>
<li><a href="../zh-CN460849/index.html">第4部分。用于计算异步并行进程的逻辑函数的图形模型</a></li>
<li><a href="../zh-CN460851/index.html">SamsPcbGuide，第10部分：技术-焊接无铅组件</a></li>
<li><a href="../zh-CN460855/index.html">如何使用PHP实现微服务？</a></li>
<li><a href="../zh-CN460859/index.html">在哈尔科夫举行的IThink＃3会议-基于WWDC 2019</a></li>
<li><a href="../zh-CN460861/index.html">JavaScript词汇范围和闭包</a></li>
<li><a href="../zh-CN460863/index.html">Cloudflare崩溃详细信息2019年7月2日</a></li>
<li><a href="../zh-CN460865/index.html">月亮上的人。 资料来源</a></li>
<li><a href="../zh-CN460867/index.html">Sourcery自动转换为Realm对象结构</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>