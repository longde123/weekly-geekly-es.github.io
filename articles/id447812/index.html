<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏿 🚊 🎮 Bagaimana kami menerapkan pengiriman pembaruan berkelanjutan ke platform pelanggan 👩🏻‍🤝‍👨🏼 👩🏾‍🔬 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di True Engineering, kami telah menyiapkan proses pengiriman pembaruan berkelanjutan ke server pelanggan dan ingin berbagi pengalaman ini. 

 Pertama,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menerapkan pengiriman pembaruan berkelanjutan ke platform pelanggan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/447812/">  Di True Engineering, kami telah menyiapkan proses pengiriman pembaruan berkelanjutan ke server pelanggan dan ingin berbagi pengalaman ini. <br><br>  Pertama, kami mengembangkan sistem online untuk pelanggan dan menempatkannya di kluster Kubernet kami sendiri.  Sekarang solusi kami yang sangat bermuatan telah pindah ke platform pelanggan, dan kami telah menyiapkan proses Penerapan Berkelanjutan yang sepenuhnya otomatis.  Berkat ini, kami telah mempercepat waktu ke pasar - pengiriman perubahan ke lingkungan produk. <br><br>  Dalam artikel ini, kami akan berbicara tentang semua tahapan proses Penerapan Berkelanjutan (CD) atau memberikan pembaruan ke platform pelanggan: <br><br><ol><li>  bagaimana proses ini dimulai? </li><li>  sinkronisasi dengan repositori Git pelanggan, </li><li>  perakitan backend dan frontend </li><li>  penyebaran aplikasi secara otomatis dalam lingkungan pengujian, </li><li>  penyebaran otomatis di Prod. </li></ol><br>  Dalam prosesnya kami akan membagikan detail pengaturan. <br><br><img src="https://habrastorage.org/webt/ii/pa/gh/iipaghverrphnx-_scgemoqhgy0.jpeg"><br><a name="habracut"></a><br><h3>  1. Mulai CD </h3><br>  Penerapan Berkelanjutan dimulai dengan fakta bahwa pengembang memposting perubahan ke cabang rilis repositori Git kami. <br><br>  Aplikasi kami bekerja berdasarkan arsitektur microservice dan semua komponennya disimpan dalam satu repositori.  Berkat ini, semua layanan microsoft dirakit dan diinstal, bahkan jika salah satu dari mereka telah berubah. <br><br>  Kami mengorganisir pekerjaan melalui satu repositori karena beberapa alasan: <br><br><ul><li>  Kemudahan pengembangan - aplikasi sedang aktif dikembangkan, sehingga Anda dapat segera bekerja dengan semua kode. </li><li>  Saluran pipa CI / CD tunggal yang memastikan bahwa aplikasi sebagai sistem tunggal melewati semua pengujian dan dikirimkan ke lingkungan produk pelanggan. </li><li>  Kami mengecualikan kebingungan dalam versi - kami tidak harus menyimpan peta versi layanan-mikro dan menjelaskan konfigurasi kami untuk setiap layanan-mikro di skrip Helm. </li></ul><br><h3>  2. Sinkronisasi dengan repositori Git dari kode sumber pelanggan </h3><br>  Perubahan yang dilakukan secara otomatis disinkronkan dengan repositori Git pelanggan.  Di sana, perakitan aplikasi dikonfigurasi, yang dimulai setelah memperbarui cabang, dan penyebaran ke prod.  Kedua proses terjadi di lingkungannya dari repositori Git. <br><br>  Kami tidak dapat bekerja dengan repositori pelanggan secara langsung, karena kami membutuhkan pengembangan dan lingkungan pengujian kami sendiri.  Kami menggunakan repositori Git kami untuk tujuan ini - disinkronkan dengan repositori Git mereka.  Segera setelah pengembang memposting perubahan ke cabang yang sesuai dari repositori kami, GitLab segera mengirimkan perubahan ini kepada pelanggan. <br><br><img src="https://habrastorage.org/webt/x4/de/zu/x4dezunuwwydsx3xq2uaxj1wbzo.png"><br><br>  Setelah itu, Anda perlu membuat pertemuan.  Ini terdiri dari beberapa tahap: merakit backend dan frontend, pengujian dan pengiriman ke prod. <br><br><h3>  3. Bangun backend dan frontend </h3><br>  Perakitan backend dan frontend adalah dua tugas paralel yang dilakukan dalam sistem Runner GitLab.  Konfigurasi rakitan aslinya terletak di repositori yang sama. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial untuk menulis skrip YAML untuk dibuat di GitLab</a> . <br><br>  GitLab Runner mengambil kode dari repositori yang diinginkan, mengumpulkan perintah Java application build dan mengirimkannya ke registri Docker.  Di sini kami mengumpulkan backend dan frontend, mendapatkan gambar Docker, yang kami tempatkan di repositori di sisi pelanggan.  Untuk mengelola gambar Doker, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin Gradle</a> . <br><br>  Kami menyinkronkan versi gambar kami dengan versi rilis, yang akan diposting di Docker.  Untuk kelancaran operasi, kami membuat beberapa pengaturan: <br><br>  1. Antara lingkungan pengujian dan wadah grosir tidak dipasang kembali.  Kami melakukan parameterisasi sehingga wadah yang sama dapat bekerja tanpa membangun kembali dengan semua pengaturan, variabel lingkungan dan layanan baik di lingkungan pengujian dan di prod. <br><br>  2. Untuk memperbarui aplikasi melalui Helm, Anda harus menentukan versinya.  Kami memiliki perakitan backend, antarmuka dan pembaruan aplikasi - ini adalah tiga tugas yang berbeda, jadi penting untuk menggunakan versi aplikasi yang sama di mana-mana.  Untuk tugas ini, kami menggunakan data dari sejarah Git, karena kami memiliki konfigurasi cluster K8S dan aplikasi berada dalam repositori Git yang sama. <br><br>  Kami mendapatkan versi aplikasi dari hasil perintah <br>  <code>git describe --tags --abbrev=7</code> . <br><br><h3>  4. Penerapan otomatis semua perubahan dalam lingkungan pengujian (UAT) </h3><br>  Langkah selanjutnya dalam skrip build ini adalah memperbarui kluster K8S secara otomatis.  Ini terjadi asalkan seluruh aplikasi dirakit dan semua artefak diterbitkan ke Docker Registry.  Setelah itu, pembaruan lingkungan pengujian dimulai. <br><br>  Pembaruan cluster diluncurkan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembaruan Helm</a> .  Jika, sebagai akibatnya, terjadi kesalahan, Helm akan secara otomatis dan independen mengembalikan semua perubahannya.  Karyanya tidak perlu dikontrol. <br><br>  Bersama dengan perakitan, kami memberikan konfigurasi cluster K8S.  Oleh karena itu, langkah selanjutnya adalah memperbaruinya: configMaps, penyebaran, layanan, rahasia, dan konfigurasi K8S lainnya yang kami ubah. <br><br>  Setelah itu, Helm meluncurkan RollOut untuk memperbarui aplikasi itu sendiri dalam lingkungan uji.  Sebelum aplikasi dikerahkan ke prod.  Ini dilakukan agar pengguna secara manual memeriksa fitur bisnis yang telah kami posting di lingkungan pengujian. <br><br><h3>  5. Secara otomatis menyebarkan semua perubahan ke Prod </h3><br>  Untuk menyebarkan pembaruan ke lingkungan produk, yang tersisa hanyalah mengklik satu tombol di GitLab - dan kontainer segera dikirim ke lingkungan produk. <br><br>  Satu dan aplikasi yang sama dapat bekerja tanpa membangun kembali di lingkungan yang berbeda - pengujian dan produksi.  Kami menggunakan artefak yang sama tanpa mengubah apa pun dalam aplikasi, dan kami menetapkan parameter dari luar. <br><br>  Parameterisasi yang fleksibel dari pengaturan aplikasi tergantung pada lingkungan di mana aplikasi ini akan dijalankan.  Kami mengeluarkan semua pengaturan lingkungan: semuanya diparameterisasi melalui konfigurasi K8S dan parameter Helm.  Ketika Helm menyebarkan unit ke lingkungan pengujian, parameter uji berlaku untuknya, dan parameter produk berlaku untuk lingkungan produk. <br><br>  Hal yang paling sulit adalah membuat parameter semua layanan dan variabel yang digunakan, yang bergantung pada lingkungan, dan menerjemahkannya ke dalam variabel lingkungan dan deskripsi-konfigurasi parameter lingkungan untuk Helm. <br><br>  Parameter aplikasi menggunakan variabel lingkungan.  Nilai-nilainya diatur dalam wadah menggunakan configmap K8S, yang templated menggunakan Go templates.  Misalnya, mengatur variabel lingkungan ke nama domain dapat dilakukan seperti ini: <br><br><pre> <code class="plaintext hljs">APP_EXTERNAL_DOMAIN: {{ (pluck .Values.global.env .Values.app.properties.app_external_domain | first) }}</code> </pre> <br>  <b>.Values.global.env</b> - nama lingkungan (prod, stage, UAT) disimpan dalam variabel ini. <br>  <b>.Values.app.properties.app_external_domain</b> - dalam variabel ini kita di file .Values.yaml mengatur domain yang diinginkan <br><br>  Saat memperbarui aplikasi, Helm menciptakan file configmap.yaml dari templat dan mengisi nilai APP_EXTERNAL_DOMAIN dengan nilai yang diperlukan tergantung pada lingkungan di mana pembaruan aplikasi dimulai.  Variabel ini sudah diatur dalam wadah.  Akses ke sana adalah dari aplikasi, masing-masing, di setiap lingkungan aplikasi akan ada nilai yang berbeda dari variabel ini. <br><br>  Yang relatif baru, Spring Cloud memperkenalkan dukungan K8S, termasuk bekerja dengan configMaps: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring Cloud Kubernetes</a> .  Sementara proyek ini aktif berkembang dan berubah secara dramatis, kami tidak dapat menggunakannya dalam produksi.  Tetapi kami secara aktif memantau kondisinya dan menggunakannya dalam konfigurasi DEV.  Begitu stabil, kami akan beralih dari menggunakan variabel lingkungan ke sana. <br><br><h3>  Total </h3><br>  Jadi, Penerapan Berkelanjutan sudah berjalan dan berjalan.  Semua pembaruan terjadi dengan mengklik tombol.  Pengiriman perubahan ke lingkungan makanan bersifat otomatis.  Dan, yang terpenting, pembaruan tidak menghentikan sistem. <br><br><img src="https://habrastorage.org/webt/3j/aq/bs/3jaqbs3llw95qie5ienc8efaymw.jpeg"><br><br><h3>  Paket mendatang: migrasi basis otomatis </h3><br>  Kami berpikir untuk meningkatkan basis data dan kemampuan untuk mengembalikan perubahan ini.  Lagi pula, dua versi aplikasi yang berbeda bekerja secara bersamaan: yang lama berfungsi, dan yang baru naik.  Dan kami akan mematikan yang lama hanya ketika kami yakin bahwa versi yang baru berfungsi.  Migrasi basis data harus memungkinkan bekerja dengan kedua versi aplikasi. <br><br>  Karena itu, kami tidak bisa hanya mengubah nama kolom atau data lainnya.  Tetapi kita dapat membuat kolom baru, menyalin data dari kolom lama ke dalamnya dan menulis pemicu bahwa, ketika data diperbarui, secara bersamaan akan menyalin dan memperbaruinya di kolom lain.  Dan setelah keberhasilan penerapan versi baru aplikasi, setelah periode dukungan pasca peluncuran, kita dapat menghapus kolom lama dan pemicu yang telah menjadi tidak perlu. <br><br>  Jika versi baru aplikasi tidak berfungsi dengan benar, kita dapat memutar kembali ke versi sebelumnya, termasuk versi database sebelumnya.  Singkatnya, perubahan kami akan memungkinkan bekerja secara bersamaan dengan beberapa versi aplikasi. <br><br>  Kami berencana untuk mengotomatisasi migrasi basis data melalui pekerjaan K8S dengan menyematkannya dalam proses CD.  Dan kami pasti akan membagikan pengalaman ini pada Habré. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447812/">https://habr.com/ru/post/id447812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447802/index.html">Isabella 2</a></li>
<li><a href="../id447804/index.html">Dwarf Fortress meninggalkan grafik teks, tetapi bukan esensinya</a></li>
<li><a href="../id447806/index.html">Mempercepat kinerja jaringan saraf menggunakan hashing</a></li>
<li><a href="../id447808/index.html">Belajar menulis kontrak pintar pada RIDE dan RIDE4DAPPS. Bagian 2 (DAO - Organisasi Otonomi Terdesentralisasi)</a></li>
<li><a href="../id447810/index.html">Analytics untuk Layanan Azure DevOps sekarang tersedia untuk umum</a></li>
<li><a href="../id447814/index.html">Di mana dan bagaimana cara membuka pusat pengembangan?</a></li>
<li><a href="../id447816/index.html">Sedikit keajaiban template C ++ dan CRTP untuk mengontrol kebenaran tindakan programmer dalam waktu kompilasi</a></li>
<li><a href="../id447818/index.html">AgileDays 2019</a></li>
<li><a href="../id447820/index.html">Impor model 3D ke dalam Unity dan jebakan</a></li>
<li><a href="../id447822/index.html">Hampir dipecat. Bagaimana saya membangun departemen analitik Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>