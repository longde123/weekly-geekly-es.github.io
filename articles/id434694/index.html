<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•– ğŸ‘©â€ğŸ³ ğŸ™ğŸ½ Gambaran Umum NeurIPS-2018 (mis. NIPS) â« ğŸ˜‡ ğŸ‘©ğŸ½â€ğŸ”¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awal Desember, Montreal menjadi tuan rumah konferensi Sistem Pemrosesan Informasi Saraf tahunan ke-32 tentang pembelajaran mesin. Menurut tabel p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gambaran Umum NeurIPS-2018 (mis. NIPS)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ru_mts/blog/434694/"> Pada awal Desember, Montreal menjadi tuan rumah konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem Pemrosesan Informasi Saraf</a> tahunan ke-32 tentang pembelajaran mesin.  Menurut tabel peringkat tidak resmi, konferensi ini adalah acara top-1 format ini di dunia.  Semua tiket konferensi tahun ini terjual habis dalam catatan 13 menit.  Kami memiliki tim besar ilmuwan data MTS, tetapi hanya satu dari mereka - Marina Yaroslavtseva ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">magoli</a> ) - cukup beruntung untuk sampai ke Montreal.  Bersama Danila <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Savenkov</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">danila_savenkov</a> ), yang dibiarkan tanpa visa dan mengikuti konferensi dari Moskow, kita akan berbicara tentang karya-karya yang menurut kami paling menarik bagi kami.  Sampel ini sangat subyektif, tetapi mudah-mudahan ini akan menarik minat Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c10/868/6af/c108686af497e18c338a44c475d6d64e.png" alt="gambar"><br><a name="habracut"></a><br>  <b>Jaringan saraf berulang relasional</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Ketika bekerja dengan urutan, seringkali sangat penting bagaimana elemen-elemen dari urutan tersebut saling berhubungan satu sama lain.  Arsitektur standar jaringan perulangan (GRU, LSTM) hampir tidak dapat memodelkan hubungan antara dua elemen yang cukup jauh satu sama lain.  Hingga taraf tertentu, perhatian membantu mengatasi hal ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtu.be/SysgYptB198</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtu.be/quoGRI-1l0A</a> ), tetapi tetap saja ini tidak sepenuhnya benar.  Perhatian memungkinkan Anda untuk menentukan bobot kondisi tersembunyi dari masing-masing langkah urutan akan memengaruhi kondisi tersembunyi terakhir dan, karenanya, prediksi.  Kami tertarik pada hubungan unsur-unsur urutan. <br><br>  Tahun lalu, sekali lagi di NIPS, google menyarankan untuk mengabaikan pengulangan sama sekali dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perhatian pribadi</a> .  Pendekatannya terbukti sangat baik, meskipun terutama pada tugas seq2seq (artikel ini memberikan hasil terjemahan mesin). <br><br>  Artikel tahun ini menggunakan ide perhatian diri sebagai bagian dari LSTM.  Tidak banyak perubahan: <br><br><ol><li>  Kami mengubah vektor keadaan sel ke matriks "memori" M. Sampai batas tertentu, matriks memori adalah banyak vektor keadaan sel (banyak sel memori).  Mendapatkan elemen baru dari urutan, kami menentukan berapa banyak elemen ini harus memperbarui setiap sel memori. </li><li>  Untuk setiap elemen dari urutan, kami akan memperbarui matriks ini menggunakan perhatian produk multi-head dot (MHDPA, Anda dapat membaca tentang metode ini dalam artikel yang disebutkan dari google).  Hasil MHPDA untuk elemen saat ini dari urutan dan matriks M dijalankan melalui mesh yang terhubung penuh, sigmoid dan kemudian matriks M diperbarui dengan cara yang sama seperti keadaan sel dalam LSTM </li></ol><br>  Dikatakan bahwa itu adalah karena MHDPA bahwa grid dapat mempertimbangkan interkoneksi elemen urutan bahkan ketika mereka dihapus dari satu sama lain. <br><br>  Sebagai masalah mainan, model diminta dalam urutan vektor untuk menemukan vektor N berdasarkan jarak dari Mth dalam hal jarak Euclidean.  Misalnya, ada urutan 10 vektor dan kami meminta Anda untuk menemukan yang berada di tempat ketiga di dekat yang kelima.  Jelas bahwa untuk menjawab pertanyaan model ini, perlu untuk mengevaluasi jarak dari semua vektor ke yang kelima dan mengurutkannya.  Di sini, model yang diusulkan oleh penulis dengan percaya diri mengalahkan LSTM dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DNC</a> .  Selain itu, penulis membandingkan model mereka dengan arsitektur lain pada Learning to Execute (kami mendapatkan beberapa baris kode untuk dimasukkan, memberikan hasilnya), Mini-Pacman, Pemodelan Bahasa dan di mana-mana melaporkan hasil terbaik. <br><br>  <b>Imputasi Seri Waktu Multivariat dengan Jaringan Adversarial Generatif</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> (meskipun mereka tidak menautkan artikel ini di sini) <br><br>  Dalam rangkaian waktu multidimensi, sebagai suatu peraturan, ada sejumlah besar kelalaian, yang mencegah penggunaan metode statistik lanjutan.  Solusi standar - mengisi dengan mean / nol, menghapus kasus yang tidak lengkap, mengembalikan data berdasarkan ekspansi matriks dalam situasi ini, seringkali tidak berfungsi, karena mereka tidak dapat mereproduksi ketergantungan waktu dan distribusi kompleks deret waktu multidimensi. <br><br>  Kemampuan jaringan permusuhan generatif (GAN) untuk meniru setiap distribusi data, khususnya, dalam tugas-tugas "menggambar" wajah dan menghasilkan kalimat, sudah dikenal luas.  Tetapi, sebagai suatu peraturan, model-model tersebut membutuhkan pelatihan awal pada dataset lengkap tanpa kesenjangan, atau tidak memperhitungkan sifat konsisten dari data. <br><br>  Penulis mengusulkan untuk melengkapi GAN dengan elemen baru - Gaten Recurrent Unit for Imputation (GRUI).  Perbedaan utama dari GRU biasanya adalah bahwa GRUI dapat belajar dari data pada interval panjang yang berbeda antara pengamatan dan menyesuaikan efek pengamatan tergantung pada jarak waktu dari titik saat ini.  Parameter atenuasi khusus Î² dihitung, nilainya bervariasi dari 0 hingga 1 dan semakin kecil, semakin besar jeda waktu antara pengamatan saat ini dan yang sebelumnya tidak kosong. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ab/c71/63b/6abc7163bf3ff1b16310104100b53236.png" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/203/a64/599/203a6459932c852ad827db0d9574ef2c.png" alt="gambar"><br><br>  Baik diskriminator dan generator GAN terdiri dari lapisan GRUI dan lapisan yang terhubung penuh.  Seperti biasa dalam GAN, generator belajar mensimulasikan data sumber (dalam hal ini, cukup mengisi celah di baris), dan diskriminator belajar untuk membedakan baris yang diisi dengan generator dari yang asli. <br><br>  Ternyata, pendekatan ini sangat memadai mengembalikan data bahkan dalam rangkaian waktu dengan bagian yang sangat besar dari kelalaian (dalam tabel di bawah ini - pemulihan data UMK dalam dataset KDD tergantung pada persentase kelalaian dan metode pemulihan. Dalam kebanyakan kasus, metode berbasis GAN memberikan akurasi terbesar pemulihan). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/188/737/e57/188737e575173058d1c0a79482b8679d.png" alt="gambar"><br><br>  <b>Tentang Dimensi Kata-Kata yang Digunakan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Penyematan kata / representasi vektor kata adalah pendekatan yang banyak digunakan untuk berbagai aplikasi NLP: dari sistem rekomendasi hingga analisis pewarnaan emosional teks dan terjemahan mesin. <br><br>  Selain itu, pertanyaan tentang bagaimana mengatur secara optimal hiperparameter yang penting seperti dimensi vektor tetap terbuka.  Dalam praktiknya, paling sering dipilih oleh pencarian lengkap empiris atau ditetapkan secara default, misalnya, pada level 300. Pada saat yang sama, dimensi yang terlalu kecil tidak memungkinkan untuk mencerminkan semua hubungan yang signifikan antara kata-kata, dan terlalu besar dapat menyebabkan pelatihan ulang. <br><br>  Para penulis penelitian mengusulkan solusi mereka untuk masalah ini dengan meminimalkan parameter kehilangan PIP, ukuran baru dari perbedaan antara dua opsi penyematan. <br>  Perhitungan didasarkan pada matriks-PIP yang berisi produk skalar dari semua pasangan representasi vektor kata dalam corpus.  Kehilangan PIP dihitung sebagai norma Frobenius antara matriks PIP dari dua embedding: dilatih pada data (dilatih menyematkan E_hat) dan ideal, dilatih pada data bising (oracle embedding E). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/135/a0a/1f2/135a0a1f216137c64ab73f9d2b86f0dc.png" alt="gambar" width="300" height="200"></div><br><br>  Tampaknya sederhana: Anda harus memilih dimensi yang meminimalkan kehilangan PIP, satu-satunya momen yang tidak bisa dipahami adalah di mana mendapatkan penanaman oracle.  Pada 2015-2017, sejumlah karya diterbitkan di mana ditunjukkan bahwa berbagai metode untuk membangun embeddings (word2vec, GloVe, LSA) secara implisit memfaktisasi (menurunkan dimensi) matriks sinyal dari kasing.  Dalam kasus word2vec (skip-gram), matriks sinyal adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PMI</a> , dalam kasus GloVe itu adalah matriks penghitungan log.  Diusulkan untuk mengambil kamus yang ukurannya tidak terlalu besar, membangun matriks sinyal dan menggunakan SVD untuk mendapatkan oracle embedding.  Dengan demikian, dimensi embedded oracle sama dengan peringkat matriks sinyal (dalam praktiknya, untuk kamus 10k kata, dimensi akan menjadi urutan 2k).  Namun, matriks sinyal empiris kami selalu berisik dan kami harus menggunakan skema rumit untuk mendapatkan oracle embedding dan memperkirakan kehilangan PIP dengan matriks berisik. <br><br>  Para penulis berpendapat bahwa untuk memilih dimensi penyematan optimal, cukup menggunakan kamus 10k kata, yang tidak terlalu banyak dan memungkinkan Anda untuk menjalankan prosedur ini dalam jumlah waktu yang wajar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/454/806/a20/454806a208dd7c10df8b9cbd365c440a.png" alt="gambar"><br><br>  Ternyata, dimensi penyematan dihitung dengan cara ini dalam banyak kasus dengan kesalahan hingga 5% bertepatan dengan dimensi optimal yang ditentukan berdasarkan perkiraan ahli.  Ternyata (diharapkan) bahwa Word2Vec dan GloVe praktis tidak berlatih ulang (kehilangan PIP tidak turun pada dimensi yang sangat besar), tetapi LSA dilatih ulang dengan cukup kuat. <br><br>  Menggunakan kode yang diposting di github oleh penulis, orang dapat mencari dimensi optimal dari Word2Vec (skip-gram), GloVe, LSA. <br><br>  <b>FRAGE: Representasi Frekuensi-Agnostik</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Para penulis berbicara tentang bagaimana embeddings bekerja secara berbeda untuk kata-kata langka dan populer.  Maksud saya bukan berarti menghentikan kata-kata (kami tidak menganggapnya sama sekali), tetapi kata-kata informatif yang tidak terlalu jarang. <br><br>  Pengamatan adalah sebagai berikut: <br><br>  Jika kita berbicara tentang kata-kata populer, maka kedekatannya dengan ukuran kosinus mencerminkan dengan sangat baik <br><br><ol><li>  afinitas semantik mereka.  Untuk kata-kata langka, ini tidak begitu (apa yang diharapkan), dan (apa yang kurang diharapkan) teratas-n dari kata kosinus terdekat dengan kata langka juga jarang dan pada saat yang sama tidak berhubungan secara semantik.  Artinya, kata-kata yang jarang dan sering di ruang pernikahan hidup di tempat yang berbeda (di kerucut yang berbeda, jika kita berbicara tentang kosinus) </li><li>  Selama pelatihan, vektor kata populer diperbarui lebih sering dan rata-rata dua kali lipat dari inisialisasi daripada vektor untuk kata-kata langka.  Ini mengarah pada fakta bahwa penyisipan kata-kata langka rata-rata lebih dekat ke asal.  Sejujurnya, saya selalu percaya bahwa, sebaliknya, kata-kata langka embeddings rata-rata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih lama</a> dan saya tidak tahu bagaimana berhubungan dengan pernyataan penulis =) </li></ol><br>  Apa pun hubungan antara norma L2 dari embeddings, pemisahan kata-kata populer dan langka bukanlah fenomena yang sangat baik.  Kami ingin embeddings untuk mencerminkan semantik kata, bukan frekuensinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7e/f4d/e70/c7ef4de7034a8347269fa40d6bdc7005.png" alt="gambar"><br><br>  Gambar menunjukkan Word2Vec kata populer (merah) dan langka (biru) setelah SVD.  Populer di sini mengacu pada 20% kata teratas dalam frekuensi. <br><br>  Jika masalahnya hanya pada norma L2 embeddings, kita bisa menormalkannya dan hidup bahagia, tetapi, seperti yang saya katakan di paragraf pertama, kata-kata langka juga dipisahkan dari yang populer dengan kedekatan cosinus (dalam koordinat polar). <br><br>  Penulis menyarankan, tentu saja, GAN.  Mari kita lakukan hal yang sama seperti sebelumnya, tetapi tambahkan pembeda yang akan mencoba untuk membedakan antara kata-kata populer dan langka (sekali lagi, kami menganggap top-n% dari kata dalam frekuensi menjadi populer). <br><br>  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/0a3/0b7/f0e0a30b77a9071ff63fa208401fad56.png" alt="gambar"><br><br>  Para penulis menguji pendekatan pada tugas kesamaan kata, terjemahan mesin, klasifikasi teks dan pemodelan bahasa dan di mana-mana mereka melakukan lebih baik daripada garis dasar.  Dalam kesamaan kata, dinyatakan bahwa kualitas tumbuh terutama terlihat pada kata-kata langka. <br><br>  Salah satu contoh: kewarganegaraan.  Masalah lewati-gram: kebahagiaan, Pakistan, pemberhentian, penguatan.  Masalah FRAGE: populasi, stÃ¤dtischen, martabat, bÃ¼rger.  Kata-kata warga dan warga di FRAGE berada di tempat ke-79 dan ke-7, masing-masing (berdekatan dengan kewarganegaraan), dalam lompatan gram mereka tidak berada di atas 10.000. <br><br>  Untuk beberapa alasan, penulis memposting kode hanya untuk terjemahan mesin dan pemodelan bahasa, kesamaan kata dan tugas klasifikasi teks dalam repositori, sayangnya, tidak terwakili. <br><br>  <b>Penyelarasan Lintas-Modal Tanpa Spasi untuk Ruang Bicara dan Teks</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  Kode: tidak ada kode, tapi saya mau <br><br>  Studi terbaru menunjukkan bahwa dua ruang vektor dilatih menggunakan algoritma embedding (misalnya, word2vec) pada badan teks dalam dua bahasa yang berbeda dapat dicocokkan satu sama lain tanpa markup dan pencocokan konten antara kedua bangunan.  Secara khusus, pendekatan ini digunakan untuk terjemahan mesin di Facebook.  Salah satu sifat kunci dari ruang embedding digunakan: di dalamnya, kata-kata yang mirip harus dekat secara geometris, dan yang berbeda, sebaliknya, harus jauh dari satu sama lain.  Diasumsikan bahwa, secara umum, struktur ruang vektor dilestarikan terlepas dari bahasa tempat korpus digunakan untuk mengajar. <br><br>  Para penulis artikel melangkah lebih jauh dan menerapkan pendekatan yang serupa dengan bidang pengenalan dan terjemahan ucapan otomatis.  Diusulkan untuk melatih ruang vektor secara terpisah untuk corpus teks dalam bahasa yang diinginkan (misalnya, Wikipedia), secara terpisah untuk corpus pidato yang direkam (dalam format audio), mungkin dalam bahasa lain, sebelumnya dipecah menjadi kata-kata, dan kemudian membandingkan dua ruang ini dengan cara yang sama seperti dengan dua kasus teks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d07/950/b6f/d07950b6f9bac05e9ce48dd80bb24838.png" alt="gambar"><br><br>  Untuk corpus teks, word2vec digunakan, dan untuk pidato, pendekatan yang serupa, yang disebut oleh Speech2vec, didasarkan pada LSTM dan metodologi yang digunakan untuk word2vec (CBOW / skip-gram), sehingga diasumsikan bahwa ia menggabungkan kata-kata secara tepat dengan karakteristik kontekstual dan semantik, dan tidak terdengar. <br><br>  Setelah kedua ruang vektor dilatih dan ada dua set embeddings - S (pada tubuh ucapan), yang terdiri dari n embeds dimensi d1 dan T (pada badan teks), yang terdiri dari m embeds dimensi d2, Anda perlu membandingkannya.  Idealnya, kami memiliki kamus yang menentukan vektor dari S yang sesuai dengan vektor dari T. Lalu dua matriks dibentuk untuk perbandingan: k embedding dipilih dari S, yang membentuk matriks X ukuran d1 xk;  dari T, k embeddings yang sesuai (menurut kamus) yang sebelumnya dipilih dari S juga dipilih, dan matriks Y ukuran d2 xk diperoleh.  Selanjutnya, Anda perlu menemukan pemetaan linear W sedemikian rupa sehingga: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/59e/e40/db359ee40ad9f907c6461d378db3d7aa.png" alt="gambar" width="300" height="200"></div><br><br>  Tetapi karena artikel tersebut mempertimbangkan pendekatan tanpa pengawasan, awalnya tidak ada kamus, oleh karena itu, prosedur untuk membuat kamus sintetis, yang terdiri dari dua bagian, diusulkan.  Pertama, kami mendapatkan perkiraan pertama W menggunakan pelatihan domain-adversarial (model kompetitif seperti GAN, tetapi bukannya generator - pemetaan linear W, yang dengannya kami mencoba membuat S dan T tidak dapat dibedakan satu sama lain, dan diskriminator mencoba menentukan asal sebenarnya dari penanaman).  Kemudian, berdasarkan kata-kata yang embeddingsnya menunjukkan kecocokan terbaik satu sama lain dan paling sering ditemukan di kedua bangunan, kamus dibentuk.  Setelah itu, penyempurnaan W sesuai dengan rumus di atas terjadi. <br><br>  Pendekatan ini memberikan hasil yang sebanding dengan belajar pada data berlabel, yang dapat sangat berguna dalam tugas mengenali dan menerjemahkan pidato dari bahasa langka yang terlalu sedikit kasus teks ucapan paralel, atau tidak ada. <br><br>  <b>Deteksi Anomali Jauh Menggunakan Transformasi Geometris</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Pendekatan yang agak tidak biasa dalam deteksi anomali, yang, menurut penulis, sangat mengalahkan pendekatan lain. <br><br>  Idenya adalah ini: mari kita datang dengan K transformasi geometris yang berbeda (kombinasi dari pergeseran, 90 derajat rotasi dan refleksi) dan menerapkannya pada setiap gambar dari dataset asli.  Gambar yang diperoleh sebagai hasil dari transformasi ke-i sekarang akan menjadi milik kelas i, yaitu, akan ada total kelas K, masing-masing akan diwakili oleh jumlah gambar yang semula dalam dataset.  Sekarang kita akan mengajarkan klasifikasi multikelas pada markup tersebut (penulis memilih resnet lebar). <br><br>  Sekarang kita bisa mendapatkan vektor K y (Ti (x)) dimensi K untuk gambar baru, di mana Ti adalah transformasi ke-i, x adalah gambar, y adalah output model.  Definisi dasar "normalitas" adalah sebagai berikut: <br><br>  Di sini, untuk gambar x, kami menambahkan probabilitas prediksi kelas yang benar untuk semua transformasi.  Semakin besar â€œnormalitasâ€, semakin besar kemungkinan gambar diambil dari distribusi yang sama dengan sampel pelatihan.  Para penulis mengklaim bahwa ini sudah bekerja sangat keren, tetapi bagaimanapun menawarkan cara yang lebih kompleks yang bekerja bahkan sedikit lebih baik.  Kami akan menganggap bahwa vektor y (Ti (x)) untuk setiap transformasi Ti adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dirichlet yang</a> terdistribusi dan kami akan mengambil kemungkinan logaritma sebagai ukuran "normalitas" gambar.  Parameter distribusi Dirichlet diestimasi pada satu set pelatihan. <br><br>  Penulis melaporkan peningkatan kinerja luar biasa dibandingkan dengan pendekatan lain. <br><br>  <b>Kerangka Kerja Terpadu Sederhana untuk Mendeteksi Sampel yang Tidak Terdistribusi dan Serangan Musuh</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Identifikasi dalam sampel untuk penerapan model kasus berbeda secara signifikan dari distribusi sampel pelatihan adalah salah satu persyaratan utama untuk mendapatkan hasil klasifikasi yang dapat diandalkan.  Pada saat yang sama, jaringan saraf dikenal untuk fitur mereka dengan tingkat kepercayaan yang tinggi (dan salah) untuk mengklasifikasikan objek yang tidak ditemukan dalam pelatihan, atau sengaja rusak (contoh permusuhan). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/780/f35/1e0780f3540fcb4ba894f38a40c31cbb.png" alt="gambar"><br><br>  Penulis artikel ini menawarkan metode baru untuk mengidentifikasi kasus-kasus tersebut dan "buruk" lainnya.  Pendekatan diimplementasikan sebagai berikut: pertama, jaringan saraf dengan output softmax biasa dilatih, kemudian output dari lapisan kedua dari belakang diambil, dan classifier generatif dilatih di atasnya.  Biarkan ada x - yang diumpankan ke input model untuk objek klasifikasi tertentu, y - label kelas yang sesuai, lalu anggaplah bahwa kita memiliki classifier softmax pra-terlatih dari formulir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/898/826/223898826445e2677c03a2078b182208.png" alt="gambar" width="300" height="200"></div><br><br>  Dimana wc dan bc adalah bobot dan konstanta dari lapisan softmax untuk kelas c, dan f (.) Adalah output dari DNN kedelai kedua dari belakang. <br><br>  Lebih lanjut, tanpa perubahan apa pun pada pengklasifikasi pra-terlatih, transisi dibuat ke pengklasifikasi generatif, yaitu, analisis diskriminan.  Diasumsikan bahwa fitur yang diambil dari lapisan kedua dari classifier softmax memiliki distribusi normal multidimensi, masing-masing komponen yang sesuai dengan satu kelas.  Kemudian distribusi kondisional dapat ditentukan melalui vektor cara distribusi multidimensi dan matriks kovariannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ada/0d8/e70/ada0d8e70536c7993a6061b154f3c0eb.png" alt="gambar" width="300" height="200"></div><br><br>  Untuk mengevaluasi parameter dari classifier generatif, rata-rata empiris dihitung untuk setiap kelas, serta kovarians untuk kasus dari sampel pelatihan {(x1, y1), ..., (xN, yN)}: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ada/0d8/e70/ada0d8e70536c7993a6061b154f3c0eb.png" alt="gambar" width="300" height="200"></div><br><br>  di mana N adalah jumlah kasus dari kelas yang sesuai dalam set pelatihan.  Kemudian, ukuran reliabilitas dihitung pada sampel uji - jarak Mahalanobis antara test case dan distribusi kelas normal terdekat dengan case ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/928/03b/09592803b18f664fad5940fc81d47f77.png" alt="gambar" width="400" height="300"></div><br><br>  Ternyata, metrik seperti itu bekerja jauh lebih andal pada objek atipikal atau rusak, tanpa memberikan perkiraan tinggi, seperti lapisan softmax.  Dalam sebagian besar perbandingan pada data yang berbeda, metode yang diusulkan menunjukkan hasil yang melampaui keadaan terkini dalam menemukan kedua kasus yang tidak ada dalam pelatihan, dan sengaja dimanjakan. <br><br>  Selanjutnya, penulis mempertimbangkan aplikasi lain yang menarik dari metodologi mereka: gunakan classifier generatif untuk menyoroti kelas-kelas baru yang tidak dalam pelatihan tentang tes, dan kemudian memperbarui parameter dari classifier itu sendiri sehingga dapat menentukan kelas baru ini di masa depan. <br><br>  <b>Contoh Adversarial yang Menipu Visi Komputer dan Manusia Berbatas Waktu</b> <br>  Abstrak: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://arxiv.org/abs/1802.08195</a> <br><br>     adversarial examples     .     ,           .          adversarial example      . ,         ,   , ,         , ,  ,      adversarial attacks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/859/b13/cf0/859b13cf0bb3c14ac58eeab39b5a0945.png" alt="gambar"><br><br>         adversarial examples.   adversarial examples  ,         (   ,           ). <br><br> ,   adversarial example,        . ,        ,         63          .    accuracy      10% ,   adversarial.        ,  adversarial             ,     .   ,     perturbation   perturbation   ,  accuracy        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/f4d/e03/966f4de0389283dd83f73a1be2cf36cb.png" alt="gambar"><br><br>   adv â€” adversarial example, image â€”  , flip â€”   + adversarial perturbation,   . <br><br> <b>Sanity Checks for Saliency Maps</b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstract</a> <br><br>   â€”      .     deep learning,     saliency maps. Saliency maps                 .    saliency map,       ,      â€œâ€. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa5/2c5/659/aa52c5659d4c00d7666661797671c4b9.png" alt="gambar"><br><br>     : â€œ      saliency maps?â€    ,   : <br><br><ol><li> Saliency map      </li><li> Saliency map    ,     </li></ol><br>     ,      : cascading randomization ( ,     ,   saliency map)  independent randomization (  ).     :      ,     saliency maps. <br>    saliency map     ,   ,       saliency maps. : â€œTo our surprise, some widely deployed saliency methods are independent of both the data the model was trained on, and the model parametersâ€, â€”  . , ,   saliency maps,     ,  cascading randomization: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/eaa/ca7/965eaaca7902d24ef5369a63d493b4ff.png" alt="gambar"><br><br>      ,           .     ,   saliency maps    . <br><br>    ,  â€”  saliency maps          ,      ,      confirmation bias.         ,          . <br><br> <b>An intriguing failing of convolutional neural networks and the CoordConv solution</b> <br> Abstract: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://arxiv.org/abs/1807.03247</a> <br> :           ,     10 . <br><br>        Uber.        ,  ,     ,     .           ,           : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ed/408/c14/6ed408c1456a509c86a6260df5c5a23b.png" alt="gambar"><br><br>    :    (     CoodrConv )   i  j,          : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2a/87e/8cb/a2a87e8cb6b7d283396a0fb3ef11fe30.png" alt="gambar"><br><br> , : <br><br><ol><li>       ImageNet'.         , ,   ,    ,         </li><li> CoordConv   object detection.        MNIST,      Faster R-CNN,    IoU  21% </li><li>   CoordConv  GAN    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fee/a18/425/feea18425335abbb7d784669a1b82bcd.png" alt="gambar"><br><br>  GAN'   :                 LSUN.       ,     â€”     c.  ,   GAN'    , ,         .   CoordConv         ,      .    LSUN   d ,     ,  CoordConv GAN,    <br></li><li> 4.  CoordConv  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A2C</a>     (  ) . </li></ol><br>        ,       ,     .   CoordConv      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">U-net</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://arxiv.org/abs/1812.01429,%2520">https://arxiv.org/abs/1812.01429, https://www.kaggle.com/c/tgs-salt-identification-challenge/discussion/69274</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mjDelta/Kaggle-RSNA-Pneumonia-Detection-Challenge</a> . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> . <br><br> <b>Regularizing by the Variance of the Activations' Sample-Variances</b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstract</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <br><br>     batch normalization.          - .      :       S1  S2    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/2ea/97a/e5f2ea97aaebf6af472880bc2190b2cc.png" alt="gambar" width="300" height="200"></div><br><br>  di mana Ïƒ2 adalah varians sampel dalam S1 dan S2, masing-masing, Î² adalah koefisien positif terlatih.  Penulis menyebut hal ini variance constancy loss (VCL) dan menambahkannya ke total loss. <br><br>  Pada bagian tentang percobaan, penulis mengeluh tentang bagaimana hasil artikel orang lain tidak direproduksi dan berkomitmen untuk mengeluarkan kode yang dapat direproduksi (ditata).  Pertama, mereka bereksperimen dengan mesh 11-layer kecil pada dataset gambar kecil (CIFAR-10 dan CIFAR-100).  Kami mendapatkan bahwa VCL terbukti, jika Anda menggunakan Leaky ReLU atau ELU sebagai aktivasi, tetapi normalisasi bets berfungsi lebih baik dengan ReLU.  Kemudian mereka menambah jumlah layer sebanyak 2 kali dan beralih ke Tiny Imagenet - versi sederhana dari Imagenet dengan 200 kelas dan resolusi 64x64.  Dalam validasi, VCL mengungguli normalisasi batch pada grid dengan ELU, serta ResNet-110 dan DenseNet-40, tetapi mengungguli Wide-ResNet-32.  Suatu hal yang menarik adalah bahwa hasil terbaik diperoleh ketika himpunan bagian S1 dan S2 terdiri dari dua sampel. <br><br>  Selain itu, penulis menguji VCL dalam jaringan umpan-maju dan VCL menang lebih sering daripada jaringan dengan normalisasi batch atau tanpa regularisasi. <br><br>  <b>DropMax: Adaptive Variational Softmax</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Diusulkan dalam masalah klasifikasi multi-kelas pada setiap iterasi dari gradient descent untuk setiap sampel untuk secara acak menjatuhkan sejumlah kelas yang salah.  Selain itu, probabilitas dengan mana kita menjatuhkan satu atau kelas lain untuk satu atau objek lain juga sedang dilatih.  Akibatnya, ternyata jaringan "berkonsentrasi" pada membedakan antara kelas yang paling sulit untuk dipisahkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2d/f45/914/b2df45914519d3b6dd1d4f12d5513775.png" alt="gambar"><br><br>  Eksperimen pada subset MNIST, CIFAR, dan Imagenet menunjukkan bahwa DropMax berkinerja lebih baik daripada SoftMax standar dan beberapa modifikasinya. <br><br>  <b>Model Intelektual Yang Akurat dengan Interaksi Berpasangan</b> <br>  (Teman Jangan Biarkan Teman Menyebarkan Model Kotak Hitam: Pentingnya Kecerdasan dalam Pembelajaran Mesin) <br><br>  Abstrak: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.cs.cornell.edu/~yinlou/papers/lou-kdd13.pdf</a> <br>  Kode: tidak ada di sana.  Saya sangat tertarik dengan bagaimana penulis mengarsipkan nama yang sedikit imperatif dengan kurangnya kode.  Akademisi, pak =) <br><br>  Anda dapat melihat paket ini, misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dswah/pyGAM</a> .  Interaksi fitur ditambahkan ke dalamnya belum lama ini (yang sebenarnya membedakan GAM dari GA2M). <br><br>  Artikel ini disajikan dalam rangka lokakarya "Interpretabilitas dan Keteguhan dalam Audio, Pidato, dan Bahasa", meskipun dikhususkan untuk interpretabilitas model secara umum, dan bukan untuk bidang analisis suara dan ucapan. Mungkin, semua orang dihadapkan pada batas tertentu dengan dilema memilih antara interpretabilitas model dan akurasinya.  Jika kita menggunakan regresi linear biasa, maka kita dapat memahami dengan koefisien bagaimana masing-masing variabel independen mempengaruhi dependen.  Jika kita menggunakan model kotak hitam, misalnya, peningkatan gradien tanpa batasan pada kompleksitas atau jaringan saraf yang dalam, model yang disetel dengan benar pada data yang sesuai akan sangat akurat, tetapi melacak dan menjelaskan semua pola yang ditemukan model dalam data akan bermasalah.  Dengan demikian, akan sulit untuk menjelaskan model kepada pelanggan dan melacak apakah dia telah mempelajari sesuatu yang tidak kita sukai.  Tabel di bawah ini memberikan perkiraan interpretabilitas relatif dan akurasi berbagai jenis model. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fca/429/548/fca42954836ae74af472d4baacf732f1.png" alt="gambar"><br><br>  Contoh situasi di mana interpretabilitas model yang buruk dikaitkan dengan risiko besar: pada salah satu set data medis, masalah memprediksi probabilitas pasien meninggal akibat pneumonia telah terpecahkan.  Pola menarik berikut ditemukan dalam data: jika seseorang memiliki asma bronkial, maka kemungkinan kematian akibat pneumonia lebih rendah daripada pada orang tanpa penyakit ini.  Ketika para peneliti beralih ke dokter praktek, ternyata pola seperti itu benar-benar ada, karena orang dengan asma dalam kasus pneumonia menerima bantuan yang paling cepat dan obat-obatan yang kuat.  Jika kami melatih xgboost pada dataset ini, kemungkinan besar ia akan menangkap pola ini, dan model kami akan mengklasifikasikan pasien dengan asma sebagai kelompok berisiko rendah dan, karenanya, akan merekomendasikan prioritas yang lebih rendah dan intensitas pengobatan untuk mereka. <br><br>  Para penulis artikel menawarkan alternatif yang dapat ditafsirkan dan akurat pada saat yang sama - ini adalah GA2M, subspesies dari model aditif umum. <br><br>  GAM klasik dapat dianggap sebagai generalisasi lebih lanjut dari GLM: suatu model adalah penjumlahan, setiap istilah yang mencerminkan pengaruh hanya satu variabel independen pada dependen, tetapi pengaruhnya dinyatakan bukan oleh satu koefisien bobot, seperti dalam GLM, tetapi oleh fungsi nonparametrik yang halus (sebagai aturan, ditentukan dengan sendirinya fungsi - splines atau pohon dengan kedalaman kecil, termasuk "tunggul").  Karena fitur ini, GAM dapat memodelkan hubungan yang lebih kompleks daripada model linier sederhana.  Di sisi lain, dependensi yang dipelajari (fungsi) dapat divisualisasikan dan ditafsirkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/643/828/ca8/643828ca8aaeb0f0728ba2d094de7e43.png" alt="gambar"><br><br>  Namun, GAM standar masih sering tidak mencapai keakuratan algoritma kotak hitam.  Untuk memperbaikinya, penulis artikel menawarkan kompromi - untuk menambah persamaan model, selain fungsi satu variabel, sejumlah kecil fungsi dua variabel - pasangan yang dipilih dengan cermat yang interaksinya signifikan untuk memprediksi variabel dependen.  Dengan demikian, GA2M diperoleh. <br><br>  Pertama, GAM standar dibangun (tanpa memperhitungkan interaksi variabel), dan kemudian pasangan variabel ditambahkan langkah demi langkah (GAM yang tersisa digunakan sebagai variabel target).  Untuk kasus ketika ada banyak variabel dan memperbarui model setelah setiap langkah sulit secara komputasi, algoritma peringkat FAST diusulkan, dengan mana Anda dapat memilih sebelumnya pasangan yang berpotensi berguna dan menghindari penghitungan lengkap. <br><br>  Pendekatan ini memungkinkan kami untuk mencapai kualitas yang dekat dengan model kompleksitas yang tidak terbatas.  Tabel menunjukkan tingkat kesalahan model aditif umum dibandingkan dengan hutan acak untuk menyelesaikan masalah klasifikasi pada dataset yang berbeda, dan dalam kebanyakan kasus kualitas prediksi untuk GA2M dengan FAST dan untuk hutan acak tidak berbeda secara signifikan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5b/809/a50/e5b809a50067cbfcd2f7bbb04f98630e.png" alt="gambar"><br><br>  Saya ingin menarik perhatian pada fitur-fitur karya akademisi yang menawarkan untuk mengirimkan dorongan dan pemahaman mendalam ini ke tungku.  Harap dicatat bahwa dataset yang hasilnya disajikan tidak lebih dari 20 ribu objek (semua dataset dari repositori UCI).  Sebuah pertanyaan alami muncul: apakah benar-benar tidak ada dataset terbuka dengan ukuran normal untuk eksperimen seperti itu pada 2018?  Anda bisa melangkah lebih jauh dan membandingkan pada dataset 50 objek - ada kemungkinan bahwa model konstan tidak akan berbeda secara signifikan dari hutan acak. <br><br>  Poin selanjutnya adalah regularisasi.  Pada sejumlah besar tanda, sangat mudah untuk melatih ulang bahkan tanpa interaksi.  Para penulis mungkin percaya bahwa masalah ini tidak ada, dan satu-satunya masalah adalah model kotak hitam.  Setidaknya dalam artikel itu, regularisasi tidak dibicarakan di mana pun, meskipun itu jelas diperlukan. <br><br>  Dan yang terakhir, tentang interpretabilitas.  Bahkan model linier tidak dapat diartikan jika kita memiliki banyak fitur.  Ketika Anda memiliki 10 ribu bobot yang terdistribusi secara normal (dalam hal menggunakan regularisasi L2 akan menjadi seperti ini), tidak mungkin untuk mengatakan dengan tepat tanda mana yang bertanggung jawab atas fakta bahwa predict_proba memberikan 0,86.  Untuk interpretabilitas, kami ingin tidak hanya model linier, tetapi model linier dengan bobot jarang.  Tampaknya ini dapat dicapai dengan regularisasi L1, tetapi di sini juga tidak begitu sederhana.  Dari serangkaian fitur yang sangat berkorelasi, regularisasi L1 akan memilih satu hampir secara tidak sengaja.  Sisanya akan mendapatkan bobot 0, meskipun jika salah satu dari fitur ini memiliki kemampuan prediksi, yang lain jelas bukan hanya noise.  Dalam hal interpretasi model, ini mungkin OK, dalam hal memahami hubungan fitur dan variabel target, ini sangat buruk.  Artinya, bahkan dengan model linier, tidak semuanya begitu sederhana, rincian lebih lanjut tentang model yang dapat ditafsirkan dan kredibel dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  <b>Visualisasi untuk Pembelajaran Mesin: UMAP</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lenyap</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> <br><br>  Pada hari tutorial, salah satu yang pertama dilakukan adalah "Visualisasi untuk Pembelajaran Mesin" oleh Google Brain.  Sebagai bagian dari tutorial, kami diberitahu tentang sejarah visualisasi, mulai dari pencipta grafik pertama, serta tentang berbagai fitur otak manusia dan persepsi serta teknik yang dapat digunakan untuk menarik perhatian pada hal terpenting dalam gambar, bahkan berisi banyak detail kecil - misalnya, menyoroti bentuk, warna, bingkai, dll., seperti pada gambar di bawah ini.  Saya akan melewati bagian ini, tetapi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulasan yang bagus</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/751/f0f/c31/751f0fc318a4bb3edadf59e35ecc7ba9.png" alt="gambar"><br><br>  Secara pribadi, saya paling tertarik dengan topik visualisasi set data multidimensi, khususnya pendekatan Uniform Manifold Approximation and Projection (UMAP) - sebuah metode baru non-linear untuk mengurangi dimensi.  Itu diusulkan pada bulan Februari tahun ini, sehingga masih sedikit orang yang menggunakannya, tetapi terlihat menjanjikan baik dalam hal waktu kerja dan dalam hal kualitas pemisahan kelas dalam visualisasi dua dimensi.  Jadi, pada kumpulan data yang berbeda, UMAP 2-10 kali lebih cepat dari t-SNE dan metode lain dalam hal kecepatan, dan semakin besar dimensi data, semakin besar kesenjangan dalam kinerja: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/045/a12/b82045a12b1cb8782c5c9fb64dfa46b9.png" alt="gambar"><br><br>  Selain itu, tidak seperti t-SNE, waktu operasi UMAP hampir tidak tergantung pada dimensi ruang baru tempat kami akan menanamkan dataset kami (lihat gambar di bawah), yang menjadikannya alat yang cocok untuk tugas-tugas lain (selain visualisasi) - khususnya, untuk mengurangi dimensi sebelum melatih model. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/f14/56a/0c6f1456a68537b5e12f58f6e1dfb740.png" alt="gambar"><br><br>  Pada saat yang sama, pengujian pada set data yang berbeda menunjukkan bahwa UMAP bekerja tidak lebih buruk untuk visualisasi, dan t-SNE lebih baik di beberapa tempat: misalnya, pada set data MNIST dan Mode MNIST, kelas lebih baik dipisahkan dalam versi dengan UMAP: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f35/4b4/869/f354b48691226fd262e3f92af9fe398f.png" alt="gambar"><br><br>  Nilai tambah tambahan adalah implementasi yang mudah: kelas UMAP mewarisi dari kelas sklearn, sehingga Anda dapat menggunakannya sebagai transformator reguler di pipa sklearn.  Selain itu, dikatakan bahwa UMAP lebih dapat ditafsirkan daripada t-SNE, seperti  lebih baik mempertahankan struktur data global. <br><br>  Di masa depan, penulis berencana untuk menambahkan dukungan untuk pelatihan semi-diawasi - yaitu, jika kita memiliki tag untuk setidaknya beberapa objek, kita dapat membangun UMAP berdasarkan informasi ini. <br><br>  Artikel apa yang kamu suka?  Tulis komentar, ajukan pertanyaan, kami akan menjawabnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434694/">https://habr.com/ru/post/id434694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434684/index.html">Rust 2019 and Beyond: Batasan Pertumbuhan</a></li>
<li><a href="../id434686/index.html">Kursus Kuliah tentang JavaScript dan Node.js di KPI</a></li>
<li><a href="../id434688/index.html">FreeBSD berencana untuk beralih ke ZFSonLinux</a></li>
<li><a href="../id434690/index.html">Sistem operasi Haiku: porting aplikasi dan pembuatan paket</a></li>
<li><a href="../id434692/index.html">25 pemula AS yang paling mahal akan mati pada 2018</a></li>
<li><a href="../id434696/index.html">Karyawan raksasa TI menemukan cara memengaruhi kebijakan perusahaan mereka</a></li>
<li><a href="../id434698/index.html">Pesimisme Tentang Multithreading</a></li>
<li><a href="../id434700/index.html">Keuntungan mengikuti style guide saat mengembangkan aplikasi Angular</a></li>
<li><a href="../id434702/index.html">Mengapa SSD modern membuat saya crash</a></li>
<li><a href="../id434704/index.html">Alasan penurunan biaya lalu lintas seluler di Rusia dan perkiraan untuk 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>