<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹️ 🙏🏼 🆕 Memory Profileing pada STM32 dan Mikrokontroler Lainnya: Analisis Ukuran Stack Statis 🔖 ⛅️ 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Dalam artikel terakhir , saya menyebutkannya sendiri dan bertanya dalam komentar - ok, well, menggunakan metode poke ilmiah, kami memil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memory Profileing pada STM32 dan Mikrokontroler Lainnya: Analisis Ukuran Stack Statis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443544/">  Halo, Habr! <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir</a> , saya menyebutkannya sendiri dan bertanya dalam komentar - ok, well, menggunakan metode poke ilmiah, kami memilih ukuran tumpukan, sepertinya tidak ada yang jatuh, tetapi bisakah kita dengan lebih baik mengevaluasi apa yang setara dan siapa yang makan begitu banyak? <br><br>  Kami menjawab singkat: ya, tapi tidak. <br><br>  Tidak, dengan menggunakan metode analisis statis tidak mungkin untuk secara akurat mengukur ukuran tumpukan yang diperlukan oleh program - tetapi, bagaimanapun, metode ini dapat berguna. <br><br>  Jawabannya sedikit lebih lama - di bawah potongan. <br><a name="habracut"></a><br>  Seperti diketahui secara luas oleh sekelompok kecil orang, tempat di stack dialokasikan, pada kenyataannya, untuk variabel lokal yang digunakan fungsi saat ini - dengan pengecualian variabel dengan pengubah statis, yang disimpan dalam memori yang dialokasikan secara statis, di area bss, karena mereka harus menyimpan artinya antara panggilan fungsi. <br><br>  Ketika fungsi dieksekusi, kompiler menambahkan ruang pada stack untuk variabel yang dibutuhkannya, dan setelah selesai, ia membebaskan ruang ini kembali.  Tampaknya semuanya sederhana, tetapi - dan ini sangat berani <b>tetapi</b> - kami memiliki beberapa masalah: <br><br><ol><li>  fungsi memanggil fungsi-fungsi lain yang juga membutuhkan stack </li><li> terkadang fungsi memanggil fungsi lain bukan dengan referensi langsung mereka, tetapi dengan pointer ke suatu fungsi </li><li>  pada prinsipnya, dimungkinkan - meskipun harus dihindari dengan segala cara - fungsi rekursif memanggil ketika A memanggil B, B memanggil C, dan C di dalam dirinya sendiri memanggil A lagi </li><li>  kapan saja gangguan dapat terjadi, pawang yang fungsinya sama dengan yang ingin bagian tumpukannya sendiri </li><li>  jika Anda memiliki hierarki interupsi, interupsi lain dapat terjadi di dalam interupsi! </li></ol><br>  Jelas, panggilan fungsi rekursif harus dihapus dari daftar ini, karena kehadiran mereka adalah alasan untuk tidak mempertimbangkan ukuran tumpukan, tetapi untuk menyampaikan pendapat Anda kepada pembuat kode.  Segala sesuatu yang lain, sayangnya, tidak dapat dicoret dalam kasus umum (meskipun secara khusus mungkin ada nuansa: misalnya, semua interupsi untuk Anda dapat memiliki prioritas yang sama dengan desain, misalnya, seperti pada RIOT OS, dan tidak akan ada interupsi bersarang). <br><br>  Sekarang bayangkan sebuah lukisan cat minyak: <br><br><ul><li>  fungsi A, memakan 100 byte pada stack, memanggil fungsi B, yang membutuhkan 50 byte </li><li>  pada saat eksekusi B, A sendiri, jelas, belum selesai, jadi 100 byte tidak dibebaskan, jadi kita sudah memiliki 150 byte pada stack </li><li>  fungsi B memanggil fungsi C, dan melakukan ini sesuai dengan sebuah penunjuk yang, tergantung pada logika program, dapat menunjuk ke setengah lusin fungsi yang berbeda yang mengkonsumsi dari 5 hingga 50 byte tumpukan </li><li>  pada saat runtime C, terjadi interupsi dengan handler berat berjalan relatif lama dan menghabiskan 20 byte stack </li><li>  selama pemrosesan interupsi, interupsi prioritas tinggi lainnya terjadi, pawang yang menginginkan 10 byte stack </li></ul><br>  Dalam desain yang indah ini, dengan kebetulan yang sukses dari semua keadaan, Anda akan memiliki <i>setidaknya lima fungsi aktif secara bersamaan</i> - A, B, C dan dua penangan interupsi.  Selain itu, salah satu dari mereka tidak memiliki konstanta konsumsi tumpukan, karena itu bisa saja merupakan fungsi yang berbeda dalam lintasan yang berbeda, dan untuk memahami kemungkinan atau ketidakmungkinan saling mengganggu, Anda setidaknya harus tahu apakah Anda memiliki interupsi dengan prioritas yang berbeda sama sekali , dan sebagai maksimum - untuk memahami apakah mereka dapat saling tumpang tindih. <br><br>  Jelas, untuk penganalisa kode statis otomatis tugas ini sangat dekat dengan berlebihan, dan hanya dapat dilakukan dalam perkiraan kasar dari estimasi atas: <br><br><ul><li>  jumlah tumpukan semua penangan interrupt </li><li>  jumlah tumpukan fungsi yang berjalan di cabang kode yang sama </li><li>  coba temukan semua pointer ke fungsi dan panggilannya, dan ambil ukuran stack maksimum di antara fungsi yang ditunjuk pointer ini sebagai ukuran stack </li></ul><br>  Dalam kebanyakan kasus, Anda mendapatkan, di satu sisi, perkiraan yang sangat tinggi, dan di sisi lain, kesempatan untuk melewati beberapa pemanggilan fungsi yang sangat rumit melalui pointer. <br><br>  Oleh karena itu, dalam kasus umum, kita dapat mengatakan: <b>tugas ini tidak diselesaikan secara otomatis</b> .  Solusi manual - seseorang yang tahu logika program ini - membutuhkan penggalian beberapa angka. <br><br>  Namun demikian, perkiraan statis ukuran tumpukan dapat sangat berguna dalam mengoptimalkan perangkat lunak - setidaknya untuk tujuan sederhana memahami siapa yang makan banyak, dan tidak terlalu banyak. <br><br>  Ada dua alat yang sangat berguna untuk ini di GNU / gcc toolchain: <br><br><ul><li>  flag -fstack-use </li><li>  utilitas cflow </li></ul><br>  Jika Anda menambahkan -fstack-use ke flag gcc (misalnya, ke Makefile sejalan dengan CFLAGS), maka untuk <i>setiap</i> file yang dikompilasi% nama file% .c kompiler akan membuat file% nama file% .su, di dalamnya akan terdapat teks yang sederhana dan jelas. <br><br>  Ambil, misalnya, target.su untuk <a href="">alas kaki raksasa ini</a> : <br><br><pre><code class="plaintext hljs">target.c:159:13:save_settings 8 static target.c:172:13:disable_power 8 static target.c:291:13:adc_measure_vdda 32 static target.c:255:13:adc_measure_current 24 static target.c:76:6:cpu_setup 0 static target.c:81:6:clock_setup 8 static target.c:404:6:dma1_channel1_isr 24 static target.c:434:6:adc_comp_isr 40 static target.c:767:6:systick_activity 56 static target.c:1045:6:user_activity 104 static target.c:1215:6:gpio_setup 24 static target.c:1323:6:target_console_init 8 static target.c:1332:6:led_bit 8 static target.c:1362:6:led_num 8 static</code> </pre> <br>  Di sini kita melihat konsumsi sebenarnya dari stack untuk setiap fungsi yang muncul di dalamnya, yang darinya kita dapat menarik beberapa kesimpulan untuk diri kita sendiri - contohnya, bahwa ada baiknya mencoba mengoptimalkannya sejak awal, jika kita mengalami kekurangan RAM. <br><br>  Pada saat yang sama, perhatian, <b>file ini sebenarnya tidak memberikan informasi yang akurat tentang konsumsi aktual dari stack untuk fungsi-fungsi dari mana fungsi-fungsi lain dipanggil</b> ! <br><br>  Untuk memahami total konsumsi, kita perlu membangun pohon panggilan dan merangkum tumpukan semua fungsi yang termasuk dalam setiap cabangnya.  Ini dapat dilakukan, misalnya, dengan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU cflow</a> dengan mengaturnya pada satu atau lebih file. <br><br>  Knalpot di sini kita mendapatkan urutan besarnya lebih berat, saya hanya akan memberikan sebagian untuk target yang sama. C: <br><br><pre> <code class="bash hljs">olegart@oleg-npc /mnt/c/Users/oleg/Documents/Git/dap42 (umdk-emb) $ cflow src/stm32f042/umdk-emb/target.c adc_comp_isr() &lt;void adc_comp_isr (void) at src/stm32f042/umdk-emb/target.c:434&gt;: TIM_CR1() ADC_DR() ADC_ISR() DMA_CCR() GPIO_BSRR() GPIO_BRR() ADC_TR1() ADC_TR1_HT_VAL() ADC_TR1_LT_VAL() TIM_CNT() DMA_CNDTR() DIV_ROUND_CLOSEST() NVIC_ICPR() clock_setup() &lt;void clock_setup (void) at src/stm32f042/umdk-emb/target.c:81&gt;: rcc_clock_setup_in_hsi48_out_48mhz() crs_autotrim_usb_enable() rcc_set_usbclk_source() dma1_channel1_isr() &lt;void dma1_channel1_isr (void) at src/stm32f042/umdk-emb/target.c:404&gt;: DIV_ROUND_CLOSEST() gpio_setup() &lt;void gpio_setup (void) at src/stm32f042/umdk-emb/target.c:1215&gt;: rcc_periph_clock_enable() button_setup() &lt;void button_setup (void) at src/stm32f042/umdk-emb/target.c:1208&gt;: gpio_mode_setup() gpio_set_output_options() gpio_mode_setup() gpio_set() gpio_clear() rcc_peripheral_enable_clock() tim2_setup() &lt;void tim2_setup (void) at src/stm32f042/umdk-emb/target.c:1194&gt;: rcc_periph_clock_enable() rcc_periph_reset_pulse() timer_set_mode() timer_set_period() timer_set_prescaler() timer_set_clock_division() timer_set_master_mode() adc_setup_common() &lt;void adc_setup_common (void) at src/stm32f042/umdk-emb/target.c:198&gt;: rcc_periph_clock_enable() gpio_mode_setup() adc_set_clk_source() adc_calibrate() adc_set_operation_mode() adc_disable_discontinuous_mode() adc_enable_external_trigger_regular() ADC_CFGR1_EXTSEL_VAL() adc_set_right_aligned() adc_disable_temperature_sensor() adc_disable_dma() adc_set_resolution() adc_disable_eoc_interrupt() nvic_set_priority() nvic_enable_irq() dma_channel_reset() dma_set_priority() dma_set_memory_size() dma_set_peripheral_size() dma_enable_memory_increment_mode() dma_disable_peripheral_increment_mode() dma_enable_transfer_complete_interrupt() dma_enable_half_transfer_interrupt() dma_set_read_from_peripheral() dma_set_peripheral_address() dma_set_memory_address() dma_enable_circular_mode() ADC_CFGR1() memcpy() console_reconfigure() tic33m_init() strlen() tic33m_display_string()</code> </pre> <br>  Dan itu bahkan tidak setengah pohon. <br><br>  Untuk memahami konsumsi sebenarnya dari stack, kita perlu mengambil konsumsi untuk <i>masing</i> - <i>masing</i> fungsi yang disebutkan di dalamnya dan menjumlahkan nilai-nilai ini untuk masing-masing cabang. <br><br>  Dan sementara kita masih tidak memperhitungkan panggilan fungsi akun oleh pointer dan interupsi, termasuk.  bersarang (dan secara khusus dalam kode ini, mereka dapat disarangkan). <br><br>  Seperti yang Anda tebak, melakukan ini setiap kali Anda mengubah kode, untuk membuatnya lebih ringan, sulit - itulah sebabnya biasanya tidak ada yang melakukannya. <br><br>  Namun demikian, perlu untuk memahami prinsip-prinsip pengisian tumpukan - ini dapat menyebabkan pembatasan tertentu pada kode proyek, meningkatkan keandalannya dari sudut pandang mencegah tumpukan meluap (misalnya, larangan interupsi bersarang atau pemanggilan fungsi oleh pointer), dan khususnya -penggunaan simpanan sangat bisa membantu dengan optimasi kode pada sistem dengan kekurangan RAM. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443544/">https://habr.com/ru/post/id443544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443528/index.html">Amazon merilis Open Distro untuk Elasticsearch</a></li>
<li><a href="../id443530/index.html">Evolusi Infrastruktur Basis Data: Dari Basis Data dan Aplikasi pada Satu Server hingga Streaming Replikasi</a></li>
<li><a href="../id443532/index.html">5 fitur serbuk logam untuk pencetakan 3D</a></li>
<li><a href="../id443534/index.html">Compute Express Link - Interkoneksi untuk Data Besar</a></li>
<li><a href="../id443542/index.html">Titik Periksa Gratis Memulai Kursus Gratis R80.20</a></li>
<li><a href="../id443546/index.html">Toyota dan JAXA berencana untuk memiliki penjelajah berawak di bulan pada tahun 2029</a></li>
<li><a href="../id443548/index.html">Psikologi konsumen modern atau apa yang membantu kita membuat keputusan pembelian</a></li>
<li><a href="../id443556/index.html">Tenggat Waktu Pembakaran: Bagaimana Manajer Proyek Tidak Bisa Tersesat</a></li>
<li><a href="../id443568/index.html">Biografi Terry Davis, "programmer terbesar yang pernah hidup"</a></li>
<li><a href="../id443570/index.html">Kami tidak mengharapkan ini: surat terbuka tahunan dari Bill dan Melinda Gates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>