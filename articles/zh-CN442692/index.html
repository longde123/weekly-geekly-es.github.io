<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏫 😫 ⛹🏾 没有中介的区块链：我们如何将证券发送到分布式注册表 🐪 🚧 👈🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="历史上，所有经济活动都是建立在中介机构之上的。 双方之间任何甚至简单的交易都伴随着各种中介机构的介入，包括银行，交易所，票据交换所等。 排除中介人可能会使交互更加有效。 那么，为什么不尝试在区块链的基础上构建一个新的，去中心化的基础架构呢？ 在这篇文章中，我们将讨论如何开始我们的基础设施之旅：我们开...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>没有中介的区块链：我们如何将证券发送到分布式注册表</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/442692/"> 历史上，所有经济活动都是建立在中介机构之上的。 双方之间任何甚至简单的交易都伴随着各种中介机构的介入，包括银行，交易所，票据交换所等。 排除中介人可能会使交互更加有效。 那么，为什么不尝试在区块链的基础上构建一个新的，去中心化的基础架构呢？ 在这篇文章中，我们将讨论如何开始我们的基础设施之旅：我们开发了区块链交易，并最终进行了回购-由证券担保的货币贷款。 <br><br><img src="https://habrastorage.org/webt/5y/08/en/5y08enodezvkfd1qngslkh-pl4y.png"><br><a name="habracut"></a><br><h2> 短期债券 </h2><br> 我们在区块链上进行的第一个场外金融交易是MTS移动运营商的短期债券发行，国家清算所（NSD）参与了此次发行。 这是所有存托机构的“中央银行”。 存托机构是基础结构中介机构，保留证券所有者的记录并进行发行。 <br><br> 在该交易中，MTS通过调用智能合约的功能，在区块链中记录了将证券出售给Sberbank的意愿表达，并在区块链中确认其同意交易条款。  NSD收到了双方签署的抗辩令，并在其会计系统中执行了抗辩令。 此外，区块链还显示了证券和货币交易参与者的账户。 <br><br> 在该项目中，我们选择了开放源代码<i>Hyperledger Fabric 1.1</i>平台，该平台旨在创建封闭的企业区块链解决方案。 公共区块链在这里不合适，因为我们需要确保数据隐私。 我们在以太坊区块链上实施的M.Video在Sberbank的分解试验中遇到了这样的限制。 相比之下，Hyperledger Fabric允许您将交易中的所有参与者放置在专用渠道中，他们可以在其中交换任何必要的信息，并使用功能齐全的智能合约对其进行处理。 <br><br>  MTS债券发行项目的源代码已在GitHub上公开上传。 甚至无需深入研究工作算法，您就可以了解到，在交易的生命周期中，区块链在清算订单的传输中所起的作用不大。 另一方面，根据这些说明，帐户余额发生了变化-因此，从业务逻辑的角度来看，这比简单的电子文档管理服务更有趣。 <br><br> 该解决方案的主要优势是多功能性。  “两个交易对手和一个注册商”计划几乎涵盖了场外交易市场中的所有交易，并且变化很小-大部分是一般的商业交易。 <br><br><h2> 回购1.0 </h2><br> 在关于区块链的一个新项目中，我们决定展示如何在去中心化系统中实施回购协议-借贷证券。 通常，这些和其他OTC交易通过中介机构进行-托存机构，票据交换所，经纪人。 <br><br> 在该项目中，我们与Sberbank和外国合作伙伴签订了回购协议。 它已经使用了Hyperledger Fabric 1.2版。 与MTS债券相比，我们有两个区别： <br><br><ul><li> 交易中只有两个参与者连接到区块链，其存放人Euroclear和Clearstream通过传统数据传输渠道从Sberbank及其对手方的后台收到所有订单。 <br></li><li> 在智能合约中，我们实施了复杂的业务逻辑：将用作贷款抵押品的证券的每日报价下载到了区块链中，并且智能合约考虑了抵押品成本的变化，折扣，退出交易所的日历等参数，计算了提前还款的需求和金额。 没有分布式注册表，就无法获得参与者之间计算算法的这种P2P同步。 这比双方独立计算债务和金额要方便得多-无需费时的对帐，无需确认。 <br></li></ul><br> 交易对手之间在渠道内组织了聊天和工作流程。 它们上的数据存储在区块链中。 分布式注册表中的每次更改后，渠道成员都会收到一封电子邮件警报。 <br><br> 我们从法律角度制定了“ REPO 1.0”。 在一家大型律师事务所的帮助下，对伦敦高等法院的案件进行了分析。 此外，银行及其交易对手的EDS使用不同的密码算法。 <br><br><h3>  REPO 1.0如何工作？ </h3><br> 交易的每一方都有自己的区块链节点。 所有节点在P2P网络中相互连接。 假设您需要达成协议。 我们在交易各方之间部署智能合约，其中对金融工具进行了充分描述。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/e38/b7e/f42e38b7e23eac1217952790f217a4e9.png"><br><br> 在我们完成合同创建后，交易员将其签字。 客户还审查并签署合同。 然后对签名进行审查和验证。 在这种情况下，交易是根据英国法律进行的，有关电子数字签名的数据已输入GMRA文件中。 为了由客户进行签名，需要验证签名证书中是否存在授权人。 最后，客户接受合同并同意所有条件。 您可以将任意数量的文档附加到已签订的合同中。 <br><br> 此后，合同将获得“工作中”状态。 加载新的市场价格后，将自动重新计算“进行中”的合同。 如果合同中有担保，则采用市场价格，重新计算“贷款价值”（LTV）-贷款额与担保价值之比。  LTV是回购交易中的关键术语之一，其含义已在合同中规定。 股票价格急剧上涨-LTV变得比GMRA所指示的要少（涉及英国法律时）。 因此，由于考虑到新价格，银行将证券返还给客户（作为一种选择），因此证明银行拥有更高的安全性。 <br><br> 但是，如果LTV变大，则该程序允许您打印抵押品通知-向客户发出有关需要增加额外安全性（股票或金钱）的通知，以便LTV值恢复为初始值。 以前，附带通知只能通过邮件发送，为此创建了单独的文档，并且在创建这些文档期间，LTV可能会再次更改。 现在，我们可以在线查看与客户端相同的计算，我们可以轻松地进行交互。 <br><br> 此外，该计划每天都在考虑利息的情况下确定股票回购的价格。 如果客户在加载市场价格时不同意该价格，他会查看完整的重新计算日志-什么是什么，变成了什么，加载了什么价格，来自何处。 然后，聊天讨论开始。 <br><br><h2>  REPO 2.0 </h2><br> 我们希望区块链上的REPO能够根据我们的内部逻辑启动真实资产的移动。 但是在REPO 1.0中，由于在连接西方存托机构方面存在组织上的困难，我们尚未能够实现这一目标。 因此，我们开始了新的Repo 2.0试验。 他有两个目标： <br><br><ul><li> 交易应在两方和托管人的参与下进行，以充分利用MTS债券项目的基础设施。 <br></li><li> 需要授权区块链重新评估抵押品并建立保证金催缴，该催缴催缴可以由连接到分布式网络的托管机构自动执行。 <br></li></ul><br>  NSD立即想连接到该项目。 为了使区块链中发起的交易落入管辖国内金融市场的联邦法律的保守领域，我们与律师合作制定了一份五页的电子文档管理协议补充协议。 该文件已由交易各方和NSD签署。 <br><br>  NSD在此交易中充当交换所。 他执行了有关资金和证券流动的所有指示。 此交易是根据俄罗斯法律完成的。 <br><br> 客户接受了带有电子签名的合同。 然后，该协议被Sberbank签署并接受-它检查了所有参数是否符合必要的值以及接受客户人员的权限。 此后，合同开始生效。  NSD上传了市场数据，重新计算了智能合约。 <br><br><h3>  REPO 2.0如何工作？ </h3><br> 为了部署网络并使用链代码与客户端接口进行交互，我们使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fabric Starter</a>解决方案。 它提供了REST API，而不是HLF的标准grpc接口，在我们的案例中，它显着降低了集成的复杂性。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07a/86a/997/07a86a997c7017a122b03aad7995f6ad.png"><br><br> 网络如下。 在Docker服务器上进行预安装之后，三个方面中的每一个都启动了Fabric Starter，后者创建了带有节点组件的容器。 这些组件包括一个用于与其他组织进行交互的外部同位体以及一个REST API服务，节点通过该服务与客户端应用程序进行交互。 在Starter启动时，还配置了区块链网络，并创建了一个专用渠道，在其中安装了具有背书策略的链代码。 在我们的案例中，每笔交易都必须具有所有三个参与者的签名。 <br><br> 在测试阶段，使用Docker Swarm来组织参与者服务器的连接，但是，为了达成一项真正的协议，他们切换到了DNS。 该平台本身负责消息传输；数据通过TLS加密通过Internet传输。 <br><br><h2> 问题的技术方面 </h2><br> 在HLF上开发分布式应用程序的过程非常传统地开始-从数据结构和链代码（实际上是一组存储过程）开始，对它们的调用导致从分类账中存储，修改或读取这些结构。 该平台允许使用各种编程语言来开发链代码和用于本地存储的DBMS。 我们分别更喜欢Go和CouchDB。 <br><br> 在我们的数据模型中，回购项目的核心要素是合同本身及其附属义务。 它们是针对两个飞行员中的每个飞行员以及追加保证金而创建的。 与基于“订单”本质的MTS债券模型相比，该体系结构向前迈了一大步。 还为证券创建了独立的对象，从而对它们进行了部分标记。 但是在进行帐户管理和虚拟虚拟货币化实验的过程中，我们决定推迟到该解决方案的下一个版本。 <br><br> 我们解决方案的主要功能： <br><br><ul><li> 创建合同。 <br></li><li> 与您的EDS签订合同，确认已接受合同条款。 <br></li><li> 下载市场价格并开始重新计算抵押品价值。 它偏离设定的阈值导致了新的追加保证金义务。 <br></li><li> 反映义务的状况。 <br></li></ul><br> 在技​​术方面，重估程序在这里最有趣。 让我们更详细地分析它。 <br><br> 在业务流程中，应在Oracle（由NSD执行的“ REPO 2.0”试点）将更新后的证券报价上载到系统后，每天执行一次该程序。 <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *CIBContract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recalculationData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface, loadData *loadDataType, curDay </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> {...}</code> </pre> <br> 该过程的主要周期遍历所有已更新其报价的证券。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, securities := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Securities {...}</code> </pre> <br> 接下来，进行几次检查。 例如，如果今天接收市场数据的交易所是休息日，则不应进行重新计票。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.checkHoliday(stub, contract.Settings.Calendars) == <span class="hljs-string"><span class="hljs-string">"yes"</span></span> { hisYes := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"LoadData. Calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Today is holiday ! No load market data to contract !"</span></span>} ... contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, hisYes) … err = stub.PutState(contrID, contractJSONasBytes) }</code> </pre><br> 为了计算更新的债券价格，应将累计的息票收益率（NDC）添加到加载的净价格中。 该试点为计算NKD的30/360方案提供了支持。 <br><br><pre> <code class="go hljs">priceIzm = <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.Price + <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(securities.CouponRate)*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Year()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Year()))*<span class="hljs-number"><span class="hljs-number">360</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Month()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Month()))*<span class="hljs-number"><span class="hljs-number">30</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(settlementDate.Day()) - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(dateStart.Day())))*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">360</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>) curCurrVal = priceIzm</code> </pre><br> 如果交易货币不同于证券的报价货币，则进行兑换。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> contract.GeneralTerms.PurchasePrice.Currency != securities.Currency { curCurrName = securities.Currency + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + contract.GeneralTerms.PurchasePrice.Currency               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, currency := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> loadData.Currencies {              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currency.Name == curCurrName {                           curCurrVal = priceIzm * currency.Value } } }</code> </pre><br> 现在我们需要计算LTV。 保留故事的旧系数值。 <br><br><pre> <code class="go hljs">oldCurLTV := contract.MarginingTerms.CurrentLTV</code> </pre> <br> 必须考虑在交易有效期内执行的追加保证金要求。 需求可以来自双方，并且有两种形式： <br><br><ul><li> 证券。 如果有价证券的市场价格下跌，借款人将提供额外的有价证券。 如果价格上涨，债权人归还部分担保。 <br></li><li> 钱 借款人提前偿还了不再由廉价抵押品支付的那部分贷款。 贷方根据抵押品价值的增加而增加贷款额。 <br></li></ul><br> 在第一种情况下，只需更新抵押品中的证券数量。 并且如果要靠它们赚钱，还必须累积交易附加条款中规定的获利能力。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addCollateral := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> contract.MarginingTerms.AddCollateral { currSumCollateral := addCollateral.Sum + (addCollateral.Sum*contract.MarginingTerms.RateOnCashMargin*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaColDate) / <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span> ... allSumCollateral = allSumCollateral + currSumCollateral ... ht := historyType{curDay, System<span class="hljs-string"><span class="hljs-string">", "</span></span>LoadData. Recalculation data(addCollateral) Contract <span class="hljs-string"><span class="hljs-string">" + contrID + "</span></span> - currSumCollateral: <span class="hljs-string"><span class="hljs-string">" + strconv.FormatFloat(float64(currSumCollateral), 'f', 2, 64) ... }        ... contract.History = append(contract.History, ht) }</span></span></code> </pre> <br> 我们计算回购的总金额-实际上，这是我们需要偿还的带息贷款的金额。 <br><br><pre> <code class="go hljs">rePurchasePriceCur := contract.GeneralTerms.PurchasePrice.Sum + (contract.GeneralTerms.PurchasePrice.Sum*contract.GeneralTerms.RepoRate*<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(deltaSigningDate)/<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.Basis))/<span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br> 现在我们计算LTV系数。 为此，我们从回购价格中减去现金证券，然后将结果值除以证券中的证券总值。 债权人贷记的金额标有“-”，并将添加到回购价格中。 <br><br><pre> <code class="go hljs">contract.MarginingTerms.CurrentLTV = (rePurchasePriceCur - allSumCollateral) * <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) / (<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.GeneralTerms.PurchasedSecurities.Quantity) * curCurrVal)</code> </pre><br> 最后，我们计算合同中的触发器。 如果LTV值偏离指定的通道，则相同的过程将创建追加保证金的订单对象。 <br><br><pre> <code class="go hljs">contract = t.checkTriggerEvents(stub, <span class="hljs-string"><span class="hljs-string">"LoadData"</span></span>, contract, curDay, securities)</code> </pre><br> 并将信息写入历史记录以在UI上显示。 <br><br><pre> <code class="go hljs">ht := historyType{curDay, <span class="hljs-string"><span class="hljs-string">"System"</span></span>, <span class="hljs-string"><span class="hljs-string">"LoadData. Recalculation data(change curLTV, ADTV) Contract "</span></span> + contrID + <span class="hljs-string"><span class="hljs-string">" - oldCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(oldCurLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) + <span class="hljs-string"><span class="hljs-string">", newCurLTV: "</span></span> + strconv.FormatFloat(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(contract.MarginingTerms.CurrentLTV), <span class="hljs-string"><span class="hljs-string">'f'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)...} contract.History = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(contract.History, ht)</code> </pre> <br><h2> 总结一下 </h2><br> 这种方案不仅适用于证券和合约，而且还适用于其他情况。 例如，对于具有不同电价，不同时间的不同连接的电力供应。 或通过保理-通过发货信号向供应商提供贷款。 在经济学中有许多用例，每个人都必须使用自己的数据源进行验证。 <br><br> 我们的目标是创建一个网络，该网络将银行之间以及全国范围内的客户相互连接，并使用智能合约在其中描述不是加密货币而是传统经济合约的金融工具。 这样的网络将是稳定，开放的，并且，正如它应该在P2P网络中一样，这里没有人会具有特殊的地位。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442692/">https://habr.com/ru/post/zh-CN442692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442682/index.html">输入什么以及如何组装C ++项目</a></li>
<li><a href="../zh-CN442684/index.html">平衡网站性能。 第3部分：内容</a></li>
<li><a href="../zh-CN442686/index.html">DataPower教程</a></li>
<li><a href="../zh-CN442688/index.html">Scala数据分析-迫切需要还是令人愉快的机会？</a></li>
<li><a href="../zh-CN442690/index.html">月球任务“ Bereshit”-地球背景下的自拍照</a></li>
<li><a href="../zh-CN442694/index.html">其中一家流媒体巨头在印度推出，一周吸引了100万用户</a></li>
<li><a href="../zh-CN442696/index.html">S for Security：InoThings ++ 2019的物联网安全和报告</a></li>
<li><a href="../zh-CN442698/index.html">Windows Store的Moscow Metro应用程序</a></li>
<li><a href="../zh-CN442700/index.html">处理移动式太阳能发电厂值得吗？</a></li>
<li><a href="../zh-CN442702/index.html">关于MIPT的Tinkoff.ru裁判法院</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>