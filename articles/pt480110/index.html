<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏽 👌🏼 🏂 uMCPIno: Escrevendo um protocolo simples com entrega garantida para o Arduino 👩🏼‍🌾 👩 💪🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saudações, queridos! 
 Em algum momento de sua vida, cada caixa teimosa e teimosa deixa de sentir falta do Kantian Arduino como "coisas em si mesmas" ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>uMCPIno: Escrevendo um protocolo simples com entrega garantida para o Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480110/"><h3>  Saudações, queridos! </h3><br>  Em algum momento de sua vida, cada caixa teimosa e teimosa deixa de sentir falta do Kantian Arduino como "coisas em si mesmas" <s>que simplesmente não podem!</s>  : Piscando o LED, pegando dados dos sensores e transferindo-os pelo fio para o PC é certamente divertido, mas o Santo Graal está em mobilidade, em libertação das “ligações de cobre”, em verdadeira liberdade entre as ondas do éter universal. <br>  É aqui que a dura realidade dos canais de comunicação instáveis, erros de transmissão e mensagens não entregues se abre para nós. <br>  Deus proíbe reivindicar originalidade nesta área: a humanidade há muito tempo usa muitos protocolos para todas as ocasiões. <br>  Mas nosso objetivo é aprender e, como sou um fervoroso defensor do reconhecimento em combate, estudaremos inventando nosso próprio protocolo “bicicleta”. <br>  Hoje, proponho desenvolver um protocolo que garanta entrega garantida, integridade e sequência de mensagens entre dois assinantes (ponto a ponto, ponto a ponto), saiba como e aplique o algoritmo <a href="https://en.wikipedia.org/wiki/Nagle%2527s_algorithm" rel="nofollow">Nagle</a> e o <a href="https://en.wikipedia.org/wiki/Protocol_pipelining" rel="nofollow">pipelining de protocolo</a> , seja lá o que isso signifique.  Ao mesmo tempo, ele deve ter uma <a href="https://en.wikipedia.org/wiki/Overhead_(computing)" rel="nofollow">sobrecarga</a> mínima e apertar até o apertado UNO do Arduino. <br><br><img src="https://habrastorage.org/webt/jt/7a/_b/jt7a_bc6uynr5uu08ab3plyuucq.png"><br><br>  Peço a todos os interessados ​​a bordo, fechamos as escotilhas, abrimos as pedras do rei, enchemos os tanques de lastro.  Temos uma excursão ao passado, destino: ano 1974! <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Para os impacientes (eu mesmo sou assim!)</b> <div class="spoiler_text">  Aqui está o repositório do github onde estão as implementações: <br><ul><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">Para arduino</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/STM32" rel="nofollow">Para STM32</a> </li><li>  <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/CSharp" rel="nofollow">Para PC (C #)</a> </li></ul><br></div></div><br>  De acordo com a boa e velha tradição, pelo menos dois especialistas reconhecidos neste campo estão envolvidos na descrição de algoritmos e protocolos criptográficos, se alguém não os conhece, familiarize-se: <br><div class="spoiler">  <b class="spoiler_title">Alice</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/6f4/f08/fb46f4f081e1affbfba68c39dcbc7768.jpg" alt="imagem"><br></div></div><br>  E <br><div class="spoiler">  <b class="spoiler_title">Bob</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/048/a75/668/048a75668215c8147df3f5720f283899.jpg" alt="imagem"><br></div></div><br><br><h3>  Primeiro, descrevemos uma tarefa simples </h3><br>  Alice e Bob estão sentados em trincheiras adjacentes e não podem levantar a cabeça para se ver.  Eles podem falar apenas em voz alta, ao lado deles as balas apitam e os projéteis explodem, afogando seus gritos e, além disso, quando um deles fala, você precisa gritar para não ouvir nada. <br>  A situação é complicada pelo fato de eles estarem sendo ouvidos pelos inimigos - e você precisa usar uma linguagem de código, por algum motivo que consiste em longas sequências de números. <br>  Como Alice e Bob são pessoas, eles periodicamente precisam sair para comer ou ir ao banheiro, e são tão impacientes que podem ficar impacientes no momento mais inoportuno! <br><br><h3>  Como e por que estabelecer uma conexão? </h3><br>  Como podemos organizar uma transferência de dados confiável em uma situação tão deprimente, quando parece que tudo está simplesmente fadado ao fracasso? <br><br>  A primeira solução que pode surgir é usar frases de código com <s>palavras de parada</s> para iniciar e terminar a transferência. <br><br>  Bem, digamos que, se Alice quiser enviar uma mensagem, ela precisa gritar "Comece a transmissão!" E espere até Bob responder "Comece a recepção!". <br>  Se Alice não esperar pela resposta de Bob, ela simplesmente repetirá sua solicitação para iniciar a transferência.  Naturalmente, você não deve fazer isso com muita frequência; caso contrário, como sabemos, você simplesmente não ouve a resposta de Bob. <br><br>  Ótimo.  Mas o que acontece se Alice em resposta ouvir da próxima trincheira, "Começar a transmissão!"? <br>  Acontece que Bob também decidiu transferir algumas informações importantes agora.  Alice tem um caráter moderado, e ela pode ter pensado: "Ok, vou esperar, minha mensagem é, em princípio, não urgente, deixe Bob passar primeiro."  Pensando nisso, ela responde: "Comece a recepção!". <br><br>  Como <s>em tempo de guerra o valor do seno pode chegar a quatro, a</s> velocidade do som é finita e leva algum tempo para compreender o que Alice e Bob ouviram, e até Bob, como cavalheiro, pode decidir ceder à dama, ele dá de ombros e grita: "Estou começando a receber!" <br><br>  Para ilustrar a indignação, usaremos gráficos de tempo.  O tempo passa para eles. <br><br>  O caso em que Alice e Bob não chegaram a acordo sobre o prazo: <br><img src="https://habrastorage.org/webt/cz/ye/hn/czyehnoehw9e3wnxveaiwvef5ok.png"><br><br>  O caso em que a mensagem foi perdida: <br><img src="https://habrastorage.org/webt/5u/yk/md/5uykmdq7sxiagt-5twd3uhpnxas.png"><br><br>  Isso é um fiasco.  Tudo fica confuso demais e é agravado pelo fato de o destinatário poder ouvir ou não ouvir alguma das frases e, em cada caso, o interlocutor não sabe se sua mensagem foi ouvida pelo destinatário. <br><br>  Agora, Alice e Bob estão esperando um bem-vindo.  Seria lógico perceber que ocorreu um conflito e alguém precisa retomar a transmissão.  Mas e se tudo acontecer novamente de uma nova maneira?  E aqui estamos novamente onde começamos. <br><br>  Se você acha que a situação é extremamente rara, lembre-se da última vez em que você conversou com alguém por voz, quando seu assinante ou você (ou ambos) tiver uma conexão lenta à Internet.  "Olá, olá, olá, você desaparece."  "Você não pode ouvir olá, olá." <br><br>  Enquanto isso, nas trincheiras, a situação está esquentando, os comandantes exigem a transmissão de relatórios. <br>  É hora <s>de recorrer às fontes principais: para estudar Marx, Engels</s> retornará mais de 40 anos atrás e verá como esses problemas foram resolvidos pelos engenheiros da <a href="https://en.wikipedia.org/wiki/Digital_Equipment_Corporation" rel="nofollow">DEC</a> ao projetar o protocolo <a href="https://en.wikipedia.org/wiki/Digital_Data_Communications_Message_Protocol" rel="nofollow">DDCMP</a> . <br><br>  Segundo os desenvolvedores do DDCMP, Alice e Bob precisam rejeitar emoções e se tornarem <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow">máquinas de estado finito</a> . <br>  Isso significa que, a partir de agora, nossa Alice e Bob terão apenas alguns estados fixos, as transições entre esses estados poderão ocorrer estritamente de acordo com certas regras quando certos eventos ocorrerem. <br><br>  Primeiro, simplesmente listamos os estados: <br><br><ul><li>  Interrompido </li><li>  INÍCIO INICIAL </li><li>  INÍCIO RECONHECIDO </li><li>  EXECUTANDO </li></ul><br><br>  Como você pode ver, existem apenas quatro deles.  E agora, não importa o que aconteça, cada um dos assinantes sabe ao menos com certeza que o seu vis-à-vis está em apenas um desses estados.  De fato, olhando um pouco à frente, direi que quase sempre um assinante saberá em que estado está o segundo assinante, <s>mas isso não é exato</s> . <br><br><h3>  Vamos considerar os estados separadamente, em detalhes </h3><br>  <b>HALTED</b> é o estado mais simples, ninguém vai a lugar algum, todos permanecem em seus lugares, nada é transmitido e não recebido, nenhum estímulo externo é ignorado.  Todos, exceto um - a vontade das autoridades superiores.  No protocolo DDCMP original, a transição do estado <b>HALTED</b> só pode estar no estado <b>INICIAL INÍCIO</b> a pedido do usuário - Alice ou Bob recebem um pedido para estabelecer uma conexão. <br><br>  O que acontece quando Alice ou Bob recebem esse pedido? <br>  Eles notam imediatamente a si mesmos que o estado mudou de <b>INÍCIO INICIAL</b> , e essa transição, como qualquer outra, envolve uma sequência de ações estritamente definida.  Nesse caso, você precisa gritar “DO IT!” E ajustar o relógio.  Só isso. <br><br>  Então, Alice gritou o que era necessário e apertou um botão no cronômetro.  Agora, para entender o que esperar de Bob, descobriremos o que pode acontecer com Alice quando ela estiver no estado <b>INICIAL INÍCIO</b> . <br><br>  - A partir do momento em que Alice notou que o tempo passou, digamos 10 segundos e ela não ouviu nenhuma reação de Bob (observe, eu não estou dizendo que Bob não gritou nada para ela - isso não é conhecido, mas apenas que Alice não sabe nada) ouvida durante esse período, Alice é uma mulher sábia e racional e depende apenas de fatos).  Chamamos esse evento de tempo limite - o intervalo de espera foi excedido.  Nesse caso, o protocolo nos diz para repetir: grite “FAÇA UMA VEZ!” E repita a hora.  Ainda não grosso. <br><br>  - Se Alice ouviu que Bob gritou a mesma coisa - "FAÇA UMA VEZ!", Então Alice entra de forma <b>não seletiva</b> no estado <b>INÍCIO RECONHECIDO</b> , sobre o qual ela deve gritar imediatamente "FAÇA DOIS!" E acerte o relógio novamente. <br><br>  - Mais uma vez, se Alice ouviu Bob fazer "DOIS!", Então ela imediatamente entra no estado <b>EXECUTANDO</b> (!), Grita "ACEITOU NOOOOOL!".  Se o cronômetro foi iniciado, ela o desliga da linha da frente da cautela. <br><br>  É muito importante não fazer movimentos desnecessários que não sejam previstos pelo estado atual.  O que quer que Bob chore, não importa o quanto xingue ou implore, Alice só reage conforme combinado. <br><br>  É conveniente apresentar essas coisas na forma de uma tabela.  Então, vamos começar com os <b>estados HALTED</b> e <b>INITIAL START</b> já descritos e, em seguida, reabasteceremos mais a tabela. <br><br><div class="scrollable-table"><table><tbody><tr><th>  ESTADO ATUAL </th><th>  EVENTO <br></th><th>  NOVA CONDIÇÃO </th><th>  AÇÃO <br></th></tr><tr><td>  QUALQUER UM </td><td>  A ordem "interromper a conexão" </td><td>  Interrompido <br></td><td></td></tr><tr><td>  Interrompido <br></td><td>  Encomende "Connect" <br></td><td>  ESTADO INICIAL </td><td>  1) Grite "FAÇA UMA VEZ!" <br>  2) Inicie o temporizador <br></td></tr><tr><td rowspan="3">  INÍCIO INICIAL <br></td><td>  Eu ouvi "FAÇA UMA VEZ!" <br></td><td>  INÍCIO RECONHECIDO <br></td><td>  1) Grite "DOIS!" <br>  2) Inicie o temporizador <br></td></tr><tr><td>  Eu ouvi "DOIS!" </td><td>  EXECUTANDO <br></td><td>  1) Grite "NOOOL ACEITO!" <br>  2) Pare o cronômetro <br></td></tr><tr><td>  O tempo acabou - tempo limite </td><td>  INÍCIO INICIAL <br></td><td>  1) Grite "FAÇA UMA VEZ!" <br>  2) Inicie o temporizador <br></td></tr></tbody></table></div><br><br>  Omiti conscientemente alguns pontos da descrição original do DDCMP - não precisamos deles, queremos não apenas repetir o DDCMP, mas construir com base <s>no mesmo, apenas outro</s> novo protocolo. <br><br>  Mas voltando à descrição de estados e transições.  O próximo estado é <b>INÍCIO RECONHECIDO</b> . <br>  Sendo neste estado, tudo o que pode preocupar Alice ou Bob é: <br><br>  - como antes, a expiração do tempo de espera, nesse caso, você precisa permanecer no mesmo estado, gritar "DOIS!" E iniciar o temporizador novamente <br><br>  - o “DOIS!” ouvido se traduz no estado <b>RUNNING</b> , enquanto grita “NOOOOL LOGO ACEITADO!” E pare o temporizador; <br><br>  - o ouvido “DO IT!” Sai no mesmo estado, você precisa gritar “DOIS!” E iniciar o temporizador; <br><br>  - ouviu “NOOOL ACCEPTED!” - transição para o estado <b>RUNNING</b> , pare o temporizador. <br><br>  Colocamos tudo isso em uma tabela. <br><div class="scrollable-table"><table><tbody><tr><th>  ESTADO ATUAL </th><th>  EVENTO <br></th><th>  NOVA CONDIÇÃO </th><th>  AÇÃO <br></th></tr><tr><td rowspan="4">  INÍCIO RECONHECIDO <br></td><td>  Eu ouvi "FAÇA UMA VEZ!" <br></td><td>  INÍCIO RECONHECIDO <br></td><td>  1) Grite "DOIS!" <br>  2) Inicie o temporizador <br></td></tr><tr><td>  Eu ouvi "DOIS!" </td><td>  EXECUTANDO <br></td><td>  1) Grite "NOOOL ACEITO!" <br>  2) Pare o cronômetro <br></td></tr><tr><td>  Ouvi "NOOOL ACEITO!" </td><td>  EXECUTANDO <br></td><td>  1) Pare o cronômetro <br></td></tr><tr><td>  O tempo acabou - tempo limite </td><td>  INÍCIO RECONHECIDO </td><td>  1) Grite "DOIS!" <br>  2) Inicie o temporizador <br></td></tr></tbody></table></div><br><br>  Com um aperto de mão, quase tudo está pronto - resta considerar apenas um estado <b>RUNNING</b> , porque um dos assinantes já pode entrar nele e o segundo - corre urgentemente para o banheiro, e quando ele volta, esquece tudo e tenta estabelecer uma nova conexão. <br><br>  Do ponto de vista do procedimento de handshake (ainda não lidamos com a transferência de dados, para a qual tudo foi iniciado - esta é uma história separada) no estado <b>RUNNING</b> , estamos interessados ​​em dois eventos: <br><br>  - se eles gritarem para nós "FAÇA UMA VEZ!" - tudo está muito ruim, é uma dessincronização completa, tudo precisa ser reiniciado.  O protocolo original <b>instrui</b> você a simplesmente entrar no estado <b>HALTED</b> .  Mas isso não nos ajudará de forma alguma - se, por algum motivo, isso aconteceu em um Arduino autônomo, que transmite alguns dados de alguns sensores, então, para nós, é uma falha completa.  Como sabemos, de <b>HALTED</b> você pode ir para <b>INICIAL START</b> apenas por ordem das autoridades. <br>  Portanto, estamos modificando o protocolo aqui: a recepção no estado <b>HALTED</b> do <b>comando</b> "DO ONCE!" Deve funcionar como uma ordem das autoridades - ou seja,  <b>mude para o</b> estado <b>INICIAL INÍCIO</b> , grite “FAÇA UMA VEZ!”, inicie o cronômetro.  Além disso, em alguns casos, é conveniente dar uma ordem para estabelecer comunicação imediatamente após o fornecimento de energia a si mesmo. <br>  Assim, agora, no caso mais inconveniente, simplesmente redefiniremos a conexão. <br><br>  - o segundo evento ao qual é necessário reagir no estado <b>RUNNING</b> - se ouvirmos "DOIS!" De uma trincheira vizinha.  Isso já é mais interessante.  Nesse caso, você precisa gritar “ER ACEITO!”. Onde ER significa o número de mensagens recebidas com sucesso na atual sessão de comunicação.  Este é um novo conceito.  Abaixo, consideraremos tudo com mais detalhes, mas, por enquanto, traremos tudo o que aprendemos para o momento atual em uma tabela: <br><br><div class="scrollable-table"><table><tbody><tr><th>  ESTADO ATUAL </th><th>  EVENTO <br></th><th>  NOVA CONDIÇÃO </th><th>  AÇÃO <br></th></tr><tr><td rowspan="4">  INÍCIO RECONHECIDO <br></td><td>  Eu ouvi "FAÇA UMA VEZ!" <br></td><td>  INÍCIO RECONHECIDO <br></td><td>  1) Grite "DOIS!" <br>  2) Inicie o temporizador <br></td></tr><tr><td>  Eu ouvi "DOIS!" </td><td>  EXECUTANDO <br></td><td>  1) Grite "NOOOL ACEITO!" <br>  2) Pare o cronômetro <br></td></tr><tr><td>  Ouvi "NOOOL ACEITO!" </td><td>  EXECUTANDO <br></td><td>  1) Pare o cronômetro <br></td></tr><tr><td>  O tempo acabou - tempo limite </td><td>  INÍCIO RECONHECIDO </td><td>  1) Grite "DOIS!" <br>  2) Inicie o temporizador <br></td></tr></tbody></table></div><br><br>  Agora, se Alice e Bob seguem estritamente o protocolo, eles simplesmente não têm opções <s>para entrar em</s> algo <s>incompreensível</s> , exceto como estabelecer uma conexão, alternando em conjunto para o estado <b>RUNNING</b> ou, em um caso ruim, tentando estabelecê-lo antes da vitória ser <s>clicada</s> . <br><br>  Um leitor agressivo pode tentar examinar todas as opções e chegar à conclusão de que a série de estados e transições acaba sendo fechada e estritamente determinada.  Nós (com a ajuda das mentes dos engenheiros do DEC) agora amarramos Alice e Bob com um conjunto de regras que simplesmente seguem as quais eles estabelecerão uma conexão, se nas condições atuais isso for geralmente possível em princípio. <br><br><h3>  Como transferir dados agora? </h3><br>  Ok, isso foi um bom treino.  Período de doces-buquê no relacionamento de dois nós da rede.  Lembre-se de que iniciamos um negócio: precisamos transferir dados com entrega garantida e prioridade!  Com recuperação de desastres.  Na medida em que os recursos de hardware permitem isso (afinal, Alice e Bob podem se mostrar controladores fracos de 8 bits com 2 kilobytes de RAM!). <br><br>  Os engenheiros do DEC nos ensinam que as mensagens que precisamos numerar, precisamos contar quanto enviamos, quantas recebemos e quantas das mensagens que enviamos chegaram ao destinatário. <br><br><div class="spoiler">  <b class="spoiler_title">É hora de uma digressão!</b> <div class="spoiler_text">  Admita.  quando vi os nomes das variáveis ​​na descrição do protocolo DDCMP, decidi que não foi por acaso: os americanos gostam muito de atrair belas abreviações por seus ouvidos. <br><br>  Para nossa conveniência, existem até vários recursos em que os interessados ​​podem tocar o belo. <br>  O meu favorito é este - <a href="https://www.cfa.harvard.edu/~gpetitpas/Links/Astroacro.html" rel="nofollow">Site de acrônimos astronômicos mudos ou excessivamente forçados (ou DOOFAAS)</a> <br><br>  Quanto valem essas fabricações! <br>  Aqui está um exemplo: <br><br>  <b>WASP</b> - Espectrômetro analógico de banda larga (mas não exatamente o que você pensava!) <br>  <b>SAURON</b> - Unidade Espectroscópica de <b>Área</b> para Pesquisa em Nebulosas Ópticas <br>  <b>CISCO</b> - Espectrógrafo infravermelho e câmera refrigerados para OHS (é isso que significa!) <br><br>  E aqui, apenas atire: <br>  <b>SQUIRT</b> (ah, sim, artigo 18+!) - Satettile QUICK Research Testbed <br>  <b>MERDA</b> (nem mais nem menos!) - Telescópio Interferométrico Super Enorme, com a inscrição “procure você mesmo”, ao qual o link para o resumo está anexado ao artigo com o mesmo nome. <br><br>  Portanto, as variáveis ​​que indicam o número de pacotes recebidos, enviados e entregues no nó na descrição original do protocolo são denominadas <b>RNA</b> . <br><br>  Ah, por que eles não nomearam o protocolo dessa maneira - RNA!  Uma espécie de rede de RNA.  Os protocolos DECnet tinham todas as chances de se tornar protocolos da Internet se a história tivesse sido diferente. <br></div></div><br><br><h3>  Mas voltando às nossas trincheiras </h3><br>  O padrão de protocolo original define que todos os contadores são de 8 bits e aumentam o módulo 256. Isso significa que pode haver um máximo de 256 mensagens enviadas para as quais a confirmação ainda não foi recebida. <br>  E, se a confirmação não for recebida, eles poderão precisar ser retransmitidos e, se necessário, deverão ser armazenados até a confirmação.  Afinal, temos entrega garantida! <br><br>  Os parâmetros físicos de nossa Alice e Bob nos ditam condições diferentes.  No Arduino de 8 bits, essa quantidade de dados simplesmente não existe para armazenar e temos que comprometer.  E não estou falando do fato de que, no padrão, o tamanho dos pacotes (mensagens) em bytes é limitado a um número de 16 bits, ou seja,  64 kilobytes é um luxo inadmissível! <br><br><h3>  Portanto, a conexão é estabelecida.  O que vem a seguir? </h3><br>  No momento em que Alice ou Bob <b>entram no</b> estado <b>RUNNING</b> , os contadores são redefinidos. <br>  Como já mencionei, o protocolo original envolve a numeração de mensagens no módulo 256, mas temos que reduzir esse número para se adequar à pequena quantidade de memória em coisas do tipo Arduino. <br>  Para poder limitar imediatamente todos os incrementos de contadores, apresentaremos uma certa constante UMCP_PACKETS_NUMBER, e agora todos os incrementos ocorrerão neste módulo. <br><br>  Se você usar UMCP_PACKETS_NUMBER = 8, e o tamanho máximo do pacote for UMCP_PACKET_DATA_SIZE - as partes dos dados transmitidos por vez são limitadas a 64 bytes, tudo se encaixará no Arduino UNO e permanecerá um pouco para as necessidades do usuário. <br>  É importante lembrar que esses dois parâmetros devem ser os mesmos para ambas as partes. <br><br>  Obviamente, agora, se Alice e Bob estabeleceram uma conexão com sucesso, e um deles precisa transferir dados, primeiro os dados devem ser divididos em partes que não excedam os 64 bytes de tamanho e, em segundo lugar, cada pacote também deve conter um estado dois contadores de remetentes: o número de mensagens recebidas e enviadas (R e N). <br><br>  Veja como é fácil agora organizar os chamados  pipelining e como é fácil lidar com situações de erro! <br><br>  Se Alice enviar 3 pacotes seguidos logo após o estabelecimento da conexão, todos eles terão o contador R definido como 0 (ela ainda não recebeu nenhum pacote) e o contador N aumentará em um a cada novo pacote. <br><br>  Se Bob aceitar todos eles com êxito, para confirmar o recebimento dos três pacotes, será suficiente enviar uma confirmação apenas para o último, de fato, se ele simplesmente enviar de volta o status de seus contadores R = 3 e N = 0, Alice entenderá imediatamente que todos os pacotes enviados suas mensagens chegaram ao destinatário. <br><br>  Era um caso ideal quando não ocorria força maior.  Vamos agora ver o que poderia dar errado e como lidar com isso. <br><br>  Se, por algum motivo, Bob pular o primeiro pacote e aceitar um dos próximos, ele imediatamente chamará a atenção para o fato de que o contador N (o número de pacotes transmitidos por Alice) excede claramente o contador R do lado de Bob e Bob percebe facilmente que perdeu o primeiro pacote .  Nesse caso, ele só precisa jogar o Capitão Evidence mais plano e informar a Alice o status de seu contador de pacotes recebidos (R = 0).  Ao mesmo tempo, Alice entende que ela é N = 3 e Bob tem R = 0, ou seja, ela precisa transferir pacotes de uma nova maneira, começando pelo primeiro. <br><br>  Se você observar esse esquema com atenção, poderá ver que qualquer transmissão do status de seus contadores por qualquer assinante informa imediatamente o resultado da transmissão de pacotes de dados, e a diferença entre o contador transmitido de um lado e recebido do outro indica quantos pacotes foram perdidos e de que número ele começou. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, no pior dos casos, há uma retransmissão completa da transmissão; no caso médio, o contador A no lado do transmissor aumenta para o valor do contador R no lado receptor e “enviando” os pacotes perdidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É fácil entender que, dessa maneira, a continuidade do incremento dos contadores é mantida, o que significa que a transmissão de mensagens (pacotes) é garantida. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além das variáveis ​​de RNA, cada assinante possui dois sinalizadores SACK e SPEP. Se o primeiro estiver instalado, será necessário enviar uma confirmação (Enviar confirmação), se o segundo - você precisará enviar uma solicitação de confirmação (Enviar REPly para uma mensagem).</font></font><br><br> ,   DDCMP     — SNAK (Send Negative AcKnowledgement).         - .               ,      , ,         —       . <br>       ,      . <br><br>          - . -      .  E é verdade.    . <br>                  . <br><br>       ,        —   ,   .      ,   ,    L,   (,      —  R). <br><div class="scrollable-table"><table><tbody><tr><th>  </th><th>  </th></tr><tr><td>    NR=RL+1 </td><td> 1)   <br> 2)    <br> 3) RL=RL+1 <br> 4)  RR=NL  AL&lt;=RR&lt;=NL   <br>      AL  RR  <br>  <br> 5) AL=RR <br></td></tr><tr><td>     — REP </td><td> 1) SACK = true <br> 2) SREP = false <br></td></tr><tr><td>   — ACK </td><td> 1)   <br> 2) SREP = false <br> 3)  RR=NL  AL&lt;=RR&lt;=NL   <br>      AL  RR  <br>  <br> 4) AL=RR <br></td></tr><tr><td>    </td><td> 1) SREP = true </td></tr><tr><td>      SREP </td><td> 1)     REP(RL, NL) <br> 2)   <br></td></tr><tr><td>    AL&lt;NL </td><td> 1)     AL+1 <br> 2)   <br></td></tr><tr><td>  ,   SACK </td><td> 1)   ACK(RL,NL) </td></tr><tr><td>  , AL=NL,  SACK  SREP <br>  ,     <br></td><td> 1) NL=NL+1 <br> 2)     <br></td></tr></tbody></table></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora dê uma olhada mais de perto, percorra todo o circuito na cabeça. Percebemos o que está faltando aqui. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na descrição original do DDCMP, da qual partimos bastante, isso é chamado de sinalizador SELECT - um nó (Alice ou Bob) pode ou não ser "escolhido". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que nos confundiu foi o fato de nenhum mecanismo estar autorizado a permitir ou proibir a transferência. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, aqui está: esta é a bandeira SELECT. É aplicado de maneira muito simples: se o sinalizador estiver definido, é possível transmitir, caso contrário, é impossível.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as mensagens de controle como ACK e REP devem conter esse sinalizador. </font><font style="vertical-align: inherit;">O último pacote na fila também deve conter esse sinalizador. </font><font style="vertical-align: inherit;">Se um nó "costura" um sinalizador em um pacote, ele "o distribui" e, portanto, não é mais instalado. </font><font style="vertical-align: inherit;">O nó que detecta esse sinalizador no pacote, pelo contrário, deve instalá-lo por conta própria. </font><font style="vertical-align: inherit;">É como passar um bastão ou jogar um picadinho (lembra-se disso?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mais importante ao trabalhar com esse sinalizador é que um dos nós deve ter esse sinalizador por padrão e o outro não. </font><font style="vertical-align: inherit;">Esse é outro cronômetro muito importante - o sinalizador SELECT retorna o cronômetro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, temos um conjunto completo de regras para estabelecer uma conexão e transmitir dados por ela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não tocamos apenas na implementação concreta desse conjunto de regras. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, conserte!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formação e Formato de Pacotes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso se chama Enquadramento de Mensagens - as regras para analisar e gerar mensagens e o formato. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos calcular quanto precisamos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. No mínimo, precisamos de cada mensagem para conter o estado dos contadores R e N do remetente. </font><font style="vertical-align: inherit;">Para o Arduino, concordamos que podemos ter no máximo 8 mensagens enviadas, mas não confirmadas. </font><font style="vertical-align: inherit;">Mas, como transferimos bytes, colocamos ambos os contadores em um byte, deixando-os em 4 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse byte será formado assim:</font></font><br><pre><code class="cpp hljs"> = (RL &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | (NL &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  E leremos o status dos contadores assim: <br><pre> <code class="cpp hljs">NR = (c &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; RR = c &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>;</code> </pre> <br>  c - byte correspondente da mensagem <br><br>  2. Lembramos também que cada mensagem deve conter o estado do sinalizador SELECT.  E os diferentes tipos de mensagens serão: <br><div class="scrollable-table"><table><tbody><tr><th>  Nome engraçado <br></th><th>  Nome sério <br></th><th>  Descrição do produto <br></th><th>  Valor do sinalizador SELECT <br></th><th>  Valor PTYPE </th></tr><tr><td>  "FAÇA UMA VEZ!" <br></td><td>  STR <br></td><td>  STaRt <br></td><td>  verdade </td><td>  40. <br></td></tr><tr><td>  "DOIS!" <br></td><td>  STA <br></td><td>  Início reconhecido </td><td>  verdade </td><td>  36. </td></tr><tr><td>  “NOOL ACEITO!” <br></td><td>  ACK (NL = 0, RL = 0) <br></td><td>  Reconhecimento <br></td><td>  verdade </td><td>  33 <br></td></tr><tr><td>  "ACEITO POR ER, ENVIADO POR EN" </td><td>  ACK (NL, RL) </td><td>  Reconhecimento </td><td>  verdade </td><td>  33 </td></tr><tr><td>  "CONFIRMAR COMO EU ENTENDO?" <br></td><td>  REP (NL, RL) <br></td><td>  REPly a uma mensagem </td><td>  verdade </td><td>  34 </td></tr><tr><td>  "PACOTE DE DADOS" <br></td><td>  DTA (NL, RL) <br></td><td>  Pacote de dados </td><td>  falsa </td><td>  17 </td></tr><tr><td>  PACOTE DE DADOS EXTREMOS <br></td><td>  DTE (NL, RL) </td><td>  Pacote DaTa - Fim </td><td>  verdade </td><td>  49. </td></tr></tbody></table></div><br><br>  Ou seja, apenas 6 tipos diferentes de mensagens.  Todas as mensagens, exceto o DTA, "liberam" o sinalizador SELECT - elas precisam de uma resposta imediata do assinante remoto e, sem o sinalizador, ele não poderá transmiti-lo.  A mensagem DTA não retorna um sinalizador para possibilitar o pipelining. <br><br>  Em geral, temos 3 bits suficientes para o tipo de mensagem, mas, para não mexer com os bits, atribuímos um byte inteiro ao tipo - em caso de revisão, teremos alguma liberdade de ação. <br><br>  Se a mensagem contiver dados, precisamos transferir sua quantidade e soma de verificação.  Como o tamanho máximo do pacote é de 64 bytes, também será necessário um byte para a soma de verificação e o comprimento - de repente você terá que aumentar o tamanho do pacote. <br><br>  3. Também precisamos de alguma assinatura do início da mensagem e uma soma de verificação separada para o cabeçalho. <br><br>  Com tudo isso em mente, o cabeçalho (também conhecido como mensagens de controle) fica assim: <br><div class="scrollable-table"><table><tbody><tr><th>  Deslocamento, byte <br></th><th>  Descrição do produto </th><th>  Tamanho, bit </th></tr><tr><td>  0 0 </td><td>  SIGN = 0xAD <br></td><td>  8 </td></tr><tr><td>  1 </td><td>  PTYPE </td><td>  8 </td></tr><tr><td>  2 </td><td>  TCNT </td><td>  4 <br></td></tr><tr><td>  2 </td><td>  RCNT </td><td>  4 </td></tr><tr><td>  3 </td><td>  Hchk </td><td>  8 </td></tr></tbody></table></div><br><br>  E o bloco de dados é assim: <br><div class="scrollable-table"><table><tbody><tr><th>  Deslocamento, byte <br></th><th>  Descrição do produto </th><th>  Tamanho, bit </th></tr><tr><td>  4 </td><td>  DCNT <br></td><td>  8 </td></tr><tr><td>  5..5 + DCNT-1 <br></td><td>  DADOS <br></td><td>  8 * DCNT </td></tr><tr><td>  5 + DCNT </td><td>  Dchk </td><td>  8 </td></tr></tbody></table></div><br><br>  Só isso.  Esta é uma descrição completa do protocolo que recebemos do DDCMP. <br>  Agora você pode passar pela implementação. <br><br><h3>  Como é organizado e como usá-lo? </h3><br>  Primeiro, um pouco sobre a estrutura do repositório. <br>  Como mencionei no início, o código do projeto está no github: <a href="https://github.com/AlekUnderwater/uMCPIno" rel="nofollow">uMCPIno</a> <br><br>  Para ver como tudo funciona, você pode executar um <a href="" rel="nofollow">aplicativo de teste</a> em um PC. <br><br>  No arquivo morto, execute uMCPIno_Test.exe, selecione a porta COM desejada e tente como ela funciona. <br>  Você pode verificar um par de portas COM virtuais (eu geralmente faço isso). <br>  Por que você pode executar duas cópias do aplicativo.  Apenas não esqueça de ativar “SELECTED BY DEFAULT” em uma cópia - esta será Master e na outra - desligue-a.  By the way, se estiver interessado, você pode ver o que acontece se você não seguir esta regra =) <br><br>  A opção EXTRAS permite ver todos os movimentos dos pensamentos dentro do cérebro do protocolo.  Todas as alterações no estado dos sinalizadores SELECT, eventos dos temporizadores, alterações no estado do nó, bem como os valores das variáveis ​​R e N nas mensagens transmitidas e recebidas serão exibidos. <br><br>  Eu conecto meu Arduino UNO ao meu laptop através de um conversor USB UART &lt;-&gt;.  Os conectores de pinos permitem simular uma quebra de linha a qualquer momento: <br><img src="https://habrastorage.org/webt/nn/vg/kp/nnvgkplqtoqbazpubopcb8bff-g.jpeg"><br><br>  Se você agora executar o aplicativo no laptop, depois de pressionar o botão "CONNECT", o arduina estabelecerá uma conexão: <br><img src="https://habrastorage.org/webt/cy/jm/lx/cyjmlxn_ga-_zvrzel5yjmfwdz4.png"><br><br>  E é assim que o sistema reage a uma tentativa de enviar através de uma linha "rasgada": <br><img src="https://habrastorage.org/webt/lu/kb/dw/lukbdwxot1xuopxjdqxgpq1xqsq.png"><br><br>  Para incorporar o uMCPIno no seu aplicativo para PC: <br><ol><li>  O repositório possui uma biblioteca uMCPIno.  Conecte-o às referências do seu projeto </li><li>  Ele contém a classe uMCPInoPort.  Declaramos sua instância: <br><pre> <code class="cs hljs">uMCPInoPort port; port = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uMCPInoPort(<span class="hljs-string"><span class="hljs-string">"COM1"</span></span>, UCNLDrivers.BaudRate.baudRate9600, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">8100</span></span>, <span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>);</code> </pre><br>  Parâmetros em ordem: nome da porta, velocidade da porta, estado SELECT padrão, intervalo para SELECT, intervalo de tempo limite, tamanho do pacote e o número máximo de mensagens não reconhecidas. <br></li><li>  Inscrever-se para eventos: <br>  quando o sinalizador SELECT - port.Select for alterado: <br><pre> <code class="cs hljs">OnSelectChangedEventHandler</code> </pre> <br>  quando o estado muda - port.State: <br><pre> <code class="cs hljs">OnStateChangedEventHandler</code> </pre> <br>  O host remoto confirma o recebimento do código: <br><pre> <code class="cs hljs">OnDataBlockAcknowledgedEventHandler</code> </pre> <br>  quando chega o pacote de dados: <br><pre> <code class="cs hljs">OnDataBlockReceivedEventHandler</code> </pre> <br></li><li>  Antes do trabalho, abra a porta <br><pre> <code class="cs hljs">port.Open();</code> </pre> <br></li><li>  Para enviar dados, chamamos o método: <pre> <code class="cs hljs">port.Send(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data);</code> </pre> <br></li><li>  Após a conclusão, feche a porta: <pre> <code class="cs hljs">port.Close();</code> </pre> <br></li></ol><br><br>  Basta enviar dois bytes! <br><br>  Agora vamos à implementação do Arduino.  Dois exemplos estão na pasta <a href="https://github.com/AlekUnderwater/uMCPIno/tree/master/Arduino" rel="nofollow">github.com/AlekUnderwater/uMCPIno/tree/master/Arduino</a> <br><br>  <a href="" rel="nofollow">O primeiro</a> é apenas um conversor de e para o uMCP.  O primeiro Serial serve para se comunicar com o Host e o Serial1 (se estiver na sua placa) ou o SoftwareSerial nos pinos 2 e 3 - para se comunicar com outro nó do uMCPIno.  Você pode conectar o Bluetooth ou um módulo de rádio aqui. <br><br>  <a href="" rel="nofollow">O segundo</a> é um modelo de projeto com suporte para o protocolo uMCPIno <br><br>  Ambos os projetos têm configurações onde você pode e deve subir.  Aqui estão elas: <br><br>  O estado padrão do sinalizador SELECT.  Se definido como (true), mesmo que o nó remoto não retorne o sinalizador, ele será definido como true pelo timer. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_STATE (false)</span></span></code> </pre> <br><br>  Para definir o período desse timer, existe a seguinte configuração: intervalo para retornar o sinalizador SELECT em milissegundos <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_SELECT_DEFAULT_INTERVAL_MS (4000)</span></span></code> </pre> <br><br>  O intervalo para aguardar uma resposta em milissegundos, é melhor deixá-lo um pouco menos que o intervalo para retornar o sinalizador SELECT. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_TIMEOUT_INTERVAL_MS (3000)</span></span></code> </pre> <br><br>  A taxa de transmissão real da linha.  Este parâmetro é necessário para determinar quando a transferência será finalizada. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_LINE_BAUDRATE_BPS (9600)</span></span></code> </pre> <br><br>  Intervalo de acumulação de dados para o algoritmo Nagle.  Insolentemente, considere igual a 100 milissegundos.  Durante esse tempo, estamos aguardando um conjunto de pacotes, se não for digitado, enviamos como está.  A tarefa do algoritmo Nagle é livrar a rede de uma pilha de pacotes pequenos de um a vários bytes de tamanho. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_NAGLE_DELAY_MS (100)</span></span></code> </pre> <br><br>  Essas configurações definem as velocidades da porta para comunicação com o sistema de controle (Host) e a linha.  Não confunda a velocidade da porta com uma linha com uma taxa de transferência física. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_HOST_CONNECTION_BAUDRATE_BPS (9600) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Host connection port speed #define CFG_LINE_CONNECTION_BAUDRATE_BPS (9600) // Line connection port speed</span></span></span></span></code> </pre> <br><br>  Se essa configuração estiver ativada, quando a energia for fornecida ao controlador, o próprio protocolo se comandará para iniciar o estabelecimento de uma conexão. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IS_AUTOSTART_ON_POWERON (true)</span></span></code> </pre> <br><br>  Este é o tamanho em bytes do buffer para pacotes de dados recebidos. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_IL_RING_SIZE (255)</span></span></code> </pre> <br><br>  A seguir, vamos ver como é o loop de esboço principal: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uMCP_ITimers_Process(); DC_Input_Process(); DC_Output_Process(); <span class="hljs-comment"><span class="hljs-comment">//  ip_ready  ,      if (ip_ready) { uMCP_OnIncomingPacket(); } //        ,     -  if ((state == uMCP_STATE_HALTED) &amp;&amp; ((ih_Cnt &gt; 0) || (isStartup &amp;&amp; CFG_IS_AUTOSTART_ON_POWERON))) { if (isStartup) { isStartup = false; } uMCP_STATE_Set(uMCP_STATE_ISTART); uMCP_CtrlSend(uMCP_PTYPE_STR, 0, 0, true); } else if (state == uMCP_STATE_RUNNING) { uMCP_Protocol_Perform(); //      -   if (il_ready) { il_ready = false; USER_uMCPIno_DataPacketReceived(); } } }</span></span></code> </pre><br><br>  Agora vamos ver como o protocolo funciona.  A lógica principal está contida na função uMCP_Protocol_Perform ();  Aqui está o código dela: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_Protocol_Perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == uMCP_STATE_RUNNING) { <span class="hljs-comment"><span class="hljs-comment">//              SELECT  if ((!iTimer_State[uMCP_Timer_TX]) &amp;&amp; (!iTimer_State[uMCP_Timer_TMO]) &amp;&amp; (select)) { //     if (ih_Cnt == 0) { //    REP -  if (srep) { uMCP_CtrlSend(uMCP_PTYPE_REP, N, R, true); srep = false; } //     -   else if (sentBlocksCnt &gt; 0) { uMCP_DataBlockResend((A + 1) % UMCP_PACKETS_NUMBER, true, true); } //    SACK  -        //  -       ACK else if ((!selectDefaultState) || (sack)) { uMCP_CtrlSend(uMCP_PTYPE_ACK, N, R, false); sack = false; } } //     -  else if (ih_Cnt &gt; 0) { //              -  if ((ih_Cnt &gt;= UMCP_PACKET_DATA_SIZE) || (millis() &gt;= ih_TS + CFG_NAGLE_DELAY_MS)) { //   N N = (N + 1) % UMCP_PACKETS_NUMBER; uMCP_NextDataBlockSend(); } } } } }</span></span></code> </pre><br><br>  Um analisador de pacotes que vive em uma função <pre> <code class="cpp hljs">On_NewByte_From_Line</code> </pre>  também organizado pelo princípio de uma máquina de estados finitos e funciona "byte a byte".  Isso é feito para economizar memória. <br><br>  O restante da implementação não é de particular interesse.  Analisaremos melhor como o usuário interage com o protocolo.  Neste exemplo, existem quatro "pontos de contato". <br><br>  A primeira é a função de enviar dados na linha uMCPIno: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCPIno_SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte* dataToSend, byte dataSize)</span></span></span></span>;</code> </pre> <br>  Tudo é simples aqui - você tem um buffer de bytes dataToSend, seu tamanho é dataSize.  A função retorna true se o envio for possível (há espaço para adicionar dados) e false caso contrário. <br>  Para não dirigir em vão, você pode verificar imediatamente a disponibilidade de espaço suficiente usando a função: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uMCP_IsCanSend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte dataSize)</span></span></span></span>;</code> </pre> <br><br>  Para analisar os pacotes de dados recebidos, você precisa adicionar seu código ao corpo da função <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCPIno_DataPacketReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><br>  Os dados recebidos são gravados no buffer de anel il_ring.  A leitura a partir dele pode ser organizada em bytes como este: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (il_Cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { c = il_ring[il_rPos]; il_rPos = (il_rPos + <span class="hljs-number"><span class="hljs-number">1</span></span>) % CFG_IL_RING_SIZE; il_Cnt--; <span class="hljs-comment"><span class="hljs-comment">//   "c" -      }</span></span></code> </pre><br><br>  Para prazeres sofisticados existe uma função <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USER_uMCP_OnTxBufferEmptry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Que é chamado quando todos os dados são enviados com sucesso.  Também é possível e necessário colocar algum tipo de código nele. <br><br><h3>  Por que isso é tudo e onde? </h3><br>  Eu lidei principalmente com apenas por diversão.  Além disso, eu precisava de um protocolo simples e, o mais importante, "leve" para enviar dados através de nossos modems de sonar <a href="https://habr.com/ru/post/428367/">uWAVE</a> .  Como eles transmitem dados através da água a uma velocidade de apenas 80 bps e com seu alcance máximo de comunicação de 1000 metros e a velocidade do som na água de cerca de 1500 m / s, a transmissão está associada a atrasos visíveis e existe apenas um canal de sonar (se não o mais !) das mais barulhentas, mais lentas e mais instáveis. <br>  Em grande parte devido a isso, tive que abandonar o mecanismo de reconhecimento negativo (NAK) - se é possível não transmitir - na água é melhor não transmitir 100%. <br>  Na realidade, o protocolo foi útil ao transmitir dados por um canal de rádio usando módulos <a href="http://www.dorji.com/products.php%3FCateId%3D9" rel="nofollow">DORJI</a> e o <a href="https%253A%252F%252Fwww.elecrow.com%252Fdownload%252FHC-12.pdf%26usg%3DAOvVaw2rNtYm7nLdpqPN6HR-LAS8" rel="nofollow">NS-012</a> conhecido por arduinos. <br><br><h3>  O que vem a seguir? </h3><br>  Se houver tempo, pretendo adicionar a possibilidade de endereçamento (que, a propósito, estava no DDCMP).  Como a principal tarefa deste protocolo agora é fornecer comodidade para todos os tipos de testes de nossos modens de sonar e outras redes de sensores, então existem (literalmente!) Armadilhas lá.  Só posso dizer que o problema não pode ser resolvido simplesmente adicionando os campos "Remetente" e "Alvo". <br>  Talvez seja o <a href="https://en.wikipedia.org/wiki/Geographic_routing" rel="nofollow">Roteamento Geográfico</a> e todo esse jazz. <br><br><h3>  PS </h3><br>  Tradicionalmente, serei muito grato por críticas, desejos e sugestões construtivas.  É sempre importante entender se você está fazendo algo útil para as pessoas ou perdendo tempo. <br>  Talvez, ao tentar evitar a transição desse longread para o romance "Guerra e Paz", tenha perdido alguns detalhes - não hesite em perguntar. <br><br><h3>  PPS </h3><br>  Muito obrigado pela vergonha do meu analfabetismo, apontando erros (gramaticais e lógicos): <br><ul><li>  <a href="https://habr.com/ru/users/berez/" class="user_link">Berez</a> </li><li>  <a href="https://habr.com/ru/users/edo1h/" class="user_link">edo1h</a> </li></ul><br>  O projeto era originalmente de código aberto, mas agora o artigo também é de código aberto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480110/">https://habr.com/ru/post/pt480110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480100/index.html">Iniciantes Sobre SEO</a></li>
<li><a href="../pt480102/index.html">Resumo do gerenciamento de produtos em novembro</a></li>
<li><a href="../pt480104/index.html">9 truques úteis em HTML</a></li>
<li><a href="../pt480106/index.html">Como montar uma imagem do banco de dados Oracle para contêineres de teste</a></li>
<li><a href="../pt480108/index.html">Física em um projeto de unidade usando a luta móvel como exemplo</a></li>
<li><a href="../pt480112/index.html">Diferenças entre C ++ / Visual Basic e Java no nível geral (para iniciantes e estudantes)</a></li>
<li><a href="../pt480114/index.html">Tudo sobre impostos para freelancers de TI. IE e trabalhadores por conta própria. Parte 1</a></li>
<li><a href="../pt480116/index.html">Posição do grupo Mail.ru no desenvolvimento de código-fonte aberto na Rússia</a></li>
<li><a href="../pt480118/index.html">Estamos escrevendo um simulador de digitação por toque usando JavaScript puro. Parte 1</a></li>
<li><a href="../pt480120/index.html">Uma nova conquista em criptografia - fatoração de um RSA de 795 bits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>