<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏽 👩🏼‍🚀 👩🏾‍🤝‍👨🏻 Wie man mit flockigen Tests in der OpenSource-Community umgeht 🔎 📵 🧛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Projekte stehen vor dem Problem von Flockentests, und dieses Thema wurde bei Habré mehr als einmal angesprochen. Tests, die sich nicht für ihren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man mit flockigen Tests in der OpenSource-Community umgeht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/436070/">  Viele Projekte stehen vor dem Problem von Flockentests, und dieses Thema wurde bei Habré mehr als einmal angesprochen.  Tests, die sich nicht für ihren Zustand entschieden haben, benötigen nicht nur ständig Maschinenzeit, sondern auch die Zeit von Entwicklern und Testern.  Und wenn Sie in einem kommerziellen Unternehmen eine bestimmte Ressource zuweisen können, um dieses Problem zu lösen und verantwortliche Personen zu ernennen, ist dies in der OpenSource-Community nicht so einfach.  Besonders bei großen Projekten - zum Beispiel bei Apache Ignite, wo es fast 60.000 verschiedene Tests gibt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f92/3f5/dd2/f923f5dd2d414a1737fb093c3e0ddac4.png"><br><br>  In diesem Beitrag erfahren Sie, wie Sie dieses Problem in Apache Ignite lösen können.  Wir sind Dmitry Pavlov, leitender Software-Ingenieur / Community-Manager bei GridGain, und Nikolai Kulagin, IT-Ingenieur bei Sberbank Technologies. <br><a name="habracut"></a><br>  <i>Alles, was unten geschrieben steht, repräsentiert nicht die Position eines Unternehmens, einschließlich der Sberbank.</i>  <i>Diese Geschichte stammt ausschließlich von Mitgliedern der Apache Ignite-Community.</i> <br><br><h2>  Apache Ignite und Tests </h2><br>  Die Geschichte von Apache Ignite beginnt 2014, als GridGain die erste Version des internen Produkts an die Apache Software Foundation spendete.  Seitdem sind mehr als 4 Jahre vergangen, und in dieser Zeit näherte sich die Anzahl der Tests der Marke von 60.000. <br><br>  Wir verwenden JetBrains TeamCity als Continuous Integration Server - danke an die Jungs von JetBrains für die Unterstützung der Open Source-Bewegung.  Alle unsere Tests sind auf die Suiten verteilt, deren Anzahl für den Hauptzweig nahe bei 140 liegt. In den Suiten sind die Tests nach bestimmten Kriterien gruppiert.  Dies kann nur die Funktionalität des maschinellen Lernens [RunMl], nur den Cache [RunCache] oder das gesamte [RunAll] testen.  In Zukunft wird der Testlauf genau [RunAll] bedeuten - eine vollständige Überprüfung.  Es dauert ungefähr 55 Stunden Maschinenzeit. <br><br>  Junit wird als Hauptbibliothek verwendet, es gibt jedoch nur wenige Komponententests.  Bei allen unseren Tests handelt es sich größtenteils um Integrationstests, da sie den Start eines oder mehrerer Knoten enthalten (und dies dauert einige Sekunden).  Integrationstests sind natürlich praktisch, da ein solcher Test viele Aspekte und Wechselwirkungen abdeckt, was mit einem einzelnen Einheitentest nur schwer zu erreichen ist.  Es gibt aber auch Nachteile: In unserem Fall ist dies eine ziemlich lange Vorlaufzeit sowie die Schwierigkeit, ein Problem zu finden. <br><br><h2>  Probleme mit schuppigen </h2><br>  Ein Teil dieser Tests ist schuppig.  Gemäß der TeamCity-Klassifizierung werden jetzt ungefähr 1.700 Tests als schuppig markiert, dh mit einer Statusänderung, ohne den Code oder die Konfiguration zu ändern.  Solche Tests können nicht ignoriert werden, da die Gefahr eines Fehlers in der Produktion besteht.  Daher müssen sie doppelt überprüft und manchmal mehrmals neu gestartet werden, um die Ergebnisse der Stürze zu analysieren - und dies kostet wertvolle Zeit und Mühe.  Und wenn bestehende Mitglieder der Community diese Aufgabe bewältigen, kann dies für neue Mitwirkende zu einem echten Hindernis werden.  Sie müssen zugeben, dass Sie bei Änderungen am Java Doc keinen Absturz erwarten, sondern nicht einen, sondern mehrere Dutzend. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/723/db8/c6b/723db8c6b70264074788f6783717f2b6.png"><br><br><h2>  Wer ist schuld? </h2><br>  Die Hälfte der Probleme mit Flockentests ergibt sich aus der Konfiguration der Ausrüstung aufgrund der Größe der Installation.  Und die zweite Hälfte steht in direktem Zusammenhang mit Menschen, die ihren Fehler verpasst und nicht behoben haben. <br><br>  Herkömmlicherweise können alle Community-Mitglieder in zwei Gruppen unterteilt werden: <br><br><ul><li>  Enthusiasten, die freiwillig in die Gemeinschaft eintreten und zu ihrer Freizeit beitragen. <br></li><li>  Vollzeitmitarbeiter, die für Unternehmen arbeiten, die dieses Open-Source-Produkt verwenden oder damit in Verbindung stehen. <br></li></ul><br>  Ein Mitwirkender aus der ersten Gruppe kann durchaus eine einzige Bearbeitung vornehmen und die Community verlassen.  Und es ist fast unmöglich, es zu erreichen, wenn ein Fehler entdeckt wird.  Es ist einfacher, mit Personen aus der zweiten Gruppe zu interagieren. Sie reagieren eher auf einen Test, den sie brechen.  Es kommt jedoch vor, dass ein Unternehmen, das zuvor an einem Produkt interessiert war, es nicht mehr benötigt.  Sie verlässt die Community und ihre Mitarbeiter sind bei ihr.  Oder es ist möglich, dass der Mitwirkende das Unternehmen und damit die Community verlässt.  Natürlich nehmen einige nach solchen Änderungen weiterhin an der Community teil.  Aber nicht alle. <br><br><h2>  Wer wird reparieren? </h2><br>  Wenn wir über Leute sprechen, die die Community verlassen haben, gehen ihre Fehler natürlich zu den aktuellen Mitwirkenden.  Es ist erwähnenswert, dass für die Revision, die zu dem Fehler geführt hat, auch der Reviewer verantwortlich ist, aber er kann auch ein Enthusiast sein - das heißt, er wird nicht immer verfügbar sein. <br><br>  Es kommt vor, dass es sich herausstellt, eine Person zu erreichen, ihm zu sagen: Das ist das Problem.  Aber er sagt: Nein, dies ist nicht mein Fix, der einen Fehler verursacht hat.  Da ein vollständiger Lauf des Hauptzweigs automatisch mit einer relativ freien Warteschlange ausgeführt wird, geschieht dies meistens nachts.  Zuvor können mehrere Commits für den ganzen Tag in die Filiale gegossen werden. <br><br>  In TeamCity wird jede Codeänderung als Änderungsprotokoll angesehen.  Wenn wir nach drei Wechslern einen neuen Sturz haben, werden drei Leute sagen, dass dies nicht an ihrem Engagement liegt.  Wenn es fünf Wechsler gibt, werden wir es von fünf Personen hören. <br><br>  Ein weiteres Problem: Den Mitwirkenden darüber zu informieren, dass die Tests vor jeder Überprüfung ausgeführt werden müssen.  Einige wissen nicht, wo, was und wie sie laufen sollen.  Oder die Tests wurden ausgeführt, aber der Mitwirkende hat nicht im Ticket darüber geschrieben.  Auch in dieser Phase gibt es Probleme. <br><br>  Mach weiter.  Angenommen, die Tests werden ausgeführt, und im Ticket befindet sich ein Link zu den Ergebnissen.  Wie sich herausstellte, gibt dies jedoch keine Garantie für die Analyse der Durchlauftests.  Der Mitwirkende kann sich seinen Lauf ansehen, dort einige Tropfen sehen, aber "TeamCity sieht gut aus" schreiben.  Der Prüfer - insbesondere wenn er mit dem Mitwirkenden vertraut ist oder ihn bereits erfolgreich geprüft hat - sieht das Ergebnis möglicherweise nicht wirklich.  Und wir bekommen diese "TeamCity sieht gut aus": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/26c/db2/05526cdb20d19b264ac4750695e46dee.png"><br><br>  Wo "gut" hier ist, ist nicht klar.  Aber anscheinend wissen die Autoren zumindest, dass Tests durchgeführt werden müssen. <br><br><h2>  Wie wir das bekämpft haben </h2><br><h3>  Methode 1. Separate Tests </h3><br>  Wir haben die Tests in zwei Gruppen unterteilt.  Im ersten "sauberen" - stabilen Test.  Im zweiten - instabil.  Der Ansatz ist ziemlich offensichtlich, hat aber selbst bei zwei Versuchen nicht geklappt.  Warum?  Weil eine Suite mit instabilen Tests zu einem Ghetto wird, in dem etwas notwendigerweise eine Zeitüberschreitung, Abstürze usw. beginnt.  Infolgedessen beginnt jeder, diese immer problematischen Tests einfach zu ignorieren.  Im Allgemeinen macht es keinen Sinn, Tests nach Noten zu unterteilen. <br><br><h4>  Methode 2. Trennung und Benachrichtigung </h4><br>  Die zweite Option ähnelt der ersten - um stabilere Tests zuzuweisen und die verbleibenden PR-Tests nachts auszuführen.  Wenn in einer stabilen Gruppe etwas kaputt geht, wird eine Nachricht mit Standard-TeamCity-Tools an den Mitwirkenden gesendet, die besagt, dass etwas repariert werden muss. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/321/7d1/7ba/3217d17ba4744bf932a498f8c2dcd63d.png"><br><br>  ... 0 Personen haben auf diese Nachrichten reagiert.  Alle ignorierten sie. <br><br><h3>  Methode 3. Tägliche Überwachung </h3><br>  Wir haben die Suiten in mehrere "Beobachter" aufgeteilt, die verantwortungsvollsten Mitglieder der Community, und sie für Warnungen über Stürze unterschrieben.  Infolgedessen wurde in der Praxis bestätigt, dass die Begeisterung tendenziell endet.  Mitwirkende geben dieses Unternehmen auf und hören auf, es regelmäßig zu überprüfen.  Dann habe ich es verpasst, dort hingeschaut - und wieder ist etwas in den Meister gekrochen. <br><br><h3>  Methode 4. Automatisierung </h3><br>  Nach einer weiteren erfolglosen Methode erinnerten sich die Jungs von GridGain an ein zuvor entwickeltes Dienstprogramm, das die zu diesem Zeitpunkt fehlenden Funktionen in TeamCity hinzufügte.  Die Möglichkeit, allgemeine Statistiken über die Anzahl der Stürze anzuzeigen: Wie viel und was ist gefallen, hat das Ergebnis am nächsten Tag verschlechtert oder verbessert.  Dieses Dienstprogramm wurde schrittweise entwickelt, Berichte wurden hinzugefügt und umbenannt.  Dann fügten sie Benachrichtigungen hinzu, die erneut umbenannt wurden.  So stellte sich heraus, TeamCity Bot.  Jetzt hat es fast 500 Commits und 7 Mitwirkende und befindet sich im zusätzlichen Apache-Repository. <br><br>  Was macht der Bot?  Seine Fähigkeiten können in zwei Gruppen kombiniert werden: <br><br><ul><li>  Projektüberwachung - visuelle Überwachung durch Anzeigen der Ergebnisse von Läufen sowie automatische Benachrichtigung in Instant Messenger (z. B. Slack) <br></li><li>  Branch Check - Analyse von PR-Tests sowie Ausstellung eines Visums in einem Ticket. <br></li></ul><br><h2>  TeamCity Bot Workflow </h2><br>  Vor Apache Ignite Teamcity Bot war der Prozess des "Beitrags" zur Community wie folgt: <br><br><ol><li>  In JIRA wird eines der Tickets ausgewählt und festgelegt. <br></li><li>  Eine Pull-Anfrage wird erstellt. <br></li><li>  Führt Tests aus, die von den vorgenommenen Änderungen betroffen sein können. <br></li><li>  Wenn die Tests bestanden sind, kann die Pull-Anforderung vom Committer in der Vorschau angezeigt und temperiert werden. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/1b2/c5c/d81/1b2c5cd81a826ec8e761b8c12b62c7f4.png"><br><br>  Es sieht einfach aus, aber tatsächlich kann der dritte Punkt für einige Mitwirkende ein Hindernis sein.  Zum Beispiel: Ein Neuling in der Community beschließt, seinen ersten Beitrag zu leisten, indem er das einfachste Ticket auswählt.  Dies kann das Bearbeiten eines Java-Dokuments oder das Aktualisieren von Maven-Abhängigkeitsversionen sein.  Als er die Ergebnisse des Laufs in seinem kleinen Fix analysiert, stellt er plötzlich fest, dass etwa 30 Tests gefallen sind.  Woher kommt die Anzahl der fehlgeschlagenen Tests und wie man sie analysiert - er weiß es nicht.  Es ist zu erwarten, dass der Mitwirkende nie wieder hierher zurückkehren wird. <br><br>  Erfahrene Mitglieder der Community leiden ebenfalls unter Schuppenbildung - sie verbringen Zeit damit, zufällige Tests zu analysieren und damit die Produktentwicklung zu behindern. <br><img src="https://habrastorage.org/getpro/habr/post_images/c42/290/ffb/c42290ffb3ead465704b6a3a990b09b2.png"><br>  <i>Beitragsschema mit TeamCity Bot</i> <br><br>  Mit dem Aufkommen des Bots nahmen die Schritte im Gegenspiel zu, aber die Zeit, die für die Analyse der gefallenen Tests aufgewendet wurde, nahm erheblich ab.  Jetzt reicht es aus, den Test auszuführen und nach dem Bestehen die entsprechende Bot-Seite aufzurufen.  Wenn es mögliche Blocker gibt (abgelegte Tests, die nicht als schuppig gelten), reicht es aus, eine doppelte Überprüfung durchzuführen. Anschließend können Sie in JIRA ein Visum in Form eines Kommentars mit den Testergebnissen erhalten. <br><br><h2>  Funktionsübersicht </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/07c/a1b/a0e/07ca1ba0eb4d07a1537e75062eda2dd5.png"><br><br>  <i>Beitrag überprüfen - Eine Liste aller nicht geschlossenen PRs mit einer Zusammenfassung aller Informationen: Datum der letzten Aktualisierung, PR-Nummer, Name, Autor und Ticket in JIRA</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d9/7ec/2f8/6d97ec2f8eba182718d88d291edfa58d.png"><br>  <i>Für jede Pull-Anfrage steht eine Registerkarte mit detaillierteren Informationen zur Verfügung: der richtige PR-Name, ohne den der Bot das gewünschte Ticket in JIRA nicht finden kann;</i>  <i>ob Tests durchgeführt wurden;</i>  <i>ob das Testergebnis fertig ist;</i>  <i>hat einen Kommentar in JIRA hinterlassen.</i> <br><br>  Analyse der Testergebnisse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed8/104/3c2/ed81043c26693ca7f40f3f9379797b7a.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/c42/a79/22c/c42a7922ce4b4163c9561bfaa4964ea9.png"><br><br>  Hier sind zwei Berichte zum Testen derselben PR.  Der erste ist vom Bot.  Der zweite ist ein Standardbericht über Teamcity.  Der Unterschied in der Informationsmenge ist offensichtlich, und dies berücksichtigt nicht die Tatsache, dass zum Anzeigen des Verlaufs der TC-Testläufe auch mehrere Übergänge zu benachbarten Seiten erforderlich sind. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c66/7d5/24d/c667d524d85a956b5aca555343056563.png"><br><br>  Kommen wir zurück zum Bot-Bericht.  Dieser Bericht ist visuell in zwei Tabellen unterteilt: mögliche Blocker und alle Abstürze.  Blocker umfassen Tests, die: <br><br><ul><li>  eine Fehlerrate im Master von weniger als 4% haben (weniger als 4 Starts von 100 waren erfolglos); <br></li><li>  sind gemäß der Klassifizierung von TeamCity nicht schuppig; <br></li><li>  fiel aufgrund einer Zeitüberschreitung, zu wenig Speicher, Exit-Code, JVM-Fehler. <br></li></ul><br>  Im obigen Screenshot sind beispielsweise zwei Suiten als mögliche Blocker angegeben - in der ersten fiel der Test und in der zweiten fand eine Zeitüberschreitung statt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/867/ba7/53b/867ba753b7fee200ae041c36c30fc136.png"><br><br>  Um endlich zu verstehen, was ein schuppiger Test und was ein Fehler ist, betrachten Sie das obige Bild.  Die horizontale Leiste ist 100 Läufe.  Vertikaler grüner Balken - Test erfolgreich bestanden, roter Tropfen.  Im Falle eines Fehlers sieht der Laufverlauf natürlich aus: Ein einfacher grüner Balken am Ende ändert die Farbe in Rot.  Dies bedeutet, dass an dieser Stelle ein Fehler auftrat und der Test ständig abfiel.  Wenn wir einen schuppigen Test vor uns haben, dann ist seine Laufhistorie ein kontinuierlicher Wechsel von grünen und roten Farben. <br><br>  Analyse der Testergebnisse <br><br><img src="https://habrastorage.org/getpro/habr/post_images/faa/050/154/faa050154f92d1cd4cb388efa59f461d.png"><br><br>  Zum Beispiel analysieren wir die Ergebnisse des Bestehens der Tests im obigen Screenshot.  Laut der Bot-Version kann es aufgrund eines Fehlers zu zwei Abstürzen kommen - sie sind in der Tabelle "Mögliche Blocker" aufgeführt.  Es kann sich jedoch durchaus um schuppige Tests mit einer geringen Ausfallrate handeln.  Um diese Option auszuschließen, klicken Sie einfach auf die Schaltfläche Mögliche Blocker erneut ausführen. Diese beiden Suiten werden dann noch einmal überprüft.  Um die Aufgabe noch einfacher zu machen, können Sie auf Mögliche Blocker erneut ausführen und JIRA kommentieren und nach Abschluss der Prüfung einen Kommentar (und damit eine Benachrichtigung per E-Mail) vom Bot erhalten.  Dann gehen Sie hinein und sehen Sie, ob es ein Problem gibt oder nicht. <br><br>  Für Rezensenten ist dies sehr cool.  Sie können Änderungen vergessen, die keine Prüfungen bestanden haben. Klicken Sie einfach auf eine Reihe von Änderungen, klicken Sie auf die große grüne Schaltfläche "Ausführen" und warten Sie auf den Buchstaben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/352/de5/eb0352de55fe68f17e69139426ac4474.png"><br>  <i>Perfekter Bericht: Keine Blocker erkannt</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce9/8aa/303/ce98aa3034b0b39391aa1fe4db081375.png"><br></i>  <i>Grünes Visum (Kommentar) des Bots.</i>  <i>Keine Blocker gefunden.</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c5/be4/802/9c5be48026aad0175d690636ea5d14d9.png"><br></i>  <i>Rotes Visum - Überprüfung und / oder Bearbeitung von Fehlern erforderlich</i> <br><br>  Es kommt vor, dass immer noch einige Fehler in den „Master“ gelangen.  Wie gesagt, bevor dies durch persönliche Benachrichtigungen bekämpft wurde.  Oder jemand hat dafür gesorgt, dass nichts fiel.  Jetzt verwenden wir eine einfachere Lösung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57d/c82/90f/57dc8290f1643362d93ff95e497ce36c.png"><br><br>  Wenn ein neuer Fehler erkannt wird, wird eine Nachricht an die Entwicklerliste gesendet, die die Mitwirkenden und ihre Wechsler angibt, die möglicherweise die Fehlerursache sind.  So wird die ganze Community herausfinden, wer alles verursacht hat. <br><br>  Auf diese Weise konnten wir die Anzahl der Hotfixes erhöhen und die Zeit zur Behebung des Problems erheblich verkürzen. <br><br>  Status des Überwachungsassistenten <br>  Eine weitere Funktion des Bots ist die Überwachung des Status des Assistenten mit den Statistiken zu den letzten Starts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce6/3da/e80/ce63dae8033464df004d8a168e75c9c1.png"><br><br>  Meistertrends <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/d34/ecc/ab4d34ecc348552b4de5804a1b66a7a6.png"><br><br>  Auf der Seite "Mastertrends" werden zwei "Master" -Auswahlen für bestimmte Zeiträume verglichen.  Für jedes Element in der Tabelle werden der Maximal-, Minimalwert und der Median angezeigt. <br><img src="https://habrastorage.org/getpro/habr/post_images/564/8c5/fd1/5648c5fd1dd4080a736856bf2d9afbd3.png"><br><br>  Zusätzlich zu den allgemeinen Ergebnissen für die gesamte Stichprobe enthält die Tabelle Diagramme für jeden Indikator mit der Anzeige der Werte jedes Builds.  Durch Klicken auf einen Punkt können Sie zu den Ergebnissen des Laufs in TeamCity gelangen.  Außerdem ist es möglich, das Ergebnis aus der Statistik zu entfernen.  Dies ist nützlich, wenn abnormale Werte aufgrund schwerwiegender Ausfälle auftreten, an denen der Mitwirkende wahrscheinlich nicht schuld ist.  Solche Ergebnisse sollten ausgeschlossen werden, damit sie bei der Berechnung derselben Flockentests nicht berücksichtigt werden.  Darüber hinaus kann der Build auch unterschieden werden, um die Ergebnisse für jeden Indikator zu verfolgen. <br><br>  Apache Ignite Teamcity Bot hat jetzt über 65 registrierte Mitglieder.  Während des gesamten Zeitraums der Nutzung des Bots erhielten Visa mehr als 400 Pull-Anfragen, und durchschnittlich werden fünf Visa pro Tag ausgestellt. <br><br><h2>  TeamCity Bot Struktur </h2><br>  Der Bot wird auf einem separaten Server gehostet, geht zu ignite.apache.org, um Daten zu erhalten, benachrichtigt öffentlich alle auf der Entwicklerliste - dies ist unsere Hauptplattform für Ignite-Entwickler - und schreibt Visa über die JIRA-API auf Tickets. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/609/73e/734/60973e7345a076dbabedb9ef35921b7e.png"><br><br>  Es verwendet den Jetty-Server, Jersey-Servlets, eine Reihe von Diensten mit komplexer Geschäftslogik des Bots selbst, einschließlich Teamcity-, JIRA- und GitHub-Dienste, die auf den Ignited Integration-Dienst zugreifen.  Darüber hinaus Pure Integration für http-Anfragen.  Als Speicher - Apache Ignites eigenes Produkt im eingebetteten Einzelknotenkonfigurationsmodus mit aktiver Persistenz.  Zusätzlich zu den offensichtlichen Vorteilen der Verwendung von Ignite als Datenbank hilft es uns, verschiedene Anwendungsbereiche von Ignite zu finden und zu verstehen, was praktisch ist und was nicht. <br><br>  Die erste Version der Bot-Implementierung wurde von einem Artikel zum REST-Caching inspiriert und bestand aus einem REST-Cache sowie GitHub- und Teamcity-Diensten.  Teamcity xml und json, die vom Server zurückgegeben wurden, wurden von Pure Java Objects analysiert, die dann zwischengespeichert wurden.  Zuerst hat es funktioniert und das ziemlich schnell.  Mit zunehmender Datenmenge begannen sich die Ergebnisse jedoch zu verschlechtern. <br><br>  Es ist erwähnenswert, dass TeamCity eine Geschichte löscht, die älter als ~ 2 Wochen ist, der Bot jedoch nicht.  Letztendlich erschienen mit diesem Ansatz Tonnen von Daten, die sehr schwer zu verwalten sind. <br><br><h2>  TeamCity Bot Entwicklung </h2><br>  Der neue Ansatz implementiert eine kompakte Datenspeicheroption und entscheidet sich für eine kleine Anzahl von Cache-Partitionen.  Eine große Anzahl von Partitionen auf einem Knoten wirkt sich negativ auf die Geschwindigkeit der Datensynchronisation mit der Festplatte aus und erhöht die Startzeit des Clusters. <br><br>  Alle wichtigen Datenaktualisierungen werden asynchron durchgeführt, da wir sonst aufgrund der langsamen Rückgabe von TeamCity-Daten Gefahr laufen, eine schlechte UX zu erhalten. <br><br>  Für Zeichenfolgen, deren Werte selten geändert werden (z. B. die Namen von Tests), erfolgt eine einfache Zuordnung in id, die von Atomic Sequence generiert wird.  Hier ist ein Beispiel für einen solchen Eintrag: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/408/1f8/1f5/4081f81f553eb5b318799e11ea847043.png"><br><br>  Der lange Testname entspricht der int-Nummer, die in allen Builds gespeichert ist.  Dies spart eine enorme Menge an Ressourcen.  Zu den Methoden, die diese Zeile zurückgeben, gehört der In-Memory-Cache-Interceptor von Guava.  Dank der Cache-Annotation wählen wir selbst im Heap keine Zeilen aus, indem wir sie von Ignite by id lesen.  Und mit id bekommen wir immer die gleiche Linie, was gut für die Leistung ist. <br><br>  Für "unvorhersehbare" Zeilen, z. B. Stapelverfolgungsprotokolle, werden verschiedene Arten der Komprimierung verwendet - gzip-Komprimierung, schnelle Komprimierung oder unkomprimierte, je nachdem, welche besser ist.  Alle diese Methoden helfen dabei, maximale Daten in den Arbeitsspeicher zu integrieren und dem Client schnell eine Antwort zu geben. <br><br><h2>  Warum TeamCity Bot besser ist </h2><br>  Dies bedeutet nicht, dass TeamCity nicht über die oben aufgeführten Funktionen verfügt.  Sie sind, aber auf einem Haufen von verschiedenen Orten verstreut.  Im Bot wird alles auf einer Seite gesammelt und Sie können schnell verstehen, wo das Problem liegt. <br><br>  Eine nette Ergänzung ist der Brief, den der Bot auf dem Entwicklungsblatt sendet, wenn er ein Problem erkennt.  Unmittelbar in der Community gibt es Gelegenheit, eine Diskussion zu beginnen: „Lassen Sie uns vielleicht jetzt umkehren?“.  Dies erhöht das Vertrauen der Prüfer. <br><br>  Mit dem Bot ist es für neue Mitwirkende viel einfacher, sich dem Entwicklungsprozess anzuschließen.  Wenn Sie Ihre erste Korrektur vornehmen, wissen Sie nicht immer, was die vorgenommenen Änderungen bedeuten können.  Wenn Sie direkt in die Analyse der Testergebnisse in TeamCity eintauchen, können Sie leicht Ihre Begeisterung für die weitere Entwicklung verlieren.  Apache Ignite TeamCity Bot hilft Ihnen, schnell zu verstehen, ob es ein Problem gibt, und die Begeisterung aufrechtzuerhalten. <br><br>  Wir hoffen, dass der Bot das Leben der derzeitigen Mitwirkenden vereinfacht und neue Leute für die Community gewinnt.  Schließlich raten wir natürlich, das Auftreten einer großen Anzahl von Flockentests zu verhindern, da es schwierig ist, mit ihnen umzugehen.  Und vertraue Robotern - sie haben keine Vorlieben und sie nehmen nicht das Wort der Leute dafür. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436070/">https://habr.com/ru/post/de436070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436060/index.html">Architekturlösungen für ein Handyspiel. Teil 3: Blick auf den Strahlschub</a></li>
<li><a href="../de436062/index.html">Schiedsverfahren für Anfänger, Teil 1</a></li>
<li><a href="../de436064/index.html">Künstliche Intelligenz für alle</a></li>
<li><a href="../de436066/index.html">Mathematik der Apokalypse: Spieltheorie und die karibische Atomkrise</a></li>
<li><a href="../de436068/index.html">C ++ Russland Konferenz 2019</a></li>
<li><a href="../de436072/index.html">Reinigen, markieren: Wie wir Chatbot beigebracht haben, um Kundenprobleme zu unterscheiden</a></li>
<li><a href="../de436076/index.html">Kauri Hanipot Angriffsanalyse</a></li>
<li><a href="../de436080/index.html">Sicherheitswoche 03: 2019 - Jahr der Privatsphäre</a></li>
<li><a href="../de436082/index.html">Wie UEBA zur Verbesserung der Cybersicherheit beiträgt</a></li>
<li><a href="../de436086/index.html">Übersicht über Update 4 für Veeam Cloud Connect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>