<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖍️ 💝 👎🏿 Jouez "osu!", Mais attention aux bugs 🤳 🚥 ☀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, vous tous, collectionneurs d'insectes exotiques et simples! Nous avons un spécimen rare sur notre banc d'essai PVS-Studio aujourd'hui - un jeu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jouez "osu!", Mais attention aux bugs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/483436/"><p><img src="https://habrastorage.org/getpro/habr/post_images/3ac/9da/a12/3ac9daa12b519fc14e45f7f65abdd204.png" alt="Image 1" align="left"></p><br>  Salut, vous tous, collectionneurs d'insectes exotiques et simples!  Nous avons un spécimen rare sur notre banc d'essai PVS-Studio aujourd'hui - un jeu appelé "osu!", Écrit en C #.  Comme d'habitude, nous chercherons des bogues, les analyserons et jouerons. <br><a name="habracut"></a><br><h2>  Le jeu </h2><br>  Osu!  est un jeu de rythme open source.  Selon le <a href="https://osu.ppy.sh/home">site Web</a> du jeu, il est assez populaire, avec plus de 15 millions de comptes de joueurs.  Le projet propose un gameplay gratuit, un design coloré, une personnalisation de la carte, un système avancé de classement des joueurs en ligne, un mode multijoueur et un riche ensemble de pièces musicales.  Il n'y a aucun intérêt à approfondir le jeu;  vous pouvez tout lire sur Internet.  Commencez avec <a href="https://en.wikipedia.org/wiki/Osu!">cette page</a> . <br><br>  Je suis plus intéressé par le code source du projet, qui est disponible sur <a href="https://github.com/ppy/osu">GitHub</a> .  Une chose qui attire immédiatement votre attention est le grand nombre de validations de référentiel (plus de 24 mille), qui est un signe de développement intense et continu (le jeu a été publié pour la première fois en 2007, mais le travail doit avoir commencé encore plus tôt).  Le projet n'est pas grand cependant: seulement 1813 fichiers .cs avec un total de 135 000 LOC non vides.  Ce nombre comprend également des tests, que je ne prends généralement pas en compte lors de l'exécution des vérifications.  Les tests représentent 306 des fichiers .cs avec 25 000 LOC.  Le projet est en effet petit: par exemple, le noyau C # de PVS-Studio fait environ 300 000 LOC. <br><br>  Laissant de côté les fichiers de test, j'ai vérifié 1507 fichiers de 110 000 LOC.  La vérification a révélé quelques bugs intéressants, que je suis prêt à vous montrer. <br><br><h2>  Les bugs </h2><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Il existe des sous-expressions identiques 'result == HitResult.Perfect' à gauche et à droite de '||'  opérateur.  DrawableHoldNote.cs 266 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckForResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... ApplyResult(r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holdNote.hasBroken &amp;&amp; (result == HitResult.Perfect || result == HitResult.Perfect)) result = HitResult.Good; .... }); }</code> </pre> <br>  Ceci est un bel exemple de programmation orientée copier-coller, qui est un terme humoristique récemment utilisé par mon collègue Valeriy Komarov dans son article " <a href="https://www.viva64.com/en/b/0699/">Top 10 des bogues trouvés dans les projets Java en 2019</a> ". <br><br>  Quoi qu'il en soit, deux vérifications identiques sont exécutées d'affilée.  L'un d'eux était probablement destiné à vérifier une autre constante de l'énumération <i>HitResult</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HitResult { None, Miss, Meh, Ok, Good, Great, Perfect, }</code> </pre> <br>  Quelle constante devait être vérifiée?  Ou peut-être que le deuxième chèque ne devrait pas être là du tout?  Ce sont les questions auxquelles seuls les auteurs peuvent répondre.  Quoi qu'il en soit, il s'agit d'une erreur qui déforme la logique d'exécution du programme. <br><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Il existe des sous-expressions identiques «famille! = GetFamilyString (TournamentTypeface.Aquatico)» à gauche et à droite de l'opérateur «&amp;&amp;».  TournamentFont.cs 64 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> family, FontWeight weight</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight == FontWeight.Regular &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico) &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico)) weightString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; .... }</code> </pre> <br>  Copiez-collez à nouveau.  J'ai refactorisé le code afin que l'erreur soit facilement détectée maintenant, mais à l'origine, elle avait été écrite sur une seule ligne.  Tout comme dans l'exemple précédent, je ne peux pas dire avec certitude comment celui-ci doit être corrigé.  L'énumération <i>TournamentTypeface</i> contient une seule constante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TournamentTypeface { Aquatico }</code> </pre> <br>  L'erreur consiste peut-être à vérifier deux fois la variable <i>familiale</i> , mais je me trompe peut-être. <br><br>  <a href="https://www.viva64.com/en/w/v3009/">V3009</a> [CWE-393] Il est étrange que cette méthode renvoie toujours une seule et même valeur de 'false'.  KeyCounterAction.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forwards</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EqualityComparer&lt;T&gt;.Default.Equals(action, Action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IsLit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forwards) Increment(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Cette méthode renvoie <i>false à</i> chaque fois.  Dans des cas comme celui-ci, je vérifie généralement l'appel de fonction, car vous pouvez souvent constater que l'appelant n'utilise pas la valeur de retour, ce qui signifie qu'il n'y a pas de problème (autre qu'un mauvais style).  Voici à quoi ressemble l'appel dans ce cas: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action</span></span></span><span class="hljs-function">)</span></span> =&gt; Target.Children .OfType&lt;KeyCounterAction&lt;T&gt;&gt;() .Any(c =&gt; c.OnPressed(action, Clock.Rate &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br>  Comme vous pouvez le voir, l'appelant utilise la valeur renvoyée par la méthode <i>OnPressed</i> .  Puisque cette valeur est toujours <i>fausse</i> , l'appelant lui-même retourne toujours <i>faux</i> également.  Ce code contient très probablement une erreur et doit être révisé. <br><br>  Un autre bug similaire: <br><br><ul><li>  V3009 [CWE-393] Il est étrange que cette méthode renvoie toujours une seule et même valeur de 'false'.  KeyCounterAction.cs 30 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476] Possible NullReferenceException.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'val.NewValue' TournamentTeam.cs 41 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TournamentTeam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Acronym.ValueChanged += val =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) FlagName.Value = val.NewValue.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? val.NewValue?.Substring(0, 2).ToUpper() : string.Empty; }; .... }</span></span></code> </pre> <br>  La variable <i>val.NewValue</i> est gérée de manière dangereuse dans la condition de l'opérateur <i>?:</i> .  Ce qui fait que l'analyseur pense ainsi, c'est que plus tard dans la branche <i>alors</i> , la même variable est gérée de manière sûre en utilisant l'opérateur d'accès conditionnel: <i>val.NewValue? .Substring (....)</i> . <br><br>  Un autre bug similaire: <br><br><ul><li>  V3042 [CWE-476] Possible NullReferenceException.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'val.NewValue' TournamentTeam.cs 48 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476] Possible NullReferenceException.  Le '?.'  et '.'  les opérateurs sont utilisés pour accéder aux membres de l'objet 'api' SetupScreen.cs 77 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionableInfo { Label = <span class="hljs-string"><span class="hljs-string">"Current User"</span></span>, ButtonText = <span class="hljs-string"><span class="hljs-string">"Change Login"</span></span>, Action = () =&gt; { api.Logout(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }, Value = api?.LocalUser.Value.Username, .... }, .... } private class ActionableInfo : LabelledDrawable&lt;Drawable&gt; { .... public Action Action; .... }</span></span></code> </pre> <br>  Celui-ci est plus ambigu, mais je pense que c'est aussi un bug.  Le programmeur crée un objet de type <i>ActionableInfo</i> .  Le champ <i>Action</i> est initialisé à l'aide d'une fonction lambda, qui gère de manière dangereuse l' <i>API de</i> référence potentiellement nulle.  L'analyseur pense que ce modèle est une erreur car la variable <i>api</i> est traitée de manière sûre plus tard, lors de l'initialisation du paramètre <i>Value</i> .  J'ai appelé ce cas ambigu parce que le code de la fonction lambda implique une exécution retardée, au moment où le développeur pourrait en quelque sorte garantir que la référence <i>api</i> serait non nulle.  Mais je ne suis pas sûr de cela, car le corps de la fonction lambda ne semble pas utiliser de gestion de référence sûre, comme les vérifications préalables. <br><br>  <a href="https://www.viva64.com/en/w/v3066/">V3066</a> [CWE-683] Ordre incorrect possible des arguments passés à la méthode 'Atan2': 'diff.X' et 'diff.Y'.  SliderBall.cs 182 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completionProgress</span></span></span><span class="hljs-function">)</span></span> { .... Rotation = <span class="hljs-number"><span class="hljs-number">-90</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(-Math.Atan2(diff.X, diff.Y) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI); .... }</code> </pre> <br>  L'analyseur soupçonne que les arguments de la méthode <i>Atan2</i> sont passés dans le mauvais ordre.  Voici la déclaration de la méthode: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Parameters: // y: // The y coordinate of a point. // // x: // The x coordinate of a point. public static double Atan2(double y, double x);</span></span></code> </pre> <br>  Les valeurs ont été transmises dans l'ordre inverse.  Je ne suis pas sûr que ce soit un bug car la méthode <i>UpdateProgress</i> contient pas mal de calculs non triviaux;  Je le mentionne juste comme un bug possible. <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> [CWE-476] <a href="https://www.viva64.com/en/w/v3080/">Déréférence</a> nulle possible.  Pensez à inspecter «Beatmap».  WorkingBeatmap.cs 57 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Track </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObject = Beatmap.HitObjects.LastOrDefault(); .... }</code> </pre> <br>  L'analyseur signale une éventuelle déréférence nulle de <i>Beatmap</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBeatmap Beatmap { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LoadBeatmapAsync().Result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br>  Eh bien, l'analyseur est correct. <br><br>  Pour en savoir plus sur la façon dont PVS-Studio détecte des bogues comme celui-ci et sur les nouvelles fonctionnalités ajoutées dans C # 8.0 qui ont à voir avec la gestion des références potentiellement nulles, consultez l'article " <a href="https://www.viva64.com/en/b/0631/">Types de référence Nullable dans C # 8.0 et analyse statique</a> ". <br><br>  <a href="https://www.viva64.com/en/w/v3083/">V3083</a> [CWE-367] L'appel non sécurisé de l'événement 'ObjectConverted', NullReferenceException est possible.  Pensez à affecter un événement à une variable locale avant de l'invoquer.  BeatmapConverter.cs 82 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjectConverted != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { converted = converted.ToList(); ObjectConverted.Invoke(obj, converted); } .... }</code> </pre> <br>  Il s'agit d'une erreur mineure et assez courante.  Les abonnés peuvent se désinscrire de l'événement entre la vérification nulle et l'invocation de l'événement, entraînant un plantage.  C'est une façon de corriger le bogue: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... converted = converted.ToList(); ObjectConverted?.Invoke(obj, converted); .... }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3095/">V3095</a> [CWE-476] L'objet 'colonnes' a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: 141, 142. SquareGraph.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redrawProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ColumnCount; i++) columns[i].State = i &lt;= progress ? ColumnState.Lit : ColumnState.Dimmed; columns?.ForceRedraw(); }</code> </pre> <br>  L'itération sur la collection de <i>colonnes</i> se fait de manière dangereuse.  Le développeur a supposé que la référence des <i>colonnes</i> pouvait être nulle, ce qui est indiqué par l'utilisation de l'opérateur d'accès conditionnel pour accéder à la collection plus loin dans le code. <br><br>  <a href="https://www.viva64.com/en/w/v3119/">V3119 L'</a> appel de l'événement ignoré 'OnNewResult' peut entraîner un comportement imprévisible.  Envisagez d'implémenter explicitement les accesseurs d'événements ou utilisez un mot clé «scellé».  DrawableRuleset.cs 256 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHitObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject hitObject</span></span></span><span class="hljs-function">)</span></span> { .... drawableObject.OnNewResult += (_, r) =&gt; OnNewResult?.Invoke(r); .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;JudgementResult&gt; OnNewResult;</code> </pre> <br>  L'analyseur indique qu'il est dangereux d'utiliser un événement ignoré ou virtuel.  Voir la <a href="https://www.viva64.com/en/w/v3119/">description</a> du diagnostic pour l'explication.  J'ai également écrit un article sur ce sujet: " <a href="https://www.viva64.com/en/b/0453/">Evénements virtuels en C #: quelque chose s'est mal passé</a> ". <br><br>  Voici une autre construction dangereuse similaire: <br><br><ul><li>  V3119 L'appel d'un événement ignoré peut entraîner un comportement imprévisible.  Envisagez d'implémenter explicitement les accesseurs d'événements ou utilisez un mot clé «scellé».  DrawableRuleset.cs 257 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783] Peut-être le '??'  L'opérateur fonctionne d'une manière différente de celle attendue.  Sa priorité est inférieure à la priorité des autres opérateurs dans sa partie gauche.  OsuScreenStack.cs 45 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * ((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; }</code> </pre> <br>  Pour une meilleure compréhension, voici un exemple synthétique démontrant la logique d'origine de ce code: <br><br><pre> <code class="cs hljs">x = (c * a) ?? b;</code> </pre> <br>  Le bogue provient du fait que la priorité de l'opérateur "*" est supérieure à celle de l'opérateur "??"  opérateur.  Voici à quoi devrait ressembler le code fixe (avec des parenthèses ajoutées): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * (((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre> <br>  Un autre bug similaire: <br><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783] Peut-être le '??'  L'opérateur fonctionne d'une manière différente de celle attendue.  Sa priorité est inférieure à la priorité des autres opérateurs dans sa partie gauche.  FramedReplayInputHandler.cs 103 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime - NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  Comme dans le cas précédent, le programmeur avait des hypothèses erronées sur la priorité des opérateurs.  L'expression d'origine transmise à la méthode <i>Math.Abs ​​est</i> évaluée comme suit: <br><br><pre> <code class="cs hljs">(a – b) ?? <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Voici comment cela devrait être corrigé: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime – (NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3142/">V3142</a> [CWE-561] Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  DrawableHoldNote.cs 214 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnPressed(action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Result.Type == HitResult.Miss) <span class="hljs-comment"><span class="hljs-comment">// &lt;= holdNote.hasBroken = true; .... }</span></span></code> </pre> <br>  L'analyseur pense que le code du gestionnaire <i>OnPressed</i> est inaccessible à partir de la deuxième instruction <i>if</i> .  Cela découle du fait que la première condition est toujours vraie, c'est-à-dire que la méthode <i>base.OnPressed</i> retournera toujours <i>false</i> .  Jetons un coup d'œil à la méthode <i>base.OnPressed</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action != Action.Value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdateResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Et maintenant à la méthode <i>UpdateResult</i> : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userTriggered</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.Elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Judged) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Judged; }</code> </pre> <br>  Notez que l'implémentation de la propriété <i>Judged</i> n'a pas d'importance ici car la logique de la méthode <i>UpdateResult</i> implique que la dernière instruction de <i>retour</i> est équivalente à la suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Cela signifie que la méthode <i>UpdateResult</i> retournera <i>false</i> tout le temps, conduisant ainsi au problème de code inaccessible plus tôt dans la pile. <br><br>  <a href="https://www.viva64.com/en/w/v3146/">V3146</a> [CWE-476] <a href="https://www.viva64.com/en/w/v3146/">Déréférence</a> nulle possible de 'jeu de règles'.  Le 'FirstOrDefault' peut renvoyer la valeur nulle par défaut.  APILegacyScoreInfo.cs 24 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ScoreInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScoreInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RulesetStore rulesets</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ruleset = rulesets.GetRuleset(OnlineRulesetID); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mods = Mods != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? ruleset.CreateInstance() <span class="hljs-comment"><span class="hljs-comment">// &lt;= .GetAllMods().Where(....) .ToArray() : Array.Empty&lt;Mod&gt;(); .... }</span></span></code> </pre> <br>  L'analyseur considère que l'appel de <i>ruleset.CreateInstance ()</i> n'est pas sûr.  Avant cet appel, la variable d'ensemble de <i>règles</i> se voit attribuer une valeur à la suite de l'appel de la méthode <i>GetRuleset</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RulesetInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRuleset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; AvailableRulesets.FirstOrDefault(....);</code> </pre> <br>  Comme vous pouvez le voir, l'avertissement est valide car la séquence d'appel inclut la méthode <i>FirstOrDefault</i> , qui peut retourner <i>null</i> . <br><br><h2>  Conclusion </h2><br>  Il n'y a pas beaucoup de bugs dans le code de "osu!", Et c'est bien.  Mais je recommanderais toujours aux auteurs de vérifier les problèmes signalés par l'analyseur.  J'espère que cela aidera à maintenir la haute qualité et que le jeu continuera à apporter de la joie aux joueurs. <br><br>  Pour rappel, PVS-Studio est un bon choix si vous aimez bricoler le code source.  L'analyseur est disponible en <a href="https://www.viva64.com/en/pvs-studio-download/">téléchargement</a> sur le site officiel.  J'aimerais également que vous gardiez à l'esprit que les contrôles ponctuels comme celui-ci n'ont rien à voir avec l'utilisation normale de l'analyse statique dans le processus de développement réel.  Il n'est plus efficace que lorsqu'il est utilisé régulièrement à la fois sur le serveur de build et sur les ordinateurs des développeurs (c'est ce qu'on appelle l'analyse incrémentale).  Votre but ultime est d'empêcher les bogues de glisser dans le système de contrôle de version en les rattrapant au stade du codage. <br><br>  Bonne chance et restez créatif! <br><br><h2>  Les références </h2><br>  Ceci est notre premier article en 2020. Pendant que nous y sommes, voici les liens vers les vérifications des projets C # effectuées au cours de la dernière année: <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0605/">Recherche d'erreurs dans le code source du SDK Amazon Web Services pour .NET</a> </li><li>  <a href="https://www.viva64.com/en/b/0622/">Vérification du code source de Roslyn</a> </li><li>  <a href="https://www.viva64.com/en/b/0631/">Types de référence Nullable en C # 8.0 et analyse statique</a> </li><li>  <a href="https://www.viva64.com/en/b/0653/">WinForms: erreurs, Holmes</a> </li><li>  <a href="https://www.viva64.com/en/b/0654/">L'histoire de la façon dont PVS-Studio a trouvé une erreur dans la bibliothèque utilisée dans ... PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0656/">Vérification du code source des bibliothèques .NET Core par l'analyseur statique PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0664/">Vérification des analyseurs Roslyn</a> </li><li>  <a href="https://www.viva64.com/en/b/0677/">Vérification de l'interface utilisateur de Telerik pour UWP comme moyen de démarrer avec PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0678/">Azure PowerShell: principalement inoffensif</a> </li><li>  <a href="https://www.viva64.com/en/b/0681/">Analyse du code d'Orchard CMS pour les bogues</a> </li><li>  <a href="https://www.viva64.com/en/b/0683/">Vérification de l'encapsuleur OpenCvSharp pour OpenCV avec PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0692/">SDK Azure pour .NET: histoire d'une recherche d'erreur difficile</a> </li><li>  <a href="https://www.viva64.com/en/b/0694/">SDK SARIF et ses erreurs</a> </li><li>  <a href="https://www.viva64.com/en/b/0698/">Top 10 des bugs trouvés dans les projets C # en 2019</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483436/">https://habr.com/ru/post/fr483436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483416/index.html">Essayer d'automatiser des processus à l'aide de Powershell</a></li>
<li><a href="../fr483418/index.html">Systèmes de billetterie: comment avez-vous payé trois OTRS gratuits?</a></li>
<li><a href="../fr483424/index.html">DBA: transfert de valeurs SEQUENCE entre des bases de données PostgreSQL</a></li>
<li><a href="../fr483426/index.html">Enquête sur l'onglet du vendredi</a></li>
<li><a href="../fr483428/index.html">Quelle sera la gestion électronique des documents après l'entrée en vigueur des amendements à la loi sur la signature électronique?</a></li>
<li><a href="../fr483438/index.html">Jouez "osu!", N'oubliez pas les erreurs</a></li>
<li><a href="../fr483440/index.html">Derniers compilateurs D</a></li>
<li><a href="../fr483444/index.html">Rapport DORA 2019: comment améliorer les performances de DevOps</a></li>
<li><a href="../fr483446/index.html">Les scientifiques ont trouvé une nouvelle façon de réduire les niveaux de fer dans l'eau potable</a></li>
<li><a href="../fr483448/index.html">Disney - Le plus grand double sens de l'histoire de l'humanité</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>