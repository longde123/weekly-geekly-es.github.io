<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚕️ 💶 ♒️ Di bawah kap React. Kami menulis implementasi kami dari awal 🈺 🐢 😷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam seri artikel ini, kami akan membuat implementasi Bereaksi kami sendiri dari awal. Pada akhirnya, Anda akan memiliki pemahaman tentang bagaimana ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Di bawah kap React. Kami menulis implementasi kami dari awal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458916/">  Dalam seri artikel ini, kami akan membuat implementasi Bereaksi kami sendiri dari awal.  Pada akhirnya, Anda akan memiliki pemahaman tentang bagaimana React bekerja, apa metode siklus hidup komponen yang disebutnya, dan mengapa.  Artikel ini ditujukan bagi mereka yang telah menggunakan Bereaksi dan ingin belajar tentang perangkatnya, atau untuk yang sangat penasaran. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/ea8/66a/9d8ea866a9fac6aadd47eb3d51026f61.jpg" alt="gambar"><br><a name="habracut"></a><br>  Artikel ini adalah terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React Internal, Bagian Satu: rendering dasar</a> <br><br><h2>  Ini sebenarnya adalah artikel pertama dari lima </h2><br><ol><li>  Dasar-dasar Rendering &lt;- kami di sini </li><li>  ComponentWillMount dan componentDidMount </li><li>  Perbarui </li><li>  setState </li><li>  Transaksi </li></ol><br><blockquote>  Materi dibuat ketika React 15.3 relevan, khususnya penggunaan ReactDOM dan stack reconciler.  Bereaksi 16 dan di atas memiliki beberapa perubahan.  Namun, bahan ini tetap relevan, karena memberikan gambaran umum tentang apa yang terjadi "di bawah tenda". <br></blockquote><h2>  Bagian 1. Dasar-Dasar Rendering </h2><br><h3>  Elemen dan komponen </h3><br>  Ada tiga jenis entitas dalam Bereaksi: elemen DOM asli, elemen Bereaksi virtual, dan komponen. <br><br><h4>  Elemen DOM Asli </h4><br>  Ini adalah elemen DOM yang digunakan browser untuk membuat halaman web, misalnya, div, span, h1.  Bereaksi membuat mereka dengan memanggil document.createElement (), dan berinteraksi dengan halaman menggunakan metode DOM API berbasis browser seperti element.insertBefore (), element.nodeValue, dan lainnya. <br><br><h4>  Elemen reaksi virtual </h4><br>  Elemen Bereaksi virtual (sering disebut sebagai "elemen") adalah objek javascript yang berisi properti yang diperlukan untuk membuat atau memperbarui elemen DOM asli atau pohon elemen tersebut.  Berdasarkan elemen Bereaksi virtual, elemen DOM asli dibuat, seperti div, span, h1, dan lainnya.  Kita dapat mengatakan bahwa elemen Bereaksi virtual adalah turunan dari komponen komposit yang ditentukan pengguna, lebih lanjut tentang ini di bawah. <br><br><h4>  Komponen </h4><br>  Komponen adalah istilah yang cukup umum dalam Bereaksi.  Komponen adalah entitas yang Bereaksi melakukan berbagai manipulasi.  Komponen yang berbeda memiliki tujuan yang berbeda pula.  Misalnya, ReactDomComponent dari perpustakaan ReactDom bertanggung jawab untuk menghubungkan antara elemen React dan elemen DOM asli yang sesuai. <br><br><h4>  Komponen Senyawa Ubahsuaian </h4><br>  Kemungkinan besar Anda telah menemukan komponen jenis ini.  Saat Anda memanggil React.createClass () atau menggunakan kelas ES6 melalui extended React.Component, Anda membuat komponen komposit khusus.  Komponen semacam itu memiliki metode siklus hidup, seperti componentWillMount, shouldComponentUpdate, dan lainnya.  Kita dapat mendefinisikannya kembali untuk menambahkan semacam logika.  Selain itu, metode lain dibuat, seperti mountComponent, acceptComponent.  Metode ini hanya digunakan oleh Bereaksi untuk tujuan internalnya, kami tidak berinteraksi dengan mereka dengan cara apa pun. <br><br><div class="spoiler">  <b class="spoiler_title">ZanudaMode = aktif</b> <div class="spoiler_text">  Bahkan, komponen yang dibuat pengguna pada awalnya tidak lengkap.  React membungkusnya dalam ReactCompositeComponentWrapper, yang menambahkan semua metode siklus hidup ke komponen kami, setelah itu Bereaksi dapat mengelolanya (masukkan, perbarui, dll.). <br></div></div><br><h3>  Bereaksi deklaratif </h3><br>  Ketika datang ke komponen kustom, tugas kami adalah menentukan kelas-kelas komponen ini, tetapi kami tidak membuat instance kelas-kelas ini.  Bereaksi menciptakan mereka saat dibutuhkan. <br><br>  Selain itu, kami tidak secara eksplisit membuat elemen menggunakan gaya imperatif; sebagai gantinya, kami menulis dalam gaya deklaratif menggunakan JSX: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Kode ini dengan markup JSX diterjemahkan oleh kompiler ke dalam yang berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } }</code> </pre> <br>  Artinya, pada dasarnya, itu berubah menjadi konstruksi imperatif untuk membuat elemen melalui panggilan eksplisit ke React.createElement ().  Tetapi konstruksi ini ada di dalam metode render (), yang tidak kami panggil secara eksplisit, Bereaksi akan memanggil metode ini sendiri bila diperlukan.  Karena itu, memahami React sama deklaratifnya: kita menggambarkan apa yang ingin kita terima, dan React menentukan cara melakukannya. <br><br><h3>  Tulis Bereaksi kecil Anda </h3><br>  Setelah menerima dasar teknis yang diperlukan, kami akan mulai membuat implementasi Bereaksi kami sendiri.  Ini akan menjadi versi yang sangat disederhanakan, sebut saja Feact. <br><br>  Misalkan kita ingin membuat aplikasi Feact sederhana yang kodenya akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">Feact.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">hello world</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>));</code> </pre> <br>  Pertama, mari kita ngelantur tentang BEJ.  Ini justru "mundur," karena penguraian JSX adalah topik besar terpisah yang akan kami hilangkan sebagai bagian dari implementasi Feact.  Jika kami berurusan dengan JSX yang diproses, kami akan melihat kode berikut: <br><br><pre> <code class="javascript hljs">Feact.render( Feact.createElement(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'hello world'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>) );</code> </pre> <br>  Artinya, kami menggunakan Feact.createElement bukan JSX.  Jadi kami menerapkan metode ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createElement(type, props, children) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = { type, <span class="hljs-attr"><span class="hljs-attr">props</span></span>: props || {} }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) { element.props.children = children; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element; } };</code> </pre> <br>  Elemen yang dikembalikan adalah objek sederhana yang mewakili apa yang ingin kita render. <br><br><h3>  Apa yang dilakukan Feact.render ()? </h3><br>  Dengan memanggil Feact.render (), kami memberikan dua parameter: apa yang ingin kami render dan di mana.  Ini adalah titik awal dari setiap aplikasi Bereaksi.  Mari kita menulis implementasi metode render () untuk Feact: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createElement() { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }, render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentInstance.mountComponent(container); } };</code> </pre> <br>  Setelah render () selesai, kami mendapatkan halaman web yang selesai.  Elemen DOM dibuat oleh FeactDOMComponent.  Mari kita tulis implementasinya: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactDOMComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props.children; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> textNode = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._hostNode = domElement; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> domElement; } }</code> </pre> <br>  Metode mountComponent membuat elemen DOM dan menyimpannya di this._hostNode.  Kami tidak akan menggunakannya sekarang, tetapi kami akan kembali ke ini di bagian berikut. <br><br>  Versi aplikasi saat ini dapat dilihat secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acak</a> . <br><br>  Secara harfiah 40 baris kode sudah cukup untuk membuat implementasi React yang primitif.  The Feact yang kami buat tidak mungkin menaklukkan dunia, tetapi mencerminkan esensi dari apa yang terjadi di balik tudung React. <br><br><h3>  Menambahkan komponen khusus </h3><br>  Feact kami harus dapat membuat tidak hanya elemen dalam HTML (div, span, dll.), Tetapi juga komponen komposit yang ditentukan pengguna: <br><blockquote>  Metode Feact.createElement () yang dijelaskan sebelumnya saat ini baik-baik saja, jadi saya tidak akan mengulanginya dalam daftar kode. <br></blockquote><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { createClass(spec) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props = props; } Constructor.prototype.render = spec.render; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Constructor; }, render(element, container) { <span class="hljs-comment"><span class="hljs-comment">//      //   , //    } }; const MyTitle = Feact.createClass({ render() { return Feact.createElement('h1', null, this.props.message); } }; Feact.render({ Feact.createElement(MyTitle, { message: 'hey there Feact' }), document.getElementById('root') );</span></span></code> </pre> <br>  Biarkan saya mengingatkan Anda bahwa jika JSX tersedia, memanggil metode render () akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">Feact.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyTitle</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"hey there Feact"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('root') );</span></span></code> </pre> <br>  Kami melewati kelas komponen khusus ke createElement.  Elemen Bereaksi virtual dapat mewakili elemen DOM biasa atau komponen kustom.  Kami akan membedakan mereka sebagai berikut: jika kami melewati tipe string, maka ini adalah elemen DOM;  Jika suatu fungsi, maka elemen ini mewakili komponen kustom. <br><br><h3>  Meningkatkan Feact.render () </h3><br>  Jika Anda memperhatikan kode saat ini, Anda akan melihat bahwa Feact.render () tidak dapat memproses komponen kustom.  Mari kita perbaiki ini: <br><br><pre> <code class="javascript hljs">Feact = { render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactCompositeComponentWrapper(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentInstance.mountComponent(container); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactCompositeComponentWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = componentInstance.render(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domComponentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> domComponentInstance.mountComponent(container); } }</code> </pre> <br>  Kami telah membuat pembungkus untuk item yang diteruskan.  Di dalam bungkus, kami membuat turunan dari kelas komponen pengguna dan memanggil metode componentInstance.render ().  Hasil dari metode ini dapat diteruskan ke komponen FeactDOMComponent, di mana elemen DOM yang sesuai akan dibuat. <br><br>  Sekarang kita dapat membuat dan merender komponen khusus.  Feact akan membuat simpul DOM berdasarkan komponen khusus, dan mengubahnya tergantung pada properti (properti) komponen khusus kami.  Ini merupakan peningkatan signifikan dalam Feact kami. <br><blockquote>  Perhatikan bahwa FeactCompositeComponentWrapper secara langsung membuat FeactDOMComponent.  Hubungan dekat seperti itu buruk.  Kami akan memperbaikinya nanti.  Jika Bereaksi memiliki koneksi dekat yang sama, maka hanya aplikasi web yang dapat dibuat.  Menambahkan lapisan tambahan ReactCompositeComponentWrapper memungkinkan Anda untuk memisahkan logika Bereaksi untuk mengelola elemen virtual dan tampilan akhir dari elemen asli, yang memungkinkan Anda untuk menggunakan Bereaksi tidak hanya saat membuat aplikasi web, tetapi juga, misalnya, Bereaksi Asli untuk ponsel. <br></blockquote><h3>  Peningkatan komponen khusus </h3><br>  Komponen khusus yang dibuat hanya dapat mengembalikan elemen DOM asli, jika kami mencoba mengembalikan komponen khusus lainnya, kami mendapatkan kesalahan.  Perbaiki kekurangan ini.  Bayangkan kami ingin menjalankan kode berikut tanpa kesalahan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyMessage = Feact.createClass({ render() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.asTitle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Feact.createElement(MyTitle, { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Feact.createElement(<span class="hljs-string"><span class="hljs-string">'p'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); } } }</code> </pre><br>  Metode render () komponen kustom dapat mengembalikan elemen DOM asli atau komponen kustom lainnya.  Jika properti asTitle benar, maka FeactCompositeComponentWrapper akan mengembalikan komponen kustom untuk FeactDOMComponent di mana kesalahan akan terjadi.  Perbaiki FeactCompositeComponentWrapper: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeactCompositeComponentWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(element) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement = element; } mountComponent(container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentElement.props); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = componentInstance.render(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> element.type === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { element = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> element.type(element.props)).render(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> domComponentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactDOMComponent(element); domComponentInstance.mountComponent(container); } }</code> </pre><br>  Sebenarnya, kami sekarang telah membuat penopang untuk memenuhi kebutuhan saat ini.  Panggilan ke metode render akan mengembalikan komponen anak hingga mengembalikan elemen DOM asli.  Ini buruk karena komponen anak seperti itu tidak akan berpartisipasi dalam siklus hidup.  Misalnya, dalam hal ini, kami tidak akan dapat mengimplementasikan panggilan componentWillMount.  Kami akan memperbaikinya nanti. <br><br><h3>  Dan lagi kita memperbaiki Feact.render () </h3><br>  Versi pertama dari Feact.render () hanya dapat memproses elemen DOM asli.  Sekarang hanya komponen yang ditentukan pengguna yang diproses dengan benar tanpa dukungan asli.  Penting untuk menangani kedua kasus.  Anda dapat menulis pabrik yang akan membuat komponen tergantung pada jenis elemen yang dilewati, tetapi Bereaksi memilih cara yang berbeda: cukup bungkus komponen yang masuk di komponen lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TopLevelWrapper = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props = props; }; TopLevelWrapper.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Feact = { render(element, container) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapperElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createElement(TopLevelWrapper, element); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FeactCompositeComponentWrapper(wrapperElement); <span class="hljs-comment"><span class="hljs-comment">//   } };</span></span></code> </pre><br>  TopLevelWrapper pada dasarnya adalah komponen khusus.  Itu juga dapat didefinisikan dengan memanggil Feact.createClass ().  Metode render-nya hanya mengembalikan elemen yang diteruskan ke sana.  Sekarang setiap elemen dibungkus dalam TopLevelWrapper, dan FeactCompositeComponentWrapper akan selalu menerima komponen kustom sebagai input. <br><br><h3>  Kesimpulan bagian pertama </h3><br>  Kami telah menerapkan Feact, yang dapat membuat komponen.  Kode yang dihasilkan menunjukkan konsep dasar rendering.  Render nyata dalam Bereaksi jauh lebih rumit, dan mencakup peristiwa, fokus, pengguliran jendela, kinerja, dll. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jsfiddle</a> terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari bagian</a> pertama. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458916/">https://habr.com/ru/post/id458916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458906/index.html">[Yekaterinburg, pengumuman] Flutteron - sebuah lokakarya tentang pengembangan Flutter</a></li>
<li><a href="../id458908/index.html">Memindai dokumen melalui jaringan</a></li>
<li><a href="../id458910/index.html">Benchmarking PostgreSQL dengan halaman Linux yang besar</a></li>
<li><a href="../id458912/index.html">Bermigrasi ke Zimbra dengan imapsync</a></li>
<li><a href="../id458914/index.html">Apa (tidak) yang perlu Anda ketahui untuk membuat game di Unity</a></li>
<li><a href="../id458918/index.html">Apa yang bisa Anda pelajari dari desain gim kasual</a></li>
<li><a href="../id458920/index.html">Konferensi untuk penggemar DevOps</a></li>
<li><a href="../id458922/index.html">Cara pindah dari ESXi ke KVM / LXD dan tidak kehilangan akal</a></li>
<li><a href="../id458924/index.html">Kecelakaan membantu Anda belajar</a></li>
<li><a href="../id458926/index.html">Tragedi tidak datang sendiri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>