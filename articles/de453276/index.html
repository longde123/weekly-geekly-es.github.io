<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçñ üßõüèª ü§ôüèº Arduino und Timer unterbrechen üôÖüèø üëÖ üïäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Timer Interrupts" von E. 
 Vorwort 


 Mit dem Arduino-Board k√∂nnen Sie eine Vielzahl ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduino und Timer unterbrechen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453276/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Timer Interrupts"</a> von E. </p><br><h3 id="predislovie">  Vorwort </h3><br><p>  Mit dem Arduino-Board k√∂nnen Sie eine Vielzahl von Problemen schnell und minimal l√∂sen.  Wenn jedoch beliebige Zeitintervalle erforderlich sind (periodisches Abfragen von Sensoren, hochpr√§zise PWM-Signale, Impulse von langer Dauer), sind Standardbibliotheksverz√∂gerungsfunktionen nicht zweckm√§√üig.  F√ºr die Dauer ihrer Aktion wird die Skizze angehalten und kann nicht mehr verwaltet werden. </p><br><p>  In einer √§hnlichen Situation ist es besser, die eingebauten AVR-Timer zu verwenden.  Wie Sie dies tun und sich nicht in der technischen Wildnis von Datenbl√§ttern verlieren, hei√üt es in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erfolgreichen Artikel</a> , auf dessen √úbersetzung Sie aufmerksam gemacht werden. </p><br><p><img src="https://habrastorage.org/webt/3g/n_/iw/3gn_iwqe-tubwgqslsclzuaznki.png"></p><a name="habracut"></a><br><p>  Dieser Artikel beschreibt AVR- und Arduino-Timer und deren Verwendung in Arduino-Projekten und Benutzerschaltungen. </p><br><h3 id="chto-takoe-taymer">  Was ist ein Timer? </h3><br><p> Wie im Alltag von Mikrocontrollern kann ein Timer in dem Moment, in dem Sie ihn einstellen, in der Zukunft signalisieren.  In diesem Moment wird der Mikrocontroller unterbrochen, was ihn daran erinnert, etwas zu tun, um beispielsweise einen bestimmten Code auszuf√ºhren. </p><br><p>  Timer arbeiten wie externe Interrupts unabh√§ngig vom Hauptprogramm.  Anstatt den <em>Millis () -</em> Verz√∂gerungsaufruf zu wiederholen oder zu wiederholen, k√∂nnen Sie einen Timer zuweisen, der seine Aufgabe erledigt, w√§hrend Ihr Code andere Aufgaben <em>ausf√ºhrt</em> . </p><br><p>  Angenommen, es gibt ein Ger√§t, das etwas tun muss, z. B. alle 5 Sekunden eine LED blinken lassen.  Wenn Sie keine Timer verwenden, sondern regul√§ren Code schreiben, m√ºssen Sie in dem Moment, in dem die LED gez√ºndet wird, eine Variable einstellen und st√§ndig pr√ºfen, ob der Moment ihres Schaltens gekommen ist.  Bei einem Timer-Interrupt m√ºssen Sie nur den Interrupt konfigurieren und dann den Timer starten.  Die LED blinkt genau p√ºnktlich, unabh√§ngig von den Aktionen des Hauptprogramms. </p><br><h3 id="kak-rabotaet-taymer">  Wie funktioniert der Timer? </h3><br><p>  Es wirkt durch Inkrementieren einer Variablen, die als <em>Z√§hlregister bezeichnet wird</em> .  Das Z√§hlregister kann abh√§ngig von seiner Gr√∂√üe bis zu einem bestimmten Wert z√§hlen.  Der Timer erh√∂ht seinen Z√§hler immer wieder, bis er seinen Maximalwert erreicht. Zu diesem Zeitpunkt l√§uft der Z√§hler √ºber und wird auf Null zur√ºckgesetzt.  Ein Timer setzt normalerweise ein Flag-Bit, um Sie dar√ºber zu informieren, dass ein √úberlauf aufgetreten ist. </p><br><p>  Sie k√∂nnen dieses Flag manuell √ºberpr√ºfen oder einen Timer umschalten - verursachen Sie automatisch einen Interrupt, wenn das Flag gesetzt ist.  Wie bei jedem anderen Interrupt k√∂nnen Sie eine <em>Interrupt Service Routine</em> ( <em>ISR</em> ) zuweisen, um den angegebenen Code auszuf√ºhren, wenn der Timer √ºberl√§uft.  Der ISR selbst l√∂scht das √úberlaufflag, daher ist die Verwendung von Interrupts aufgrund seiner Einfachheit und Geschwindigkeit normalerweise die beste Wahl. </p><br><p>  Um die Z√§hlerwerte in genauen Zeitintervallen zu erh√∂hen, muss der Timer an die Taktquelle angeschlossen werden.  Die Taktquelle erzeugt ein sich st√§ndig wiederholendes Signal.  Jedes Mal, wenn der Timer dieses Signal erkennt, erh√∂ht er den Z√§hlerwert um eins.  Da der Timer auf einer Taktquelle l√§uft, ist die kleinste messbare Zeiteinheit die Zyklusperiode.  Wenn Sie ein 1-MHz-Taktsignal anschlie√üen, betr√§gt die Timer-Aufl√∂sung (oder Timer-Periode): </p><br><p>  T = 1 / f (f ist die Taktfrequenz) <br>  T = 1/1 MHz = 1/10 ^ 6 Hz <br>  T = (1 ‚â§ 10 ^ -6) s </p><br><p>  Somit betr√§gt die Aufl√∂sung des Timers eine Millionstel Sekunde.  Obwohl Sie eine externe Taktquelle f√ºr Timer verwenden k√∂nnen, wird in den meisten F√§llen die interne Quelle des Chips selbst verwendet. </p><br><h3 id="tipy-taymerov">  Timer-Typen </h3><br><p>  In Standard-Arduino-Boards auf einem 8-Bit-AVR-Chip gibt es mehrere Timer gleichzeitig.  Die Atmega168- und Atmega328-Chips verf√ºgen √ºber drei Timer0-, Timer1- und Timer2-Timer.  Sie haben auch einen Watchdog-Timer, der zum Schutz vor Fehlern oder als Software-Reset-Mechanismus verwendet werden kann.  Hier sind einige Funktionen jedes Timers. </p><br><p>  Timer0: <br>  Timer0 ist ein 8-Bit-Timer, was bedeutet, dass sein Z√§hlregister Zahlen bis zu 255 (d. H. Ein vorzeichenloses Byte) speichern kann.  Timer0 wird von tempor√§ren Arduino-Standardfunktionen wie <em>delay ()</em> und <em>millis () verwendet.</em> Verwechseln Sie es daher am besten nicht, wenn Sie sich um die Konsequenzen k√ºmmern. </p><br><p>  Timer1: <br>  Timer1 ist ein 16-Bit-Timer mit einem maximalen Z√§hlwert von 65535 (vorzeichenlose Ganzzahl).  Dieser Timer verwendet die Arduino Servo-Bibliothek. Denken Sie daran, wenn Sie ihn in Ihren Projekten verwenden. </p><br><p>  Timer2: <br>  Timer2 ist 8 Bit und ist Timer0 sehr √§hnlich.  Es wird in der Funktion Arduino <em>Tone ()</em> verwendet. </p><br><p>  Timer3, Timer4, Timer5: <br>  Die Chips ATmega1280 und ATmega2560 (in Arduino Mega-Varianten installiert) verf√ºgen √ºber drei zus√§tzliche Timer.  Alle von ihnen sind 16 Bit und funktionieren √§hnlich wie Timer1. </p><br><h3 id="konfiguraciya-registrov">  Konfiguration registrieren </h3><br><p>  Um diese Timer verwenden zu k√∂nnen, verf√ºgt der AVR √ºber Einstellungsregister.  Timer enthalten viele solcher Register.  Zwei davon - Timer / Z√§hler-Steuerregister - enthalten Einstellvariablen und werden als TCCRxA und TCCRxB bezeichnet, wobei x die Nummer des Timers ist (TCCR1A und TCCR1B usw.).  Jedes Register enth√§lt 8 Bits und jedes Bit speichert eine Konfigurationsvariable.  Hier sind die Details aus dem Atmega328-Datenblatt: </p><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1A </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 </td></tr><tr><td>  0x80 </td><td>  COM1A1 </td><td>  COM1A0 </td><td>  COM1B1 </td><td>  COM1B0 </td><td>  - - </td><td>  - - </td><td>  Wgm11 </td><td>  Wgm10 </td></tr><tr><td>  Readwrite </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  R. </td><td>  R. </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Anfangswert </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1B </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 </td></tr><tr><td>  0x81 </td><td>  ICNC1 </td><td>  ICES1 </td><td>  - - </td><td>  Wgm13 </td><td>  Wgm12 </td><td>  CS12 </td><td>  CS11 </td><td>  CS10 </td></tr><tr><td>  Readwrite </td><td>  Rw </td><td>  Rw </td><td>  R. </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Anfangswert </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr></tbody></table></div><br><p>  Die wichtigsten sind die letzten drei Bits in TCCR1B: CS12, CS11 und CS10.  Sie bestimmen die Taktfrequenz des Timers.  Wenn Sie sie in verschiedenen Kombinationen ausw√§hlen, k√∂nnen Sie den Timer so einstellen, dass er mit unterschiedlichen Geschwindigkeiten arbeitet.  Hier ist eine Datenblatttabelle, die die Wirkung der Auswahlbits beschreibt: </p><br><div class="scrollable-table"><table><thead><tr><th>  CS12 </th><th>  CS11 </th><th>  CS10 </th><th>  Aktion </th></tr></thead><tbody><tr><td>  0 </td><td>  0 </td><td>  0 </td><td>  Keine Taktquelle (Timer / Z√§hler gestoppt) </td></tr><tr><td>  0 </td><td>  0 </td><td>  1 </td><td>  clk_io / 1 (keine Division) </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td><td>  clk_io / 8 (Frequenzteiler) </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td><td>  clk_io / 64 (Frequenzteiler) </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td><td>  clk_io / 256 (Frequenzteiler) </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td><td>  clk_io / 1024 (Frequenzteiler) </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td><td>  Externe Taktquelle an Pin T1.  Rezessionsuhr </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  Externe Taktquelle an Pin T1.  Frontuhr </td></tr></tbody></table></div><br><p>  Standardm√§√üig sind alle diese Bits auf Null gesetzt. </p><br><p>  Angenommen, Sie m√∂chten, dass Timer1 mit einer Taktfrequenz mit einem Sample pro Periode l√§uft.  Wenn es √ºberl√§uft, m√∂chten Sie die Interrupt-Routine aufrufen, die die an Bein 13 angeschlossene LED in den Ein- oder Ausschaltzustand schaltet.  In diesem Beispiel werden wir den Arduino-Code schreiben, aber wir werden die Prozeduren und Funktionen der avr-libc-Bibliothek verwenden, wenn dies die Dinge nicht zu kompliziert macht.  Unterst√ºtzer von reinem AVR k√∂nnen den Code nach Belieben anpassen. </p><br><p>  Initialisieren Sie zun√§chst den Timer: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //  TCCR1A   0 TCCR1B = 0; //   Timer1 overflow: TIMSK1 = (1 &lt;&lt; TOIE1); //  CS10  ,      : TCCR1B |= (1 &lt;&lt; CS10); sei(); //    }</span></span></code> </pre> <br><p>  Das TIMSK1-Register ist ein Timer / Z√§hler1-Interrupt-Maskenregister.  Es steuert den Interrupt, den der Timer verursachen kann.  Durch Setzen des TOIE1-Bits wird der Timer angewiesen, zu unterbrechen, wenn der Timer √ºberl√§uft.  Dazu sp√§ter mehr. </p><br><p>  Wenn Sie das CS10-Bit setzen, beginnt der Timer zu z√§hlen und sobald ein √úberlauf-Interrupt auftritt, wird der ISR (TIMER1_OVF_vect) aufgerufen.  Dies geschieht immer dann, wenn der Timer √ºberl√§uft. </p><br><p>  Als n√§chstes definieren wir die ISR-Interrupt-Funktion: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_OVF_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Jetzt k√∂nnen wir den loop () -Zyklus definieren und die LED schalten, unabh√§ngig davon, was im Hauptprogramm passiert.  Um den Timer auszuschalten, setzen Sie jederzeit TCCR1B = 0. </p><br><h3 id="kak-chasto-budet-migat-svetodiod">  Wie oft blinkt die LED? </h3><br><p>  Timer1 ist auf √úberlauf-Interrupt eingestellt. Nehmen wir an, Sie verwenden einen Atmega328 mit einer Taktfrequenz von 16 MHz.  Da der Timer 16-Bit ist, kann er bis zum Maximalwert (2 ^ 16 - 1) oder 65535 z√§hlen. Bei 16 MHz l√§uft der Zyklus 1 / (16 ‚àó 10 ^ 6) Sekunden oder 6,25e-8 s.  Dies bedeutet, dass 65535 Proben in (65535 ‚àó 6,25e-8 s) auftreten und der ISR nach ungef√§hr 0,0041 s aufgerufen wird.  Und so immer wieder alle viertausendstel Sekunden.  Es ist zu schnell, um ein Flackern zu sehen. </p><br><p>  Wenn wir ein sehr schnelles PWM-Signal mit einer Abdeckung von 50% an die LED anlegen, erscheint das Leuchten kontinuierlich, aber weniger hell als gew√∂hnlich.  Ein solches Experiment zeigt die erstaunliche Leistung von Mikrocontrollern - selbst ein kosteng√ºnstiger 8-Bit-Chip kann Informationen viel schneller verarbeiten, als wir erkennen k√∂nnen. </p><br><h3 id="delitel-taymera-i-rezhim-ctc">  Timer-Teiler und CTC-Modus </h3><br><p>  Um die Periode zu steuern, k√∂nnen Sie einen Teiler verwenden, mit dem Sie das Taktsignal in verschiedene Zweiergrade teilen und die Timer-Periode verl√§ngern k√∂nnen.  Sie m√∂chten beispielsweise, dass die LED im Abstand von einer Sekunde blinkt.  Das TCCR1B-Register enth√§lt drei CS-Bits, die die am besten geeignete Aufl√∂sung einstellen.  Wenn Sie die Bits CS10 und CS12 setzen mit: </p><br><pre> <code class="cpp hljs">TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS10); TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS12);</code> </pre> <br><p>  dann wird die Frequenz der Taktquelle durch 1024 geteilt. Dies ergibt eine Timeraufl√∂sung von 1 / (16 ‚àó 10 ^ 6/1024) oder 6,4e-5 s.  Jetzt l√§uft der Timer alle (65535 ‚àó 6.4e-5s) oder f√ºr 4.194s √ºber.  Es ist zu lang </p><br><p>  Es gibt jedoch einen anderen AVR-Timer-Modus.  Dies wird als Coincident Timer Reset oder CTC bezeichnet.  Anstatt bis zum √úberlauf zu z√§hlen, vergleicht der Timer seinen Z√§hler mit der zuvor im Register gespeicherten Variablen.  Wenn die Anzahl mit dieser Variablen √ºbereinstimmt, kann der Timer entweder ein Flag setzen oder einen Interrupt verursachen, genau wie im Fall eines √úberlaufs. </p><br><p>  Um den CTC-Modus verwenden zu k√∂nnen, m√ºssen Sie wissen, wie viele Zyklen Sie ben√∂tigen, um ein Intervall von einer Sekunde zu erhalten.  Angenommen, das Teilungsverh√§ltnis betr√§gt immer noch 1024. </p><br><p>  Die Berechnung wird wie folgt sein: </p><br><pre> <code class="plaintext hljs">(target time) = (timer resolution) * (# timer counts + 1) (# timer counts + 1) = (target time) / (timer resolution) (# timer counts + 1) = (1 s) / (6.4e-5 s) (# timer counts + 1) = 15625 (# timer counts) = 15625 - 1 = 15624</code> </pre> <br><p>  Sie m√ºssen der Anzahl der Samples eine zus√§tzliche Einheit hinzuf√ºgen, da sich der Z√§hler im CTC-Modus auf Null zur√ºcksetzt, wenn er mit dem eingestellten Wert √ºbereinstimmt.  Das Zur√ºcksetzen dauert eine Taktperiode, die bei den Berechnungen ber√ºcksichtigt werden muss.  In vielen F√§llen ist ein Fehler in einer Periode nicht sehr signifikant, aber bei hochpr√§zisen Aufgaben kann er kritisch sein. </p><br><p>  Die Funktion setup () sieht folgenderma√üen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(LEDPIN, OUTPUT); <span class="hljs-comment"><span class="hljs-comment">//  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //   CTC  //   CS10  CS12    1024 TCCR1B |= (1 &lt;&lt; CS10); TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //     sei(); //    }</span></span></code> </pre> <br><p>  Sie m√ºssen auch den √úberlauf-Interrupt durch einen zuf√§lligen Interrupt ersetzen: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Jetzt schaltet sich die LED genau eine Sekunde lang ein und aus.  Und Sie k√∂nnen alles in einer loop () - Schleife tun.  Bis Sie die Timer-Einstellungen √§ndern, hat das Programm nichts mit Interrupts zu tun.  Sie haben keine Einschr√§nkungen bei der Verwendung eines Timers mit verschiedenen Modi und Einstellungen des Teilers. </p><br><p>  Hier ist ein vollst√§ndiges Startbeispiel, das Sie als Grundlage f√ºr Ihre eigenen Projekte verwenden k√∂nnen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Arduino  CTC  // avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //  CTC  TCCR1B |= (1 &lt;&lt; CS10); //      1024 TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //      sei(); //    } void loop() { //   } ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</span></span></code> </pre> <br><p>  Denken Sie daran, dass Sie die integrierten ISR-Funktionen verwenden k√∂nnen, um die Timerfunktionen zu erweitern.  Beispielsweise m√ºssen Sie den Sensor alle 10 Sekunden abfragen.  Es gibt jedoch keine Timer-Einstellungen, die eine so lange Z√§hlung ohne √úberlauf erm√∂glichen.  Sie k√∂nnen jedoch ISR verwenden, um die Z√§hlvariable einmal pro Sekunde zu erh√∂hen und dann den Sensor abzufragen, wenn die Variable 10 erreicht. Im STS-Modus aus dem vorherigen Beispiel k√∂nnte der Interrupt folgenderma√üen aussehen: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { seconds++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(seconds == <span class="hljs-number"><span class="hljs-number">10</span></span>) { seconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; readSensor(); } }</code> </pre> <br><p>  Da die Variable innerhalb des ISR ge√§ndert wird, muss sie als <em>fl√ºchtig</em> deklariert werden.  Wenn Sie Variablen zu Beginn des Programms beschreiben, m√ºssen Sie daher Folgendes schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> byte seconds;</code> </pre> <br><h3 id="posleslovie-perevodchika">  Nachwort des √úbersetzers </h3><br><p>  Dieser Artikel hat mir einmal viel Zeit bei der Entwicklung eines Prototyp-Messgenerators gespart.  Ich hoffe, dass es f√ºr andere Leser n√ºtzlich sein wird. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453276/">https://habr.com/ru/post/de453276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453260/index.html">DPI-Einstellungsfunktionen</a></li>
<li><a href="../de453262/index.html">Wo sind Ihre Konstanten auf dem CortexM-Mikrocontroller gespeichert (am Beispiel des C ++ IAR-Compilers)?</a></li>
<li><a href="../de453264/index.html">Virtuali-Tee: Ein ‚Äûmedizinisches T-Shirt‚Äú, das nicht bedeckt, sondern freilegt</a></li>
<li><a href="../de453272/index.html">GitHub-Sponsoren: Ein neuer Weg, um zu Open Source beizutragen</a></li>
<li><a href="../de453274/index.html">Versteckte Provision Yandex.Money in Samsung Pay</a></li>
<li><a href="../de453278/index.html">Warum k√ºmmern sich Ingenieure nicht um die Anwendungs√ºberwachung?</a></li>
<li><a href="../de453280/index.html">Technische Schulden</a></li>
<li><a href="../de453286/index.html">Der teuerste Fehler in meinem Leben: Details zum Angriff auf den SIM-Kartenanschluss</a></li>
<li><a href="../de453290/index.html">Data Science Digest (Mai 2019)</a></li>
<li><a href="../de453292/index.html">"Ein kleines Buch √ºber Schwarze L√∂cher"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>