<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗳️ 🙍🏽 💼 Como trabalhar com o Postgres in Go: práticas, recursos, nuances 🏀 ㊙️ 🎆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O comportamento inesperado do aplicativo em relação ao trabalho com o banco de dados leva a uma guerra entre o DBA e os desenvolvedores: DBA grita: "S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como trabalhar com o Postgres in Go: práticas, recursos, nuances</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461935/"><p><img src="https://habrastorage.org/webt/yg/8e/hm/yg8ehmpmicsm7ye6fwju6kwog14.png"></p><br><p>  O comportamento inesperado do aplicativo em relação ao trabalho com o banco de dados leva a uma guerra entre o DBA e os desenvolvedores: DBA grita: "Seu aplicativo descarta o banco de dados", os desenvolvedores - "Mas tudo funcionou antes!"  O pior de tudo é que o DBA e os desenvolvedores não podem ajudar um ao outro: alguns não sabem as nuances do aplicativo e do driver, outros não sabem os recursos relacionados à infraestrutura.  Seria bom evitar tal situação. </p><br><p>  Você precisa entender, geralmente não é suficiente procurar no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">go-database-sql.org</a> .  É melhor se armar com a experiência de outras pessoas.  Ainda melhor se for uma experiência adquirida com sangue e dinheiro perdido. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Uojy57I-xP0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Meu nome é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ryabinkov Artemy</a> e este artigo é uma interpretação gratuita do meu relatório da conferência <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saints HighLoad 2019</a> . </p><br><h1 id="instrumenty">  As ferramentas </h1><br><p>  Você pode encontrar as informações mínimas necessárias sobre como trabalhar com o Go com qualquer banco de dados semelhante ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SQL</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">go-database-sql.org</a> .  Se você ainda não leu, leia. </p><br><h2 id="sqlx">  sqlx </h2><br><p>  Na minha opinião, o poder do Go é a simplicidade.  E isso é expresso, por exemplo, no fato de que o Go costuma escrever consultas em SQL puro (o ORM não é uma honra).  Isso é uma vantagem e uma fonte de dificuldades adicionais. </p><br><p> Portanto, usando o pacote padrão de <code>database/sql</code> idioma <code>database/sql</code> , você desejará expandir suas interfaces.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quando</a> isso acontecer, dê uma olhada em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/jmoiron/sqlx</a> .  Deixe-me mostrar alguns exemplos de como essa extensão pode simplificar sua vida. </p><br><p>  O uso do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">StructScan</a> elimina a necessidade de mudar manualmente os dados das colunas para as propriedades da estrutura. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Place <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> City sql.NullString TelephoneCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`db:"telcode"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place err = rows.StructScan(&amp;p)</code> </pre> <br><p>  O uso do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NamedQuery</a> permite usar propriedades da estrutura como espaços reservados em uma consulta. </p><br><pre> <code class="go hljs">p := Place{Country: <span class="hljs-string"><span class="hljs-string">"South Africa"</span></span>} sql := <span class="hljs-string"><span class="hljs-string">`.. WHERE country=:country`</span></span> rows, err := db.NamedQuery(sql, p)</code> </pre> <br><p>  O uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Get</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Select</a> permite que você se livre da necessidade de gravar manualmente loops que obtêm linhas do banco de dados. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pp []Place <span class="hljs-comment"><span class="hljs-comment">// Get   p     err = db.Get(&amp;p, ".. LIMIT 1") // Select   pp   . err = db.Select(&amp;pp, ".. WHERE telcode &gt; ?", 50)</span></span></code> </pre> <br><h1 id="drayvery">  Drivers </h1><br><p>  <code>database/sql</code> é um conjunto de interfaces para trabalhar com o banco de dados e <code>sqlx</code> é sua extensão.  Para que essas interfaces funcionem, elas precisam de uma implementação.  Os drivers são responsáveis ​​pela implementação. </p><br><p>  Drivers mais populares: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/lib/pq</a> - <code>pure Go Postgres driver for database/sql.</code>  Esse driver permaneceu por muito tempo o padrão padrão.  Hoje, porém, perdeu sua relevância e não está sendo desenvolvida pelo autor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/jackc/pgx</a> - <code>PostgreSQL driver and toolkit for Go.</code>  Hoje é melhor escolher essa ferramenta. </li></ul><br><p>  <strong>github.com/jackc/pgx</strong> - este é o driver que você deseja usar.  Porque </p><br><ul><li>  Ativamente <strong>apoiado e desenvolvido</strong> . </li><li>  Pode ser mais <strong>produtivo</strong> se usado sem interfaces de <code>database/sql</code> . </li><li>  Suporte para mais de <strong>60 tipos de PostgreSQL</strong> que o <code>PostgreSQL</code> implementa fora do padrão <code>SQL</code> . </li><li>  A capacidade de implementar convenientemente o <strong>log</strong> do que está acontecendo dentro do driver. </li><li>  <code>pgx</code> <strong>erros legíveis por humanos</strong> , enquanto apenas <code>lib/pq</code> lança ataques de pânico.  Se você não entrar em pânico, o programa falhará.  ( <em>Você não deve entrar em pânico no Go, isso não é o mesmo que exceção.</em> ) </li><li>  Com o <code>pgx</code> , temos a capacidade de <strong>configurar</strong> independentemente <strong>cada conexão</strong> . </li><li>  Há suporte <strong>para o protocolo de replicação lógica do</strong> <code>PostgreSQL</code> . </li></ul><br><h2 id="4kb">  4KB </h2><br><p>  Normalmente, escrevemos esse loop para obter dados do banco de dados: </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, sql) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { err = rows.Scan(...) }</code> </pre> <br><p>  Dentro do driver, obtemos dados armazenando-os em <strong>um buffer de 4KB</strong> .  <code>rows.Next()</code> gera uma viagem de rede e preenche o buffer.  Se o buffer não for suficiente, vamos à rede para os dados restantes.  Mais visitas à rede - menos velocidade de processamento.  Por outro lado, como o limite do buffer é de 4KB, não vamos esquecer toda a memória do processo. </p><br><p>  Mas, é claro, quero desaparafusar o volume do buffer ao máximo para reduzir o número de solicitações à rede e reduzir a latência do nosso serviço.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adicionamos</a> essa oportunidade e tentamos descobrir a aceleração esperada em <a href="">testes sintéticos</a> : </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run=XXX -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/furdarius/pgxexperiments/bufsize BenchmarkBufferSize/4KB 5 315763978 ns/op 53112832 B/op 12967 allocs/op BenchmarkBufferSize/8KB 5 300140961 ns/op 53082521 B/op 6479 allocs/op BenchmarkBufferSize/16KB 5 298477972 ns/op 52910489 B/op 3229 allocs/op BenchmarkBufferSize/1MB 5 299602670 ns/op 52848230 B/op 50 allocs/op PASS ok github.com/furdarius/pgxexperiments/bufsize 10.964s</code> </pre> <br><p>  Pode-se ver que não há grande diferença na velocidade de processamento.  Porque </p><br><p>  Acontece que estamos limitados pelo tamanho do buffer para enviar dados dentro do próprio Postgres.  Este buffer tem um tamanho <a href="">fixo</a> de 8 <strong>KB</strong> .  Usando <code>strace</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">você pode ver</a> que o sistema operacional retorna <code>8192</code> bytes na chamada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">leitura do</a> sistema.  E o <code>tcpdump</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confirma</a> isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com o</a> tamanho dos pacotes. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tom Lane</a> ( <em>um dos principais desenvolvedores do kernel do Postgres</em> ) <a href="">comenta</a> assim: </p><br><blockquote>  Tradicionalmente, pelo menos, esse era o tamanho dos buffers de tubo nas máquinas Unix, portanto, em princípio, esse é o tamanho de bloco mais ideal para enviar dados através de um soquete Unix. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andres Freund</a> ( <em>desenvolvedor do Postgres do EnterpriseDB</em> ) <a href="">acredita</a> que um buffer de 8 KB não é a melhor opção de implementação até o momento, e você precisa testar o comportamento em tamanhos diferentes e com uma configuração de soquete diferente. </p><br><p>  Também devemos lembrar que o PgBouncer também possui um buffer e seu tamanho pode ser configurado com o parâmetro <code>pkt_buf</code> . </p><br><h2 id="oids">  OIDs </h2><br><p>  Outro recurso do driver pgx ( <em>v3</em> ): para cada conexão, ele faz um pedido ao banco de dados para obter informações sobre o <strong>ID</strong> do <strong>Objeto</strong> ( <em>OID</em> ). </p><br><p>  Esses identificadores foram adicionados ao Postgres para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">identificar exclusivamente</a> objetos internos: linhas, tabelas, funções, etc. </p><br><p>  O driver usa o conhecimento de <code>OIDs</code> para entender qual coluna do banco de dados em qual idioma primitivo adicionar dados.  Para isso, o <code>pgx</code> suporta essa tabela (a <em>chave é o nome do tipo, o valor é ID do objeto</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Value{ <span class="hljs-string"><span class="hljs-string">"_aclitem"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"_bool"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"_int4"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"_int8"</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span>, ... }</code> </pre> <br><p>  Essa implementação leva ao fato de que o driver para cada conexão estabelecida com o banco de dados faz cerca de três solicitações para formar uma tabela com um <code>Object ID</code> .  No modo normal de operação do banco de dados e do aplicativo, o conjunto de conexões no Go permite que você não gere novas conexões com o banco de dados.  Porém, com a menor degradação do banco de dados, o conjunto de conexões no lado do aplicativo se esgota e o número de conexões geradas por unidade de tempo aumenta significativamente.  As solicitações de <code>OIDs</code> bastante pesadas; como resultado, o driver pode levar o banco de dados a um estado crítico. </p><br><p>  Aqui é o momento em que essas solicitações foram despejadas em um de nossos bancos de dados: </p><br><p><img src="https://habrastorage.org/webt/lm/ra/vb/lmravbubtqb2ah8dvbvvpklbz8m.png"></p><br><p>  <strong>15 transações por minuto</strong> no modo normal, um salto de até <strong>6500 transações</strong> durante a degradação. </p><br><p>  <strong>O que fazer</strong> </p><br><p>  Em primeiro lugar, limite o tamanho da sua piscina de cima. </p><br><p>  Para <code>database/sql</code> isso pode ser feito com a função <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DB.SetMaxOpenConns</a> .  Se você abandonar as interfaces de <code>database/sql</code> e usar <code>pgx.ConnPool</code> (o <em>conjunto de conexões implementado pelo próprio driver</em> ), poderá especificar <code>MaxConnections</code> (o <em>padrão é 5</em> ). </p><br><p>  A propósito, ao usar o <code>pgx.ConnPool</code> driver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reutilizará as</a> informações sobre os <code>OIDs</code> recebidos e não fará consultas ao banco de dados para cada nova conexão. </p><br><p>  Se você não quiser recusar o <code>database/sql</code> , poderá armazenar em cache as informações sobre os <code>OIDs</code> . </p><br><pre> <code class="go hljs">github.com/jackc/pgx/stdlib.OpenDB(pgx.ConnConfig{ CustomConnInfo: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgtype.ConnInfo, error)</span></span></span></span> { cachedOids = <span class="hljs-comment"><span class="hljs-comment">//  OIDs   . info := pgtype.NewConnInfo() info.InitializeDataTypes(cachedOids) return info, nil } })</span></span></code> </pre> <br><p>  Este é um método de trabalho, mas usá-lo pode ser perigoso sob duas condições: </p><br><ul><li>  você usa tipos de enumeração ou domínio no Postgres; </li><li>  se o assistente falhar, você alterna o aplicativo para a réplica, que é derramada pela replicação lógica. </li></ul><br><p>  O cumprimento dessas condições leva ao fato de que os <code>OIDs</code> armazenados em cache se tornam inválidos.  Mas não conseguiremos limpá-los, porque não sabemos o momento de mudar para uma nova base. </p><br><p>  No mundo do <code>Postgres</code> , a replicação física geralmente é usada para organizar a alta disponibilidade, que copia as instâncias do banco de dados pouco a pouco; portanto, problemas com o cache do <code>OIDs</code> raramente <code>OIDs</code> vistos na natureza.  ( <em>Mas é melhor verificar com seu DBA como a espera funciona para você</em> ). </p><br><p>  Na próxima versão principal do driver <code>pgx</code> - <code>v4</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não haverá</a> campanhas para <code>OIDs</code> .  Agora, o driver dependerá apenas da lista de <code>OIDs</code> no código.  Para tipos personalizados, você precisará assumir o controle da desserialização no lado do aplicativo: o driver simplesmente abrirá um pedaço de memória como uma matriz de bytes. </p><br><h1 id="logirovanie-i-monitoring">  Registro e Monitoramento </h1><br><p>  O monitoramento e o registro ajudarão a detectar problemas antes que a base falhe. </p><br><p>  <code>database/sql</code> fornece o método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DB.Stats ()</a> .  O instantâneo de status retornado fornecerá uma idéia do que está acontecendo dentro do driver. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DBStats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxOpenConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// Pool State OpenConnections int InUse int Idle int // Counters WaitCount int64 WaitDuration time.Duration MaxIdleClosed int64 MaxLifetimeClosed int64 }</span></span></code> </pre> <br><p>  Se você usar o pool no <code>pgx</code> diretamente, o método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ConnPool.Stat ()</a> fornecerá informações semelhantes: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnPoolStat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AvailableConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  O registro é igualmente importante e o <code>pgx</code> permite que você faça isso.  O driver aceita a interface do <code>Logger</code> , implementando qual, você obtém todos os eventos que ocorrem dentro do driver. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Log a message at the given level with data key/value pairs. // data may be nil. Log(level LogLevel, msg string, data map[string]interface{}) }</span></span></code> </pre> <br><p>  Provavelmente, você nem precisa implementar essa interface.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgx pronto para uso</a> , há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto de adaptadores</a> para os registradores mais populares, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uber-go / zap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sirupsen / logrus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rs / zerolog</a> . </p><br><h1 id="infrastruktura">  A infraestrutura </h1><br><p>  Quase sempre, ao trabalhar com o <code>Postgres</code> você usará o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pool de</a> <strong>conexões</strong> , e será o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PgBouncer</a> ( <em>ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">odisséia</a> - se você é Yandex</em> ). </p><br><p>  Por isso, você pode ler o excelente artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">brandur.org/postgres-connections</a> .  Em resumo, quando o número de clientes <strong>excede 100, a</strong> velocidade das solicitações de processamento começa a diminuir.  Isso acontece devido aos recursos da implementação do Postgres: o lançamento de um processo separado para cada conexão, o mecanismo para remover instantâneos e o uso de memória compartilhada para interação - tudo isso afeta. </p><br><p>  Aqui está a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">referência de</a> várias implementações do pool de conexões: <br><img src="https://habrastorage.org/webt/im/p1/-n/imp1-nuasdxn1wmve7l89rrvmbw.png"></p><br><p>  E <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compare a</a> largura de banda com e sem o PgBouncer. </p><br><p><img src="https://habrastorage.org/webt/jc/cp/21/jccp2150oefyeiixeu005lpsl_0.png"></p><br><p>  Como resultado, sua infraestrutura ficará assim: </p><br><p><img src="https://habrastorage.org/webt/bf/ee/ok/bfeeokt_cdojbuddo7_rhzddjis.png"></p><br><p>  Onde <code>Server</code> é o processo que processa solicitações do usuário.  Esse processo gira em <code>kubernetes</code> em 3 cópias ( <em>pelo menos</em> ).  Separadamente, em um servidor de ferro, existe o <code>Postgres</code> , coberto pelo <code>PgBouncer'</code> .  <code>PgBouncer</code> próprio <code>PgBouncer</code> de thread único, então lançamos vários bouncers, cujo tráfego é equilibrado usando o <code>HAProxy</code> .  Como resultado, obtemos uma cadeia de execução de consulta no banco de dados: <code>   → HAProxy → PgBouncer → Postgres</code> . </p><br><p>  <code>PgBouncer</code> pode funcionar em três modos: </p><br><ul><li>  <strong>Pool de sessões</strong> - para cada sessão, uma conexão é emitida e atribuída a ela por todo o tempo de vida. </li><li>  <strong>Pool de transações</strong> - a conexão permanece enquanto a transação está em execução.  Assim que a transação é concluída, o <code>PgBouncer</code> pega essa conexão e a devolve para outra transação.  Este modo permite uma disposição muito boa de compostos. </li><li>  <strong>Conjunto de instruções</strong> - modo <strong>descontinuado</strong> .  Foi criado apenas para dar suporte ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PL / Proxy</a> . </li></ul><br><p>  Você pode ver a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">matriz</a> de quais propriedades estão disponíveis em cada modo.  Escolhemos o <strong>Pool de Transações</strong> , mas ele tem limitações para trabalhar com <code>Prepared Statements</code> . </p><br><h2 id="transaction-pooling--prepared-statements">  Pool de Transações + Instruções Preparadas </h2><br><p>  Vamos imaginar que queremos preparar uma solicitação e executá-la.  Em algum momento, iniciamos uma transação na qual enviamos uma solicitação de Preparação e obtemos o ID da solicitação preparada no banco de dados. </p><br><p><img src="https://habrastorage.org/webt/pb/tu/bq/pbtubqa7cvmly0ntnhs0dwc9etc.png"></p><br><p>  Depois, em qualquer outro momento, geramos outra transação.  Nele, nos voltamos para o banco de dados e queremos atender à solicitação usando o identificador com os parâmetros especificados. </p><br><p><img src="https://habrastorage.org/webt/uy/ci/h4/uycih4iuh8aasw43aqodbsxolac.png"></p><br><p>  No modo <strong>Pool de Transações</strong> , duas transações podem ser executadas em conexões diferentes, mas o <strong>ID</strong> da <strong>Instrução é</strong> válido apenas dentro de uma conexão.  Recebemos uma <code>prepared statement does not exist</code> erro ao tentar executar uma solicitação. </p><br><p>  O mais desagradável: como durante o desenvolvimento e o teste a carga é pequena, o <code>PgBouncer</code> geralmente emite a mesma conexão e tudo funciona corretamente.  Mas assim que lançamos o produto, as solicitações começam a cair com um erro. </p><br><p>  Agora encontre <code>Prepared Statements</code> neste código: </p><br><pre> <code class="go hljs">sql := <span class="hljs-string"><span class="hljs-string">`select * from places where city = ?`</span></span> rows, err := s.db.Query(sql, city)</code> </pre> <br><p>  Você não o verá!  A preparação da consulta ocorrerá implicitamente dentro de <code>Query()</code> .  Ao mesmo tempo, a preparação e a execução da solicitação ocorrerão em diferentes transações e receberemos totalmente tudo o que descrevi acima. </p><br><p>  <strong>O que fazer</strong> </p><br><p>  A primeira opção mais fácil é <strong>alternar o <code>PgBouncer</code> para o <code>Session pooling</code></strong> .  Uma conexão é alocada para a sessão, todas as transações começam a ocorrer nessa conexão e as solicitações preparadas funcionam corretamente.  Mas, nesse modo, a eficiência da utilização de compostos deixa muito a desejar.  Portanto, esta opção não é considerada. </p><br><p>  A segunda opção é <strong>preparar uma solicitação no lado do cliente</strong> .  Não quero fazer isso por dois motivos: </p><br><ul><li>  Potenciais vulnerabilidades SQL.  O desenvolvedor pode esquecer ou fazer incorretamente escapar. </li><li>  Escapar dos parâmetros da consulta toda vez que você precisar escrever com as mãos. </li></ul><br><p>  Outra opção é <strong>agrupar explicitamente cada solicitação em uma transação</strong> .  Afinal, enquanto a transação <code>PgBouncer</code> , o <code>PgBouncer</code> não <code>PgBouncer</code> a conexão.  Isso funciona, mas, além da verbosidade em nosso código, também recebemos mais chamadas de rede: Iniciar, Preparar, Executar, Confirmar.  Total de 4 chamadas de rede por solicitação.  Latência está crescendo. </p><br><p>  Mas eu quero isso com segurança, conveniência e eficiência.  E existe essa opção!  Você pode dizer explicitamente ao driver que deseja <strong>usar o modo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consulta Simples</a></strong> .  Nesse modo, não haverá preparação e toda a solicitação passará em uma chamada de rede.  Nesse caso, o driver fará a blindagem de cada um dos parâmetros em si (as <em><code>standard_conforming_strings</code> devem ser ativadas no nível base ou ao estabelecer uma conexão</em> ). </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... RuntimeParams: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"standard_conforming_strings"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span>, }, PreferSimpleProtocol: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }</code> </pre> <br><h1 id="otmena-zaprosov">  Cancelar solicitações </h1><br><p>  Os seguintes problemas estão relacionados ao cancelamento de solicitações no lado do aplicativo. </p><br><p>  Dê uma olhada neste código.  Onde estão as armadilhas? </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, ...)</code> </pre> <br><p>  Go possui um método para controlar o fluxo de execução do programa - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">context.Context</a> .  Nesse código, passamos o <code>ctx</code> driver para que, quando o contexto for fechado, o driver cancele a solicitação no nível do banco de dados. </p><br><p>  Ao mesmo tempo, espera-se que economizemos recursos, cancelando solicitações pelas quais ninguém está esperando.  Porém, ao cancelar uma solicitação, o <code>PgBouncer</code> versão <em>1.7</em> envia informações para a conexão de que essa conexão está pronta para uso e depois a retorna para o pool.  Esse comportamento do <code>PgBouncer'</code> está enganando o driver, que, ao enviar a próxima solicitação, recebe instantaneamente o <code>ReadyForQuery</code> em resposta.  No final, detectamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">erros inesperados do ReadyForQuery</a> . </p><br><p>  Começando com o <code>PgBouncer</code> versão <em>1.8,</em> esse comportamento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">foi corrigido</a> .  Use a versão atual do <code>PgBouncer</code> . </p><br><p>  E, embora, neste caso, os erros desapareçam - um comportamento interessante permanecerá.  Em alguns casos, nosso aplicativo pode receber respostas não à sua solicitação, mas à vizinha (a principal é que as solicitações correspondam ao tipo e ordem dos dados solicitados).  Isso é, por exemplo, para a consulta em <code>where user_id = 2</code> , a resposta da consulta em <code>where user_id = 42</code> será retornada.  Isso ocorre devido ao processamento de solicitações de cancelamento em diferentes níveis: no nível do pool de drivers e do bouncer. </p><br><h3 id="otlozhennaya-otmena">  Cancelamento atrasado </h3><br><p>  Para cancelar a solicitação, precisamos criar uma nova conexão com o banco de dados e solicitar um cancelamento.  <code>Postgres</code> cria um processo separado para cada conexão.  Enviamos um comando para cancelar a solicitação <strong>atual</strong> em um processo específico.  Para isso, crie uma nova conexão e transfira a identificação do processo (PID) de seu interesse.  Mas enquanto o comando de cancelamento voa para a base, a solicitação cancelada pode terminar sozinha. </p><br><p><img src="https://habrastorage.org/webt/us/xf/v_/usxfv_i0ze_axpmjtlir183reiu.png"></p><br><p>  <code>Postgres</code> executará o comando e cancelará a solicitação <strong>atual</strong> no processo especificado.  Mas a solicitação atual não será a que queremos cancelar inicialmente.  Devido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse comportamento</a> ao trabalhar com o <code>Postgres</code> com o <code>PgBouncer</code> mais seguro não cancelar a solicitação no nível do driver.  Para fazer isso, você pode definir a <code>CustomCancel</code> , que não cancelará a solicitação, mesmo que <code>context.Context</code> usado. </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... CustomCancel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, }</code> </pre> <br><h1 id="cheklist-po-rabote-s-postgres">  Lista de verificação do Postgres </h1><br><p>  Em vez de conclusões, decidi fazer uma lista de verificação para trabalhar com o Postgres.  Isso deve ajudar o artigo a se encaixar na minha cabeça. </p><br><ul><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/jackc/pgx</a> como um driver para trabalhar com o Postgres. </li><li>  Limite o tamanho do pool de conexões de cima. </li><li>  Faça cache de <code>OIDs</code> ou use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgx.ConnPool</a> se estiver trabalhando com a versão 3 do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgx</a> . </li><li>  Colete métricas do pool de conexões usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DB.Stats ()</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ConnPool.Stat ()</a> . </li><li>  Registre o que está acontecendo no driver. </li><li>  Use o modo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consulta Simples</a> para evitar problemas com a preparação de consultas no modo transacional <code>PgBouncer</code> . </li><li>  Atualize o <code>PgBouncer</code> para a versão mais recente. </li><li>  Cuidado ao cancelar solicitações do aplicativo. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461935/">https://habr.com/ru/post/pt461935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461919/index.html">Reutilizando formulários no React</a></li>
<li><a href="../pt461921/index.html">HDMI-LVDS. Desenvolvimento em TSUMV59 de MStar</a></li>
<li><a href="../pt461923/index.html">Dia Aberto do JetBrains em São Petersburgo: vídeo</a></li>
<li><a href="../pt461927/index.html">Aprendizagem do Ranking Ativo</a></li>
<li><a href="../pt461929/index.html">Monitorando e Verificando o Status do SSD no Linux</a></li>
<li><a href="../pt461937/index.html">A lei de Parkinson e como quebrá-la</a></li>
<li><a href="../pt461939/index.html">Ano de aventura com grafeno-python</a></li>
<li><a href="../pt461941/index.html">Massageie</a></li>
<li><a href="../pt461945/index.html">Resumo de eventos para profissionais de RH na área de TI em agosto de 2019</a></li>
<li><a href="../pt461949/index.html">AppCode 2019.2: Swift 5.1, análise de cobertura de código por testes, exibição de código desmontado e muito mais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>