<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏻 🙇🏻 👨🏻‍🏫 Olahpesan -> PubSub di dalam OTP 🗽 🚶🏾 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OTP adalah singkatan dari Open Telecom Platform ; jadi itu terjadi secara historis, karena platform diciptakan untuk kebutuhan dan uang Ericsson . Tet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Olahpesan -> PubSub di dalam OTP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481460/"><p>  <a href="https://en.wikipedia.org/wiki/Open_Telecom_Platform" rel="nofollow">OTP</a> adalah singkatan dari <em>Open Telecom Platform</em> ;  jadi itu terjadi secara historis, karena platform diciptakan untuk kebutuhan dan uang <em>Ericsson</em> .  Tetapi, pada prinsipnya, nama ini memiliki konotasi sebanyak dengan fungsinya seperti apel dengan ponsel berkualitas rata-rata. </p><br><p>  Karakteristik pembeda utama <em>OTP,</em> menurut penulis, adalah toleransi kesalahan.  Bukan multithreading, bukan model aktor, tidak kaya fitur pencocokan pola, bahkan pengelompokan tidak transparan dan tidak pembaruan kode panas.  Toleransi kesalahan. </p><br><p>  Mesin virtual Erlang dirancang sangat sederhana: ada banyak "proses" (bukan proses sistem, proses erlang) dengan memori terisolasi yang dapat bertukar pesan.  Itu saja.  Inilah yang dikatakan Joe Armstrong tentang ini: </p><br><blockquote> Di blog saya, saya berpendapat bahwa proses harus berperilaku seperti orang.  Orang-orang memiliki kenangan pribadi dan bertukar data dengan mengirimkan pesan. <br>  - <a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-dont-like-shared-memory.html" rel="nofollow">Mengapa saya tidak suka memori bersama</a> </blockquote><p>  Perpesanan di dalam OTP sangat sederhana: satu proses mengirim pesan ke yang lain (atau sekelompok proses lain), secara sinkron, atau tidak sinkron.  Tetapi untuk ini, Anda perlu tahu kepada siapa harus mengirim pesan-pesan ini.  Artinya, pengirimnya adalah manajer pertukaran.  Tetapi bagaimana jika kita hanya ingin mengirim siaran dan memungkinkan semua proses yang tertarik untuk berlangganan pesan ini? </p><a name="habracut"></a><br><p>  Ya, ini adalah PubSub biasa, tetapi di luar kotak dalam OTP tidak diterapkan.  Yah, itu tidak masalah, kita memiliki semua batu bata dalam satu jam untuk membuatnya bertekuk lutut.  Mari kita mulai. </p><br><h3 id="varianty-realizacii">  Opsi implementasi </h3><br><p> Pada dasarnya, <em>Elixir</em> termasuk modul <a href="https://hexdocs.pm/elixir/master/Registry.html" rel="nofollow"><code>Registry</code></a> yang dapat digunakan sebagai <a href="https://hexdocs.pm/elixir/master/Registry.html" rel="nofollow">perancah untuk pubsub</a> .  Sedikit kode tenunan sendiri, penampilan rapi dari semua peserta (pengawas untuk semua orang), dan Anda selesai.  Satu-satunya masalah adalah bahwa <code>Registry</code> lokal dan tidak tahu cara mengelompokkan.  Artinya, dalam lingkungan terdistribusi (node ​​terdistribusi) keindahan ini tidak akan berfungsi. </p><br><p>  <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html" rel="nofollow"><code>Phoenix.PubSub</code></a> kami, ada implementasi terdistribusi dari <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html" rel="nofollow"><code>Phoenix.PubSub</code></a> , yang dilengkapi dengan dua implementasi siap pakai: <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.PG2.html" rel="nofollow"><code>Phoenix.PubSub.PG2</code></a> dan <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html" rel="nofollow"><code>Phoenix.PubSub.Redis</code></a> .  Ya, <code>Redis</code> jelas merupakan tautan tambahan dalam rantai kami, tetapi <code>PG2</code> , yang bekerja di atas kelompok Erlang proses <a href="http://erlang.org/doc/man/pg2.html" rel="nofollow"><code>pg2</code></a> , adalah itu.  Namun, tanpa boilerplate tidak akan berhasil. </p><br><p>  Jadi, kami memiliki segalanya untuk membuat langganan <em>PubSub yang</em> nyaman di aplikasi kami.  Apakah sudah waktunya membuka editor teks?  "Tidak juga."  Saya tidak suka menduplikasi kode dari proyek ke proyek, dan semua yang saya dapat mengisolasi ke perpustakaan terisolasi untuk digunakan kembali. </p><br><h3 id="envio">  Envío </h3><br><p>  Jadi paket <a href="https://hexdocs.pm/envio" rel="nofollow"><code>Envío</code></a> lahir.  Karena obrolan, seperti yang Anda tahu, tidak bernilai sepeser pun, kami akan mulai dengan contoh penggunaan. </p><br><h4 id="lokalnaya-rassylka--registry">  Newsletter Lokal → <code>Registry</code> </h4><br><pre> <code class="ruby hljs">defmodule MyApp.Sub <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Envio.Subscriber, <span class="hljs-symbol"><span class="hljs-symbol">channels:</span></span> [{MyApp.Pub, <span class="hljs-symbol"><span class="hljs-symbol">:main</span></span>}] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_envio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message, state)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># optionally call the default implementation {:noreply, state} = super(message, state) # handle it! IO.inspect({message, state}, label: "Received") # respond with `{:noreply, state}` as by contract {:noreply, state} end end</span></span></code> </pre> <br><p>  Itu, secara umum, itu saja.  Tetap <code>MyApp.Sub</code> ke dalam pohon pengawas kami, dan proses ini akan mulai menerima semua pesan yang dikirim menggunakan fungsi dari <code>MyApp.Pub</code> , yang juga tidak dibebani dengan kode. </p><br><pre> <code class="ruby hljs">defmodule MyApp.Pub <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Envio.Publisher, <span class="hljs-symbol"><span class="hljs-symbol">channel:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:main</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel, what)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> broadcast(channel, what) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(what)</span></span></span></span>, <span class="hljs-symbol"><span class="hljs-symbol">do:</span></span> broadcast(what) <span class="hljs-comment"><span class="hljs-comment"># send to :main end</span></span></code> </pre> <br><h4 id="raspredelennaya-rassylka--pg2">  Newsletter Terdistribusi → <code>PG2</code> </h4><br><p>  Untuk sistem terdistribusi yang terdiri dari banyak node, metode ini tidak akan berfungsi.  Kami harus dapat berlangganan pesan dari node lain, dan <code>Registry</code> bukan asisten di sini.  Tetapi ada <code>PG2</code> yang mengimplementasikan <code>behaviour</code> sama. </p><br><pre> <code class="ruby hljs">defmodule Pg2Sucker <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Envio.Subscriber, <span class="hljs-symbol"><span class="hljs-symbol">channels:</span></span> [<span class="hljs-string"><span class="hljs-string">"main"</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">manager:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:phoenix_pub_sub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_envio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message, state)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:noreply</span></span>, state} = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(message, state) IO.inspect({message, state}, <span class="hljs-symbol"><span class="hljs-symbol">label:</span></span> <span class="hljs-string"><span class="hljs-string">"Received"</span></span>) {<span class="hljs-symbol"><span class="hljs-symbol">:noreply</span></span>, state} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Satu-satunya perbedaan dari kode mandiri di atas adalah <code>manager: :phoenix_pub_sub</code> parameter yang kami berikan untuk <code>use Envio.Subscriber</code> (dan <code>use Envio.Publisher</code> ) untuk membangun modul berdasarkan pada <code>:pg2</code> alih-alih <code>Registry</code> lokal.  Sekarang pesan yang dikirim menggunakan <code>Publisher</code> ini akan tersedia di semua node di cluster. </p><br><h3 id="primenenie">  Aplikasi </h3><br><p>  <a href="https://hexdocs.pm/envio" rel="nofollow"><code>Envío</code></a> mendukung apa yang disebut sebagai <a href="https://hexdocs.pm/envio/backends.html" rel="nofollow">backends</a> .  <code>Envio.Slack</code> hadir dengan <code>Envio.Slack</code> , yang memungkinkan Anda untuk menyederhanakan pengiriman pesan ke <code>Slack</code> .  Semua yang diperlukan dari aplikasi adalah mengirim pesan ke saluran yang dikonfigurasi dalam file <code>config/prod.exs</code> - <code>Envío</code> akan melakukan <code>Envío</code> .  Berikut ini contoh konfigurasi: </p><br><pre> <code class="ruby hljs">config <span class="hljs-symbol"><span class="hljs-symbol">:envio</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:backends</span></span>, <span class="hljs-string"><span class="hljs-string">%{ Envio.Slack =&gt; %{ {MyApp.Pub, :slack}</span></span> =&gt; [ <span class="hljs-symbol"><span class="hljs-symbol">hook_url:</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:system</span></span>, <span class="hljs-string"><span class="hljs-string">"SLACK_ENVIO_HOOK_URL"</span></span>} ] } }</code> </pre> <br><p>  Sekarang semua pesan yang dikirim dengan memanggil <code>MyApp.Pub.publish(:slack, %{foo: :bar})</code> akan dikirimkan ke saluran yang sesuai di <em>Slack</em> , diformat dengan indah.  Untuk berhenti mengirim pesan ke <em>Slack</em> , cukup hentikan proses <code>Envio.Slack</code> .  Contoh lainnya (misalnya, log in <code>IO</code> ) dapat ditemukan dalam tes. </p><br><p>  Mengapa saya menyalibkan, coba sendiri. </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deps</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> [ {:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">envio</span></span></span><span class="hljs-function">, "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">~</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> 0.8"} ] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  Komunikasi yang baik! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481460/">https://habr.com/ru/post/id481460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481446/index.html">Pengantar Arsitektur Keamanan 5G: NFV, Kunci, dan 2 Otentikasi</a></li>
<li><a href="../id481450/index.html">Bagaimana kami mengotomatiskan pengiriman makanan pada Aiko</a></li>
<li><a href="../id481452/index.html">Investor Rusia akan dapat membeli saham di bursa London dan Hong Kong</a></li>
<li><a href="../id481456/index.html">Swift: Kontainer untuk menyimpan nilai-nilai kunci</a></li>
<li><a href="../id481458/index.html">Programmer fanatik. Abstrak bagian 2 + tabel abstrak. Ikan, Giants, dan Mentor</a></li>
<li><a href="../id481462/index.html">Sejarah perangkat lunak pendidikan: pengembangan komputer pribadi dan guru virtual</a></li>
<li><a href="../id481466/index.html">Cara membangun proyek di Jenkins, jika Anda membutuhkan banyak lingkungan berbeda</a></li>
<li><a href="../id481470/index.html">Karangan bunga pintar untuk sepanjang tahun</a></li>
<li><a href="../id481472/index.html">Riwayat DNS: Saat Nama Domain Dibayar</a></li>
<li><a href="../id481474/index.html">Kami dari tes lain - kami sedang menguji database di MSTest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>