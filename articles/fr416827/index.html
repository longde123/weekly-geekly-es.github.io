<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíó ü¶ä üåù Conteneurs pour adultes (partie 02): un guide pratique de la terminologie üé£ üë©‚Äçüëß üìØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreux mod√®les de construction de conteneurs. Un conteneur n'est qu'une version ex√©cutable de sa propre image. Par cons√©quent, la fa√ßon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conteneurs pour adultes (partie 02): un guide pratique de la terminologie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416827/">  Il existe de nombreux mod√®les de construction de conteneurs.  Un conteneur n'est qu'une version ex√©cutable de sa propre image.  Par cons√©quent, la fa√ßon de cr√©er un conteneur est √©troitement li√©e √† la fa√ßon dont il d√©marre. <br><br>  Certaines images de conteneur fonctionnent correctement sans privil√®ges sp√©ciaux; d'autres n√©cessitent des privil√®ges root.  De plus, la m√™me image / conteneur peut combiner plusieurs mod√®les de construction et sc√©narios d'utilisation √† la fois. <br><br><img src="https://habrastorage.org/webt/vb/ka/oc/vbkaocfqfq-tdb_a97lu5sifqna.png" width="100%"><br><br>  Ci-dessous, nous examinerons les cas d'utilisation de conteneurs les plus courants. <br><br>  (Pour une introduction √† la terminologie des conteneurs, voir la premi√®re <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie</a> ) <br><a name="habracut"></a><br><h3>  Sc√©narios d'utilisation des conteneurs </h3><br><h4>  Conteneurs d'application </h4><br>  Les conteneurs d'application sont le type de conteneur le plus courant.  Les d√©veloppeurs et les propri√©taires d'applications les g√®rent et ils contiennent eux-m√™mes le code source, ainsi que des √©l√©ments comme MySQL, Apache, MongoDB et Node.js. <br><br>  Un vaste √©cosyst√®me de conteneurs d'application se forme.  Des projets comme Software Collections fournissent des images de conteneurs d'applications s√©curis√©es et prises en charge pour Red Hat Enterprise Linux.  Dans le m√™me temps, les membres de la communaut√© Red Hat d√©veloppent et prennent en charge des conteneurs d'applications innovants. <br><br>  Chez Red Hat, nous pensons que les conteneurs d'applications n'ont g√©n√©ralement pas besoin de privil√®ges sp√©ciaux.  Cependant, lors de la cr√©ation d'environnements de production de conteneurs, d'autres conteneurs sont n√©cessaires. <br><br><h4>  Conteneurs de syst√®me d'exploitation </h4><br>  Le conteneur du syst√®me d'exploitation est un conteneur qui ressemble beaucoup plus √† un syst√®me d'exploitation virtuel √† part enti√®re.  Ces conteneurs utilisent √©galement le noyau h√¥te, mais ex√©cutent le syst√®me d'initialisation complet, ce qui leur permet d'ex√©cuter facilement plusieurs processus.  Des exemples de conteneurs de syst√®me d'exploitation sont LXC et LXD. <br><br>  Les conteneurs du syst√®me d'exploitation peuvent, en principe, √™tre √©mul√©s √† l'aide de conteneurs docker / OCI, √† condition que vous puissiez ex√©cuter le syst√®me √† l'int√©rieur afin que l'utilisateur final puisse installer le logiciel √† l'int√©rieur de ces conteneurs de la mani√®re habituelle et les per√ßoit comme un syst√®me d'exploitation virtuel √† part enti√®re. <br><br><pre><code class="hljs sql">yum <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> mysql systemctl <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> mysql</code> </pre> <br>  Cela simplifie consid√©rablement la conteneurisation des applications existantes.  Red Hat travaille dur pour simplifier les conteneurs du syst√®me d'exploitation en permettant √† systemd de s'ex√©cuter √† l'int√©rieur du conteneur et d'utiliser le d√©mon usin√©.  Bien que de nombreux clients ne soient pas encore pr√™ts pour l'architecture de microservices, la transition vers un mod√®le de livraison de logiciels conteneuris√© bas√© sur des images de conteneurs peut encore leur offrir de nombreux avantages. <br><br><h4>  Conteneurs pour animaux </h4><br>  Bien que Red Hat recommande fortement, promeuve et supporte l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®les bas√©s</a> sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud</a> lors du d√©veloppement de nouvelles applications, nous sommes bien conscients que toutes les applications existantes ne seront pas r√©√©crites de cette mani√®re.  En particulier, parce que beaucoup d'entre eux sont si uniques et inimitables que, par rapport aux applications standard, ils ressemblent √† des animaux domestiques ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pets</a> ) contre un troupeau de vaches.  C'est pour de telles applications que des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneurs</a> sp√©ciaux pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">animaux de compagnie</a> sont con√ßus. <br><br>  Les conteneurs pour animaux de compagnie combinent la portabilit√© et la commodit√© d'une infrastructure de conteneurs bas√©e sur des serveurs de registre, des images de conteneurs et des h√¥tes de conteneurs avec la flexibilit√© d'un environnement informatique traditionnel, impl√©ment√© dans un conteneur s√©par√©.  L'id√©e ici est de simplifier la conteneurisation des applications existantes en raison de la m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capacit√© √† utiliser systemd √† l'int√©rieur du conteneur</a> pour utiliser les outils d'automatisation existants, les installations logicielles et d'autres outils pour cr√©er facilement des images pr√™tes pour le lancement. <br><br><h4>  Conteneurs Super Privil√®ge </h4><br>  Lors de la construction d'une infrastructure de conteneurs bas√©e sur des h√¥tes de conteneurs d√©di√©s tels que Red Hat Enterprise Linux Atomic Host, les administrateurs syst√®me doivent toujours g√©rer.  Et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneurs Super Privileged</a> (SPC) s'av√®rent tr√®s utiles dans de tels environnements distribu√©s, que ce soit Kubernetes, OpenShift ou m√™me des conteneurs autonomes.  Les SPC peuvent m√™me charger des modules de noyau sp√©cialis√©s, tels que systemtap. <br><br>  Dans l'infrastructure cr√©√©e pour ex√©cuter les conteneurs, les administrateurs auront probablement besoin de conteneurs SPC pour effectuer des t√¢ches telles que la surveillance, la sauvegarde, etc. Il est important de comprendre que, puisque les conteneurs SPC sont g√©n√©ralement beaucoup plus connect√©s au noyau h√¥te, les administrateurs doivent Portez une attention particuli√®re aux probl√®mes de fiabilit√© et de normalisation lors du choix des syst√®mes d'exploitation h√¥tes, en particulier dans les grands environnements en cluster et distribu√©s qui rendent le d√©pannage difficile.  De plus, les administrateurs doivent s'assurer que l'espace utilisateur dans le SPC est compatible avec le noyau h√¥te. <br><br><h4>  Outils et logiciels syst√®me </h4><br>  Les distributions Linux ont toujours fourni √† l'utilisateur des logiciels syst√®me, tels que Rsyslogd, SSSD, sadc, etc.  En particulier, Red Hat propose des √©l√©ments tels que des conteneurs pr√™ts √† l'emploi tels que les outils de virtualisation Red Hat, rsyslog, sssd et sadc. <br><br><h3>  Architecture de conteneur </h3><br>  Alors que la livraison de logiciels conteneuris√©s prend de l'ampleur, de nouveaux mod√®les de conception de conteneurs apparaissent.  Dans cette section, nous parlerons de certains d'entre eux. <br><br>  La fa√ßon dont le conteneur est enregistr√© sur le disque (en d'autres termes, le format de l'image) peut grandement affecter la fa√ßon dont il d√©marre.  Par exemple, un conteneur con√ßu pour ex√©cuter sssd doit avoir des privil√®ges sp√©ciaux √† chaque d√©marrage, sinon il ne pourra pas faire son travail.  Ci-dessous, nous examinons bri√®vement les principaux mod√®les qui sont actuellement en cours de formation active. <br><br><h4>  Images d'application </h4><br>  C'est avec ces images que les utilisateurs finaux traitent.  Les sc√©narios d'utilisation de ces images vont du SGBD et des serveurs Web aux applications individuelles et aux bus de service.  Ces images peuvent √™tre cr√©√©es en interne par l'organisation ou fournies par des √©diteurs de logiciels.  Par cons√©quent, les utilisateurs finaux se rapportent souvent au contenu de ces conteneurs autonomes avec prudence et scrupule.  De plus, bien qu'il s'agisse de l'option la plus simple pour l'utilisateur final de conteneurs, les images autonomes sont beaucoup plus difficiles √† concevoir, √† construire et √† corriger. <br><br><h4>  Images de base </h4><br>  Une image de base est l'un des types d'images les plus simples.  Cependant, les gens peuvent d√©signer ce terme avec une vari√©t√© de choses, par exemple, un assemblage d'entreprise standard ou m√™me une image d'application.  Bien que, √† proprement parler, ce ne soient pas des images basiques, mais interm√©diaires. <br>  Il suffit donc de pr√©ciser que l'image de base est une image qui n'a pas de couche parente.  Les images de base contiennent g√©n√©ralement une copie propre du syst√®me d'exploitation, ainsi que les outils n√©cessaires pour installer des packages logiciels ou mettre √† jour l'image ult√©rieurement (yum, rpm, apt-get, dnf, microdnf).  Les images de base peuvent √™tre collect√©es manuellement par l'utilisateur final, mais dans la pratique, elles sont g√©n√©ralement cr√©√©es et publi√©es par des communaut√©s de d√©veloppement (par exemple Debian, Fedora ou CentOS) ou des fournisseurs de logiciels (par exemple Red Hat).  L'origine de l'image de base est critique pour la s√©curit√©.  En r√©sum√©, le but principal et unique de l'image de base est de fournir une base sur la base de laquelle vous pouvez cr√©er vos images enfants.  Lors de l'utilisation de dockerfile, la s√©lection de l'image de base sous-jacente se fait explicitement: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> registry.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.redhat.com/rhel7-atomic</code> </pre> <br><h4>  Images de g√©n√©rateur </h4><br>  Il s'agit d'un type d'image sp√©cial sur la base duquel les images enfants des conteneurs d'application sont ensuite cr√©√©es.  Les images du g√©n√©rateur incluent tout sauf le code source √©crit par les d√©veloppeurs, √† savoir les biblioth√®ques de syst√®me d'exploitation, les runtimes de langage, les middlewares et les outils <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source-√†-image</a> . <br><br>  Au d√©marrage, l'image du g√©n√©rateur extrait le code source de l'application √©crit par les d√©veloppeurs et cr√©e une image enfant du conteneur d'application pr√™te √† √™tre lanc√©e, qui peut ensuite √™tre ex√©cut√©e dans un environnement de d√©veloppement ou de production. <br><br>  Disons que les d√©veloppeurs ont √©crit le code PHP de l'application et veulent l'ex√©cuter dans le conteneur.  Pour ce faire, ils prennent simplement l'image de g√©n√©rateur de PHP et lui transmettent l'URL sur le site Web GitHub, o√π leur code est stock√©.  En cons√©quence, les d√©veloppeurs pr√©parent une image de conteneur d'application pour le lancement qui contient Red Hat Enterprise Linux, PHP des collections de logiciels et, bien s√ªr, le code PHP source de l'application. <br><br>  Les images Builder sont un moyen puissant, simple et rapide de transformer le code source en un conteneur construit sur la base de composants fiables. <br><br><h4>  Composants conteneuris√©s </h4><br>  Un conteneur est principalement destin√© √† √™tre d√©ploy√© en tant que composant d'un syst√®me logiciel plus important, et non en tant qu'unit√© autonome.  Et il y a deux raisons principales √† cela. <br><br>  Premi√®rement, l'architecture de microservices augmente la libert√© de choix des composants et conduit √©galement √† une augmentation du nombre de composants √† partir desquels les applications et les syst√®mes logiciels sont compos√©s.  Les composants conteneuris√©s aident √† d√©ployer ces syst√®mes plus rapidement et plus facilement.  Par exemple, les images de conteneurs permettent de r√©soudre facilement le probl√®me de la coexistence de diff√©rentes versions du m√™me composant.  Et des outils de d√©finition d'applications tels que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©ploiements yaml / json</a> dans Kubernetes / OpenShift, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Open Service Broker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenShift Templates</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Helm Charts</a> permettent de cr√©er des descriptions d'applications de haut niveau. <br><br>  Deuxi√®mement, loin d'√™tre toujours, toutes les parties d'un syst√®me logiciel peuvent √™tre facilement conteneuris√©es.  Par cons√©quent, il est logique de n'effectuer la conteneurisation que pour les composants individuels les plus appropri√©s ou les plus prometteurs en termes de r√©sultats.  Dans les applications multiservices, une partie des services peut √™tre d√©ploy√©e en tant que conteneurs, et l'autre en utilisant des m√©thodes traditionnelles, comme RPM ou des scripts d'installation, voir conteneurs pour animaux de compagnie.  De plus, certains composants peuvent √™tre difficiles √† conteneuriser, car ils sont mal divis√©s en composants, ou sont li√©s √† du mat√©riel sp√©cial, ou utilisent des appels d'API de noyau de bas niveau, etc. Par cons√©quent, dans un grand syst√®me logiciel, tr√®s probablement il y aura des pi√®ces qui peuvent √™tre conteneuris√©es et des pi√®ces qui ne peuvent pas √™tre conteneuris√©es.  Les composants conteneuris√©s sont ce qui peut √™tre conteneuris√© et d√©j√† conteneuris√©.  Les composants conteneuris√©s sont con√ßus pour s'ex√©cuter dans le cadre d'une application sp√©cifique, et non par eux-m√™mes.  Il est important de comprendre qu'ils ne sont pas destin√©s √† un fonctionnement autonome, car ils ne sont utiles que dans le cadre d'un syst√®me logiciel plus vaste et, isol√©s de celui-ci, ils sont pratiquement inutiles. <br><br>  Par exemple, dans OpenShift Enterprise 3.0, la plupart du code principal a √©t√© d√©ploy√© √† l'aide de RPM, mais apr√®s son installation, les administrateurs ont d√©ploy√© le routeur et le registre en tant que conteneurs.  OpenShift 3.1 a introduit l'option de d√©ploiement conteneuris√© pour master, node, openvswitch et etcd, et une fois install√©, les administrateurs peuvent √©galement d√©ployer elasticsearch, fluentd et kibana en tant que conteneurs. <br><br>  Bien que le programme d'installation d'OpenShift continue d'apporter des modifications au syst√®me de fichiers du serveur, tous les principaux composants logiciels peuvent d√©sormais √™tre install√©s √† l'aide d'images de conteneur.  Par cons√©quent, ces composants conteneuris√©s, par exemple, une instance de l'image etcd incorpor√©e dans OpenShift, ne devraient jamais - et ne seront jamais - utilis√©s pour stocker le code source de l'application avec laquelle vos clients travaillent, simplement parce que ces composants conteneuris√©s sont destin√©s √† √™tre ex√©cut√©s dans le cadre de Plateforme de conteneurs OpenShift. <br><br>  Dans les nouvelles versions d'OpenShift, la tendance √† la conteneurisation des composants ne fait que s'intensifier, et d'autres d√©veloppeurs de logiciels utilisent de plus en plus cette approche. <br><br><h4>  Images d√©ployantes </h4><br>  L'image Deployer est un type sp√©cial de conteneur qui, une fois lanc√©, d√©ploie ou g√®re d'autres conteneurs.  Deployer vous permet d'impl√©menter des sch√©mas de d√©ploiement complexes, par exemple, le lancement de conteneurs dans un certain ordre ou l'ex√©cution de certaines actions au premier d√©marrage, comme la g√©n√©ration d'un sch√©ma de donn√©es ou le remplissage initial de la base de donn√©es. <br><br>  Par exemple, dans OpenShift, le mod√®le ¬´type d'image / conteneur¬ª est utilis√© pour d√©ployer les journaux et les m√©triques.  Le d√©ploiement de ces composants √† l'aide d'images de d√©ploiement permet aux ing√©nieurs d'OpenShift de contr√¥ler l'ordre dans lequel les diff√©rents composants s'ex√©cutent et de v√©rifier qu'ils fonctionnent correctement. <br><br><h4>  Images interm√©diaires </h4><br>  Une image interm√©diaire est une image d'un conteneur qui repose sur une image de base.  Les assemblages du noyau, les middlewares et les ex√©cutions de langage sont g√©n√©ralement impl√©ment√©s en tant que couches suppl√©mentaires au-dessus de l'image de base, puis sp√©cifi√©s dans la directive FROM avec cette image de base.  Les images interm√©diaires ne sont g√©n√©ralement pas utilis√©es seules, mais comme √©l√©ments constitutifs de la cr√©ation d'une image autonome. <br><br>  Les diff√©rentes couches de l'image, en r√®gle g√©n√©rale, sont engag√©es dans diff√©rents groupes de sp√©cialistes.  Par exemple, les administrateurs syst√®me sont responsables de la couche d'assemblage du noyau et les d√©veloppeurs de la couche middleware.  Dans le m√™me temps, les couches sous-jacentes pr√©par√©es par une √©quipe agissent comme une image interm√©diaire pour ceux qui sont responsables des couches d'un niveau sup√©rieur.  Bien que ces images interm√©diaires puissent parfois √™tre utilis√©es de mani√®re autonome, en particulier lors des tests. <br><br><h4>  Images polyvalentes (intermodales) </h4><br>  Les images de conteneurs polyvalents sont des images avec une architecture hybride.  Par exemple, de nombreuses images des collections de logiciels Red Hat peuvent √™tre utilis√©es de deux mani√®res.  Tout d'abord, en tant que conteneurs d'applications standard avec serveur Ruby on Rails et Apache complet.  Deuxi√®mement, ils peuvent √™tre utilis√©s comme images de g√©n√©rateur pour la plate-forme de conteneur OpenShift et bas√©s sur eux des images enfants contenant Ruby on Rails, Apache et le code d'application que vous avez transmis au processus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source to image</a> lors de la construction d'une telle image enfant. <br><br>  Notez que les images polyvalentes gagnent en popularit√© car elles vous permettent de r√©soudre deux t√¢ches fondamentalement diff√©rentes en utilisant la m√™me image. <br><br><h4>  Conteneurs syst√®me </h4><br>  Lors du d√©ploiement de logiciels syst√®me sous forme de conteneurs, ces derniers n√©cessitent souvent des privil√®ges de superutilisateur.  Pour simplifier cette option de d√©ploiement et garantir que ces conteneurs sont lanc√©s avant le lancement de l'ex√©cution du conteneur et du syst√®me d'orchestration, Red Hat a d√©velopp√© un mod√®le sp√©cial appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneurs syst√®me</a> .  Ces conteneurs sont lanc√©s pendant le processus de d√©marrage du syst√®me d'exploitation √† l'aide de systemd et de la commande atomique, ce qui les rend ind√©pendants de tout syst√®me d'ex√©cution ou d'orchestration de conteneurs.  Aujourd'hui, Red Hat propose des conteneurs syst√®me pour rsyslog, cockpit, etcd et flanneld et √©tendra cette liste √† l'avenir. <br><br>  Les conteneurs syst√®me simplifient consid√©rablement l'ajout s√©lectif de ces services √† Red Hat Enterprise Linux et Atomic Host. <br><br><h3>  Conclusion </h3><br>  Les conteneurs semblent √™tre une chose assez simple pour le consommateur final, mais de nombreuses questions se posent lors de la cr√©ation d'un environnement de production de conteneurs.  Pour discuter fructueusement de l'architecture et des m√©thodes de construction de tels environnements, une terminologie uniforme est requise pour tous les participants.  Plus vous vous plongerez dans la conception et la construction de tels environnements, plus les pi√®ges se multiplieront.  Enfin, nous n'en rappelons que quelques-uns. <br><br>  Souvent, les gens ne voient pas la diff√©rence entre les termes "image de conteneur" et "r√©f√©rentiel", en particulier lorsqu'ils sont utilis√©s dans les commandes de docker.  Mais si vous pouvez utiliser les commandes sans comprendre les diff√©rences, alors lorsque vous travaillez sur l'architecture des environnements de conteneurs, vous devez clairement comprendre que le r√©f√©rentiel est vraiment la structure de donn√©es principale. <br><br>  Il est √©galement assez facile de mal comprendre la diff√©rence entre les espaces de noms, les r√©f√©rentiels, les couches d'images et les balises.  Chacune de ces choses a son but dans l'architecture de conteneur.  Et bien que les fournisseurs et les utilisateurs les utilisent √† diverses fins, ce ne sont que des outils. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/fh/dugjfhpr95u8484ca-bttbr-3no.png"></div><br><br>  Le but de cet article est de vous aider √† comprendre la terminologie afin de pouvoir cr√©er des architectures plus avanc√©es.  Par exemple, imaginez que vous venez d'√™tre charg√© de d√©velopper une infrastructure qui devrait d√©limiter la disponibilit√© des espaces de noms, des r√©f√©rentiels et, de plus, des balises et des couches en fonction des r√¥les et des r√®gles m√©tier.  Et le dernier - rappelez-vous que la fa√ßon dont le conteneur est assembl√© d√©termine en grande partie comment il d√©marre (orchestration, privil√®ges, etc.). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416827/">https://habr.com/ru/post/fr416827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416817/index.html">3e place dans la phase de qualification de DataScienceGame 2018</a></li>
<li><a href="../fr416819/index.html">Adieu, microservices: de cent enfants √† probl√®mes √† une superstar</a></li>
<li><a href="../fr416821/index.html">Fonctionnement de JS: communications WebRTC et P2P</a></li>
<li><a href="../fr416823/index.html">Sang, sueur et pixels: quel est le livre de Jason Schreier</a></li>
<li><a href="../fr416825/index.html">Comment ne PAS √™tre un d√©veloppeur m√©diocre</a></li>
<li><a href="../fr416829/index.html">ABI Model Pattern v0.5.6 Beta</a></li>
<li><a href="../fr416831/index.html">L'acheminement externe du trafic int√©rieur russe sera r√©duit √† 5%</a></li>
<li><a href="../fr416833/index.html">Bienvenue dans le Meetup MskDotNet # 24</a></li>
<li><a href="../fr416837/index.html"># Dashanalune 0</a></li>
<li><a href="../fr416839/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 3: Buffer Overflows: Exploits and Protection, Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>