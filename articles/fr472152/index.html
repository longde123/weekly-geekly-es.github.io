<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍈 🚾 🎶 Test de code multithread et asynchrone 👩🏽‍🤝‍👩🏻 🆙 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Cette semaine, la tâche consistait à écrire un test d'intégration pour une application Spring Boot utilisant une interaction asynchrone avec des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test de code multithread et asynchrone</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472152/"> Salut  Cette semaine, la tâche consistait à écrire un test d'intégration pour une application Spring Boot utilisant une interaction asynchrone avec des systèmes externes.  Actualisé beaucoup de matériel sur le débogage de code multithread.  L'article «Tester le code multithread et asynchrone» de Jonathan Halterman, dont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma traduction</a> est donnée ci-dessous, a attiré l'attention. <br><a name="habracut"></a><br>  Merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shalomman</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schroeder</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTOH</a> pour les commentaires de code les plus importants de l'article original. <br><br>  Si vous écrivez le code assez longtemps ou peut-être pas, alors vous êtes probablement tombé sur un script dans lequel vous devez tester du code multithread.  Il est généralement admis que les threads et les tests ne doivent pas être mélangés.  Cela se produit généralement parce que  ce qui doit être testé ne fait que commencer dans un système multithread et peut être testé individuellement sans utiliser de threads.  Mais que faire si vous ne pouvez pas les séparer, ou plus, si le multithreading est cet aspect du code que vous testez? <br><br>  Je suis ici pour vous dire que bien que les threads dans les tests ne soient pas très courants, ils sont assez utilisés.  La police logicielle ne vous arrêtera pas pour avoir démarré un thread dans un test unitaire, bien que la façon de tester réellement le code multi-thread soit une autre affaire.  Certaines excellentes technologies asynchrones, telles que Akka et Vert.x, fournissent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des kits de test</a> pour alléger ce fardeau.  Mais au-delà de cela, le test de code multithread nécessite généralement une approche différente de celle d'un test unitaire synchrone typique. <br><br><h2>  Nous allons parallèlement </h2><br>  La première étape consiste à lancer toute action multithread dont vous souhaitez vérifier le résultat.  Par exemple, utilisons une API hypothétique pour enregistrer un gestionnaire de messages sur un bus de messages et publier un message sur le bus, qui sera remis à notre gestionnaire de manière asynchrone dans un thread séparé: <br><br><pre><code class="java hljs">messageBus.registerHandler(message - &gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); }); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"test"</span></span>);</code> </pre> <br>  Ça a l'air bien.  Lorsque le test démarre, le bus doit livrer notre message au gestionnaire dans un autre thread, mais ce n'est pas très utile, car nous ne vérifions rien.  Mettons à jour notre test pour confirmer que le bus de messages livre notre message comme prévu: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg);</code> </pre> <br>  Ça a l'air mieux.  Nous exécutons notre test et il est vert.  Cool!  Mais le message reçu n'a été imprimé nulle part, quelque chose n'allait pas quelque part. <br><br><h2>  Attends une seconde </h2><br>  Dans le test ci-dessus, lorsqu'un message est publié sur le bus de messages, il est remis par le bus au gestionnaire dans un autre thread.  Mais lorsqu'un outil de test unitaire tel que JUnit exécute un test, il ne sait rien des flux de bus de messages.  JUnit ne connaît que le thread principal dans lequel il exécute le test.  Ainsi, alors que le bus de messages est occupé à essayer de délivrer le message, le test termine l'exécution dans le thread de test principal et JUnit signale la réussite.  Comment résoudre ça?  Nous avons besoin du thread de test principal pour attendre que le bus de messages transmette notre message.  Ajoutons donc une déclaration de sommeil: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Notre test est vert et l'expression Reçu est imprimée comme prévu.  Cool!  Mais une seconde de sommeil signifie que notre test est effectué pendant au moins une seconde, et il n'y a rien de bon en elle.  Nous pourrions réduire le temps de sommeil, mais nous courons le risque de terminer le test avant de recevoir un message.  Nous avons besoin d'un moyen de coordination entre le thread de test principal et le thread du gestionnaire de messages.  En regardant le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">java.util.concurrent</a> , nous sommes sûrs de trouver ce que nous pouvons utiliser.  Qu'en est-il de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CountDownLatch</a> ? <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); latch.countDown(); }; messageBus.publish(msg); latch.await();</code> </pre> <br>  Dans cette approche, nous partageons le CountDownLatch entre le thread de test principal et le thread du gestionnaire de messages.  Le thread principal est obligé d'attendre le bloqueur.  Le thread de test libère le thread principal en attente en appelant countDown () sur le bloqueur après avoir reçu le message.  Nous n'avons plus besoin de dormir une seconde.  Notre test prend exactement autant de temps que nécessaire. <br><br><h2>  Si heureux? </h2><br>  Avec notre nouveau charme, CountDownLatch, nous commençons à écrire des tests multi-thread, comme les dernières fashionistas.  Mais assez rapidement, nous remarquons que l'un de nos cas de test est bloqué pour toujours et ne se termine pas.  Que se passe-t-il?  Considérez le scénario du bus de messages: le bloqueur vous fait attendre, mais il n'est libéré qu'après avoir reçu le message.  Si le bus ne fonctionne pas et que le message n'est jamais transmis, le test ne se terminera jamais.  Ajoutons donc un délai d'attente au bloqueur: <br><br><pre> <code class="java hljs">latch.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Un test bloqué échoue après 1 seconde avec une exception TimeoutException.  À la fin, nous trouverons le problème et corrigerons le test, mais nous déciderons de laisser les délais d'attente en place.  Si cela se reproduit, nous préférerions que notre test se verrouille une seconde et se bloque, que de bloquer pour toujours et de ne pas être terminé du tout. <br>  Un autre problème que nous remarquons lors de l'écriture des tests est qu'ils semblent tous réussir même s'ils ne devraient probablement pas.  Comment est-ce possible?  Considérez à nouveau le test de traitement des messages: <br><br><pre> <code class="java hljs">messageBus.registerHandler(message -&gt; { assertEquals(message, msg); latch.countDown(); };</code> </pre> <br>  Nous aurions dû utiliser CountDownLatch pour coordonner la fin de notre test avec le thread de test principal, mais qu'en est-il des assertions?  Si la validation échoue, JUnit le saura-t-il?  Il s'avère que puisque nous n'effectuons pas de validation dans le thread de test principal, toutes les vérifications défectueuses restent complètement inaperçues par JUnit.  Essayons un petit script pour tester ceci: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); latch.countDown(); }).start(); latch.await();</code> </pre> <br>  Le test est vert!  Alors qu'est-ce qu'on fait maintenant?  Nous avons besoin d'un moyen de renvoyer toutes les erreurs de test du flux du gestionnaire de messages vers le flux de test principal.  Si une défaillance se produit dans le thread du gestionnaire de messages, nous en avons besoin pour réapparaître dans le thread principal afin que le test bascule, comme prévu.  Essayons de faire ceci: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); AtomicReference&lt;AssertionError&gt; failure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicReference&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AssertionError e) { failure.set(e); } latch.countDown(); }).start(); latch.await(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failure.get() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> failure.get();</code> </pre> <br>  Démarrage rapide et oui, le test échoue, comme il se doit!  Maintenant, nous pouvons revenir en arrière et ajouter des blocs CountDownLatches, try / catch et AtomicReference à tous nos cas de test.  Cool!  En fait, pas cool, ça ressemble à un passe-partout. <br><br><h2>  Découpez la poubelle </h2><br>  Idéalement, nous avons besoin d'une API qui nous permet de coordonner l'attente, la vérification et la reprise de l'exécution entre les threads, afin que les tests unitaires puissent réussir ou échouer comme prévu, peu importe où la validation échoue.  Heureusement, ConcurrentUnit fournit un cadre léger qui fait exactement cela: Waiter.  Adaptons le test de traitement des messages ci-dessus pour la dernière fois et voyons ce que Waiter de ConcurrentUnit peut faire pour nous: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.assertEquals(message, msg); waiter.resume(); }; messageBus.publish(msg); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Dans ce test, nous voyons que Waiter a pris la place de CountDownLatch et AtomicReference.  Avec Waiter, nous bloquons le thread de test principal, effectuons le test, puis reprenons le thread de test principal afin que le test puisse se terminer.  Si la vérification échoue, l'appel de waiter.await libérera automatiquement le verrou et lancera un échec, ce qui entraînera la réussite ou l'échec du test, comme il se doit, même si la vérification a été effectuée à partir d'un autre thread. <br><br><h2>  Encore plus parallèle </h2><br>  Maintenant que nous sommes devenus des testeurs multi-threads certifiés, nous pourrions vouloir confirmer que plusieurs actions asynchrones se produisent.  Le serveur de ConcurrentUnit rend cela simple: <br><br><pre> <code class="java hljs">Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.resume(); }; messageBus.publish(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Ici, nous publions deux messages sur le bus et vérifions que les deux messages sont livrés, ce qui fait que Waiter attend que resume () soit appelé 2 fois.  Si les messages ne sont pas remis et que la reprise n'est pas appelée deux fois en 1 seconde, le test échoue avec une erreur TimeoutException. <br>  Une astuce générale avec cette approche est de vous assurer que vos délais d'attente sont suffisamment longs pour effectuer toutes les actions simultanées.  Dans des conditions normales, lorsque le système testé fonctionne comme prévu, la temporisation n'a pas d'importance et ne prend effet qu'en cas de défaillance du système pour une raison quelconque. <br><br><h2>  Résumé </h2><br>  Dans cet article, nous avons appris que le test unitaire multithread n'est pas mauvais et qu'il est assez facile à faire.  Nous avons appris l'approche générale lorsque nous bloquons le thread de test principal, effectuons des vérifications à partir d'autres threads, puis reprenons le thread principal.  Et nous avons découvert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ConcurrentUnit</a> , qui peut faciliter cette tâche. <br>  Bon test! <br><br>  <b>Traduit par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472152/">https://habr.com/ru/post/fr472152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472128/index.html">Pourquoi j'aime PHP?</a></li>
<li><a href="../fr472130/index.html">Comment éviter le déchaînement des entreprises?</a></li>
<li><a href="../fr472138/index.html">Numérisation de l'éducation</a></li>
<li><a href="../fr472144/index.html">Sifflez tout le monde sur Linux, le tonnerre et la foudre</a></li>
<li><a href="../fr472148/index.html">Retrogaming: PAL vs NTSC. Ou pourquoi PAL n'est pas nécessaire</a></li>
<li><a href="../fr472154/index.html">Comment ne pas rater le budget de la production en série des bâtiments-2: prix du moulage plastique à petite échelle</a></li>
<li><a href="../fr472156/index.html">Implémentation du modèle d'objet de page en Python + pytest</a></li>
<li><a href="../fr472158/index.html">"Le processus éducatif en informatique et pas seulement": concours et événements technologiques de l'Université ITMO</a></li>
<li><a href="../fr472160/index.html">Phantom OS: sous-système de fenêtre - faire des contrôles</a></li>
<li><a href="../fr472162/index.html">Marketing par e-mail externalisé: comment construire et à quoi s'attendre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>