<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçà üöæ üé∂ Test de code multithread et asynchrone üë©üèΩ‚Äçü§ù‚Äçüë©üèª üÜô üóûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Cette semaine, la t√¢che consistait √† √©crire un test d'int√©gration pour une application Spring Boot utilisant une interaction asynchrone avec des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test de code multithread et asynchrone</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472152/"> Salut  Cette semaine, la t√¢che consistait √† √©crire un test d'int√©gration pour une application Spring Boot utilisant une interaction asynchrone avec des syst√®mes externes.  Actualis√© beaucoup de mat√©riel sur le d√©bogage de code multithread.  L'article ¬´Tester le code multithread et asynchrone¬ª de Jonathan Halterman, dont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma traduction</a> est donn√©e ci-dessous, a attir√© l'attention. <br><a name="habracut"></a><br>  Merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shalomman</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schroeder</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTOH</a> pour les commentaires de code les plus importants de l'article original. <br><br>  Si vous √©crivez le code assez longtemps ou peut-√™tre pas, alors vous √™tes probablement tomb√© sur un script dans lequel vous devez tester du code multithread.  Il est g√©n√©ralement admis que les threads et les tests ne doivent pas √™tre m√©lang√©s.  Cela se produit g√©n√©ralement parce que  ce qui doit √™tre test√© ne fait que commencer dans un syst√®me multithread et peut √™tre test√© individuellement sans utiliser de threads.  Mais que faire si vous ne pouvez pas les s√©parer, ou plus, si le multithreading est cet aspect du code que vous testez? <br><br>  Je suis ici pour vous dire que bien que les threads dans les tests ne soient pas tr√®s courants, ils sont assez utilis√©s.  La police logicielle ne vous arr√™tera pas pour avoir d√©marr√© un thread dans un test unitaire, bien que la fa√ßon de tester r√©ellement le code multi-thread soit une autre affaire.  Certaines excellentes technologies asynchrones, telles que Akka et Vert.x, fournissent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des kits de test</a> pour all√©ger ce fardeau.  Mais au-del√† de cela, le test de code multithread n√©cessite g√©n√©ralement une approche diff√©rente de celle d'un test unitaire synchrone typique. <br><br><h2>  Nous allons parall√®lement </h2><br>  La premi√®re √©tape consiste √† lancer toute action multithread dont vous souhaitez v√©rifier le r√©sultat.  Par exemple, utilisons une API hypoth√©tique pour enregistrer un gestionnaire de messages sur un bus de messages et publier un message sur le bus, qui sera remis √† notre gestionnaire de mani√®re asynchrone dans un thread s√©par√©: <br><br><pre><code class="java hljs">messageBus.registerHandler(message - &gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); }); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"test"</span></span>);</code> </pre> <br>  √áa a l'air bien.  Lorsque le test d√©marre, le bus doit livrer notre message au gestionnaire dans un autre thread, mais ce n'est pas tr√®s utile, car nous ne v√©rifions rien.  Mettons √† jour notre test pour confirmer que le bus de messages livre notre message comme pr√©vu: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg);</code> </pre> <br>  √áa a l'air mieux.  Nous ex√©cutons notre test et il est vert.  Cool!  Mais le message re√ßu n'a √©t√© imprim√© nulle part, quelque chose n'allait pas quelque part. <br><br><h2>  Attends une seconde </h2><br>  Dans le test ci-dessus, lorsqu'un message est publi√© sur le bus de messages, il est remis par le bus au gestionnaire dans un autre thread.  Mais lorsqu'un outil de test unitaire tel que JUnit ex√©cute un test, il ne sait rien des flux de bus de messages.  JUnit ne conna√Æt que le thread principal dans lequel il ex√©cute le test.  Ainsi, alors que le bus de messages est occup√© √† essayer de d√©livrer le message, le test termine l'ex√©cution dans le thread de test principal et JUnit signale la r√©ussite.  Comment r√©soudre √ßa?  Nous avons besoin du thread de test principal pour attendre que le bus de messages transmette notre message.  Ajoutons donc une d√©claration de sommeil: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Notre test est vert et l'expression Re√ßu est imprim√©e comme pr√©vu.  Cool!  Mais une seconde de sommeil signifie que notre test est effectu√© pendant au moins une seconde, et il n'y a rien de bon en elle.  Nous pourrions r√©duire le temps de sommeil, mais nous courons le risque de terminer le test avant de recevoir un message.  Nous avons besoin d'un moyen de coordination entre le thread de test principal et le thread du gestionnaire de messages.  En regardant le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">java.util.concurrent</a> , nous sommes s√ªrs de trouver ce que nous pouvons utiliser.  Qu'en est-il de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CountDownLatch</a> ? <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); latch.countDown(); }; messageBus.publish(msg); latch.await();</code> </pre> <br>  Dans cette approche, nous partageons le CountDownLatch entre le thread de test principal et le thread du gestionnaire de messages.  Le thread principal est oblig√© d'attendre le bloqueur.  Le thread de test lib√®re le thread principal en attente en appelant countDown () sur le bloqueur apr√®s avoir re√ßu le message.  Nous n'avons plus besoin de dormir une seconde.  Notre test prend exactement autant de temps que n√©cessaire. <br><br><h2>  Si heureux? </h2><br>  Avec notre nouveau charme, CountDownLatch, nous commen√ßons √† √©crire des tests multi-thread, comme les derni√®res fashionistas.  Mais assez rapidement, nous remarquons que l'un de nos cas de test est bloqu√© pour toujours et ne se termine pas.  Que se passe-t-il?  Consid√©rez le sc√©nario du bus de messages: le bloqueur vous fait attendre, mais il n'est lib√©r√© qu'apr√®s avoir re√ßu le message.  Si le bus ne fonctionne pas et que le message n'est jamais transmis, le test ne se terminera jamais.  Ajoutons donc un d√©lai d'attente au bloqueur: <br><br><pre> <code class="java hljs">latch.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Un test bloqu√© √©choue apr√®s 1 seconde avec une exception TimeoutException.  √Ä la fin, nous trouverons le probl√®me et corrigerons le test, mais nous d√©ciderons de laisser les d√©lais d'attente en place.  Si cela se reproduit, nous pr√©f√©rerions que notre test se verrouille une seconde et se bloque, que de bloquer pour toujours et de ne pas √™tre termin√© du tout. <br>  Un autre probl√®me que nous remarquons lors de l'√©criture des tests est qu'ils semblent tous r√©ussir m√™me s'ils ne devraient probablement pas.  Comment est-ce possible?  Consid√©rez √† nouveau le test de traitement des messages: <br><br><pre> <code class="java hljs">messageBus.registerHandler(message -&gt; { assertEquals(message, msg); latch.countDown(); };</code> </pre> <br>  Nous aurions d√ª utiliser CountDownLatch pour coordonner la fin de notre test avec le thread de test principal, mais qu'en est-il des assertions?  Si la validation √©choue, JUnit le saura-t-il?  Il s'av√®re que puisque nous n'effectuons pas de validation dans le thread de test principal, toutes les v√©rifications d√©fectueuses restent compl√®tement inaper√ßues par JUnit.  Essayons un petit script pour tester ceci: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); latch.countDown(); }).start(); latch.await();</code> </pre> <br>  Le test est vert!  Alors qu'est-ce qu'on fait maintenant?  Nous avons besoin d'un moyen de renvoyer toutes les erreurs de test du flux du gestionnaire de messages vers le flux de test principal.  Si une d√©faillance se produit dans le thread du gestionnaire de messages, nous en avons besoin pour r√©appara√Ætre dans le thread principal afin que le test bascule, comme pr√©vu.  Essayons de faire ceci: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); AtomicReference&lt;AssertionError&gt; failure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicReference&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AssertionError e) { failure.set(e); } latch.countDown(); }).start(); latch.await(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failure.get() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> failure.get();</code> </pre> <br>  D√©marrage rapide et oui, le test √©choue, comme il se doit!  Maintenant, nous pouvons revenir en arri√®re et ajouter des blocs CountDownLatches, try / catch et AtomicReference √† tous nos cas de test.  Cool!  En fait, pas cool, √ßa ressemble √† un passe-partout. <br><br><h2>  D√©coupez la poubelle </h2><br>  Id√©alement, nous avons besoin d'une API qui nous permet de coordonner l'attente, la v√©rification et la reprise de l'ex√©cution entre les threads, afin que les tests unitaires puissent r√©ussir ou √©chouer comme pr√©vu, peu importe o√π la validation √©choue.  Heureusement, ConcurrentUnit fournit un cadre l√©ger qui fait exactement cela: Waiter.  Adaptons le test de traitement des messages ci-dessus pour la derni√®re fois et voyons ce que Waiter de ConcurrentUnit peut faire pour nous: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.assertEquals(message, msg); waiter.resume(); }; messageBus.publish(msg); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Dans ce test, nous voyons que Waiter a pris la place de CountDownLatch et AtomicReference.  Avec Waiter, nous bloquons le thread de test principal, effectuons le test, puis reprenons le thread de test principal afin que le test puisse se terminer.  Si la v√©rification √©choue, l'appel de waiter.await lib√©rera automatiquement le verrou et lancera un √©chec, ce qui entra√Ænera la r√©ussite ou l'√©chec du test, comme il se doit, m√™me si la v√©rification a √©t√© effectu√©e √† partir d'un autre thread. <br><br><h2>  Encore plus parall√®le </h2><br>  Maintenant que nous sommes devenus des testeurs multi-threads certifi√©s, nous pourrions vouloir confirmer que plusieurs actions asynchrones se produisent.  Le serveur de ConcurrentUnit rend cela simple: <br><br><pre> <code class="java hljs">Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.resume(); }; messageBus.publish(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Ici, nous publions deux messages sur le bus et v√©rifions que les deux messages sont livr√©s, ce qui fait que Waiter attend que resume () soit appel√© 2 fois.  Si les messages ne sont pas remis et que la reprise n'est pas appel√©e deux fois en 1 seconde, le test √©choue avec une erreur TimeoutException. <br>  Une astuce g√©n√©rale avec cette approche est de vous assurer que vos d√©lais d'attente sont suffisamment longs pour effectuer toutes les actions simultan√©es.  Dans des conditions normales, lorsque le syst√®me test√© fonctionne comme pr√©vu, la temporisation n'a pas d'importance et ne prend effet qu'en cas de d√©faillance du syst√®me pour une raison quelconque. <br><br><h2>  R√©sum√© </h2><br>  Dans cet article, nous avons appris que le test unitaire multithread n'est pas mauvais et qu'il est assez facile √† faire.  Nous avons appris l'approche g√©n√©rale lorsque nous bloquons le thread de test principal, effectuons des v√©rifications √† partir d'autres threads, puis reprenons le thread principal.  Et nous avons d√©couvert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ConcurrentUnit</a> , qui peut faciliter cette t√¢che. <br>  Bon test! <br><br>  <b>Traduit par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472152/">https://habr.com/ru/post/fr472152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472128/index.html">Pourquoi j'aime PHP?</a></li>
<li><a href="../fr472130/index.html">Comment √©viter le d√©cha√Ænement des entreprises?</a></li>
<li><a href="../fr472138/index.html">Num√©risation de l'√©ducation</a></li>
<li><a href="../fr472144/index.html">Sifflez tout le monde sur Linux, le tonnerre et la foudre</a></li>
<li><a href="../fr472148/index.html">Retrogaming: PAL vs NTSC. Ou pourquoi PAL n'est pas n√©cessaire</a></li>
<li><a href="../fr472154/index.html">Comment ne pas rater le budget de la production en s√©rie des b√¢timents-2: prix du moulage plastique √† petite √©chelle</a></li>
<li><a href="../fr472156/index.html">Impl√©mentation du mod√®le d'objet de page en Python + pytest</a></li>
<li><a href="../fr472158/index.html">"Le processus √©ducatif en informatique et pas seulement": concours et √©v√©nements technologiques de l'Universit√© ITMO</a></li>
<li><a href="../fr472160/index.html">Phantom OS: sous-syst√®me de fen√™tre - faire des contr√¥les</a></li>
<li><a href="../fr472162/index.html">Marketing par e-mail externalis√©: comment construire et √† quoi s'attendre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>