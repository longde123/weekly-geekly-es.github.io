<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏽 📆 ⌚️ Memory and Span pt. 2 🖐🏿 🤚 👨‍👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rentang contoh penggunaan <T> 


 Manusia pada dasarnya tidak dapat sepenuhnya memahami tujuan instrumen tertentu sampai ia mendapatkan pengalaman. Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memory and Span pt. 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443976/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h3 id="spanlttgt-usage-examples">  Rentang contoh penggunaan &lt;T&gt; </h3><br><p>  Manusia pada dasarnya tidak dapat sepenuhnya memahami tujuan instrumen tertentu sampai ia mendapatkan pengalaman.  Jadi, mari kita beralih ke beberapa contoh. </p><br><h4 id="valuestringbuilder">  ValueStringBuilder </h4><br><p> Salah satu contoh paling menarik sehubungan dengan algoritma adalah tipe <code>ValueStringBuilder</code> .  Namun, itu terkubur jauh di dalam mscorlib dan ditandai dengan pengubah <code>internal</code> karena banyak tipe data lain yang sangat menarik.  Ini berarti kami tidak akan menemukan instrumen yang luar biasa ini untuk optimasi jika kami belum meneliti kode sumber mscorlib. </p><br><p>  Apa kerugian utama dari tipe sistem <code>StringBuilder</code> ?  Kelemahan utamanya adalah tipe dan dasarnya - ini adalah tipe referensi dan didasarkan pada <code>char[]</code> , yaitu array karakter.  Paling tidak, ini berarti dua hal: kita menggunakan heap (walaupun tidak banyak) dan meningkatkan peluang untuk melewatkan uang CPU. </p><br><p>  Masalah lain dengan <code>StringBuilder</code> yang saya hadapi adalah konstruksi string kecil, yaitu ketika string yang dihasilkan harus pendek misalnya kurang dari 100 karakter.  Pemformatan singkat menimbulkan masalah kinerja. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><pre> <code class="plaintext hljs"> $"{x} is in range [{min};{max}]"</code> </pre> <br><p>  Sejauh mana varian ini lebih buruk daripada konstruksi manual melalui <code>StringBuilder</code> ?  Jawabannya tidak selalu jelas.  Itu tergantung pada tempat konstruksi dan frekuensi memanggil metode ini.  Awalnya, <code>string.Format</code> mengalokasikan memori untuk <code>StringBuilder</code> internal yang akan membuat array karakter (SourceString.Length + args.Length * 8).  Jika selama konstruksi array ternyata panjangnya tidak ditentukan dengan benar, <code>StringBuilder</code> lain akan dibuat untuk membangun sisanya.  Ini akan mengarah pada pembuatan daftar tertaut tunggal.  Akibatnya, ia harus mengembalikan string yang dikonstruksi yang berarti penyalinan lain.  Itu sia-sia.  Akan lebih bagus jika kita bisa menghilangkan mengalokasikan array dari string yang terbentuk di heap: ini akan menyelesaikan salah satu masalah kita. </p><br><p>  Mari kita lihat jenis ini dari kedalaman <code>mscorlib</code> : </p><br><p>  <strong>Kelas ValueStringBuilder</strong> <br>  <a href="">/ src / mscorlib / shared / System / Text / ValueStringBuilder</a> </p><br><pre> <code class="plaintext hljs"> internal ref struct ValueStringBuilder { // this field will be active if we have too many characters private char[] _arrayToReturnToPool; // this field will be the main private Span&lt;char&gt; _chars; private int _pos; // the type accepts the buffer from the outside, delegating the choice of its size to a calling party public ValueStringBuilder(Span&lt;char&gt; initialBuffer) { _arrayToReturnToPool = null; _chars = initialBuffer; _pos = 0; } public int Length { get =&gt; _pos; set { int delta = value - _pos; if (delta &gt; 0) { Append('\0', delta); } else { _pos = value; } } } // Here we get the string by copying characters from the array into another array public override string ToString() { var s = new string(_chars.Slice(0, _pos)); Clear(); return s; } // To insert a required character into the middle of the string //you should add space into the characters of that string and then copy that character public void Insert(int index, char value, int count) { if (_pos &gt; _chars.Length - count) { Grow(count); } int remaining = _pos - index; _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count)); _chars.Slice(index, count).Fill(value); _pos += count; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Append(char c) { int pos = _pos; if (pos &lt; _chars.Length) { _chars[pos] = c; _pos = pos + 1; } else { GrowAndAppend(c); } } [MethodImpl(MethodImplOptions.NoInlining)] private void GrowAndAppend(char c) { Grow(1); Append(c); } // If the original array passed by the constructor wasn't enough // we allocate an array of a necessary size from the pool of free arrays // It would be ideal if the algorithm considered // discreteness of array size to avoid pool fragmentation. [MethodImpl(MethodImplOptions.NoInlining)] private void Grow(int requiredAdditionalCapacity) { Debug.Assert(requiredAdditionalCapacity &gt; _chars.Length - _pos); char[] poolArray = ArrayPool&lt;char&gt;.Shared.Rent(Math.Max(_pos + requiredAdditionalCapacity, _chars.Length * 2)); _chars.CopyTo(poolArray); char[] toReturn = _arrayToReturnToPool; _chars = _arrayToReturnToPool = poolArray; if (toReturn != null) { ArrayPool&lt;char&gt;.Shared.Return(toReturn); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Clear() { char[] toReturn = _arrayToReturnToPool; this = default; // for safety, to avoid using pooled array if this instance is erroneously appended to again if (toReturn != null) { ArrayPool&lt;char&gt;.Shared.Return(toReturn); } } // Missing methods: the situation is crystal clear private void AppendSlow(string s); public bool TryCopyTo(Span&lt;char&gt; destination, out int charsWritten); public void Append(string s); public void Append(char c, int count); public unsafe void Append(char* value, int length); public Span&lt;char&gt; AppendSpan(int length); }</code> </pre> <br><p>  Kelas ini secara fungsional mirip dengan rekan seniornya <code>StringBuilder</code> , walaupun memiliki satu fitur yang menarik dan sangat penting: ini adalah tipe nilai.  Itu berarti disimpan dan dilewati sepenuhnya oleh nilai.  Juga, pengubah tipe <code>ref</code> baru, yang merupakan bagian dari tanda tangan deklarasi tipe, menunjukkan bahwa tipe ini memiliki kendala tambahan: ia hanya dapat dialokasikan pada stack.  Maksud saya menyampaikan instance-nya ke bidang kelas akan menghasilkan kesalahan.  Untuk apa semua ini?  Untuk menjawab pertanyaan ini, Anda hanya perlu melihat kelas <code>StringBuilder</code> , esensi yang baru saja kami jelaskan: </p><br><p>  <strong>Kelas StringBuilder</strong> <a href="">/src/mscorlib/src/System/Text/StringBuilder.cs</a> </p><br><pre> <code class="plaintext hljs">public sealed class StringBuilder : ISerializable { // A StringBuilder is internally represented as a linked list of blocks each of which holds // a chunk of the string. It turns out string as a whole can also be represented as just a chunk, // so that is what we do. internal char[] m_ChunkChars; // The characters in this block internal StringBuilder m_ChunkPrevious; // Link to the block logically before this block internal int m_ChunkLength; // The index in m_ChunkChars that represent the end of the block internal int m_ChunkOffset; // The logical offset (sum of all characters in previous blocks) internal int m_MaxCapacity = 0; // ... internal const int DefaultCapacity = 16;</code> </pre> <br><p>  <code>StringBuilder</code> adalah kelas yang berisi referensi ke array karakter.  Jadi, ketika Anda membuatnya, tampak ada dua objek sebenarnya: <code>StringBuilder</code> dan array karakter yang setidaknya berukuran 16 karakter.  Inilah sebabnya mengapa sangat penting untuk mengatur panjang string yang diharapkan: itu akan dibangun dengan membuat daftar array yang terhubung dengan masing-masing 16 karakter.  Akui, itu sia-sia.  Dalam hal tipe <code>ValueStringBuilder</code> , itu berarti tidak ada <code>capacity</code> default, karena meminjam memori eksternal.  Juga, ini adalah tipe nilai, dan itu membuat pengguna mengalokasikan buffer untuk karakter pada stack.  Dengan demikian, seluruh instance dari suatu jenis diletakkan di tumpukan bersama dengan isinya dan masalah optimasi diselesaikan.  Karena tidak perlu mengalokasikan memori pada heap, tidak ada masalah dengan penurunan kinerja ketika berhadapan dengan heap.  Jadi, Anda mungkin memiliki pertanyaan: mengapa kita tidak selalu menggunakan <code>ValueStringBuilder</code> (atau analog khusus karena kami tidak dapat menggunakan yang asli karena ini internal)?  Jawabannya adalah: itu tergantung pada tugas.  Apakah string yang dihasilkan memiliki ukuran yang pasti?  Apakah akan diketahui panjang maksimalnya?  Jika Anda menjawab "ya" dan jika string tidak melebihi batas yang masuk akal, Anda dapat menggunakan versi nilai dari <code>StringBuilder</code> .  Namun, jika Anda mengharapkan string yang panjang, gunakan versi yang biasa. </p><br><h4 id="valuelistbuilder">  ValueListBuilder </h4><br><pre> <code class="plaintext hljs">internal ref partial struct ValueListBuilder&lt;T&gt; { private Span&lt;T&gt; _span; private T[] _arrayFromPool; private int _pos; public ValueListBuilder(Span&lt;T&gt; initialSpan) { _span = initialSpan; _arrayFromPool = null; _pos = 0; } public int Length { get; set; } public ref T this[int index] { get; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Append(T item); public ReadOnlySpan&lt;T&gt; AsSpan(); [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Dispose(); private void Grow(); }</code> </pre> <br><p>  Tipe data kedua yang ingin saya perhatikan adalah tipe <code>ValueListBuilder</code> .  Ini digunakan ketika Anda perlu membuat kumpulan elemen untuk waktu yang singkat dan meneruskannya ke algoritma untuk diproses. </p><br><p>  Akui, tugas ini terlihat sangat mirip dengan tugas <code>ValueStringBuilder</code> .  Dan itu diselesaikan dengan cara yang serupa: </p><br><p>  <strong>File ValueListBuilder.cs</strong> <a href="">coreclr / src /../ Generic / ValueListBuilder.cs</a> </p><br><p>  Untuk lebih jelasnya, situasi ini sering terjadi.  Namun, sebelumnya kami memecahkan masalah dengan cara lain.  Kami dulu membuat <code>List</code> , mengisinya dengan data dan kehilangan referensi untuk itu.  Jika metode ini sering dipanggil, ini akan menyebabkan situasi yang menyedihkan: banyak instance <code>List</code> (dan array terkait) ditangguhkan di heap.  Sekarang masalah ini terpecahkan: tidak ada objek tambahan yang akan dibuat.  Namun, seperti dalam kasus <code>ValueStringBuilder</code> diselesaikan hanya untuk programmer Microsoft: kelas ini memiliki pengubah <code>internal</code> . </p><br><h3 id="rules-and-use-practice">  Aturan dan praktik penggunaan </h3><br><p>  Untuk sepenuhnya memahami tipe data baru yang Anda butuhkan untuk bermain dengannya dengan menulis dua atau tiga metode yang lebih baik yang menggunakannya.  Namun, dimungkinkan untuk mempelajari peraturan utama saat ini: </p><br><ul><li>  Jika metode Anda memproses beberapa dataset input tanpa mengubah ukurannya, Anda dapat mencoba menggunakan tipe <code>Span</code> .  Jika Anda tidak akan memodifikasi buffer, pilih tipe <code>ReadOnlySpan</code> ; </li><li>  Jika metode Anda menangani string yang menghitung beberapa statistik atau mem-parsing string ini, ia <em>harus</em> menerima <code>ReadOnlySpan&lt;char&gt;</code> .  Harus adalah aturan baru.  Karena ketika Anda menerima string, Anda membuat seseorang membuat substring untuk Anda; </li><li>  Jika Anda perlu membuat array data pendek (tidak lebih dari 10 kB) untuk suatu metode, Anda dapat dengan mudah mengaturnya menggunakan <code>Span&lt;TType&gt; buf = stackalloc TType[size]</code> .  Perhatikan bahwa TType harus menjadi tipe nilai karena <code>stackalloc</code> berfungsi dengan tipe nilai. </li></ul><br><p>  Dalam kasus lain, Anda sebaiknya melihat lebih dekat pada <code>Memory</code> atau menggunakan tipe data klasik. </p><br><h3 id="how-does-span-work">  Bagaimana cara kerja span? </h3><br><p>  Saya ingin mengatakan beberapa kata tambahan tentang bagaimana <code>Span</code> berfungsi dan mengapa itu penting.  Dan ada sesuatu untuk dibicarakan.  Jenis data ini memiliki dua versi: satu untuk .NET Core 2.0+ dan yang lainnya untuk sisanya. </p><br><p>  <strong>File Span.Fast.cs, .NET Core 2.0</strong> <a href="">coreclr /.../ System / Span.Fast.cs</a> ** </p><br><pre> <code class="plaintext hljs">public readonly ref partial struct Span&lt;T&gt; { /// A reference to a .NET object or a pure pointer internal readonly ByReference&lt;T&gt; _pointer; /// The length of the buffer based on the pointer private readonly int _length; // ... }</code> </pre> <br><p>  <strong>File ???</strong>  <strong>[didekompilasi]</strong> </p><br><pre> <code class="plaintext hljs">public ref readonly struct Span&lt;T&gt; { private readonly System.Pinnable&lt;T&gt; _pinnable; private readonly IntPtr _byteOffset; private readonly int _length; // ... }</code> </pre> <br><p>  Masalahnya adalah .NET Framework dan .NET Core 1. * yang besar itu tidak memiliki pengumpul sampah yang diperbarui dengan cara khusus (tidak seperti .NET Core 2.0+) dan mereka harus menggunakan pointer tambahan ke awal buffer di gunakan.  Itu berarti, bahwa secara internal <code>Span</code> menangani objek .NET yang dikelola seolah-olah tidak dikelola.  Lihat saja varian kedua dari struktur: ia memiliki tiga bidang.  Yang pertama adalah referensi ke objek manged.  Yang kedua adalah offset dalam byte dari awal objek ini, yang digunakan untuk mendefinisikan awal buffer data (dalam string buffer ini berisi karakter <code>char</code> sedangkan di array berisi data dari array).  Terakhir, bidang ketiga berisi jumlah elemen dalam buffer yang diletakkan dalam satu baris. </p><br><p>  Mari kita lihat bagaimana <code>Span</code> menangani string, misalnya: </p><br><p>  <strong>File MemoryExtensions.Fast.cs</strong> <br>  <a href="">coreclr /../ MemoryExtensions.Fast.cs</a> </p><br><pre> <code class="plaintext hljs">public static ReadOnlySpan&lt;char&gt; AsSpan(this string text) { if (text == null) return default; return new ReadOnlySpan&lt;char&gt;(ref text.GetRawStringData(), text.Length); }</code> </pre> <br><p>  Di mana <code>string.GetRawStringData()</code> terlihat seperti berikut: </p><br><p>  <strong>File dengan definisi bidang</strong> <a href="">coreclr /../ System / String.CoreCLR.cs</a> </p><br><p>  <strong>File dengan definisi GetRawStringData</strong> <a href="">coreclr /../ System / String.cs</a> </p><br><pre> <code class="plaintext hljs">public sealed partial class String : IComparable, IEnumerable, IConvertible, IEnumerable&lt;char&gt;, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, ICloneable { // // These fields map directly onto the fields in an EE StringObject. See object.h for the layout. // [NonSerialized] private int _stringLength; // For empty strings, this will be '\0' since // strings are both null-terminated and length prefixed [NonSerialized] private char _firstChar; internal ref char GetRawStringData() =&gt; ref _firstChar; }</code> </pre> <br><p>  Ternyata metode tersebut secara langsung mengakses bagian dalam string, sementara spesifikasi referensi memungkinkan GC untuk melacak referensi yang tidak dikelola ke bagian dalam string dengan memindahkannya bersama-sama dengan string ketika GC aktif. </p><br><p>  Hal yang sama dengan array: ketika <code>Span</code> dibuat, beberapa kode JIT internal menghitung offset untuk awal array data dan menginisialisasi <code>Span</code> dengan offset ini.  Cara Anda dapat menghitung offset untuk string dan array dibahas dalam bab tentang struktur objek dalam memori (. \ ObjectsStructure.md). </p><br><h3 id="spanlttgt-as-a-returned-value">  Rentang &lt;T&gt; sebagai nilai yang dikembalikan </h3><br><p>  Terlepas dari semua harmoni, <code>Span</code> memiliki beberapa kendala logis tetapi tak terduga dalam pengembalian dari suatu metode.  Jika kita melihat kode berikut: </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var x = GetSpan(); } public Span&lt;byte&gt; GetSpan() { Span&lt;byte&gt; reff = new byte[100]; return reff; }</code> </pre> <br><p>  kita dapat melihatnya logis dan baik.  Namun, jika kami mengganti satu instruksi dengan instruksi lainnya: </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var x = GetSpan(); } public Span&lt;byte&gt; GetSpan() { Span&lt;byte&gt; reff = stackalloc byte[100]; return reff; }</code> </pre> <br><p>  kompiler akan melarangnya.  Sebelum saya katakan alasannya, saya ingin Anda menebak masalah apa yang dikandung oleh konstruk ini. </p><br><p>  Yah, saya harap Anda berpikir, menebak, dan mungkin bahkan mengerti alasannya.  Jika ya, upaya saya untuk menulis bab terperinci tentang [utas tumpukan] (./ThreadStack.md) terbayar.  Karena ketika Anda mengembalikan referensi ke variabel lokal dari metode yang menyelesaikan tugasnya, Anda bisa memanggil metode lain, tunggu sampai selesai juga, dan kemudian membaca nilai variabel-variabel lokal menggunakan x [0,99]. </p><br><p>  Untungnya, ketika kami mencoba untuk menulis kode seperti itu kompiler menampar pergelangan tangan kami dengan peringatan: <code>CS8352 Cannot use local 'reff' in this context because it may expose referenced variables outside of their declaration scope</code> .  Kompiler benar karena jika Anda melewati kesalahan ini, akan ada peluang, saat dalam plug-in, untuk mencuri kata sandi orang lain atau untuk meningkatkan hak istimewa untuk menjalankan plug-in kami. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443976/">https://habr.com/ru/post/id443976/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443964/index.html">Kolesa Conf adalah konferensi IT terbesar di Kazakhstan. Pengumuman laporan</a></li>
<li><a href="../id443966/index.html">Google Documents - obrolan favorit di antara para siswa</a></li>
<li><a href="../id443968/index.html">Bagaimana kami membeli rumah dengan panel surya, dan apa yang terjadi</a></li>
<li><a href="../id443972/index.html">Yandex akan mencari bajak laut menggunakan robot</a></li>
<li><a href="../id443974/index.html">Memory and Span pt. 1</a></li>
<li><a href="../id443978/index.html">ATtiny13 vs PLC, atau cara mendapatkan 14 I / O dari pengontrol 8-kaki</a></li>
<li><a href="../id443980/index.html">Memory and Span pt. 3</a></li>
<li><a href="../id443984/index.html">Standar baru berdasarkan PCIe 5.0 akan "menghubungkan" CPU dan GPU - apa yang diketahui tentang itu</a></li>
<li><a href="../id443986/index.html">Seperti tupai di roda atau sedikit tentang penelitian pengguna dalam pengaturan cacat</a></li>
<li><a href="../id443988/index.html">Arsitektur Microservice = Komputasi Terdistribusi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>