<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèØ ‚ÅâÔ∏è üßôüèΩ Implementa√ß√£o de FPFT inteiro FFT üß£ üö∂üèª ‚òòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Uma vez, os clientes me perguntaram se eu tinha FFT inteiro em meus projetos, ao qual eu sempre respondia que isso j√° havia sido feito...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementa√ß√£o de FPFT inteiro FFT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420517/"> Ol√° pessoal! <br><br>  Uma vez, os clientes me perguntaram se eu tinha FFT inteiro em meus projetos, ao qual eu sempre respondia que isso <u>j√° havia sido feito por outras pessoas</u> na forma de n√∫cleos IP prontos, embora curvos, mas gratuitos (Altera / Xilinx) - pegue-o e use-o.  No entanto, esses n√∫cleos <b>n√£o</b> s√£o <b>√≥timos</b> , possuem um conjunto de "recursos" e requerem refinamentos adicionais.  Nesse contexto, tendo sa√≠do para outras f√©rias planejadas, que eu n√£o queria gastar med√≠ocre, comecei a implementar o kernel configur√°vel da FFT inteira. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (processo de depura√ß√£o de erros de estouro de dados)</i></sub> <br><br>  No artigo, quero dizer a voc√™ por quais m√©todos e meios as opera√ß√µes matem√°ticas s√£o realizadas ao calcular a transformada r√°pida de Fourier em um formato inteiro nos cristais modernos de FPGA.  A base de qualquer FFT √© um n√≥ chamado "borboleta".  A borboleta implementa opera√ß√µes matem√°ticas - adi√ß√£o, multiplica√ß√£o e subtra√ß√£o.  √â sobre a implementa√ß√£o da "borboleta" e seus n√≥s acabados que a hist√≥ria ir√° primeiro.  Com base nas modernas fam√≠lias Xilinx FPGA - s√£o as s√©ries Ultrascale e Ultrascale +, assim como as s√©ries mais antigas 6- (Virtex) e 7- (Artix, Kintex, Virtex) s√£o afetadas.  As s√©ries mais antigas em projetos modernos n√£o s√£o de interesse em 2018.  O objetivo do artigo √© revelar os recursos da implementa√ß√£o de kernels personalizados do processamento de sinal digital usando o exemplo de uma FFT. <br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  N√£o √© segredo para ningu√©m que os algoritmos para a tomada de FFT est√£o firmemente enraizados na vida dos engenheiros de processamento de sinais digitais e, portanto, essa ferramenta √© constantemente necess√°ria.  Os principais fabricantes de FPGA, como o Altera / Xilinx, j√° possuem n√∫cleos FFT / IFFT configur√°veis ‚Äã‚Äãflex√≠veis, mas eles t√™m v√°rias limita√ß√µes e recursos e, portanto, tive que usar minha pr√≥pria experi√™ncia mais de uma vez.  Dessa vez, tive que implementar uma FFT em um formato inteiro, de acordo com o esquema Radix-2 no FPGA.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu √∫ltimo artigo, eu j√° fiz FFT</a> no formato de ponto flutuante e, a partir da√≠, voc√™ sabe que o algoritmo com duplo paralelismo √© usado para implementar a FFT, ou seja, o <b>n√∫cleo pode processar duas amostras complexas na mesma frequ√™ncia</b> .  Esse √© um recurso essencial da FFT que n√£o est√° dispon√≠vel nos kernels prontos para Xilinx FFT. <br><br>  <i>Exemplo:</i> √© necess√°rio desenvolver um n√≥ FFT executando opera√ß√£o cont√≠nua do fluxo de entrada de n√∫meros complexos a uma frequ√™ncia de 800 MHz.  O n√∫cleo do Xilinx n√£o far√° isso (as freq√º√™ncias de clock de processamento alcan√ß√°veis ‚Äã‚Äãnos modernos FPGAs s√£o da ordem de 300-400 MHz) ou exigir√° dizimar o fluxo de entrada de alguma forma.  O n√∫cleo personalizado permite registrar duas amostras de entrada a uma frequ√™ncia de 400 MHz sem interven√ß√£o pr√©via, em vez de uma √∫nica amostra a 800 MHz.  Outro ponto <u>negativo do n√∫cleo da Xilinx FFT √© a incapacidade de aceitar o fluxo de entrada na ordem de revers√£o de bits</u> .  Nesse contexto, um grande recurso de mem√≥ria de chips FPGA √© gasto para reorganizar os dados em uma ordem normal.  Para tarefas de r√°pida convolu√ß√£o de sinais, quando dois n√≥s FFT ficam atr√°s um do outro, isso pode se tornar um momento cr√≠tico, ou seja, a tarefa simplesmente n√£o estar√° no chip FPGA selecionado.  O n√∫cleo da FFT personalizado permite receber dados na ordem normal na entrada e envi√°-los no modo de revers√£o de bits, enquanto o n√∫cleo da FFT inversa - pelo contr√°rio, recebe dados na ordem de revers√£o de bits e os envia no modo normal.  Dois buffers para permuta√ß√£o de dados s√£o salvos de uma vez !!! <br><br>  Como a maior parte do material deste artigo pode se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobrepor ao anterior</a> , decidi me concentrar no t√≥pico de opera√ß√µes matem√°ticas em formato inteiro no FPGA para a implementa√ß√£o da FFT. <br><br><h3>  Par√¢metros do kernel da FFT </h3><br><ul><li>  <i>NFFT</i> - n√∫mero de borboletas (comprimento FFT), </li><li>  <i>DATA_WIDTH</i> - profundidade de bits dos dados de entrada (4-32), </li><li>  <i>TWDL_WIDTH</i> - profundidade de bit dos fatores de torneamento (8-27). </li><li>  <i>S√âRIE</i> - define a fam√≠lia FPGA na qual a FFT √© implementada ("NEW" - Ultrascale, "OLD" - 6/7 da s√©rie Xilinx FPGA). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Como qualquer outro link no circuito, o FFT possui portas de controle de entrada - um sinal de rel√≥gio e um reset, al√©m de portas de dados de entrada e sa√≠da.  Al√©m disso, o sinal USE_FLY √© usado no kernel, o que permite desativar dinamicamente as borboletas FFT para processos de depura√ß√£o ou para ver o fluxo de entrada original. <br><br>  A tabela abaixo mostra a quantidade de recursos FPGA utilizados, dependendo do comprimento da NFFT FFT para DATA_WIDTH = 16 e dois bits TWDL_WIDTH = 16 e 24 bits. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  O n√∫cleo em NFFT = 64K √© est√°vel na frequ√™ncia de processamento <b>FREQ = 375 MHz</b> em um cristal Kintex-7 (410T). <br><br><h3>  Estrutura do projeto </h3><br><br>  O gr√°fico esquem√°tico do n√≥ FFT √© mostrado na figura a seguir: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  Para facilitar a compreens√£o dos recursos de determinados componentes, darei uma lista dos arquivos do projeto e sua breve descri√ß√£o em uma ordem hier√°rquica: <br><ul><li>  <b>N√∫cleos FFT:</b> <br><ul><li>  <i>int_fftNk</i> - n√≥ FFT, circuito Radix-2, dizima√ß√£o de frequ√™ncia (DIF), fluxo de entrada normal, fluxo de sa√≠da inverso de bits. </li><li>  <i>int_ifftNk</i> - n√≥ <i>OBPF</i> , circuito Radix-2, dizima√ß√£o de tempo (DIT), fluxo de entrada com invers√£o de bits, fluxo de sa√≠da normal. </li></ul></li><li>  <b>Borboletas:</b> <br><br><ul><li>  <i>int_dif2_fly</i> - borboleta Radix-2, dizima√ß√£o em frequ√™ncia, </li><li>  <i>int_dit2_fly</i> - borboleta Radix-2, dizima√ß√£o no tempo, </li></ul></li><li>  <b>Multiplicadores complexos:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - multiplicador configur√°vel geral, inclui: </li><li>  <i>int_cmult18x25_dsp48</i> - multiplicador para pequenas <i>profundidades de</i> bits <i>dos</i> dados e fatores de rota√ß√£o, </li><li>  <i>int_cmult_dbl18_dsp48</i> - multiplicador dobrado, largura de bit dos fatores de torneamento de at√© 18 bits, </li><li>  <i>int_cmult_dbl35_dsp48</i> - multiplicador dobrado, largura dos bits dos fatores de rota√ß√£o de at√© 25 * bits, </li><li>  <i>int_cmult_trpl18_dsp48</i> - multiplicador triplo, a capacidade dos fatores de torneamento de at√© 18 bits, </li><li>  <i>int_cmult_trpl52_dsp48</i> - multiplicador triplo, a capacidade dos fatores de rota√ß√£o de at√© 25 * bits, </li></ul></li><li>  <b>Multiplicadores:</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> - um multiplicador com bits de operandos de at√© 42 e 18 bits com base no DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> - multiplicador com bits de operando de at√© 59 e 18 bits com base no DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> - um multiplicador com bits de operandos de at√© 35 e 25 bits com base no DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> - um multiplicador com bits de operandos de at√© 52 e 25 bits com base no DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> - multiplicador com bits de operandos de at√© 44 e 18 bits com base no DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> - multiplicador com bits de operando de at√© 61 e 18 bits com base no DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> - multiplicador com bits de operando de at√© 35 e 27 bits com base no DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> √© um multiplicador com bits de operando de at√© 52 e 27 bits com base no DSP48E2. </li></ul></li><li>  <b>Totalizador:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - somador universal, bits de operando de at√© 96 bits. </li></ul></li><li>  <b>Linhas de atraso:</b> <br><br><ul><li>  <i>int_delay_line</i> - a linha de base do atraso, fornece uma permuta√ß√£o de dados entre borboletas, </li><li>  <i>int_align_fft</i> - alinhamento dos dados de entrada e os fatores de viragem na entrada da borboleta FFT, </li><li>  <i>int_align_fft</i> - alinhamento dos dados de entrada e os fatores de viragem na entrada da borboleta <i>OBPF</i> , </li></ul></li><li>  <b>Fatores rotativos:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> - um gerador de fatores rotativos, de um certo comprimento a FFT considera coeficientes baseados em c√©lulas DSP FPGA, </li><li>  <i>row_twiddle_tay</i> - gerador de fatores rotativos usando uma s√©rie de Taylor (NFFT&gt; 2K) **. </li></ul></li><li>  <b>Buffer de dados:</b> <br><br><ul><li>  <i>inbuf_half_path</i> - buffer de entrada, recebe o fluxo no modo normal e produz duas seq√º√™ncias de amostras deslocadas pela metade do comprimento da FFT ***, </li><li>  <i>outbuf_half_path</i> - o buffer de sa√≠da, coleta duas seq√º√™ncias e produz uma cont√≠nua igual ao comprimento da FFT, </li><li>  <i>iobuf_flow_int2</i> - o buffer funciona em dois modos: recebe um fluxo no modo Interleave-2 e produz duas seq√º√™ncias de FFT deslocadas pela metade do comprimento.  Ou vice-versa, dependendo da op√ß√£o BITREV. </li><li>  <i>int_bitrev_ord</i> √© um simples conversor de dados da ordem natural para a revers√£o de bits. </li></ul></li></ul><br>  <i>* - para DSP48E1: 25 bits, para DSP48E2 - 27 bits.</i> <br>  <i>** - a partir de um certo est√°gio da FFT, uma quantidade fixa de mem√≥ria de bloco pode ser usada para armazenar coeficientes de rota√ß√£o e coeficientes intermedi√°rios podem ser calculados usando n√≥s DSP48, usando a f√≥rmula de Taylor para a primeira derivada.</i>  <i>Devido ao fato de que o recurso de mem√≥ria √© mais importante para a FFT, voc√™ pode sacrificar com seguran√ßa as unidades de computa√ß√£o em prol da mem√≥ria.</i> <i><br></i>  <i>*** - buffer de entrada e linhas de atraso - contribuem significativamente para a quantidade de recursos de mem√≥ria FPGA ocupados</i> <br><br>  <b>Borboleta</b> <br><br>  Todo mundo que encontrou pelo menos uma vez o algoritmo de transforma√ß√£o r√°pida de Fourier sabe que esse algoritmo √© baseado em uma opera√ß√£o elementar - uma "borboleta".  Ele converte o fluxo de entrada multiplicando a entrada pelo fator twiddle.  Existem dois esquemas de convers√£o cl√°ssicos para FFTs - dizima√ß√£o em frequ√™ncia (DIF, dizima√ß√£o em frequ√™ncia) e dizima√ß√£o no tempo (DIT, dizima√ß√£o em tempo).  O algoritmo DIT √© caracterizado pela divis√£o da sequ√™ncia de entrada em duas sequ√™ncias de meia dura√ß√£o, e o algoritmo DIF em duas sequ√™ncias de amostras pares e √≠mpares de dura√ß√£o NFFT.  Al√©m disso, esses algoritmos diferem em opera√ß√µes matem√°ticas para a opera√ß√£o borboleta. <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - pares de entrada de amostras complexas, <br>  <i>X, Y</i> - pares de sa√≠da de amostras complexas, <br>  <i>W</i> - fatores de torneamento complexos. <br><br>  Como os dados de entrada s√£o quantidades complexas, a borboleta requer um multiplicador complexo (4 opera√ß√µes de multiplica√ß√£o e 2 opera√ß√µes de adi√ß√£o) e dois somadores complexos (4 opera√ß√µes de adi√ß√£o).  Essa √© toda a base matem√°tica que deve ser implementada no FPGA. <br><br><h3>  Multiplicador </h3><br>  Deve-se notar que todas as opera√ß√µes matem√°ticas nos FPGAs s√£o frequentemente executadas em c√≥digo adicional (complemento 2).  O multiplicador FPGA pode ser implementado de duas maneiras - na l√≥gica, usando gatilhos e tabelas LUT, ou em unidades especiais de c√°lculo DSP48, que foram inclu√≠das longa e firmemente em todos os FPGAs modernos.  Em blocos l√≥gicos, a multiplica√ß√£o √© implementada usando o algoritmo Booth ou suas modifica√ß√µes, consome uma quantidade decente de recursos l√≥gicos e nem sempre satisfaz as restri√ß√µes de tempo em altas frequ√™ncias de processamento de dados.  Nesse sentido, multiplicadores FPGA em projetos modernos quase sempre s√£o projetados com base em n√≥s DSP48 e apenas ocasionalmente na l√≥gica.  Um n√≥ DSP48 √© uma c√©lula final complexa que implementa fun√ß√µes matem√°ticas e l√≥gicas.  Opera√ß√µes b√°sicas: multiplica√ß√£o, adi√ß√£o, subtra√ß√£o, acumula√ß√£o, contador, opera√ß√µes l√≥gicas (XOR, NAND, AND, OR, NOR), quadratura, compara√ß√£o de n√∫meros, turno, etc.  A figura a seguir mostra a c√©lula DSP48E2 da fam√≠lia Xilinx Ultrascale + FPGA. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  Por meio de uma configura√ß√£o simples das portas de entrada, opera√ß√µes de c√°lculo nos n√≥s e atrasos de configura√ß√£o dentro do n√≥, voc√™ pode fazer uma debulhadora de dados matem√°ticos de alta velocidade. <br>  Observe que todos os principais fornecedores de FPGA no ambiente de desenvolvimento possuem n√∫cleos de IP padr√£o e livres para calcular fun√ß√µes matem√°ticas com base no n√≥ DSP48.  Eles permitem calcular fun√ß√µes matem√°ticas primitivas e definir v√°rios atrasos na entrada e sa√≠da do n√≥.  Para o Xilinx, esse √© o ‚Äúmultiplicador‚Äù do IP-Core (vers√£o 12.0, 2018), que permite configurar o multiplicador para qualquer profundidade de dados de entrada de 2 a 64 bits.  Al√©m disso, voc√™ pode especificar como o multiplicador √© implementado - em recursos l√≥gicos ou em primitivas DSP48 integradas. <br><br>  <b>Estime quanta l√≥gica o multiplicador ‚Äúcome‚Äù</b> com a profundidade de bits dos dados de entrada nas portas A e B = 64 bits.  Se voc√™ usar os n√≥s DSP48, eles precisar√£o de apenas 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  A principal limita√ß√£o nas c√©lulas DSP48 √© a profundidade de bits dos dados de entrada.  O n√≥ DSP48E1, que √© a c√©lula base das s√©ries FPGA Xilinx 6 e 7, a largura das portas de entrada para multiplica√ß√£o: ‚ÄúA‚Äù - 25 bits, ‚ÄúB‚Äù - 18 bits. Portanto, o resultado da multiplica√ß√£o √© um n√∫mero de 43 bits.  Para a fam√≠lia Xilinx Ultrascale e Ultrascale + FPGA, o n√≥ passou por v√°rias altera√ß√µes, em particular, a capacidade da primeira porta aumentada em dois bits: ‚ÄúA‚Äù - 27 bits, ‚ÄúB‚Äù - 18 - bits.  Al√©m disso, o pr√≥prio n√≥ √© chamado DSP48E2. <br><br>  Para n√£o ficar vinculado a uma fam√≠lia espec√≠fica e ao chip FPGA, para garantir a "pureza do c√≥digo fonte" e levar em considera√ß√£o todas as profundidades de bits poss√≠veis dos dados de entrada, foi decidido projetar nosso pr√≥prio conjunto de multiplicadores.  Isso permitir√° a implementa√ß√£o mais eficiente de multiplicadores complexos para borboletas FFT, ou seja, multiplicadores e um somador-subtrator baseado em blocos DSP48.  A primeira entrada do multiplicador s√£o os dados de entrada, a segunda entrada do multiplicador s√£o os fatores rotativos (sinal harm√¥nico da mem√≥ria).  Um conjunto de multiplicadores √© implementado usando a biblioteca UNISIM integrada, a partir da qual √© necess√°rio conectar as primitivas DSP48E1 e DSP48E2 para uso posterior no projeto.  Um conjunto de multiplicadores √© apresentado na tabela.  Note-se que: <br><br><ul><li>  A opera√ß√£o de multiplica√ß√£o de n√∫meros leva a um aumento na capacidade do produto como a soma da capacidade dos operandos. </li><li>  Cada um dos multiplicadores 25x18 e 27x18 √© duplicado, de fato - este √© um componente para fam√≠lias diferentes. </li><li>  Quanto maior o est√°gio de paralelismo da opera√ß√£o, maior o atraso na computa√ß√£o e maior a quantidade de recursos ocupados. </li><li>  Com menor profundidade de bit na entrada ‚ÄúB‚Äù, multiplicadores com maior profundidade de bit em outra entrada podem ser implementados. </li><li>  A principal limita√ß√£o no aumento da profundidade de bits √© introduzida pela porta ‚ÄúB‚Äù (a porta real da primitiva DSP48) e o registro de deslocamento interno em 17 bits. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  Um aumento adicional na profundidade de bits n√£o interessa na estrutura da tarefa pelos motivos descritos abaixo: <br><br><h3>  Profundidade de bit dos fatores de torneamento </h3><br>  Sabe-se que quanto maior a resolu√ß√£o do sinal harm√¥nico, mais preciso o n√∫mero aparece (mais sinais na parte fracion√°ria).  Mas o tamanho do bit da porta √© B &lt;25 bits devido ao fato de que, para os fatores rotacionais nos n√≥s da FFT, essa profundidade de bits √© suficiente para garantir uma multiplica√ß√£o de alta qualidade do fluxo de entrada com elementos de sinal harm√¥nico nas "borboletas" (para qualquer comprimento de FFT real√≠stico poss√≠vel nos FPGAs modernos).  O valor t√≠pico da profundidade de bits dos coeficientes de torneamento nas tarefas que estou implementando √© 16 bits, 24 - menos frequentemente, 32 - nunca. <br><br><h3>  Profundidade de bits das amostras de entrada </h3><br>  A capacidade desses n√≥s de recep√ß√£o e grava√ß√£o t√≠picos (ADCs, DACs) n√£o √© grande - de 8 a 16 bits e raramente - 24 ou 32 bits.  Al√©m disso, no √∫ltimo caso, √© mais eficiente usar o formato de dados de ponto flutuante de acordo com o padr√£o IEEE-754.  Por outro lado, cada est√°gio da ‚Äúborboleta‚Äù na FFT adiciona um bit de dados √†s amostras de sa√≠da devido a opera√ß√µes matem√°ticas.  Por exemplo, para um comprimento de NFFT = 1024, log2 (NFFT) = 10 borboletas √© usado. <br><br>  Portanto, a profundidade do bit de sa√≠da ser√° dez bits maior que a entrada, WOUT = WIN + 10. Em geral, a f√≥rmula fica assim: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Um exemplo: <br><br>  Profundidade de bits do fluxo de entrada WIN = 32 bits, <br>  Profundidade de bit dos fatores de torneamento TWD = 27, <br>  A capacidade da porta "A" da lista de multiplicadores implementados neste artigo n√£o excede 52 bits.  Isso significa que o n√∫mero m√°ximo de borboletas √© FFT = 52-32 = 20. Ou seja, √© poss√≠vel realizar a FFT com um comprimento de at√© 2 ^ 20 = 1M de amostras.  (No entanto, na pr√°tica, isso n√£o √© poss√≠vel por meios diretos devido aos recursos limitados, mesmo para os cristais FPGA mais poderosos, mas isso se relaciona a outro t√≥pico e n√£o ser√° considerado no artigo). <br><br>  Como voc√™ pode ver, essa √© uma das principais raz√µes pelas quais eu n√£o implementei multiplicadores com maior profundidade de bits nas portas de entrada.  <b>Os multiplicadores usados ‚Äã‚Äãcobrem toda a gama de</b> tamanhos de <b>bits de</b> entrada <b>necess√°rios</b> e fatores de rota√ß√£o para a tarefa de calcular a FFT inteira.  Em todos os outros casos, voc√™ pode usar o c√°lculo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>FFT no formato de ponto flutuante</b></a> ! <br><br><h3>  A implementa√ß√£o do multiplicador "amplo" </h3><br>  Com base em um exemplo simples de multiplicar dois n√∫meros que n√£o se encaixam na profundidade de bits de um n√≥ DSP48 padr√£o, mostrarei como voc√™ pode implementar um amplo multiplicador de dados.  A figura a seguir mostra seu diagrama de blocos.  O multiplicador implementa a multiplica√ß√£o de dois n√∫meros assinados no c√≥digo adicional, a largura do primeiro operando X √© de 42 bits, o segundo Y √© de 18 bits.  Ele cont√©m dois n√≥s DSP48E2.  Dois registros s√£o usados ‚Äã‚Äãpara equalizar atrasos no n√≥ superior.  Isso √© feito porque no somador superior voc√™ precisa adicionar corretamente os n√∫meros dos n√≥s superiores e inferiores do DSP48.  O somador de baixo n√£o √© realmente usado.  Na sa√≠da do n√≥ inferior, h√° um atraso adicional do produto para alinhar o n√∫mero de sa√≠da com o tempo.  O atraso total √© de 4 ciclos. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  O trabalho consiste em dois componentes: <br><br><ul><li>  A parte mais jovem: <b>P1 = '0' e X [16: 0] * Y [17: 0];</b> </li><li>  A parte mais antiga: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Totalizador </h3><br>  Como um multiplicador, um somador pode ser constru√≠do com recursos l√≥gicos usando uma cadeia de transfer√™ncia ou em blocos DSP48.  Para alcan√ßar o rendimento m√°ximo, um segundo m√©todo √© prefer√≠vel.  Uma primitiva DSP48 permite implementar a opera√ß√£o de adi√ß√£o de at√© 48 bits, dois n√≥s de at√© 96 bits.  Para a tarefa atual, essas profundidades de bits s√£o suficientes.  Al√©m disso, a primitiva DSP48 possui um modo "SIMD MODE" especial, que paralela a ALU de 48 bits incorporada em v√°rias opera√ß√µes com dados diferentes de pequena capacidade.  Ou seja, no modo "UM", uma grade de bits completa de 48 bits e dois operandos s√£o usados, e no modo "DOIS", a grade de bits √© dividida em v√°rias correntes paralelas de 24 bits cada (4 operandos).  Esse modo, usando apenas um somador, ajuda a reduzir a quantidade de recursos de chips FPGA ocupados em pequenas profundidades de bits de amostras de entrada (nos primeiros est√°gios do c√°lculo). <br><br><h3>  Aumento da profundidade de bits </h3><br>  A opera√ß√£o de <b>multiplicar</b> dois n√∫meros pelos bits N e M em um c√≥digo adicional bin√°rio leva a um aumento na capacidade do bit de sa√≠da para <b>P = N + M.</b> <br><br>  Exemplo: para multiplicar n√∫meros de tr√™s bits N = M = 3, o n√∫mero positivo m√°ximo √© +3 ‚Äã‚Äã= <i>(011) <sub>2</sub></i> e o n√∫mero negativo m√°ximo √© 4 = <i>(100) <sub>2</sub></i> .  O bit mais significativo √© respons√°vel pelo sinal do n√∫mero.  Portanto, o n√∫mero m√°ximo poss√≠vel ao multiplicar √© +16 = <i>(010000) <sub>2</sub></i> , que √© formado como resultado da multiplica√ß√£o de dois n√∫meros negativos m√°ximos -4.  A profundidade de bits da sa√≠da √© igual √† soma dos bits de entrada P = N + M = 6 bits. <br><br>  A opera√ß√£o de <b>adi√ß√£o de</b> dois n√∫meros com os bits N e M no c√≥digo adicional bin√°rio leva a um aumento no bit de sa√≠da em um bit. <br><br>  Exemplo: adicione dois n√∫meros positivos, N = M = 3, o n√∫mero positivo m√°ximo √© 3 = <i>(011) <sub>2</sub></i> e o n√∫mero negativo m√°ximo √© 4 = <i>(100) <sub>2</sub></i> .      . ,    ‚Äì  6 = <i>(0110) <sub>2</sub></i> ,     ‚Äì  -8 = <i>(1000) <sub>2</sub></i> .       . <br><br><h3>    </h3><br> <i><b>  :</b></i> <br>                       .         . ,   16-      -32768 = 0x8000,     -32767 = 0x8001.            <b>~0.003%</b>      . <br><br>       ,         . :  ‚Äì 4 = (100) <sub>2</sub> ,  +3 = (011) <sub>2</sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Resultado da Multiplica√ß√£o = -12 = (110100) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O quinto bit pode ser descartado porque ele duplica o vizinho, o quarto √© um sinal. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Truncamento de bits abaixo:</font></font></b></i> <br><br> ,    ¬´¬ª     ,        ,     .      M- ,        ,   .    0x8000 = -1,   0x7FFF = +1. ,         (  M      ).    ,    ,     1    . ,          [N+M-1-1: M-1].     (  1),  ‚Äì . <br><br> /    ¬´¬ª            <b>          </b> . <br><br> ,      FFT DIT      FFT DIF          W0 = {Re, Im} = {1, 0}.    ,       ‚Äì  ,    .         :      ¬´¬ª  .      : W0 = {Re, Im} = {1, 0}  W1 = {Re, Im} = {0, -1}. ,             .     DSP48     . <br><br>     ‚Äì     -,           ,     . <br><br>       -  ,     .       .   ‚Äî       ‚Äî . <br><br><h3>    INT_FFTK </h3><br><ul><li>     . </li><li>   NFFT = 8-512K . </li><li>     NFFT. </li><li>    ,  . </li><li>    ,  . </li><li>            . </li><li>          ! </li><li>        . </li><li> :    ‚Äì   ,    -. </li><li> :     - ,   ‚Äì  . </li><li>      . Radix-2. </li><li>       NFFT *. </li><li>        . </li><li>      (Virtex-6, 7-Series, Ultrascale). </li><li>    <b>~375MHz</b>  Kintex-7 </li><li>   ‚Äì VHDL. </li><li>     bitreverse   +. </li><li> Open Source     IP-Cores. </li></ul><br><h3>   </h3><br>     INTFFTK  VHDL (     )  m-  Matlab / Octave <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     </a></b> . <br><br><h3>  Conclus√£o </h3><br>       ,       .           ,        .        ,     IP-CORE Xilinx.             . <br><br>        :   Radix-4, Radix-8, Ultra-Long FFT    , FFT-FP32 (  IEEE-754).  ,     ,               .    FFT Radix-8,       (  ). <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">dsmv2014</a> ,      .  Obrigado pela aten√ß√£o! <br><br><h3> UPDATE 2018/08/22 </h3><br><br>      <b>SCALED FFT / IFFT</b> .        1  (truncate LSB).    =  . <br><br>          ,     ,  :          .   ,        -        . <br><br> :    ‚Äî 6 .  ‚Äî   128  . NFFT = 1024 , DATA_WIDTH = 16, TWDL_WIDTH = 16. <br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text">  <b>Fig.</b> <b>1  - :</b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Fig.</b> <b>2  - :</b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li>  ‚Äî UNSCALED FFT, </li><li>  ‚Äî SCALED FFT. </li></ul><br></div></div><br>  ,  SCALED ¬´ ¬ª   ,      UNSCALED   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420517/">https://habr.com/ru/post/pt420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420507/index.html">Antecedentes: a Internet global para todos e seus criadores</a></li>
<li><a href="../pt420509/index.html">Um problema √≥bvio ao usar assert</a></li>
<li><a href="../pt420511/index.html">Trabalhe como especialista em TI no Extremo Oriente - Regi√£o de Amur</a></li>
<li><a href="../pt420513/index.html">Uma c√≥pia pirateada de um servi√ßo pago em 39 linhas de c√≥digo Python</a></li>
<li><a href="../pt420515/index.html">Diariza√ß√£o baseada no modelo GMM-UBM e no algoritmo de adapta√ß√£o MAP</a></li>
<li><a href="../pt420519/index.html">Populariza√ß√£o da ci√™ncia</a></li>
<li><a href="../pt420521/index.html">Agora oficialmente: TLS 1.3 reconhecido como padr√£o</a></li>
<li><a href="../pt420523/index.html">An√°lise de gr√°ficos de op√ß√µes bin√°rias ou como mais uma vez provei para mim mesmo que brindes n√£o existem</a></li>
<li><a href="../pt420525/index.html">Redes para os mais experientes. Parte quinze. QoS</a></li>
<li><a href="../pt420527/index.html">Um sorriso pode soar e √© contagioso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>