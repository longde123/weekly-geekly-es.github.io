<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☣️ 🈷️ 🤧 FAQ tentang arsitektur dan pekerjaan VKontakte 🧑🏿‍🤝‍🧑🏿 ♂️ 👩🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejarah VKontakte ada di Wikipedia, demikian diceritakan oleh Pavel sendiri. Tampaknya semua orang sudah mengenalnya. Pavel berbicara tentang bagian d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FAQ tentang arsitektur dan pekerjaan VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449254/">  Sejarah VKontakte ada di Wikipedia, demikian diceritakan oleh Pavel sendiri.  Tampaknya semua orang sudah mengenalnya.  Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang bagian dalam, arsitektur dan desain situs di HighLoad ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kembali pada tahun 2010</a> .  Banyak server telah bocor sejak itu, jadi kami akan memperbarui informasi: kami membedah, mengeluarkan bagian dalamnya, menimbang - kami melihat perangkat VK dari sudut pandang teknis. <br><br><img src="https://habrastorage.org/webt/_x/zc/wp/_xzcwpb5ze_4e-yx_jw_-8nvnei.jpeg"><br><br>  <strong>Alexey Akulovich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">AterCattus</a> ) adalah pengembang backend di tim VKontakte.  Transkrip dari laporan ini adalah jawaban kolektif untuk pertanyaan yang sering diajukan tentang pengoperasian platform, infrastruktur, server dan interaksi di antara mereka, tetapi bukan tentang pengembangan, yaitu <strong>tentang perangkat keras</strong> .  Secara terpisah - tentang basis data dan apa yang dimiliki VK di tempatnya, tentang pengumpulan log dan pemantauan seluruh proyek secara keseluruhan.  Detail di bawah potongan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_GqcriadL-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Selama lebih dari empat tahun saya telah melakukan semua jenis tugas yang berkaitan dengan backend. <br><br><ul><li>  Unduh, penyimpanan, pemrosesan, distribusi media: video, streaming langsung, audio, foto, dokumen. </li><li>  Infrastruktur, platform, pemantauan pengembang, log, cache regional, CDN, protokol RPC eksklusif. </li><li>  Integrasi dengan layanan eksternal: push mailing, parsing tautan eksternal, umpan RSS. </li><li>  Bantu kolega dalam berbagai masalah, untuk jawaban yang harus Anda masukkan ke dalam kode yang tidak dikenal. </li></ul><br>  Selama ini, saya punya banyak komponen di situs ini.  Saya ingin berbagi pengalaman ini. <br><br><h2>  Arsitektur umum </h2><br>  Semuanya, seperti biasa, dimulai dengan server atau sekelompok server yang menerima permintaan. <br><br><h3>  Server depan </h3><br>  Server depan menerima permintaan melalui HTTPS, RTMP, dan WSS. <br><br>  <strong>HTTPS</strong> adalah permintaan untuk versi web utama dan seluler dari situs: vk.com dan m.vk.com, dan klien resmi dan tidak resmi dari API kami: klien seluler, pengirim pesan instan.  Kami memiliki lalu lintas <strong>RTMP</strong> untuk siaran langsung dengan server depan yang terpisah dan koneksi <strong>WSS</strong> untuk Streaming API. <br><br>  Untuk HTTPS dan WSS, <strong>nginx</strong> diinstal pada server.  Untuk siaran RTMP, kami baru-baru ini beralih ke solusi <strong>kive</strong> kami sendiri, tetapi itu berada di luar cakupan laporan.  Untuk toleransi kesalahan, server ini mengumumkan alamat IP umum dan bertindak sebagai grup sehingga jika terjadi masalah pada salah satu server, permintaan pengguna tidak hilang.  Untuk HTTPS dan WSS, server yang sama ini mengenkripsi lalu lintas untuk mengambil bagian dari beban CPU sendiri. <br><br>  Lebih lanjut kami tidak akan berbicara tentang WSS dan RTMP, tetapi hanya tentang permintaan standar HTTPS, yang biasanya terkait dengan proyek web. <br><br><h3>  Backend </h3><br>  Di belakang bagian depan biasanya server backend.  Mereka menangani permintaan yang diterima server depan dari klien. <br><br>  Ini adalah <strong>server kPHP yang</strong> menjalankan daemon HTTP karena HTTPS sudah didekripsi.  kPHP adalah server yang bekerja sesuai dengan <strong>model prefork</strong> : memulai proses master, sekelompok proses anak, melewati soket mendengarkan kepada mereka dan mereka memproses permintaan mereka.  Pada saat yang sama, proses tidak dimulai ulang antara setiap permintaan dari pengguna, tetapi cukup mengatur ulang negara mereka ke keadaan nol nilai awal - permintaan dengan permintaan, alih-alih memulai kembali. <br><br><h4>  Muat pembagian </h4><br>  Semua backend kami bukanlah kumpulan besar mesin yang dapat menangani permintaan apa pun.  Kami <strong>membaginya menjadi beberapa kelompok</strong> : umum, seluler, api, video, pementasan ... Masalah pada kelompok mesin yang berbeda tidak akan memengaruhi orang lain.  Jika ada masalah dengan video, pengguna yang mendengarkan musik bahkan tidak tahu tentang masalahnya.  Backend untuk mengirim permintaan ke diselesaikan oleh nginx di bagian depan dalam konfigurasi. <br><br><h4>  Pengumpulan dan penyeimbangan metrik </h4><br>  Untuk memahami berapa banyak mobil yang Anda butuhkan di setiap grup, kami <strong>tidak mengandalkan QPS</strong> .  Backend berbeda, mereka memiliki permintaan yang berbeda, setiap permintaan memiliki kompleksitas penghitungan QPS yang berbeda.  Oleh karena itu, kami menggunakan <strong>konsep beban di server secara keseluruhan - pada CPU dan perf</strong> . <br><br>  Kami memiliki ribuan server seperti itu.  Grup kPHP berjalan pada setiap server fisik untuk memanfaatkan semua kernel (karena kPHP adalah single-threaded). <br><br><h3>  Server konten </h3><br>  <strong>CS atau Server Konten adalah penyimpanan</strong> .  CS adalah server yang menyimpan file, dan juga memproses file yang diunggah, semua jenis tugas latar belakang sinkron yang diajukan oleh frontend web utama untuk itu. <br><br>  Kami memiliki puluhan ribu server fisik yang menyimpan file.  Pengguna suka mengunggah file, dan kami senang menyimpan dan membagikannya.  Beberapa server ini ditutup oleh server pu / pp khusus. <br><br><h3>  pu / pp </h3><br>  Jika Anda membuka tab jaringan di VK, maka Anda melihat pu / pp. <br><br><img src="https://habrastorage.org/webt/fd/am/xo/fdamxolkfxlplnc5h5flbihru3g.png"><br><br>  Apa itu pu / pp?  Jika kami menutup satu server demi satu, maka ada dua opsi untuk mengunggah dan mengunduh file ke server yang ditutup: <strong>langsung</strong> melalui <code>http://cs100500.userapi.com/path</code> atau <strong>melalui server perantara</strong> - <code>http://pu.vk.com/c100500/path</code> . <br><br>  <strong>Pu adalah nama historis untuk unggahan foto, dan pp adalah proxy foto</strong> .  Yaitu, satu server untuk mengunggah foto, dan lainnya - untuk diberikan.  Sekarang tidak hanya foto yang dimuat, tetapi nama telah disimpan. <br><br>  Server-server ini <strong>menghentikan sesi HTTPS</strong> untuk menghapus beban prosesor dari penyimpanan.  Juga, karena file pengguna diproses pada server ini, informasi yang kurang sensitif disimpan pada mesin ini, semakin baik.  Misalnya, kunci enkripsi HTTPS. <br><br>  Karena mesin ditutup oleh mesin kami yang lain, kami tidak dapat memberi mereka IP eksternal "putih", dan <strong>memberikan yang "abu-abu"</strong> .  Jadi kami menyimpan di kolam IP dan dijamin untuk melindungi mesin dari akses dari luar - tidak ada IP untuk sampai ke sana. <br><br>  <strong>Toleransi kesalahan melalui IP bersama</strong> .  Dalam hal toleransi kesalahan, skema bekerja dengan cara yang sama - beberapa server fisik memiliki IP fisik yang sama, dan sepotong besi di depannya memilih di mana untuk mengirim permintaan.  Nanti saya akan berbicara tentang opsi lain. <br><br>  Poin kontroversialnya adalah bahwa dalam kasus ini, <strong>klien memiliki lebih sedikit koneksi</strong> .  Jika ada IP yang sama pada beberapa mesin - dengan host yang sama: pu.vk.com atau pp.vk.com, browser klien memiliki batasan jumlah permintaan simultan ke satu host.  Tetapi selama HTTP / 2 di mana-mana, saya percaya bahwa ini tidak lagi terjadi. <br><br>  Yang minus dari skema ini adalah Anda harus <strong>memompa semua lalu lintas</strong> yang masuk ke penyimpanan melalui server lain.  Karena kita memompa lalu lintas melalui mobil, kita belum dapat memompa lalu lintas yang padat dengan cara yang sama, misalnya, video.  Kami mentransfernya langsung - koneksi langsung terpisah untuk repositori individual khusus untuk video.  Kami mengirimkan konten yang lebih ringan melalui proxy. <br><br>  Belum lama ini, kami memiliki versi proksi yang ditingkatkan.  Sekarang saya akan memberitahu Anda bagaimana mereka berbeda dari yang biasa dan mengapa ini perlu. <br><br><h3>  Sun </h3><br>  Pada bulan September 2017, Oracle, yang sebelumnya membeli Sun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memberhentikan sejumlah besar karyawan Sun.</a>  Kita dapat mengatakan bahwa saat ini perusahaan tidak ada lagi.  Memilih nama untuk sistem baru, admin kami memutuskan untuk membayar upeti dan rasa hormat kepada perusahaan ini, dan menamai sistem Sun yang baru.  Di antara kita sendiri, kita menyebutnya "sinar matahari". <br><br><img src="https://habrastorage.org/webt/d3/6f/0j/d36f0jjqbwlst9mk2-lcncltkq4.png"><br><br>  Pp punya beberapa masalah.  <strong>Satu IP per grup adalah cache yang tidak efisien</strong> .  Beberapa server fisik memiliki alamat IP yang sama, dan tidak ada cara untuk mengontrol server mana permintaan akan datang.  Oleh karena itu, jika pengguna yang berbeda datang untuk file yang sama, maka jika ada cache pada server ini, file mengendap di cache masing-masing server.  Ini adalah skema yang sangat tidak efisien, tetapi tidak ada yang bisa dilakukan. <br><br>  Akibatnya, <strong>kami tidak dapat membagikan konten</strong> , karena kami tidak dapat memilih server tertentu untuk grup ini - mereka memiliki IP yang sama.  Juga, untuk beberapa alasan internal, kami <strong>tidak memiliki kesempatan untuk menempatkan server seperti itu di wilayah</strong> .  Mereka hanya berdiri di St. Petersburg. <br><br>  Dengan matahari, kami mengubah sistem seleksi.  Sekarang kami memiliki <strong>routing anycast</strong> : routing dinamis, anycast, daemon self-check.  Setiap server memiliki IP individualnya masing-masing, tetapi pada saat yang sama merupakan subnet yang umum.  Semuanya dikonfigurasi sedemikian rupa sehingga dalam hal hilangnya satu server, lalu lintas menyebar ke server lain dari grup yang sama secara otomatis.  Sekarang dimungkinkan untuk memilih server tertentu, <strong>tidak ada caching yang berlebihan</strong> , dan keandalan tidak terpengaruh. <br><br>  <strong>Dukungan berat badan</strong> .  Sekarang kita dapat menempatkan mobil dengan kapasitas berbeda sesuai kebutuhan, dan juga jika terjadi masalah sementara, ubah bobot “matahari” yang bekerja untuk mengurangi beban pada mobil sehingga mereka “beristirahat” dan bekerja kembali. <br><br>  <strong>Sharding oleh id konten</strong> .  Hal yang lucu tentang sharding adalah bahwa kita biasanya membagikan konten sehingga pengguna yang berbeda mengikuti file yang sama melalui "sun" yang sama sehingga mereka memiliki cache yang sama. <br><br>  Kami baru-baru ini meluncurkan aplikasi Clover.  Ini adalah kuis siaran langsung online tempat presenter mengajukan pertanyaan dan pengguna merespons secara real time dengan memilih opsi.  Aplikasi ini memiliki obrolan tempat pengguna dapat membanjiri.  <strong>Lebih dari 100 ribu orang</strong> dapat secara bersamaan terhubung ke siaran.  Mereka semua menulis pesan yang dikirim ke semua peserta, bersama dengan pesan datang avatar lain.  Jika 100 ribu orang datang untuk satu avatar dalam satu "matahari", maka itu kadang-kadang dapat bergulir di atas awan. <br><br>  Untuk menahan semburan permintaan dari file yang sama, itu untuk beberapa jenis konten yang kami sertakan skema bodoh yang menyebar file di semua "matahari" yang tersedia di wilayah tersebut. <br><br><h4>  Berjemur di dalam </h4><br>  Membalikkan proxy ke nginx, cache di RAM atau disk cepat Optane / NVMe.  Contoh: <code>http://sun4-2.userapi.com/c100500/path</code> - tautan ke "matahari", yang berada di wilayah keempat, grup server kedua.  Itu menutup file path, yang secara fisik terletak di server 100500. <br><br><h3>  Cache </h3><br>  Kami menambahkan satu simpul lagi ke skema arsitektur kami - lingkungan caching. <br><br><img src="https://habrastorage.org/webt/jp/4p/xv/jp4pxvydhstms-z9bpbmpjy0htk.png"><br><br>  Di bawah ini adalah tata letak <strong>cache regional</strong> , ada sekitar 20 di antaranya.  Ini adalah tempat di mana tepatnya cache dan "suns" berada, yang dapat men-cache lalu lintas melalui diri mereka sendiri. <br><br><img src="https://habrastorage.org/webt/yh/9i/qk/yh9iqkv3dyqd3uox9wgd2cmgqba.png"><br><br>  Ini adalah caching konten multimedia, data pengguna tidak disimpan di sini - hanya musik, video, foto. <br><br>  Untuk menentukan wilayah pengguna, kami <strong>mengumpulkan awalan jaringan BGP yang diumumkan di wilayah tersebut</strong> .  Dalam kasus fallback, kami masih memiliki parsing pangkalan geoip, jika kami tidak dapat menemukan IP dengan awalan.  <strong>Berdasarkan IP pengguna, kami menentukan wilayah</strong> .  Dalam kode, kita dapat melihat satu atau lebih wilayah pengguna - titik-titik yang paling dekat secara geografis dengan dia. <br><br><h4>  Bagaimana cara kerjanya? </h4><br>  <strong>Kami mempertimbangkan popularitas file berdasarkan wilayah</strong> .  Ada nomor cache regional tempat pengguna berada, dan pengidentifikasi file - kami mengambil pasangan ini dan menambah peringkat untuk setiap unduhan. <br><br>  Pada saat yang sama, iblis - layanan di wilayah - dari waktu ke waktu datang ke API dan berkata: "Saya memiliki cache ini dan itu, beri saya daftar file paling populer di wilayah saya yang belum saya miliki."  API memberikan banyak file yang diurutkan berdasarkan peringkat, daemon memompanya, membawanya ke daerah dan memberi mereka file dari sana.  Ini adalah perbedaan mendasar antara pu / pp dan Sun dari cache: mereka memberikan file melalui diri mereka sendiri segera, bahkan jika file tersebut tidak ada dalam cache, dan cache pertama memompa file ke dirinya sendiri, dan kemudian mulai memberikannya. <br><br>  Pada saat yang sama, kami mendapatkan <strong>konten lebih dekat dengan pengguna</strong> dan mengolesi beban jaringan.  Misalnya, hanya dari cache Moskow kami mendistribusikan lebih dari 1 Tbit / s selama jam sibuk. <br><br>  Tapi ada masalah - <strong>server cache bukan karet</strong> .  Untuk konten yang sangat populer, terkadang tidak ada cukup jaringan di server yang terpisah.  Kami memiliki server cache 40-50 Gbit / s, tetapi ada konten yang sepenuhnya menyumbat saluran tersebut.  Kami berupaya mewujudkan penyimpanan lebih dari satu salinan file populer di kawasan ini.  Saya berharap bahwa kita akan menyadarinya pada akhir tahun ini. <br><br>  Kami memeriksa arsitektur umum. <br><br><ul><li>  Server depan yang menerima permintaan. </li><li>  Backends yang menangani permintaan. </li><li>  Vault yang ditutup oleh dua jenis proxy. </li><li>  Cache regional. </li></ul><br>  Apa yang hilang dari skema ini?  Tentu saja, basis data tempat kita menyimpan data. <br><br><h2>  Database atau mesin </h2><br>  Kami menyebutnya bukan basis data, tetapi mesin Engine, karena dalam pengertian yang berlaku umum, kami praktis tidak memiliki basis data. <br><br><img src="https://habrastorage.org/webt/n6/zm/lj/n6zmlj5pwxsnqoqp0xgfhxza_ic.png"><br><br>  <strong>Ini adalah langkah yang perlu</strong> .  Itu terjadi karena pada 2008-2009, ketika VK memiliki pertumbuhan popularitas yang eksplosif, proyek ini sepenuhnya bekerja pada MySQL dan Memcache, dan ada masalah.  MySQL suka jatuh dan merusak file, setelah itu tidak naik, dan Memcache secara bertahap menurunkan kinerjanya, dan harus dimulai kembali. <br><br>  Ternyata dalam proyek yang mendapatkan popularitas ada penyimpanan gigih yang merusak data, dan cache yang melambat.  Dalam kondisi seperti itu, sulit untuk mengembangkan proyek yang sedang tumbuh.  Diputuskan untuk mencoba menulis ulang hal-hal penting yang menjadi sandaran proyek dengan sepeda motor mereka sendiri. <br><br>  <strong>Solusinya berhasil</strong> .  Kemampuan untuk melakukan ini adalah, sebagaimana kebutuhan mendesak, karena metode penskalaan lain tidak ada pada waktu itu.  Tidak ada tumpukan basis, NoSQL belum ada, hanya ada MySQL, Memcache, PostrgreSQL - dan itu saja. <br><br>  <strong>Operasi universal</strong> .  Pengembangan ini dipimpin oleh tim pengembang-C kami, dan semuanya dilakukan dengan cara yang sama.  Terlepas dari mesin, di mana-mana ada kira-kira format yang sama dari file yang ditulis ke disk, parameter startup yang sama, sinyal diproses sama dan berperilaku sama jika terjadi situasi dan masalah tepi.  Dengan pertumbuhan mesin, akan lebih mudah bagi administrator untuk mengoperasikan sistem - tidak ada kebun binatang yang perlu dipelihara, dan belajar untuk mengoperasikan setiap pangkalan pihak ketiga yang baru lagi, yang memungkinkan peningkatan jumlah mereka dengan cepat dan mudah. <br><br><h3>  Jenis mesin </h3><br>  Tim telah menulis beberapa mesin.  Berikut adalah beberapa di antaranya: teman, petunjuk, gambar, ipdb, surat, daftar, log, memcached, meowdb, berita, nostradamus, foto, daftar putar, pmemcached, kotak pasir, pencarian, penyimpanan, suka, tugas, ... <br><br>  Untuk setiap tugas yang membutuhkan struktur data spesifik atau proses permintaan yang tidak lazim, tim-C menulis mesin baru.  Kenapa tidak <br><br>  Kami memiliki mesin <strong>memcached</strong> terpisah, yang mirip dengan yang biasa, tetapi dengan banyak roti, dan yang tidak melambat.  Bukan ClickHouse, tetapi berfungsi juga.  Ada <strong>pmemcached</strong> secara terpisah - ini adalah <strong>memcached persisten</strong> yang dapat menyimpan data juga pada disk, dan lebih dari itu masuk ke dalam RAM agar tidak kehilangan data saat memulai ulang.  Ada berbagai mesin untuk tugas individu: antrian, daftar, set - semua yang diperlukan oleh proyek kami. <br><br><h3>  Cluster </h3><br>  Dari sudut pandang kode, tidak perlu membayangkan mesin atau database sebagai proses, entitas, atau instance tertentu.  Kode ini bekerja secara khusus dengan kluster, dengan grup mesin - <strong>satu jenis per kluster</strong> .  Katakanlah ada cluster memcached - itu hanya sekelompok mesin. <br><br><blockquote>  Kode tidak perlu mengetahui lokasi fisik, ukuran dan jumlah server.  Dia pergi ke cluster oleh beberapa pengenal. </blockquote><br>  Agar ini berfungsi, Anda perlu menambahkan entitas lain, yang terletak di antara kode dan mesin - <strong>proxy</strong> . <br><br><h3>  Proxy RPC </h3><br>  Proxy - <strong>bus penghubung</strong> , yang menjalankan hampir seluruh situs.  Pada saat yang sama, kami <strong>tidak memiliki penemuan layanan</strong> - sebagai gantinya ada konfigurasi proxy ini, yang mengetahui lokasi semua cluster dan semua pecahan dari cluster ini.  Ini dilakukan oleh admin. <br><br>  Pemrogram umumnya tidak peduli berapa banyak, di mana dan berapa biayanya - mereka hanya pergi ke cluster.  Ini memungkinkan kita banyak.  Setelah menerima permintaan, proksi mengalihkan permintaan, mengetahui di mana - itu menentukan ini. <br><br><img src="https://habrastorage.org/webt/7k/pf/ia/7kpfiagxzy2a4mrosc_f4otqnw8.png"><br><br>  Pada saat yang sama, proksi adalah titik perlindungan terhadap kegagalan layanan.  Jika ada mesin yang melambat atau mogok, maka proksi memahami ini dan karenanya menanggapi sisi klien.  Ini memungkinkan Anda untuk menghapus batas waktu - kode tidak menunggu mesin merespons, tetapi memahami bahwa itu tidak berfungsi dan Anda perlu berperilaku berbeda.  Kode harus disiapkan untuk fakta bahwa database tidak selalu berfungsi. <br><br><h4>  Implementasi spesifik </h4><br>  Terkadang kami masih ingin memiliki semacam solusi khusus sebagai mesin.  Pada saat yang sama, diputuskan untuk tidak menggunakan rpc-proxy kami yang sudah jadi, yang dibuat khusus untuk mesin kami, tetapi untuk membuat proksi terpisah untuk tugas tersebut. <br><br>  Untuk MySQL, yang masih kami miliki di beberapa tempat, kami menggunakan db-proxy, dan untuk ClickHouse - <strong>Kittenhouse</strong> . <br><br>  Ini berfungsi secara keseluruhan seperti itu.  Ada server, kPHP, Go, Python berjalan di atasnya - secara umum, kode apa pun yang dapat mengikuti protokol RPC kami.  Kode berjalan secara lokal ke RPC-proxy - pada setiap server di mana ada kode, proksi lokalnya sendiri diluncurkan.  Atas permintaan, proksi mengerti ke mana harus pergi. <br><br><img src="https://habrastorage.org/webt/f-/dx/ro/f-dxrox3o97ckejzygz8mgf4tcs.png"><br><br>  Jika satu mesin ingin pergi ke yang lain, bahkan jika itu adalah tetangga, itu melalui proxy, karena tetangga itu bisa berada di pusat data yang berbeda.  Mesin tidak harus dikaitkan dengan mengetahui lokasi selain dari dirinya sendiri - kami memiliki solusi standar ini.  Tapi tentu saja ada pengecualian :) <br><br>  Contoh skema TL yang sesuai dengan semua mesin bekerja. <br><br><pre> <code class="plaintext hljs">memcache.not_found = memcache.Value; memcache.strvalue value:string flags:int = memcache.Value; memcache.addOrIncr key:string flags:int delay:int value:long = memcache.Value; tasks.task fields_mask:# flags:int tag:%(Vector int) data:string id:fields_mask.0?long retries:fields_mask.1?int scheduled_time:fields_mask.2?int deadline:fields_mask.3?int = tasks.Task; tasks.addTask type_name:string queue_id:%(Vector int) task:%tasks.Task = Long;</code> </pre> <br>  Ini adalah protokol biner, analog terdekat yang merupakan <strong>protobuf.</strong>  Skema ini menjelaskan bidang opsional di muka, tipe kompleks - ekstensi skalars bawaan, dan kueri.  Semuanya berfungsi sesuai dengan protokol ini. <br><br><h4>  RPC over TL over TCP / UDP ... UDP? </h4><br>  Kami memiliki protokol RPC untuk menanyakan mesin, yang berjalan di atas skema TL.  Ini semua berfungsi di atas koneksi TCP / UDP.  TCP - sudah jelas mengapa kita sering ditanya tentang UDP. <br><br>  UDP membantu <strong>menghindari masalah sejumlah besar koneksi antar server</strong> .  Jika ada RPC-proxy di setiap server dan secara umum dapat masuk ke mesin apa pun, maka Anda mendapatkan puluhan ribu koneksi TCP ke server.  Ada beban, tetapi tidak berguna.  Dalam kasus UDP, ini bukan masalah. <br><br>  <strong>Tidak ada jabat tangan TCP yang berlebihan</strong> .  Ini adalah masalah khas: ketika mesin baru atau server baru muncul, banyak koneksi TCP dibuat sekaligus.  Untuk permintaan ringan kecil, misalnya, muatan UDP, semua komunikasi antara kode dan mesin adalah <strong>dua paket UDP:</strong> satu terbang di satu arah, yang lain terbang di yang lain.  Satu perjalanan pulang pergi - dan kode menerima respons dari mesin tanpa jabat tangan. <br><br>  Ya, itu semua hanya berfungsi <strong>dengan persentase paket yang sangat kecil</strong> .  Protokol memiliki dukungan untuk transmisi ulang, batas waktu, tetapi jika kita kehilangan banyak, kita mendapatkan TCP praktis, yang tidak menguntungkan.  Di seberang lautan, jangan mengemudi UDP. <br><br>  Kami memiliki ribuan server seperti itu, dan skema yang sama ada di sana: satu paket mesin ditempatkan pada setiap server fisik.  Pada dasarnya, mereka single-threaded untuk bekerja secepat mungkin tanpa pemblokiran, dan diparut sebagai solusi single-threaded.  Pada saat yang sama, kami tidak memiliki yang lebih andal daripada mesin ini, dan banyak perhatian diberikan pada penyimpanan data yang persisten. <br><br><h3>  Penyimpanan data yang persisten </h3><br>  <strong>Mesin menulis binlog</strong> .  Binlog adalah file di mana suatu peristiwa ditambahkan untuk mengubah keadaan atau data.  Dalam solusi yang berbeda itu disebut berbeda: log biner, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AOF</a> , tetapi prinsipnya satu. <br><br>  Agar mesin tidak membaca ulang seluruh binlog selama restart selama bertahun-tahun, mesin menulis <strong>snapshots - status saat ini</strong> .  Jika perlu, mereka pertama membaca dari itu, dan kemudian membaca dari binlog.  Semua binlog ditulis dalam format biner yang sama - sesuai dengan skema-TL, sehingga admin dapat mengadministrasikannya secara merata dengan alat mereka.  Tidak perlu snapshot seperti itu.  Ada tajuk umum yang menunjukkan foto siapa yang int, keajaiban mesin, dan bodi mana yang tidak penting bagi siapa pun.  Ini adalah masalah mesin yang merekam snapshot. <br><br>  Saya akan menjelaskan secara singkat prinsip kerja.  Ada server tempat mesin berjalan.  Dia membuka binlog kosong baru untuk merekam, menulis perubahan acara ke dalamnya. <br><br><img src="https://habrastorage.org/webt/dd/w9/9p/ddw99p7g6upg9hci9ou6aln6d_c.png"><br><br>  Pada titik tertentu, ia memutuskan untuk mengambil snapshot, atau ia menerima sinyal.  Server membuat file baru, benar-benar menulis statusnya ke dalamnya, menambahkan ukuran saat ini dari binlog - offset ke akhir file, dan terus menulis lebih lanjut  Binlog baru tidak dibuat. <br><br><img src="https://habrastorage.org/webt/ec/fq/yt/ecfqytibh2tsm5ncd8mfli-b1ta.png"><br><br>  Pada titik tertentu, ketika mesin dinyalakan kembali, akan ada binlog dan snapshot pada disk.  Mesin membaca dalam snapshot penuh, menaikkan statusnya pada titik tertentu. <br><br><img src="https://habrastorage.org/webt/bg/ph/-u/bgph-uu68nqedhby4a2kf3r9c5u.png"><br><br>  Kurangi posisi yang pada saat snapshot dibuat, dan ukuran binlog. <br><br><img src="https://habrastorage.org/webt/ar/gs/lq/argslqv8ewosmtic8-zaobq4g5o.png"><br><br>  Membaca akhir binlog untuk mendapatkan status saat ini dan terus menulis acara lebih lanjut.  Ini adalah skema sederhana, semua mesin kami bekerja di atasnya. <br><br><h4>  Replikasi data </h4><br>  Akibatnya, replikasi data <strong>berbasis pernyataan</strong> - kami tidak menulis perubahan halaman apa pun pada binlog, melainkan <strong>meminta perubahan</strong> .  Sangat mirip dengan apa yang datang melalui jaringan, hanya sedikit yang berubah. <br><br>  Skema yang sama digunakan tidak hanya untuk replikasi, tetapi juga <strong>untuk membuat cadangan</strong> .  Kami memiliki mesin - master penulisan yang menulis dalam binlog.  Di tempat lain di mana admin mengatur, menyalin binlog ini naik, dan itu saja - kami memiliki cadangan. <br><br><img src="https://habrastorage.org/webt/og/al/sz/ogalszm0wfe3f_064sbjnpo4p9c.png"><br><br>  Jika Anda memerlukan <strong>replika bacaan</strong> untuk mengurangi beban bacaan pada CPU, mesin bacaan hanya naik, yang membaca akhir binlog dan menjalankan perintah ini secara lokal. <br><br>  Jeda di sini sangat kecil, dan ada peluang untuk mengetahui berapa banyak replika di belakang master. <br><br><h3>  Sharding data dalam RPC-proxy </h3><br>  Bagaimana cara kerja sharding?  Bagaimana proksi memahami pecahan mana yang akan dikirim?  Kode tidak mengatakan: "Kirim ke 15 shard!"  - tidak, itu proxy. <br><br>  <strong>Skema paling sederhana adalah firstint</strong> , angka pertama dalam permintaan. <br><br> <code>get(photo100_500) =&gt; 100 % N.</code> <br> <br>  Ini adalah contoh untuk protokol teks memcached sederhana, tetapi, tentu saja, permintaan kompleks, terstruktur.  Contoh mengambil nomor pertama dalam kueri dan sisanya dari divisi dengan ukuran cluster. <br><br>  Ini berguna ketika kita ingin memiliki lokalitas data dari satu entitas.  Katakanlah 100 adalah ID pengguna atau grup, dan kami ingin semua data dari satu entitas berada di beling yang sama untuk permintaan kompleks. <br><br>  Jika kami tidak peduli bagaimana permintaan tersebar di seluruh kluster, ada opsi lain - <strong>membuat seluruh halaman</strong> . <br><br> <code>hash(photo100_500) =&gt; 3539886280 % N</code> <br> <br>  Kami juga mendapatkan hash, sisa divisi dan jumlah pecahan. <br><br>  Kedua opsi ini hanya berfungsi jika kita siap untuk fakta bahwa ketika kita menambah ukuran cluster, kita akan membagi atau menambahnya beberapa kali.  Misalnya, kami memiliki 16 pecahan, kami hilang, kami ingin lebih - Anda bisa mendapatkan 32 dengan aman tanpa downtime.  Jika kita ingin membangun berulang kali, akan ada downtime, karena tidak mungkin untuk menghancurkan semuanya dengan hati-hati tanpa kehilangan.  Opsi ini bermanfaat, tetapi tidak selalu. <br><br>  Jika kita perlu menambah atau menghapus jumlah server yang arbitrer, <strong>hashing yang konsisten pada cincin a la Ketama digunakan</strong> .  Tetapi pada saat yang sama, kami benar-benar kehilangan lokasi data, kami harus membuat permintaan penggabungan ke cluster sehingga masing-masing bagian mengembalikan jawaban kecilnya, dan sudah menggabungkan tanggapan ke proxy. <br><br>  - .   : RPC-proxy  , ,       .     , ,     ,      .    proxy. <br><br><img src="https://habrastorage.org/webt/jx/6t/f9/jx6tf9jlkkmva1qfifzmwrx58wc.png"><br><br><h2>  </h2><br>     .     — <strong>   memcache</strong> . <br><br> <code>ring-buffer: prefix.idx = line</code> <br> <br>    —  , ,      —  .     0     1.   memcache —       .        . <br><br>    ,   <strong>Multi Get</strong>  ,   ,         .  ,   -      ,   ,         ,      . <br><br>         <strong>logs-engine</strong> .      ,       .       600   . <br><br>   ,  ,    6–7 .    ,    , ,    ClickHouse   . <br><br><h3>    ClickHouse </h3><br>   ,      . <br><br><img src="https://habrastorage.org/webt/jm/-j/s0/jm-js04tjh8lb8pii1_dzl_sfa4.png"><br><br>  ,   RPC    RPC-proxy,   ,    .       ClickHouse,        : <br><br><ul><li>  -   ClickHouse; </li><li>  RPC-proxy,      ClickHouse,  - ,  ,   RPC. </li></ul><br>    —          ClickHouse. <br><br>     ClickHouse,   <strong>KittenHouse</strong> .      KittenHouse  ClickHouse —   .   ,  HTTP-     .   ,    ClickHouse <strong>  reverse proxy</strong> ,   ,     .         . <br><br><img src="https://habrastorage.org/webt/zj/fy/5y/zjfy5yuay9-6wqe3nrgjkeznvny.png"><br><br>      RPC-   , ,  nginx.   KittenHouse      UDP. <br><br><img src="https://habrastorage.org/webt/hq/wl/v_/hqwlv_vnujb-maxakxksbmrf6xo.png"><br><br>         ,    UDP-      .       RPC     ,      UDP.      . <br><br><h2>  Pemantauan </h2><br>     : ,        ,     .     : <strong>  </strong> . <br><br><h3>   </h3><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Netdata</a> ,        <strong>Graphite Carbon</strong> .      ClickHouse,   Whisper, .       ClickHouse,   <strong>Grafana</strong>  ,   .  ,   Netdata  Grafana  . <br><br><h3>   </h3><br>      . ,    ,    Counts, UniqueCounts   ,   - . <br><br><pre> <code class="plaintext hljs">statlogsCountEvent ( 'stat_name', $key1, $key2, …) statlogsUniqueCount ( 'stat_name', $uid, $key1, $key2, …) statlogsValuetEvent ( 'stat_name', $value, $key1, $key2, …) $stats = statlogsStatData($params)</code> </pre><br>      ,    ,     —  ,  Wathdogs. <br><br>    <strong> ,</strong>    600   1   .       <strong>   </strong> ,     .     —  ,     . ,      . <br><br>    ,     <strong>  memcache</strong> ,    .         <strong>stats-daemon</strong>   .         <strong>logs-collectors</strong> ,       ,      . <br><br><img src="https://habrastorage.org/webt/ih/ab/oy/ihaboy4luh5hriorej9seodbx6u.png"><br><br>        logs-collectors. <br><br><img src="https://habrastorage.org/webt/fq/ta/bj/fqtabjgq556wqfdz5_kfq3mj94c.png"><br><br>          stas-daemom —   ,      collector.  ,    -        memcache stats-daemon,   ,    . <br><br>  logs-collectors    <strong>meowDB</strong> —   ,      . <br><br><img src="https://habrastorage.org/webt/v_/gb/_y/v_gb_ya-9ywkra7xdh5h_qtqsc4.png"><br><br>      «-SQL»  . <br><br><img src="https://habrastorage.org/webt/1q/gw/wp/1qgwwpyj3ewcwuonshvty_zcfhc.png"><br><br><h3>  </h3><br>  2018     ,          -,      ClickHouse.      ClickHouse —    ? <br><br><img src="https://habrastorage.org/webt/wg/mz/kl/wgmzklw41x7ilj0-5hbr_kfdif8.png"><br><br>    ,     KittenHouse. <br><br><img src="https://habrastorage.org/webt/kq/s7/uj/kqs7ujzbhnqzt5f8djepldmwxia.png"><br><br>   <strong>     «*House»</strong> ,        ,       UDP.   *House    inserts,  ,   KittenHouse.        ClickHouse,     . <br><br><img src="https://habrastorage.org/webt/ff/k3/th/ffk3thypln9exuhyuhr-nuj9hr4.png"><br><br>   memcache, stats-daemon  logs-collectors    . <br><br><img src="https://habrastorage.org/webt/r4/g3/e9/r4g3e9yakpzbx5gscmgyl6keqsa.png"><br><br>   memcache, stats-daemon  logs-collectors    . <br><br><ul><li>     ,     StatsHouse. </li><li> StatsHouse   KittenHouse UDP-,    SQL-inserts, . </li><li> KittenHouse    ClickHouse. </li><li>     ,      StatsHouse —   ClickHouse  SQL. </li></ul><br>    <strong></strong> ,   ,  .    , , ,    .     . <br><br>  <strong>  </strong> .   ,    stats-daemons  logs-collectors,  ClickHouse   ,  ,     . <strong>  ,       </strong> . <br><br><h2>  </h2><br>     PHP.    <strong>git</strong> :  <strong>GitLab</strong>  <strong>TeamCity</strong>  .     -,       ,   —  . <br><br>        ,     diff  — : , , .     binlog   copyfast,          .     ,  <strong>gossip replication</strong> ,       ,  —  ,   .            .      ,       <strong>  </strong> .       . <br><br>     kPHP         <strong>git</strong>   .    <strong> HTTP-</strong> ,      diff —     .     —    <strong>binlog copyfast</strong> .     ,      .  <strong>  </strong> .  copyfast' ,   binlog   ,     gossip replication     ,    -,      .   <strong>graceful </strong>   . <br><br>   ,     ,   : <br><br><ul><li> git master branch; </li><li>   <strong>.deb</strong> ; </li><li>    binlog copyfast; </li><li>   ; </li><li>     .dep; </li><li> <strong>dpkg -i</strong> ; </li><li> graceful    . </li></ul><br>   ,        <strong>.deb</strong> ,     <strong>dpkg -i</strong>   .    kPHP  ,   — dpkg?  .  —  . <br><br> <b> :</b> <br><br><ul><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«  Vkontakte. ?»</a>    copyfast  gossip. </li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">« VK    CLickHouse    »</a> . </li><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«     »</a> ,     ,   . </li></ul><br><blockquote>     ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Russia</a>  17          PHP-. ,     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> (     PHP!) — ,      PHP,   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449254/">https://habr.com/ru/post/id449254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449236/index.html">Oke Google: bagaimana cara melewati captcha?</a></li>
<li><a href="../id449240/index.html">Kisah layanan Daida muda (seni berlangganan)</a></li>
<li><a href="../id449246/index.html">AX200 - Intel Wi-Fi 6</a></li>
<li><a href="../id449248/index.html">IDE modern. Jelas D, sampai batas tertentu E, dan tentu saja bukan saya</a></li>
<li><a href="../id449252/index.html">Proyek zombie - menggabungkan data pengguna bahkan setelah kematiannya</a></li>
<li><a href="../id449256/index.html">Saya membaca 80 resume, saya punya pertanyaan</a></li>
<li><a href="../id449260/index.html">Apa itu pembelajaran mesin otomatis (AutoML)</a></li>
<li><a href="../id449262/index.html">IRM Terbaru - Upgrade Siebel ke IP17 +</a></li>
<li><a href="../id449264/index.html">Membuat sistem pelaporan untuk 1C: ERP berdasarkan OLAP dan Excel</a></li>
<li><a href="../id449266/index.html">3 laporan dengan RusCrypto: konferensi dengan pengalaman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>