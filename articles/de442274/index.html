<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§í ü§¶üèΩ ‚è≤Ô∏è Dart 2. Asynchrone Programmierung: Datenstr√∂me üë©üèº‚Äçü§ù‚Äçüë®üèΩ ü§∑üèª üçö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asynchrone Programmierung: Datenstr√∂me 


 Inhalt 


- Stream-Ereignisse empfangen 
- Fehlerereignisse 
- Arbeite mit Streams 
- Stream-Typen Abonneme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Asynchrone Programmierung: Datenstr√∂me</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442274/"><h1 id="asinhronnoe-programmirovanie-potoki-dannyh">  Asynchrone Programmierung: Datenstr√∂me </h1><br><p>  <strong>Inhalt</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream-Ereignisse empfangen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerereignisse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeite mit Streams</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream-Typen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abonnement-Streams</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broadcast-Streams</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow-Verarbeitungsmethoden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methoden zur Fluss√§nderung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transform () Funktion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen und Dekodieren einer Datei</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Listen () -Methode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was noch zu lesen?</a> </li></ul><br><p>  <strong>Was ist wichtig:</strong> </p><br><ul><li>  Streams bieten eine asynchrone Datensequenz. </li><li>  Datensequenzen enthalten Benutzerereignisse und aus Dateien gelesene Daten. </li><li> Der Stream kann mit <strong>await for</strong> oder <code>listen()</code> von der <code>Stream</code> API verarbeitet werden. </li><li>  Streams bieten eine M√∂glichkeit, auf Fehler zu reagieren. </li><li>  Es gibt zwei Arten von Streams: <code>single subscription</code> Streams und Broadcast. <a name="habracut"></a></li></ul><br><p>  Die asynchrone Programmierung in Dart ist durch die Klassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream gekennzeichnet</a> . </p><br><p>  <code>Future</code> ist eine verz√∂gerte Berechnung.  Wenn eine normale Funktion ein Ergebnis zur√ºckgibt, gibt die asynchrone Funktion ein <code>Future</code> ( <code>future</code> ) -Objekt zur√ºck, das letztendlich das Ergebnis enth√§lt.  <code>future</code> gibt das Ergebnis zur√ºck, wenn der Vorgang abgeschlossen ist. </p><br><p>  Ein Stream ist eine Folge von asynchronen Ereignissen.  Dies √§hnelt einem <code>Iterable</code> asynchronen Objekt, bei dem der Thread das Ereignis nicht meldet, wenn Sie es anfordern, sondern das Ereignis meldet, wenn es bereit ist. </p><br><h2 id="poluchenie-sobytiy-potoka">  Stream-Ereignisse empfangen </h2><br><p>  Streams k√∂nnen auf verschiedene Arten erstellt werden. Dies ist das Thema eines anderen Artikels. Sie k√∂nnen jedoch alle auf dieselbe Weise verwendet werden: Eine asynchrone for-Schleife (normalerweise als <strong>Warten auf bezeichnet</strong> ) iteriert Stream-Ereignisse wie eine <strong>for-</strong> Schleife durch eine Sammlung.  Zum Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value in stream)</span></span></span><span class="hljs-function"> </span></span>{ sum += value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br><p>  Dieser Code empf√§ngt einfach das ganzzahlige Ereignis vom Stream, f√ºgt sie hinzu und gibt den ( <code>future</code> ) Betrag zur√ºck.  Wenn der Hauptteil der Schleife endet, wird die Funktion angehalten, bis das n√§chste Ereignis oder der n√§chste Thread beendet wird. </p><br><p>  Die Funktion ist mit dem <code>async</code> , das bei Verwendung der Warteschleife <code>async</code> erforderlich ist. </p><br><p>  Das folgende Beispiel (auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DartPad</a> ) √ºberpr√ºft den vorherigen Code, indem ein einfacher Strom von Ganzzahlen mithilfe einer Funktion mit <code>async*</code> ( <em>Notengenerator</em> ) erstellt wird: </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; await for (var value in stream) { sum += value; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { yield i; } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // 55 }</span></span></code> </pre> </div></div><br><h2 id="sobytiya-s-oshibkoy">  Fehlerereignisse </h2><br><p>  Threads werden ausgef√ºhrt, wenn sie keine Ereignisse mehr enthalten, und der Code, der die Ereignisse empf√§ngt, wird auf dieselbe Weise dar√ºber informiert, wie er √ºber das Eintreffen eines neuen Ereignisses informiert wird.  Wenn Sie Ereignisse mit <strong>Wartezeit</strong> lesen <strong>,</strong> endet <strong>die</strong> Schleife, wenn der Stream endet. </p><br><p>  In einigen F√§llen tritt ein Fehler auf, bevor der Stream endet.  M√∂glicherweise enth√§lt ein Netzwerkfehler beim Abrufen einer Datei von einem Remoteserver oder der Code, der die Ereignisse generiert hat, einen Fehler. Jemand sollte dar√ºber Bescheid wissen. </p><br><p>  Streams k√∂nnen ein Fehlerereignis auf dieselbe Weise wie Datenereignisse melden.  Die meisten Threads werden nach dem ersten Fehler gestoppt, aber Threads, die mehr als einen Fehler zur√ºckgeben, und Threads, die Daten nach einem Fehlerereignis melden, sind m√∂glich.  In diesem Dokument werden nur Threads behandelt, die nicht mehr als einen Fehler zur√ºckgeben. </p><br><p>  Beim Lesen eines Streams mit " <strong>Warten auf"</strong> wird vom Schleifenoperator <strong>ein</strong> Fehler ausgegeben.  Dies vervollst√§ndigt auch die Schleife.  Sie k√∂nnen den Fehler mit try-catch abfangen.  Im folgenden Beispiel (auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DartPad</a> ) tritt ein Fehler auf, wenn der Schleifeniterator 4 ist: </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; try { await for (var value in stream) { sum += value; } } catch (e) { return -1; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { if (i == 4) { throw new Exception('Intentional exception'); } else { yield i; } } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // -1 }</span></span></code> </pre> </div></div><br><h2 id="rabota-s-potokami">  Arbeite mit Streams </h2><br><p>  Die <code>Stream</code> Klasse enth√§lt eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfsmethoden</a> , die allgemeine Operationen an einem Stream ausf√ºhren k√∂nnen, √§hnlich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterable-</a> Methoden.  Mit <code>lastWhere()</code> aus der <code>Stream</code> API k√∂nnen Sie beispielsweise die kleinste positive Ganzzahl in einem <code>Stream</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastPositive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> </span></span>=&gt; stream.lastWhere((x) =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h2 id="tipy-potokov">  Stream-Typen </h2><br><h3 id="potoki-podpiski">  Abonnement-Streams </h3><br><p>  Der h√§ufigste Stream-Typ enth√§lt eine Folge von Ereignissen, die Teile eines gr√∂√üeren Ganzen sind.  Ereignisse m√ºssen in der richtigen Reihenfolge geliefert werden, ohne dass eines davon fehlt.  Dies ist die Art von Stream, die Sie erhalten, wenn Sie eine Datei lesen oder eine Webanforderung erhalten. </p><br><p>  Ein solcher Stream kann nur einmal angeh√∂rt werden.  Sp√§teres Abh√∂ren kann bedeuten, dass die ersten Ereignisse √ºbersprungen werden, und dann macht der Rest des Streams keinen Sinn.  Wenn Sie mit dem H√∂ren beginnen, werden die Daten extrahiert und in Teilen bereitgestellt. </p><br><h3 id="shirokoveschatelnye-potoki">  Broadcast-Streams </h3><br><p>  Eine andere Art von Stream ist f√ºr einzelne Nachrichten, die einzeln verarbeitet werden k√∂nnen.  Ein solcher Stream kann beispielsweise f√ºr Mausereignisse in einem Browser verwendet werden. </p><br><p>  Sie k√∂nnen jederzeit mit dem Abh√∂ren eines solchen Streams beginnen und erhalten Ereignisse, die w√§hrend des Abh√∂rens aufgetreten sind.  Stream kann mehrere Listener anh√∂ren.  Sie k√∂nnen Streaming-Ereignisse erneut abh√∂ren, nachdem Sie ein vorheriges Abonnement gek√ºndigt haben. </p><br><h2 id="metody-obrabatyvayuschie-potok">  Flow-Verarbeitungsmethoden </h2><br><p>  Die folgenden Methoden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream &lt;T&gt;</a> verarbeiten den Stream und geben das Ergebnis zur√ºck: </p><br><pre> <code class="java hljs">Future&lt;T&gt; get first; Future&lt;bool&gt; get isEmpty; Future&lt;T&gt; get last; Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get length; Future&lt;T&gt; get single; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span></span>; Future&lt;E&gt; drain&lt;E&gt;([E futureValue]); <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;S&gt; fold&lt;S&gt;(S initialValue, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamConsumer&lt;T&gt; streamConsumer)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T Function(T previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">singleWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;List&lt;T&gt;&gt; toList(); Future&lt;Set&lt;T&gt;&gt; toSet();</code> </pre> <br><p>  Alle diese Funktionen au√üer <code>drain()</code> und <code>pipe()</code> entsprechen einer √§hnlichen Funktion in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterable</a> .  Jeder von ihnen kann einfach mit einer asynchronen Funktion mit einer Warteschleife (oder einfach mit einer der anderen Methoden) geschrieben werden.  Einige Implementierungen k√∂nnen beispielsweise wie folgt aussehen: <br>  Alle diese Funktionen au√üer Drain () und Pipe () entsprechen einer √§hnlichen Funktion in Iterable.  Jedes kann einfach geschrieben werden, indem eine asynchrone Funktion mit einer Wait-for-Schleife verwendet wird (oder einfach eine der anderen Methoden verwendet wird).  Einige Implementierungen k√∂nnten beispielsweise sein: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == needle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action) async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ action(event); } } Future&lt;List&lt;T&gt;&gt; toList() async { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> result = &lt;T&gt;[]; await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forEach(result.add); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> async </span></span>=&gt; (await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toList()).join(separator);</code> </pre> <br><p>  (Die tats√§chliche Implementierung ist etwas komplizierter, jedoch haupts√§chlich aus historischen Gr√ºnden.) </p><br><h2 id="metody-izmenyayuschie-potok">  Methoden zur Fluss√§nderung </h2><br><p>  Die folgenden Methoden in Stream geben einen neuen Stream zur√ºck, der auf dem urspr√ºnglichen Stream basiert.  Jeder von ihnen wartet darauf, dass jemand den neuen Stream h√∂rt, bevor er den urspr√ºnglichen h√∂rt. </p><br><pre> <code class="java hljs">Stream&lt;R&gt; cast&lt;R&gt;(); Stream&lt;S&gt; expand&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">Iterable&lt;S&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;S&gt; map&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;R&gt; retype&lt;R&gt;(); <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T event)</span></span></span><span class="hljs-function"> test)</span></span>;</code> </pre> <br><p>  Die obigen Methoden entsprechen √§hnlichen Methoden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterable</a> , die das iterierbare Objekt in ein anderes iterierbares Objekt konvertieren.  All dies kann einfach mit einer asynchronen Funktion mit einer Warteschleife geschrieben werden. </p><br><pre> <code class="java hljs">Stream&lt;E&gt; asyncExpand&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">Stream&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;E&gt; asyncMap&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">FutureOr&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([bool Function(T previous, T next)</span></span></span><span class="hljs-function"> equals])</span></span>;</code> </pre> <br><p>  Die Funktionen <code>asyncExpand()</code> und <code>asyncMap()</code> √§hneln den Funktionen <code>expand()</code> und <code>map()</code> , erm√∂glichen jedoch, dass das Funktionsargument eine asynchrone Funktion ist.  Verschiedene <code>distinct()</code> Funktionen existieren in Iterable nicht, k√∂nnen aber implementiert werden. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function onError, {bool test(error)</span></span></span><span class="hljs-function">})</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Duration timeLimit, {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(EventSink&lt;T&gt; sink)</span></span></span><span class="hljs-function"> onTimeout})</span></span>; Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer);</code> </pre> <br><p>  Die letzten drei Funktionen sind spezifischer.  Dazu geh√∂rt die Fehlerbehandlung, die <strong>die</strong> Warteschleife nicht ausf√ºhren kann, da der allererste Fehler die Schleife beendet und den Stream abonniert.  Es gibt nichts zu tun.  Sie k√∂nnen <code>handleError()</code> , um Fehler aus dem Stream zu entfernen, bevor Sie ihn in der <strong>Wait-for-</strong> Schleife verwenden. </p><br><h3 id="funkciya-transform">  Transform () Funktion </h3><br><p>  Die transform () -Funktion dient nicht nur zur Fehlerbehandlung.  Es ist eine allgemeinere "Karte" f√ºr Streams.  Eine normale Karte erfordert einen Wert f√ºr jedes eingehende Ereignis.  Insbesondere f√ºr E / A-Streams k√∂nnen jedoch mehrere eingehende Ereignisse erforderlich sein, um ein Ausgabeereignis zu erstellen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamTransformer</a> kann dabei helfen.  Decoder wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utf8Decoder</a> sind beispielsweise Transformatoren.  Ein Transformator ben√∂tigt nur eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bind ()</a> -Funktion, die einfach √ºber eine asynchrone Funktion implementiert werden kann. </p><br><pre> <code class="java hljs">Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;( Stream&lt;T&gt; stream, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert, ) async* </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> streamWithoutErrors = stream.handleError((e) =&gt; log(e)); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in streamWithoutErrors)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span>; } }</code> </pre> <br><h3 id="chtenie-i-dekodirovanie-fayla">  Lesen und Dekodieren einer Datei </h3><br><p>  Der folgende Code liest die Datei und f√ºhrt zwei Konvertierungen im Stream durch.  Zuerst werden Daten aus UTF8 konvertiert und dann √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LineSplitter weitergeleitet</a> .  Alle Zeilen werden gedruckt, mit Ausnahme derjenigen, die mit einem Hashtag ( <code>#</code> ) beginnen. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:convert'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:io'</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; args)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file = File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines = file .openRead() .transform(utf8.decoder) .transform(LineSplitter()); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line in lines)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!line.startsWith(<span class="hljs-string"><span class="hljs-string">'#'</span></span>)) print(line); } }</code> </pre> <br><h2 id="metod-listen">  Listen () -Methode </h2><br><p>  Die <code>listen()</code> -Methode ist eine "Low-Level" -Methode, alle anderen Funktionen der Funktion werden durch <code>listen()</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">StreamSubscription&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T event)</span></span></span><span class="hljs-function"> onData, </span></span>{Function onError, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> onDone, bool cancelOnError})</span></span>;</code> </pre> <br><p>  Um einen neuen Stream-Typ zu erstellen, k√∂nnen Sie einfach die <code>Stream</code> Klasse erben und die <code>listen()</code> -Methode implementieren. Alle anderen <code>Stream</code> Methoden rufen <code>listen()</code> auf, um zu funktionieren. </p><br><p>  Mit der listen () -Methode k√∂nnen Sie den Stream abh√∂ren.  Bis Sie dies tun, ist der Stream ein inertes Objekt, das beschreibt, welche Ereignisse Sie abh√∂ren m√∂chten.  Beim Abh√∂ren wird ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamSubscription-</a> Objekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zur√ºckgegeben</a> , das den aktiven Stream darstellt, der Ereignisse generiert.  Dies √§hnelt der <code>Iterable</code> , dass <code>Iterable</code> nur eine Sammlung von Objekten ist und ein Iterator die eigentliche Iteration <code>Iterable</code> . </p><br><p>  Sie k√∂nnen das Abonnieren eines Streams beenden, ihn nach einer Pause fortsetzen und ihn vollst√§ndig k√ºndigen.  Sie k√∂nnen R√ºckrufe angeben, die f√ºr jedes Datenereignis oder Fehlerereignis sowie beim Schlie√üen des Streams aufgerufen werden. </p><br><hr><br><h2 id="chto-esche-pochitat">  Was noch zu lesen? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dart 2. Asynchrone Programmierung: Futures</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442274/">https://habr.com/ru/post/de442274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442264/index.html">Beseitigung von M√∂glichkeiten zur Entf√ºhrung von Verkehr</a></li>
<li><a href="../de442266/index.html">Delta Chat - dezentraler Messenger √ºber E-Mail</a></li>
<li><a href="../de442268/index.html">AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung</a></li>
<li><a href="../de442270/index.html">5 Fehler, die beim Erstellen von 3D-Modellen f√ºr den 3D-Druck vermieden werden sollten</a></li>
<li><a href="../de442272/index.html">Go + = Paketversionierung</a></li>
<li><a href="../de442278/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 6</a></li>
<li><a href="../de442280/index.html">Maschinelles Lernen in Dodo. So starten Sie eine neue Richtung, wenn Sie Entwickler sind</a></li>
<li><a href="../de442282/index.html">Dart 2. Asynchrone Programmierung: Futures</a></li>
<li><a href="../de442284/index.html">NoVerify: Der Linter f√ºr PHP vom VKontakte-Team ist jetzt gemeinfrei</a></li>
<li><a href="../de442286/index.html">Russische Augen√§rzte sprachen √ºber bionisches Sehen. Die neue mobile Anwendung demonstriert die Arbeit von Cyber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>