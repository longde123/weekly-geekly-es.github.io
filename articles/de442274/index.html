<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤒 🤦🏽 ⏲️ Dart 2. Asynchrone Programmierung: Datenströme 👩🏼‍🤝‍👨🏽 🤷🏻 🍚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asynchrone Programmierung: Datenströme 


 Inhalt 


- Stream-Ereignisse empfangen 
- Fehlerereignisse 
- Arbeite mit Streams 
- Stream-Typen Abonneme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Asynchrone Programmierung: Datenströme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442274/"><h1 id="asinhronnoe-programmirovanie-potoki-dannyh">  Asynchrone Programmierung: Datenströme </h1><br><p>  <strong>Inhalt</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream-Ereignisse empfangen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerereignisse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeite mit Streams</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream-Typen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abonnement-Streams</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broadcast-Streams</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow-Verarbeitungsmethoden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methoden zur Flussänderung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transform () Funktion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen und Dekodieren einer Datei</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Listen () -Methode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was noch zu lesen?</a> </li></ul><br><p>  <strong>Was ist wichtig:</strong> </p><br><ul><li>  Streams bieten eine asynchrone Datensequenz. </li><li>  Datensequenzen enthalten Benutzerereignisse und aus Dateien gelesene Daten. </li><li> Der Stream kann mit <strong>await for</strong> oder <code>listen()</code> von der <code>Stream</code> API verarbeitet werden. </li><li>  Streams bieten eine Möglichkeit, auf Fehler zu reagieren. </li><li>  Es gibt zwei Arten von Streams: <code>single subscription</code> Streams und Broadcast. <a name="habracut"></a></li></ul><br><p>  Die asynchrone Programmierung in Dart ist durch die Klassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream gekennzeichnet</a> . </p><br><p>  <code>Future</code> ist eine verzögerte Berechnung.  Wenn eine normale Funktion ein Ergebnis zurückgibt, gibt die asynchrone Funktion ein <code>Future</code> ( <code>future</code> ) -Objekt zurück, das letztendlich das Ergebnis enthält.  <code>future</code> gibt das Ergebnis zurück, wenn der Vorgang abgeschlossen ist. </p><br><p>  Ein Stream ist eine Folge von asynchronen Ereignissen.  Dies ähnelt einem <code>Iterable</code> asynchronen Objekt, bei dem der Thread das Ereignis nicht meldet, wenn Sie es anfordern, sondern das Ereignis meldet, wenn es bereit ist. </p><br><h2 id="poluchenie-sobytiy-potoka">  Stream-Ereignisse empfangen </h2><br><p>  Streams können auf verschiedene Arten erstellt werden. Dies ist das Thema eines anderen Artikels. Sie können jedoch alle auf dieselbe Weise verwendet werden: Eine asynchrone for-Schleife (normalerweise als <strong>Warten auf bezeichnet</strong> ) iteriert Stream-Ereignisse wie eine <strong>for-</strong> Schleife durch eine Sammlung.  Zum Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value in stream)</span></span></span><span class="hljs-function"> </span></span>{ sum += value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br><p>  Dieser Code empfängt einfach das ganzzahlige Ereignis vom Stream, fügt sie hinzu und gibt den ( <code>future</code> ) Betrag zurück.  Wenn der Hauptteil der Schleife endet, wird die Funktion angehalten, bis das nächste Ereignis oder der nächste Thread beendet wird. </p><br><p>  Die Funktion ist mit dem <code>async</code> , das bei Verwendung der Warteschleife <code>async</code> erforderlich ist. </p><br><p>  Das folgende Beispiel (auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DartPad</a> ) überprüft den vorherigen Code, indem ein einfacher Strom von Ganzzahlen mithilfe einer Funktion mit <code>async*</code> ( <em>Notengenerator</em> ) erstellt wird: </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; await for (var value in stream) { sum += value; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { yield i; } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // 55 }</span></span></code> </pre> </div></div><br><h2 id="sobytiya-s-oshibkoy">  Fehlerereignisse </h2><br><p>  Threads werden ausgeführt, wenn sie keine Ereignisse mehr enthalten, und der Code, der die Ereignisse empfängt, wird auf dieselbe Weise darüber informiert, wie er über das Eintreffen eines neuen Ereignisses informiert wird.  Wenn Sie Ereignisse mit <strong>Wartezeit</strong> lesen <strong>,</strong> endet <strong>die</strong> Schleife, wenn der Stream endet. </p><br><p>  In einigen Fällen tritt ein Fehler auf, bevor der Stream endet.  Möglicherweise enthält ein Netzwerkfehler beim Abrufen einer Datei von einem Remoteserver oder der Code, der die Ereignisse generiert hat, einen Fehler. Jemand sollte darüber Bescheid wissen. </p><br><p>  Streams können ein Fehlerereignis auf dieselbe Weise wie Datenereignisse melden.  Die meisten Threads werden nach dem ersten Fehler gestoppt, aber Threads, die mehr als einen Fehler zurückgeben, und Threads, die Daten nach einem Fehlerereignis melden, sind möglich.  In diesem Dokument werden nur Threads behandelt, die nicht mehr als einen Fehler zurückgeben. </p><br><p>  Beim Lesen eines Streams mit " <strong>Warten auf"</strong> wird vom Schleifenoperator <strong>ein</strong> Fehler ausgegeben.  Dies vervollständigt auch die Schleife.  Sie können den Fehler mit try-catch abfangen.  Im folgenden Beispiel (auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DartPad</a> ) tritt ein Fehler auf, wenn der Schleifeniterator 4 ist: </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; try { await for (var value in stream) { sum += value; } } catch (e) { return -1; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { if (i == 4) { throw new Exception('Intentional exception'); } else { yield i; } } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // -1 }</span></span></code> </pre> </div></div><br><h2 id="rabota-s-potokami">  Arbeite mit Streams </h2><br><p>  Die <code>Stream</code> Klasse enthält eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfsmethoden</a> , die allgemeine Operationen an einem Stream ausführen können, ähnlich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterable-</a> Methoden.  Mit <code>lastWhere()</code> aus der <code>Stream</code> API können Sie beispielsweise die kleinste positive Ganzzahl in einem <code>Stream</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastPositive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> </span></span>=&gt; stream.lastWhere((x) =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h2 id="tipy-potokov">  Stream-Typen </h2><br><h3 id="potoki-podpiski">  Abonnement-Streams </h3><br><p>  Der häufigste Stream-Typ enthält eine Folge von Ereignissen, die Teile eines größeren Ganzen sind.  Ereignisse müssen in der richtigen Reihenfolge geliefert werden, ohne dass eines davon fehlt.  Dies ist die Art von Stream, die Sie erhalten, wenn Sie eine Datei lesen oder eine Webanforderung erhalten. </p><br><p>  Ein solcher Stream kann nur einmal angehört werden.  Späteres Abhören kann bedeuten, dass die ersten Ereignisse übersprungen werden, und dann macht der Rest des Streams keinen Sinn.  Wenn Sie mit dem Hören beginnen, werden die Daten extrahiert und in Teilen bereitgestellt. </p><br><h3 id="shirokoveschatelnye-potoki">  Broadcast-Streams </h3><br><p>  Eine andere Art von Stream ist für einzelne Nachrichten, die einzeln verarbeitet werden können.  Ein solcher Stream kann beispielsweise für Mausereignisse in einem Browser verwendet werden. </p><br><p>  Sie können jederzeit mit dem Abhören eines solchen Streams beginnen und erhalten Ereignisse, die während des Abhörens aufgetreten sind.  Stream kann mehrere Listener anhören.  Sie können Streaming-Ereignisse erneut abhören, nachdem Sie ein vorheriges Abonnement gekündigt haben. </p><br><h2 id="metody-obrabatyvayuschie-potok">  Flow-Verarbeitungsmethoden </h2><br><p>  Die folgenden Methoden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream &lt;T&gt;</a> verarbeiten den Stream und geben das Ergebnis zurück: </p><br><pre> <code class="java hljs">Future&lt;T&gt; get first; Future&lt;bool&gt; get isEmpty; Future&lt;T&gt; get last; Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get length; Future&lt;T&gt; get single; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span></span>; Future&lt;E&gt; drain&lt;E&gt;([E futureValue]); <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;S&gt; fold&lt;S&gt;(S initialValue, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamConsumer&lt;T&gt; streamConsumer)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T Function(T previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">singleWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;List&lt;T&gt;&gt; toList(); Future&lt;Set&lt;T&gt;&gt; toSet();</code> </pre> <br><p>  Alle diese Funktionen außer <code>drain()</code> und <code>pipe()</code> entsprechen einer ähnlichen Funktion in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterable</a> .  Jeder von ihnen kann einfach mit einer asynchronen Funktion mit einer Warteschleife (oder einfach mit einer der anderen Methoden) geschrieben werden.  Einige Implementierungen können beispielsweise wie folgt aussehen: <br>  Alle diese Funktionen außer Drain () und Pipe () entsprechen einer ähnlichen Funktion in Iterable.  Jedes kann einfach geschrieben werden, indem eine asynchrone Funktion mit einer Wait-for-Schleife verwendet wird (oder einfach eine der anderen Methoden verwendet wird).  Einige Implementierungen könnten beispielsweise sein: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == needle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action) async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ action(event); } } Future&lt;List&lt;T&gt;&gt; toList() async { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> result = &lt;T&gt;[]; await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forEach(result.add); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> async </span></span>=&gt; (await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toList()).join(separator);</code> </pre> <br><p>  (Die tatsächliche Implementierung ist etwas komplizierter, jedoch hauptsächlich aus historischen Gründen.) </p><br><h2 id="metody-izmenyayuschie-potok">  Methoden zur Flussänderung </h2><br><p>  Die folgenden Methoden in Stream geben einen neuen Stream zurück, der auf dem ursprünglichen Stream basiert.  Jeder von ihnen wartet darauf, dass jemand den neuen Stream hört, bevor er den ursprünglichen hört. </p><br><pre> <code class="java hljs">Stream&lt;R&gt; cast&lt;R&gt;(); Stream&lt;S&gt; expand&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">Iterable&lt;S&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;S&gt; map&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;R&gt; retype&lt;R&gt;(); <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T event)</span></span></span><span class="hljs-function"> test)</span></span>;</code> </pre> <br><p>  Die obigen Methoden entsprechen ähnlichen Methoden in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterable</a> , die das iterierbare Objekt in ein anderes iterierbares Objekt konvertieren.  All dies kann einfach mit einer asynchronen Funktion mit einer Warteschleife geschrieben werden. </p><br><pre> <code class="java hljs">Stream&lt;E&gt; asyncExpand&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">Stream&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;E&gt; asyncMap&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">FutureOr&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([bool Function(T previous, T next)</span></span></span><span class="hljs-function"> equals])</span></span>;</code> </pre> <br><p>  Die Funktionen <code>asyncExpand()</code> und <code>asyncMap()</code> ähneln den Funktionen <code>expand()</code> und <code>map()</code> , ermöglichen jedoch, dass das Funktionsargument eine asynchrone Funktion ist.  Verschiedene <code>distinct()</code> Funktionen existieren in Iterable nicht, können aber implementiert werden. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function onError, {bool test(error)</span></span></span><span class="hljs-function">})</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Duration timeLimit, {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(EventSink&lt;T&gt; sink)</span></span></span><span class="hljs-function"> onTimeout})</span></span>; Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer);</code> </pre> <br><p>  Die letzten drei Funktionen sind spezifischer.  Dazu gehört die Fehlerbehandlung, die <strong>die</strong> Warteschleife nicht ausführen kann, da der allererste Fehler die Schleife beendet und den Stream abonniert.  Es gibt nichts zu tun.  Sie können <code>handleError()</code> , um Fehler aus dem Stream zu entfernen, bevor Sie ihn in der <strong>Wait-for-</strong> Schleife verwenden. </p><br><h3 id="funkciya-transform">  Transform () Funktion </h3><br><p>  Die transform () -Funktion dient nicht nur zur Fehlerbehandlung.  Es ist eine allgemeinere "Karte" für Streams.  Eine normale Karte erfordert einen Wert für jedes eingehende Ereignis.  Insbesondere für E / A-Streams können jedoch mehrere eingehende Ereignisse erforderlich sein, um ein Ausgabeereignis zu erstellen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamTransformer</a> kann dabei helfen.  Decoder wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Utf8Decoder</a> sind beispielsweise Transformatoren.  Ein Transformator benötigt nur eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bind ()</a> -Funktion, die einfach über eine asynchrone Funktion implementiert werden kann. </p><br><pre> <code class="java hljs">Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;( Stream&lt;T&gt; stream, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert, ) async* </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> streamWithoutErrors = stream.handleError((e) =&gt; log(e)); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in streamWithoutErrors)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span>; } }</code> </pre> <br><h3 id="chtenie-i-dekodirovanie-fayla">  Lesen und Dekodieren einer Datei </h3><br><p>  Der folgende Code liest die Datei und führt zwei Konvertierungen im Stream durch.  Zuerst werden Daten aus UTF8 konvertiert und dann über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LineSplitter weitergeleitet</a> .  Alle Zeilen werden gedruckt, mit Ausnahme derjenigen, die mit einem Hashtag ( <code>#</code> ) beginnen. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:convert'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:io'</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; args)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file = File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines = file .openRead() .transform(utf8.decoder) .transform(LineSplitter()); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line in lines)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!line.startsWith(<span class="hljs-string"><span class="hljs-string">'#'</span></span>)) print(line); } }</code> </pre> <br><h2 id="metod-listen">  Listen () -Methode </h2><br><p>  Die <code>listen()</code> -Methode ist eine "Low-Level" -Methode, alle anderen Funktionen der Funktion werden durch <code>listen()</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">StreamSubscription&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T event)</span></span></span><span class="hljs-function"> onData, </span></span>{Function onError, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> onDone, bool cancelOnError})</span></span>;</code> </pre> <br><p>  Um einen neuen Stream-Typ zu erstellen, können Sie einfach die <code>Stream</code> Klasse erben und die <code>listen()</code> -Methode implementieren. Alle anderen <code>Stream</code> Methoden rufen <code>listen()</code> auf, um zu funktionieren. </p><br><p>  Mit der listen () -Methode können Sie den Stream abhören.  Bis Sie dies tun, ist der Stream ein inertes Objekt, das beschreibt, welche Ereignisse Sie abhören möchten.  Beim Abhören wird ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamSubscription-</a> Objekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zurückgegeben</a> , das den aktiven Stream darstellt, der Ereignisse generiert.  Dies ähnelt der <code>Iterable</code> , dass <code>Iterable</code> nur eine Sammlung von Objekten ist und ein Iterator die eigentliche Iteration <code>Iterable</code> . </p><br><p>  Sie können das Abonnieren eines Streams beenden, ihn nach einer Pause fortsetzen und ihn vollständig kündigen.  Sie können Rückrufe angeben, die für jedes Datenereignis oder Fehlerereignis sowie beim Schließen des Streams aufgerufen werden. </p><br><hr><br><h2 id="chto-esche-pochitat">  Was noch zu lesen? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dart 2. Asynchrone Programmierung: Futures</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442274/">https://habr.com/ru/post/de442274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442264/index.html">Beseitigung von Möglichkeiten zur Entführung von Verkehr</a></li>
<li><a href="../de442266/index.html">Delta Chat - dezentraler Messenger über E-Mail</a></li>
<li><a href="../de442268/index.html">AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung</a></li>
<li><a href="../de442270/index.html">5 Fehler, die beim Erstellen von 3D-Modellen für den 3D-Druck vermieden werden sollten</a></li>
<li><a href="../de442272/index.html">Go + = Paketversionierung</a></li>
<li><a href="../de442278/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 6</a></li>
<li><a href="../de442280/index.html">Maschinelles Lernen in Dodo. So starten Sie eine neue Richtung, wenn Sie Entwickler sind</a></li>
<li><a href="../de442282/index.html">Dart 2. Asynchrone Programmierung: Futures</a></li>
<li><a href="../de442284/index.html">NoVerify: Der Linter für PHP vom VKontakte-Team ist jetzt gemeinfrei</a></li>
<li><a href="../de442286/index.html">Russische Augenärzte sprachen über bionisches Sehen. Die neue mobile Anwendung demonstriert die Arbeit von Cyber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>