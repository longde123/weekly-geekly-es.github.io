<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛃 🏘️ 🐘 Anpassen der Abhängigkeitsauflösung im Frühjahr 🤳🏾 👨🏽‍🏭 🐒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Andrey Nevedomsky und ich bin der Chefingenieur in SberTekh. Ich arbeite in einem Team, das einen der Systemdienste des ESF (Unif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anpassen der Abhängigkeitsauflösung im Frühjahr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/435364/">  Hallo!  Mein Name ist Andrey Nevedomsky und ich bin der Chefingenieur in SberTekh.  Ich arbeite in einem Team, das einen der Systemdienste des ESF (Unified Frontal System) entwickelt.  In unserer Arbeit nutzen wir aktiv das Spring Framework, insbesondere dessen DI, und sehen uns von Zeit zu Zeit mit der Tatsache konfrontiert, dass das Auflösen von Abhängigkeiten im Frühjahr für uns nicht klug genug ist.  Dieser Artikel ist das Ergebnis meiner Versuche, ihn intelligenter zu gestalten und allgemein zu verstehen, wie er funktioniert.  Ich hoffe, Sie können daraus etwas Neues über das Gerät des Frühlings lernen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ea/bbf/f4c/0eabbff4c25bb87806837c487f847fcc.png"><br><a name="habracut"></a><br>  Bevor Sie den Artikel lesen, empfehle ich Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dringend, die</a> Berichte von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Boris</a> Yevgeny <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">EvgenyBorisov zu</a> lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring the Ripper, Teil 1</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Federtrenner, Teil 2</a> .  Es gibt noch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiedergabeliste von ihnen</a> . <br><br><h2>  Einführung </h2><br>  Stellen wir uns vor, wir wurden gebeten, einen Dienst zur Vorhersage von Schicksal und Horoskopen zu entwickeln.  Es gibt mehrere Komponenten in unserem Service, aber die wichtigsten für uns sind zwei: <br><br><ul><li>  Globa, das die FortuneTeller-Schnittstelle implementiert und das Schicksal vorhersagt; <br><br><img src="https://habrastorage.org/getpro/habr/post_images/301/c90/6f1/301c906f1584237b8bab4f8627484ff2.png" width="365" height="450"><br><br></li></ul><br><ul><li>  Gypsy, der die HoroscopeTeller-Schnittstelle implementiert und Horoskope erstellt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/520/3ad/d9f5203ad3b823ea61d5322655d2164d.png" width="365" height="450"><br><br></li></ul><br>  Auch in unserem Dienst wird es mehrere Endpunkte (Controller) geben, um tatsächlich Wahrsagerei und Horoskope zu erhalten.  Außerdem werden wir den Zugriff auf unsere Anwendung über IP mithilfe eines Aspekts steuern, der auf Controller-Methoden angewendet wird und ungefähr so ​​aussieht: <br><br><div class="spoiler">  <b class="spoiler_title">RestrictionAspect.java</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Aspect</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RestrictionAspect</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;String&gt; ipIsAllowed;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestrictionAspect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Predicate&lt;String&gt; ipIsAllowed)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ipIsAllowed = ipIsAllowed;    }    <span class="hljs-meta"><span class="hljs-meta">@Before</span></span>(<span class="hljs-string"><span class="hljs-string">"execution(public * com.github.monosoul.fortuneteller.web.*.*(..))"</span></span>)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{        val ip = getRequestSourceIp();       log.debug(<span class="hljs-string"><span class="hljs-string">"Source IP: {}"</span></span>, ip);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ipIsAllowed.test(ip)) {            <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AccessDeniedException(format(<span class="hljs-string"><span class="hljs-string">"Access for IP [%s] is denied"</span></span>, ip));        }    }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRequestSourceIp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{        val requestAttributes = currentRequestAttributes();        Assert.state(requestAttributes <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ServletRequestAttributes,                <span class="hljs-string"><span class="hljs-string">"RequestAttributes needs to be a ServletRequestAttributes"</span></span>);        val request = ((ServletRequestAttributes) requestAttributes).getRequest();        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.getRemoteAddr();    } }</code> </pre> <br></div></div><br>  Um zu überprüfen, ob der Zugriff von einer solchen IP aus zulässig ist, verwenden wir eine Implementierung des Prädikats <code>ipIsAllowed</code> .  Im Allgemeinen kann es auf der Website dieses Aspekts eine andere, beispielsweise autorisierende Funktion geben. <br><br>  Also haben wir die Anwendung entwickelt und alles funktioniert gut für uns.  Aber lassen Sie uns jetzt über das Testen sprechen. <br><br><h2>  Wie teste ich es? </h2><br>  Lassen Sie uns darüber sprechen, wie wir die Anwendung von Aspekten testen können.  Wir haben verschiedene Möglichkeiten, dies zu tun. <br><br>  Sie können separate Tests für einen Aspekt und für Controller schreiben, ohne den Federkontext zu erhöhen (wodurch nur ein Proxy mit einem Aspekt für den Controller erstellt wird. Weitere Informationen hierzu finden Sie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ). In diesem Fall werden wir jedoch <u>nicht genau testen, auf welche Aspekte korrekt angewendet wird Controller und arbeiten genau so, wie wir es erwarten</u> ; <br><br>  Sie können Tests schreiben, in denen wir den vollständigen Kontext unserer Anwendung ansprechen, aber in diesem Fall: <br><br><ul><li>  Das Ausführen von Tests wird lange dauern, weil  alle Behälter werden steigen; </li><li>  Wir müssen gültige Testdaten vorbereiten, die die gesamte Anrufkette zwischen Bins durchlaufen können, ohne gleichzeitig NPE zu werfen. </li></ul><br>  Aber wir wollen genau testen, was der Aspekt angewendet hat und seine Arbeit macht.  Wir möchten die vom Controller aufgerufenen Dienste nicht testen und möchten daher nicht durch Testdaten verwirrt werden und die Startzeit opfern.  Daher werden wir Tests schreiben, in denen wir nur einen Teil des Kontexts ansprechen.  Das heißt,  In unserem Kontext wird es eine echte Aspekt-Bean und eine echte Controller-Bean geben, und alles andere wird Mokami sein. <br><br><h2>  Wie erstelle ich Moka Bohnen? </h2><br>  Es gibt verschiedene Möglichkeiten, im Frühjahr Moka-Bohnen herzustellen.  Zur Verdeutlichung nehmen wir als Beispiel einen der Controller unseres Dienstes - <code>PersonalizedHoroscopeTellController</code> . Der Code sieht folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">PersonalizedHoroscopeTellController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>( value = <span class="hljs-string"><span class="hljs-string">"/horoscope"</span></span>, produces = APPLICATION_JSON_UTF8_VALUE ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HoroscopeTeller horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, ZodiacSign&gt; zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, String&gt; nameNormalizer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeTeller horoscopeTeller, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, ZodiacSign&gt; zodiacSignConverter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, String&gt; nameNormalizer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.horoscopeTeller = horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zodiacSignConverter = zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nameNormalizer = nameNormalizer; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/tell/personal/{name}/{sign}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PersonalizedHoroscope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String name, @PathVariable </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String sign)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"Received name: {}; sign: {}"</span></span>, name, sign); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonalizedHoroscope.builder() .name( nameNormalizer.apply(name) ) .horoscope( horoscopeTeller.tell( zodiacSignConverter.apply(sign) ) ) .build(); } }</code> </pre> <br></div></div><br><h3>  Java-Konfiguration mit Abhängigkeiten in jedem Test </h3><br>  Für jeden Test können wir Java Config schreiben, in dem wir sowohl die Controller- als auch die Aspect-Beans und die Beans mit den Controller-Abhängigkeits-Moks beschreiben.  Diese Art der Beschreibung der Bohnen ist unerlässlich, da wir dem Frühling ausdrücklich mitteilen werden, wie wir die Bohnen herstellen müssen. <br><br>  In diesem Fall sieht der Test für unseren Controller folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">javaconfig / PersonalizedHoroscopeTellControllerTest.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringJUnitConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LIMIT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonalizedHoroscopeTellController controller; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Predicate&lt;String&gt; ipIsAllowed; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doNothingWhenAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwExceptionWhenNotAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); assertThatThrownBy(() -&gt; controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT))) .isInstanceOf(AccessDeniedException.class); } <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>(AspectConfiguration.class) <span class="hljs-meta"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PersonalizedHoroscopeTellController </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">personalizedHoroscopeTellController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeTeller horoscopeTeller, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, ZodiacSign&gt; zodiacSignConverter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, String&gt; nameNormalizer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonalizedHoroscopeTellController(horoscopeTeller, zodiacSignConverter, nameNormalizer); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HoroscopeTeller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">horoscopeTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock(HoroscopeTeller.class); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Function&lt;String, ZodiacSign&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zodiacSignConverter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock(Function.class); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Function&lt;String, String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nameNormalizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock(Function.class); } } }</code> </pre> <br></div></div><br>  Ein solcher Test sieht ziemlich umständlich aus.  In diesem Fall müssen wir Java Config für jeden der Controller schreiben.  Obwohl der Inhalt unterschiedlich sein wird, hat er dieselbe Bedeutung: Erstellen Sie eine Controller-Bean und ein Moki für ihre Abhängigkeiten.  Im Wesentlichen ist es also für alle Controller gleich.  Ich bin, wie jeder Programmierer, eine faule Person, deshalb habe ich diese Option sofort abgelehnt. <br><br><h3>  @ MockBean-Annotation über jedes Feld mit Abhängigkeit </h3><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Annotation @MockBean wurde</a> in Spring Boot Test Version 1.4.0 angezeigt.  Es ähnelt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Mock</a> von Mockito (und verwendet es sogar intern), mit dem einzigen Unterschied, dass bei Verwendung von <code>@MockBean</code> das erstellte Mock automatisch in den Spring-Kontext gestellt wird.  Diese Methode zum Deklarieren von Mok ist deklarativ, da wir Spring nicht genau sagen müssen, wie diese Mok erstellt werden sollen. <br><br>  In diesem Fall sieht der Test folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">mockbean / PersonalizedHoroscopeTellControllerTest.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringJUnitConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LIMIT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HoroscopeTeller horoscopeTeller; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Function&lt;String, ZodiacSign&gt; zodiacSignConverter; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Function&lt;String, String&gt; nameNormalizer; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Predicate&lt;String&gt; ipIsAllowed; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonalizedHoroscopeTellController controller; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doNothingWhenAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwExceptionWhenNotAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); assertThatThrownBy(() -&gt; controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT))) .isInstanceOf(AccessDeniedException.class); } <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>({PersonalizedHoroscopeTellController.class, RestrictionAspect.class, RequestContextHolderConfigurer.class}) <span class="hljs-meta"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br></div></div><br>  In dieser Option gibt es noch Java Config, aber es ist viel kompakter.  Unter den Mängeln - Ich musste Felder mit Controller-Abhängigkeiten deklarieren (Felder mit <code>@MockBean</code> Annotation), obwohl sie im Test nicht weiter verwendet werden.  Wenn Sie aus irgendeinem Grund eine Spring Boot-Version unter 1.4.0 verwenden, können Sie diese Anmerkung nicht verwenden. <br><br>  Daher kam mir eine Idee für eine andere Option zum Rauchen.  Ich möchte, dass es so funktioniert ... <br><br><h3>  @Automocked Annotation über abhängige Komponente </h3><br>  Ich möchte, dass wir die Annotation <code>@Automocked</code> , die ich nur mit dem Controller über das Feld setzen kann, und dann wird moki automatisch für diesen Controller erstellt und in den Kontext gestellt. <br><br>  Der Test in diesem Fall könnte folgendermaßen aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">automocked / PersonalizedHoroscopeTellControllerTest.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringJUnitConfig</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = AspectConfiguration.class) <span class="hljs-meta"><span class="hljs-meta">@TestExecutionListeners</span></span>(listeners = AutomockTestExecutionListener.class, mergeMode = MERGE_WITH_DEFAULTS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LIMIT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Automocked</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonalizedHoroscopeTellController controller; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Predicate&lt;String&gt; ipIsAllowed; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doNothingWhenAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwExceptionWhenNotAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); assertThatThrownBy(() -&gt; controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT))) .isInstanceOf(AccessDeniedException.class); } }</code> </pre> <br></div></div><br>  Wie Sie sehen können, ist diese Option die kompakteste der vorgestellten, es gibt nur eine Controller-Bean (plus ein Prädikat für einen Aspekt), <code>@Automocked</code> Annotation <code>@Automocked</code> befindet sich <code>@Automocked</code> , und die ganze <u>Magie, Beans zu erstellen und in den Kontext zu stellen, wird einmal geschrieben</u> und kann in allen verwendet werden Tests. <br><br><h2>  Wie funktioniert es </h2><br>  Mal sehen, wie es funktioniert und was wir dafür brauchen. <br><br><h3>  TestExecutionListener </h3><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frühjahr</a> gibt es eine solche Schnittstelle - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TestExecutionListener</a> .  Es bietet eine API zum Einbetten in den Testausführungsprozess in seinen verschiedenen Phasen, z. B. beim Erstellen einer Instanz einer Testklasse, vor oder nach dem Aufrufen einer Testmethode usw.  Er hat mehrere sofort einsatzbereite Implementierungen.  Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DirtiesContextTestExecutionListener</a> , der den Kontext bereinigt, wenn Sie die entsprechende Anmerkung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfügen</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DependencyInjectionTestExecutionListener</a> - Führt die Abhängigkeitsinjektion in Tests usw. durch.  Um Ihren benutzerdefinierten Listener auf den Test anzuwenden, müssen Sie die Annotation <code>@TestExecutionListeners</code> darüber setzen und Ihre Implementierung angeben. <br><br><h3>  Bestellt </h3><br>  Im Frühjahr gibt es auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geordnete</a> Schnittstelle.  Es wird verwendet, um anzugeben, dass Objekte auf irgendeine Weise sortiert werden sollen.  Wenn Sie beispielsweise mehrere Implementierungen derselben Schnittstelle haben und diese in eine Sammlung einfügen möchten, werden sie in dieser Sammlung gemäß der Reihenfolge sortiert.  Im Fall von TestExecutionListener gibt diese Anmerkung an, in welcher Reihenfolge sie angewendet werden sollen. <br><br>  Unser Listener implementiert also zwei Schnittstellen: <b>TestExecutionListener</b> und <b>Ordered</b> .  Wir nennen es <b>AutomockTestExecutionListener</b> und es wird so aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">AutomockTestExecutionListener.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutomockTestExecutionListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestExecutionListener</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordered</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1900</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareTestInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TestContext testContext)</span></span></span><span class="hljs-function"> </span></span>{ val beanFactory = ((DefaultListableBeanFactory) testContext.getApplicationContext().getAutowireCapableBeanFactory()); setByNameCandidateResolver(beanFactory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val field : testContext.getTestClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.getAnnotation(Automocked.class) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } log.debug(<span class="hljs-string"><span class="hljs-string">"Performing automocking for the field: {}"</span></span>, field.getName()); makeAccessible(field); setField( field, testContext.getTestInstance(), createBeanWithMocks(findConstructorToAutomock(field.getType()), beanFactory) ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setByNameCandidateResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DefaultListableBeanFactory beanFactory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((beanFactory.getAutowireCandidateResolver() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AutomockedBeanByNameAutowireCandidateResolver)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } beanFactory.setAutowireCandidateResolver( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutomockedBeanByNameAutowireCandidateResolver(beanFactory.getAutowireCandidateResolver()) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Constructor&lt;?&gt; findConstructorToAutomock(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Class&lt;?&gt; clazz) { log.debug(<span class="hljs-string"><span class="hljs-string">"Looking for suitable constructor of {}"</span></span>, clazz.getCanonicalName()); Constructor&lt;?&gt; fallBackConstructor = clazz.getDeclaredConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getDeclaredConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameterTypes().length &gt; fallBackConstructor.getParameterTypes().length) { fallBackConstructor = constructor; } val autowired = getAnnotation(constructor, Autowired.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (autowired != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fallBackConstructor; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBeanWithMocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor&lt;T&gt; constructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DefaultListableBeanFactory beanFactory)</span></span></span><span class="hljs-function"> </span></span>{ createMocksForParameters(constructor, beanFactory); val clazz = constructor.getDeclaringClass(); val beanName = forClass(clazz).toString(); log.debug(<span class="hljs-string"><span class="hljs-string">"Creating bean {}"</span></span>, beanName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { val bean = beanFactory.createBean(clazz); beanFactory.registerSingleton(beanName, bean); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanFactory.getBean(beanName, clazz); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMocksForParameters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor&lt;T&gt; constructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DefaultListableBeanFactory beanFactory)</span></span></span><span class="hljs-function"> </span></span>{ log.debug(<span class="hljs-string"><span class="hljs-string">"{} is going to be used for auto mocking"</span></span>, constructor); val constructorArgsAmount = constructor.getParameterTypes().length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorArgsAmount; i++) { val parameterType = forConstructorParameter(constructor, i); val beanName = parameterType.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { beanFactory.registerSingleton( beanName, mock(parameterType.resolve(), withSettings().stubOnly()) ); } log.debug(<span class="hljs-string"><span class="hljs-string">"Mocked {}"</span></span>, beanName); } } }</code> </pre> <br></div></div><br>  Was ist hier los?  Zunächst werden in der Methode <code>prepareTestInstance()</code> alle Felder mit der Annotation <code>@Automocked</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val field : testContext.getTestClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.getAnnotation(Automocked.class) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Dann werden diese Felder beschreibbar: <br><br><pre> <code class="java hljs">makeAccessible(field);</code> </pre> <br>  Dann findet es in der <code>findConstructorToAutomock()</code> -Methode den entsprechenden Konstruktor: <br><br><pre> <code class="java hljs">Constructor&lt;?&gt; fallBackConstructor = clazz.getDeclaredConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getDeclaredConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameterTypes().length &gt; fallBackConstructor.getParameterTypes().length) { fallBackConstructor = constructor; } val autowired = getAnnotation(constructor, Autowired.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (autowired != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fallBackConstructor;</code> </pre> <br>  Ein geeigneter Konstruktor ist in unserem Fall entweder der Konstruktor mit der Annotation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Autowired</a> oder der Konstruktor mit der größten Anzahl von Argumenten. <br><br>  Anschließend wird der gefundene Konstruktor als Argument an die Methode <code>createBeanWithMocks()</code> , die wiederum die Methode <code>createMocksForParameters()</code> , wobei die Mocks für die Konstruktorargumente erstellt und im Kontext registriert werden: <br><br><pre> <code class="java hljs">val constructorArgsAmount = constructor.getParameterTypes().length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorArgsAmount; i++) { val parameterType = forConstructorParameter(constructor, i); val beanName = parameterType.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { beanFactory.registerSingleton( beanName, mock(parameterType.resolve(), withSettings().stubOnly()) ); } }</code> </pre> <br>  Es ist wichtig zu beachten, dass eine Zeichenfolgendarstellung des Argumenttyps (zusammen mit Generika) als Name des Bin verwendet wird.  Das heißt, für ein Argument vom Typ <u><code>packages.Function&lt;String, String&gt;</code> Zeichenfolgendarstellung die Zeichenfolge <code>"packages.Function&lt;java.lang.String, java.lang.String&gt;"</code></u> .  Dies ist wichtig, wir werden darauf zurückkommen. <br><br>  Nachdem wir Mocks für alle Argumente erstellt und im Kontext registriert haben, kehren wir zum Erstellen der Bean der abhängigen Klasse (d. H. Des Controllers in unserem Fall) zurück: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { val bean = beanFactory.createBean(clazz); beanFactory.registerSingleton(beanName, bean); }</code> </pre> <br>  Sie sollten auch darauf achten, dass wir <u>Order 1900 verwendet haben</u> .  Dies liegt daran, dass unser Listener nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Löschen</a> des Ohm-Kontexts von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DirtiesContextBeforeModesTestExecutionListener</a> (order = 1500) und vor der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abhängigkeitsinjektion</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DependencyInjectionTestExecutionListener</a> (order = 2000) aufgerufen werden sollte, da unser Listener neue Bins erstellt. <br><br><h2>  AutowireCandidateResolver </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit AutowireCandidateResolver wird</a> ermittelt, ob die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BeanDefinition mit der</a> Abhängigkeitsbeschreibung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">übereinstimmt</a> .  Er hat mehrere Implementierungen "out of the box", darunter: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QualifierAnnotationAutowireCandidateResolver</a> - Bestimmt basierend auf Qualifier, ob die Abhängigkeit geeignet ist. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GenericTypeAwareAutowireCandidateResolver</a> - bestimmt basierend auf Generika, ob die Abhängigkeit geeignet ist; </li><li>  und andere. </li></ul><br>  Gleichzeitig ist die Implementierung "out of the box" eine russische Puppe aus der Vererbung, dh  sie erweitern sich gegenseitig.  Wir werden einen Dekorateur schreiben, weil  es ist flexibler. <br><br>  Der Resolver funktioniert wie folgt: <br><br><ol><li>  Spring verwendet einen Abhängigkeitsdeskriptor - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DependencyDescriptor</a> ; <br></li><li>  Dann werden alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BeanDefinitions</a> der entsprechenden Klasse benötigt. <br></li><li>  Iteriert über die empfangenen BeanDefinitions und ruft die <code>isAutowireCandidate()</code> -Methode des Resolvers auf. <br></li><li>  Je nachdem, ob die Beschreibung der Bean mit der Beschreibung der Abhängigkeit übereinstimmt oder nicht, gibt die Methode true oder false zurück. <br></li></ol><br><h2>  Warum brauchten Sie Ihren Resolver? </h2><br>  Lassen Sie uns nun am Beispiel unseres Controllers sehen, warum wir unseren Resolver brauchten. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HoroscopeTeller horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, ZodiacSign&gt; zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, String&gt; nameNormalizer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeTeller horoscopeTeller, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, ZodiacSign&gt; zodiacSignConverter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, String&gt; nameNormalizer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.horoscopeTeller = horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zodiacSignConverter = zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nameNormalizer = nameNormalizer; }</code> </pre> <br>  Wie Sie sehen können, gibt es zwei Abhängigkeiten des gleichen Typs - <b>Funktion</b> , jedoch mit unterschiedlichen Generika.  In einem Fall <b>String</b> und <b>ZodiacSign</b> , in dem anderen <b>String</b> und <b>String</b> .  Das Problem dabei ist, dass <u>Mockito unter Berücksichtigung von Generika keine Moks erstellen kann</u> .  Das heißt,  Wenn wir Mokas für diese Abhängigkeiten erstellen und sie in einen Kontext setzen, kann Spring sie nicht in diese Klasse einfügen, da sie keine Informationen zu Generika enthalten.  Und wir werden die Ausnahme sehen, dass es im Kontext mehr als eine Bean der <b>Funktionsklasse gibt</b> .  Genau dieses Problem werden wir mit Hilfe unseres Resolvers lösen.  Wie Sie sich erinnern, haben wir in unserer Implementierung von Listener einen Typ mit Generika als Namen des Fachs verwendet. Dies bedeutet, dass wir dem Frühling nur beibringen müssen, den Typ der Abhängigkeit mit dem Namen des Fachs zu vergleichen. <br><br><h2>  AutomockedBeanByNameAutowireCandidateResolver </h2><br>  Unser Resolver wird also genau das tun, was ich oben geschrieben habe, und die Implementierung der <code>isAutowireCandidate()</code> -Methode sieht folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">AutowireCandidateResolver.isAutowireCandidate ()</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAutowireCandidate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BeanDefinitionHolder beanDefinitionHolder, DependencyDescriptor descriptor)</span></span></span><span class="hljs-function"> </span></span>{ val dependencyType = descriptor.getResolvableType().resolve(); val dependencyTypeName = descriptor.getResolvableType().toString(); val candidateBeanDefinition = (AbstractBeanDefinition) beanDefinitionHolder.getBeanDefinition(); val candidateTypeName = beanDefinitionHolder.getBeanName(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidateTypeName.equals(dependencyTypeName) &amp;&amp; candidateBeanDefinition.getBeanClass() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidateResolver.isAutowireCandidate(beanDefinitionHolder, descriptor); }</code> </pre> <br></div></div><br>  Hier erhält er die Zeichenfolgendarstellung des Abhängigkeitstyps aus der Abhängigkeitsbeschreibung, erhält den Bean-Namen von BeanDefinition (die bereits die Zeichenfolgendarstellung des Bean-Typs enthält), vergleicht sie und gibt sie zurück, wenn sie übereinstimmen.  Wenn sie nicht übereinstimmen, wird sie an den internen Resolver delegiert. <br><br><h2>  Optionen zur Benetzung des Testbehälters </h2><br>  Insgesamt können wir in Tests die folgenden Optionen für die Behälterbenetzung verwenden: <br><br><ul><li>  Java Config - es wird zwingend, umständlich, mit einem Boilerplate, aber vielleicht so informativ wie möglich; <br></li><li>  <code>@MockBean</code> - ist deklarativ, weniger sperrig als Java Config, aber es gibt immer noch eine kleine Boilerplate in Form von Feldern mit Abhängigkeiten, die im Test selbst nicht verwendet werden. <br></li><li>  <code>@Automocked</code> + benutzerdefinierter Resolver - Mindestcode in Tests und Boilerplate, aber möglicherweise recht enger Umfang, und dieser muss noch geschrieben werden.  Es kann jedoch sehr praktisch sein, wenn Sie sicherstellen möchten, dass die Feder die Proxys korrekt erstellt. <br></li></ul><br><h2>  Dekorateure hinzufügen </h2><br>  Unser Team <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">liebt die Decorator-</a> Designvorlage wegen ihrer Flexibilität.  Tatsächlich implementieren Aspekte dieses spezielle Muster.  Wenn Sie jedoch den Spring-Kontext mit Anmerkungen konfigurieren und den Paketscan verwenden, tritt ein Problem auf.  Wenn Sie mehrere Implementierungen derselben Schnittstelle im Kontext haben, fällt beim <b>Start</b> der Anwendung eine <b>NoUniqueBeanDefinitionException aus</b> , d. H.  Der Frühling kann nicht herausfinden, welche der Bohnen injiziert werden sollen.  Dieses Problem hat mehrere Lösungen, und dann werden wir sie betrachten, aber zuerst wollen wir herausfinden, wie sich unsere Anwendung ändern wird. <br><br>  Jetzt haben die <b>FortuneTeller-</b> und <b>HoroscopeTeller-</b> Schnittstellen eine Implementierung. Wir werden für jede der Schnittstellen zwei weitere Implementierungen hinzufügen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1b/efb/01b/f1befb01b6356587cfe2c1728c7f2b0f.png"><br><br><ul><li>  Caching ... - Caching Dekorateur; <br></li><li>  Logging ... ist ein Logging-Dekorateur. <br></li></ul><br>  Wie lösen Sie das Problem der Bestimmung der Reihenfolge der Bohnen? <br><br><h2>  Java-Konfiguration mit Top Level Decorator </h2><br>  Sie können Java Config erneut verwenden.  In diesem Fall beschreiben wir die Beans als Methoden der Konfigurationsklasse und müssen die Argumente angeben, die erforderlich sind, um den Konstruktor der Bean als Argumente für die Methode aufzurufen.  Daraus folgt, dass wir im Falle einer Änderung im Konstruktor des Bin die Konfiguration ändern müssen, was nicht sehr cool ist.  Von den Vorteilen dieser Option: <br><br><ul><li>  es wird eine geringe Konnektivität zwischen Dekorateuren geben, wie  Die Verbindung zwischen ihnen wird in der Konfiguration beschrieben, d.h.  sie werden nichts voneinander wissen; <br></li><li>  Alle Änderungen in der Reihenfolge der Dekorateure werden an einem Ort lokalisiert - der Konfiguration. <br></li></ul><br>  In unserem Fall sieht Java Config folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">DomainConfig.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DomainConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FortuneTeller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fortuneTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Map&lt;FortuneRequest, FortuneResponse&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FortuneResponseRepository fortuneResponseRepository, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;FortuneRequest, PersonalData&gt; personalDataExtractor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PersonalDataRepository personalDataRepository )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggingFortuneTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachingFortuneTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Globa(fortuneResponseRepository, personalDataExtractor, personalDataRepository), cache ) ); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HoroscopeTeller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">horoscopeTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Map&lt;ZodiacSign, Horoscope&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeRepository horoscopeRepository )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggingHoroscopeTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachingHoroscopeTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gypsy(horoscopeRepository), cache ) ); } }</code> </pre> <br></div></div><br>  Wie Sie sehen können, wird hier für jede der Schnittstellen nur eine Bean deklariert, und die Methoden enthalten in den Argumenten die Abhängigkeiten aller darin erstellten Objekte.  In diesem Fall ist die Logik zum Erstellen von Beans ziemlich offensichtlich. <br><br><h2>  Qualifikation </h2><br>  Sie können die Annotation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Qualifier verwenden</a> .  Dies ist deklarativer als Java Config. In diesem Fall müssen Sie jedoch den Namen der Bean explizit angeben, von der die aktuelle Bean abhängt.  Was der Nachteil bedeutet: erhöhte Konnektivität zwischen Bins.  Und da die Konnektivität auch bei einer Änderung der Reihenfolge der Dekorateure zunimmt, werden die Änderungen gleichmäßig über den Code verschmiert.  Das heißt, wenn Sie beispielsweise in der Mitte der Kette einen neuen Dekorateur hinzufügen, wirken sich die Änderungen auf mindestens zwei Klassen aus. <br><br><div class="spoiler">  <b class="spoiler_title">LoggingFortuneTeller.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Primary</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggingFortuneTeller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FortuneTeller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FortuneTeller internal; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoggingFortuneTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @Qualifier(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cachingFortuneTeller"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> @NonNull </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> FortuneTeller internal ) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.internal = internal; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger = getLogger(internal.getClass()); }</code> </pre> <br></div></div><br>        , ,       (      ,  <b>FortuneTeller</b> ,   ),      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Primary</a> .     <b>internal</b>   <code>@Qualifier</code>    ,     — <b>cachingFortuneTeller</b> .         . <br><br><h2> Custom qualifier </h2><br>    2.5       Qualifier',    .     . <br><br>     enum   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DecoratorType { LOGGING, CACHING, NOT_DECORATOR }</code> </pre> <br>    ,    qualifier': <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Decorator { <span class="hljs-function"><span class="hljs-function">DecoratorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> NOT_DECORATOR</span></span>; }</code> </pre> <br>  :    ,       <code>@Qualifier</code> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CustomAutowireConfigurer</a> ,        . <br><br>         Qualifier'   : <br><br><div class="spoiler"> <b class="spoiler_title">CachingFortuneTeller.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Decorator</span></span>(CACHING) <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachingFortuneTeller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FortuneTeller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FortuneTeller internal; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;FortuneRequest, FortuneResponse&gt; cache; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CachingFortuneTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @Decorator(NOT_DECORATOR)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> FortuneTeller internal, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map&lt;FortuneRequest, FortuneResponse&gt; cache ) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.internal = internal; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = cache; }</code> </pre> <br></div></div><br>   –    ,      <code>@Decorator</code>   ,   ,     –      ,      <u> </u> ,     <b>FortuneTeller</b> ',    – <b>Globa</b> . <br><br>       Qualifier' - , - . ,          ,     . ,      -    –      ,     ,      . <br><br><h2> DecoratorAutowireCandidateResolver </h2><br>   –   !      ! :)   ,     -     ,   Java Config',        . ,   -    ,     .     : <br><br><div class="spoiler"> <b class="spoiler_title">DomainConfig.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DomainConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderConfig&lt;FortuneTeller&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fortuneTellerOrderConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () -&gt; asList( LoggingFortuneTeller.class, CachingFortuneTeller.class, Globa.class ); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderConfig&lt;HoroscopeTeller&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">horoscopeTellerOrderConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () -&gt; asList( LoggingHoroscopeTeller.class, CachingHoroscopeTeller.class, Gypsy.class ); } }</code> </pre> <br></div></div><br>     –    Java Config'       ,       – . ,     ! <br><br>     -   .   , ,    ,      .    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderConfig</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Class&lt;? extends T&gt;&gt; getClasses(); }</code> </pre> <br><h3> BeanDefinitionRegistryPostProcessor </h3><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BeanDefinitionRegistryPostProcessor</a> ,   BeanFactoryPostProcessor,   , ,  ,      BeanDefinition'.  ,      BeanFactoryPostProcessor,    . <br><br>    : <br><br><ul><li>   BeanDefinition'; <br></li><li>  BeanDefinition' ,   <b>OrderConfig</b> '.  , ..              BeanDefinition'   ; <br></li><li>   ,   <b>OrderConfig</b> ',  BeanDefinition',    ,     () . <br></li></ul><br><h3> BeanFactoryPostProcessor </h3><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BeanFactoryPostProcessor</a> ,      BeanDefinition'  ,    . ,      « Spring-». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/459/cac/4c5/459cac4c50791a09e9195d53fe51b9e0.png"><br><br> ,      , –       AutowireCandidateResolver': <br><br><div class="spoiler"> <b class="spoiler_title">DecoratorAutowireCandidateResolverConfigurer.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecoratorAutowireCandidateResolverConfigurer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactoryPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeanFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ConfigurableListableBeanFactory configurableListableBeanFactory)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> BeansException </span></span>{ Assert.state(configurableListableBeanFactory <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> DefaultListableBeanFactory, <span class="hljs-string"><span class="hljs-string">"BeanFactory needs to be a DefaultListableBeanFactory"</span></span>); val beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory; beanFactory.setAutowireCandidateResolver( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DecoratorAutowireCandidateResolver(beanFactory.getAutowireCandidateResolver()) ); } }</code> </pre> <br></div></div><br><br><h3> DecoratorAutowireCandidateResolver </h3><br>       : <br><div class="spoiler"> <b class="spoiler_title">DecoratorAutowireCandidateResolver.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecoratorAutowireCandidateResolver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutowireCandidateResolver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AutowireCandidateResolver resolver; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAutowireCandidate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BeanDefinitionHolder bdHolder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DependencyDescriptor descriptor)</span></span></span><span class="hljs-function"> </span></span>{ val dependentType = descriptor.getMember().getDeclaringClass(); val dependencyType = descriptor.getDependencyType(); val candidateBeanDefinition = (AbstractBeanDefinition) bdHolder.getBeanDefinition(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependencyType.isAssignableFrom(dependentType)) { val candidateQualifier = candidateBeanDefinition.getQualifier(OrderQualifier.class.getTypeName()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidateQualifier != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependentType.getTypeName().equals(candidateQualifier.getAttribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolver.isAutowireCandidate(bdHolder, descriptor); }</code> </pre> <br></div></div><br>    descriptor'   (dependencyType)     (dependentType): <br><br><pre> <code class="java hljs">val dependentType = descriptor.getMember().getDeclaringClass(); val dependencyType = descriptor.getDependencyType();</code> </pre> <br>    bdHolder' BeanDefinition: <br><br><pre> <code class="java hljs">val candidateBeanDefinition = (AbstractBeanDefinition) bdHolder.getBeanDefinition();</code> </pre> <br>       .    ,     : <br><br><pre> <code class="java hljs">dependencyType.isAssignableFrom(dependentType)</code> </pre> <br>    ,      , ..      . <br><br>   BeanDefinition'       : <br><br><pre> <code class="java hljs">val candidateQualifier = candidateBeanDefinition.getQualifier(OrderQualifier.class.getTypeName());</code> </pre> <br>    ,         : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidateQualifier != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependentType.getTypeName().equals(candidateQualifier.getAttribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>)); }</code> </pre> <br>    –     (),   –  false. <br><br><h3>    </h3><br><ul><li> ,           <a href="">ConfigurationClassBeanDefinitionReader</a> '; <br></li><li>              ,   BeanDefintion'    Qualifier'.                 ,      . <br></li></ul><br><h2>     </h2><br> ,          : <br><br><ul><li> Java Config –   ,  ,      ,        ; <br></li><li> <code>@Qualifier</code> –  ,      -       ; <br></li><li> Custom qualifier –   ,     Qualifier',   ; <br></li><li>     - – ,  ,     ,     . <br></li></ul><br><h2>  </h2><br>  ,          ,     .           – :   .    ,               , ,  .    –   ,            JRE.     ,      ,   . <br><br>   ,      –  ,   ,        - .  Danke fürs Lesen! <br><br>     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/monosoul/spring-di-customization</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435364/">https://habr.com/ru/post/de435364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435352/index.html">DEFCON-Konferenz 18. Praktische Spionage mit einem Mobiltelefon. Teil 2</a></li>
<li><a href="../de435354/index.html">DEFCON-Konferenz 18. Praktische Spionage mit einem Mobiltelefon. Teil 1</a></li>
<li><a href="../de435358/index.html">Antiquitäten: Minidisk im Zeitalter des iPod</a></li>
<li><a href="../de435360/index.html">Snippets vs Clover - Schließe das beliebteste Echtzeit-Quiz ab</a></li>
<li><a href="../de435362/index.html">Geschwindigkeits-Hash</a></li>
<li><a href="../de435368/index.html">Pathologische Anatomie am Arbeitsplatz</a></li>
<li><a href="../de435372/index.html">Ein paar Worte zu FastPath und FastTrack bei MikroTik</a></li>
<li><a href="../de435374/index.html">Mathe in Gamedev ist einfach. Triangulation und Triangle.Net in Unity</a></li>
<li><a href="../de435376/index.html">Weltraum 2019: bemannte Schiffe, neue Raketen und Mondsonden</a></li>
<li><a href="../de435380/index.html">Kostenlose Konten auf GitHub können [fast] ohne Einschränkungen mit privaten Repositories arbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>