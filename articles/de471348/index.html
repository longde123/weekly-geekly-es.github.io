<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏻 👩🏽 🙅🏼 Full-Stack-TypeScript-Apps 👨🏼‍🤝‍👨🏻 😪 🌡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Full-Stack TypeScript Apps - Teil 1: Entwickeln von Backend-APIs mit Nest.js" von Ana ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Full-Stack-TypeScript-Apps</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Full-Stack TypeScript Apps - Teil 1: Entwickeln von Backend-APIs mit Nest.js"</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Teil 1: Entwickeln der Server-API mit Nest.JS </h2><br><p>  TL; DR: Dies ist eine Reihe von Artikeln zum Erstellen einer TypeScript-Webanwendung mit Angular und Nest.JS.  Im ersten Teil werden wir eine einfache Server-API mit Nest.JS schreiben.  Der zweite Teil dieser Serie ist der Front-End-Anwendung mit Angular gewidmet.  Den endgültigen Code, der in diesem Artikel entwickelt wurde, finden Sie in diesem <a href="">GitHub-Repository.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  Was ist Nest.Js und warum Angular? </h3><br><p>  Nest.js ist ein Framework zum Erstellen von Node.js Webserveranwendungen. </p><br><p>  Eine Besonderheit ist, dass es ein Problem löst, das kein anderes Framework löst: die Struktur des node.js-Projekts. <a name="habracut"></a>  Wenn Sie jemals unter node.js entwickelt haben, wissen Sie, dass Sie mit einem Modul viel erreichen können (z. B. kann Express Middleware alles von der Authentifizierung bis zur Validierung erledigen), was letztendlich zu einem nicht unterstützten "Durcheinander" führen kann. .  Wie Sie unten sehen werden, hilft uns nest.js dabei, indem es Klassen bereitstellt, die sich auf verschiedene Themen spezialisiert haben. </p><br><p>  Nest.js ist stark von Angular inspiriert.  Zum Beispiel <cut></cut>  Beide Plattformen verwenden Schutzvorrichtungen, um den Zugriff auf einige Teile Ihrer Anwendungen zu ermöglichen oder zu verhindern, und beide Plattformen bieten eine CanActivate-Schnittstelle zum Implementieren dieser Schutzfunktionen.  Es ist jedoch wichtig zu beachten, dass trotz einiger ähnlicher Konzepte beide Strukturen unabhängig voneinander sind.  Das heißt, in diesem Artikel erstellen wir eine unabhängige API für unser Front-End, die mit jedem anderen Framework (React, Vue.JS usw.) verwendet werden kann. </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Webanwendung für Online-Bestellungen </h3><br><p>  In diesem Handbuch erstellen wir eine einfache Anwendung, in der Benutzer Bestellungen in einem Restaurant aufgeben können.  Diese Logik wird implementiert: </p><br><ul><li>  Jeder Benutzer kann das Menü anzeigen. </li><li>  Nur ein autorisierter Benutzer kann Waren in den Warenkorb legen (Bestellung aufgeben). </li><li>  Nur der Administrator kann neue Menüelemente hinzufügen. </li></ul><br><p>  Der Einfachheit halber werden wir nicht mit einer externen Datenbank interagieren und die Funktionalität unseres Warenkorbs nicht implementieren. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Erstellen der Dateistruktur des Nest.js-Projekts </h3><br><p>  Um Nest.js zu installieren, müssen wir Node.js (v.8.9.x oder höher) und NPM installieren.  Laden Sie Node.js für Ihr Betriebssystem von der offiziellen Website herunter und installieren Sie es (NPM ist enthalten).  Wenn alles installiert ist, überprüfen Sie die Versionen: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Es gibt verschiedene Möglichkeiten, ein Projekt mit Nest.js zu erstellen.  Sie finden sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Wir werden <code>nest-cli</code> .  Installieren Sie es: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  Als nächstes erstellen Sie unser Projekt mit einem einfachen Befehl: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  Dabei werden wir von nest aufgefordert, einen Paketmanager auszuwählen: <code>npm</code> oder <code>yarn</code> </p><br><p>  Wenn alles gut gegangen ist, erstellt <code>nest</code> die folgende Dateistruktur: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── .gitignore ├── .prettierrc ├── nest-cli.json ├── package.json ├── package-lock.json ├── README.md ├── tsconfig.build.json ├── tsconfig.json └── tslint.json</code> </pre> <br><p>  Wechseln Sie in das erstellte Verzeichnis und starten Sie den Entwicklungsserver: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Öffnen Sie einen Browser und geben Sie <code>http://localhost:3000</code> .  Auf dem Bildschirm sehen wir: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Im Rahmen dieses Tutorials werden wir unsere API nicht testen (obwohl Sie Tests für jede gebrauchsfertige Anwendung schreiben sollten).  Auf diese Weise können Sie das <code>src/app.controller.spec.ts</code> löschen und die <code>src/app.controller.spec.ts</code> (die Testdatei) löschen.  Daher enthält unser Quellordner die folgenden Dateien: </p><br><ul><li>  <code>src/app.controller.ts</code> und <code>src/app.module.ts</code> : Diese Dateien sind für die Erstellung der <code>Hello world</code> Nachricht entlang der <code>/</code> route verantwortlich.  Weil  Dieser Einstiegspunkt ist für diese Anwendung nicht wichtig. Wir löschen sie.  In Kürze werden Sie detaillierter erfahren, was <strong>Controller</strong> und <strong>Services sind</strong> . </li><li>  <code>src/app.module.ts</code> : enthält eine Beschreibung einer Klasse von <code>src/app.module.ts</code> , die für die Deklaration des Imports, Exports von Controllern und Anbietern in die Anwendung nest.js verantwortlich ist.  Jede Anwendung verfügt über mindestens ein Modul. Sie können jedoch mehr als ein Modul für komplexere Anwendungen erstellen (mehr in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . Unsere Anwendung enthält nur ein Modul </li><li>  <code>src/main.ts</code> : Dies ist die Datei, die für den Start des Servers verantwortlich ist. </li></ul><br><blockquote><cut text=""></cut>  Hinweis: Nach dem Entfernen von <code>src/app.controller.ts</code> und <code>src/app.module.ts</code> Sie unsere Anwendung nicht starten.  Keine Sorge, wir werden es bald beheben. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Einstiegspunkte erstellen (Endpunkte) </h3><br><br><p>  Unsere API wird auf der Route <code>/items</code> verfügbar sein.  Über diesen Einstiegspunkt können Benutzer Daten empfangen und Administratoren verwalten das Menü.  Lass es uns schaffen. </p><br><p>  Erstellen Sie dazu ein Verzeichnis mit dem Namen <code>items</code> in <code>src</code> .  Alle Dateien, die der Route <code>/items</code> sind, werden in diesem neuen Verzeichnis gespeichert. </p><br><h4 id="sozdanie-kontrollerov">  Controller erstellen </h4><br><p>  In <code>nest.js</code> sind Controller wie in vielen anderen Frameworks für die Zuordnung von Routen mit Funktionen verantwortlich.  <code>nest.js</code> zum Erstellen eines Controllers in <code>nest.js</code> den <code>nest.js</code> Dekorator wie folgt: <code>@Controller(${ENDPOINT})</code> .  Um verschiedene <code>HTTP</code> Methoden wie <code>GET</code> und <code>POST</code> <code>@Get</code> , werden <code>@Post</code> Dekoratoren <code>@Get</code> , <code>@Post</code> , <code>@Delete</code> usw. verwendet. </p><br><p>  In unserem Fall müssen wir einen Controller erstellen, der die im Restaurant verfügbaren Gerichte zurückgibt und mit dem Administratoren den Inhalt des Menüs verwalten.  Erstellen wir eine Datei mit dem Namen <code>items.controller.tc</code> im Verzeichnis <code>src/items</code> mit den folgenden Inhalten: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  Um unseren neuen Controller in unserer Anwendung verfügbar zu machen, registrieren Sie ihn im Modul: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Starten Sie unsere Anwendung: <code>npm run start:dev</code> und öffnen Sie sie im Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 3000 / items</a> . Wenn Sie alles richtig gemacht haben, sollten wir die Antwort auf unsere Get-Anfrage sehen: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Anmerkung des <code>nest.js</code> : <code>nest.js</code> neue Controller sowie andere Elemente von <code>nest.js</code> : Dienste, Anbieter usw., ist es bequemer, den Befehl <code>nest generate</code> aus dem <code>nest-cli</code> .</em>  <em>Um beispielsweise den oben beschriebenen Controller zu erstellen, können Sie den Befehl <code>nest generate controller items</code> Infolgedessen erstellt <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> und <code>src/items/items.controller.tc</code> folgenden Inhalten:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>und registrieren Sie es in <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Hinzufügen eines Dienstes </h4><br><p>  Beim Zugriff auf <code>/items</code> unsere Anwendung jetzt für jede Anforderung dasselbe Array zurück, das wir nicht ändern können.  Das Verarbeiten und Speichern von Daten ist nicht Sache des Controllers. Zu diesem Zweck sind Dienste in nest.js vorgesehen <br>  Dienste im Nest sind <code>@Injectable</code> <br>  Der Name des Dekorateurs spricht für sich selbst. Durch Hinzufügen dieses Dekorators zur Klasse kann er in andere Komponenten wie z. B. Controller injiziert werden. <br>  Lassen Sie uns unseren Service erstellen.  Erstellen Sie die Datei <code>items.service.ts</code> Ordner <code>items.service.ts</code> mit den folgenden Inhalten: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  und ändern Sie den <code>ItemsController</code> Controller (deklariert in <code>items.controller.ts</code> ), um unseren Service zu nutzen: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  In der neuen Version des Controllers haben wir den <code>@Body</code> Dekorator auf das Argument <code>create</code> method angewendet.  Dieses Argument wird verwendet, um die über <code>req.body ['item']</code> Daten automatisch mit dem Argument selbst (in diesem Fall <code>item</code> ) <code>req.body ['item']</code> . <br>  Außerdem empfängt unser Controller eine Instanz der <code>ItemsService</code> Klasse, die über den Konstruktor <code>ItemsService</code> wird.  Wenn Sie <code>ItemsService</code> als <code>private readonly</code> wird eine Instanz unveränderlich und nur innerhalb der Klasse sichtbar. <br>  Und vergessen Sie nicht, unseren Service in <code>app.module.ts</code> zu registrieren: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Senden Sie nach allen Änderungen eine HTTP-POST-Anfrage an das Menü: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Anschließend überprüfen wir, ob neue Gerichte auf unserer Speisekarte erscheinen, indem wir eine GET-Anfrage stellen (oder indem wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 3000 / items</a> in einem Browser öffnen). </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Erstellen einer Warenkorbroute </h4><br><p>  Nachdem wir die erste Version des Einstiegspunkts <code>/items</code> unserer API haben, implementieren wir die Warenkorbfunktion.  Der Prozess zum Erstellen dieser Funktionalität unterscheidet sich nicht wesentlich von der bereits erstellten API.  Um das Handbuch nicht zu überladen, erstellen wir eine Komponente, die beim Zugriff mit dem Status OK antwortet. </p><br><p>  Erstellen Sie zunächst im <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Registrieren Sie diesen Controller in unserem Modul ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Führen Sie den folgenden Befehl aus, um diesen Einstiegspunkt zu überprüfen, nachdem Sie sichergestellt haben, dass die Anwendung ausgeführt wird: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Hinzufügen eines Schnittstellentypskripts für Elemente </h4><br><p>  Zurück zu unserem <code>items</code> .  Jetzt speichern wir nur den Namen des Gerichts, aber dies ist eindeutig nicht genug, und wir werden sicher mehr Informationen haben wollen (zum Beispiel die Kosten des Gerichts).  Ich denke, Sie werden zustimmen, dass das Speichern dieser Daten als Array von Zeichenfolgen keine gute Idee ist? <br>  Um dieses Problem zu lösen, können wir ein Array von Objekten erstellen.  Aber wie kann man die Struktur von Objekten speichern?  Hier hilft uns die TypeScript-Oberfläche, in der wir die Struktur des <code>items</code> Objekts definieren.  Erstellen Sie eine neue Datei mit dem Namen <code>item.interface.ts</code> im Ordner <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  <code>items.service.ts</code> Datei <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  Und auch in <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validierung der Eingabe in Nest.js </h4><br><p>  Trotz der Tatsache, dass wir die Struktur des <code>item</code> , gibt unsere Anwendung keinen Fehler zurück, wenn wir eine ungültige POST-Anforderung senden (alle Arten von Daten, die nicht in der Schnittstelle definiert sind).  Zum Beispiel für eine solche Anfrage: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Der Server sollte mit einem Status von 400 (fehlerhafte Anfrage) antworten. Stattdessen antwortet unsere Anwendung mit einem Status von 200 (OK). </p><br><p>  Um dieses Problem zu lösen, erstellen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DTO (Data Transfer Object)</a> und eine Pipe-Komponente (Channel). </p><br><p>  DTO ist ein Objekt, das definiert, wie Daten zwischen Prozessen übertragen werden sollen.  Wir beschreiben das DTO in der <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Pipes in <code>Nest.js</code> sind die Komponenten, die für die Validierung verwendet werden.  Erstellen Sie für unsere API einen Kanal, in dem überprüft wird, ob die an die Methode gesendeten Daten mit dem DTO übereinstimmen.  Ein Kanal kann von verschiedenen Controllern verwendet werden. Erstellen Sie daher das Verzeichnis <code>src/common/</code> mit der Datei <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Hinweis: Wir müssen zwei Module installieren: <code>class-validator</code> und <code>class-transformer</code> .  Führen Sie dazu <code>npm install class-validator class-transformer</code> in der Konsole aus und starten Sie den Server neu. </blockquote><p>  Anpassen von <code>items.controller.ts</code> für die Verwendung mit unserer neuen Pipe und DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Lassen Sie uns unseren Code noch einmal überprüfen. Jetzt akzeptiert der Eintrag <code>/items</code> nur dann Daten, wenn sie im DTO definiert sind.  Zum Beispiel: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Fügen Sie ungültige Daten ein (Daten, die in <code>ValidationPipe</code> nicht überprüft werden können). Als Ergebnis erhalten wir die Antwort: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Middleware erstellen </h5><br><p>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Auth0-Schnellstartanleitung</a> wird empfohlen, das von Auth0 ausgegebene JWT-Token zu überprüfen, indem Sie die von <code>express-jwt</code> bereitgestellte <code>express-jwt</code> .  Diese Middleware automatisiert einen großen Teil der Arbeit. </p><br><p>  Erstellen wir eine <code>authentication.middleware.ts</code> Datei im Verzeichnis <code>src / common</code> mit dem folgenden Code: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Ersetzen Sie <code>${DOMAIN}</code> durch den <em>Domänenwert</em> aus den Auth0-Anwendungseinstellungen </p><br><blockquote>  Anmerkung des Übersetzers: <code>DOMAIN</code> Sie in einer realen Anwendung <code>DOMAIN</code> in eine Konstante und legen Sie den Wert über <code>env</code> (virtuelle Umgebung) fest. </blockquote><p>  Installieren Sie die <code>jwks-rsa</code> <code>express-jwt</code> und <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  Es ist notwendig, die erstellte Middleware (Handler) mit unserer Anwendung zu verbinden.  Dazu in der Datei <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  Der obige Code besagt, dass POST-Anforderungen an die Routen <code>/items</code> und <code>/shopping-cart</code> durch <em>Express-Middleware</em> geschützt sind, die in der Anforderung nach dem Zugriffstoken sucht. </p><br><p>  Starten Sie den Entwicklungsserver neu ( <code>npm run start:dev</code> ) und rufen Sie die Nest.js-API auf: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Rollenverwaltung mit Auth0 </h5><br><p>  Derzeit kann jeder Benutzer mit einem verifizierten Token Elemente in unserer API veröffentlichen.  Wir möchten jedoch, dass dies nur Benutzer mit Administratorrechten tun können.  Um diese Funktion zu implementieren, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln (Regeln) Auth0</a> . </p><br><p>  Wechseln Sie also zur Systemsteuerung Auth0 im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt <em>Regeln</em></a> .  Klicken Sie dort auf die <code>+ CREATE RULE</code> und wählen Sie als Regelmodell "Rollen für einen Benutzer <code>+ CREATE RULE</code> ". </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Anschließend erhalten wir eine JavaScript-Datei mit einer Regelvorlage, die jedem Benutzer, der E-Mails hat, die zu einer bestimmten Domäne gehören, die Administratorrolle hinzufügt.  Lassen Sie uns einige Details in dieser Vorlage ändern, um ein Funktionsbeispiel zu erhalten.  Für unsere Anwendung gewähren wir dem Administrator nur Zugriff auf unsere eigene E-Mail-Adresse.  Wir müssen auch den Speicherort für die Speicherung von Administratorstatusinformationen ändern. </p><br><p>  Derzeit werden diese Informationen in einem Identifikationstoken gespeichert (das zum Bereitstellen von Informationen über den Benutzer verwendet wird). Für den Zugriff auf Ressourcen in der API sollte jedoch ein Zugriffstoken verwendet werden.  Der Code nach den Änderungen sollte folgendermaßen aussehen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Hinweis: Ersetzen Sie <code>${YOUR_EMAIL}</code> durch Ihre E-Mail-Adresse.  Es ist wichtig zu beachten, dass es in der Regel ideal ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die E-Mail-Überprüfung</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erzwingen</a> , wenn Sie mit E-Mails in den Auth0-Regeln arbeiten.  In diesem Fall ist dies nicht erforderlich, da wir unsere eigene E-Mail-Adresse verwenden. <br><br>  Anmerkung des Übersetzers: Das obige Codefragment wird im Browser auf der Konfigurationsseite der Auth0-Regel eingegeben </blockquote><p>  Um zu überprüfen, ob das an unsere API übergebene Token das Administrator-Token ist, müssen wir einen <em>Schutz</em> Nest.js erstellen.  Erstellen Sie im Ordner <code>src/common</code> die Datei <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Wenn wir nun den oben beschriebenen Anmeldevorgang wiederholen und die in der Regel definierte E-Mail-Adresse verwenden, erhalten wir ein neues <code>access_token</code> .  Um den Inhalt dieses <code>access_token</code> zu überprüfen, kopieren Sie das Token und fügen Sie es in das Feld <code>Encoded</code> der Site <code>https://jwt.io/</code> .  Wir werden sehen, dass der Payload-Abschnitt dieses Tokens das folgende Array enthält: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Wenn unser Token diese Informationen wirklich enthält, setzen wir die Integration mit Auth0 fort.  Öffnen Sie also <code>items.controller.ts</code> und fügen Sie dort unseren neuen Wächter hinzu: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Mit unserem neuen Token können wir jetzt neue Elemente über unsere API hinzufügen: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Anmerkung des Übersetzers: Zur Überprüfung können Sie sehen, was wir in den Artikeln haben: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Zusammenfassung </h4><br><p>  Glückwunsch!  Wir haben gerade die Erstellung unserer Nest.JS-API abgeschlossen und können uns nun auf die Entwicklung des Frontend-Teils unserer Anwendung konzentrieren!  Lesen Sie unbedingt den zweiten Teil dieser Serie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Full-Stack TypeScript-Apps - Teil 2: Entwickeln von Frontend Angular Apps.</a> </p><br><blockquote>  Anmerkung des Übersetzers: Die Übersetzung des zweiten Teils des Prozesses </blockquote><p>  Zusammenfassend haben wir in diesem Artikel verschiedene Funktionen von Nest.js und TypeScript verwendet: Module, Controller, Dienste, Schnittstellen, Pipes, Middleware und Guard zum Erstellen API  Ich hoffe, Sie haben gute Erfahrungen gemacht und sind bereit, unsere Anwendung weiterzuentwickeln.  Wenn Ihnen etwas nicht klar ist, ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation zu nest.j</a> eine gute Quelle mit Antworten </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471348/">https://habr.com/ru/post/de471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471336/index.html">Holivar. Geschichte von Runet. Teil 6. Schlösser: Lurk, Tape, 282. und chinesischer Pfad</a></li>
<li><a href="../de471340/index.html">Drimsim gegen Mate 20 Pro Round! Aber für wen?</a></li>
<li><a href="../de471342/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471344/index.html">Noch einmal über ImmutableList in Java</a></li>
<li><a href="../de471346/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 384 (7. - 13. Oktober 2019)</a></li>
<li><a href="../de471350/index.html">Reverse Engineering von rauscharmen Operationsverstärkern von einem analogen Computer im Jahr 1969</a></li>
<li><a href="../de471352/index.html">Präsentationen in LaTeX schreiben</a></li>
<li><a href="../de471358/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python über Ontologie? Teil 4: Native API</a></li>
<li><a href="../de471360/index.html">Vervielfältigungsmethode. 11 Beispiele aus dem Design von ICE</a></li>
<li><a href="../de471364/index.html">Automatisiertes Testmanagement mit Telegramm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>