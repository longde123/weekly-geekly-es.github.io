<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèª üë©üèΩ üôÖüèº Full-Stack-TypeScript-Apps üë®üèº‚Äçü§ù‚Äçüë®üèª üò™ üå°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Full-Stack TypeScript Apps - Teil 1: Entwickeln von Backend-APIs mit Nest.js" von Ana ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Full-Stack-TypeScript-Apps</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Full-Stack TypeScript Apps - Teil 1: Entwickeln von Backend-APIs mit Nest.js"</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Teil 1: Entwickeln der Server-API mit Nest.JS </h2><br><p>  TL; DR: Dies ist eine Reihe von Artikeln zum Erstellen einer TypeScript-Webanwendung mit Angular und Nest.JS.  Im ersten Teil werden wir eine einfache Server-API mit Nest.JS schreiben.  Der zweite Teil dieser Serie ist der Front-End-Anwendung mit Angular gewidmet.  Den endg√ºltigen Code, der in diesem Artikel entwickelt wurde, finden Sie in diesem <a href="">GitHub-Repository.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  Was ist Nest.Js und warum Angular? </h3><br><p>  Nest.js ist ein Framework zum Erstellen von Node.js Webserveranwendungen. </p><br><p>  Eine Besonderheit ist, dass es ein Problem l√∂st, das kein anderes Framework l√∂st: die Struktur des node.js-Projekts. <a name="habracut"></a>  Wenn Sie jemals unter node.js entwickelt haben, wissen Sie, dass Sie mit einem Modul viel erreichen k√∂nnen (z. B. kann Express Middleware alles von der Authentifizierung bis zur Validierung erledigen), was letztendlich zu einem nicht unterst√ºtzten "Durcheinander" f√ºhren kann. .  Wie Sie unten sehen werden, hilft uns nest.js dabei, indem es Klassen bereitstellt, die sich auf verschiedene Themen spezialisiert haben. </p><br><p>  Nest.js ist stark von Angular inspiriert.  Zum Beispiel <cut></cut>  Beide Plattformen verwenden Schutzvorrichtungen, um den Zugriff auf einige Teile Ihrer Anwendungen zu erm√∂glichen oder zu verhindern, und beide Plattformen bieten eine CanActivate-Schnittstelle zum Implementieren dieser Schutzfunktionen.  Es ist jedoch wichtig zu beachten, dass trotz einiger √§hnlicher Konzepte beide Strukturen unabh√§ngig voneinander sind.  Das hei√üt, in diesem Artikel erstellen wir eine unabh√§ngige API f√ºr unser Front-End, die mit jedem anderen Framework (React, Vue.JS usw.) verwendet werden kann. </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Webanwendung f√ºr Online-Bestellungen </h3><br><p>  In diesem Handbuch erstellen wir eine einfache Anwendung, in der Benutzer Bestellungen in einem Restaurant aufgeben k√∂nnen.  Diese Logik wird implementiert: </p><br><ul><li>  Jeder Benutzer kann das Men√º anzeigen. </li><li>  Nur ein autorisierter Benutzer kann Waren in den Warenkorb legen (Bestellung aufgeben). </li><li>  Nur der Administrator kann neue Men√ºelemente hinzuf√ºgen. </li></ul><br><p>  Der Einfachheit halber werden wir nicht mit einer externen Datenbank interagieren und die Funktionalit√§t unseres Warenkorbs nicht implementieren. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Erstellen der Dateistruktur des Nest.js-Projekts </h3><br><p>  Um Nest.js zu installieren, m√ºssen wir Node.js (v.8.9.x oder h√∂her) und NPM installieren.  Laden Sie Node.js f√ºr Ihr Betriebssystem von der offiziellen Website herunter und installieren Sie es (NPM ist enthalten).  Wenn alles installiert ist, √ºberpr√ºfen Sie die Versionen: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Es gibt verschiedene M√∂glichkeiten, ein Projekt mit Nest.js zu erstellen.  Sie finden sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Wir werden <code>nest-cli</code> .  Installieren Sie es: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  Als n√§chstes erstellen Sie unser Projekt mit einem einfachen Befehl: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  Dabei werden wir von nest aufgefordert, einen Paketmanager auszuw√§hlen: <code>npm</code> oder <code>yarn</code> </p><br><p>  Wenn alles gut gegangen ist, erstellt <code>nest</code> die folgende Dateistruktur: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ‚îú‚îÄ‚îÄ src ‚îÇ ‚îú‚îÄ‚îÄ app.controller.spec.ts ‚îÇ ‚îú‚îÄ‚îÄ app.controller.ts ‚îÇ ‚îú‚îÄ‚îÄ app.module.ts ‚îÇ ‚îú‚îÄ‚îÄ app.service.ts ‚îÇ ‚îî‚îÄ‚îÄ main.ts ‚îú‚îÄ‚îÄ test ‚îÇ ‚îú‚îÄ‚îÄ app.e2e-spec.ts ‚îÇ ‚îî‚îÄ‚îÄ jest-e2e.json ‚îú‚îÄ‚îÄ .gitignore ‚îú‚îÄ‚îÄ .prettierrc ‚îú‚îÄ‚îÄ nest-cli.json ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ package-lock.json ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ tsconfig.build.json ‚îú‚îÄ‚îÄ tsconfig.json ‚îî‚îÄ‚îÄ tslint.json</code> </pre> <br><p>  Wechseln Sie in das erstellte Verzeichnis und starten Sie den Entwicklungsserver: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  √ñffnen Sie einen Browser und geben Sie <code>http://localhost:3000</code> .  Auf dem Bildschirm sehen wir: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Im Rahmen dieses Tutorials werden wir unsere API nicht testen (obwohl Sie Tests f√ºr jede gebrauchsfertige Anwendung schreiben sollten).  Auf diese Weise k√∂nnen Sie das <code>src/app.controller.spec.ts</code> l√∂schen und die <code>src/app.controller.spec.ts</code> (die Testdatei) l√∂schen.  Daher enth√§lt unser Quellordner die folgenden Dateien: </p><br><ul><li>  <code>src/app.controller.ts</code> und <code>src/app.module.ts</code> : Diese Dateien sind f√ºr die Erstellung der <code>Hello world</code> Nachricht entlang der <code>/</code> route verantwortlich.  Weil  Dieser Einstiegspunkt ist f√ºr diese Anwendung nicht wichtig. Wir l√∂schen sie.  In K√ºrze werden Sie detaillierter erfahren, was <strong>Controller</strong> und <strong>Services sind</strong> . </li><li>  <code>src/app.module.ts</code> : enth√§lt eine Beschreibung einer Klasse von <code>src/app.module.ts</code> , die f√ºr die Deklaration des Imports, Exports von Controllern und Anbietern in die Anwendung nest.js verantwortlich ist.  Jede Anwendung verf√ºgt √ºber mindestens ein Modul. Sie k√∂nnen jedoch mehr als ein Modul f√ºr komplexere Anwendungen erstellen (mehr in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . Unsere Anwendung enth√§lt nur ein Modul </li><li>  <code>src/main.ts</code> : Dies ist die Datei, die f√ºr den Start des Servers verantwortlich ist. </li></ul><br><blockquote><cut text=""></cut>  Hinweis: Nach dem Entfernen von <code>src/app.controller.ts</code> und <code>src/app.module.ts</code> Sie unsere Anwendung nicht starten.  Keine Sorge, wir werden es bald beheben. </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Einstiegspunkte erstellen (Endpunkte) </h3><br><br><p>  Unsere API wird auf der Route <code>/items</code> verf√ºgbar sein.  √úber diesen Einstiegspunkt k√∂nnen Benutzer Daten empfangen und Administratoren verwalten das Men√º.  Lass es uns schaffen. </p><br><p>  Erstellen Sie dazu ein Verzeichnis mit dem Namen <code>items</code> in <code>src</code> .  Alle Dateien, die der Route <code>/items</code> sind, werden in diesem neuen Verzeichnis gespeichert. </p><br><h4 id="sozdanie-kontrollerov">  Controller erstellen </h4><br><p>  In <code>nest.js</code> sind Controller wie in vielen anderen Frameworks f√ºr die Zuordnung von Routen mit Funktionen verantwortlich.  <code>nest.js</code> zum Erstellen eines Controllers in <code>nest.js</code> den <code>nest.js</code> Dekorator wie folgt: <code>@Controller(${ENDPOINT})</code> .  Um verschiedene <code>HTTP</code> Methoden wie <code>GET</code> und <code>POST</code> <code>@Get</code> , werden <code>@Post</code> Dekoratoren <code>@Get</code> , <code>@Post</code> , <code>@Delete</code> usw. verwendet. </p><br><p>  In unserem Fall m√ºssen wir einen Controller erstellen, der die im Restaurant verf√ºgbaren Gerichte zur√ºckgibt und mit dem Administratoren den Inhalt des Men√ºs verwalten.  Erstellen wir eine Datei mit dem Namen <code>items.controller.tc</code> im Verzeichnis <code>src/items</code> mit den folgenden Inhalten: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  Um unseren neuen Controller in unserer Anwendung verf√ºgbar zu machen, registrieren Sie ihn im Modul: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Starten Sie unsere Anwendung: <code>npm run start:dev</code> und √∂ffnen Sie sie im Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 3000 / items</a> . Wenn Sie alles richtig gemacht haben, sollten wir die Antwort auf unsere Get-Anfrage sehen: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Anmerkung des <code>nest.js</code> : <code>nest.js</code> neue Controller sowie andere Elemente von <code>nest.js</code> : Dienste, Anbieter usw., ist es bequemer, den Befehl <code>nest generate</code> aus dem <code>nest-cli</code> .</em>  <em>Um beispielsweise den oben beschriebenen Controller zu erstellen, k√∂nnen Sie den Befehl <code>nest generate controller items</code> Infolgedessen erstellt <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> und <code>src/items/items.controller.tc</code> folgenden Inhalten:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>und registrieren Sie es in <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Hinzuf√ºgen eines Dienstes </h4><br><p>  Beim Zugriff auf <code>/items</code> unsere Anwendung jetzt f√ºr jede Anforderung dasselbe Array zur√ºck, das wir nicht √§ndern k√∂nnen.  Das Verarbeiten und Speichern von Daten ist nicht Sache des Controllers. Zu diesem Zweck sind Dienste in nest.js vorgesehen <br>  Dienste im Nest sind <code>@Injectable</code> <br>  Der Name des Dekorateurs spricht f√ºr sich selbst. Durch Hinzuf√ºgen dieses Dekorators zur Klasse kann er in andere Komponenten wie z. B. Controller injiziert werden. <br>  Lassen Sie uns unseren Service erstellen.  Erstellen Sie die Datei <code>items.service.ts</code> Ordner <code>items.service.ts</code> mit den folgenden Inhalten: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  und √§ndern Sie den <code>ItemsController</code> Controller (deklariert in <code>items.controller.ts</code> ), um unseren Service zu nutzen: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  In der neuen Version des Controllers haben wir den <code>@Body</code> Dekorator auf das Argument <code>create</code> method angewendet.  Dieses Argument wird verwendet, um die √ºber <code>req.body ['item']</code> Daten automatisch mit dem Argument selbst (in diesem Fall <code>item</code> ) <code>req.body ['item']</code> . <br>  Au√üerdem empf√§ngt unser Controller eine Instanz der <code>ItemsService</code> Klasse, die √ºber den Konstruktor <code>ItemsService</code> wird.  Wenn Sie <code>ItemsService</code> als <code>private readonly</code> wird eine Instanz unver√§nderlich und nur innerhalb der Klasse sichtbar. <br>  Und vergessen Sie nicht, unseren Service in <code>app.module.ts</code> zu registrieren: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Senden Sie nach allen √Ñnderungen eine HTTP-POST-Anfrage an das Men√º: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Anschlie√üend √ºberpr√ºfen wir, ob neue Gerichte auf unserer Speisekarte erscheinen, indem wir eine GET-Anfrage stellen (oder indem wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 3000 / items</a> in einem Browser √∂ffnen). </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Erstellen einer Warenkorbroute </h4><br><p>  Nachdem wir die erste Version des Einstiegspunkts <code>/items</code> unserer API haben, implementieren wir die Warenkorbfunktion.  Der Prozess zum Erstellen dieser Funktionalit√§t unterscheidet sich nicht wesentlich von der bereits erstellten API.  Um das Handbuch nicht zu √ºberladen, erstellen wir eine Komponente, die beim Zugriff mit dem Status OK antwortet. </p><br><p>  Erstellen Sie zun√§chst im <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Registrieren Sie diesen Controller in unserem Modul ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  F√ºhren Sie den folgenden Befehl aus, um diesen Einstiegspunkt zu √ºberpr√ºfen, nachdem Sie sichergestellt haben, dass die Anwendung ausgef√ºhrt wird: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Hinzuf√ºgen eines Schnittstellentypskripts f√ºr Elemente </h4><br><p>  Zur√ºck zu unserem <code>items</code> .  Jetzt speichern wir nur den Namen des Gerichts, aber dies ist eindeutig nicht genug, und wir werden sicher mehr Informationen haben wollen (zum Beispiel die Kosten des Gerichts).  Ich denke, Sie werden zustimmen, dass das Speichern dieser Daten als Array von Zeichenfolgen keine gute Idee ist? <br>  Um dieses Problem zu l√∂sen, k√∂nnen wir ein Array von Objekten erstellen.  Aber wie kann man die Struktur von Objekten speichern?  Hier hilft uns die TypeScript-Oberfl√§che, in der wir die Struktur des <code>items</code> Objekts definieren.  Erstellen Sie eine neue Datei mit dem Namen <code>item.interface.ts</code> im Ordner <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  <code>items.service.ts</code> Datei <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  Und auch in <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validierung der Eingabe in Nest.js </h4><br><p>  Trotz der Tatsache, dass wir die Struktur des <code>item</code> , gibt unsere Anwendung keinen Fehler zur√ºck, wenn wir eine ung√ºltige POST-Anforderung senden (alle Arten von Daten, die nicht in der Schnittstelle definiert sind).  Zum Beispiel f√ºr eine solche Anfrage: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Der Server sollte mit einem Status von 400 (fehlerhafte Anfrage) antworten. Stattdessen antwortet unsere Anwendung mit einem Status von 200 (OK). </p><br><p>  Um dieses Problem zu l√∂sen, erstellen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DTO (Data Transfer Object)</a> und eine Pipe-Komponente (Channel). </p><br><p>  DTO ist ein Objekt, das definiert, wie Daten zwischen Prozessen √ºbertragen werden sollen.  Wir beschreiben das DTO in der <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Pipes in <code>Nest.js</code> sind die Komponenten, die f√ºr die Validierung verwendet werden.  Erstellen Sie f√ºr unsere API einen Kanal, in dem √ºberpr√ºft wird, ob die an die Methode gesendeten Daten mit dem DTO √ºbereinstimmen.  Ein Kanal kann von verschiedenen Controllern verwendet werden. Erstellen Sie daher das Verzeichnis <code>src/common/</code> mit der Datei <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Hinweis: Wir m√ºssen zwei Module installieren: <code>class-validator</code> und <code>class-transformer</code> .  F√ºhren Sie dazu <code>npm install class-validator class-transformer</code> in der Konsole aus und starten Sie den Server neu. </blockquote><p>  Anpassen von <code>items.controller.ts</code> f√ºr die Verwendung mit unserer neuen Pipe und DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Lassen Sie uns unseren Code noch einmal √ºberpr√ºfen. Jetzt akzeptiert der Eintrag <code>/items</code> nur dann Daten, wenn sie im DTO definiert sind.  Zum Beispiel: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  F√ºgen Sie ung√ºltige Daten ein (Daten, die in <code>ValidationPipe</code> nicht √ºberpr√ºft werden k√∂nnen). Als Ergebnis erhalten wir die Antwort: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Middleware erstellen </h5><br><p>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Auth0-Schnellstartanleitung</a> wird empfohlen, das von Auth0 ausgegebene JWT-Token zu √ºberpr√ºfen, indem Sie die von <code>express-jwt</code> bereitgestellte <code>express-jwt</code> .  Diese Middleware automatisiert einen gro√üen Teil der Arbeit. </p><br><p>  Erstellen wir eine <code>authentication.middleware.ts</code> Datei im Verzeichnis <code>src / common</code> mit dem folgenden Code: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Ersetzen Sie <code>${DOMAIN}</code> durch den <em>Dom√§nenwert</em> aus den Auth0-Anwendungseinstellungen </p><br><blockquote>  Anmerkung des √úbersetzers: <code>DOMAIN</code> Sie in einer realen Anwendung <code>DOMAIN</code> in eine Konstante und legen Sie den Wert √ºber <code>env</code> (virtuelle Umgebung) fest. </blockquote><p>  Installieren Sie die <code>jwks-rsa</code> <code>express-jwt</code> und <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  Es ist notwendig, die erstellte Middleware (Handler) mit unserer Anwendung zu verbinden.  Dazu in der Datei <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  Der obige Code besagt, dass POST-Anforderungen an die Routen <code>/items</code> und <code>/shopping-cart</code> durch <em>Express-Middleware</em> gesch√ºtzt sind, die in der Anforderung nach dem Zugriffstoken sucht. </p><br><p>  Starten Sie den Entwicklungsserver neu ( <code>npm run start:dev</code> ) und rufen Sie die Nest.js-API auf: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Rollenverwaltung mit Auth0 </h5><br><p>  Derzeit kann jeder Benutzer mit einem verifizierten Token Elemente in unserer API ver√∂ffentlichen.  Wir m√∂chten jedoch, dass dies nur Benutzer mit Administratorrechten tun k√∂nnen.  Um diese Funktion zu implementieren, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regeln (Regeln) Auth0</a> . </p><br><p>  Wechseln Sie also zur Systemsteuerung Auth0 im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt <em>Regeln</em></a> .  Klicken Sie dort auf die <code>+ CREATE RULE</code> und w√§hlen Sie als Regelmodell "Rollen f√ºr einen Benutzer <code>+ CREATE RULE</code> ". </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Anschlie√üend erhalten wir eine JavaScript-Datei mit einer Regelvorlage, die jedem Benutzer, der E-Mails hat, die zu einer bestimmten Dom√§ne geh√∂ren, die Administratorrolle hinzuf√ºgt.  Lassen Sie uns einige Details in dieser Vorlage √§ndern, um ein Funktionsbeispiel zu erhalten.  F√ºr unsere Anwendung gew√§hren wir dem Administrator nur Zugriff auf unsere eigene E-Mail-Adresse.  Wir m√ºssen auch den Speicherort f√ºr die Speicherung von Administratorstatusinformationen √§ndern. </p><br><p>  Derzeit werden diese Informationen in einem Identifikationstoken gespeichert (das zum Bereitstellen von Informationen √ºber den Benutzer verwendet wird). F√ºr den Zugriff auf Ressourcen in der API sollte jedoch ein Zugriffstoken verwendet werden.  Der Code nach den √Ñnderungen sollte folgenderma√üen aussehen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Hinweis: Ersetzen Sie <code>${YOUR_EMAIL}</code> durch Ihre E-Mail-Adresse.  Es ist wichtig zu beachten, dass es in der Regel ideal ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die E-Mail-√úberpr√ºfung</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erzwingen</a> , wenn Sie mit E-Mails in den Auth0-Regeln arbeiten.  In diesem Fall ist dies nicht erforderlich, da wir unsere eigene E-Mail-Adresse verwenden. <br><br>  Anmerkung des √úbersetzers: Das obige Codefragment wird im Browser auf der Konfigurationsseite der Auth0-Regel eingegeben </blockquote><p>  Um zu √ºberpr√ºfen, ob das an unsere API √ºbergebene Token das Administrator-Token ist, m√ºssen wir einen <em>Schutz</em> Nest.js erstellen.  Erstellen Sie im Ordner <code>src/common</code> die Datei <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Wenn wir nun den oben beschriebenen Anmeldevorgang wiederholen und die in der Regel definierte E-Mail-Adresse verwenden, erhalten wir ein neues <code>access_token</code> .  Um den Inhalt dieses <code>access_token</code> zu √ºberpr√ºfen, kopieren Sie das Token und f√ºgen Sie es in das Feld <code>Encoded</code> der Site <code>https://jwt.io/</code> .  Wir werden sehen, dass der Payload-Abschnitt dieses Tokens das folgende Array enth√§lt: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Wenn unser Token diese Informationen wirklich enth√§lt, setzen wir die Integration mit Auth0 fort.  √ñffnen Sie also <code>items.controller.ts</code> und f√ºgen Sie dort unseren neuen W√§chter hinzu: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Mit unserem neuen Token k√∂nnen wir jetzt neue Elemente √ºber unsere API hinzuf√ºgen: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Anmerkung des √úbersetzers: Zur √úberpr√ºfung k√∂nnen Sie sehen, was wir in den Artikeln haben: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Zusammenfassung </h4><br><p>  Gl√ºckwunsch!  Wir haben gerade die Erstellung unserer Nest.JS-API abgeschlossen und k√∂nnen uns nun auf die Entwicklung des Frontend-Teils unserer Anwendung konzentrieren!  Lesen Sie unbedingt den zweiten Teil dieser Serie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Full-Stack TypeScript-Apps - Teil 2: Entwickeln von Frontend Angular Apps.</a> </p><br><blockquote>  Anmerkung des √úbersetzers: Die √úbersetzung des zweiten Teils des Prozesses </blockquote><p>  Zusammenfassend haben wir in diesem Artikel verschiedene Funktionen von Nest.js und TypeScript verwendet: Module, Controller, Dienste, Schnittstellen, Pipes, Middleware und Guard zum Erstellen API  Ich hoffe, Sie haben gute Erfahrungen gemacht und sind bereit, unsere Anwendung weiterzuentwickeln.  Wenn Ihnen etwas nicht klar ist, ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation zu nest.j</a> eine gute Quelle mit Antworten </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471348/">https://habr.com/ru/post/de471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471336/index.html">Holivar. Geschichte von Runet. Teil 6. Schl√∂sser: Lurk, Tape, 282. und chinesischer Pfad</a></li>
<li><a href="../de471340/index.html">Drimsim gegen Mate 20 Pro Round! Aber f√ºr wen?</a></li>
<li><a href="../de471342/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471344/index.html">Noch einmal √ºber ImmutableList in Java</a></li>
<li><a href="../de471346/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 384 (7. - 13. Oktober 2019)</a></li>
<li><a href="../de471350/index.html">Reverse Engineering von rauscharmen Operationsverst√§rkern von einem analogen Computer im Jahr 1969</a></li>
<li><a href="../de471352/index.html">Pr√§sentationen in LaTeX schreiben</a></li>
<li><a href="../de471358/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python √ºber Ontologie? Teil 4: Native API</a></li>
<li><a href="../de471360/index.html">Vervielf√§ltigungsmethode. 11 Beispiele aus dem Design von ICE</a></li>
<li><a href="../de471364/index.html">Automatisiertes Testmanagement mit Telegramm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>