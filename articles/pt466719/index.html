<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜò ‚òéÔ∏è üëáüèæ Perfil de velocidade superluz: teoria e pr√°tica. Parte 1 üë©üèø‚Äçü§ù‚Äçüë®üèΩ üïú ‚òπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Pela manchete, voc√™ j√° entendeu sobre o que vou falar. Haver√° muito hardcore: 
 discutiremos Java, C, C ++, assembler, um pouco de Linux, um pouco ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perfil de velocidade superluz: teoria e pr√°tica. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/466719/">  Oi  Pela manchete, voc√™ j√° entendeu sobre o que vou falar.  Haver√° muito hardcore: <br>  discutiremos Java, C, C ++, assembler, um pouco de Linux, um pouco do kernel do sistema operacional.  Tamb√©m analisaremos um caso pr√°tico, para que o artigo seja dividido em tr√™s partes grandes (bastante volumosas). <br><br><img src="https://habrastorage.org/webt/mp/cl/er/mpclerfppp9jx5ciuziyfv-n8oa.png"><br><br>  No primeiro, tentaremos extrair tudo dos criadores de perfil existentes. <br>  Na segunda parte, criaremos nosso pr√≥prio pequeno gerador de perfil e na terceira veremos como criar um perfil do que n√£o √© habitual, porque as ferramentas existentes n√£o s√£o muito adequadas para isso.  Se voc√™ est√° pronto para seguir esse caminho - estou esperando por voc√™ :) <br><a name="habracut"></a><br><h3>  Conte√∫do </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tempo e meios de compreens√£o - profiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como funcionam os criadores de perfil de amostragem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quantas vezes precisamos provar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Escolha um profiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda perf para criar um perfil de aplicativo Java.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aumentar a taxa de amostragem de perf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usamos (explicitamente) eventos de PMU / PEBS de hardware</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Breve resumo</a> </li></ul><br><a name="1"></a><h3>  Tempo e meios de compreens√£o - profiler </h3><br>  Do ponto de vista cotidiano, 1 segundo √© muito pequeno.  Mas sabemos que 1 segundo √© um bilh√£o inteiro de nanossegundos.  E deixe levar cerca de 4 ciclos do processador em apenas 1 nanossegundo. Em 1 segundo, muitas coisas s√£o feitas no computador que podem melhorar ou piorar nossas vidas. <br><br>  Suponha que estamos desenvolvendo um aplicativo que por si s√≥ √© cr√≠tico o suficiente para acelerar, e para alguns fragmentos de c√≥digo isso geralmente √© cr√≠tico.  Essas partes s√£o executadas, digamos, centenas de microssegundos - com rapidez suficiente, mas elas [ <i>se√ß√µes do c√≥digo</i> ] afetam diretamente o sucesso do nosso aplicativo e a quantidade de dinheiro ganho ou perdido.  Por exemplo <br>  ao enviar ordens para concluir transa√ß√µes de c√¢mbio, um atraso de 100 microssegundos pode custar √† troca 1 milh√£o de rublos ou mais em cada transa√ß√£o, completada por um, n√£o dois, ou mesmo cem. <br><br>  E a <b>tarefa</b> foi definida para mim: por um lado, voc√™ precisa enviar todos os pedidos ao mesmo tempo e, por outro lado, envi√°-los para que a varia√ß√£o entre o primeiro e o √∫ltimo seja m√≠nima.  Ou seja, era necess√°rio criar um perfil de uma fun√ß√£o que envia pedidos para a central.  Uma tarefa t√≠pica, exceto por uma pequena nuance: o tempo de execu√ß√£o caracter√≠stico dessa fun√ß√£o √© <i>significativamente menor que 100 Œºs</i> . <br><br>  Vamos pensar em como tra√ßamos esses 100 Œºs para entender o que est√° acontecendo l√° dentro. <br>  O que considerar ao escolher esta ferramenta? <br><br><ol><li>  A se√ß√£o de c√≥digo que nos interessa raramente √© executada, ou seja, 100 microssegundos s√£o executados em algum lugar uma vez por segundo.  E isso est√° na bancada de testes e ainda menos na produ√ß√£o. </li><li>  Ser√° dif√≠cil isolar esse trecho de c√≥digo em uma marca de microbench, porque afeta uma parte significativa do projeto e at√© mesmo a entrada / sa√≠da da rede. </li><li>  E, finalmente, o mais importante, quero que o perfil resultante corresponda ao comportamento que estar√° em nossos servidores de produ√ß√£o. </li></ol><br>  Como levamos em conta todas essas nuances e definimos corretamente o m√©todo de interesse? <br><br>  Conceitualmente, todos os criadores de perfil podem ser divididos em dois grupos de <i>instrumentadores</i> ou <i>amostragem</i> .  Vamos considerar cada grupo separadamente. <br><br>  <b>Os criadores de perfil de ferramentas</b> contribuem com bastante sobrecarga porque modificam nosso bytecode e inserem um registro de temporiza√ß√£o nele.  Da√≠ a principal desvantagem de tais criadores de perfil: eles podem afetar significativamente o c√≥digo execut√°vel.  Como resultado, ser√° dif√≠cil dizer o quanto o perfil resultante corresponde ao comportamento nos servidores de produ√ß√£o: algumas otimiza√ß√µes podem funcionar de maneira diferente, outras acontecem e outras n√£o.  Talvez, em outras escalas de tempo - segundos, minutos, horas - tenhamos dados representativos.  Por√©m, em uma escala de 100 Œºs, a otimiza√ß√£o acionada ou com falha pode levar o perfil a n√£o ser representativo.  Ent√£o, vamos dar uma olhada em outro grupo de criadores de perfil. <br><br>  <b>Os criadores de perfil de amostragem</b> contribuem para sobrecarga m√≠nima ou moderada.  Essas ferramentas n√£o afetam diretamente o c√≥digo execut√°vel e seu uso requer um pouco mais de aten√ß√£o de voc√™.  Portanto, vamos nos concentrar nos criadores de perfil de amostragem.  Vamos ver quais dados e de que forma receberemos deles. <br><br><a name="2"></a><h3>  Como funcionam os criadores de perfil de amostragem? </h3><br>  Para entender como um criador de perfil de amostra funciona, considere o exemplo a seguir - o m√©todo <b>sendToMoex</b> chama v√°rios outros m√©todos.  N√≥s olhamos: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sendToMoex() { a.qqq(); b.doo(); c.ccc() } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> doo() { da(); db(); }</code> </pre> <br>  Se monitorarmos o estado da pilha de chamadas no momento da execu√ß√£o desta se√ß√£o do programa e a registrarmos periodicamente, receberemos informa√ß√µes aproximadamente da seguinte forma: <br><br><img src="https://habrastorage.org/webt/gl/je/y5/gljey5esfyih7lqm1yjvpaxfese.png"><br><br>  Este √© um conjunto de pilhas de chamadas.  Supondo que as amostras sejam distribu√≠das igualmente, o n√∫mero de pilhas id√™nticas indica o tempo de execu√ß√£o relativo do m√©todo que est√° no topo da pilha. <br><br>  Neste exemplo, o m√©todo Da foi executado tanto quanto o m√©todo C.ccc, e isso √© 2 vezes mais que o m√©todo Db. No entanto, a suposi√ß√£o de que a distribui√ß√£o de amostras √© uniforme pode n√£o estar completamente correta e, portanto, a estimativa do tempo de execu√ß√£o estar√° incorreta. <br><br><a name="3"></a><h3>  Quantas vezes precisamos provar? </h3><br>  Suponha que queremos coletar 1000 amostras em 100 microssegundos para entender o que foi reproduzido por dentro.  Em seguida, calculamos com uma propor√ß√£o simples que, se precisarmos fazer 1000 amostras em 100 Œºs, ser√£o 10 milh√µes de amostras em 1 segundo ou 10.000.000 de amostras / s. <br><br><img src="https://habrastorage.org/webt/x6/rw/2j/x6rw2jbbfxfouax9ncy8hkfn3nq.png"><br><br>  Se fizermos uma amostragem nessa velocidade, em uma execu√ß√£o do c√≥digo, coletaremos 1000 amostras, agregamos e entenderemos o que funcionou r√°pida ou lentamente.  Depois disso, analisaremos o desempenho e ajustaremos o c√≥digo. <br><br>  No entanto, uma frequ√™ncia de 10 milh√µes de amostras por segundo √© muito.  E se falharmos em atingir tal velocidade de cria√ß√£o de perfil desde o in√≠cio?  Suponha que coletamos para 10 ¬µs apenas 10 amostras, e n√£o 1000. Nesse caso, precisamos aguardar a pr√≥xima execu√ß√£o do c√≥digo de perfil, que ocorrer√° ap√≥s 1 segundo (afinal, o c√≥digo de perfil √© executado uma vez por segundo).  Ent√£o, vamos coletar mais 10 amostras.  Como eles s√£o distribu√≠dos igualmente conosco, eles podem ser combinados em um conjunto comum.  Basta esperar at√© que o c√≥digo de perfil seja executado 1000/10 = 100 vezes, e coletaremos as 1000 amostras necess√°rias (10 amostras cada uma das 100 vezes). <br><br><a name="4"></a><h3>  Escolha um profiler </h3><br>  Armado com esse conhecimento te√≥rico, vamos √† pr√°tica. <br><br>  Tome o <b>Async-profiler.</b>  Uma √≥tima ferramenta (usa a chamada de m√°quina virtual AsyncGetCallTrace) que coleta a pilha de chamadas at√© a instru√ß√£o do c√≥digo de bytes da m√°quina virtual Java.  A taxa de amostragem nativa do criador de perfis de assinaturas √© de <i>1000 amostras por segundo</i> . <br><br>  Resolveremos uma propor√ß√£o simples: 10.000.000 amostras / s - 1 segundo, 1000 amostras / s - X segundos. <br>  Conclu√≠mos que na frequ√™ncia de amostragem padr√£o do async-profiler, a cria√ß√£o de perfil levar√° cerca de 3 horas.  Faz muito tempo.  Idealmente, quero montar o perfil o mais r√°pido poss√≠vel, na velocidade superluminal. <br><br>  Vamos tentar fazer overclock do <b>Async-profiler</b> .  Para fazer isso, no leia-me, encontramos o sinalizador <code>-i</code> , que define o intervalo de amostragem.  Vamos tentar definir o sinalizador <code>-i1</code> (1 nanossegundo) ou <code>-i0</code> em geral, para que o criador de perfil seja <code>-i0</code> sem parar.  Eu tenho uma frequ√™ncia de cerca de 2,5 mil amostras por segundo.  Nesse caso, a dura√ß√£o total da cria√ß√£o de perfil ser√° de aproximadamente 1 hora.  Claro, n√£o 3 horas, mas tamb√©m n√£o muito r√°pido.  Parece que, para atingir as velocidades de cria√ß√£o de perfil necess√°rias, √© necess√°rio fazer algo qualitativamente diferente, para atingir um novo n√≠vel. <br><br>  Para obter frequ√™ncias significativamente mais altas, voc√™ ter√° que abandonar a chamada AsyncGetCallTrace e usar o <b>perf</b> , o criador de perfil Linux em tempo integral encontrado em todas as distribui√ß√µes Linux.  No entanto, o perf n√£o sabe nada sobre Java, e ainda precisamos trein√°-lo para trabalhar com Java.  Enquanto isso, vamos tentar executar o perf desta maneira assustadora: <br><br><pre> <code class="java hljs">$ perf record ‚ÄìF <span class="hljs-number"><span class="hljs-number">10000</span></span> -p PID -g -- sleep <span class="hljs-number"><span class="hljs-number">1</span></span> [ perf record: Woken up <span class="hljs-number"><span class="hljs-number">1</span></span> times to write data ] [ perf record: .. <span class="hljs-number"><span class="hljs-number">0.215</span></span> MB perf.data (<span class="hljs-number"><span class="hljs-number">4032</span></span> samples) ]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mais sobre nota√ß√£o</b> <div class="spoiler_text"><ul><li>  <i>registro perf</i> significa que queremos gravar um perfil. </li><li>  O sinalizador <code>-F</code> e o argumento 10.000 s√£o a taxa de amostragem. </li><li>  O sinalizador <code>-p</code> indica que queremos criar um perfil apenas do PID espec√≠fico do nosso processo Java. </li><li>  O sinalizador <code>-g</code> √© respons√°vel por coletar pilhas de chamadas. </li><li>  Finalmente, com o <i>sono 1,</i> limitamos a entrada do perfil a 1 segundo. </li></ul></div></div><br>  Por que precisamos coletar pilhas de chamadas?  N√≥s perfilamos tudo em uma linha e, a partir dos dados coletados, extra√≠mos a parte que nos interessa (o m√©todo respons√°vel pela forma√ß√£o e envio de pedidos).  O marcador que a amostra coletada pertence aos dados nos quais estamos interessados ‚Äã‚Äã√© a presen√ßa do quadro de pilha da <b>chamada do</b> m√©todo <b>sendToMoex</b> . <br><br><a name="5"></a><h3>  Aprenda perf para criar um perfil de aplicativo Java. </h3><br>  Executamos o comando perf record ..., esperamos 1 segundo e executamos o script perf para ver o que foi perfilado?  E veremos algo n√£o muito claro: <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.746571</span></span>: <span class="hljs-number"><span class="hljs-number">3745505</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b53f8 [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.747565</span></span>: <span class="hljs-number"><span class="hljs-number">3728336</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b5372 [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.748613</span></span>: <span class="hljs-number"><span class="hljs-number">3731147</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b53ef [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map)</code> </pre><br>  Parece ser endere√ßos, mas n√£o h√° nomes de m√©todos Java.  Portanto, voc√™ precisa ensinar o perf para combinar esses endere√ßos com os nomes dos m√©todos. <br><br>  No mundo de C e C ++, as chamadas informa√ß√µes de depura√ß√£o s√£o usadas para corresponder endere√ßos e nomes de fun√ß√µes.  Uma correspond√™ncia √© armazenada em uma se√ß√£o especial do arquivo execut√°vel: um m√©todo est√° nesses endere√ßos, outro m√©todo est√° em outros endere√ßos.  O Perf obt√©m essas informa√ß√µes e faz um mapeamento. <br><br>  Obviamente, o compilador JIT da m√°quina virtual n√£o gera informa√ß√µes de depura√ß√£o nesse formato.  Ainda temos outra maneira - escrever dados sobre a correspond√™ncia de endere√ßos e nomes de m√©todos em um arquivo perf-map especial, que o perf tratar√° como um complemento √†s informa√ß√µes de depura√ß√£o lidas.  Esse arquivo perf-map deve estar na pasta tmp e ter a seguinte estrutura de dados: <br><div class="scrollable-table"><table><tbody><tr><th>  Endere√ßo de in√≠cio do c√≥digo do m√©todo </th><th>  Comprimento do c√≥digo </th><th>  Nome do m√©todo </th></tr><tr><td>  7f99a911d600 </td><td>  120 </td><td>  java.util.AbstractCollection. &lt;init&gt; </td></tr><tr><td>  7f99a911d9c0 </td><td>  180 </td><td>  java.util.AbstractList. &lt;init&gt; </td></tr><tr><td>  7f99a911de80 </td><td>  5c0 </td><td>  java.util.Arrays.copyOf </td></tr><tr><td>  7f99a911ed40 </td><td>  140 </td><td>  java.util.ArrayList $ Itr.hasNext </td></tr><tr><td>  7f99a911f200 </td><td>  3e0 </td><td>  java.util.ArrayList $ Itr.next <br></td></tr></tbody></table></div><br>  A primeira coluna √© o endere√ßo do in√≠cio do c√≥digo do m√©todo, a segunda √© o seu comprimento, a terceira coluna √© o nome do m√©todo. <br><br>  Portanto, precisamos gerar um arquivo semelhante.  Obviamente, n√£o conseguiremos fazer isso manualmente (como sabemos em que endere√ßo o compilador JIT colocar√° o c√≥digo); portanto, usaremos o script create-java-perf-map.sh do projeto perf-map-agent, passando o PID do nosso processo Java .  O arquivo est√° pronto, verifique seu conte√∫do, execute o perf-script novamente. <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.867498</span></span>: cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f527 Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.868176</span></span>: <span class="hljs-number"><span class="hljs-number">2127960</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f57f Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.868737</span></span>: <span class="hljs-number"><span class="hljs-number">1959990</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f627 Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map)</code> </pre> <br>  Voila!  Vemos os nomes dos m√©todos java!  O que aconteceu: ensinamos o perf profiler, que n√£o sabe nada sobre Java, a criar um perfil de um aplicativo Java comum e ver os m√©todos hot java desse aplicativo! <br><br>  No entanto, para analisar o desempenho da parte do programa que estamos interrogando, n√£o temos pilha de chamadas suficiente para filtrar os dados de interesse de todas as amostras coletadas. <br><br>  <b>Como obter uma pilha de chamadas?</b> <br><br>  Agora voc√™ precisa fazer outra coisa com perf ou uma m√°quina virtual para obter pilhas de chamadas.  Para entender o que precisa ser feito, vamos dar um passo atr√°s e ver como a pilha geralmente funciona.  Imagine que temos tr√™s fun√ß√µes f1, f2, f3.  Al√©m disso, f1 chama f2 e f2 chama f3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f1() { f2(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f2() { f3(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f3() { ... }</code> </pre> <br>  No momento em que a fun√ß√£o <code>f3</code> executada, vamos ver em que estado a pilha est√°.  Vemos o registro <code>rsp</code> , que aponta para o topo da pilha.  Tamb√©m sabemos que a pilha possui o endere√ßo do quadro anterior.  E como posso obter uma pilha de chamadas? <br><br>  Se, de alguma forma, pud√©ssemos obter o endere√ßo dessa √°rea, poder√≠amos imaginar a pilha como uma lista simplesmente conectada e entender a sequ√™ncia de chamadas que nos levaram ao ponto de execu√ß√£o atual. <br><br>  Do que precisamos para isso?  Precisamos de um registro rbp extra que aponte para a √°rea amarela.  Acontece que o registro rbp permite que o perf obtenha a pilha de chamadas, entenda a sequ√™ncia que nos levou ao ponto atual.  Eu recomendo a leitura desses detalhes na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface bin√°ria do aplicativo System V.</a>  Ele descreve como os m√©todos s√£o chamados no Linux. <br><br><img src="https://habrastorage.org/webt/0m/0w/vx/0m0wvx8wcaplslb7k5illbb4hbm.png"><br><br>  N√≥s entendemos qual √© o nosso problema.  Precisamos for√ßar a m√°quina virtual a usar o registro rbp para sua finalidade original - como um ponteiro para o in√≠cio do quadro da pilha.  √â assim que o compilador JIT deve usar o registro rbp.  H√° um sinalizador PreserveFramePointer na m√°quina virtual para isso.  Quando passamos esse sinalizador para a m√°quina virtual, a m√°quina virtual come√ßar√° a usar o registro rbp para sua finalidade tradicional.  E ent√£o o Perf pode girar a pilha.  E temos uma pilha de chamadas real no perfil.  A bandeira foi contribu√≠da pelo not√≥rio Brendan Gregg em apenas JDK8u60. <br><br>  Iniciamos a m√°quina virtual com uma nova bandeira.  Execute <code>create-java-perf-map</code> , em seguida, <code>perf record</code> e <code>perf script</code> .  Agora podemos criar um perfil preciso com pilhas de chamadas: <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">18657</span></span> <span class="hljs-number"><span class="hljs-number">1901247.601878</span></span>: <span class="hljs-number"><span class="hljs-number">979583</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>f285d007b10 Interpreter (...) <span class="hljs-number"><span class="hljs-number">7</span></span>f285d0004e7 call_stub (...) <span class="hljs-number"><span class="hljs-number">67</span></span>d0db [unknown] (... libjvm.so) ... <span class="hljs-number"><span class="hljs-number">708</span></span>c start_thread (... libpthread<span class="hljs-number"><span class="hljs-number">-2.26</span></span>.so)</code> </pre><br>  Ensinamos o perf profiler, inclu√≠do na maioria das distribui√ß√µes Linux, a trabalhar com aplicativos Java.  Portanto, agora podemos ver n√£o apenas as se√ß√µes importantes do c√≥digo, mas tamb√©m a sequ√™ncia de chamadas que levaram ao ponto ativo atual.  Uma grande conquista, j√° que o perf profiler n√£o sabe nada sobre java.  Acabamos de ensinar a tudo isso! <br><br><a name="7"></a><h3>  Aumentar a taxa de amostragem de perf </h3><br>  Vamos tentar fazer um overclock do perf para 10 milh√µes de amostras por segundo.  Agora temos uma frequ√™ncia significativamente menor. <br><br>  Para automatizar todas as tarefas que acabamos de executar, voc√™ pode usar o script <code>perf-java-record-stack</code> do projeto perf-map-agent.  Ele tem uma caneta maravilhosa - a vari√°vel de ambiente <code>perf_record-freq</code> , com a qual voc√™ pode definir a frequ√™ncia de amostragem.  Primeiro, vamos definir 100 mil amostras por segundo e tentar executar.  Uma mensagem terr√≠vel aparece no console informando que excedeu a frequ√™ncia de amostragem m√°xima permitida: <br><br><pre> <code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number"><span class="hljs-number">100000</span></span> ./bin/perf-java-record-stack PID ... Maximum frequency rate (<span class="hljs-number"><span class="hljs-number">30000</span></span>) reached. Please use -F freq option <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> lower value or consider tweaking /proc/sys/kernel/perf_event_max_sample_rate. ...</code> </pre><br>  No meu caso, o limite foi de 30 mil amostras por segundo.  O Perf diz imediatamente qual argumento do kernel precisa ser corrigido, o que faremos usando echo sudo tee no arquivo desejado ou diretamente atrav√©s do <code>sysctl</code> .  Ent√£o: <br><br><pre> <code class="javascript hljs">$ echo <span class="hljs-string"><span class="hljs-string">'1000000'</span></span> | sudo tee /proc/sys/kernel/perf_event_max_sample_rate</code> </pre> <br>  ou mais: <br><br><pre> <code class="javascript hljs">$ sudo sysctl kernel.perf_event_max_sample_rate=<span class="hljs-number"><span class="hljs-number">1000000</span></span></code> </pre><br>  Agora, estamos dizendo ao kernel que o limite superior da frequ√™ncia agora √© de 1 milh√£o de amostras por segundo.  Iniciamos o criador de perfil novamente e indicamos a frequ√™ncia de 200 mil amostras por segundo.  O criador de perfil funcionar√° por 15 segundos e fornecer√° 1 milh√£o de amostras.  Tudo parece estar bem.  Pelo menos nenhuma mensagem de erro formid√°vel.  Mas que frequ√™ncia n√≥s realmente recebemos?  Acontece que apenas 70 mil amostras por segundo.  O que deu errado? <br><br>  Vamos ver a sa√≠da do <code>dmesg</code> : <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">84430.412898</span></span>] perf: interrupt took too long (<span class="hljs-number"><span class="hljs-number">1783</span></span> &gt; <span class="hljs-number"><span class="hljs-number">200</span></span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number"><span class="hljs-number">89700</span></span> ... [<span class="hljs-number"><span class="hljs-number">84431.618452</span></span>] perf: interrupt took too long (<span class="hljs-number"><span class="hljs-number">2229</span></span> &gt; <span class="hljs-number"><span class="hljs-number">2228</span></span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number"><span class="hljs-number">71700</span></span></code> </pre><br>  Esta √© a sa√≠da do kernel do Linux.  Ele percebeu que amostramos com muita frequ√™ncia e leva muito tempo, portanto o kernel diminui a frequ√™ncia.  Acontece que precisamos desaparafusar outro identificador no kernel - ele √© chamado <code>kernel.perf_cpu_time_max_percent</code> e controla a quantidade de tempo que o kernel pode gastar em interrup√ß√µes do perf. <br><br>  Pediremos uma frequ√™ncia de amostragem de 200 mil amostras por segundo.  E ap√≥s 15 segundos, obtemos 3 milh√µes de amostras - 200 mil amostras por segundo. <br><br><pre> <code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number"><span class="hljs-number">200000</span></span> ./bin/perf-java-record-stack PID Recording events <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> seconds ... ... [ perf record: Captured ... (<span class="hljs-number"><span class="hljs-number">2.961</span></span><span class="hljs-number"><span class="hljs-number">.252</span></span> samples) ]</code> </pre><br>  Agora vamos ver o perfil.  Execute o <code>perf script</code> : <br><br><pre> <code class="javascript hljs">$ perf script ... java ... native_write_msr (<span class="hljs-regexp"><span class="hljs-regexp">/.../</span></span>vmlinux) java ... Loop2.main (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-29621.</span></span>map) java ... native_write_msr (<span class="hljs-regexp"><span class="hljs-regexp">/.../</span></span>vmlinux) ...</code> </pre><br>  Vemos fun√ß√µes estranhas e o m√≥dulo execut√°vel vmlinux - o kernel do Linux.  Definitivamente, este n√£o √© o nosso c√≥digo.  O que aconteceu?  A frequ√™ncia acabou sendo t√£o alta que o c√≥digo do kernel come√ßou a cair nas amostras.  Ou seja, quanto maior aumentarmos a frequ√™ncia, mais haver√° amostras que n√£o est√£o relacionadas ao nosso c√≥digo, mas ao kernel do Linux. <br><br>  Beco sem sa√≠da. <br><br><a name="8"></a><h3>  Usamos (explicitamente) eventos de PMU / PEBS de hardware </h3><br>  Ent√£o decidi tentar usar a tecnologia de hardware PMU / PEBS - Performance Monitoring Unit, Precise Event Based Sampling.  Ele permite que voc√™ receba notifica√ß√µes de que um evento ocorreu um determinado n√∫mero de vezes.  Isso √© chamado de "per√≠odo".  Por exemplo, podemos receber notifica√ß√µes sobre a execu√ß√£o pelo processador de cada 20¬™ instru√ß√£o.  Vejamos um exemplo.  Deixe a instru√ß√£o xor ser executada agora e o contador da PMU obter o valor 18;  depois vem a instru√ß√£o mov - o contador √© 19;  e a pr√≥xima instru√ß√£o, <b>adicione% r14,% r13</b> , a PMU ser√° exibida como "quente". <br><br>  Em seguida, um novo ciclo come√ßa: <code>inc</code> √© executado - a PMU √© redefinida para 1. Mais algumas itera√ß√µes do ciclo passam.  No final, paramos na instru√ß√£o <code>mov</code> , a PMU tira 19. A pr√≥xima instru√ß√£o add e novamente a marcamos como quente.  Veja a lista: <br><br><pre> <code class="plaintext hljs">mov aaa, bbbb xor %rdx, %rdx L_START: mov $0x0(%rbx, %rdx),%r14 add %r14, %r13 ; (PMU       "") cmp %rdx,100000000 jne L_START</code> </pre> <br>  N√£o percebe as esquisitices?  Um ciclo de cinco instru√ß√µes, mas cada vez que marcamos a mesma instru√ß√£o como quente.  Obviamente, isso n√£o √© verdade: todas as instru√ß√µes s√£o "quentes".  Eles tamb√©m gastam tempo e marcamos apenas um.  O fato √© que, entre o per√≠odo e o contador do n√∫mero de instru√ß√µes na itera√ß√£o, temos um fator comum 4. Acontece que a cada quarta itera√ß√£o, marcaremos a mesma instru√ß√£o como "quente".  Para evitar esse comportamento, voc√™ precisa escolher um n√∫mero como um per√≠odo no qual a probabilidade de um divisor comum entre o n√∫mero de itera√ß√µes no loop e o pr√≥prio contador √© minimizada.  Idealmente, o per√≠odo deve ser primo, ou seja,  compartilhe somente consigo mesmo e com a unidade.  Para o exemplo acima: voc√™ deve escolher um per√≠odo igual a 23. Em seguida, marcamos uniformemente todas as instru√ß√µes deste ciclo como "quentes". <br><br>  A tecnologia PMU / PEBS √© suportada em sua forma moderna desde pelo menos 2009, ou seja, est√° dispon√≠vel em praticamente qualquer computador.  Para aplic√°-lo explicitamente, vamos modificar o script <code>perf-java-record-stack</code> .  Substitua o sinalizador <code>-F</code> por <code>-e</code> , que especifica explicitamente o uso de PMU / PEBS. <br><br><pre> <code class="javascript hljs">... sudo perf record -F $PERF_RECORD_FREQ ... ...</code> </pre> <br>  Transformando o script: <br><br><pre> <code class="javascript hljs">... sudo perf record -e cycles ‚Äìc <span class="hljs-number"><span class="hljs-number">10007</span></span> ... ...</code> </pre> <br>  Voc√™ j√° sabe quais propriedades um per√≠odo deve ter - precisamos de um n√∫mero primo.  Para o nosso caso, ser√° o per√≠odo 10007. <br><br>  Eles lan√ßaram o script perf-java-record-stack modificado e obtiveram 4,5 milh√µes de amostras em 15 segundos - quase 300 mil amostras por segundo, uma amostra a cada 3 microssegundos.  Ou seja, para uma execu√ß√£o de nosso c√≥digo de perfil, por 100 Œºs, coletaremos 33 amostras.  Nessa frequ√™ncia, o tempo total de coleta de perfis √© de apenas 30 segundos.  Nem beba uma x√≠cara de caf√©!  Na realidade, tudo √© um pouco mais complicado.  O que acontece se nosso c√≥digo come√ßar a ser executado n√£o uma vez por segundo, mas uma vez a cada 5 segundos?  Em seguida, a dura√ß√£o do perfil aumentar√° para 2,5 minutos, o que tamb√©m √© um resultado decente. <br><br>  Assim, em 30 segundos voc√™ pode obter um perfil que cubra completamente todas as nossas necessidades de pesquisa.  Vit√≥ria <br><br>  Mas a sensa√ß√£o de algum truque sujo n√£o me deixou.  Vamos voltar √† situa√ß√£o em que nosso c√≥digo √© executado a cada 5 segundos.  A cria√ß√£o de perfil levar√° 150 segundos, durante os quais coletaremos cerca de 45 milh√µes de amostras.  Desses, precisamos apenas de 1000, ou seja, 0,002% dos dados coletados.  Todo o resto √© lixo, o que atrasa o trabalho de outras ferramentas e aumenta a sobrecarga.  Sim, o problema est√° resolvido, mas na testa, for√ßa suja e contundente. <br><br>  E naquela noite, quando obtive um perfil t√£o detalhado com a ajuda do perf, tive um sonho.  Eu estava voltando para casa do trabalho e pensando, mas seria bom se o ferro fosse capaz de montar o perfil em si e at√© a precis√£o das microestruturas e microssegundos, e analisar√≠amos apenas os resultados.  Meu sonho se tornar√° realidade?  O que voc√™ acha? <br><br><a name="9"></a><h3>  Breve resumo: </h3><br><ul><li>  Para criar um perfil de um aplicativo Java usando perf, voc√™ precisa gerar um arquivo com informa√ß√µes sobre s√≠mbolos usando scripts do projeto perf-map-agent </li><li>  Para coletar informa√ß√µes n√£o apenas sobre se√ß√µes importantes do c√≥digo, mas tamb√©m sobre pilhas, voc√™ precisa executar uma m√°quina virtual com o sinalizador -XX: + PreserveFramePointer </li><li>  Se voc√™ deseja aumentar a frequ√™ncia de amostragem, preste aten√ß√£o no sysctl'i e no kernel.perf_cpu_time_max_percent e no kernel.perf_event_max_sample_rate. </li><li>  Se amostras do kernel que n√£o est√£o relacionadas ao aplicativo come√ßaram a entrar no perfil, pense em especificar explicitamente o per√≠odo da PMU / PEBS. </li></ul><br>  Este artigo (e suas partes subseq√ºentes) √© uma transcri√ß√£o do relat√≥rio, adaptada em forma de texto.  Se voc√™ deseja n√£o apenas ler, mas tamb√©m ouvir sobre cria√ß√£o de perfil, uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refer√™ncia</a> √† apresenta√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466719/">https://habr.com/ru/post/pt466719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466701/index.html">Let's Encrypt serve quase 30% dos dom√≠nios</a></li>
<li><a href="../pt466705/index.html">Vivaldi Beta para Android - Navegador Real</a></li>
<li><a href="../pt466709/index.html">Desenvolvendo um sistema operacional monol√≠tico semelhante a Unix - C Library (2)</a></li>
<li><a href="../pt466711/index.html">Vulnerabilidade O DaOffice permitiu remover qualquer usu√°rio da rede social</a></li>
<li><a href="../pt466713/index.html">√â poss√≠vel em 1C n√£o observar a tecnologia de componentes externos? Ou como parabenizar os colegas usando o 1C?</a></li>
<li><a href="../pt466721/index.html">[Yekaterinburg, an√∫ncio] java.ural.Meetup @ 3 - an√∫ncio do terceiro relat√≥rio de v√≠deo mitap + Java de java.ural.Meetup @ 2</a></li>
<li><a href="../pt466723/index.html">Transmiss√£o de texto da Apple - 10 de setembro de 2019</a></li>
<li><a href="../pt466725/index.html">O punhal 2 √© elementar (parte 1)</a></li>
<li><a href="../pt466727/index.html">Atualiza√ß√£o pregui√ßosa: como o PostgreSQL 12 melhora o desempenho</a></li>
<li><a href="../pt466729/index.html">O livro "Minera√ß√£o de dados. Recuperando informa√ß√µes do Facebook, Twitter, LinkedIn, Instagram, GitHub ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>