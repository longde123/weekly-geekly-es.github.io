<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüíº üë©‚ÄçüöÄ üõ¥ PVS-Studio f√ºr Java üë®üèæ‚Äç‚öïÔ∏è üì§ üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der siebten Version des statischen Analysators PVS-Studio haben wir die Unterst√ºtzung der Java-Sprache hinzugef√ºgt. Es ist Zeit f√ºr eine kurze Gesc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio f√ºr Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436496/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio f√ºr Java"></div><br>  In der siebten Version des statischen Analysators PVS-Studio haben wir die Unterst√ºtzung der Java-Sprache hinzugef√ºgt.  Es ist Zeit f√ºr eine kurze Geschichte dar√ºber, wie wir begonnen haben, die Java-Sprache zu unterst√ºtzen, wie weit wir gekommen sind und was in unseren weiteren Pl√§nen steht.  In diesem Artikel werden nat√ºrlich erste Analysatorversuche zu Open Source-Projekten aufgef√ºhrt. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Hier finden Sie eine kurze Beschreibung von PVS-Studio f√ºr Java-Entwickler, die noch nichts davon geh√∂rt haben. <br><br>  Dieses Tool wurde entwickelt, um Fehler und potenzielle Schwachstellen im Quellcode von Programmen zu erkennen, die in C, C ++, C # und Java geschrieben wurden.  Es funktioniert in Windows-, Linux- und MacOS-Umgebungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> f√ºhrt eine statische Code-Analyse durch und generiert einen Bericht, der einem Entwickler hilft, Fehler zu finden und zu beseitigen.  F√ºr diejenigen, die daran interessiert sind, wie genau PVS-Studio nach Fehlern sucht, empfehle ich den Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Technologien, die im PVS-Studio-Code-Analysator zum Auffinden von Fehlern und potenziellen Schwachstellen verwendet werden</a> ". <br><br><h2>  Anfang </h2><br>  Ich h√§tte mir eine clevere Geschichte einfallen lassen k√∂nnen, wie wir dar√ºber spekuliert haben, welche n√§chste Sprache in PVS-Studio unterst√ºtzt werden soll.  √úber eine vern√ºnftige Wahl von Java, die auf einer hohen Popularit√§t dieser Sprache basiert, und so weiter. <br><br>  Wie es im Leben passiert, wurde die Wahl jedoch nicht durch eine gr√ºndliche Analyse getroffen, sondern durch ein Experiment :).  Ja, wir haben √ºber die Richtung der Weiterentwicklung des PVS-Studio-Analysators nachgedacht.  Wir haben folgende Sprachen betrachtet: Java, PHP, Python, JavaScript, IBM RPG.  Wir waren sogar zur Java-Sprache geneigt, aber die endg√ºltige Wahl wurde nicht getroffen.  F√ºr diejenigen, deren Blick auf einem unbekannten IBM-RPG beruhte, m√∂chte ich Sie auf diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Notiz</a> verweisen, aus der alles klar wird. <br><br>  Ende 2017 √ºberpr√ºfte mein Kollege Egor Bredikhin die f√ºr uns interessanten Standardbibliotheken f√ºr Parsing-Code (mit anderen Worten Parser) auf neue Entwicklungsrichtungen.  Schlie√ülich stie√ü er auf mehrere Projekte zum Parsen von Java-Code.  Es gelang ihm, schnell einen Analysator-Prototyp mit einigen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spoon</a> basierenden Diagnosen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> .  Dar√ºber hinaus ist klar geworden, dass wir im Java-Analysator einige Mechanismen des C ++ - Analysators mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIG verwenden k√∂nnen</a> .  Wir haben uns angesehen, was wir bekommen haben, und festgestellt, dass unser n√§chster Analysator f√ºr Java sein wird. <br><br>  Wir m√∂chten Egor f√ºr sein Engagement und seine harte Arbeit am Java-Analysator danken.  Der Entwicklungsprozess selbst wurde von ihm im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines neuen statischen Analysators: PVS-Studio Java</a> " beschrieben. <br><br><h2>  Was ist mit Wettbewerbern? </h2><br>  Es gibt weltweit viele kostenlose und kommerzielle statische Code-Analysatoren f√ºr Java.  Es macht keinen Sinn, sie alle im Artikel aufzulisten.  Ich lasse einfach den Link zur " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der Tools f√ºr die statische Code-Analyse</a> " (siehe Abschnitt Java und Mehrsprachigkeit). <br><br>  Ich wei√ü jedoch, dass wir in erster Linie nach IntelliJ IDEA, FindBugs und SonarQube (SonarJava) gefragt werden. <br><br>  <b>IntelliJ IDEE</b> <br><br>  In IntelliJ IDEA ist ein sehr leistungsf√§higer statischer Code-Analysator integriert.  Dar√ºber hinaus entwickelt sich der Analysator weiter und seine Autoren verfolgen unsere Aktivit√§ten genau.  IntelliJ IDEA ist f√ºr uns also ein harter Keks.  Zumindest vorerst werden wir IntelliJ IDEA in Bezug auf diagnostische F√§higkeiten nicht √ºbertreffen k√∂nnen.  Deshalb werden wir uns auf unsere anderen Vorteile konzentrieren. <br><br>  Die statische Analyse in IntelliJ IDEA ist in erster Linie eines der Merkmale der Umgebung, das ihr bestimmte Einschr√§nkungen auferlegt.  Wir haben die Freiheit, was wir mit unserem Analyseger√§t tun k√∂nnen.  Zum Beispiel k√∂nnen wir es schnell an spezifische Kundenbed√ºrfnisse anpassen.  Schnelle und umfassende Unterst√ºtzung ist unser Wettbewerbsvorteil.  Unsere Kunden kommunizieren direkt mit Entwicklern und arbeiten an dem einen oder anderen Teil von PVS-Studio. <br><br>  In PVS-Studio gibt es viele M√∂glichkeiten, es in einen Zyklus der Entwicklung gro√üer alter Projekte zu integrieren.  Zum Beispiel ist es unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration mit SonarQube</a> .  Es enth√§lt auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Massenunterdr√ºckung</a> von Analysatorwarnungen, mit der Sie das Tool sofort in einem gro√üen Projekt verwenden k√∂nnen, um Fehler nur im neuen oder ge√§nderten Code zu verfolgen.  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> in einem kontinuierlichen Integrationsprozess erstellt werden.  Ich denke, diese und andere Funktionen werden unserem Analysator helfen, einen Platz unter der Sonne in der Java-Welt zu finden. <br><br>  <b>Findbugs</b> <br><br>  Das FindBugs-Projekt wird abgebrochen.  Trotzdem sollten wir es erw√§hnen, weil es vielleicht der bekannteste kostenlose statische Analysator f√ºr Java-Code ist. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpotBugs</a> kann als Nachfolger von FindBugs bezeichnet werden.  Es ist jedoch weniger beliebt und es ist noch nicht klar, was damit passieren wird. <br><br>  Generell sind wir der Meinung, dass FindBugs, obwohl es √§u√üerst beliebt war und ist, und dar√ºber hinaus ein kostenloser Analysator, nicht weiter darauf eingehen sollten.  Dieses Projekt wird nur leise eine Geschichte werden. <br><br>  PS √úbrigens kann PVS-Studio jetzt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlos</a> bei der Arbeit mit offenen Projekten verwendet werden. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Wir glauben, dass wir nicht mit SonarQube konkurrieren, sondern es erg√§nzen.  PVS-Studio ist in SonarQube integriert, wodurch Entwickler mehr Fehler und potenzielle Sicherheitsl√ºcken in ihren Projekten finden k√∂nnen.  Wir erkl√§ren regelm√§√üig, wie das PVS-Studio-Tool und andere Analyseger√§te in SonarQube in Meisterklassen integriert werden k√∂nnen, die wir in Bezug auf verschiedene Konferenzen abhalten. <br><br><h2>  So f√ºhren Sie PVS-Studio f√ºr Java aus </h2><br>  Wir haben den Benutzern die beliebtesten Methoden zur Integration des Analysators in das Build-System zur Verf√ºgung gestellt: <br><br><ul><li>  Plugin f√ºr Maven; </li><li>  Plugin f√ºr Gradle; </li><li>  Plugin f√ºr IntelliJ IDEA </li></ul><br>  W√§hrend der Testphase haben wir viele Benutzer getroffen, die √ºber selbst geschriebene Build-Systeme verf√ºgen, insbesondere im Bereich der mobilen Entwicklung.  Sie genossen die Gelegenheit, den Analysator direkt auszuf√ºhren und die Quellen und den Klassenpfad aufzulisten. <br><br>  Detaillierte Informationen zu allen M√∂glichkeiten zum Ausf√ºhren des Analysators finden Sie auf der Dokumentationsseite " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausf√ºhren von PVS-Studio Java</a> ". <br><br>  Wir konnten uns nicht vor der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarQube-</a> Plattform zur Codequalit√§tskontrolle scheuen, die bei Java-Entwicklern so beliebt ist. Deshalb haben wir die Unterst√ºtzung der Java-Sprache in unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin f√ºr SonarQube aufgenommen</a> . <br><br><h2>  Weitere Pl√§ne </h2><br>  Wir haben viele Ideen, die m√∂glicherweise weiterer Untersuchungen bed√ºrfen, aber einige spezifische Pl√§ne, die jedem unserer Analyseger√§te eigen sind, lauten wie folgt: <br><br><ul><li>  Erstellung neuer Diagnosen und Verbesserung der bestehenden; </li><li>  Verbesserung der Datenflussanalyse; </li><li>  Steigerung der Zuverl√§ssigkeit und Benutzerfreundlichkeit. </li></ul><br>  Vielleicht finden wir Zeit, um das IntelliJ IDEA-Plugin f√ºr CLion anzupassen.  Hallo an C ++ - Entwickler, die √ºber den Java-Analysator gelesen haben :-) <br><br><h2>  Beispiele f√ºr Fehler in Open Source-Projekten </h2><br>  Zittern Sie meine H√∂lzer, wenn ich im Artikel nicht einige Fehler zeige, die mit dem neuen Analyseger√§t gefunden wurden!  Nun, wir h√§tten ein gro√ües Open-Source-Java-Projekt nehmen und einen klassischen Artikel schreiben k√∂nnen, in dem Fehler √ºberpr√ºft werden, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir es normalerweise tun</a> . <br><br>  Ich erwarte jedoch sofort Fragen dar√ºber, was wir in Projekten wie IntelliJ IDEA, FindBugs usw. finden k√∂nnen.  Ich habe einfach keinen Ausweg, au√üer mit diesen Projekten zu beginnen.  Deshalb habe ich mich entschlossen, einige interessante Fehlerbeispiele aus den folgenden Projekten schnell zu √ºberpr√ºfen und aufzuschreiben: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IntelliJ IDEA Community Edition</a> .  Ich denke, es ist nicht n√∂tig zu erkl√§ren, warum dieses Projekt ausgew√§hlt wurde :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpotBugs</a>  Wie ich bereits geschrieben habe, schreitet das FindBugs-Projekt nicht voran.  Schauen wir uns also das SpotBugs-Projekt an, das der Nachfolger von FindBugs ist.  SpotBugs ist ein klassischer statischer Analysator von Java-Code. </li><li>  Etwas aus dem SonarSource-Unternehmensprojekt, das Software zur kontinuierlichen √úberwachung der Codequalit√§t entwickelt.  Schauen wir uns nun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarQube</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SonarJava an</a> . </li></ul><br>  Das Schreiben √ºber Fehler dieser Projekte ist eine Herausforderung.  Tatsache ist, dass diese Projekte von sehr hoher Qualit√§t sind.  Eigentlich ist es nicht √ºberraschend.  Unsere Beobachtungen zeigen, dass statische Codeanalysatoren immer gut mit anderen Tools getestet und verifiziert werden. <br><br>  Trotz alledem muss ich genau mit diesen Projekten beginnen.  Ich werde nicht die zweite Chance haben, dar√ºber zu schreiben.  Ich bin sicher, dass Entwickler der aufgef√ºhrten Projekte nach der Ver√∂ffentlichung von PVS-Studio f√ºr Java PVS-Studio an Bord nehmen und es f√ºr regelm√§√üige oder zumindest gelegentliche √úberpr√ºfungen ihres Codes verwenden werden.  Ich wei√ü zum Beispiel, dass Tagir Valeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">lany</a> ), einer der Entwickler von JetBrains, der gerade am IntelliJ IDEA Static Code Analyzer arbeitet, als ich den Artikel schreibe, bereits mit der Beta-Version von PVS-Studio spielt .  Er schrieb uns ungef√§hr 15 E-Mails mit Fehlerberichten und Empfehlungen.  Danke, Tagir! <br><br>  Gl√ºcklicherweise muss ich nicht so viele Fehler in einem bestimmten Projekt finden.  Im Moment ist es meine Aufgabe zu zeigen, dass der PVS-Studio Analyzer f√ºr Java nicht umsonst erschien und in der Lage sein wird, eine Reihe anderer Tools zur Verbesserung der Codequalit√§t zu f√ºllen.  Ich habe nur die Analyseberichte durchgesehen und einige Fehler aufgelistet, die interessant erschienen.  Wenn m√∂glich, habe ich versucht, verschiedene Arten von Fehlern zu zitieren.  Mal sehen, wie es ausgegangen ist. <br><br><h3>  IntelliJ IDEA, Integer Division </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V6011 [CWE-682] Das Literal '0.2' vom Typ 'double' wird mit einem Wert vom Typ 'int' verglichen.  TitleCapitalizationInspection.java 169 <br><br>  Der Punkt war, dass die Funktion true zur√ºckgeben sollte, wenn weniger als 20% der W√∂rter mit einem Gro√übuchstaben beginnen.  Tats√§chlich funktioniert die Pr√ºfung nicht, da eine Ganzzahldivision auftritt.  Als Ergebnis der Division k√∂nnen wir nur zwei Werte erhalten: 0 oder 1. <br><br>  Die Funktion gibt nur dann false zur√ºck, wenn alle W√∂rter mit einem Gro√übuchstaben beginnen.  In allen anderen F√§llen f√ºhrt die Divisionsoperation zu 0 und die Funktion gibt true zur√ºck. <br><br><h3>  IntelliJ IDEA, Verd√§chtige Schleife </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'index&gt; = 0' ist immer wahr.  Updater.java 184 <br><br>  Schauen Sie sich zun√§chst die Bedingung an <i>(0 &lt;= aktuell &amp;&amp; aktuell &lt;Anzahl)</i> .  Es wird nur ausgef√ºhrt, wenn der Wert der <i>Z√§hlvariablen</i> gr√∂√üer als 0 ist. <br><br>  Schauen Sie sich nun die Schleife an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  Der Variablenindex wird mit einem Ausdruck <i>count - 1</i> initialisiert.  Da die Z√§hlvariable gr√∂√üer als 0 ist, ist der Anfangswert der <i>Indexvariablen</i> immer gr√∂√üer oder gleich 0. Es stellt sich heraus, dass die Schleife ausgef√ºhrt wird, bis ein √úberlauf der <i>Indexvariablen</i> auftritt. <br><br>  H√∂chstwahrscheinlich handelt es sich nur um einen Tippfehler, und es muss ein Dekrement und kein Inkrement einer Variablen ausgef√ºhrt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, Kopieren-Einf√ºgen </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V6001 [CWE-570] Links und rechts vom '||' befinden sich identische Unterausdr√ºcke 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)'.  Betreiber.  √úberpr√ºfen Sie die Zeilen: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Guter alter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Effekt der letzten Zeile</a> .  Ein Entwickler sprang die Waffe und nachdem er die Codezeile multipliziert hatte, verga√ü er, sie zu reparieren.  Infolgedessen wird eine Zeichenfolge zweimal mit <i>BEFORE_STR_OLD</i> verglichen.  H√∂chstwahrscheinlich muss einer der Vergleiche mit <i>AFTER_STR_OLD durchgef√ºhrt werden</i> . <br><br><h3>  IntelliJ IDEA, Tippfehler </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  PVS-Studio-Warnung: V6001 [CWE-571] Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke '! StringUtil.endsWithChar (Name,' "'). JsonNamesValidator.java 27 <br><br>  Dieses Codefragment √ºberpr√ºft, ob der Name in einfache oder doppelte Anf√ºhrungszeichen eingeschlossen ist.  Ist dies nicht der Fall, werden doppelte Anf√ºhrungszeichen automatisch hinzugef√ºgt. <br><br>  Aufgrund eines Tippfehlers wird das Ende des Namens nur auf doppelte Anf√ºhrungszeichen √ºberpr√ºft.  Infolgedessen wird der Name in einfachen Anf√ºhrungszeichen falsch verarbeitet. <br><br>  Der Name <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  Durch das Hinzuf√ºgen zus√§tzlicher doppelter Anf√ºhrungszeichen wird Folgendes angezeigt: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, Falscher Schutz vor Array-√úberlauf </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'i &lt;endOffset' ist immer wahr.  EnterAfterJavadocTagHandler.java 183 <br><br>  Der Unterausdruck <i>i &lt;endOffset</i> im Zustand des <i>if-</i> Operators ist nicht sinnvoll.  Die Variable <i>i</i> ist in jedem Fall immer kleiner als <i>endOffset</i> , was sich aus der Bedingung der Schleifenausf√ºhrung ergibt. <br><br>  H√∂chstwahrscheinlich wollte ein Entwickler beim Aufrufen von Funktionen vor einem √úberlaufen von Zeichenfolgen sch√ºtzen: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (Text, i + 2, endOffset, startTag) </li></ul><br>  In diesem Fall muss der Unterausdruck zum √úberpr√ºfen des Index sein: <i>(i) &lt;endOffset-2</i> . <br><br><h3>  IntelliJ IDEA, Wiederholte √úberpr√ºfung </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'buffer.length ()&gt; 0' ist immer wahr.  DeleteUtil.java 62 <br><br>  Dies kann entweder ein harmloser redundanter Code oder ein entscheidender Fehler sein. <br><br>  Wenn versehentlich eine doppelte Pr√ºfung aufgetreten ist, z. B. w√§hrend des Refactorings, ist daran nichts auszusetzen.  Sie k√∂nnen den zweiten Scheck einfach l√∂schen. <br><br>  Ein anderes Szenario ist ebenfalls m√∂glich.  Die zweite Pr√ºfung muss ganz anders sein und der Code verh√§lt sich nicht wie beabsichtigt.  Dann ist es ein echter Fehler. <br><br>  <b>Hinweis</b>  √úbrigens gibt es viele verschiedene redundante Pr√ºfungen.  Nun, oft ist klar, dass es kein Fehler ist.  Wir k√∂nnen die Warnungen des Analysators jedoch nicht als falsch positiv betrachten.  Zur Erkl√§rung m√∂chte ich ein solches Beispiel anf√ºhren, das ebenfalls aus IntelliJ IDEA stammt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  Der Analysator sagt, dass die Funktion <i>text.contains ("\ r \ n")</i> immer false zur√ºckgibt.  Wenn das Zeichen "\ n" und "\ r" nicht gefunden wird, macht es keinen Sinn, nach "\ r \ n" zu suchen.  Es ist kein Fehler, und der Code ist nur deshalb schlecht, weil er etwas langsamer arbeitet und eine bedeutungslose Suche nach einem Teilstring durchf√ºhrt. <br><br>  Wie mit einem solchen Code umzugehen ist, ist jeweils eine Frage f√ºr Entwickler.  Beim Schreiben von Artikeln achte ich normalerweise nicht auf solchen Code. <br><br><h3>  IntelliJ IDEE, etwas stimmt nicht </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-570] Der Ausdruck '"0" .equals (text)' ist immer falsch.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Der Code enth√§lt mit Sicherheit einen logischen Fehler.  Es f√§llt mir schwer zu sagen, was genau der Programmierer √ºberpr√ºfen wollte und wie der Fehler behoben werden kann.  Also werde ich hier nur auf einen bedeutungslosen Scheck hinweisen. <br><br>  Zu Beginn muss √ºberpr√ºft werden, ob die Zeichenfolge mindestens zwei Symbole enth√§lt.  Ist dies nicht der Fall, gibt die Funktion <i>false zur√ºck</i> . <br><br>  Als n√§chstes kommt das H√§kchen <i>"0" .equals (Text)</i> .  Es ist bedeutungslos, weil keine Zeichenfolge nur ein Zeichen enthalten kann. <br><br>  Hier stimmt also etwas nicht, und der Code sollte korrigiert werden. <br><br><h3>  SpotBugs (Nachfolger von FindBugs), Fehler bei der Begrenzung der Anzahl der Iterationen </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  PVS-Studio-Warnung: V6007 [CWE-571] Der Ausdruck 'count &lt;4' ist immer wahr.  Util.java 394 <br><br>  Theoretisch darf eine Suche des XML-Tags nur in den ersten vier Zeilen der Datei durchgef√ºhrt werden.  Aufgrund der Tatsache, dass man vergessen hat, die <i>Z√§hlvariable zu</i> erh√∂hen, wird die gesamte Datei gelesen. <br><br>  Erstens kann dies ein sehr langsamer Vorgang sein, und zweitens kann irgendwo in der Mitte der Datei etwas gefunden werden, das als XML-Tag wahrgenommen wird, nicht als XML-Tag. <br><br><h3>  SpotBugs (Nachfolger von FindBugs), L√∂schen eines Wertes </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V6021 [CWE-563] Der Wert wird der Variablen 'priority' zugewiesen, jedoch nicht verwendet.  FindNonShortCircuit.java 197 <br><br>  Der Wert der <i>Priorit√§tsvariablen</i> wird abh√§ngig vom Wert der Variablen <i>sawNullTestVeryOld festgelegt</i> .  Es spielt jedoch √ºberhaupt keine Rolle.  Danach wird der <i>Priorit√§tsvariablen</i> in jedem Fall ein anderer Wert zugewiesen.  Ein offensichtlicher Fehler in der Funktionslogik. <br><br><h3>  SonarQube, Kopieren-Einf√ºgen </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Es ist merkw√ºrdig, dass der Hauptteil der Methode 'setUpdatedAtFromDefinition' dem Hauptteil einer anderen Methode 'setUpdatedAtFromMetadata' vollst√§ndig entspricht.  √úberpr√ºfen Sie die Zeilen: 396, 405. RuleDto.java 396 <br><br>  In der Methode <i>setUpdatedAtFromMetadata wird</i> ein <i>Definitionsfeld</i> verwendet.  H√∂chstwahrscheinlich sollte das <i>Metadatenfeld</i> verwendet werden.  Dies ist den Auswirkungen eines fehlgeschlagenen Kopierens und Einf√ºgens sehr √§hnlich. <br><br><h3>  SonarJava, Duplikate beim Initialisieren der Karte </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  PVS-Studio-Warnung: V6033 [CWE-462] Ein Element mit demselben Schl√ºssel 'JavaPunctuator.PLUSEQU' wurde bereits hinzugef√ºgt.  √úberpr√ºfen Sie die Zeilen: 104, 100. KindMaps.java 104 <br><br>  Das gleiche Schl√ºssel-Wert-Paar wird zweimal in der Karte festgelegt.  H√∂chstwahrscheinlich ist es versehentlich passiert und tats√§chlich gibt es keinen wirklichen Fehler.  Dieser Code muss jedoch auf jeden Fall √ºberpr√ºft werden, da man m√∂glicherweise vergessen hat, ein anderes Paar hinzuzuf√ºgen. <br><br><h2>  Fazit </h2><br>  Warum eine Schlussfolgerung schreiben, wenn es so offensichtlich ist ?!  Ich schlage vor, dass Sie alle jetzt PVS-Studio herunterladen und versuchen, Ihre Arbeitsprojekte in der Java-Sprache zu √ºberpr√ºfen!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie PVS-Studio herunter</a> . <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit.  Ich hoffe, dass wir unseren Lesern bald eine Reihe von Artikeln zur √úberpr√ºfung verschiedener Open-Source-Java-Projekte gefallen werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436496/">https://habr.com/ru/post/de436496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436486/index.html">Was passiert auf dem Audio-Podcast-Markt?</a></li>
<li><a href="../de436488/index.html">Currying und Teilanwendung in C ++ 14</a></li>
<li><a href="../de436490/index.html">Motorola plant die Einf√ºhrung der Razr v3-Inkarnation</a></li>
<li><a href="../de436492/index.html">Wir suchen Redner beim 10. DIY Mitap am 17. Februar 2019</a></li>
<li><a href="../de436494/index.html">Ersetzen einer Festplatte unter Beibehaltung der richtigen Nummerierung in CEPH</a></li>
<li><a href="../de436498/index.html">Software AG: Nicht nur ARIS</a></li>
<li><a href="../de436500/index.html">Wie der Rahmen von Rise of the Tomb Raider gerendert wird</a></li>
<li><a href="../de436502/index.html">Abonnement verw√∂hnt oder wie man mehr an dieselben Kunden verkauft</a></li>
<li><a href="../de436504/index.html">System im Paket oder was ist unter Chip-Paketabdeckung?</a></li>
<li><a href="../de436506/index.html">Wie man ohne gro√üen Aufwand einen KI-Rassisten erschafft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>