<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèæ üëÇüèΩ üë©üèæ‚Äç‚úàÔ∏è Menyebarkan Symfony + Bereaksi aplikasi pada AWS melalui CI üë®üèø‚Äç‚úàÔ∏è ‚ôøÔ∏è ü¶Ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, dalam artikel ini saya akan menunjukkan cara menggunakan aplikasi Symfony 4 di AWS. Ada contoh proses seperti itu dalam dokumentasi res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menyebarkan Symfony + Bereaksi aplikasi pada AWS melalui CI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462415/"> Selamat siang, dalam artikel ini saya akan menunjukkan cara menggunakan aplikasi Symfony 4 di AWS.  Ada contoh proses seperti itu dalam dokumentasi resmi, tetapi versi saya tidak sepele seperti mengunduh arsip zip dengan aplikasi.  Di halaman 2019, dalam mode buruh pelabuhan, arsitektur layanan mikro dan praktik CI / CD akhirnya mulai dimasukkan dalam alat tidak hanya insinyur DevOps, tetapi juga pengembang <s>manusia</s> biasa.  Untuk membuat artikel lebih menarik, saya menambahkan sebuah front ke React.JS, untuk menutupi kebutuhan lebih banyak orang, jika aplikasi Anda tidak menggunakan Encore - itu tidak masalah, saya akan menunjukkan bagaimana cara mengubah file Docker untuk Anda, dukungan untuk React.JS hanya memengaruhi .  Siapa yang akan tertarik dengan tutorial ini?  Pertama-tama, ini ditujukan untuk pengembang PHP yang ingin mengubah praktik penyebaran mereka - untuk menjauh dari kanon biasa dan menggunakan buruh pelabuhan untuk mengemas aplikasi mereka dan meletakkan gambar.  Tapi Anda bisa sedikit lebih dalam, dan narasi lebih lanjut akan ditujukan untuk secara otomatis menyebarkan aplikasi dari Git melalui platform CI / CD (CircleCI akan digunakan, tetapi jika Anda tertarik dengan konfigurasi Gitlab, tulis di komentar, saya akan melampirkannya).  Faktanya, sama sekali tidak penting untuk Bereaksi / PHP apakah Anda memiliki aplikasi atau, katakanlah, .NET Core, bagian ini akan menarik bagi pengembang untuk mendapatkan keterampilan otomatisasi penyebaran secara umum.  Kode sumber tersedia di repositori github, tautan di akhir artikel.  Ayo pergi! <br><a name="habracut"></a><br>  Saya berasumsi bahwa Anda memiliki aplikasi Symfony Anda sendiri, tetapi untuk tujuan demonstrasi saya membuat sketsa "halo, dunia!" Berisi paket-paket berikut: <br><br>  <code>`symfony/webpack-encore-bundle symfony/form symfony/orm-pack symfony/profiler-pack symfony/security-bundle symfony/twig-bundle symfony/validator symfony/phpunit-bridge`</code> adalah perangkat pria yang minimal.  Saat ini, struktur folder harus sebagai berikut: <br><br><img width="350" src="https://habrastorage.org/webt/6m/ck/xi/6mckxiczmqlde3nsjhdpzcbforq.png" alt="gambar"><br><br>  Sekarang Anda perlu mengkonfigurasi infrastruktur cloud Anda.  Saya tidak akan fokus mendaftar dan mengaktifkan periode uji coba AWS, pada tahap ini kita perlu membuat 2 instance DB - Saya akan menggunakan 2 jenis lingkungan: STG (pementasan) untuk menguji implementasi "fitur" baru dan PROD (produksi) sebagai "pertempuran" secara langsung server  Banyak artikel telah ditulis tentang manfaat dari database layanan yang dikelola, terlebih lagi, kami terutama mengejar kenyamanan bagi pengembang dalam panduan ini, oleh karena itu kami menggunakan RDS, daripada meningkatkan server database kami sendiri yang terpisah.  Sebagai DBMS untuk contoh ini, saya menggunakan PostgreSQL, Anda bebas memilih yang cocok untuk Anda, buka layanan RDS dan buat 2 instance kapasitas dan volume yang Anda butuhkan.  Karena file <code>.env</code> tersedia untuk kita "di luar kotak" di Symfony, kita akan menggunakannya, misalnya, untuk PROD, dan untuk STG kita akan membuat salinan <code>.env.stg</code> dan mengubah <code>APP_ENV=dev</code> ke <code>APP_ENV=stg</code> di <code>.env.stg</code> dan <code>APP_ENV=dev</code> pada <code>APP_ENV=prod</code> di <code>.env</code> , dan juga masukkan parameter koneksi <code>.env</code> untuk setiap instance yang dibuat. <br><br>  Hebat, awal telah dibuat!  Seperti yang Anda ketahui, dependensi symfony dipasang melalui komposer, untuk menginstalnya, gunakan file composer.sh, yang kami masukkan ke dalam root proyek: <br><br><div class="spoiler">  <b class="spoiler_title">composer.sh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/bin/sh EXPECTED_SIGNATURE="$(wget -q -O - https://composer.github.io/installer.sig)" php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" ACTUAL_SIGNATURE="$(php -r "echo hash_file('sha384', 'composer-setup.php');")" if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ] then &gt;&amp;2 echo 'ERROR: Invalid installer signature' rm composer-setup.php exit 1 fi php composer-setup.php --quiet RESULT=$? rm composer-setup.php exit $RESULT</code> </pre> <br></div></div><br>  Ini <a href="">adalah</a> panduan <a href="">instalasi perangkat lunak dari komposer</a> . <br><br>  Sekarang, untuk masing-masing lingkungan, buat Dockerfile Anda sendiri di root proyek: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile.stg (pementasan)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ COPY ./.env.stg ./.env RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  dan <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile (produksi)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  File dapat digunakan "sebagaimana adanya", tidak ada makro yang digunakan untuk perubahan.  Mari kita menelusuri isi Dockerfile untuk menghilangkan sentuhan "ajaib".  Sebagai "dasar" kami menggunakan gambar resmi PHP 7.2.19 dengan server web Apache terintegrasi (Anda bebas untuk menggunakan pilihan Anda, mengkonfigurasi bundel dengan Nginx, dan sebagainya, dalam contoh ini saya menggunakan yang di atas sebagai yang paling, menurut saya, nyaman).  Garis expose tidak penting bagi kami saat ini, dengan sendirinya tidak melakukan apa-apa, tetapi di masa depan itu akan digunakan oleh ElasticBeanstalk, yang membutuhkannya untuk digunakan dengan benar.  Konstruksi berikut menggunakan pengaturan produksi yang dioptimalkan oleh PHP yang direkomendasikan oleh pabrikan, mengaktifkan mod_rewrite untuk Apache dan meningkatkan memori maksimum untuk skrip PHP dari 128 hingga 256 mb, yang diperlukan agar komposer bekerja dengan benar.  Selanjutnya, kami menginstal aplikasi yang diperlukan, dependensi dan ekstensi PHP, dan segera mengonfigurasinya.  Kami menetapkan folder / var / www ke direktori kerja aplikasi kami - kode sumber aplikasi kami akan disalin di sana.  Karena apache, secara default, menggunakan / var / www sebagai titik masuk untuk inangnya, dan file indeks symfony terletak di / var / www / publik, kami mengubah root dokumen apache dengan konstruksi berikut.  Kemudian kami memasang komposer, simpul dan benang secara berurutan (jika Anda tidak menggunakan encore / react.js dalam aplikasi Anda, maka Anda tidak perlu dua poin terakhir).  Akhirnya, kami menyalin kode sumber kami dan memulai pemasangan dependensi melalui komposer untuk symfony dan benang untuk react.js.  Arti Dockerfile terpisah untuk STG terletak pada instruksi kedua dari belakang untuk docker - menyalin .env.stg ke .env, sehingga file .env pada gambar STG akan berisi parameter yang relevan untuk lingkungan ini.  Anda dapat secara lokal (tentu saja dengan buruh pelabuhan diinstal) mengumpulkan gambar, menjalankannya dan memastikan bahwa aplikasi berfungsi dan tidak memerlukan hal lain untuk pekerjaan ini: <br><br><pre> <code class="plaintext hljs">docker build -t tmp:stg -f Dockerfile.stg . docker run -p 80:80 tmp:stg</code> </pre> <br>  untuk STG dan <br><br><pre> <code class="plaintext hljs">docker build -t tmp:prod . docker run -p 80:80 tmp:prod</code> </pre> <br>  untuk PROD. <br>  Kita dapat menggunakan EC2, mengkonfigurasi ELB / ASG, dll., Atau menggunakan ElasticBeanstalk, yang hanya hadiah bagi kita dalam hal kenyamanan.  Pergi ke bagian ElasticBeanstalk dan buat aplikasi baru dengan nama dan deskripsi.  Kemudian buat 2 lingkungan yang disebutkan sebelumnya: STG dan PROD, buat kedua lingkungan sebagai lingkungan server Web, tentukan "Docker" sebagai platform, dan biarkan aplikasi Sampel sebagai kode aplikasi.  Penempatan ke ElasticBeanstalk dilakukan dengan mengunggah file atau instruksi proyek, biasanya dalam arsip zip.  Dalam kasus kami, alurnya akan seperti ini: kami mengumpulkan gambar buruh pelabuhan dari aplikasi kami, memuatnya ke dalam repositori dan memuat instruksi alih-alih arsip sumber atau gambar buruh pelabuhan, yang memberi tahu ElasticBeanstalk untuk mengambil gambar dari server jarak jauh dan menyebarkannya.  Dan semua ini otomatis. <br><br>  Mari kita mulai dengan membuat repositori untuk menyimpan gambar buruh pelabuhan.  Ada 2 opsi: <br><br>  1 - proyek Anda bersifat pribadi, kodenya tertutup dan repositori, masing-masing, juga harus ditutup.  Dalam hal ini, Anda menyimpan daftar gambar Anda sendiri di suatu tempat atau menggunakan cloud pribadi.  AWS memiliki ECR untuk tujuan ini, Anda dapat membuat repositori di sana, tetapi tidak ada yang memaksa Anda untuk melakukan ini. <br><br>  2 - Anda memiliki proyek sumber terbuka dan Anda dapat menggunakan dockerhub. <br><br>  Dalam contoh kita, kode terbuka, tetapi saya akan menunjukkan cara menggunakan repositori tertutup, setelah memahami proses ini, menghubungkan gambar dari dockerhub tidak akan sulit.  Hal pertama yang kita butuhkan adalah membuat repositori itu sendiri, setelah itu kamu akan mendapatkan URI yang unik.  Narasi selanjutnya akan berlaku untuk pihak ketiga (bukan repositori AWS ECR dan integrasi mereka), untuk ECR saya akan menulis setelah itu. <br><br>  Setelah membuat repositori, kita perlu masuk ke layanan ini dan ada sedikit trik ... Buka pengaturan buruh pelabuhan yang diinstal secara lokal dan periksa apakah Anda memiliki opsi untuk menyimpan kata sandi di penyimpanan eksternal yang dihapus (untuk pengguna macOS: ‚ÄúSimpan login buruh pelabuhan dengan aman di macOS Keychain ‚Äù), jika tidak file konfigurasi yang kita butuhkan akan kosong.  Jadi, kami memberi otorisasi dalam layanan yang dipilih untuk menyimpan register gambar Anda: <br><br><pre> <code class="plaintext hljs">docker login -u LOGIN -p PASSWORD REGISTRY</code> </pre> <br>  setelah otentikasi berhasil, konstruksi berikut akan muncul di file konfigurasi ~ / .docker / config.json: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> }</code> </pre><br>  Jika tidak muncul, periksa konfigurasi buruh pelabuhan yang dijelaskan di atas lagi. <br><br>  Sekarang semuanya siap untuk menyiapkan file instruksi untuk ElasticBeanstalk - Dockerrun.aws.json, kodenya akan seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Secara umum, instruksi terlihat seperti ini: masuk menggunakan kunci yang terletak oleh KEY_PATH di BUCKET_ID penyimpanan S3, muat gambar dengan IMAGE_URL menimpa yang disimpan, mulai dengan meneruskan port 80 ke port yang sama pada wadah.  Sekarang tentang konstanta yang digunakan: <br><br>  BUCKET_ID adalah "backpack" yang secara otomatis dibuat untuk Anda di layanan S3, yang berbentuk elasticbeanstalk-REGION-HASH, di sinilah sistem mencari file layanan untuk ElasticBeanstalk Anda, termasuk file aplikasi yang Anda unduh menggunakan tombol "Unggah dan gunakan". <br><br>  KEY_PATH - path ke file otorisasi ke repositori gambar, saya menggunakan format APP_NAME / cr.json, yaitu, dalam folder di dalam BUCKET_ID dengan nama aplikasi saya (saya membuat, jika belum) saya meletakkan file cr.json yang berisi kode yang diterima setelah otorisasi dalam register. Gambar secara lokal: <br><br><div class="spoiler">  <b class="spoiler_title">BUCKET_ID / APP_NAME / cr.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> } }</code> </pre> </div></div><br>  IMAGE_URL adalah URI unik dari register gambar Anda + tag gambar itu sendiri, semuanya harus jelas di sini. <br><br>  Itu saja, sekarang kita dapat mengunduh file ini sebagai versi aplikasi kita di ElasticBeanstalk, dan dia akan menarik gambar yang ditentukan dan menyebarkannya. <br><br>  Tetap mengotomatiskan proses ini.  Dan untuk menjadi sangat menarik, saya akan menerapkan urutan langkah-langkah untuk aliran berikutnya: untuk semua yang melakukan TIDAK di cabang master, gambar akan dikumpulkan dan digunakan di lingkungan STG, dan jika kita mendorong ke master, atau lebih baik, tutup dan isi dengan permintaan penggabungan , maka kode tersebut akan digunakan pada PROD.  Dengan demikian, kami mendapatkan PROD penyihir terkini, di mana semuanya harus baik-baik saja, dan cabang untuk mengembangkan dan menguji kode baru dalam STG.  Untuk implementasi ini, kita memerlukan instruksi untuk mengunggah gambar yang tidak terbaru, salin Dockerrun.aws.json ke Dockerrun.aws.stg.json, dan ganti nama Dockerrun.aws.json ke Dockerrun.aws.prod.json (hanya untuk kenyamanan). <br><br>  Satu-satunya hal yang membuat Dockerrun.aws.stg.json terpisah dari Dockerrun.aws.prod.json adalah IMAGE_URL: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.stg.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL:dev"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Seperti yang saya katakan di awal artikel, saya akan menggunakan CircleCI sebagai CI / CD, yang, menurut perasaan pribadi saya, lebih cepat daripada GitlabCI jika saya menggunakan versi SaaS gratis.  Free Travis akan melakukannya, tetapi karena tidak bekerja dengan repositori git pribadi, saya tidak secara khusus melakukan demo di dalamnya sehingga tidak akan ada kekecewaan ketika kesempatan seperti itu diperlukan.  Saya akan meninggalkan pengaturan untuk proyek di CircleCI kepada pembaca untuk belajar sendiri, saya akan memberikan instruksi yang diperlukan untuk penyebaran sendiri - di root proyek kami, kami akan membuat folder .circleci, di dalamnya config.yml dengan konten berikut: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>  Saya melukis aliran itu sendiri sedikit lebih awal, di sini diterjemahkan ke dalam yaml-instructions untuk CircleCI, mari kita pergi melalui implementasi langkah-langkah spesifik.  Penting untuk mencatat keberadaan variabel lingkungan yang didefinisikan untuk CI yang akan digunakan olehnya selama bekerja: <br><br>  CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD diperlukan untuk mengakses penyimpanan gambar buruh pelabuhan - hal yang sama yang kami tempatkan di cr.json, hanya tanpa base64 <br><br>  CI_REGISTRY / CI_REGISTRY_ID membuat URL gambar unik, tanpa tag <br><br>  AWS_ACCESS_KEY_ID dan AWS_SECRET_ACCESS_KEY - nama-nama berbicara sendiri, ini adalah kredit AWS untuk pengguna yang atas nama CircleCI akan menyebarkan.  Buka AWS IAM dan buat pengguna, tambahkan dia ke grup administrator dan hanya berikan akses terprogram.  Ingat bahwa AWS_SECRET_ACCESS_KEY hanya tersedia untuk dilihat / disalin satu kali, setelah Anda mengklik tautan acara, Anda tidak akan melihatnya lagi. <br><br>  Kembali ke langkah-langkah konfigurasi CircleCI.  Apa sih sihirnya?  Checkout memuat kode sumber dari cabang git ke direktori kerja saat ini, proses ini diulang dalam setiap pekerjaan.  Dalam proses pembuatan, kami secara berurutan login ke repositori, mengumpulkan kode berdasarkan Dockerfile.stg di bawah tag XXX: dev dan mengirimkannya ke repositori.  build-master melakukan hal yang sama, hanya untuk build itu menggunakan Dockerfile "normal" di bawah tag XXX: latest. <br><br>  deploy-stg menginstal AWS EB CLI dan membuat profil otorisasi dalam file ~ / .aws / config, yang diperlukan agar CLI berfungsi dengan benar, kemudian menginisialisasi variabel untuk CLI - Anda harus menentukan wilayah yang Anda pilih, platform - selalu Docker dan nama aplikasi Anda.  Selanjutnya, kami menyalin konten Dockerrun.aws.stg.json ke file Dockerrun.aws.json yang baru dan, menggunakan lingkungan dan wilayah tertentu, memberikan perintah untuk menyebarkan aplikasi kami menggunakan profil otorisasi yang dibuat.  Secara default, sebagai hasil dari perintah ini, semua kode cabang yang dipantau akan berakhir di arsip zip, yang akan diunduh ke ElasticBeanstalk dan dibongkar di sana, tetapi operasi ini relatif mahal, oleh karena itu kami membuat file Dockerrun.aws.json yang baru, yang cukup untuk digunakan oleh kami. gambar jarak jauh, dan kita hanya perlu mengunggahnya, sebenarnya.  Untuk melakukan ini, buat file .ebignore di root proyek: <br><br><div class="spoiler">  <b class="spoiler_title">.ebignore</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">* !Dockerrun.aws.json</code> </pre></div></div><br>  File ini menggunakan sintaks .gitignore dan itu adalah .gitignore, tetapi tidak untuk Git CLI, tetapi untuk AWS EB CLI.  Dalam file ini, saya memberitahu CLI untuk melewati semua file kecuali Dockerrun.aws.json.  Itu saja, sekarang ketika Anda menjalankan pekerjaan deploy-stg di ElasticBeanstalk, hanya file yang kami buat akan dikirim.  deploy-prod melakukan hal yang sama, hanya menyalin isi file Dockerrun.aws.prod.json ke Dockerrun.aws.json, dan yang terakhir adalah indikasi urutan pekerjaan dalam format CircleCI (deploy-stg setelah build dan deploy-prod setelah build -master), dan pada cabang mana data dicari (abaikan: - master dan hanya: - master). <br><br>  Hal yang sedikit berbeda adalah dengan AWS ECR, seperti yang saya janjikan, kami akan kembali ke sana.  Anda tidak perlu login jarak jauh ke ECR dan membuat file cr.json, karena ElasticBeanstalk "kenal saudara secara langsung".  Dengan demikian, Dockerrun.aws.json akan terlihat berbeda - tidak akan ada blok otentikasi: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json (AWS ECR)</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Tetapi bagaimana kemudian otentikasi akan terjadi?  Faktanya adalah bahwa layanan yang mengakses ECR memiliki seperangkat hak tertentu, yang pada gilirannya didasarkan pada kebijakan keamanan tertentu.  Dalam kasus kami, ketika penyebaran diluncurkan melalui AWS CLI dari server pihak ketiga (dari CI), peran "aws-elasticbeanstalk-ec2-role" digunakan, temukan di AWS IAM di bagian peran dan lampirkan kebijakan tambahan "AmazonEC2ContainerRegistryReadOnly" padanya.  Sekarang mengunduh dari repositori pribadi ke "tetangganya" akan berhasil tanpa kesalahan. <br><br>  Tapi ini persis memuat dari VPC yang sama, melalui CLI perintah login buruh pelabuhan juga bukan "tanpa trik": Anda perlu mendapatkan (hanya mendapatkan) kredit untuk login buruh pelabuhan melalui AWS CLI, untuk ini ada perintah <br><br> <code>aws ecr get-login --region REGION --no-include-email</code> <br> <br>  Perintah ini akan mengembalikan Anda satu baris login form buruh pelabuhan ..., cukup cantumkan, di konsol yang perlu Anda jalankan <br><br> <code>eval $(aws ecr get-login --region EB_REGION --no-include-email)</code> <br> <br>  Perintah pertama akan menerima string untuk otentikasi, dan kemudian memulai proses yang sesuai.  Mengingat aturan ini untuk AWS ECR, file instruksi untuk CircleCI akan terlihat seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml (untuk AWS ECR)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>   docker-in-docker   setup_remote_docker   ,          .   ,       : <br><br><img width="350" src="https://habrastorage.org/webt/7e/cw/sj/7ecwsjkjjmr8myxiuutwkujwnkg.png" alt="gambar"><br><br>   ,     ,     ()      .   ¬´¬ª   .  ( - )  ,      ,         ,                . <br><br>    GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial-aws-symfony-ci</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462415/">https://habr.com/ru/post/id462415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462401/index.html">Pengembang Dosa Mematikan</a></li>
<li><a href="../id462403/index.html">Pemilihan ukuran monitor: teori ukuran sudut, dasar pemikiran dan perbandingan</a></li>
<li><a href="../id462407/index.html">Intisari Desain Makanan Juli 2019</a></li>
<li><a href="../id462409/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 1</a></li>
<li><a href="../id462411/index.html">Pecahkan Sudoku dengan Algoritma X</a></li>
<li><a href="../id462417/index.html">Petisi Apple</a></li>
<li><a href="../id462421/index.html">Apollo Guidance Computer - arsitektur dan perangkat lunak sistem. Bagian 2</a></li>
<li><a href="../id462423/index.html">Manajemen Proyek</a></li>
<li><a href="../id462429/index.html">VueJs + VueRouter + modal. Sepeda lain</a></li>
<li><a href="../id462431/index.html">Intisari materi menarik untuk pengembang seluler # 309 (29 Juli - 4 Agustus)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>