<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 🧔🏽 🤳 Energie, Wärme und Wasser Teil drei: Gehen Sie zum Radio 🚴🏾 🤙🏼 🧟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eintrag 
 Bei der Auswahl von Lösungen für ein Smart Home versuche ich, Boxed-Lösungen zu umgehen, die die Kommunikation mit externen Clouds erfordern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Energie, Wärme und Wasser Teil drei: Gehen Sie zum Radio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467761/"><h2>  Eintrag </h2><br>  Bei der Auswahl von Lösungen für ein Smart Home versuche ich, Boxed-Lösungen zu umgehen, die die Kommunikation mit externen Clouds erfordern oder über eigene Anwendungen verfügen, insbesondere Lösungen, die keine direkte Verbindung zum Gerät herstellen können.  Alle verfügbaren Metriken werden auf eine Schnittstelle reduziert - zabbix, wo ein Stakeholder-Warnsystem organisiert ist.  Steuerknöpfe sind in einer lokal lokalisierten Weboberfläche implementiert. <br><br><h2>  Vorherige Artikel: </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil eins</a> (1Drahttemperatur, Ups, Wasserzähler ...) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil zwei</a> (Netping, Gidrolock, Drucksensoren ...) <br><br><h2>  Gelöste Aufgaben in diesem Artikel </h2><br><ul><li>  Skalierbarer, flexibler Wasserleckschutz mit Zabbix-Alarm </li><li>  Andere Geräte bei 433 MHz: Klingel, Tür offen usw. </li><li>  Wir drücken 1wire in MQTT </li></ul><br><h2>  Auslaufschutzsystem </h2><br><h3>  Systemanforderungen: </h3><br><ul><li>  viele Sensoren im ganzen Haus verteilt (in meinem Fall - 6 Stück an verschiedenen Orten) </li><li>  Keine Kabel an den Sensoren </li><li>  schnelles Herunterfahren bei Lecksuche </li><li>  Alle aktuellen Statusinformationen in zabbix.  Es gibt eine Warnung </li></ul><br><h3>  Systemzusammensetzung </h3><br><ul><li>  Himbeer PI </li><li>  RTL2832U USB-Tuner </li><li>  Lecksensoren 433 MHz </li><li>  Netping + Gidrolock-Kran (siehe vorherigen Artikel) zum Abschalten des Kofferraums </li></ul><a name="habracut"></a><br><h3>  Über Eisen </h3><br>  In einem früheren Artikel habe ich die Lösung zum Absperren der Wasserversorgung mithilfe von Netping beschrieben.  Ich habe einen verdrahteten Sensor für diese Lösung.  Dies ist praktisch, wenn sich alle Stellen, an denen Leckagen auftreten können, ungefähr an derselben Stelle befinden.  In meinem Fall wird Netping direkt am Eingang der Autobahn installiert und steuert den elektromechanischen Gidrolock-Kran an derselben Stelle (siehe vorherigen Artikel).  Das Streuen von Netping + Gidrolock + verdrahtetem Sensor an allen Stellen ist teuer und umständlich.  Außerdem habe ich keine Möglichkeit mehr, neue Drähte um das Haus zu ziehen.  Das Besetzen von Steckdosen und das Einatmen von Elektrokränen ist eine mittelmäßige Lösung.  Die erwartete Lösung - wir verwenden die Überlappung der gemeinsamen Autobahn basierend auf Signalen von Funksensoren, die über die Standorte verteilt sind. <br>  Nach dem, was im Internet gefunden wurde - eine Reihe verschiedener Funksensoren aus vorgefertigten Systemen.  Einige können separat gekauft werden, ich habe keine Controller für Sensoren gekauft, um keine zusätzlichen Elemente in der Schaltung zu produzieren. <br><br>  Wie kann ich 433 MHz fangen?  Es stellt sich heraus - ein TV-Tuner auf einem bestimmten Chipsatz.  Und jetzt ist er einen Cent wert (ich habe Avito für 300r übernommen) wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b84/efb/7c8/b84efb7c88ad3e4a89edbb470a653843.png" alt="Bild"><br><br>  Ich habe eine separate Antenne für 12dbi bestellt, da die aktuelle nicht das ganze Haus abdeckte. <br><br>  Da ich versuchte, die Steuerungskomponenten der Schaltung zu minimieren, bestand der Wunsch, den Tuner mit Openwrt, das bis dahin der Kern der Smart-Home-Lösung für 1wire-, Modbus- und WLAN-Sensoren / -Protokolle war, in meinem Heimrouter festzuziehen, aber leider habe ich einige seiner Ressourcen erschöpft ( Der Speicherplatz auf dem eingebauten Flash-Laufwerk für die erforderliche Software endet, der Prozessor lädt mit etwas - es wird bereits Probleme mit dem Netzwerk geben, und wir müssen noch 4k online suchen :), + es hängen bereits zu viele Dinge an USB, was die Stabilität der Datenerfassung beeinträchtigt.  Es wurde beschlossen, die Funktionalität des Smart Home schrittweise auf ein externes Gerät zu übertragen - rarpberry pi (eine der ersten Versionen war verfügbar). <br><br><h3>  Über Software </h3><br>  Nachdem ich mit einem sdr-scharfen TV-Tuner auf einem Desktop-Computer mit Fenstern gespielt hatte (nachdem ich versucht hatte, die Radios und Flugzeugverhandlungen anderer Leute zu erfassen), begann ich zu sehen, ob die Sensoren selbst das „Pfeifen“ sahen.  Ja, es sieht perfekt aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37e/68a/4d6/37e68a4d69b575f74e47db6ae45b0d4b.jpg" alt="Bild"><br><br><h4>  Himbeereinstellung </h4><br>  Ich entschied mich für einheimische Raspbian.  Ich habe das letzte Bild auf dem USB-Stick unter Mac / Linux geschrieben: <br><br><pre><code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=2019-07-10-raspbian-buster-lite.img of=/dev/disk2 bs=1048576 conv=sync</code> </pre> <br>  Booten Sie, konfigurieren Sie das Netzwerk und ssh. <br><br>  Weiter - setzen Sie die Himbeer-Pakete rtl-sdr, rtl_433: <br><br><pre> <code class="bash hljs">sudo apt-get install cmake build-essential python-pip libusb-1.0-0-dev libusb-1.0 python-numpy git git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/merbanan/rtl_433.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rtl_433/ mkdir build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build cmake .. make make install</code> </pre> <br>  rtl_433 verfügt über integrierte Protokolle, die Daten von verschiedenen Geräten im Bereich von 433 MHz entschlüsseln. <br><br><h4>  Wir starten rtl_433 </h4><br><pre> <code class="bash hljs">rtl_433 -f 433.9e6</code> </pre> <br>  Wir senken die Sensoren ins Wasser und bekommen die geschätzten: <br><br><pre> <code class="bash hljs">time : 2019-09-17 15:04:39 model : Smoke detector GS 558 id : 16919 unit : 1 learn : 0 Raw Code : c842e1</code> </pre><br>  Rauchmelder?  Ok, lassen Sie uns das Lied "Smoke on the water" von diesen Sensoren alarmieren ... :) <br>  Aber im Ernst - wir haben die ID jedes Sensors, nach der wir in Zukunft verstehen werden, wo genau wir ein Leck haben (und wir werden auf jeden Fall abschalten). <br><br><h4>  Über Lecksensoren </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/47a/255/60d/47a25560dd09554b0749dc171502c71b.png" alt="Bild"><img src="https://habrastorage.org/getpro/habr/post_images/710/dd8/917/710dd891751f85699ed64c30b180c443.png" alt="Bild"><img src="https://habrastorage.org/getpro/habr/post_images/b56/f4b/a31/b56f4ba310bd674da8b16171c5112806.png" alt="Bild"><br><br>  Nach dem Einrichten des Softwareteils bemerkte ich, dass die Sensoren mit aliexpress (linkes Foto) ein einzelnes Signal senden, wenn Wasser in die Kontakte gelangt.  Plus ein einzelnes Signal, wenn das Wasser die Kontakte nicht mehr schließt.  Dies passt in keiner Weise zu mir (erwartetes Verhalten: Senden Sie ständig ein Alarmsignal, wenn der Sensor Wasser erkennt, da ein einzelnes Signal verloren gehen kann).  Ein ähnliches Verhalten wird beobachtet, wenn Sie die Kontakte mit einem Draht schließen.  Aber was seltsam ist - Alarm tritt alle 2-3 Sekunden auf, wenn Sie die Kontakte mit Ihren Händen (Haut) schließen.  Hier habe ich noch zwei Annahmen: Entweder haben die Chinesen Widerstandsmessungen vermasselt, oder die Sensoren haben eine andere Betriebsart, in der sie sich irgendwie anders verhalten (zum Beispiel gepaart mit einem Controller), oder es gibt andere Frequenzen (bis ich sie gefunden habe) ) <br><br>  <i>Übrigens, schreiben Sie in die Kommentare, vielleicht hat jemand mit diesen Sensoren gearbeitet. Kann man ihnen irgendwie "beibringen", ständig ein Signal über ein Leck zu senden?</i> <br><br>  Ich legte diese Sensoren beiseite, im Arsenal befand sich ein weiterer von Rubetek (rechtes Foto) und kaufte in Leroy: GAL SHW-1005 (mittleres Foto). <br><br>  Das Verhalten des Rubetek-Sensors schien völlig unvorhersehbar (die unvorhersehbare Reaktion „sieht Wasser / sieht nicht“). <br><br>  Aber der Sensor von Leroy in Bewegung zeigte genau das, was ich brauchte: Es gibt Wasser - ich spamme es in der Luft, es gibt kein Wasser - ich schweige.  Das einzige Minus ist ein kleinerer Aktionsradius als bei anderen Sensoren.  Das Problem wurde jedoch durch den Kauf einer empfindlicheren Antenne für den Empfänger gelöst. <br><br><h4>  MQTT </h4><br>  Wie sende ich eine rtl_433-Ausgabe an zabbix?  Den Agenten füttern?  An zabbix_sender senden und den Prozess analysieren?  Vielleicht durch Syslog? <br><br>  Hier müssen Sie sich daran erinnern, dass mein Zabbix irgendwo in den Wolken ist.  Und sicherlich ist es nicht notwendig, das Wasser mit Hilfe seiner Auslöser zu blockieren.  Der Boden des Hauses wird überflutet, bis er eine Entscheidung trifft (falls überhaupt verfügbar). <br><br>  Die gute Nachricht ist, dass rtl_433 Informationen über MQTT senden kann.  Out of the Box.  Gleichzeitig werden Daten im JSON-Format an den Broker gesendet. <br><br>  Sie brauchen also: <br><br><ul><li>  Platzieren Sie einen lokalen Mückenmakler (tun Sie es auf der Himbeere). </li><li>  Führen Sie die Informationen mit dem gewünschten Thema in den Broker ein, damit sie später analysiert werden können. </li><li>  Stellen Sie eine lokale Verbindung zum Broker auf der Himbeere her und senden Sie Befehle an netping </li><li>  Stellen Sie von dem Ort aus, an dem die Umleitung zu zabbix erfolgen soll, eine Verbindung zum Broker her (der zabbix-Server ist in meinem Fall auch ein MQTT-Client). </li></ul><br><h4>  Installations-Setup-Mücke MQTT: </h4><br><pre> <code class="bash hljs">apt-get install mosquitto mosquitto-clients systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> mosquitto systemctl start mosquitto</code> </pre> <br><h4>  Wir senden dem Broker Informationen mit der Geräte-ID: </h4><br><pre> <code class="bash hljs">rtl_433 -f 433.88e6 -F mqtt://127.0.0.1,events=/433/[id]</code> </pre> <br>  Im mqtt-Client erhalten wir ungefähr Folgendes: <br><br><pre> <code class="bash hljs">mosquitto_sub -h 127.0.0.1 -t <span class="hljs-string"><span class="hljs-string">'#'</span></span> (   ) /433/16919 {<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-18 11:55:29"</span></span>,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Smoke detector GS 558"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:16919,<span class="hljs-string"><span class="hljs-string">"unit"</span></span>:1,<span class="hljs-string"><span class="hljs-string">"learn"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-string"><span class="hljs-string">"c842e1"</span></span>}</code> </pre> <br><h4>  Skript zum Herstellen einer Verbindung zum Broker und zum Senden des Befehls an netping </h4><br>  Ich habe einen einfachen MQTT-Skriptclient entworfen, mit dem Sie das dem Thema zugeordnete Skript ausführen können, wenn das in der Konfiguration angegebene Thema angezeigt wird.  Wenn also ein bestimmter Sensor ausgelöst wird und Informationen darüber in der Luft angezeigt werden (z. B. / 433/16919), können Sie eine Aktion ausführen (im Falle eines Netzes senden Sie eine Curl-Anforderung zum Schließen des Krans, siehe vorherigen Artikel).  Ein Link zum Skript befindet sich am Ende des Artikels. <br><br><h4>  Umleitung in zabbix </h4><br>  Ich habe die fertige mqtt-zabbix-Lösung verwendet.  Auf seiner Ebene verstehen wir, in welchem ​​Element der Wert gesendet werden soll (anhand der ID). <br><br>  Geben Sie in keys.cfg Folgendes an: <br><br><pre> <code class="bash hljs">/433/16919,mqtt.ventilation.waterleak::hostname</code> </pre> <br>  Dabei ist Hostname der Hostname mit dem Elementtramp-Typ in Zabbix. <br><br>  Wichtig !!!  Der Hostname in den Einstellungen sollte dem Namen entsprechen, der im Skript gesendet werden soll. Der Elementtyp (Datenelement) sollte für die gesendeten Daten geeignet sein (z. B. für json - text), da sonst Fehler des Formulars auftreten: <br><br><pre> <code class="bash hljs">2019-09-18 14:29:48,749 Got response from Zabbix: {u<span class="hljs-string"><span class="hljs-string">'info'</span></span>: u<span class="hljs-string"><span class="hljs-string">'processed: 0; failed: 1; total: 1; seconds spent: 0.000055'</span></span>, u<span class="hljs-string"><span class="hljs-string">'response'</span></span>: u<span class="hljs-string"><span class="hljs-string">'success'</span></span>}</code> </pre> <br>  Darüber hinaus ist es schwierig, mehr Debugging (und warum fehlgeschlagen) von zabbix zu erreichen. <br><br>  Wir konfigurieren /etc/mqtt-zabbix/mqtt-zabbix.cfg (geben Sie den ip mqtt-Broker und die Adresse des zabbix-Servers an). <br><br><h3>  Was kann man noch mit 433 verbinden? </h3><br>  <i>Ja, alles!</i>  <i>:) :)</i> <br><br><h4>  Wetterstationssensoren </h4><br>  Beim Basteln mit drahtlosen Lecksensoren habe ich versehentlich das Signal eines externen Sensors von einer Wetterstation abgefangen.  Es sah so aus: <br><br><pre> <code class="bash hljs">time : 2019-09-19 10:48:54 Protocol : 56 model : TFA pool temperature sensor Id : 182 Channel : 3 Temperature: 19.3 C Modulation: ASK Freq : 433.9 MHz RSSI : -0.1 dB SNR : 35.0 dB Noise : -35.2 dB time : 2019-09-20 10:57:29 Protocol : 12 brand : OS model : THN132N House Code: 4 Channel : 3 Battery : OK Celsius : 20.00 C Modulation: ASK Freq : 432.9 MHz RSSI : -0.2 dB SNR : 31.5 dB Noise : -31.7 dB</code> </pre><br>  Der Bonus war somit die Möglichkeit, die Temperatur der Punkte über Luft mit Anzeige in Zabbix zu überwachen.  Nur in einigen Räumen kann ich das Kabel nicht dehnen. <br><br><h4>  Türklingel </h4><br>  Viele Funkanrufe arbeiten im gleichen Frequenzbereich von ~ 433 MHz.  Auf diese Weise können wir das Drücken der Anruftaste abfangen (es ist nicht einmal erforderlich, den Anruf selbst zu tätigen, nur die Taste reicht aus).  Warum?  Zum Beispiel, um zusätzliche Benachrichtigungen per SMS / Telegramm / was auch immer zu konfigurieren oder das Bild von der Kamera auf dem Monitor anzuzeigen. <br><br>  Ich habe einen Anruf gekauft: Evology QA-688-E RU. <br><br>  Damit die Schaltfläche rtl_433 die Anruftaste anzeigt, müssen Sie die Testprotokolle aktivieren, indem Sie beispielsweise die Option „G“ ausführen oder ein bestimmtes zusätzliches Protokoll angeben. Gleichzeitig fügen wir die Ausgabe von Informationen über das Protokoll und die Häufigkeit hinzu: <br><br><pre> <code class="bash hljs">rtl_433 -f 433.9e6 -G -M protocol -M level -F mqtt://127.0.0.1,events=/433/[id] &amp;</code> </pre> <br>  Holen Sie sich in MQTT: <br><br><pre> <code class="bash hljs">{<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 10:57:00"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:72,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"RF-tech"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"battery"</span></span>:<span class="hljs-string"><span class="hljs-string">"LOW"</span></span>,<span class="hljs-string"><span class="hljs-string">"temperature_C"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"button"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.84822,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-3.5981,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:33.77488,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-37.373}</code> </pre> <br>  Hier sehen Sie id = 0.  Gleichzeitig ließ ich mehrere Geräte als RF-Tech identifizieren.  Alle hatten eine ID gleich 0. Daher werden alle Geräte in zabbix als ein Element angezeigt.  Es ist nur anhand der Frequenz möglich, genau zu unterscheiden, welches Gerät funktioniert hat. <br><br>  Wir ziehen die Frequenz in ein separates abhängiges Element: mqtt.outside.doorbell.freq mit JSON-Vorverarbeitung bei $ .freq (zabbix kann dies ab der 4. Version tun). <br><br>  Machen Sie für dieses Element einen Trigger mit dem Ausdruck: <br><br><pre> <code class="bash hljs">{HOME_PI:mqtt.outside.doorbell.freq.last()}&gt;433.8 and {HOME_PI:mqtt.outside.doorbell.freq.last()}&lt;433.81 and {HOME_PI:mqtt.outside.doorbell.freq.nodata(30)}=0</code> </pre> <br>  Das heißt,  Wenn plötzlich ein Wert im allgemeinen Element mqtt.outside.doorbell.freq (nodata) erscheint und die Häufigkeit im angegebenen Bereich zwischen 433,8 und 433,81 liegt, können wir daraus schließen, dass sie uns anrufen (und beispielsweise einen Anruf bei SMS duplizieren). <br><br><h4>  Tür- / Fenstersensoren </h4><br>  Ich habe einen Penetrationssensor von Rubetek.  Sendet Folgendes: <br><br><pre> <code class="bash hljs">{<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 14:11:28"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:86,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Smoke detector GS 558"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:12262,<span class="hljs-string"><span class="hljs-string">"unit"</span></span>:16,<span class="hljs-string"><span class="hljs-string">"learn"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-string"><span class="hljs-string">"e5fcd0"</span></span>,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.85021,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-3.99241,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:33.38058,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-37.373}  : {<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 14:11:28"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:68,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Kerui Security"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:46074,<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>:7,<span class="hljs-string"><span class="hljs-string">"state"</span></span>:<span class="hljs-string"><span class="hljs-string">"close"</span></span>,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.85021,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-3.99241,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:33.38058,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-37.373}  : {<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 14:11:21"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:68,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Kerui Security"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:46074,<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>:14,<span class="hljs-string"><span class="hljs-string">"state"</span></span>:<span class="hljs-string"><span class="hljs-string">"open"</span></span>,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.85005,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-11.0148,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:25.1088,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-36.1236}</code> </pre> <br>  Sobald der letzte Funksensor zu zabbix hinzugefügt wurde, wollte ich alles auf MQTT wiederholen.  Bequeme Katalogisierung, Sie können das Thema-ah sowie die Platzierung und Typen von Geräten bestimmen.  Sie erhalten die allgemeine Übertragung aller Ereignisse. <br><br><h2>  1Wire zu MQTT </h2><br>  Ich möchte, dass alles in MQTT ist, zumindest für die gleiche Art der Implementierung.  Ich möchte einen allgemeinen "Äther" der Ereignisse und einen allgemeinen Ansatz als Reaktion auf diese Ereignisse erhalten.  Natürlich löst zabbix das Reaktionsproblem und ich hinterlasse Warnungen.  Aber ich möchte das Management unbeschwerter machen, nah am System und am "Äther". <br><br>  Es gibt vorgefertigte Lösungen für die Weiterleitung von Sensorzuständen von einem 1-Draht-Netzwerk an MQTT, aber sie passten nicht zu mir.  Vorgefertigte Lösungen auf dem Knoten enthalten entweder eine Reihe von Abhängigkeiten oder den gesamten Himbeerprozessor.  Einige der Lösungen aus den Top 10 der Google-Suche werden von den Autoren aufgegeben, andere werden nur von Temperatursensoren unterstützt.  Es gibt auch eine Klasse von Gateways, die Informationen über die GPIO-Schnittstelle sammeln.  Das alles passte nicht zu mir. <br><br>  Ich habe ein gemountetes Pseudo-Dateisystem mit 1wire-Geräten in / mnt / 1wire. Dort möchte ich alle erforderlichen Informationen abrufen.  Um dies zu tun, reicht es aus, eine einfache einzeilige Bash zu erstellen und Daten für jeden der Sensoren über mosquitto_pub zu senden.  Es gibt jedoch Fragen zum Starten dieser Skripte (über die Krone, um in eine Art Dämon zu fahren?), Zur normalen Darstellung von Daten (mit demselben JSON), zum Hinzufügen eines neuen Sensors usw. Je weiter sich der Gedanke entwickelte, desto mehr Krücken wurden geboren.  Es stellte sich heraus, dass es einfacher war, ein Gateway für ein weiteres Owfs zu mqtt für diese Aufgabe zu schreiben. <br><br>  Es gibt eine Konfigurationsdatei, in der wir die ID der Sensoren und die Dateien von fuse.OWFS eingeben müssen, die wir in mqtt veröffentlichen möchten. <br><br>  Die Ausgabe in mqtt ist die folgende json: <br><br><pre> <code class="bash hljs">/1wire/28.0425260a0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"30"</span></span>} /1wire/28.bf16270a0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"7.9375"</span></span>} /1wire/26.da2f71010000 {<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"25.2812"</span></span>, <span class="hljs-string"><span class="hljs-string">"IAD"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"CA"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"VAD"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.91"</span></span>, <span class="hljs-string"><span class="hljs-string">"VDD"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.59"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS2438"</span></span>} /1wire/28.48b3010b0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"40.5625"</span></span>} /1wire/1d.6a9306000000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS2423"</span></span>, <span class="hljs-string"><span class="hljs-string">"counter.B"</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>, <span class="hljs-string"><span class="hljs-string">"counter.A"</span></span>: <span class="hljs-string"><span class="hljs-string">"9219"</span></span>} /1wire/28.61cc260a0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"12.5"</span></span>}</code> </pre> <br>  Zum Autorun hinzufügen, das Abfrageintervall festlegen.  Das Problem ist gelöst. <br><br><h3>  Referenzen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/merbanan/rtl_433</a> - ein Tool zum Dekodieren von Funkprotokollen <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/kylegordon/mqtt-zabbix</a> - MQTT auf Zabbix <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/unlo/1wire2mqtt</a> - 1wire in MQTT, MQTT-Client, mit dem Sie Skripts ausführen können, wenn das Thema angezeigt wird </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467761/">https://habr.com/ru/post/de467761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467749/index.html">GCP: Analysieren des Google Cloud Platform Computing Stack</a></li>
<li><a href="../de467751/index.html">Wie funktioniert ein dezentraler Messenger in der Blockchain?</a></li>
<li><a href="../de467753/index.html">Weltrekord für drahtlose Datenübertragung: 40 Gbit / s pro 11 Kilometer</a></li>
<li><a href="../de467755/index.html">Prionen, Kalzium, Mikrobiota, Nahrungshormone und Alzheimer</a></li>
<li><a href="../de467759/index.html">Unix-ähnliches Betriebssystemdesign - Virtueller Adressraum (6)</a></li>
<li><a href="../de467763/index.html">Die ganze Wahrheit über RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE</a></li>
<li><a href="../de467765/index.html">Wi-Fi und viele andere Abkürzungen. So erhalten Sie Daten auf Wi-Fi-Knoten in einer Android-Anwendung und schwellen nicht an</a></li>
<li><a href="../de467767/index.html">Weitere Annehmlichkeiten für JSON-RPC-Follower</a></li>
<li><a href="../de467769/index.html">Auf einer einzigen Bundesinformationsquelle, die Bevölkerungsinformationen enthält</a></li>
<li><a href="../de467773/index.html">Beschaffung ungewöhnlicher Ressourcen und Erstkontakt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>