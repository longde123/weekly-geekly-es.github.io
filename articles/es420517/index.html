<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåô ü§¥ üßúüèº Implementaci√≥n FPGA Integer FFT üß† üôÖüèº üöè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Una vez, los clientes me preguntaron si ten√≠a FFT entera en mis proyectos, a lo que siempre respond√≠ que esto ya lo hab√≠an hecho otro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci√≥n FPGA Integer FFT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420517/"> Hola a todos! <br><br>  Una vez, los clientes me preguntaron si ten√≠a FFT entera en mis proyectos, a lo que siempre respond√≠ que esto <u>ya lo hab√≠an hecho otros</u> en forma de n√∫cleos IP listos para usar, aunque curvos, pero libres (Altera / Xilinx): t√≥malo y √∫salo.  Sin embargo, estos n√∫cleos <b>no</b> son <b>√≥ptimos</b> , tienen un conjunto de "caracter√≠sticas" y requieren un mayor refinamiento.  En este sentido, despu√©s de haber ido a otras vacaciones planificadas, que no quer√≠a pasar mediocres, comenc√© a implementar el kernel configurable del entero FFT. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (proceso de depuraci√≥n de errores de desbordamiento de datos)</i></sub> <br><br>  En el art√≠culo quiero decirle por qu√© m√©todos y medios se realizan las operaciones matem√°ticas al calcular la transformada r√°pida de Fourier en un formato entero en cristales modernos de FPGA.  La base de cualquier FFT es un nodo llamado "mariposa".  La mariposa implementa operaciones matem√°ticas: suma, multiplicaci√≥n y sustracci√≥n.  Se trata de la implementaci√≥n de la "mariposa" y sus nodos terminados que la historia ir√° primero.  Basado en las modernas familias Xilinx FPGA: esta es la serie Ultrascale y Ultrascale +, as√≠ como las series m√°s antiguas 6- (Virtex) y 7- (Artix, Kintex, Virtex) se ven afectadas.  Las series m√°s antiguas en proyectos modernos no son de inter√©s en 2018.  El prop√≥sito del art√≠culo es revelar las caracter√≠sticas de la implementaci√≥n de n√∫cleos personalizados de procesamiento de se√±ales digitales utilizando el ejemplo de una FFT. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Para nadie es un secreto que los algoritmos para tomar FFT est√°n firmemente arraigados en la vida de los ingenieros de procesamiento de se√±ales digitales y, por lo tanto, esta herramienta se necesita constantemente.  Los principales fabricantes de FPGA como Altera / Xilinx ya tienen n√∫cleos FFT / IFFT configurables flexibles, pero tienen una serie de limitaciones y caracter√≠sticas, y por lo tanto he tenido que usar mi propia experiencia m√°s de una vez.  As√≠ que esta vez tuve que implementar una FFT en un formato entero de acuerdo con el esquema Radix-2 en el FPGA.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi √∫ltimo art√≠culo, ya hice FFT</a> en formato de coma flotante, y desde all√≠ sabes que el algoritmo con doble paralelismo se usa para implementar el FFT, es decir, el <b>n√∫cleo puede procesar dos muestras complejas con la misma frecuencia</b> .  Esta es una caracter√≠stica clave de FFT que no est√° disponible en los n√∫cleos preparados de Xilinx FFT. <br><br>  <i>Ejemplo:</i> se requiere desarrollar un nodo FFT que realice una operaci√≥n continua del flujo de entrada de n√∫meros complejos a una frecuencia de 800 MHz.  El n√∫cleo de Xilinx no extraer√° esto (las frecuencias de reloj de procesamiento alcanzables en los FPGA modernos son del orden de 300-400 MHz), o requerir√° diezmar el flujo de entrada de alguna manera.  El n√∫cleo personalizado le permite registrar dos muestras de entrada a una frecuencia de 400 MHz sin intervenci√≥n previa, en lugar de una sola muestra a 800 MHz.  Otra <u>desventaja del n√∫cleo Xilinx FFT es la incapacidad de aceptar el flujo de entrada en orden de inversi√≥n de bits</u> .  En este sentido, se gasta un enorme recurso de memoria de chip FPGA para reorganizar los datos en un orden normal.  Para tareas de convoluci√≥n r√°pida de se√±ales, cuando dos nodos FFT se encuentran uno detr√°s del otro, esto puede convertirse en un momento cr√≠tico, es decir, la tarea simplemente no estar√° en el chip FPGA seleccionado.  El n√∫cleo FFT personalizado le permite recibir datos en el orden normal en la entrada y emitirlos en modo bit-reverse, mientras que el n√∫cleo del FFT inverso, por el contrario, recibe datos en orden bit-reverse y los emite en modo normal.  ¬°Se guardan dos memorias intermedias para la permutaci√≥n de datos a la vez! <br><br>  Como la mayor parte del material de este art√≠culo podr√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superponerse con el anterior</a> , decid√≠ centrarme en el tema de las operaciones matem√°ticas en formato entero en FPGA para la implementaci√≥n de FFT. <br><br><h3>  Par√°metros del kernel FFT </h3><br><ul><li>  <i>NFFT</i> - n√∫mero de mariposas (longitud FFT), </li><li>  <i>DATA_WIDTH</i> : profundidad de bits de los datos de entrada (4-32), </li><li>  <i>TWDL_WIDTH</i> : profundidad de bits de los factores de giro (8-27). </li><li>  <i>SERIE</i> : define la familia FPGA en la que se implementa el FFT ("NUEVO" - Ultrascale, "OLD" - 6/7 Xilinx FPGA series). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Al igual que cualquier otro enlace en el circuito, el FFT tiene puertos de control de entrada: una se√±al de reloj y un reinicio, as√≠ como puertos de datos de entrada y salida.  Adem√°s, la se√±al USE_FLY se usa en el n√∫cleo, lo que le permite desactivar din√°micamente las mariposas FFT para los procesos de depuraci√≥n o para ver la secuencia de entrada original. <br><br>  La siguiente tabla muestra la cantidad de recursos FPGA utilizados, dependiendo de la longitud de la NFFT FFT para DATA_WIDTH = 16 y dos bits TWDL_WIDTH = 16 y 24 bits. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  El n√∫cleo en NFFT = 64K es estable a la frecuencia de procesamiento <b>FREQ = 375 MHz</b> en un cristal Kintex-7 (410T). <br><br><h3>  Estructura del proyecto </h3><br><br>  El gr√°fico esquem√°tico del nodo FFT se muestra en la siguiente figura: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  Para la conveniencia de comprender las caracter√≠sticas de ciertos componentes, dar√© una lista de archivos de proyecto y su breve descripci√≥n en un orden jer√°rquico: <br><ul><li>  <b>Granos FFT:</b> <br><ul><li>  <i>int_fftNk</i> - nodo FFT, circuito Radix-2, decimaci√≥n de frecuencia (DIF), el flujo de entrada es normal, el flujo de salida es bit-reverse. </li><li>  <i>int_ifftNk</i> : nodo <i>OBPF</i> , circuito Radix-2, decimaci√≥n de tiempo (DIT), el flujo de entrada es de inversi√≥n de bits, el flujo de salida es normal. </li></ul></li><li>  <b>Mariposas</b> <br><br><ul><li>  <i>int_dif2_fly</i> - mariposa Radix-2, diezmado en frecuencia, </li><li>  <i>int_dit2_fly</i> - mariposa Radix-2, diezmado en el tiempo, </li></ul></li><li>  <b>Multiplicadores complejos:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - multiplicador configurable general, incluye: </li><li>  <i>int_cmult18x25_dsp48</i> : multiplicador para peque√±as <i>profundidades de</i> bits <i>de los</i> datos y factores de rotaci√≥n, </li><li>  <i>int_cmult_dbl18_dsp48</i> - multiplicador duplicado, ancho de bit de los factores de giro hasta 18 bits, </li><li>  <i>int_cmult_dbl35_dsp48</i> - multiplicador duplicado, ancho de bits de los factores de rotaci√≥n de hasta 25 * bits, </li><li>  <i>int_cmult_trpl18_dsp48</i> - multiplicador triple, la capacidad de los factores de giro de hasta 18 bits, </li><li>  <i>int_cmult_trpl52_dsp48</i> - multiplicador triple, la capacidad de los factores de rotaci√≥n de hasta 25 * bits, </li></ul></li><li>  <b>Multiplicadores</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> : un multiplicador con bits de operandos de hasta 42 y 18 bits basado en DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> : multiplicador con bits de operando de hasta 59 y 18 bits basados ‚Äã‚Äãen DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> : un multiplicador con bits de operandos de hasta 35 y 25 bits basado en DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> : un multiplicador con bits de operandos de hasta 52 y 25 bits basado en DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> : multiplicador con bits de operandos de hasta 44 y 18 bits basados ‚Äã‚Äãen DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> : multiplicador con bits de operando de hasta 61 y 18 bits basados ‚Äã‚Äãen DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> : multiplicador con bits de operando de hasta 35 y 27 bits basados ‚Äã‚Äãen DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> es un multiplicador con bits de operando de hasta 52 y 27 bits basado en DSP48E2. </li></ul></li><li>  <b>Totalizador:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - sumador universal, bits de operando de hasta 96 bits. </li></ul></li><li>  <b>L√≠neas de retraso:</b> <br><br><ul><li>  <i>int_delay_line</i> : la l√≠nea de base de la demora, proporciona una permutaci√≥n de datos entre mariposas, </li><li>  <i>int_align_fft</i> : alineaci√≥n de los datos de entrada y los factores de giro en la entrada de la mariposa FFT, </li><li>  <i>int_align_fft</i> : alineaci√≥n de los datos de entrada y los factores de giro en la entrada de la mariposa <i>OBPF</i> , </li></ul></li><li>  <b>Factores rotativos:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> : un generador de factores rotativos, a partir de una cierta longitud, la FFT considera coeficientes basados ‚Äã‚Äãen celdas FPGA DSP, </li><li>  <i>row_twiddle_tay</i> - generador de factores rotativos usando una serie Taylor (NFFT&gt; 2K) **. </li></ul></li><li>  <b>B√∫fer de datos:</b> <br><br><ul><li>  <i>inbuf_half_path</i> - buffer de entrada, recibe el flujo en el modo normal y produce dos secuencias de muestras desplazadas a la mitad de la longitud del FFT ***, </li><li>  <i>outbuf_half_path</i> : el b√∫fer de salida, recopila dos secuencias y produce una continua igual a la longitud de la FFT, </li><li>  <i>iobuf_flow_int2</i> : el b√∫fer funciona en dos modos: recibe un flujo en modo Intercalaci√≥n-2 y produce dos secuencias de FFT desplazadas a la mitad de la longitud.  O viceversa, dependiendo de la opci√≥n BITREV. </li><li>  <i>int_bitrev_ord</i> es un simple convertidor de datos de orden natural a bit-reverse. </li></ul></li></ul><br>  <i>* - para DSP48E1: 25 bits, para DSP48E2 - 27 bits.</i> <br>  <i>** - a partir de una determinada etapa de la FFT, se puede usar una cantidad fija de memoria de bloque para almacenar coeficientes de rotaci√≥n, y se pueden calcular coeficientes intermedios utilizando nodos DSP48 usando la f√≥rmula de Taylor para la primera derivada.</i>  <i>Debido al hecho de que el recurso de memoria es m√°s importante para la FFT, puede sacrificar de forma segura las unidades inform√°ticas por el bien de la memoria.</i> <i><br></i>  <i>*** - buffer de entrada y l√≠neas de retardo - hacen una contribuci√≥n significativa a la cantidad de recursos de memoria FPGA ocupados</i> <br><br>  <b>Mariposa</b> <br><br>  Todos los que han encontrado al menos una vez el algoritmo de transformaci√≥n r√°pida de Fourier saben que este algoritmo se basa en una operaci√≥n elemental: una "mariposa".  Convierte el flujo de entrada multiplicando la entrada por el factor twiddle.  Existen dos esquemas de conversi√≥n cl√°sicos para FFT: diezmado en frecuencia (DIF, diezmado en frecuencia) y diezmado en tiempo (DIT, diezmado en tiempo).  El algoritmo DIT se caracteriza por dividir la secuencia de entrada en dos secuencias de media duraci√≥n, y el algoritmo DIF en dos secuencias de muestras pares e impares de duraci√≥n NFFT.  Adem√°s, estos algoritmos difieren en operaciones matem√°ticas para la operaci√≥n de mariposa. <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - pares de entrada de muestras complejas, <br>  <i>X, Y</i> - pares de salida de muestras complejas, <br>  <i>W</i> - factores de giro complejos. <br><br>  Dado que los datos de entrada son cantidades complejas, la mariposa requiere un multiplicador complejo (4 operaciones de multiplicaci√≥n y 2 operaciones de suma) y dos sumadores complejos (4 operaciones de suma).  Esta es toda la base matem√°tica que debe implementarse en el FPGA. <br><br><h3>  Multiplicador </h3><br>  Cabe se√±alar que todas las operaciones matem√°ticas en FPGA a menudo se realizan en c√≥digo adicional (complemento de 2).  El multiplicador de FPGA se puede implementar de dos maneras: en la l√≥gica usando disparadores y tablas LUT, o en unidades especiales de c√°lculo DSP48, que se han incluido larga y firmemente en todos los FPGA modernos.  En los bloques l√≥gicos, la multiplicaci√≥n se implementa utilizando el algoritmo Booth o sus modificaciones, ocupa una cantidad decente de recursos l√≥gicos y no siempre satisface las limitaciones de tiempo a altas frecuencias de procesamiento de datos.  En este sentido, los multiplicadores de FPGA en proyectos modernos casi siempre se dise√±an en base a nodos DSP48 y solo ocasionalmente en l√≥gica.  Un nodo DSP48 es una celda terminada compleja que implementa funciones matem√°ticas y l√≥gicas.  Operaciones b√°sicas: multiplicaci√≥n, suma, resta, acumulaci√≥n, contador, operaciones l√≥gicas (XOR, NAND, AND, OR, NOR), cuadratura, comparaci√≥n de n√∫meros, desplazamiento, etc.  La siguiente figura muestra la celda DSP48E2 para la familia Xilinx Ultrascale + FPGA. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  Mediante una configuraci√≥n simple de los puertos de entrada, operaciones de c√°lculo en los nodos y la configuraci√≥n de retrasos dentro del nodo, puede hacer una trilladora de datos matem√°ticos de alta velocidad. <br>  Tenga en cuenta que todos los principales proveedores de FPGA en el entorno de desarrollo tienen n√∫cleos IP est√°ndar y gratuitos para calcular funciones matem√°ticas basadas en el nodo DSP48.  Le permiten calcular funciones matem√°ticas primitivas y establecer varios retrasos en la entrada y salida del nodo.  Para Xilinx, este es el "multiplicador" IP-Core (ver. 12.0, 2018), que le permite configurar el multiplicador a cualquier profundidad de bits de datos de entrada de 2 a 64 bits.  Adem√°s, puede especificar c√≥mo se implementa el multiplicador: en recursos l√≥gicos o en primitivas DSP48 incorporadas. <br><br>  <b>Calcule cu√°nta l√≥gica "come" el multiplicador</b> con la profundidad de bits de los datos de entrada en los puertos A y B = 64 bits.  Si usa los nodos DSP48, necesitar√°n solo 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  La principal limitaci√≥n en las celdas DSP48 es la profundidad de bits de los datos de entrada.  El nodo DSP48E1, que es la celda base de las series FPGA Xilinx 6 y 7, el ancho de los puertos de entrada para la multiplicaci√≥n: "A" - 25 bits, "B" - 18 bits, por lo tanto, el resultado de la multiplicaci√≥n es un n√∫mero de 43 bits.  Para la familia Xilinx Ultrascale y Ultrascale + FPGA, el nodo ha sufrido varios cambios, en particular, la capacidad del primer puerto aument√≥ en dos bits: "A" - 27 bits, "B" - 18 - bits.  Adem√°s, el nodo en s√≠ se llama DSP48E2. <br><br>  Para no estar vinculado a una familia espec√≠fica y un chip FPGA, para garantizar la "pureza del c√≥digo fuente", y para tener en cuenta todas las profundidades de bits posibles de los datos de entrada, se decidi√≥ dise√±ar nuestro propio conjunto de multiplicadores.  Esto permitir√° la implementaci√≥n m√°s eficiente de multiplicadores complejos para mariposas FFT, a saber, multiplicadores y un sumador-sustractor basado en bloques DSP48.  La primera entrada del multiplicador son los datos de entrada, la segunda entrada del multiplicador son los factores de rotaci√≥n (se√±al arm√≥nica de la memoria).  Se implementa un conjunto de multiplicadores utilizando la biblioteca UNISIM incorporada, desde la cual es necesario conectar las primitivas DSP48E1 y DSP48E2 para su uso posterior en el proyecto.  Un conjunto de multiplicadores se presenta en la tabla.  Cabe se√±alar que: <br><br><ul><li>  La operaci√≥n de multiplicar n√∫meros conduce a un aumento en la capacidad del producto como la suma de la capacidad de los operandos. </li><li>  De hecho, cada uno de los multiplicadores 25x18 y 27x18 est√° duplicado: este es un componente para diferentes familias. </li><li>  Cuanto mayor es la etapa de paralelismo de la operaci√≥n, mayor es el retraso en la computaci√≥n y mayor es la cantidad de recursos ocupados. </li><li>  Con una profundidad de bits m√°s baja en la entrada "B", se pueden implementar multiplicadores con una profundidad de bits m√°s alta en otra entrada. </li><li>  La principal limitaci√≥n para aumentar la profundidad de bits se introduce por el puerto "B" (el puerto real de la primitiva DSP48) y el registro de desplazamiento interno por 17 bits. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  Un aumento adicional en la profundidad de bits no es de inter√©s en el marco de la tarea por las razones que se describen a continuaci√≥n: <br><br><h3>  Profundidad de bits de los factores de giro </h3><br>  Se sabe que cuanto mayor es la resoluci√≥n de la se√±al arm√≥nica, m√°s exactamente aparece el n√∫mero (m√°s signos en la parte fraccional).  Pero el tama√±o del bit de puerto es B &lt;25 bits debido al hecho de que para los factores de rotaci√≥n en los nodos FFT, esta profundidad de bits es suficiente para garantizar una multiplicaci√≥n de alta calidad de la secuencia de entrada con elementos de se√±al arm√≥nica en las "mariposas" (para cualquier longitud FFT real√≠sticamente alcanzable en FPGA modernos).  El valor t√≠pico de la profundidad de bits de los coeficientes de giro en las tareas que estoy implementando es 16 bits, 24, con menos frecuencia, 32, nunca. <br><br><h3>  Profundidad de bits de muestras de entrada </h3><br>  La capacidad de estos nodos de recepci√≥n y grabaci√≥n t√≠picos (ADC, DAC) no es grande, de 8 a 16 bits, y rara vez, de 24 o 32 bits.  Adem√°s, en el √∫ltimo caso, es m√°s eficiente usar el formato de datos de coma flotante de acuerdo con el est√°ndar IEEE-754.  Por otro lado, cada etapa de la "mariposa" en la FFT agrega un bit de datos a las muestras de salida debido a operaciones matem√°ticas.  Por ejemplo, para una longitud de NFFT = 1024, se utiliza log2 (NFFT) = 10 mariposas. <br><br>  Por lo tanto, la profundidad de bits de salida ser√° diez bits mayor que la entrada, WOUT = WIN + 10. En general, la f√≥rmula se ve as√≠: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Un ejemplo: <br><br>  Profundidad de bits del flujo de entrada WIN = 32 bits, <br>  Profundidad de bits de los factores de giro TWD = 27, <br>  La capacidad del puerto "A" de la lista de multiplicadores implementados en este art√≠culo no supera los 52 bits.  Esto significa que el n√∫mero m√°ximo de mariposas es FFT = 52-32 = 20. Es decir, es posible realizar FFT con una longitud de hasta 2 ^ 20 = 1M de muestras.  (Sin embargo, en la pr√°ctica, esto no es posible por medios directos debido a los recursos limitados incluso para los cristales FPGA m√°s potentes, pero esto se relaciona con otro tema y no ser√° considerado en el art√≠culo). <br><br>  Como puede ver, esta es una de las razones principales por las que no implement√© multiplicadores con mayor profundidad de bits de puertos de entrada.  <b>Los multiplicadores utilizados cubren el rango completo de</b> los tama√±os de <b>bits de</b> entrada <b>requeridos</b> y los factores de rotaci√≥n para la tarea de calcular el FFT entero.  ¬°En todos los dem√°s casos, puede usar el c√°lculo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>FFT en formato de punto flotante</b></a> ! <br><br><h3>  La implementaci√≥n del multiplicador "ancho" </h3><br>  Basado en un ejemplo simple de multiplicar dos n√∫meros que no encajan en la profundidad de bits de un nodo DSP48 est√°ndar, mostrar√© c√≥mo puede implementar un multiplicador de datos amplio.  La siguiente figura muestra su diagrama de bloques.  El multiplicador implementa la multiplicaci√≥n de dos n√∫meros con signo en el c√≥digo adicional, el ancho del primer operando X es de 42 bits, el segundo Y es de 18 bits.  Contiene dos nodos DSP48E2.  Se utilizan dos registros para igualar los retrasos en el nodo superior.  Esto se hace porque en el sumador superior necesita agregar correctamente los n√∫meros de los nodos superior e inferior del DSP48.  El sumador inferior no se usa realmente.  En la salida del nodo inferior hay un retraso adicional del producto para alinear el n√∫mero de salida con el tiempo.  El retraso total es de 4 ciclos. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  El trabajo consta de dos componentes: <br><br><ul><li>  La parte m√°s joven: <b>P1 = '0' y X [16: 0] * Y [17: 0];</b> </li><li>  La parte anterior: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Totalizador </h3><br>  Al igual que un multiplicador, un sumador puede construirse sobre recursos l√≥gicos utilizando una cadena de transferencia o en bloques DSP48.  Para lograr el m√°ximo rendimiento, es preferible un segundo m√©todo.  Una primitiva DSP48 permite implementar la operaci√≥n de adici√≥n hasta 48 bits, dos nodos hasta 96 bits.  Para la tarea actual, tales profundidades de bits son suficientes.  Adem√°s, la primitiva DSP48 tiene un modo especial "MODO SIMD", que paraleliza la ALU incorporada de 48 bits en varias operaciones con diferentes datos de peque√±a capacidad.  Es decir, en el modo "UNO" se utiliza una cuadr√≠cula de bits completa de 48 bits y dos operandos, y en el modo "DOS" la cuadr√≠cula de bits se divide en varios flujos paralelos de 24 bits cada uno (4 operandos).  Este modo, que usa solo un sumador, ayuda a reducir la cantidad de recursos de chip FPGA ocupados a peque√±as profundidades de bits de muestras de entrada (en las primeras etapas de c√°lculo). <br><br><h3>  Incremento de profundidad de bits </h3><br>  La operaci√≥n de <b>multiplicar</b> dos n√∫meros con los bits N y M en un c√≥digo adicional binario conduce a un aumento en la capacidad del bit de salida a <b>P = N + M.</b> <br><br>  Ejemplo: para multiplicar n√∫meros de tres bits N = M = 3, el n√∫mero positivo m√°ximo es +3 = <i>(011) <sub>2</sub></i> , y el n√∫mero negativo m√°ximo es 4 = <i>(100) <sub>2</sub></i> .  El bit m√°s significativo es responsable del signo del n√∫mero.  Por lo tanto, el n√∫mero m√°ximo posible al multiplicar es +16 = <i>(010000) <sub>2</sub></i> , que se forma como resultado de multiplicar dos n√∫meros negativos m√°ximos -4.  La profundidad de bits de la salida es igual a la suma de los bits de entrada P = N + M = 6 bits. <br><br>  La operaci√≥n de <b>agregar</b> dos n√∫meros con los bits N y M en el c√≥digo adicional binario conduce a un aumento en el bit de salida en un bit. <br><br>  Ejemplo: agregue dos n√∫meros positivos, N = M = 3, el n√∫mero positivo m√°ximo es 3 = <i>(011) <sub>2</sub></i> , y el n√∫mero negativo m√°ximo es 4 = <i>(100) <sub>2</sub></i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El bit m√°s significativo es responsable del signo del n√∫mero. </font><font style="vertical-align: inherit;">Por lo tanto, el n√∫mero positivo m√°ximo es 6 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0110) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y el n√∫mero negativo m√°ximo es -8 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1000) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La resoluci√≥n de la salida aumenta en un bit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consideraci√≥n de las caracter√≠sticas del algoritmo. </font></font></h3><br> <i><b>  :</b></i> <br>                       .         . ,   16-      -32768 = 0x8000,     -32767 = 0x8001.            <b>~0.003%</b>      . <br><br>       ,         . :  ‚Äì 4 = (100) <sub>2</sub> ,  +3 = (011) <sub>2</sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Resultado de multiplicaci√≥n = -12 = (110100) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El quinto bit se puede descartar porque duplica el vecino, el cuarto es un bit de signo. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Truncamiento de bits desde abajo:</font></font></b></i> <br><br> ,    ¬´¬ª     ,        ,     .      M- ,        ,   .    0x8000 = -1,   0x7FFF = +1. ,         (  M      ).    ,    ,     1    . ,          [N+M-1-1: M-1].     (  1),  ‚Äì . <br><br> /    ¬´¬ª            <b>          </b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que en la primera etapa del algoritmo FFT DIT o en la √∫ltima etapa del algoritmo FFT DIF, los datos deben multiplicarse por un factor de giro con un √≠ndice cero W0 = {Re, Im} = {1, 0}. Debido al hecho de que la multiplicaci√≥n por unidad y cero son operaciones primitivas, se pueden omitir. En este caso, la operaci√≥n de multiplicaci√≥n compleja no es necesaria en absoluto: los componentes reales e imaginarios experimentan un "giro" sin cambios. En la segunda etapa, se utilizan dos coeficientes: W0 = {Re, Im} = {1, 0} y W1 = {Re, Im} = {0, -1}. Del mismo modo, las operaciones se pueden reducir a transformaciones elementales y utilizar un multiplexor para seleccionar la muestra de salida. Esto le permite guardar significativamente los bloques DSP48 en las dos primeras mariposas.</font></font><br><br>     ‚Äì     -,           ,     . <br><br>       -  ,     .       .   ‚Äî       ‚Äî . <br><br><h3>    INT_FFTK </h3><br><ul><li>     . </li><li>   NFFT = 8-512K . </li><li>     NFFT. </li><li>    ,  . </li><li>    ,  . </li><li>            . </li><li>          ! </li><li>        . </li><li> :    ‚Äì   ,    -. </li><li> :     - ,   ‚Äì  . </li><li>      . Radix-2. </li><li>       NFFT *. </li><li>        . </li><li>      (Virtex-6, 7-Series, Ultrascale). </li><li>    <b>~375MHz</b>  Kintex-7 </li><li>   ‚Äì VHDL. </li><li>     bitreverse   +. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyecto de c√≥digo abierto sin la inclusi√≥n de n√∫cleos IP de terceros. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo fuente para el n√∫cleo FFT INTFFTK en VHDL (incluidas las operaciones b√°sicas y un conjunto de multiplicadores) y los scripts m para Matlab / Octave </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√°n disponibles en mi perfil de github</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Conclusi√≥n </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante el desarrollo, se dise√±√≥ un nuevo n√∫cleo FFT, que proporciona un mayor rendimiento en comparaci√≥n con sus pares. </font><font style="vertical-align: inherit;">La combinaci√≥n de n√∫cleos FFT y OBPF no requiere traducci√≥n al orden natural, y la longitud m√°xima de conversi√≥n est√° limitada solo por los recursos FPGA. </font><font style="vertical-align: inherit;">La doble concurrencia le permite procesar flujos de entrada de doble frecuencia, lo que Xilinx de IP-CORE no puede hacer. </font><font style="vertical-align: inherit;">La profundidad de bits en la salida del entero FFT aumenta linealmente seg√∫n el n√∫mero de etapas de conversi√≥n.</font></font><br><br>        :   Radix-4, Radix-8, Ultra-Long FFT    , FFT-FP32 (  IEEE-754).  ,     ,               .    FFT Radix-8,       (  ). <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">dsmv2014</a> ,      .  Gracias por su atencion! <br><br><h3> UPDATE 2018/08/22 </h3><br><br>      <b>SCALED FFT / IFFT</b> .        1  (truncate LSB).    =  . <br><br>          ,     ,  :          .   ,        -        . <br><br> :    ‚Äî 6 .  ‚Äî   128  . NFFT = 1024 , DATA_WIDTH = 16, TWDL_WIDTH = 16. <br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text">  <b>Fig.</b> <b>1  - :</b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Fig.</b> <b>2  - :</b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li>  ‚Äî UNSCALED FFT, </li><li>  ‚Äî SCALED FFT. </li></ul><br></div></div><br>  ,  SCALED ¬´ ¬ª   ,      UNSCALED   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420517/">https://habr.com/ru/post/es420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420507/index.html">Antecedentes: Internet global para todos y sus creadores.</a></li>
<li><a href="../es420509/index.html">Un problema obvio con el uso de afirmar</a></li>
<li><a href="../es420511/index.html">Trabajar como especialista en TI en el Lejano Oriente - Regi√≥n de Amur</a></li>
<li><a href="../es420513/index.html">Una copia pirateada de un servicio pago en 39 l√≠neas de c√≥digo Python</a></li>
<li><a href="../es420515/index.html">Diarizaci√≥n basada en el modelo GMM-UBM y el algoritmo de adaptaci√≥n MAP</a></li>
<li><a href="../es420519/index.html">Popularizaci√≥n de la ciencia.</a></li>
<li><a href="../es420521/index.html">Ahora oficialmente: TLS 1.3 reconocido como est√°ndar</a></li>
<li><a href="../es420523/index.html">An√°lisis de gr√°ficos de opciones binarias o c√≥mo una vez m√°s me demostr√© a m√≠ mismo que los obsequios no existen</a></li>
<li><a href="../es420525/index.html">Redes para los m√°s experimentados. Parte quince. QoS</a></li>
<li><a href="../es420527/index.html">Puede sonar una sonrisa y es contagiosa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>