<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏿 💃🏿 ♌️ Entrenamiento Cisco 200-125 CCNA v3.0. Día 36. Protocolo de canal STP 📴 ⚰️ ⚜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy exploraremos el protocolo STP de árbol de expansión de canales. Este tema asusta a muchas personas debido a su aparente complejidad, porque no pue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entrenamiento Cisco 200-125 CCNA v3.0. Día 36. Protocolo de canal STP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/466405/"> Hoy exploraremos el protocolo STP de árbol de expansión de canales.  Este tema asusta a muchas personas debido a su aparente complejidad, porque no pueden entender lo que hace el protocolo STP.  Espero que al final de este video tutorial o en la próxima lección comprenda cómo funciona este "árbol".  Antes de comenzar la lección, quiero mostrarles el nuevo diseño de mi escritorio para esta semana. <br><br><img src="https://habrastorage.org/webt/qd/8j/_q/qd8j_qwzpce7ydqcvqggv4phr50.jpeg"><br><br>  También puede configurar su escritorio de manera similar si usa el enlace en la esquina superior derecha de este video.  Y, por favor, no te olvides de "me gusta" y compartir mis lecciones de video con amigos. <br><br>  Como la última vez, hoy discutiremos otro tema de acuerdo con el cronograma ICND2 presentado en el sitio web de Cisco.  Esta es la sección 1.3, "Configuración, verificación y problemas con los protocolos STP", subpárrafo 1.3a, "Modos STP (PVST + y RPVST +)", y 1.3b, "Selección de un interruptor de puente raíz STP". <a name="habracut"></a><br><br>  Como este es un tema extenso, moví la discusión de la subsección 1.3b a la siguiente lección, "Día 37", y agregaré la sección 1.4 allí.  Entonces, hoy miramos cómo es STP, miramos los modos de este protocolo PVST + y RPVST +, y luego miramos la ID del interruptor raíz del Switch Bridge y el costo de la ruta al puerto raíz del Costo del Puerto. <br><br><img src="https://habrastorage.org/webt/wl/as/sj/wlassjxj2oqy2pvoyrb-ykzx5mi.jpeg"><br><br>  Para empezar, debemos comprender qué es el bucle de conmutación que aparece en el segundo nivel del modelo OSI (a nivel de trama) y qué problemas están asociados con él.  Ya hemos discutido el tráfico en bucle en uno de los episodios anteriores, y esa lección puede considerarse una introducción al tema de hoy.  Permítanme darles un ejemplo: tenemos el interruptor A y el interruptor B conectados entre sí por dos líneas de comunicación, el primer usuario se llama Joe y el segundo es Jim. <br><br><img src="https://habrastorage.org/webt/4c/g-/xm/4cg-xm-of2s7jzigdlzvl0zuwcy.jpeg"><br><br>  Si Joe envía un mensaje a Jim, entonces envía la trama al conmutador A. El conmutador A no conoce la dirección MAC de Jim, por lo que envía una trama de difusión a través de todos los puertos, excepto por el que Joe recibió el mensaje.  Cuando los puertos del conmutador B reciben la trama de difusión, el paquete que llega a una interfaz se envía a Jim, y el paquete que llega a la segunda interfaz se reenvía al primer puerto y se envía de vuelta al conmutador A. <br><br><img src="https://habrastorage.org/webt/ci/e0/w-/cie0w-pdwbcnwjakvrfbdyv3jjq.jpeg"><br><br>  Al mismo tiempo, una solicitud que llega a la primera interfaz se reenvía al segundo puerto y también se envía al conmutador A. <br><br><img src="https://habrastorage.org/webt/oi/3l/gp/oi3lgpzuy8yklulq2hkefw-1z3k.jpeg"><br><br>  Una vez recibidas estas tramas de difusión, el conmutador A las devuelve: la trama recibida en la primera interfaz se envía en la segunda, y la recibida en la segunda se envía a la red a través de la primera interfaz.  Este proceso se repite una y otra vez, formando un bucle de solicitudes de difusión.  Si otra transmisión ingresa a la red, se repite de la misma manera que la primera.  El resultado es un fenómeno llamado tormenta de difusión, o tormenta de difusión.  La red inunda tantas tramas de difusión que se bloquea.  Esta tormenta solo puede detenerse cuando uno de los dispositivos se desconecta o la conexión se interrumpe.  Si la línea permanece operativa, poco después del inicio de tal tormenta, uno de los interruptores dejará de funcionar debido al desbordamiento de la memoria.  En el segundo caso, puede producirse un bucle debido al reenvío de una trama con una dirección MAC de unidifusión.  Este problema se llama "inestabilidad de la tabla de direcciones MAC".  Ocurre cuando hay más de dos conexiones entre conmutadores.  Dibujaré un diagrama en el que los interruptores A, B y C están conectados entre sí y también se puede formar un bucle entre ellos. <br><br>  El interruptor A tiene tres interfaces: f0 / 1, f0 / 2 y f0 / 3.  Suponga que el usuario tiene una computadora con la dirección MAC AAA y envía una trama de difusión al conmutador A. El conmutador acepta esta trama a través de la interfaz f0 / 1.  Hay otro usuario en la red cuya computadora tiene una dirección MAC BBB.  Por lo tanto, tenemos la dirección de origen AAA y la dirección de destino BBB. <br><br><img src="https://habrastorage.org/webt/vb/ny/sq/vbnysqpjkbkzx8fazia-l83dnwm.jpeg"><br><br>  El conmutador A no sabe cómo llegar a la dirección MAC de destino del BBB, pero sabe que la dirección MAC de origen de AAA se puede alcanzar a través de la interfaz f0 / 1 y coloca un registro al respecto en su tabla de direcciones MAC.  El conmutador A luego envía una solicitud de la dirección de destino a las otras dos interfaces: f0 / 2 y f0 / 3. <br><br>  Al recibir la solicitud AAA, el conmutador B ve que proviene de la fuente f0 / 2 y coloca en su tabla de direcciones MAC un registro de que el dispositivo AAA es accesible a través de la interfaz f0 / 2.  Además, ya tiene una entrada en la que la interfaz fB / 1 corresponde al destino del BBB, por lo que envía la solicitud al destinatario. <br><br><img src="https://habrastorage.org/webt/xt/ve/jh/xtvejhnvwv67ck8wezcu9idbbx4.jpeg"><br><br>  Como el conmutador A envió una trama de difusión, no solo atravesó la interfaz f0 / 2 para cambiar B, sino también a través de la interfaz f0 / 3 para cambiar C, que, a su vez, la envió a la interfaz f0 / 3 del conmutador B. <br><br><img src="https://habrastorage.org/webt/01/qe/be/01qebe868rzvxx0we7qrxfiqm44.jpeg"><br><br>  Después de recibir la trama, el interruptor B piensa de esta manera: “Sé que la fuente AAA estaba ubicada previamente en la interfaz f0 / 2, pero ahora la trama me llegó a través de la interfaz f0 / 3, así que tengo que actualizar mi tabla de direcciones MAC y reemplazar f0 / 2 en f0 / 3. " <br><br><img src="https://habrastorage.org/webt/mx/f-/hu/mxf-hu_w2zknw2aodud5qxu6rpi.jpeg"><br><br>  Luego, el marco volverá al interruptor A y lo "sorprenderá" mucho: antes del interruptor A pensaba que la fuente AAA estaba conectada por la interfaz f0 / 1, y ahora resulta que el mensaje vino de la interfaz f0 / 2.  En la dirección inversa de la trama a través del interruptor B y C, el interruptor A recibirá un mensaje que lo confundirá nuevamente; ahora resulta que la fuente AAA se encuentra en la interfaz f0 / 3. <br><br><img src="https://habrastorage.org/webt/v5/su/de/v5sudeyxunx2uctf1ssitxnirbk.jpeg"><br><br>  Por lo tanto, la tabla de direcciones MAC de este conmutador se actualizará constantemente entre estas tres interfaces, es decir, surgirá el problema antes mencionado de la inestabilidad de la tabla de direcciones MAC.  Como en el primer caso, aquí se forma un bucle de trama, lo que lleva a una actualización de la tabla cada pocos segundos. <br><br>  Hay un tercer problema de bucle: varias copias del marco.  El usuario AAA envía la trama para cambiar A, luego la envía a través de la interfaz f0 / 2 para cambiar B, que la entrega al destino BBB a través de la interfaz f0 / 1.  No hay problemas <br><br>  Pero al mismo tiempo, el conmutador A envía la misma trama a través de su segunda interfaz f0 / 3 al conmutador C, que lo reenvía al conmutador B. Al recibir el paquete, o trama, desde el conmutador C, el conmutador B ve que está dirigido a BBB y lo envía al destinatario.  Por lo tanto, el usuario BBB recibe el mismo paquete dos veces.  Aquí surge el problema: si esta es la distribución de datos realizada por la aplicación, entonces el mismo marco no debería llegar al usuario dos veces. <br><br>  Estos son los tres problemas que pueden causar los bucles de trama.  Todos ellos se resuelven de una manera, de la que hablamos anteriormente, utilizando el protocolo STP.  En uno de los videos anteriores, no recuerdo su número, cuando discutimos los modos de puerto, este protocolo ya se mencionó, lo que sirve para evitar bucles de tráfico en la red. <br><br>  Entonces, se forma un bucle cuando tres dispositivos se conectan entre sí, formando un bucle de red cerrado y pertenecen al mismo dominio de transmisión.  Para este caso, el algoritmo utilizado por el protocolo STP designa a uno de los interruptores como el interruptor raíz: Root Bridge.  Elija el interruptor A como el interruptor raíz. <br><br><img src="https://habrastorage.org/webt/nz/qg/d5/nzqgd5e78l5oqonqp3kwuopwe0o.jpeg"><br><br>  Cada puerto conectado al conmutador raíz debe estar en estado de reenvío, estos son los puertos izquierdos del conmutador C y B. Estos puertos proporcionan la transmisión de paquetes o tramas, en la dirección del conmutador raíz A. En la línea de conexión de los conmutadores C y B, uno de los puertos debe estar en estado de bloqueo Bloqueo. <br><br><img src="https://habrastorage.org/webt/to/og/mw/toogmwtdhyreqmouwhoft7gznek.jpeg"><br><br>  Esto significa que no está enviando tráfico.  El conmutador B puede continuar enviando tráfico al conmutador C, pero su puerto derecho no manejará este tráfico, aunque físicamente continuará funcionando.  Esto se realiza utilizando el identificador de puente o el identificador de interruptor BID: ID de puente. <br><br>  Debe recordar que STP se creó mucho antes de que aparecieran los conmutadores Ethernet.  Luego, en lugar del término interruptor, se usó el término puente, y muchos protocolos todavía usan la terminología clásica de los estándares técnicos.  Entonces ahora BID es el identificador del interruptor. <br><br>  La información que el conmutador raíz intercambia con otros conmutadores se llama BPDU.  Los dispositivos intercambian mensajes BPDU cada 2 segundos; esta vez se denomina "temporizador de saludo".  El mensaje BPDU contiene el BID del conmutador raíz y el costo de la ruta al conmutador raíz, o el costo de la ruta raíz (esta es en realidad la distancia al conmutador raíz).  El costo de la ruta en cada puerto sirve para calcular la ruta más corta al conmutador raíz, pero no profundizaremos en este concepto. <br><br>  Lógicamente, el esquema funciona así: gracias al puerto derecho bloqueado del interruptor C, el tráfico va en la dirección del interruptor A - interruptor B - el interruptor C no ingresa al interruptor A, es decir, no se cierra en el bucle.  C dirige el tráfico A, que lo envía a B, el interruptor B lo dirige a C, y en este punto el bucle se rompe. <br><br><img src="https://habrastorage.org/webt/un/dn/vh/undnvh6pu8b09-f6v8y2jjryco0.jpeg"><br><br>  Así es como funciona el protocolo STP, que es el estándar IEEE 802.1d.  Este es un estándar muy antiguo, cuya desventaja es el tiempo máximo para actualizar la información cuando se desconecta la comunicación, igual a 50 segundos.  Además del estado de bloqueo del puerto de bloqueo, admite 2 estados intermedios más: escucha y aprendizaje, después de lo cual cambia al estado de transferencia de reenvío. <br><br>  Cada 2 segundos, los interruptores intercambian un mensaje de saludo: C lo envía a B y A, A envía a C y B, y así sucesivamente.  Si el dispositivo no recibe este mensaje, lo espera durante otro período de 10 veces del temporizador de saludo, es decir, 20 segundos.  Después de eso, espera alguna acción, pasa al estado de Escucha, que dura 15 segundos, luego pasa al estado de Aprendizaje y permanece en él durante otros 15 segundos.  Por lo tanto, el período total de inactividad es de 50 s.  Para las redes modernas, este es un período de tiempo bastante largo. <br><br>  Para mejorar esta situación, se introdujo otro estándar: IEEE 802.1w, o Rapid STP, el protocolo STP rápido, denominado RSTP.  Carece de estados intermedios y va del estado de bloqueo al estado de reenvío. <br><br>  En STP, hay puertos raíz: puerto raíz: estos son los puertos a través de los cuales se lleva a cabo la comunicación con el conmutador raíz.  En RSTP, se agrega el concepto de puertos alternativos que no están relacionados con el conmutador raíz.  En el caso de que haya una desconexión entre el puerto raíz de RP y el conmutador raíz, el puerto ALT alternativo se convierte inmediatamente en el puerto raíz de RP, y la comunicación se lleva a cabo en una ruta diferente. <br><br><img src="https://habrastorage.org/webt/sp/gy/x1/spgyx1k4kfjhapc-ur0bdflad4o.jpeg"><br><br>  Con el curso de eventos más difícil, todo este proceso lleva un máximo de 10 segundos, y 10 segundos de inactividad es mucho mejor que 50 segundos.  Esta es la principal diferencia entre STP y RSTP. <br><br>  Cisco ahora usa STP de varias maneras, pero originalmente estaba destinado a funcionar en el mismo dominio de transmisión con una VLAN nativa, por lo que STP se vio como parte de VLAN1.  Al mismo tiempo, se creía que todo el tráfico es parte de este dominio de transmisión único.  A medida que los dispositivos de red evolucionaron, Cisco comenzó a usar STP de otras maneras, creando PVSTP (árbol de expansión por VLAN), un protocolo patentado diseñado para trabajar con múltiples VLAN.  Esto significaba que cada VLAN tendría su propio STP, es decir, su propio Root Bridge del conmutador raíz raíz. <br><br><img src="https://habrastorage.org/webt/mw/3u/mj/mw3umjyuucfzsnl2ugkludxfgpe.jpeg"><br><br>  De la misma manera que Cisco mejoró STP al crear RSTP, desarrolló la versión "acelerada" de PVSTP - RPVSTP.  Ambos protocolos encapsulados usando el protocolo ISL patentado y no admitían el estándar 802.1q, ya que se desarrollaron antes de su adopción.  Para mejorar la interoperabilidad, Cisco ha mejorado estos protocolos al agregar soporte 802.1q.  Los nuevos protocolos que admiten ISL y 802.1q se denominan PVSTP + y RPVSTP +.  Ahora son estándares de la industria para las redes de Cisco. <br>  El proceso STP se caracteriza por una métrica de costo de ruta en cada puerto de costo de puerto.  Como base para este indicador, se utilizó la característica de velocidad del puerto: la velocidad del puerto en mb / s.  Entonces, según el estándar IEEE 1998, la velocidad de 10 Mb / s correspondía al costo del puerto 100, la velocidad de 100 Mb / s - el costo de 19, 1 Gb / s - el costo de 4 y 10 Gb / s - el costo de 2. Este estándar no tuvo en cuenta la velocidad de 100 Gb / s y 1 Tb / s, por lo que en 2004 se desarrolló un nuevo IEEE, donde el indicador relativo del costo del puerto varía de 2 millones a 20. <br><br><img src="https://habrastorage.org/webt/tm/ia/oo/tmiaoosw91_gsfeccaehnp6rbzu.jpeg"><br><br>  Cuanto mayor sea la velocidad, menor será el costo, por lo que al calcular las rutas, se seleccionan los puertos con un menor costo.  Si hay dos líneas: FastEthernet y GigabitEthernet, entonces la última línea de comunicación tendrá un costo mucho menor, por lo que al elegir una ruta al conmutador raíz, el puerto GigabitEthern tendrá prioridad.  El conmutador raíz en sí tiene un costo de puerto cero.  En el siguiente video veremos el proceso de elección de una ruta, se te aclarará mucho.  Por ahora, solo recuerde cuál es el principio de fijación de precios. <br><br>  El siguiente tema es la identificación del remitente de la ID del puente.  En STP, contiene 2 bytes de información de prioridad del conmutador y 6 bytes de dirección MAC. <br><br><img src="https://habrastorage.org/webt/lr/ei/3s/lrei3sclrlls8vbn-_kbgatovvq.jpeg"><br><br>  El PVSTP más avanzado consta de 16 bits.  Los primeros 12 bits se denominan ID de sistema extendido o identificador de sistema extendido.  Contiene el identificador de red VLAN: el número de red en el rango 0-4095 y la dirección MAC.  Otros 4 bits se utilizan para indicar la prioridad del puente o conmutador.  Si recuerda nuestra tabla binaria mágica, verá que si los 4 bits son 0, obtendremos prioridad cero. <br><br>  Si los bits están en el orden 0001, esto significa que el número 4096 está por debajo de 1, es decir, la prioridad será 4096. Dependiendo de las 16 combinaciones de bits, uno de estos números se usará como prioridad: de 0 a 61440, y cada uno 4096 más que el anterior. <br><br>  De manera predeterminada, todos los conmutadores Cisco tienen prioridad 32768, pero puede elegir cualquiera de estos números como prioridad.  Cuando se usa la ID del sistema extendido, se agrega un número de VLAN a este número, es decir, si tiene VLAN1, la prioridad de la ID del puente será 32768 + 1 = 32769. <br><br><img src="https://habrastorage.org/webt/y_/hd/uf/y_hdufo0lyhy94jyx5l31jmg5gq.jpeg"><br><br>  También tenemos una dirección MAC.  Supongamos que la ID del puente de un dispositivo es 32769: AAA: AAA: AAA, y el otro es 32769: BBB: BBB: BBB.  Tienen el mismo valor de prioridad numérica, pero el dispositivo con la dirección MAC más baja tendrá una ventaja, es decir, AAA: AAA: AAA.  Para comprender mejor cómo funciona Bridge ID, puede revisar este video nuevamente. <br><br>  No podemos cambiar la dirección MAC del segundo dispositivo, pero podemos cambiar el valor de prioridad numérico 32769. Si desea que este dispositivo tenga una prioridad más alta, puede cambiar el valor de prioridad a 0 o cualquier número menor que 32769. Si tomamos 0 y el número de red VLAN1, entonces obtenemos el valor numérico de prioridad 1. En este caso, independientemente del valor de la dirección MAC, este dispositivo tendrá una prioridad más alta que el primero. <br><br>  Si desea descargar este video de nuestro sitio web, puede usar el cupón para obtener un descuento del 50%, que es válido hasta el 22 de noviembre de 2017.  Les recuerdo que hoy examinamos un tema muy importante, por lo que les aconsejo que vean este video tutorial nuevamente. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-z4HPhKiTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Gracias por quedarte con nosotros.  ¿Te gustan nuestros artículos?  ¿Quieres ver más materiales interesantes?  <b>Apóyenos</b> haciendo un pedido o recomendándolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un análogo único de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o cómo dividir el servidor?</a>  (las opciones están disponibles con RAID1 y RAID10, hasta 24 núcleos y hasta 40GB DDR4). <br><br>  <b>Dell R730xd 2 veces más barato?</b>  ¡Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV desde $ 199</a> en los Países Bajos!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - ¡desde $ 99!</b></b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466405/">https://habr.com/ru/post/466405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466383/index.html">Cryptocurrency Ocean: revisión de los 50 principales proyectos con CoinMarketCap</a></li>
<li><a href="../466385/index.html">Comprender los corredores de mensajes. Aprendiendo la mecánica de la mensajería a través de ActiveMQ y Kafka. Capitulo 1</a></li>
<li><a href="../466397/index.html">Reprogramamos el cajero e imprimimos en él Keanu Reeves. Parte 2. Software para PC</a></li>
<li><a href="../466401/index.html">Un poco de matemática financiera: cálculo de inflación e interés</a></li>
<li><a href="../466403/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Día 35. Protocolo de enlace dinámico DTP</a></li>
<li><a href="../466407/index.html">Cultura de reclutamiento en grandes empresas de estadísticas de Glassdoor</a></li>
<li><a href="../466409/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Día 37. STP: selección de puente raíz, características de protección PortFast y BPDU. Parte 1</a></li>
<li><a href="../466413/index.html">Intercambio de sitios para Bitrix y 1C: resolviendo los principales problemas</a></li>
<li><a href="../466417/index.html">Buque de guerra: una amenaza cibernética enviada por correo ordinario</a></li>
<li><a href="../466419/index.html">Por qué trabajamos en Sitefinity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>