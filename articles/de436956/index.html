<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✈️ 🚣🏽 🚣 Zum Thema Schicht, Schilder und Geschwindigkeit MK 👩🏾‍🎓 👨🏽‍🚀 🤗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Finden Sie einen Grund für alles und Sie werden viel verstehen" 
 Vielleicht erinnern sich meine regelmäßigen Leser (nun, es kann nicht sein, dass si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zum Thema Schicht, Schilder und Geschwindigkeit MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436956/"><h3>  "Finden Sie einen Grund für alles und Sie werden viel verstehen" </h3><br>  Vielleicht erinnern sich meine regelmäßigen Leser (nun, es kann nicht sein, dass sie es nicht waren) daran, dass ich in meinem Beitrag verwirrt war, dass das Attribut ohne Vorzeichen zur Beschreibung der Register externer Geräte verwendet wurde.  In den Kommentaren wurde vorgeschlagen, dies zu tun, um undefiniertes Verhalten während der Schichten zu vermeiden, und ich stimmte zu.  Wie ich kürzlich herausgefunden habe, gibt es einen weiteren Grund für diese Verwendung des Attributs und es kann nicht nur auf Register, sondern auch auf gewöhnliche Variablen angewendet werden. <br><br>  Also fangen wir an. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Zunächst eine kleine Einführung in Eisen</b> <div class="spoiler_text">  Als Zielplattform betrachten wir einen 8-Bit-MK ohne Batterie (dies ist ein erbärmlicher Versuch, den kompromittierten Namen AVR zu verbergen), der die folgenden Hardware-implementierten Befehle enthält: <br><br>  <b>lsl / lsr</b> logische Links- / Rechtsverschiebung, Low / High-Bit wird gelöscht; <br>  <b>rol / ror</b> zyklische Links- / Rechtsverschiebung durch Übertragung (Verschiebung um 9 Bit); <br>  <b>Bei einer</b> arithmetischen Verschiebung nach rechts wird das höchstwertige (vorzeichenbehaftete) Bit gespeichert (wir achten darauf, dass eine solche Verschiebung nach links grundsätzlich nicht möglich ist). <br><br>  Alle diese Befehle werden auf dem Byte-Operanden ausgeführt und bilden die Grundlage für die Implementierung aller anderen möglichen Verschiebungen.  Beispielsweise wird eine Wortverschiebung (2 Bytes rh, rl) mit einem Vorzeichen um 1 Stelle nach rechts durch die folgende Sequenz implementiert: <br><br>  <b>asr rh;</b>  <b>ror rl;</b> <br></div></div><br>  Betrachten Sie ein einfaches Codebeispiel und den entsprechenden Assembler-Code für MK mit dem AVR-Befehlssystem, wie immer auf godbolt.org erhalten.  (impliziert, dass die Optimierung aktiviert ist und sich die Variable im r24-Register befindet) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> byte; byte = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><pre> <code class="cpp hljs">clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 lsl r24 rol r25</code> </pre> <br>  und sehen, dass die Operation fünf Teams dauert? <br><br>  Hinweis: Wenn Ihnen jemand in den Kommentaren sagt, wie Sie dieses Fragment (und die nachfolgenden) in zwei Spalten anordnen sollen, bin ich Ihnen dankbar. <br><br>  Aus dem Assembler-Code ist ersichtlich, dass die Byte-Variable in den ersten drei Befehlen zu einem Integer-Typ (16-Bit) erweitert wird und in den nächsten beiden die Doppelbyte-Nummer tatsächlich verschoben wird - gelinde gesagt ist es irgendwie seltsam. <br><br>  Nach rechts zu schalten ist nicht besser <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 asr r25 ror r24</code> </pre> <br>  - die gleichen fünf Teams.  In der Zwischenzeit ist es offensichtlich, dass Sie zum Ausführen der letzten Operation einen einzigen Befehl benötigen <br><br><pre> <code class="cpp hljs">sr r24</code> </pre> <br>  und für die erste Operation nicht mehr.  Ich habe wiederholt festgestellt, dass der Compiler derzeit Assembler-Code erstellt, der nicht schlechter ist als ein Programmierer (obwohl es sich um ein ARM-Befehlssystem handelt), insbesondere wenn Sie ihm ein wenig helfen und plötzlich so ein Mist.  Versuchen Sie jedoch, dem Compiler zu helfen, den richtigen Code zu erstellen. Möglicherweise müssen Sie die Typen in einer Schichtoperation mischen und versuchen <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - hat nicht geholfen, vom Wort "vollständig", aber die Option <br><br><pre> <code class="cpp hljs"> byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  ergibt ein etwas besseres Ergebnis <br><br><pre> <code class="cpp hljs">ldi r25,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) asr r25 ror r24</code> </pre> <br>  - drei Teams, da die Erweiterung auf das Ganze jetzt ein Team belegt - es ist besser, wenn auch nicht perfekt, dasselbe Bild für <br><br><pre> <code class="cpp hljs">byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - drei Teams.  Nun, um keine zusätzlichen Casts zu schreiben, machen wir die Variable selbst ohne Vorzeichen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byteu;</code> </pre> <br>  und BINGO - Assembler Code erfüllt unsere Erwartungen voll und ganz <br><br><pre> <code class="cpp hljs">byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r24</code> </pre> <br>  Es ist seltsam, wie es scheint, was für ein Unterschied, den richtigen Typ einer Variablen sofort anzugeben oder sie direkt zu einer Operation zu bringen - aber es stellt sich heraus, dass es einen Unterschied gibt. <br><br>  Weitere Studien haben gezeigt, dass der Assembler-Code den Variablentyp berücksichtigt, dem das Ergebnis zugeordnet ist, da <br><br><pre> <code class="cpp hljs">byteu = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  funktioniert gut und erzeugt minimalen Code und die Option <br><br><pre> <code class="cpp hljs">byte = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  kann nicht ohne drei Teams auskommen. <br><br>  Sicherlich wird ein solches Verhalten im Standard der Sprache beschrieben, frage ich diejenigen, die es im Kommentar wissen, aber ich werde noch einmal stolz erklären, dass "der Tschuktschen kein Leser ist" und ich werde die Geschichte fortsetzen. <br><br>  Eine solche Technik hat also nicht dazu beigetragen, nach rechts zu wechseln - wie zuvor gab es 3 Teams (naja, das sind nicht 5, wie bei der Zeichenversion), und ich konnte das Ergebnis in keiner Weise verbessern. <br>  In jedem Fall sehen wir jedoch, dass Schichtoperationen mit einer vorzeichenlosen Nummer schneller ausgeführt werden als mit seinem Gegner.  Wenn wir also das höherwertige Bit einer Zahl nicht als Vorzeichen behandeln wollen (und im Fall von Registern ist dies normalerweise der Fall), müssen wir definitiv das vorzeichenlose Attribut hinzufügen, was wir in Zukunft tun werden. <br><br>  Es stellt sich heraus, dass bei Verschiebungen im Allgemeinen alles äußerst interessant ist. Lassen Sie uns die Anzahl der Positionen erhöhen, wenn Sie nach links verschieben und die Ergebnisse betrachten: &lt;&lt; 1 dauert 1 Taktzyklus, &lt;&lt; 2 - 2, &lt;&lt; 3 - 3, 4 - 2 unerwartet hat der Compiler eine knifflige Optimierung angewendet <br><br><pre> <code class="cpp hljs">swap r24 andi r24,lo8(<span class="hljs-number"><span class="hljs-number">-16</span></span>)</code> </pre> <br>  Dabei tauscht der Befehl s <b>wap</b> zwei Halbbytes in einem Byte aus.  Basierend auf der letzten Optimierung &lt;&lt; 5 - 3, &lt;&lt; 6 - 4, &lt;&lt; 7 - 3 gibt es erneut unerwartet eine weitere Optimierung <br><br><pre> <code class="cpp hljs">ror r24 clr r24 ror r24</code> </pre> <br>  Das Übertragungsbit wird verwendet, &lt;&lt; 8 - 0 misst, da es sich gerade als 0 herausstellt, macht es keinen Sinn, weiter zu suchen. <br><br>  Übrigens, hier ist eine interessante Aufgabe für Sie - für welche Mindestzeit können Sie eine Operation durchführen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> byteu; byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  das übersetzt 0x1234 zu 0x2340.  Die naheliegende Lösung besteht darin, einige Befehle viermal auszuführen <br><br><pre> <code class="cpp hljs">lsl rl rol rh</code> </pre> <br>  führt zu 4 * 2 = 8 Maßnahmen, ich habe mir schnell eine Option ausgedacht <br><br><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> mov tmp,rl andi tmp,<span class="hljs-number"><span class="hljs-number">0x0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rh,tmp ; <span class="hljs-number"><span class="hljs-number">2343</span></span> andi rl,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br>  Das erfordert 7 Maßnahmen und ein Zwischenregister.  Der Compiler generiert also einen Code mit 6 Befehlen und keinen Zwischenregistern - cool, ja. <br><br><div class="spoiler">  <b class="spoiler_title">Ich verstecke diesen Code unter dem Spoiler - versuche selbst eine Lösung zu finden.</b> <div class="spoiler_text">  Hinweis: Im MK-Befehlssatz gibt es einen EXKLUSIVEN ODER-Befehl oder einen GESAMTBETRAG ZWEI <b>oder</b> <br><br><div class="spoiler">  <b class="spoiler_title">Hier ist es, dieser wundervolle Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">6343</span></span> andi r2l,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">6340</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br></div></div><br>  Ich habe nur ästhetisches Vergnügen an diesem Fragment. <br></div></div><br>  Normalerweise verschwindet bei 16-Bit-Zahlen der Unterschied zwischen dem Code für vorzeichenbehaftete und vorzeichenlose Zahlen, wenn er nach links verschoben wird. Das ist seltsam. <br><br>  Kehren wir zu unseren Bytes zurück und bewegen uns nach rechts.  Wie wir uns erinnern, haben wir für ein vorzeichenbehaftetes Byte 5 Taktzyklen, für ein vorzeichenloses Byte - 3 und diese Zeit kann nicht reduziert werden.  Oder trotzdem, Sie können - ja, Sie können, aber es ist ein sehr seltsamer Weg (GCC mit aktivierten Optimierungen - "dies ist ein sehr seltsamer Ort"), nämlich <br><br><pre> <code class="cpp hljs">byteu = (byteu &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>;</code> </pre> <br>  Dies erzeugt genau einen Befehl für beide Varianten des Zeichens.  Geeignet und optional <br><br><pre> <code class="cpp hljs"> byteu = (byteu &amp; <span class="hljs-number"><span class="hljs-number">0xFE</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Aber nur für eine vorzeichenlose Nummer, mit einer vorzeichenbehafteten, wird alles noch deprimierender - 7 Maßnahmen, daher untersuchen wir weiterhin nur die erste Option. <br><br>  Ich kann nicht sagen, dass ich verstehe, was passiert, da es offensichtlich ist, dass eine logische Multiplikation (&amp;) mit einer solchen Konstante nach einer solchen Verschiebung keinen Sinn ergibt (und dies auch nicht tut), aber das Vorhandensein der &amp; -Operation den Code der Verschiebung selbst beeinflusst.  "Sie sehen den Gopher - nein - und ich sehe nicht, aber er ist." <br><br>  Verschiebungen um 2 usw. haben gezeigt, dass es wichtig ist, das Vorzeichenbit auszuzahlen, aber die Zahl ist anfangs ohne Vorzeichen. Im Allgemeinen wird etwas Müll erhalten. „Aber es funktioniert“ ist das einzige, was dazu gesagt werden kann. <br><br>  Man kann jedoch mit Sicherheit sagen, dass Sie durch die Interpretation des Inhalts von Registern und des Speichers als vorzeichenlose Zahlen eine Reihe von Operationen (z. B. Verschieben oder Erweitern eines Werts) schneller ausführen und einen kompakteren Code generieren können. Dies kann daher dringend empfohlen werden Das Schreiben von Programmen für MK ist keine Voraussetzung, sofern nicht anders angegeben (Interpretation als Zahl ist bekannt). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436956/">https://habr.com/ru/post/de436956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436946/index.html">Röntgenerkennung: Präzision = 0,84, Rückruf = 0,96. Brauchen wir mehr Ärzte?</a></li>
<li><a href="../de436948/index.html">Die Zukunft der Rechenzentrumsinfrastrukturen</a></li>
<li><a href="../de436950/index.html">Startups auf der CES 2019: Teil Eins</a></li>
<li><a href="../de436952/index.html">Um des Geldes willen: Suche und Ausnutzung von Schwachstellen in mobilen Zahlungsterminals</a></li>
<li><a href="../de436954/index.html">Digitale Veranstaltungen in Moskau vom 21. bis 27. Januar</a></li>
<li><a href="../de436958/index.html">Libratus strategischer Poker Bot angepasst für militärische Simulationen</a></li>
<li><a href="../de436960/index.html">Teste mich, wenn du kannst. Träumen YML-Entwickler davon, ansible zu testen?</a></li>
<li><a href="../de436962/index.html">Beliebte Open Source - Teil 1: 3 Tools für die Arbeit mit Daten</a></li>
<li><a href="../de436964/index.html">„Rostelecom. DataTalks "- ein Kurs mit kostenlosen Vorlesungen zu Data Engineering und Datenmanagement</a></li>
<li><a href="../de436966/index.html">Website-Optimierung für GooglePage Speed ​​(alle Funktionen werden nach der Aktualisierung berücksichtigt) Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>