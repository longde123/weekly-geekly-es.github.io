<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úàÔ∏è üö£üèΩ üö£ Zum Thema Schicht, Schilder und Geschwindigkeit MK üë©üèæ‚Äçüéì üë®üèΩ‚ÄçüöÄ ü§ó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Finden Sie einen Grund f√ºr alles und Sie werden viel verstehen" 
 Vielleicht erinnern sich meine regelm√§√üigen Leser (nun, es kann nicht sein, dass si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zum Thema Schicht, Schilder und Geschwindigkeit MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436956/"><h3>  "Finden Sie einen Grund f√ºr alles und Sie werden viel verstehen" </h3><br>  Vielleicht erinnern sich meine regelm√§√üigen Leser (nun, es kann nicht sein, dass sie es nicht waren) daran, dass ich in meinem Beitrag verwirrt war, dass das Attribut ohne Vorzeichen zur Beschreibung der Register externer Ger√§te verwendet wurde.  In den Kommentaren wurde vorgeschlagen, dies zu tun, um undefiniertes Verhalten w√§hrend der Schichten zu vermeiden, und ich stimmte zu.  Wie ich k√ºrzlich herausgefunden habe, gibt es einen weiteren Grund f√ºr diese Verwendung des Attributs und es kann nicht nur auf Register, sondern auch auf gew√∂hnliche Variablen angewendet werden. <br><br>  Also fangen wir an. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Zun√§chst eine kleine Einf√ºhrung in Eisen</b> <div class="spoiler_text">  Als Zielplattform betrachten wir einen 8-Bit-MK ohne Batterie (dies ist ein erb√§rmlicher Versuch, den kompromittierten Namen AVR zu verbergen), der die folgenden Hardware-implementierten Befehle enth√§lt: <br><br>  <b>lsl / lsr</b> logische Links- / Rechtsverschiebung, Low / High-Bit wird gel√∂scht; <br>  <b>rol / ror</b> zyklische Links- / Rechtsverschiebung durch √úbertragung (Verschiebung um 9 Bit); <br>  <b>Bei einer</b> arithmetischen Verschiebung nach rechts wird das h√∂chstwertige (vorzeichenbehaftete) Bit gespeichert (wir achten darauf, dass eine solche Verschiebung nach links grunds√§tzlich nicht m√∂glich ist). <br><br>  Alle diese Befehle werden auf dem Byte-Operanden ausgef√ºhrt und bilden die Grundlage f√ºr die Implementierung aller anderen m√∂glichen Verschiebungen.  Beispielsweise wird eine Wortverschiebung (2 Bytes rh, rl) mit einem Vorzeichen um 1 Stelle nach rechts durch die folgende Sequenz implementiert: <br><br>  <b>asr rh;</b>  <b>ror rl;</b> <br></div></div><br>  Betrachten Sie ein einfaches Codebeispiel und den entsprechenden Assembler-Code f√ºr MK mit dem AVR-Befehlssystem, wie immer auf godbolt.org erhalten.  (impliziert, dass die Optimierung aktiviert ist und sich die Variable im r24-Register befindet) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> byte; byte = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><pre> <code class="cpp hljs">clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 lsl r24 rol r25</code> </pre> <br>  und sehen, dass die Operation f√ºnf Teams dauert? <br><br>  Hinweis: Wenn Ihnen jemand in den Kommentaren sagt, wie Sie dieses Fragment (und die nachfolgenden) in zwei Spalten anordnen sollen, bin ich Ihnen dankbar. <br><br>  Aus dem Assembler-Code ist ersichtlich, dass die Byte-Variable in den ersten drei Befehlen zu einem Integer-Typ (16-Bit) erweitert wird und in den n√§chsten beiden die Doppelbyte-Nummer tats√§chlich verschoben wird - gelinde gesagt ist es irgendwie seltsam. <br><br>  Nach rechts zu schalten ist nicht besser <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 asr r25 ror r24</code> </pre> <br>  - die gleichen f√ºnf Teams.  In der Zwischenzeit ist es offensichtlich, dass Sie zum Ausf√ºhren der letzten Operation einen einzigen Befehl ben√∂tigen <br><br><pre> <code class="cpp hljs">sr r24</code> </pre> <br>  und f√ºr die erste Operation nicht mehr.  Ich habe wiederholt festgestellt, dass der Compiler derzeit Assembler-Code erstellt, der nicht schlechter ist als ein Programmierer (obwohl es sich um ein ARM-Befehlssystem handelt), insbesondere wenn Sie ihm ein wenig helfen und pl√∂tzlich so ein Mist.  Versuchen Sie jedoch, dem Compiler zu helfen, den richtigen Code zu erstellen. M√∂glicherweise m√ºssen Sie die Typen in einer Schichtoperation mischen und versuchen <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - hat nicht geholfen, vom Wort "vollst√§ndig", aber die Option <br><br><pre> <code class="cpp hljs"> byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  ergibt ein etwas besseres Ergebnis <br><br><pre> <code class="cpp hljs">ldi r25,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) asr r25 ror r24</code> </pre> <br>  - drei Teams, da die Erweiterung auf das Ganze jetzt ein Team belegt - es ist besser, wenn auch nicht perfekt, dasselbe Bild f√ºr <br><br><pre> <code class="cpp hljs">byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - drei Teams.  Nun, um keine zus√§tzlichen Casts zu schreiben, machen wir die Variable selbst ohne Vorzeichen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byteu;</code> </pre> <br>  und BINGO - Assembler Code erf√ºllt unsere Erwartungen voll und ganz <br><br><pre> <code class="cpp hljs">byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r24</code> </pre> <br>  Es ist seltsam, wie es scheint, was f√ºr ein Unterschied, den richtigen Typ einer Variablen sofort anzugeben oder sie direkt zu einer Operation zu bringen - aber es stellt sich heraus, dass es einen Unterschied gibt. <br><br>  Weitere Studien haben gezeigt, dass der Assembler-Code den Variablentyp ber√ºcksichtigt, dem das Ergebnis zugeordnet ist, da <br><br><pre> <code class="cpp hljs">byteu = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  funktioniert gut und erzeugt minimalen Code und die Option <br><br><pre> <code class="cpp hljs">byte = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  kann nicht ohne drei Teams auskommen. <br><br>  Sicherlich wird ein solches Verhalten im Standard der Sprache beschrieben, frage ich diejenigen, die es im Kommentar wissen, aber ich werde noch einmal stolz erkl√§ren, dass "der Tschuktschen kein Leser ist" und ich werde die Geschichte fortsetzen. <br><br>  Eine solche Technik hat also nicht dazu beigetragen, nach rechts zu wechseln - wie zuvor gab es 3 Teams (naja, das sind nicht 5, wie bei der Zeichenversion), und ich konnte das Ergebnis in keiner Weise verbessern. <br>  In jedem Fall sehen wir jedoch, dass Schichtoperationen mit einer vorzeichenlosen Nummer schneller ausgef√ºhrt werden als mit seinem Gegner.  Wenn wir also das h√∂herwertige Bit einer Zahl nicht als Vorzeichen behandeln wollen (und im Fall von Registern ist dies normalerweise der Fall), m√ºssen wir definitiv das vorzeichenlose Attribut hinzuf√ºgen, was wir in Zukunft tun werden. <br><br>  Es stellt sich heraus, dass bei Verschiebungen im Allgemeinen alles √§u√üerst interessant ist. Lassen Sie uns die Anzahl der Positionen erh√∂hen, wenn Sie nach links verschieben und die Ergebnisse betrachten: &lt;&lt; 1 dauert 1 Taktzyklus, &lt;&lt; 2 - 2, &lt;&lt; 3 - 3, 4 - 2 unerwartet hat der Compiler eine knifflige Optimierung angewendet <br><br><pre> <code class="cpp hljs">swap r24 andi r24,lo8(<span class="hljs-number"><span class="hljs-number">-16</span></span>)</code> </pre> <br>  Dabei tauscht der Befehl s <b>wap</b> zwei Halbbytes in einem Byte aus.  Basierend auf der letzten Optimierung &lt;&lt; 5 - 3, &lt;&lt; 6 - 4, &lt;&lt; 7 - 3 gibt es erneut unerwartet eine weitere Optimierung <br><br><pre> <code class="cpp hljs">ror r24 clr r24 ror r24</code> </pre> <br>  Das √úbertragungsbit wird verwendet, &lt;&lt; 8 - 0 misst, da es sich gerade als 0 herausstellt, macht es keinen Sinn, weiter zu suchen. <br><br>  √úbrigens, hier ist eine interessante Aufgabe f√ºr Sie - f√ºr welche Mindestzeit k√∂nnen Sie eine Operation durchf√ºhren <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> byteu; byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  das √ºbersetzt 0x1234 zu 0x2340.  Die naheliegende L√∂sung besteht darin, einige Befehle viermal auszuf√ºhren <br><br><pre> <code class="cpp hljs">lsl rl rol rh</code> </pre> <br>  f√ºhrt zu 4 * 2 = 8 Ma√ünahmen, ich habe mir schnell eine Option ausgedacht <br><br><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> mov tmp,rl andi tmp,<span class="hljs-number"><span class="hljs-number">0x0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rh,tmp ; <span class="hljs-number"><span class="hljs-number">2343</span></span> andi rl,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br>  Das erfordert 7 Ma√ünahmen und ein Zwischenregister.  Der Compiler generiert also einen Code mit 6 Befehlen und keinen Zwischenregistern - cool, ja. <br><br><div class="spoiler">  <b class="spoiler_title">Ich verstecke diesen Code unter dem Spoiler - versuche selbst eine L√∂sung zu finden.</b> <div class="spoiler_text">  Hinweis: Im MK-Befehlssatz gibt es einen EXKLUSIVEN ODER-Befehl oder einen GESAMTBETRAG ZWEI <b>oder</b> <br><br><div class="spoiler">  <b class="spoiler_title">Hier ist es, dieser wundervolle Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">6343</span></span> andi r2l,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">6340</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br></div></div><br>  Ich habe nur √§sthetisches Vergn√ºgen an diesem Fragment. <br></div></div><br>  Normalerweise verschwindet bei 16-Bit-Zahlen der Unterschied zwischen dem Code f√ºr vorzeichenbehaftete und vorzeichenlose Zahlen, wenn er nach links verschoben wird. Das ist seltsam. <br><br>  Kehren wir zu unseren Bytes zur√ºck und bewegen uns nach rechts.  Wie wir uns erinnern, haben wir f√ºr ein vorzeichenbehaftetes Byte 5 Taktzyklen, f√ºr ein vorzeichenloses Byte - 3 und diese Zeit kann nicht reduziert werden.  Oder trotzdem, Sie k√∂nnen - ja, Sie k√∂nnen, aber es ist ein sehr seltsamer Weg (GCC mit aktivierten Optimierungen - "dies ist ein sehr seltsamer Ort"), n√§mlich <br><br><pre> <code class="cpp hljs">byteu = (byteu &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>;</code> </pre> <br>  Dies erzeugt genau einen Befehl f√ºr beide Varianten des Zeichens.  Geeignet und optional <br><br><pre> <code class="cpp hljs"> byteu = (byteu &amp; <span class="hljs-number"><span class="hljs-number">0xFE</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Aber nur f√ºr eine vorzeichenlose Nummer, mit einer vorzeichenbehafteten, wird alles noch deprimierender - 7 Ma√ünahmen, daher untersuchen wir weiterhin nur die erste Option. <br><br>  Ich kann nicht sagen, dass ich verstehe, was passiert, da es offensichtlich ist, dass eine logische Multiplikation (&amp;) mit einer solchen Konstante nach einer solchen Verschiebung keinen Sinn ergibt (und dies auch nicht tut), aber das Vorhandensein der &amp; -Operation den Code der Verschiebung selbst beeinflusst.  "Sie sehen den Gopher - nein - und ich sehe nicht, aber er ist." <br><br>  Verschiebungen um 2 usw. haben gezeigt, dass es wichtig ist, das Vorzeichenbit auszuzahlen, aber die Zahl ist anfangs ohne Vorzeichen. Im Allgemeinen wird etwas M√ºll erhalten. ‚ÄûAber es funktioniert‚Äú ist das einzige, was dazu gesagt werden kann. <br><br>  Man kann jedoch mit Sicherheit sagen, dass Sie durch die Interpretation des Inhalts von Registern und des Speichers als vorzeichenlose Zahlen eine Reihe von Operationen (z. B. Verschieben oder Erweitern eines Werts) schneller ausf√ºhren und einen kompakteren Code generieren k√∂nnen. Dies kann daher dringend empfohlen werden Das Schreiben von Programmen f√ºr MK ist keine Voraussetzung, sofern nicht anders angegeben (Interpretation als Zahl ist bekannt). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436956/">https://habr.com/ru/post/de436956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436946/index.html">R√∂ntgenerkennung: Pr√§zision = 0,84, R√ºckruf = 0,96. Brauchen wir mehr √Ñrzte?</a></li>
<li><a href="../de436948/index.html">Die Zukunft der Rechenzentrumsinfrastrukturen</a></li>
<li><a href="../de436950/index.html">Startups auf der CES 2019: Teil Eins</a></li>
<li><a href="../de436952/index.html">Um des Geldes willen: Suche und Ausnutzung von Schwachstellen in mobilen Zahlungsterminals</a></li>
<li><a href="../de436954/index.html">Digitale Veranstaltungen in Moskau vom 21. bis 27. Januar</a></li>
<li><a href="../de436958/index.html">Libratus strategischer Poker Bot angepasst f√ºr milit√§rische Simulationen</a></li>
<li><a href="../de436960/index.html">Teste mich, wenn du kannst. Tr√§umen YML-Entwickler davon, ansible zu testen?</a></li>
<li><a href="../de436962/index.html">Beliebte Open Source - Teil 1: 3 Tools f√ºr die Arbeit mit Daten</a></li>
<li><a href="../de436964/index.html">‚ÄûRostelecom. DataTalks "- ein Kurs mit kostenlosen Vorlesungen zu Data Engineering und Datenmanagement</a></li>
<li><a href="../de436966/index.html">Website-Optimierung f√ºr GooglePage Speed ‚Äã‚Äã(alle Funktionen werden nach der Aktualisierung ber√ºcksichtigt) Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>