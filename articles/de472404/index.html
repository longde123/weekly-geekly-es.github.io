<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏼 📮 ♦️ 2D-Kollisionsberechnung: Gilbert-Johnson-Kirti-Algorithmus 🚟 🚧 👂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich nahm das Studium der Kollisionserkennungsprozesse auf und führte mich zum Gilbert-Johnson-Keerthi (GJK) -Algorithmus. 

 Alle Codebeispiele im Bei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2D-Kollisionsberechnung: Gilbert-Johnson-Kirti-Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472404/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/837/791/d92837791f7e383147effd9265b24f91.png" alt="Bild"></div><br>  Ich nahm das Studium der Kollisionserkennungsprozesse auf und führte mich zum Gilbert-Johnson-Keerthi (GJK) -Algorithmus. <br><br>  Alle Codebeispiele im Beitrag sind in TypeScript geschrieben.  In den Beispielen werden die von mir erstellten Strukturen verwendet, die im Beitrag nicht ausführlich behandelt werden.  Sie sind einfach und können im GitHub-Repository angezeigt werden: <br><br><ul><li><code>Vector</code> </li> <li> <code>IShape</code> </li> <li> <code>Collision</code> </li> </ul><br>  Der gesamte Code aus dem Beitrag wird im GitHub-Repository gespeichert: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jthomperoo/gjk-ts-implementation</a> <br><br>  Der Beitrag wurde basierend auf diesem Artikel und dem darin empfohlenen Video geschrieben: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://mollyrocket.com/849</a> </li></ul><br><h2>  Einleitung </h2><br>  GJK ist ein Algorithmus zur Bestimmung des Schnittpunkts zweier konvexer Formen.  Es ist einfach und wird mithilfe einer verallgemeinerten „Hilfsfunktion“ implementiert, mit der Sie einen allgemeineren Ansatz verwenden können. Auf die gleiche Weise können Sie Polygone und Formen verarbeiten, die aus Kurven bestehen, z. B. Ellipsen. <br><a name="habracut"></a><br><h2>  Erforderliche Informationen </h2><br><h3>  Minkowski-Summe </h3><br>  GJK verwendet ein Konzept namens Minkowski-Summe.  SM wird berechnet, indem alle Punkte zweier Zahlen addiert werden.  Nehmen Sie zum Beispiel die beiden folgenden Abbildungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/714/175/459/714175459fab7824d38f46a68b1b736d.png"></div><br>  <strong>Abbildung A (grün):</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  A </th><th>  B. </th><th>  C. </th></tr></thead><tbody><tr><td>  (0,1) </td><td>  (1, -1) </td><td>  (-1, -1) </td></tr></tbody></table></div><br>  <strong>Abbildung B (lila):</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  D. </th><th>  E. </th><th>  F. </th></tr></thead><tbody><tr><td>  (0, -1) </td><td>  (1,1) </td><td>  (-1,1) </td></tr></tbody></table></div><br>  Aus den Werten von Abbildung A und Abbildung B können wir die Minkowski-Summe berechnen: <br><br> <code>A + D = (0,1) + (0,-1) = (0,0) <br> <br> A + E = (0,1) + (1,1) = (1,2) <br> <br> A + F = (0,1) + (-1,1) = (-1,2) <br> <br> B + D = (1,-1) + (0,-1) = (1,-2) <br> <br> B + E = (1,-1) + (1,1) = (2,0) <br> <br> B + F = (1,-1) + (-1,1) = (0,0) <br> <br> C + D = (-1,-1) + (0,-1) = (-1,-2) <br> <br> C + E = (-1,-1) + (1,1) = (0,0) <br> <br> C + F = (-1,-1) + (-1,1) = (-2,0)</code> <br> <br>  Wenn wir diese Werte nehmen und daraus ein Diagramm erstellen, werden wir sehen, welche Zahl das Ergebnis sein wird. <br><br>  <strong>Minkowski-Summe für die Abbildungen A und B:</strong> <br><br>  <em>Beachten Sie, dass AD in Tabelle und Grafik A + D entspricht</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e40/64c/260/e4064c260487a98fb29c87fa43682ec5.png" alt="Diagramm von Minkowski Summe von Form A und B."></div><br><div class="scrollable-table"><table><thead><tr><th>  AD </th><th>  Ae </th><th>  AF </th><th>  Bd </th><th>  BE </th><th>  Bf </th><th>  CD </th><th>  CE </th><th>  CF. </th></tr></thead><tbody><tr><td>  (0,0) </td><td>  (1,2) </td><td>  (-1,2) </td><td>  (1, -2) </td><td>  (2.0) </td><td>  (0,0) </td><td>  (-1, -2) </td><td>  (0,0) </td><td>  (-2,0) </td></tr></tbody></table></div><br>  Um die Minkowski-Summe besser zu verstehen, können wir uns vorstellen, dass wir eine Zahl A nehmen und sie mit dem Umriss eines B umgehen. Die resultierende Zahl ist die Minkowski-Summe. <br><br><h3>  Minkowski Unterschied </h3><br>  GJK verwendet eine Variation der Minkowski-Summe, in der nicht A + B, sondern A - B verwendet wird. In den von mir gelesenen Quellen wird dies als „Minkowski-Differenz“ bezeichnet.  Der Minkowski-Unterschied hat eine interessante Eigenschaft: Wenn sich zwei Figuren überlappen / schneiden, enthält der resultierende Minkowski-Unterschied den Ursprung.  Und das ist die Basis des GJK-Algorithmus. <br><br>  Aus den Werten der Abbildungen A und B können wir die Minkowski-Differenz berechnen: <br><br> <code>A - D = (0,1) - (0,-1) = (0,2) <br> <br> A - E = (0,1) - (1,1) = (-1,0) <br> <br> A - F = (0,1) - (-1,1) = (1,0) <br> <br> B - D = (1,-1) - (0,-1) = (-1,0) <br> <br> B - E = (1,-1) - (1,1) = (0,-2) <br> <br> B - F = (1,-1) - (-1,1) = (2,-2) <br> <br> C - D = (-1,-1) - (0,-1) = (-1,0) <br> <br> C - E = (-1,-1) - (1,1) = (-2,-2) <br> <br> C - F = (-1,-1) - (-1,1) = (0,-2)</code> <br> <br>  Wenn wir diese Werte nehmen und in die Grafik einfügen, sehen wir die resultierende Zahl. <br><br>  <strong>Minkowski-Unterschied für die Abbildungen A und B:</strong> <br><br>  <em>Beachten Sie, dass sich AD in Tabelle und Grafik auf A - D bezieht</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/141/a87/b0f141a87c0f42c4c1f64956a8458082.png" alt="Diagramm von Minkowski Summe von Form A und B."></div><br><div class="scrollable-table"><table><thead><tr><th>  AD </th><th>  Ae </th><th>  AF </th><th>  Bd </th><th>  BE </th><th>  Bf </th><th>  CD </th><th>  CE </th><th>  CF. </th></tr></thead><tbody><tr><td>  (0,2) </td><td>  (-1,0) </td><td>  (1,0) </td><td>  (-1,0) </td><td>  (0, -2) </td><td>  (2, -2) </td><td>  (-1,0) </td><td>  (-2, -2) </td><td>  (0, -2) </td></tr></tbody></table></div><br><h2>  Algorithmus </h2><br>  Basierend auf diesen Konzepten optimiert der GJK-Algorithmus sie.  Die Berechnung der Minkowski-Summe kann viel Zeit in Anspruch nehmen, insbesondere wenn Sie den Schnittpunkt zweier aus vielen Punkten bestehender Zahlen überprüfen.  Um dies zu vermeiden, verwendet GJK zwei Schlüsselkonzepte: Hilfsfunktionen und Simplexe. <br><br><h3>  Hilfsfunktionen </h3><br>  Hilfsfunktionen sind eine Möglichkeit, einen Punkt am Rand der Minkowski-Differenz abzutasten, ohne die gesamte Figur zu konstruieren.  Die Hilfsfunktion erhält zwei verglichene Zahlen und die Richtung, die überprüft werden muss.  Dann empfängt die Hilfsfunktion von jeder Figur einen Punkt, der von zwei entgegengesetzten Richtungen am weitesten entfernt ist.  Mit diesen beiden am weitesten entfernten Punkten können Sie den Hilfspunkt auf der Zahl der Minkowski-Differenz berechnen.  Wir nehmen Punkte aus entgegengesetzten Richtungen, weil wir einen Punkt auf der Minkowski-Differenz erhalten, der uns die größte Fläche gibt, dh es besteht eine höhere Wahrscheinlichkeit, dass wir den Ursprung in die Abbildung aufnehmen.  Da die Minkowski-Differenz der <code>    a -     b</code> das Vorhandensein des Punktes der Figur b, der aus der entgegengesetzten Richtung abgetastet wurde, einen Hilfspunkt, der so weit wie möglich in dieser Richtung liegt. <br><br>  Die Implementierung der Hilfsfunktion ist recht einfach: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> support(a: IShape, b: IShape, direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFar = a.FarthestPointInDirection(direction); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bFar = b.FarthestPointInDirection(direction.Invert()); return aFar.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(bFar); }</code> </pre> <br>  Einer der Vorteile von GJK ist, dass <code>FarthestPointInDirection</code> abstrahiert und auf Polygone und Kurven angewendet werden kann.  Hier ist die Implementierung von <code>FarthestPointInDirection</code> für ein Polygon. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Polygon implements IShape { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> points: Vector[]; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FarthestPointInDirection(direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> farthestDistance = -Infinity; // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> there are no points, just return point <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> farthestPoint: Vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point of this.points) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceInDirection = point.Dot(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distanceInDirection &gt; farthestDistance) { farthestPoint = point; farthestDistance = distanceInDirection; } } return farthestPoint; } }</code> </pre> <br>  Wenn Sie sehen möchten, wie andere Formen implementiert werden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie das Git-Repository dieses Beitrags</a> , in dem die Implementierung für <code>Circle</code> . <br><br>  So wird der Hilfspunkt in <strong>(1,0)</strong> -Richtung für die Abbildungen A und B berechnet: <br><br><ol><li>  Nehmen Sie den entferntesten Punkt von der Figur A;  es stellt sich heraus, Punkt <strong>B (1, -1) zu sein</strong> .  (Sie können es wie den oben gezeigten Algorithmus berechnen oder es einfach anhand des Diagramms anzeigen.) </li><li>  Nehmen Sie den entferntesten Punkt von Abbildung B;  es stellt sich heraus, dass es der Punkt <strong>F (-1, 1) ist</strong> . </li><li>  Berechnen Sie <strong>B - F</strong> ;  es stellt sich heraus, dass es der Punkt <strong>BF (2, -2) ist</strong> - es wird ein Hilfspunkt sein. </li></ol><br><h3>  Simplexe </h3><br>  Ein Simplex ist eine Stichprobe von Punkten entlang der Minkowski-Differenzzahl.  Simplexe können bis zu drei Punkte enthalten.  GJK verwendet sie und versucht, ein Dreieck um den Ursprung zu konstruieren, um das Auftreten einer Kollision zu bestimmen. <br><br><h4>  Simplex-Konstruktion </h4><br>  Simplexe werden iterativ konstruiert, indem Hilfspunkte in verschiedene Richtungen hinzugefügt werden.  Jeder Hilfspunkt sollte in eine neue Richtung zeigen, damit wir so schnell wie möglich einen Simplex mit einem Ursprungspunkt erstellen können.  Die Schwierigkeit liegt in der Wahl der Richtung, in die der nächste Hilfspunkt gelangen soll. <br><br><h3>  Kollisionserkennung und Richtungsauswahl </h3><br>  Der Basisalgorithmus erstellt einfach mithilfe einer Hilfsfunktion einen Simplex und versucht, einen Ursprungspunkt in die Abbildung einzuschließen.  Wir können verstehen, dass es keine Kollision / Schnittmenge gibt, indem wir prüfen, ob der berechnete Hilfspunkt den Ursprung erreicht, und wenn dies nicht der Fall ist, muss der Ursprung außerhalb der Minkowski-Differenz liegen.  Daher können wir sagen, dass es keine Kollision / Kreuzung gibt. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Calculate(a: IShape, b: IShape): Collision | undefined { // Build a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> determining <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a collision has occurred <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> simplex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex(); // Choose an arbitrary starting direction <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction: Vector | undefined = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the first support point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> add it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initSupportPoint = support(a, b, direction); simplex.Add(initSupportPoint); // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert(); // Keep iterating until the direction <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined, this will occur when // <span class="hljs-comment"><span class="hljs-comment">'CalculateDirection' doesn't return a direction, indicating that an // intersection has been detected while(direction) { const supportPoint = support(a, b, direction); // If the support point did not reach as far as the origin, // the simplex must not contain the origin and therefore there is no // intersection if (supportPoint.Dot(direction!) &lt;= 0) { // No intersection return; } // Add the simplex and determine a new direction simplex.Add(supportPoint); direction = simplex.CalculateDirection(); } // No direction calculated, intersection detected return new Collision(a, b); }</span></span></code> </pre> <br>  Die gesamte Komplexität und interne Funktionsweise des Algorithmus erfolgt in <code>simplex.CalculateDirection</code> .  Diese Funktion bestimmt, ob sich der Ursprung im aktuellen Simplex befindet. In diesem Fall wird <code>undefined</code> .  Andernfalls wird eine neue Richtung zurückgegeben, um einen Hilfspunkt zu erhalten, der dem Simplex hinzugefügt werden muss. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Simplex { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> points: Vector[]; ... CalculateDirection(): Vector | undefined { // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex // C <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the oldest point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a-&gt;b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a-&gt;c lines <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ac = c.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); // Determine perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(c) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return abPerp; } // Determine perpendicular of the a-&gt;c line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> acPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ac.y, -ac.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(b) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { acPerp = acPerp.Invert(); } // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return acPerp; } return undefined; } // Otherwise the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> just a line // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex, // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> the other <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> of the line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a -&gt; b line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face TOWARDS the origin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } return abPerp; } }</code> </pre> <br>  Sie fragen sich vielleicht: Warum überprüfen wir nicht das BC-Segment?  Weil wir bedingungslos ausschließen können, dass der Ursprung entlang seiner Senkrechten liegt.  Da sich die Punkte B und C bereits im Simplex befinden und nicht nur hinzugefügt wurden, wissen wir, dass sie in der vorherigen Iteration überprüft wurden.  Sie können entweder als Teil eines Dreiecks oder als Segment der ersten beiden Punkte in einem Simplex überprüft werden - das spielt keine Rolle.  Daher können wir die BC-Segmentprüfung sicher überspringen. <br><br><h4>  Detaillierte Erklärung </h4><br>  Wir haben viel Code und es sieht verwirrend aus.  Im Folgenden werde ich die Schritte des Algorithmus für die oben gezeigten Abbildungen A und B analysieren. <br><br>  <strong>Punkte der Figuren A und B:</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  A </th><th>  B. </th><th>  C. </th><th>  D. </th><th>  E. </th><th>  F. </th></tr></thead><tbody><tr><td>  (0,1) </td><td>  (1, -1) </td><td>  (-1, -1) </td><td>  (0, -1) </td><td>  (1,1) </td><td>  (-1,1) </td></tr></tbody></table></div><br><ol><li>  Vorbereitung des Algorithmus;  wir nehmen <code>(0,1)</code> als Anfangsrichtung. <br><br><pre> <code class="vbscript hljs">// Build a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> determining <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a collision has occurred <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> simplex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex(); // Choose an arbitrary starting direction <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction: Vector | undefined = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br></li><li>  Wir bekommen den ersten Hilfspunkt. <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the first support point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> add it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initSupportPoint = support(a, b, direction); simplex.Add(initSupportPoint); // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert();</code> </pre> <br>  Wir erhalten den am weitesten entfernten Punkt von Punkt A in Richtung <code>(0,1)</code> und von Punkt B in Richtung <code>(0,-1)</code> . <br><br>  <strong>aFar:</strong> <code>(0,1)</code> und <strong>bFar:</strong> <code>(0,-1)</code> <br><br>  Verwenden Sie diese Werte, um den Hilfspunkt zu erhalten. <br><br>  <strong>Unterstützung:</strong> <em>aFar-bFar</em> = <code>(0,2)</code> <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> support(a: IShape, b: IShape, direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFar = a.FarthestPointInDirection(direction); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bFar = b.FarthestPointInDirection(direction.Invert()); return aFar.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(bFar); }</code> </pre> <br></li><li>  Wir drehen die Richtung für den nächsten Hilfspunkt um und beginnen mit der Iteration, wobei wir einen neuen Hilfspunkt berechnen. <br><br>  <strong>Unterstützung:</strong> <code>(0,-3)</code> <br><br><pre> <code class="vbscript hljs"> // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert(); // Keep iterating until the direction <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined, this will occur when // <span class="hljs-comment"><span class="hljs-comment">'CalculateDirection' doesn't return a direction, indicating that an // intersection has been detected while(direction) { const supportPoint = support(a, b, direction);</span></span></code> </pre> </li><li>  Überprüfen Sie, ob der Hilfspunkt den Ursprung erreicht hat.  Wenn nicht, sollte es keine Kreuzung geben.  Wenn sie den Ursprung erreicht hat, fügen Sie den Punkt dem Simplex hinzu. <br><br>  In diesem Fall hat der Hilfspunkt den Ursprung erreicht. <br><br>  <strong>Richtung:</strong> <code>(0,-1)</code> <br><br>  <strong>Unterstützung:</strong> <code>(0,-3)</code> <br><br>  <strong>supportPoint.Dot (Richtung):</strong> <code>3</code> <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the support point did <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reach as far as the origin, // the simplex must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contain the origin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> therefore there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> no // intersection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportPoint.Dot(direction!) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { // No intersection return; } // Add the simplex <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction simplex.Add(supportPoint);</code> </pre> <br></li><li>  Zu diesem Zeitpunkt ist der Simplex ein Segment, sodass er keinen Ursprungspunkt enthalten kann.  Definieren Sie eine neue Richtung, in die nach dem Hilfspunkt gesucht werden soll. <br><br><pre> <code class="vbscript hljs"> direction = simplex.CalculateDirection();</code> </pre> <br><ol><li>  Wir nehmen den letzten Punkt, der dem Simplex hinzugefügt wurde, und bestimmen die Richtung zum Ursprung. Dies ist der Kehrwert dieses Punktes. <br><br>  <strong>a:</strong> <code>(0,-3)</code> <strong>ao:</strong> <code>(0,3)</code> <br><br><pre> <code class="vbscript hljs"> CalculateDirection(): Vector | undefined { // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) {</code> </pre> </li><li>  Da der Simplex ein Segment und kein Dreieck ist, nehmen wir den zweiten Punkt des Segments und berechnen das Segment des Simplex. <br><br>  <strong>b:</strong> <code>(0,2)</code> <strong>ab:</strong> <code>(0,5)</code> <br><br><pre> <code class="vbscript hljs"> // Otherwise the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> just a line // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex, // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> the other <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> of the line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a -&gt; b line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a);</code> </pre> </li><li>  Wir berechnen die Senkrechte zu diesem Segment und überprüfen, ob es auf den Ursprung gerichtet ist.  Dies ist die neue Richtung für den nächsten Hilfspunkt. <br><br>  <strong>abPerp:</strong> <code>(5, 0)</code> <br><br>  <strong>abPerp.Dot (ao)</strong> <code>0</code> <br><br>  <strong>abPerp:</strong> <code>(-5, 0)</code> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef6/e2d/38d/ef6e2d38de9923b0788d6fb4c21491f3.png" alt="Diagramm der Linie ab und ihrer Senkrechten"></div><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face TOWARDS the origin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } return abPerp;</code> </pre> </li></ol></li><li>  Jetzt haben wir eine Richtung, um nach dem nächsten Hilfspunkt zu suchen.  Wir kehren zum Beginn des Zyklus zurück und verlassen ihn nicht, denn während wir eine Richtung haben und die Kreuzung noch nicht gefunden wurde. <br><br>  <strong>Richtung:</strong> <code>(-5, 0)</code> <br><br>  <strong>Unterstützung:</strong> <code>(-2,-2)</code> <br><br>  <strong>supportPoint.Dot (Richtung):</strong> <code>10</code> <br><br>  Der Hilfspunkt hat den Ursprung erreicht, daher können wir nicht sagen, dass es keinen Schnittpunkt gibt. <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(direction) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportPoint = support(a, b, direction); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the support point did <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reach as far as the origin, // the simplex must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contain the origin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> therefore there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> no // intersection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportPoint.Dot(direction!) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { // No intersection return; }</code> </pre> </li><li>  Fügen Sie dem Simplex einen neuen Hilfspunkt hinzu und erstellen Sie ein Dreieck.  Dieses Dreieck kann den Ursprung enthalten. Wenn dies der Fall ist, gibt der Simplex <code>undefined</code> und keine neue Richtung für die Suche. <br><br><pre> <code class="vbscript hljs"> // Add the simplex <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction simplex.Add(supportPoint); direction = simplex.CalculateDirection();</code> </pre> <br><ol><li>  Nehmen Sie die Punkte des Simplex des Dreiecks. <br>  <strong>a:</strong> <code>(-2,-2)</code> <strong>b:</strong> <code>(0,-3)</code> <strong>c:</strong> <code>(0,2)</code> <strong>ao:</strong> <code>(2,2)</code> <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex // C <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the oldest point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> </li><li>  Nehmen Sie die Segmente ab und ac. <br><br>  <strong>ab:</strong> <code>(2,-1)</code> <strong>ac:</strong> <code>(2,4)</code> <br><br><pre> <code class="vbscript hljs"> // Determine a-&gt;b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a-&gt;c lines <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ac = c.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a);</code> </pre> </li><li>  Wir berechnen die Senkrechte zum Segment ab, die vom Simplex gerichtet ist. <br><br>  <strong>abperp:</strong> <code>(-1,-2)</code> <br><br><pre> <code class="vbscript hljs"> // Determine perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(c) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); }</code> </pre> </li><li>  Wir bestimmen, ob der Ursprung außerhalb des Simplex jenseits von ab liegt. <br><br>  <strong>abPerp.Dot (ao):</strong> <code>-6</code> <br><br>  Der Ursprung liegt nicht außerhalb des Simplex jenseits von ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/12b/63d/84512b63d57ecf2e9e9a0b833f03d395.png" alt="Diagramm der Linie ab und ihrer Senkrechten"></div><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return abPerp; }</code> </pre> </li><li>  Wir berechnen die Senkrechte zu dem vom Simplex gerichteten Segment ac. <br><br>  <strong>acPerp:</strong> <code>(-4,2)</code> <br><br><pre> <code class="vbscript hljs"> // Determine perpendicular of the a-&gt;c line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> acPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ac.y, -ac.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(b) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { acPerp = acPerp.Invert(); }</code> </pre> </li><li>  Bestimmen Sie, ob der Ursprung außerhalb des Simplex jenseits von Wechselstrom liegt. <br><br>  <strong>acPerp.Dot (ao):</strong> <code>-4</code> <br><br>  Der Ursprung liegt nicht außerhalb des Simplex jenseits von ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/f52/962/2d6f52962deaea1aca8a87288d6f1dc6.png" alt="Diagramm der Linie ac und ihrer Senkrechten"></div><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return acPerp; }</code> </pre> </li><li>  Da AB und AC in dieser Iteration überprüft wurden und wir wissen, dass BC in der vorherigen Iteration überprüft wurde, muss der Ursprung im Simplex liegen, sodass eine Kollision / Kreuzung erkannt wurde. Wenn Sie darüber informiert werden, wird die Funktion <code>undefined</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bab/0de/57f/bab0de57f6848dc95e8cea565a549cc4.png" alt="Linien ab, ac und bc und relevante Senkrechte"></div></li></ol></li><li>  Da eine Kollision erkannt wurde, wird die Schleife verlassen und <code>Collision</code> über die Kollision zwischen den beiden Figuren werden zurückgegeben. <br><br><pre> <code class="vbscript hljs"> direction = simplex.CalculateDirection(); } // No direction calculated, intersection detected return <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collision(a, b);</code> </pre> </li></ol><br><h1>  Fazit </h1><br>  Ich hoffe, dieser Artikel hilft Ihnen, den GJK-Algorithmus zu verstehen.  Der Algorithmus gibt eine Ja / Nein-Antwort auf das Vorhandensein eines Konflikts zwischen den beiden Figuren.  Ein Arbeitsbeispiel mit Polygonen und Kreisen kann im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository für diesen Beitrag</a> angezeigt werden.  Sie können diesen Code mit zusätzlichen Algorithmen und Techniken erweitern, indem Sie versuchen, die Durchdringungsentfernung zwischen den beiden Figuren, der Kollisionsnormalen und dem Kontaktpunkt zu ermitteln.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dyn4j-Beitrag</a> enthält Links zu guten Ressourcen zu verschiedenen Kollisions- / Antworterkennungsalgorithmen.  Wenn Sie GJK erweitern möchten, sollten Sie sie studieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472404/">https://habr.com/ru/post/de472404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472388/index.html">Walmart erklärt Amazon Preiskrieg</a></li>
<li><a href="../de472392/index.html">Aufstieg, Fall und mögliche Rückkehr von Audiokassetten - wir beschäftigen uns mit Mythen und geben einen Überblick über die Situation</a></li>
<li><a href="../de472394/index.html">Bewertung der Auswirkungen künstlicher Intelligenz auf Offshore-Öl und -Gas</a></li>
<li><a href="../de472396/index.html">In 4 Sekunden um die Welt im Columnstore (Teil 1)</a></li>
<li><a href="../de472402/index.html">RTMP-Videoanruf-Streaming</a></li>
<li><a href="../de472406/index.html">Erweitern Sie das Rechenzentrum während der Pizza-Lieferung</a></li>
<li><a href="../de472410/index.html">Entwerfen verfügbarer Farbsysteme</a></li>
<li><a href="../de472412/index.html">Systemanalytiker und Produktmetriken - schütteln, aber nicht mischen?</a></li>
<li><a href="../de472414/index.html">Die lange Geschichte schneller Neutronenreaktoren und das Versprechen eines geschlossenen Brennstoffkreislaufs</a></li>
<li><a href="../de472416/index.html">ZeroNights Hackquest 2019 Ergebnisse und Zuschreibungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>