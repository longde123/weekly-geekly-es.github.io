<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèº üìÆ ‚ô¶Ô∏è 2D-Kollisionsberechnung: Gilbert-Johnson-Kirti-Algorithmus üöü üöß üëÇüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich nahm das Studium der Kollisionserkennungsprozesse auf und f√ºhrte mich zum Gilbert-Johnson-Keerthi (GJK) -Algorithmus. 

 Alle Codebeispiele im Bei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2D-Kollisionsberechnung: Gilbert-Johnson-Kirti-Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472404/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/837/791/d92837791f7e383147effd9265b24f91.png" alt="Bild"></div><br>  Ich nahm das Studium der Kollisionserkennungsprozesse auf und f√ºhrte mich zum Gilbert-Johnson-Keerthi (GJK) -Algorithmus. <br><br>  Alle Codebeispiele im Beitrag sind in TypeScript geschrieben.  In den Beispielen werden die von mir erstellten Strukturen verwendet, die im Beitrag nicht ausf√ºhrlich behandelt werden.  Sie sind einfach und k√∂nnen im GitHub-Repository angezeigt werden: <br><br><ul><li><code>Vector</code> </li> <li> <code>IShape</code> </li> <li> <code>Collision</code> </li> </ul><br>  Der gesamte Code aus dem Beitrag wird im GitHub-Repository gespeichert: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jthomperoo/gjk-ts-implementation</a> <br><br>  Der Beitrag wurde basierend auf diesem Artikel und dem darin empfohlenen Video geschrieben: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://mollyrocket.com/849</a> </li></ul><br><h2>  Einleitung </h2><br>  GJK ist ein Algorithmus zur Bestimmung des Schnittpunkts zweier konvexer Formen.  Es ist einfach und wird mithilfe einer verallgemeinerten ‚ÄûHilfsfunktion‚Äú implementiert, mit der Sie einen allgemeineren Ansatz verwenden k√∂nnen. Auf die gleiche Weise k√∂nnen Sie Polygone und Formen verarbeiten, die aus Kurven bestehen, z. B. Ellipsen. <br><a name="habracut"></a><br><h2>  Erforderliche Informationen </h2><br><h3>  Minkowski-Summe </h3><br>  GJK verwendet ein Konzept namens Minkowski-Summe.  SM wird berechnet, indem alle Punkte zweier Zahlen addiert werden.  Nehmen Sie zum Beispiel die beiden folgenden Abbildungen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/714/175/459/714175459fab7824d38f46a68b1b736d.png"></div><br>  <strong>Abbildung A (gr√ºn):</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  A </th><th>  B. </th><th>  C. </th></tr></thead><tbody><tr><td>  (0,1) </td><td>  (1, -1) </td><td>  (-1, -1) </td></tr></tbody></table></div><br>  <strong>Abbildung B (lila):</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  D. </th><th>  E. </th><th>  F. </th></tr></thead><tbody><tr><td>  (0, -1) </td><td>  (1,1) </td><td>  (-1,1) </td></tr></tbody></table></div><br>  Aus den Werten von Abbildung A und Abbildung B k√∂nnen wir die Minkowski-Summe berechnen: <br><br> <code>A + D = (0,1) + (0,-1) = (0,0) <br> <br> A + E = (0,1) + (1,1) = (1,2) <br> <br> A + F = (0,1) + (-1,1) = (-1,2) <br> <br> B + D = (1,-1) + (0,-1) = (1,-2) <br> <br> B + E = (1,-1) + (1,1) = (2,0) <br> <br> B + F = (1,-1) + (-1,1) = (0,0) <br> <br> C + D = (-1,-1) + (0,-1) = (-1,-2) <br> <br> C + E = (-1,-1) + (1,1) = (0,0) <br> <br> C + F = (-1,-1) + (-1,1) = (-2,0)</code> <br> <br>  Wenn wir diese Werte nehmen und daraus ein Diagramm erstellen, werden wir sehen, welche Zahl das Ergebnis sein wird. <br><br>  <strong>Minkowski-Summe f√ºr die Abbildungen A und B:</strong> <br><br>  <em>Beachten Sie, dass AD in Tabelle und Grafik A + D entspricht</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e40/64c/260/e4064c260487a98fb29c87fa43682ec5.png" alt="Diagramm von Minkowski Summe von Form A und B."></div><br><div class="scrollable-table"><table><thead><tr><th>  AD </th><th>  Ae </th><th>  AF </th><th>  Bd </th><th>  BE </th><th>  Bf </th><th>  CD </th><th>  CE </th><th>  CF. </th></tr></thead><tbody><tr><td>  (0,0) </td><td>  (1,2) </td><td>  (-1,2) </td><td>  (1, -2) </td><td>  (2.0) </td><td>  (0,0) </td><td>  (-1, -2) </td><td>  (0,0) </td><td>  (-2,0) </td></tr></tbody></table></div><br>  Um die Minkowski-Summe besser zu verstehen, k√∂nnen wir uns vorstellen, dass wir eine Zahl A nehmen und sie mit dem Umriss eines B umgehen. Die resultierende Zahl ist die Minkowski-Summe. <br><br><h3>  Minkowski Unterschied </h3><br>  GJK verwendet eine Variation der Minkowski-Summe, in der nicht A + B, sondern A - B verwendet wird. In den von mir gelesenen Quellen wird dies als ‚ÄûMinkowski-Differenz‚Äú bezeichnet.  Der Minkowski-Unterschied hat eine interessante Eigenschaft: Wenn sich zwei Figuren √ºberlappen / schneiden, enth√§lt der resultierende Minkowski-Unterschied den Ursprung.  Und das ist die Basis des GJK-Algorithmus. <br><br>  Aus den Werten der Abbildungen A und B k√∂nnen wir die Minkowski-Differenz berechnen: <br><br> <code>A - D = (0,1) - (0,-1) = (0,2) <br> <br> A - E = (0,1) - (1,1) = (-1,0) <br> <br> A - F = (0,1) - (-1,1) = (1,0) <br> <br> B - D = (1,-1) - (0,-1) = (-1,0) <br> <br> B - E = (1,-1) - (1,1) = (0,-2) <br> <br> B - F = (1,-1) - (-1,1) = (2,-2) <br> <br> C - D = (-1,-1) - (0,-1) = (-1,0) <br> <br> C - E = (-1,-1) - (1,1) = (-2,-2) <br> <br> C - F = (-1,-1) - (-1,1) = (0,-2)</code> <br> <br>  Wenn wir diese Werte nehmen und in die Grafik einf√ºgen, sehen wir die resultierende Zahl. <br><br>  <strong>Minkowski-Unterschied f√ºr die Abbildungen A und B:</strong> <br><br>  <em>Beachten Sie, dass sich AD in Tabelle und Grafik auf A - D bezieht</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/141/a87/b0f141a87c0f42c4c1f64956a8458082.png" alt="Diagramm von Minkowski Summe von Form A und B."></div><br><div class="scrollable-table"><table><thead><tr><th>  AD </th><th>  Ae </th><th>  AF </th><th>  Bd </th><th>  BE </th><th>  Bf </th><th>  CD </th><th>  CE </th><th>  CF. </th></tr></thead><tbody><tr><td>  (0,2) </td><td>  (-1,0) </td><td>  (1,0) </td><td>  (-1,0) </td><td>  (0, -2) </td><td>  (2, -2) </td><td>  (-1,0) </td><td>  (-2, -2) </td><td>  (0, -2) </td></tr></tbody></table></div><br><h2>  Algorithmus </h2><br>  Basierend auf diesen Konzepten optimiert der GJK-Algorithmus sie.  Die Berechnung der Minkowski-Summe kann viel Zeit in Anspruch nehmen, insbesondere wenn Sie den Schnittpunkt zweier aus vielen Punkten bestehender Zahlen √ºberpr√ºfen.  Um dies zu vermeiden, verwendet GJK zwei Schl√ºsselkonzepte: Hilfsfunktionen und Simplexe. <br><br><h3>  Hilfsfunktionen </h3><br>  Hilfsfunktionen sind eine M√∂glichkeit, einen Punkt am Rand der Minkowski-Differenz abzutasten, ohne die gesamte Figur zu konstruieren.  Die Hilfsfunktion erh√§lt zwei verglichene Zahlen und die Richtung, die √ºberpr√ºft werden muss.  Dann empf√§ngt die Hilfsfunktion von jeder Figur einen Punkt, der von zwei entgegengesetzten Richtungen am weitesten entfernt ist.  Mit diesen beiden am weitesten entfernten Punkten k√∂nnen Sie den Hilfspunkt auf der Zahl der Minkowski-Differenz berechnen.  Wir nehmen Punkte aus entgegengesetzten Richtungen, weil wir einen Punkt auf der Minkowski-Differenz erhalten, der uns die gr√∂√üte Fl√§che gibt, dh es besteht eine h√∂here Wahrscheinlichkeit, dass wir den Ursprung in die Abbildung aufnehmen.  Da die Minkowski-Differenz der <code>    a -     b</code> das Vorhandensein des Punktes der Figur b, der aus der entgegengesetzten Richtung abgetastet wurde, einen Hilfspunkt, der so weit wie m√∂glich in dieser Richtung liegt. <br><br>  Die Implementierung der Hilfsfunktion ist recht einfach: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> support(a: IShape, b: IShape, direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFar = a.FarthestPointInDirection(direction); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bFar = b.FarthestPointInDirection(direction.Invert()); return aFar.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(bFar); }</code> </pre> <br>  Einer der Vorteile von GJK ist, dass <code>FarthestPointInDirection</code> abstrahiert und auf Polygone und Kurven angewendet werden kann.  Hier ist die Implementierung von <code>FarthestPointInDirection</code> f√ºr ein Polygon. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Polygon implements IShape { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> points: Vector[]; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FarthestPointInDirection(direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> farthestDistance = -Infinity; // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> there are no points, just return point <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> farthestPoint: Vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point of this.points) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceInDirection = point.Dot(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distanceInDirection &gt; farthestDistance) { farthestPoint = point; farthestDistance = distanceInDirection; } } return farthestPoint; } }</code> </pre> <br>  Wenn Sie sehen m√∂chten, wie andere Formen implementiert werden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie das Git-Repository dieses Beitrags</a> , in dem die Implementierung f√ºr <code>Circle</code> . <br><br>  So wird der Hilfspunkt in <strong>(1,0)</strong> -Richtung f√ºr die Abbildungen A und B berechnet: <br><br><ol><li>  Nehmen Sie den entferntesten Punkt von der Figur A;  es stellt sich heraus, Punkt <strong>B (1, -1) zu sein</strong> .  (Sie k√∂nnen es wie den oben gezeigten Algorithmus berechnen oder es einfach anhand des Diagramms anzeigen.) </li><li>  Nehmen Sie den entferntesten Punkt von Abbildung B;  es stellt sich heraus, dass es der Punkt <strong>F (-1, 1) ist</strong> . </li><li>  Berechnen Sie <strong>B - F</strong> ;  es stellt sich heraus, dass es der Punkt <strong>BF (2, -2) ist</strong> - es wird ein Hilfspunkt sein. </li></ol><br><h3>  Simplexe </h3><br>  Ein Simplex ist eine Stichprobe von Punkten entlang der Minkowski-Differenzzahl.  Simplexe k√∂nnen bis zu drei Punkte enthalten.  GJK verwendet sie und versucht, ein Dreieck um den Ursprung zu konstruieren, um das Auftreten einer Kollision zu bestimmen. <br><br><h4>  Simplex-Konstruktion </h4><br>  Simplexe werden iterativ konstruiert, indem Hilfspunkte in verschiedene Richtungen hinzugef√ºgt werden.  Jeder Hilfspunkt sollte in eine neue Richtung zeigen, damit wir so schnell wie m√∂glich einen Simplex mit einem Ursprungspunkt erstellen k√∂nnen.  Die Schwierigkeit liegt in der Wahl der Richtung, in die der n√§chste Hilfspunkt gelangen soll. <br><br><h3>  Kollisionserkennung und Richtungsauswahl </h3><br>  Der Basisalgorithmus erstellt einfach mithilfe einer Hilfsfunktion einen Simplex und versucht, einen Ursprungspunkt in die Abbildung einzuschlie√üen.  Wir k√∂nnen verstehen, dass es keine Kollision / Schnittmenge gibt, indem wir pr√ºfen, ob der berechnete Hilfspunkt den Ursprung erreicht, und wenn dies nicht der Fall ist, muss der Ursprung au√üerhalb der Minkowski-Differenz liegen.  Daher k√∂nnen wir sagen, dass es keine Kollision / Kreuzung gibt. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Calculate(a: IShape, b: IShape): Collision | undefined { // Build a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> determining <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a collision has occurred <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> simplex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex(); // Choose an arbitrary starting direction <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction: Vector | undefined = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the first support point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> add it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initSupportPoint = support(a, b, direction); simplex.Add(initSupportPoint); // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert(); // Keep iterating until the direction <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined, this will occur when // <span class="hljs-comment"><span class="hljs-comment">'CalculateDirection' doesn't return a direction, indicating that an // intersection has been detected while(direction) { const supportPoint = support(a, b, direction); // If the support point did not reach as far as the origin, // the simplex must not contain the origin and therefore there is no // intersection if (supportPoint.Dot(direction!) &lt;= 0) { // No intersection return; } // Add the simplex and determine a new direction simplex.Add(supportPoint); direction = simplex.CalculateDirection(); } // No direction calculated, intersection detected return new Collision(a, b); }</span></span></code> </pre> <br>  Die gesamte Komplexit√§t und interne Funktionsweise des Algorithmus erfolgt in <code>simplex.CalculateDirection</code> .  Diese Funktion bestimmt, ob sich der Ursprung im aktuellen Simplex befindet. In diesem Fall wird <code>undefined</code> .  Andernfalls wird eine neue Richtung zur√ºckgegeben, um einen Hilfspunkt zu erhalten, der dem Simplex hinzugef√ºgt werden muss. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Simplex { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> points: Vector[]; ... CalculateDirection(): Vector | undefined { // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex // C <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the oldest point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a-&gt;b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a-&gt;c lines <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ac = c.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); // Determine perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(c) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return abPerp; } // Determine perpendicular of the a-&gt;c line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> acPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ac.y, -ac.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(b) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { acPerp = acPerp.Invert(); } // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return acPerp; } return undefined; } // Otherwise the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> just a line // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex, // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> the other <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> of the line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a -&gt; b line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face TOWARDS the origin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } return abPerp; } }</code> </pre> <br>  Sie fragen sich vielleicht: Warum √ºberpr√ºfen wir nicht das BC-Segment?  Weil wir bedingungslos ausschlie√üen k√∂nnen, dass der Ursprung entlang seiner Senkrechten liegt.  Da sich die Punkte B und C bereits im Simplex befinden und nicht nur hinzugef√ºgt wurden, wissen wir, dass sie in der vorherigen Iteration √ºberpr√ºft wurden.  Sie k√∂nnen entweder als Teil eines Dreiecks oder als Segment der ersten beiden Punkte in einem Simplex √ºberpr√ºft werden - das spielt keine Rolle.  Daher k√∂nnen wir die BC-Segmentpr√ºfung sicher √ºberspringen. <br><br><h4>  Detaillierte Erkl√§rung </h4><br>  Wir haben viel Code und es sieht verwirrend aus.  Im Folgenden werde ich die Schritte des Algorithmus f√ºr die oben gezeigten Abbildungen A und B analysieren. <br><br>  <strong>Punkte der Figuren A und B:</strong> <br><br><div class="scrollable-table"><table><thead><tr><th>  A </th><th>  B. </th><th>  C. </th><th>  D. </th><th>  E. </th><th>  F. </th></tr></thead><tbody><tr><td>  (0,1) </td><td>  (1, -1) </td><td>  (-1, -1) </td><td>  (0, -1) </td><td>  (1,1) </td><td>  (-1,1) </td></tr></tbody></table></div><br><ol><li>  Vorbereitung des Algorithmus;  wir nehmen <code>(0,1)</code> als Anfangsrichtung. <br><br><pre> <code class="vbscript hljs">// Build a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> determining <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a collision has occurred <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> simplex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Simplex(); // Choose an arbitrary starting direction <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> direction: Vector | undefined = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br></li><li>  Wir bekommen den ersten Hilfspunkt. <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the first support point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> add it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initSupportPoint = support(a, b, direction); simplex.Add(initSupportPoint); // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert();</code> </pre> <br>  Wir erhalten den am weitesten entfernten Punkt von Punkt A in Richtung <code>(0,1)</code> und von Punkt B in Richtung <code>(0,-1)</code> . <br><br>  <strong>aFar:</strong> <code>(0,1)</code> und <strong>bFar:</strong> <code>(0,-1)</code> <br><br>  Verwenden Sie diese Werte, um den Hilfspunkt zu erhalten. <br><br>  <strong>Unterst√ºtzung:</strong> <em>aFar-bFar</em> = <code>(0,2)</code> <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> support(a: IShape, b: IShape, direction: Vector): Vector { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFar = a.FarthestPointInDirection(direction); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bFar = b.FarthestPointInDirection(direction.Invert()); return aFar.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(bFar); }</code> </pre> <br></li><li>  Wir drehen die Richtung f√ºr den n√§chsten Hilfspunkt um und beginnen mit der Iteration, wobei wir einen neuen Hilfspunkt berechnen. <br><br>  <strong>Unterst√ºtzung:</strong> <code>(0,-3)</code> <br><br><pre> <code class="vbscript hljs"> // Flip the direction <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> support point direction = direction.Invert(); // Keep iterating until the direction <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> undefined, this will occur when // <span class="hljs-comment"><span class="hljs-comment">'CalculateDirection' doesn't return a direction, indicating that an // intersection has been detected while(direction) { const supportPoint = support(a, b, direction);</span></span></code> </pre> </li><li>  √úberpr√ºfen Sie, ob der Hilfspunkt den Ursprung erreicht hat.  Wenn nicht, sollte es keine Kreuzung geben.  Wenn sie den Ursprung erreicht hat, f√ºgen Sie den Punkt dem Simplex hinzu. <br><br>  In diesem Fall hat der Hilfspunkt den Ursprung erreicht. <br><br>  <strong>Richtung:</strong> <code>(0,-1)</code> <br><br>  <strong>Unterst√ºtzung:</strong> <code>(0,-3)</code> <br><br>  <strong>supportPoint.Dot (Richtung):</strong> <code>3</code> <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the support point did <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reach as far as the origin, // the simplex must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contain the origin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> therefore there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> no // intersection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportPoint.Dot(direction!) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { // No intersection return; } // Add the simplex <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction simplex.Add(supportPoint);</code> </pre> <br></li><li>  Zu diesem Zeitpunkt ist der Simplex ein Segment, sodass er keinen Ursprungspunkt enthalten kann.  Definieren Sie eine neue Richtung, in die nach dem Hilfspunkt gesucht werden soll. <br><br><pre> <code class="vbscript hljs"> direction = simplex.CalculateDirection();</code> </pre> <br><ol><li>  Wir nehmen den letzten Punkt, der dem Simplex hinzugef√ºgt wurde, und bestimmen die Richtung zum Ursprung. Dies ist der Kehrwert dieses Punktes. <br><br>  <strong>a:</strong> <code>(0,-3)</code> <strong>ao:</strong> <code>(0,3)</code> <br><br><pre> <code class="vbscript hljs"> CalculateDirection(): Vector | undefined { // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) {</code> </pre> </li><li>  Da der Simplex ein Segment und kein Dreieck ist, nehmen wir den zweiten Punkt des Segments und berechnen das Segment des Simplex. <br><br>  <strong>b:</strong> <code>(0,2)</code> <strong>ab:</strong> <code>(0,5)</code> <br><br><pre> <code class="vbscript hljs"> // Otherwise the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> just a line // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex, // <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> the other <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> of the line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // Determine a -&gt; b line <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a);</code> </pre> </li><li>  Wir berechnen die Senkrechte zu diesem Segment und √ºberpr√ºfen, ob es auf den Ursprung gerichtet ist.  Dies ist die neue Richtung f√ºr den n√§chsten Hilfspunkt. <br><br>  <strong>abPerp:</strong> <code>(5, 0)</code> <br><br>  <strong>abPerp.Dot (ao)</strong> <code>0</code> <br><br>  <strong>abPerp:</strong> <code>(-5, 0)</code> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef6/e2d/38d/ef6e2d38de9923b0788d6fb4c21491f3.png" alt="Diagramm der Linie ab und ihrer Senkrechten"></div><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> the perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face TOWARDS the origin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); } return abPerp;</code> </pre> </li></ol></li><li>  Jetzt haben wir eine Richtung, um nach dem n√§chsten Hilfspunkt zu suchen.  Wir kehren zum Beginn des Zyklus zur√ºck und verlassen ihn nicht, denn w√§hrend wir eine Richtung haben und die Kreuzung noch nicht gefunden wurde. <br><br>  <strong>Richtung:</strong> <code>(-5, 0)</code> <br><br>  <strong>Unterst√ºtzung:</strong> <code>(-2,-2)</code> <br><br>  <strong>supportPoint.Dot (Richtung):</strong> <code>10</code> <br><br>  Der Hilfspunkt hat den Ursprung erreicht, daher k√∂nnen wir nicht sagen, dass es keinen Schnittpunkt gibt. <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(direction) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportPoint = support(a, b, direction); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the support point did <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reach as far as the origin, // the simplex must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> contain the origin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> therefore there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> no // intersection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportPoint.Dot(direction!) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { // No intersection return; }</code> </pre> </li><li>  F√ºgen Sie dem Simplex einen neuen Hilfspunkt hinzu und erstellen Sie ein Dreieck.  Dieses Dreieck kann den Ursprung enthalten. Wenn dies der Fall ist, gibt der Simplex <code>undefined</code> und keine neue Richtung f√ºr die Suche. <br><br><pre> <code class="vbscript hljs"> // Add the simplex <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction simplex.Add(supportPoint); direction = simplex.CalculateDirection();</code> </pre> <br><ol><li>  Nehmen Sie die Punkte des Simplex des Dreiecks. <br>  <strong>a:</strong> <code>(-2,-2)</code> <strong>b:</strong> <code>(0,-3)</code> <strong>c:</strong> <code>(0,2)</code> <strong>ao:</strong> <code>(2,2)</code> <br><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a, the last point added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = this.points[this.points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; // Since a was just added, we know that the inverse of a points // towards the origin <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ao = a.Invert(); // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a triangle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.points.length == <span class="hljs-number"><span class="hljs-number">3</span></span>) { // B <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the penultimate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex // C <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the oldest point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the simplex <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = this.points[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = this.points[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> </li><li>  Nehmen Sie die Segmente ab und ac. <br><br>  <strong>ab:</strong> <code>(2,-1)</code> <strong>ac:</strong> <code>(2,4)</code> <br><br><pre> <code class="vbscript hljs"> // Determine a-&gt;b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a-&gt;c lines <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ab = b.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ac = c.<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>(a);</code> </pre> </li><li>  Wir berechnen die Senkrechte zum Segment ab, die vom Simplex gerichtet ist. <br><br>  <strong>abperp:</strong> <code>(-1,-2)</code> <br><br><pre> <code class="vbscript hljs"> // Determine perpendicular of the a-&gt;b line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ab.y, -ab.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(c) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { abPerp = abPerp.Invert(); }</code> </pre> </li><li>  Wir bestimmen, ob der Ursprung au√üerhalb des Simplex jenseits von ab liegt. <br><br>  <strong>abPerp.Dot (ao):</strong> <code>-6</code> <br><br>  Der Ursprung liegt nicht au√üerhalb des Simplex jenseits von ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/12b/63d/84512b63d57ecf2e9e9a0b833f03d395.png" alt="Diagramm der Linie ab und ihrer Senkrechten"></div><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return abPerp; }</code> </pre> </li><li>  Wir berechnen die Senkrechte zu dem vom Simplex gerichteten Segment ac. <br><br>  <strong>acPerp:</strong> <code>(-4,2)</code> <br><br><pre> <code class="vbscript hljs"> // Determine perpendicular of the a-&gt;c line <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> acPerp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(ac.y, -ac.x); // Check the handedness of the perpendicular, it should // face AWAY from the simplex <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(b) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { acPerp = acPerp.Invert(); }</code> </pre> </li><li>  Bestimmen Sie, ob der Ursprung au√üerhalb des Simplex jenseits von Wechselstrom liegt. <br><br>  <strong>acPerp.Dot (ao):</strong> <code>-4</code> <br><br>  Der Ursprung liegt nicht au√üerhalb des Simplex jenseits von ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/f52/962/2d6f52962deaea1aca8a87288d6f1dc6.png" alt="Diagramm der Linie ac und ihrer Senkrechten"></div><br><pre> <code class="vbscript hljs"> // <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the origin lies outside of the simplex remove the // point <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> determine a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> direction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the direction // of the perpendicular; aiming <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> encapsulate // the origin that lies outside <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acPerp.Dot(ao) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { this.points.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); return acPerp; }</code> </pre> </li><li>  Da AB und AC in dieser Iteration √ºberpr√ºft wurden und wir wissen, dass BC in der vorherigen Iteration √ºberpr√ºft wurde, muss der Ursprung im Simplex liegen, sodass eine Kollision / Kreuzung erkannt wurde. Wenn Sie dar√ºber informiert werden, wird die Funktion <code>undefined</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bab/0de/57f/bab0de57f6848dc95e8cea565a549cc4.png" alt="Linien ab, ac und bc und relevante Senkrechte"></div></li></ol></li><li>  Da eine Kollision erkannt wurde, wird die Schleife verlassen und <code>Collision</code> √ºber die Kollision zwischen den beiden Figuren werden zur√ºckgegeben. <br><br><pre> <code class="vbscript hljs"> direction = simplex.CalculateDirection(); } // No direction calculated, intersection detected return <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collision(a, b);</code> </pre> </li></ol><br><h1>  Fazit </h1><br>  Ich hoffe, dieser Artikel hilft Ihnen, den GJK-Algorithmus zu verstehen.  Der Algorithmus gibt eine Ja / Nein-Antwort auf das Vorhandensein eines Konflikts zwischen den beiden Figuren.  Ein Arbeitsbeispiel mit Polygonen und Kreisen kann im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository f√ºr diesen Beitrag</a> angezeigt werden.  Sie k√∂nnen diesen Code mit zus√§tzlichen Algorithmen und Techniken erweitern, indem Sie versuchen, die Durchdringungsentfernung zwischen den beiden Figuren, der Kollisionsnormalen und dem Kontaktpunkt zu ermitteln.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dyn4j-Beitrag</a> enth√§lt Links zu guten Ressourcen zu verschiedenen Kollisions- / Antworterkennungsalgorithmen.  Wenn Sie GJK erweitern m√∂chten, sollten Sie sie studieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472404/">https://habr.com/ru/post/de472404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472388/index.html">Walmart erkl√§rt Amazon Preiskrieg</a></li>
<li><a href="../de472392/index.html">Aufstieg, Fall und m√∂gliche R√ºckkehr von Audiokassetten - wir besch√§ftigen uns mit Mythen und geben einen √úberblick √ºber die Situation</a></li>
<li><a href="../de472394/index.html">Bewertung der Auswirkungen k√ºnstlicher Intelligenz auf Offshore-√ñl und -Gas</a></li>
<li><a href="../de472396/index.html">In 4 Sekunden um die Welt im Columnstore (Teil 1)</a></li>
<li><a href="../de472402/index.html">RTMP-Videoanruf-Streaming</a></li>
<li><a href="../de472406/index.html">Erweitern Sie das Rechenzentrum w√§hrend der Pizza-Lieferung</a></li>
<li><a href="../de472410/index.html">Entwerfen verf√ºgbarer Farbsysteme</a></li>
<li><a href="../de472412/index.html">Systemanalytiker und Produktmetriken - sch√ºtteln, aber nicht mischen?</a></li>
<li><a href="../de472414/index.html">Die lange Geschichte schneller Neutronenreaktoren und das Versprechen eines geschlossenen Brennstoffkreislaufs</a></li>
<li><a href="../de472416/index.html">ZeroNights Hackquest 2019 Ergebnisse und Zuschreibungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>