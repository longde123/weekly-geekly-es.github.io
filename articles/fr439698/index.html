<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚱️ 🛍️ 👩🏾‍⚖️ Introduction à la programmation: un simple jeu de tir 3D à partir de zéro au cours du week-end, partie 1 💃 🏌️ 👨🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce texte est destiné à ceux qui maîtrisent simplement la programmation. L'idée principale est de montrer étape par étape comment créer indépendamment ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à la programmation: un simple jeu de tir 3D à partir de zéro au cours du week-end, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439698/">  Ce texte est destiné à ceux qui maîtrisent simplement la programmation.  L'idée principale est de montrer étape par étape comment créer indépendamment le jeu à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wolfenstein 3D</a> .  Attention, je ne vais pas du tout rivaliser avec Carmack, c'est un génie et son code est magnifique.  Je vis dans un endroit complètement différent: j'utilise l'énorme puissance de calcul des ordinateurs modernes pour que les étudiants puissent créer des projets amusants en quelques jours sans s'enliser dans la folie de l'optimisation.  J'écris spécifiquement du code lent, car il est beaucoup plus court et plus facile à comprendre.  Carmack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit 0x5f3759df</a> , j'écris 1 / sqrt (x).  Nous avons des objectifs différents. <br><br>  Je suis convaincu qu'un bon programmeur n'est obtenu que de quelqu'un qui code à la maison pour le plaisir, et pas seulement assis à deux à l'université.  Dans notre université, les programmeurs apprennent une série sans fin de toutes sortes de catalogues de bibliothèques et autres ennuis.  Brr  Mon objectif est de montrer des exemples de projets intéressants à programmer.  C'est un cercle vicieux: s'il est intéressant de faire un projet, alors une personne y passe beaucoup de temps, acquiert de l'expérience et voit des choses encore plus intéressantes autour de lui (c'est devenu plus accessible!), Et encore une fois plonge dans un nouveau projet.  C'est ce qu'on appelle la formation de projet, autour de bénéfices solides. <br><br>  La feuille s'est avérée longue, j'ai donc divisé le texte en deux parties: <br><br><ul><li>  <b>Première partie: dessiner des murs</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxième partie: habiter notre interface monde + fenêtre</a> </li></ul><br>  L'exécution de code à partir de mon référentiel ressemble à ceci: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zPIVTqVilCM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ce n'est pas un jeu fini, mais seulement un blanc pour les étudiants.  Un exemple d'un jeu fini écrit par deux étudiants de première année, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la deuxième partie</a> . <br><a name="habracut"></a><br>  Il se trouve que je vous ai un peu trompé, je ne vous dirai pas comment faire un jeu complet en un week-end.  Je n'ai fait qu'un moteur 3D.  Les monstres ne me courent pas dessus et le personnage principal ne tire pas.  Mais au moins j'ai écrit ce moteur en un samedi, vous pouvez vérifier l'historique des commits.  En principe, les dimanches suffisent à rendre quelque chose de jouable, c'est-à-dire un week-end que vous pouvez rencontrer. <br><br>  Au moment d'écrire ces lignes, le référentiel contient 486 lignes de code: <br><br><pre><code class="bash hljs">haqreu@daffodil:~/tinyraycaster$ cat *.cpp *.h | wc -l 486</code> </pre> <br>  Le projet dépend de SDL2, mais en général l'interface de la fenêtre et le traitement des événements depuis le clavier apparaissent assez tard, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à minuit samedi</a> :), alors que tout le code de rendu a déjà été fait. <br><br>  Donc, je décompose tout le code en étapes, en commençant par le compilateur C ++ nu.  Comme dans mes précédents articles sur le planning ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tyts</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tyts</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tyts</a> ), j'adhère à la règle «one step = one commit», car github facilite l'affichage de l'historique des changements de code. <br><br><h1>  Étape 1: enregistrer l'image sur le disque </h1><br>  Alors allons-y.  Nous sommes encore très loin de l'interface de la fenêtre, pour commencer, nous allons simplement enregistrer les images sur le disque.  Au total, nous devons être en mesure de stocker l'image dans la mémoire de l'ordinateur et de l'enregistrer sur le disque dans un format que certains programmes tiers comprendront.  Je veux obtenir ce fichier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bc/757/fd3/8bc757fd3da42088dbf24380970e109d.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le</a> code C ++ complet qui dessine ce dont nous avons besoin: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;cstdint&gt; #include &lt;cassert&gt; uint32_t pack_color(const uint8_t r, const uint8_t g, const uint8_t b, const uint8_t a=255) { return (a&lt;&lt;24) + (b&lt;&lt;16) + (g&lt;&lt;8) + r; } void unpack_color(const uint32_t &amp;color, uint8_t &amp;r, uint8_t &amp;g, uint8_t &amp;b, uint8_t &amp;a) { r = (color &gt;&gt; 0) &amp; 255; g = (color &gt;&gt; 8) &amp; 255; b = (color &gt;&gt; 16) &amp; 255; a = (color &gt;&gt; 24) &amp; 255; } void drop_ppm_image(const std::string filename, const std::vector&lt;uint32_t&gt; &amp;image, const size_t w, const size_t h) { assert(image.size() == w*h); std::ofstream ofs(filename); ofs &lt;&lt; "P6\n" &lt;&lt; w &lt;&lt; " " &lt;&lt; h &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; h*w; ++i) { uint8_t r, g, b, a; unpack_color(image[i], r, g, b, a); ofs &lt;&lt; static_cast&lt;char&gt;(r) &lt;&lt; static_cast&lt;char&gt;(g) &lt;&lt; static_cast&lt;char&gt;(b); } ofs.close(); } int main() { const size_t win_w = 512; // image width const size_t win_h = 512; // image height std::vector&lt;uint32_t&gt; framebuffer(win_w*win_h, 255); // the image itself, initialized to red for (size_t j = 0; j&lt;win_h; j++) { // fill the screen with color gradients for (size_t i = 0; i&lt;win_w; i++) { uint8_t r = 255*j/float(win_h); // varies between 0 and 255 as j sweeps the vertical uint8_t g = 255*i/float(win_w); // varies between 0 and 255 as i sweeps the horizontal uint8_t b = 0; framebuffer[i+j*win_w] = pack_color(r, g, b); } } drop_ppm_image("./out.ppm", framebuffer, win_w, win_h); return 0; }</span></span></span></span></code> </pre><br>  Si vous n'avez pas de compilateur à portée de main, cela n'a pas d'importance, si vous avez un compte sur un github, vous pouvez voir ce code, le modifier et l'exécuter (sic!) En un clic directement depuis le navigateur. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br>  En suivant ce lien, gitpod créera une machine virtuelle pour vous, lancera VS Code et ouvrira un terminal sur la machine distante.  Dans l'historique des commandes du terminal (cliquez sur la console et appuyez sur la flèche vers le haut), il existe déjà un ensemble complet de commandes qui vous permettent de compiler le code, de l'exécuter et d'ouvrir l'image résultante. <br><br>  Donc, ce que vous devez comprendre de ce code.  Tout d'abord, les couleurs que je stocke dans un type entier à quatre octets uint32_t.  Chaque octet est un composant de R, G, B ou A. Les fonctions pack_color () et unpack_color () vous permettent d'accéder aux composants individuels de chaque couleur. <br><br>  La deuxième image bidimensionnelle que je stocke dans le tableau unidimensionnel habituel.  Pour arriver au pixel avec les coordonnées (x, y) je n'écris pas l'image [x] [y], mais j'écris l'image [x + y * largeur].  Si cette méthode de regroupement d'informations bidimensionnelles dans un tableau unidimensionnel est nouvelle pour vous, saisissez dès maintenant un stylo et traitez-le.  Pour moi personnellement, cette étape n'atteint même pas le cerveau, elle est traitée directement dans la moelle épinière.  Les tableaux tridimensionnels et plus dimensionnels peuvent être emballés exactement de la même manière, mais nous ne dépasserons pas les deux composants. <br><br>  Ensuite, je parcours ma photo dans un double cycle simple, la remplis d'un dégradé et l'enregistre sur le disque au format .ppm. <br><br><hr><br><h1>  Étape 2: dessinez une carte de niveau </h1><br>  Nous avons besoin d'une carte de notre monde.  À ce stade, je veux simplement déterminer la structure des données et dessiner une carte à l'écran.  Cela devrait ressembler à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/c96/1c7/7b8c961c7be837c6c9777770b0eed987.png"><br><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> .  Tout y est simple: j'ai codé en dur la carte en un tableau unidimensionnel de caractères, défini la fonction de dessiner un rectangle et parcouru la carte en dessinant chaque cellule. <br><br>  Je vous rappelle que ce bouton lancera le code à ce stade: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 3: ajouter un joueur </h1><br>  De quoi avons-nous besoin pour dessiner un joueur sur la carte?  Les coordonnées GPS suffisent :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf0/dfa/e21/cf0dfae212fd0372d368f53334218301.png"><br><br>  Ajoutez deux variables x et y et dessinez le joueur à l'endroit approprié: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b8/519/2e6/8b85192e6a40e7b146ecc98d219f895b.png"><br><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> .  À propos de gitpod, je ne m'en souviendrai plus :) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 4: aka trace de premier rayon du télémètre virtuel </h1><br>  En plus des coordonnées du joueur, ce serait bien de savoir dans quelle direction il regarde.  Par conséquent, nous ajoutons une autre variable player_a, qui donne la direction du regard du joueur (l'angle entre la direction du regard et l'axe des abscisses): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/f9a/af5/08df9aaf5713ca862e718a5fb0095d03.png"><br><br>  Et maintenant je veux pouvoir glisser le long du rayon orange.  Comment faire  Extrêmement simple.  Regardons un triangle vert à droite.  Nous savons que cos (player_a) = a / c, et que sin (player_a) = b / c. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99c/338/bcf/99c338bcf91ba076c1bd2bfdb15e129d.png"><br><br>  Que se passe-t-il si je prends arbitrairement c (positif) et compte x = player_x + c * cos (player_a) et y = player_y + c * sin (player_a)?  Nous nous retrouverons au point violet;  en faisant varier le paramètre c de zéro à l'infini, on peut faire glisser ce point violet le long de notre rayon orange, et c est la distance de (x, y) à (player_x, player_y)! <br><br>  Le cœur de notre moteur graphique est ce cycle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; c&lt;<span class="hljs-number"><span class="hljs-number">20</span></span>; c+=<span class="hljs-number"><span class="hljs-number">.05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = player_x + c*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(player_a); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = player_y + c*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(player_a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(x)+<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(y)*map_w]!=<span class="hljs-string"><span class="hljs-string">' '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  On déplace le point (x, y) le long du rayon, s'il rencontre un obstacle sur la carte, alors on termine le cycle, et la variable c donne la distance à l'obstacle!  Qu'est-ce qui n'est pas un télémètre laser? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9f/52d/3ce/c9f52d3ceaaffc1b4396fd13c9ab24df.png"><br><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 5: Aperçu du secteur </h1><br>  Un faisceau est très bien, mais nos yeux voient toujours tout un secteur.  Appelons l'angle de vue fov (champ de vision): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d4/83a/e06/1d483ae06cf65809eea61660c1a58db5.png"><br><br>  Et libérons 512 rayons (au fait, pourquoi 512?), Balayant en douceur tout le secteur de visionnement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fab/271/d5d/fab271d5dfe3dd4e8b87df6fc4c52676.png"><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 6: 3D! </h1><br>  Et maintenant le point clé.  Pour chacun des 512 rayons, nous avons obtenu la distance de l'obstacle le plus proche, non?  Et maintenant, faisons une deuxième image de 512 pixels de large (spoiler);  dans lequel pour chaque rayon, nous dessinerons un segment vertical, et la hauteur du segment est inversement proportionnelle à la distance à l'obstacle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f4/bf6/c7c/4f4bf6c7caa9931a087d04d6f33b4dbc.png"><br><br>  Encore une fois, c'est la clé pour créer l'illusion 3D, assurez-vous de bien comprendre ce qui est en jeu.  En dessinant des segments verticaux, en fait, nous dessinons une clôture de piquetage, où la hauteur de chaque piquet est la plus petite, la plus éloignée de nous: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/fc6/030/ed6fc60305a6da0d29d07850ba49e92a.jpg"><br><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 7: Première animation </h1><br>  À ce stade, pour la première fois, nous dessinons quelque chose de dynamique (je viens de déposer 360 photos sur le disque).  Tout est trivial: je change player_a, dessine une image, sauvegarde, change player_a, tire, sauvegarde.  Pour le rendre un peu plus amusant, j'ai attribué une valeur de couleur aléatoire à chaque type de cellule de notre carte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29d/38f/f7a/29d38ff7a03c91429cd5cbd7476fb8ed.gif"><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 8: correction des yeux de poisson </h1><br>  Avez-vous remarqué quel grand effet fish-eye nous obtenons lorsque nous regardons un mur de près?  Cela ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/fe7/f78/362fe7f78fc2d314e09b36f39d0bab6d.png"><br><br>  Pourquoi?  Oui, très simple.  Ici, nous regardons le mur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e67/632/227/e6763222768e380912c1c47d51a95871.png"><br><br>  Pour dessiner notre mur, nous mettons en lumière notre secteur bleu avec un rayon violet.  Prenez la valeur spécifique de la direction du faisceau, comme dans cette image.  La longueur du segment orange est nettement inférieure à la longueur du violet.  Puisque pour déterminer la hauteur de chaque segment vertical que nous dessinons sur l'écran, nous divisons par la distance à l'obstacle, le fisheye est assez naturel. <br><br>  Pour corriger cette distorsion n'est pas difficile du tout, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regardez comment cela se fait</a> .  Assurez-vous de bien comprendre d'où vient le cosinus.  Dessiner un diagramme sur un morceau de papier aide beaucoup. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df8/a7d/df4/df8a7ddf414fdc2018bd1649be3682f9.gif"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 9: charger le fichier de texture </h1><br>  Il est temps de gérer les textures.  Je suis paresseux pour écrire moi-même un téléchargeur d'images, j'ai donc pris l'excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque stb</a> .  J'ai préparé un fichier avec des textures pour les murs, toutes les textures sont carrées et emballées horizontalement dans l'image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c6/48e/8fd/5c648e8fd4cca05610b977b3f5b31cfe.png"><br><br>  À ce stade, je charge simplement les textures en mémoire.  Pour tester le code écrit, je dessine simplement comme c'est la texture avec l'index 5 dans le coin supérieur gauche de l'écran: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e4/a78/a9a/8e4a78a9a98ccfe4acd81ceb8f2faafa.png"><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 10: utilisation rudimentaire des textures </h1><br>  Maintenant, je jette des couleurs générées de manière aléatoire et teinte mes murs en prenant le pixel supérieur gauche de la texture correspondante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/21d/0b1/87d21d0b13110a2b05194033b8f609aa.png"><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 11: texturer les murs pour de vrai </h1><br>  Et maintenant, le moment tant attendu est venu où nous voyons enfin les murs de briques: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/175/e25/e71/175e25e71fccf3ad167a120b878f1b60.png"><br><br>  L'idée de base est très simple: ici, nous glissons le long du rayon actuel et nous nous arrêtons au point x, y.  Supposons que nous nous sommes installés sur un mur «horizontal», alors y est presque entier (pas vraiment, car notre façon de se déplacer le long du rayon introduit une petite erreur).  Prenons la partie fractionnaire de x et appelons-la hitx.  La partie fractionnaire est inférieure à un, par conséquent, si nous multiplions hitx par la taille de la texture (j'en ai 64), cela nous donnera la colonne de texture qui doit être dessinée à cet endroit.  Il reste à l'étirer à la bonne taille et la chose est dans le chapeau: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f9/444/f1c/1f9444f1cb378b082588479885799b80.png"><br><br>  En général, l'idée est extrêmement primitive, mais nécessite une exécution minutieuse, car nous avons également des murs «verticaux» (ceux avec hitx proche de zéro [x entier]).  Pour eux, la colonne de texture est déterminée par hity, la partie fractionnaire de y.  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><hr><br><h1>  Étape 12: il est temps de refactoriser! </h1><br>  A ce stade, je n'ai rien fait de nouveau, je viens de commencer le nettoyage général.  Jusqu'à présent, j'avais un gigantesque fichier (185 lignes!), Et il devenait difficile de travailler dessus.  Par conséquent, je l'ai divisé en un nuage de petits, malheureusement, en passant, doublant presque la taille du code (319 lignes), sans ajouter aucune fonctionnalité.  Mais ensuite, il est devenu beaucoup plus pratique à utiliser, par exemple, pour générer une animation, il suffit de faire une telle boucle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> frame=<span class="hljs-number"><span class="hljs-number">0</span></span>; frame&lt;<span class="hljs-number"><span class="hljs-number">360</span></span>; frame++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setfill(<span class="hljs-string"><span class="hljs-string">'0'</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setw(<span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; frame &lt;&lt; <span class="hljs-string"><span class="hljs-string">".ppm"</span></span>; player.a += <span class="hljs-number"><span class="hljs-number">2</span></span>*M_PI/<span class="hljs-number"><span class="hljs-number">360</span></span>; render(fb, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, player, tex_walls); drop_ppm_image(ss.str(), fb.img, fb.w, fb.h); }</code> </pre><br>  Eh bien, voici le résultat: <br><br><img src="https://raw.githubusercontent.com/ssloy/tinyraycaster/master/doc/012.gif"><br>  Les changements que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez voir ici</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://gitpod.io/&amp;usg=ALkJrhg0eCkGWdTvY1OuLIgIbPSqGQeStg#"><img src="https://habrastorage.org/getpro/habr/post_images/212/d5a/2a2/212d5a2a20d3071af82393c33309f62c.svg" alt="Ouvrir dans gitpod"></a> <br><br><h1>  À suivre ... immédiatement </h1><br>  Sur cette note optimiste, je termine la moitié actuelle de ma feuille, la seconde moitié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible ici</a> .  Nous y ajouterons des monstres et un lien vers SDL2 afin que vous puissiez vous promener dans notre monde virtuel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439698/">https://habr.com/ru/post/fr439698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439688/index.html">Aperçu des solutions AI et ML en 2018 et prévisions pour 2019: Partie 1 - PNL, vision par ordinateur</a></li>
<li><a href="../fr439690/index.html">Comparaison des performances des machines virtuelles pour 6 plateformes cloud: Selectel, MCS, I. Cloud, Google Cloud, AWS et Azure</a></li>
<li><a href="../fr439692/index.html">AT&T poursuivi pour avoir changé l'icône du réseau de 4G en 5G E</a></li>
<li><a href="../fr439694/index.html">Tissus intelligents sensibles aux changements de température corporelle</a></li>
<li><a href="../fr439696/index.html">Sur la crête d'une vague, ou "je veux intégrer" - mais ça vaut le coup?</a></li>
<li><a href="../fr439700/index.html">Brevet de jeu de société en Russie</a></li>
<li><a href="../fr439704/index.html">De la demande de pool à la libération. Signaler Yandex.Taxi</a></li>
<li><a href="../fr439706/index.html">Conférence BLACK HAT. Leçons de survivre à une attaque DDOS de 300 Gb / s. Partie 1</a></li>
<li><a href="../fr439708/index.html">Conférence BLACK HAT. Leçons de survivre à une attaque DDOS de 300 Gb / s. 2e partie</a></li>
<li><a href="../fr439710/index.html">Caractéristiques de la création de produits pour le marché américain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>