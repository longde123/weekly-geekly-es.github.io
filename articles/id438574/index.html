<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëò üëåüèæ üì§ Dasar-Dasar Arsitektur Aplikasi Flutter: Vanilla, Scoped Model, BLoC üë©üèº‚Äçüç≥ ü§≤üèø üôåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(artikel asli diterbitkan dalam Bahasa Inggris di Media ) 


 Flutter menyediakan kerangka kerja responsif modern, sejumlah besar widget dan alat. Nam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-Dasar Arsitektur Aplikasi Flutter: Vanilla, Scoped Model, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438574/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (artikel asli diterbitkan dalam Bahasa Inggris di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Media</a> ) </p><br><p>  Flutter menyediakan kerangka kerja responsif modern, sejumlah besar widget dan alat.  Namun, sayangnya, dokumentasi tersebut tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan arsitektur aplikasi Android yang direkomendasikan</a> . </p><br><p>  Tidak ada arsitektur universal yang ideal yang dapat memenuhi persyaratan teknis apa pun, tetapi mari kita akui bahwa sebagian besar aplikasi seluler tempat kita bekerja memiliki fungsi sebagai berikut: </p><br><ol><li>  Meminta dan mengunduh data. </li><li>  Transformasi dan persiapan data untuk pengguna. </li><li>  Menulis dan membaca data dari database atau sistem file. </li></ol><br><p> Mengingat semua ini, saya membuat aplikasi demo yang memecahkan masalah yang sama menggunakan pendekatan arsitektur yang berbeda. <a name="habracut"></a></p><br><p>  Awalnya, pengguna diperlihatkan layar dengan tombol "Muat data pengguna" yang terletak di tengah.  Ketika pengguna mengklik tombol, pemuatan data tidak sinkron terjadi, dan tombol itu diganti dengan indikator pemuatan.  Ketika pengunduhan data selesai, indikator pengunduhan digantikan oleh data. </p><br><p>  Jadi mari kita mulai. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="dannye">  Data </h2><br><p> Untuk menyederhanakan tugas, saya membuat kelas <code>Repository</code> , yang berisi metode <code>getUser()</code> .  Metode ini mensimulasikan pemuatan data yang tidak sinkron dari jaringan dan mengembalikan <code>Future&lt;User&gt;</code> . </p><br><p>  Jika Anda tidak terbiasa dengan Futures dan pemrograman asinkron di Dart, kita dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi kelas Future</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanilla </h2><br><p>  Ayo kembangkan aplikasi, seperti yang akan dilakukan pengembang jika dia membaca dokumentasi Flutter di situs web resmi. </p><br><p>  Buka layar <code>VanillaScreen</code> menggunakan <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Karena keadaan widget dapat berubah beberapa kali selama siklus hidupnya, kami perlu mewarisi dari <code>StatefulWidget</code> .  Untuk mengimplementasikan widget stateful Anda, Anda juga memerlukan kelas <code>State</code> .  Bidang <code>bool _isLoading</code> dan <code>User _user</code> di kelas <code>_VanillaScreenState</code> mewakili status widget.  Kedua bidang diinisialisasi sebelum metode <code>build(BuildContext context)</code> dipanggil untuk pertama kalinya. </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Setelah objek status widget dibuat, metode <code>build(BuildContext context)</code> dipanggil untuk membangun UI.  Semua keputusan tentang widget mana yang harus ditampilkan di layar dibuat benar dalam kode deklarasi UI. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Untuk menampilkan indikator progres, ketika pengguna mengklik tombol "Muat detail pengguna", kami melakukan hal berikut. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><p>  Dari dokumentasi (terjemahan): </p><br><blockquote>  Panggilan ke metode setState () memberi tahu kerangka kerja bahwa keadaan internal objek ini telah berubah dan dapat memengaruhi antarmuka pengguna di subtree.  Ini adalah alasan framework memanggil metode build pada objek state ini. </blockquote><p>  Ini berarti bahwa setelah memanggil metode <code>setState()</code> , framework akan memanggil metode <code>build(BuildContext context)</code> lagi, yang akan <strong>membuat ulang seluruh pohon widget</strong> .  Karena nilai bidang <code>_isLoading</code> berubah menjadi <code>true</code> , alih-alih metode <code>_buildBody()</code> , metode <code>_buildLoading()</code> akan dipanggil dan indikator progres akan ditampilkan di layar. <br>  Hal yang persis sama akan terjadi ketika kita mendapatkan panggilan balik dari <code>getUser()</code> dan memanggil metode <br>  <code>setState()</code> untuk menetapkan nilai baru ke bidang <code>_isLoading</code> dan <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="plyusy">  Pro </h3><br><ol><li>  Ambang entri rendah. </li><li>  Tidak diperlukan perpustakaan pihak ketiga. </li></ol><br><h3 id="minusy">  Cons </h3><br><ol><li>  Ketika keadaan widget berubah, pohon widget sepenuhnya dibuat ulang setiap kali. </li><li>  Melanggar prinsip tanggung jawab tunggal.  Widget ini bertanggung jawab tidak hanya untuk membuat UI, tetapi juga untuk memuat data, logika bisnis, dan manajemen negara. </li><li>  Keputusan tentang cara menampilkan keadaan saat ini dibuat langsung dalam kode UI.  Jika keadaan menjadi lebih kompleks, maka keterbacaan kode akan sangat berkurang. </li></ol><br><h2 id="scoped-model">  Model tertutup </h2><br><p>  Scoped Model adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan pihak ketiga</a> .  Begini cara pengembang menggambarkannya: </p><br><blockquote>  Seperangkat utilitas yang memungkinkan Anda mentransfer Model Data widget leluhur ke semua turunannya.  Selain itu, ketika data model berubah, semua keturunan yang menggunakan model akan dibuat kembali.  Perpustakaan ini awalnya diambil dari kode proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fuchsia</a> . </blockquote><p>  Mari kita membuat layar yang sama seperti pada contoh sebelumnya, tetapi menggunakan Model Scoped.  Pertama, kita perlu menambahkan perpustakaan Scoped Model ke proyek.  Tambahkan dependensi <code>scoped_model</code> ke file <code>scoped_model</code> di bagian <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Mari kita lihat kode <code>UserModelScreen</code> dan bandingkan dengan contoh sebelumnya, di mana kita tidak menggunakan Scoped Model.  Untuk membuat model kami dapat diakses oleh keturunan widget, kita perlu membungkus widget dan model di <code>ScopedModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Pada contoh sebelumnya, setiap kali widget berubah status, pohon widget sepenuhnya dibuat ulang.  Tetapi apakah kita benar-benar perlu membuat ulang seluruh pohon widget (layar penuh)?  Misalnya, AppBar tidak berubah sama sekali, dan tidak ada gunanya untuk membuatnya kembali.  Idealnya, Anda harus membuat ulang hanya widget yang harus berubah sesuai dengan perubahan status.  Dan Model Scoped dapat membantu kami memecahkan masalah ini. </p><br><p>  <code>ScopedModelDescendant&lt;UserModel&gt;</code> digunakan untuk menemukan <code>UserModel</code> di pohon widget.  Ini akan dibuat ulang secara otomatis setiap kali <code>UserModel</code> memberitahukan bahwa telah ada perubahan. </p><br><p>  Peningkatan lainnya adalah bahwa <code>UserModelScreen</code> tidak lagi bertanggung jawab atas manajemen negara, logika bisnis, dan pemuatan data. </p><br><p>  Mari kita lihat kode untuk kelas <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  <code>UserModel</code> sekarang berisi dan mengelola status.  Untuk memberi tahu pendengar (dan membuat ulang keturunan) bahwa perubahan telah terjadi, <code>notifyListeners()</code> harus dipanggil. </p><br><h3 id="plyusy-1">  Pro </h3><br><ol><li>  Manajemen negara, logika bisnis, dan pemuatan data terpisah dari kode UI. </li><li>  Ambang entri rendah. </li></ol><br><h3 id="minusy-1">  Cons </h3><br><ol><li>  Ketergantungan perpustakaan pihak ketiga. </li><li>  Jika model menjadi cukup kompleks, akan sulit untuk melacak kapan benar-benar perlu memanggil <code>notifyListeners()</code> untuk menghindari rekreasi yang tidak perlu. </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC (Komponen Logika Cnis) adalah pola yang direkomendasikan oleh pengembang dari Google.  Streaming digunakan untuk mengelola keadaan dan untuk memberi tahu tentang perubahan keadaan. </p><br><p>  <strong>Untuk pengembang Android:</strong> Anda dapat membayangkan bahwa <code>Bloc</code> adalah <code>ViewModel</code> , dan <code>StreamController</code> adalah <code>LiveData</code> .  Ini akan membuat kode berikut mudah dimengerti, karena Anda sudah terbiasa dengan prinsip-prinsip dasar. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  Kode menunjukkan bahwa tidak perlu lagi memanggil metode tambahan untuk memberi tahu tentang perubahan status. </p><br><p>  Saya membuat 3 kelas untuk mewakili kemungkinan status: </p><br><p>  <code>UserInitState</code> untuk keadaan saat pengguna membuka layar dengan tombol di tengah. </p><br><p>  <code>UserLoadingState</code> untuk keadaan saat indikator memuat ditampilkan saat data dimuat. </p><br><p>  <code>UserDataState</code> untuk keadaan saat data sudah dimuat dan ditampilkan di layar. </p><br><p>  Status lewat dengan cara ini memungkinkan kita untuk sepenuhnya menghilangkan logika dalam kode UI.  Dalam contoh Model yang Dicakup, kami masih memeriksa apakah nilai bidang <code>_isLoading</code> <code>true</code> atau <code>false</code> untuk menentukan widget mana yang akan dibuat.  Dalam kasus BLoC, kami meneruskan status baru ke streaming, dan satu-satunya tugas widget <code>UserBlocScreen</code> membuat UI untuk kondisi saat ini. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  Kode untuk widget <code>UserBlocScreen</code> bahkan lebih sederhana dari pada contoh sebelumnya.  Untuk mendengarkan perubahan keadaan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StreamBuilder</a> digunakan.  <code>StreamBuilder</code> adalah <code>StatefulWidget</code> yang membuat dirinya sesuai dengan nilai terakhir (Snapshot) dari aliran ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stream</a> ). </p><br><h3 id="plyusy-2">  Pro </h3><br><ol><li>  Tidak diperlukan perpustakaan pihak ketiga. </li><li>  Logika bisnis, manajemen negara, dan pemuatan data terpisah dari kode UI. </li><li>  Reaktivitas  Tidak perlu memanggil metode tambahan, seperti pada contoh dengan Scoped Model notifyListeners <code>notifyListeners()</code> . </li></ol><br><h3 id="minusy-2">  Cons </h3><br><ol><li>  Ambang entri sedikit lebih tinggi.  Butuh pengalaman dengan stream atau rxdart. </li></ol><br><h2 id="linki">  Tautan </h2><br><p>  Anda dapat membaca kode lengkap dengan mengunduhnya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori github saya</a> . </p><br><p>  Artikel asli diterbitkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Medium</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438574/">https://habr.com/ru/post/id438574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438560/index.html">Menulis XGBoost dari awal - bagian 1: pohon keputusan</a></li>
<li><a href="../id438562/index.html">Menulis XGBoost dari awal - bagian 2: meningkatkan gradien</a></li>
<li><a href="../id438566/index.html">Kasus Mikroprosesor Apple Strange A12X</a></li>
<li><a href="../id438568/index.html">Tentang komputer kuantum: bagaimana berbagai negara mengembangkan teknologi ini</a></li>
<li><a href="../id438570/index.html">CS Center Kompetisi Malam Tahun Baru 2018</a></li>
<li><a href="../id438576/index.html">Sumber terbuka populer - bagian tiga: 5 alat untuk pengembang</a></li>
<li><a href="../id438578/index.html">Bagaimana raksasa audio IT raksasa itu "dielakkan" untuk kedua kalinya</a></li>
<li><a href="../id438580/index.html">Kata sandi yang dihasilkan secara otomatis di iOS 12</a></li>
<li><a href="../id438582/index.html">AntiRating 2018</a></li>
<li><a href="../id438584/index.html">Frontend untuk pengembang backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>