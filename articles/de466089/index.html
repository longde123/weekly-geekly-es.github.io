<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíù ü¶É üê¢ Algorithmus des Denkens und Bewusstseins, Teil 2 üë®üèº‚Äçüè≠ ‚ìÇÔ∏è üí∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Text enth√§lt Erkl√§rungen f√ºr den Algorithmus aus meinem ersten Artikel ‚ÄûAlgorithmus des Denkens und Bewusstseins‚Äú . Thesen des ersten Artikels:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmus des Denkens und Bewusstseins, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466089/">  Dieser Text enth√§lt Erkl√§rungen f√ºr den Algorithmus aus meinem ersten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûAlgorithmus des Denkens und Bewusstseins‚Äú</a> .  Thesen des ersten Artikels: <br><br><ul><li>  Das Ph√§nomen des subjektiven Denkens kann algorithmisiert werden. </li><li>  Der im Artikel vorgestellte Algorithmus denkt und dies kann praktisch verwendet werden. </li><li>  Mit dem Denkalgorithmus k√∂nnen wir Bewusstsein in einer asymptotischen Form definieren. </li></ul><a name="habracut"></a><br>  <b>Ansicht des Autors im Allgemeinen</b> .  Zun√§chst gehe ich davon aus, dass Rationalit√§t und Komplexit√§t ein und dasselbe sind.  Infolgedessen geht die Logik der Komplexit√§t, was auch immer sie im Wesentlichen sein mag, jeder anderen Art von Logik voraus und ist daher absolut.  Unter diesem Gesichtspunkt ist mein vorgeschlagener Algorithmus vern√ºnftig, da er jede strukturelle Komplexit√§t in einem formalen Rechenprozess erreichen kann. <br><br>  Der Denkalgorithmus basiert auf der formalen Logik der Komplexit√§t mit den folgenden Eigenschaften: <br><br><ol><li>  Die Objekte der Logik sind abstrakte Theorien. </li><li>  Jede Theorie hat Komplexit√§t und diese Komplexit√§t kann klar verifiziert werden. </li><li>  Aus jeder Theorie kann eine komplexere Theorie abgeleitet werden. </li><li>  Aus jeder komplexen Theorie kann eine einfache Theorie abgeleitet werden. </li><li>  Es wird unterschiedliche Schlussfolgerungen aus zwei verschiedenen Theorien geben. </li><li>  Jede Theorie ist sinnvoll.  Eine Theorie hei√üt sinnvoll, wenn sie einzigartig und unendlich komplex ist.  In der Praxis bedeutet dies, dass eine potenziell unendliche Kette von Schlussfolgerungen aus einer aussagekr√§ftigen Theorie konstruiert werden kann, sodass alle Schlussfolgerungen in der Kette eindeutig sind und jede nachfolgende Schlussfolgerung komplizierter ist als die vorherige. </li></ol><br>  Der √úbergang von einer einfachen zu einer komplexeren Theorie mit vielen wesentlichen Theorien entspricht intuitiv dem Konzept des idealen Denkens.  Die konstruktive Umsetzung einer solchen Logik wird unter anderem die konstruktive Theorie des Denkens sein. <br><br>  <b>Mehr √ºber abstrakte Theorien</b> .  Abstrakte Theorien sind alles, wor√ºber nur bekannt ist, dass sie der konstruktiven Komplexit√§t inh√§rent sind, weil diese Komplexit√§t eindeutig verifiziert werden kann.  Und es ist auch bekannt, dass von so etwas ein konstruktiver √úbergang zu anderen, komplexeren St√ºcken m√∂glich ist und dies auch √ºberpr√ºft werden kann. <br><br>  <b>Informell √ºber konstruktive Komplexit√§t</b> .  Ein komplexes Objekt kann eindeutig in einfache Objekte zerlegt werden.  Je einfacher Objekte in einem komplexen Objekt enthalten sind, desto komplexer ist dieses Objekt.  Einfache Objekte k√∂nnen nicht auf einzigartige Weise erkannt werden.  Die Komplexit√§t aller einfachen Objekte ist gleich. <br><br>  Dementsprechend werden abstrakte Theorien in zwei Typen unterteilt: einfach und komplex.  Eine Theorie wird als komplex bezeichnet, wenn mit einem bestimmten Verfahren eine eindeutige Reihe einfacher Theorien daraus abgeleitet werden kann.  F√ºr alle einfachen Theorien liefert dasselbe Verfahren wiederum ein konstantes Ergebnis, und daher ist die Komplexit√§t einfacher Theorien gleich.  Aufgrund der Tatsache, dass die Komplexit√§t der betrachteten Logik konstruktiv bestimmt wird, kann sie berechnet und verglichen werden.  Zwei Theorien haben die gleiche Komplexit√§t, wenn sie in die gleiche Anzahl einfacher Theorien zerlegt werden k√∂nnen.  Je einfacher die Theorien sind, desto komplexer ist die urspr√ºngliche Theorie. <br><br>  <b>Formale Definition von Komplexit√§t</b> .  Auf der Menge der Theorien <b>S</b> = <b>P</b> ‚à™ <b>C</b> , wobei <b>P</b> = {s ‚àà <b>S</b> |  A [s] = ‚àÖ} ist eine Teilmenge einfacher Theorien, <b>C</b> = {s ‚àà <b>S</b> |  A [s] ‚â† ‚â†} ist eine Teilmenge komplexer Theorien, der Operator A: <b>S</b> ‚Üí 2 <sup><b>P</b></sup> definiert die Komplexit√§t, wenn ‚àÄ (c <sub>1</sub> , c <sub>2</sub> ) ‚àà <b>C</b> , c <sub>1</sub> ‚â† c <sub>2</sub> , A [c <sub>1</sub> ] ‚â† A [c <sub>2</sub> ] ;;  Das hei√üt, f√ºr jede komplexe Theorie gibt es eine einzigartige Zerlegung in einfache.  | A [s] |: ein numerisches Ma√ü f√ºr die Komplexit√§t s. <br><br>  <b>Die Logik der Komplexit√§t</b> .  Die Menge der Theorien <b>S</b> , der Operator A und der Operator D: <b>S</b> ‚Üí <b>S,</b> so dass ‚àÄs ‚àà <b>S</b> , | A [s] |  &lt;| A [D [s]] | und ‚àÄ (s <sub>1</sub> , s <sub>2</sub> ) ‚àà <b>S</b> , s <sub>1</sub> ‚â† s <sub>2</sub> , D [s <sub>1</sub> ] ‚â† D [s <sub>2</sub> ] definieren die Logik der Komplexit√§t.  Der Operator D leitet aus einer gegebenen Theorie eine neue, garantiert kompliziertere ab. <br><br>  <b>Die Umsetzung der Logik der Komplexit√§t</b> .  Die oben beschriebene Logik kann in formalen Operationen an Zeichenfolgen einer besonderen Art ausgedr√ºckt werden.  Im ersten Artikel finden Sie eine detaillierte Beschreibung der Implementierung.  Nachfolgend finden Sie nur eine vereinfachte, schematische Beschreibung der Implementierung. <br><br>  <b>Viele Theorien</b> .  Zur Darstellung von Theorien werden Zeichenfolgen verwendet, die aus einer beliebigen Folge von Klammern '(', ')' und beliebigen grafischen Bezeichnern in den Klammern bestehen.  Der K√ºrze halber wird jeder Buchstabe als separate Kennung betrachtet.  Der gesamte Inhalt der Zeichenfolge muss in gemeinsamen √§u√üeren Klammern stehen.  F√ºr jede √ñffnung sollte die Klammer in der Leitung schlie√üen.  Beispiel: Zeile <b>((b) a (e)) ist</b> korrekt, w√§hrend die Zeilen <b>(b) a (e)</b> , <b>(a (b (e))</b> falsch sind. <br><br>  Viele <b>S-</b> Theorien bestehen aus allen m√∂glichen regul√§ren Linien. <br><br>  Zwei Linien sind gleich, wenn sie bis zu einer Permutation unteilbarer Elemente in Teilzeichenfolgen zusammenfallen.  Ein Beispiel, wie Sie die Elemente neu anordnen k√∂nnen: (ab (cd)) ‚â° ((cd) ab) ‚â° (b (dc) a) ‚â° ... ‚â° ((dc) ba).  Leere Teilzeichenfolgen sind nicht signifikant und werden weggeworfen, z. B. (a ()) ‚â° (a). <br><br>  <b>Auszahlungsregeln</b> .  Auf der Menge <b>S sind</b> drei Inferenzregeln angegeben. <br><br>  <b>Abstraktionsregel</b> .  Gilt f√ºr Teilzeichenfolgen einer bestimmten Zeichenfolge.  Erm√∂glicht es Ihnen, denselben Inhalt in Klammern zu setzen.  Aus jeder Gruppe von Klammern auf derselben Ebene k√∂nnen identische Teilzeichenfolgen nach folgendem Prinzip aus Klammern entnommen werden: <br><br> <code>((ab)(ac)) ‚áí (a(bc)); <br> <br> ((ab)(abc)) ‚áí { (a(bbc)), (b(aac)), (ab(c )) }; <br> <br> ((ab)(ac)(ae)) ‚áí { (a(bce)), (a(bc)(ae)), (a(ab)(ce)) };</code> <br> <br>  Nach der Abstraktionsregel sind die Ergebnisse immer einfacher als die urspr√ºngliche Zeichenfolge.  Bei einfachen Zeichenfolgen, z. B. ((a) (b)), ist das Ergebnis der Anwendung der Abstraktionsregel leer.  Die rekursive Anwendung der Abstraktionsregel erm√∂glicht es Ihnen, komplexe Zeichenfolgen in einfache zu zerlegen. <br><br>  <b>Die Regel des Abzugs</b> .  Nach dieser Regel k√∂nnen Sie aus der urspr√ºnglichen Zeile so viele neue Zeilen abrufen, wie Sie m√∂chten, indem Sie alle Elemente in der urspr√ºnglichen Zeile nach dem folgenden Prinzip beliebig oft duplizieren: <br><br> <code>(a) ‚áí { ((aa)(aa)), ((aaa)(aaa)(aaa)), ((aaaa)(aaaa)(aaaa)(aaaa)), ‚Ä¶}; <br> <br> (a(b)) ‚áí { ((aa(bb)(bb))(aa(bb)(bb))), ((aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))), ‚Ä¶}; <br> <br> (a(b(cc))) ‚áí { (aa(bb(cccc)(cccc))(bb(cccc)(cccc)))(aa(bb(cccc)(cccc))(bb(cccc)(cccc))), ‚Ä¶};</code> <br> <br>  <b>Kompositionsregel</b>  Jeder Satz von Zeilen von <b>S</b> kann zu einer Zeile kombiniert werden.  Zum Beispiel: (a), (b), (e) ‚áí ((a) (b) (e)). <br><br>  <b>Operator</b> A. Das Ergebnis des Operators ist ein eindeutiger Satz einfacher Zeichenfolgen.  Die rekursive Anwendung der Abstraktionsregel auf eine bestimmte Zeile, bis sie stoppt, wenn alle m√∂glichen Zerlegungsoptionen ausgesch√∂pft sind, entspricht der Aktion von Operator A. <br><br>  Ich m√∂chte darauf hinweisen, dass der Abstraktionsoperator im Hauptartikel im Gegensatz zu dem Operator A im Ergebnis seiner Arbeit nicht nur einfache, sondern im Allgemeinen alle Zeilen enth√§lt, die gem√§√ü der Abstraktionsregel angezeigt werden k√∂nnen. <br><br>  <b>Operator</b> D. Eine Abzugsregel mit einem bestimmten Duplizierungsparameter entspricht der Aktion des Operators D. Aus einer bestimmten Zeile kann eine komplexere Zeile aus der Abzugsregel abgeleitet werden, und diese Tatsache kann mit Operator A √ºberpr√ºft werden. <br><br>  <b>Kompositionsoperator</b> ().  Entspricht der Aktion der Kompositionsregel. <br><br>  Somit wird ein formales System erhalten, das die Definition der Komplexit√§tslogik erf√ºllt. <br><br>  <b>Der Inhalt von Theorien</b> .  In der Logik der Komplexit√§t ist jede Theorie sinnvoll.  Da ‚àÄs ‚àà <b>S ist,</b> gibt es eine eindeutige Kette von Schlussfolgerungen t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]) mit zunehmender und m√∂glicherweise unendlicher Komplexit√§t. <br><br>  <b>Die Unl√∂sbarkeitshypothese</b> .  Mengen der allgemeinen Form T <sub>s</sub> = {p ‚àà <b>S</b> |  ‚àÄn ‚àà <b>N</b> , p ‚àà A [D [t <sub>n</sub> ]];  t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]);  t <sub>0</sub> = s} Ich halte das f√ºr unl√∂sbar.  Die Menge T <sub>s</sub> enth√§lt alle einfachen Zeichenfolgen, die von der rekursiven Funktion t <sub>n</sub> aus der Startzeile s abgeleitet werden.  Angesichts der Unl√∂sbarkeit von T <sub>s</sub> ist die Ausgabe t <sub>n</sub> algorithmisch zuf√§llig.  Es gibt keine Beweise. <br><br>  <b>Denken</b>  t <sub>n</sub> hat den Charakter der Komplexit√§t wie im idealen Denken und ist auf dieser Basis eine Form des idealen Denkens.  Bei jeder Iteration t <sub>n</sub> gibt es einen klaren √úbergang von einer weniger komplexen Theorie zu einer neuen, komplexeren Theorie, jeder dieser √úberg√§nge ist einzigartig und dieser Prozess ist m√∂glicherweise endlos. <br><br>  Das Denken verwirklicht das Bewusstsein in einer asymptotischen Form.  Grob gesagt ist ‚ÄûBewusstsein der Theorie‚Äú der ultimative, unendlich komplexe Inhalt, den t <sub>n</sub> im Computerprozess anstrebt. <br><br>  <b>Subjektive Erfahrung</b> .  Subjektive Erfahrungen sind das Vorrecht des Bewusstseins.  Bewusstsein ist nicht konstruktiv. <br><br>  Wird der Computer w√§hrend des Rechnens √ºberleben?  Nein.  In den Ergebnissen der Berechnungen k√∂nnen jedoch Erfahrungen auf Kosten des Computers auftreten. <br><br>  <b>Fazit</b>  Ich glaube, jeder wei√ü, wie viel Fantasie es braucht, um etwas wirklich Komplexes aufzubauen.  Nicht nur gro√ü, sondern auch komplex.  Und f√ºr unendliche Komplexit√§t braucht man endlose Fantasie.  Woher bekommt der Algorithmus so viel Vorstellungskraft?  Es sei denn, die Fantasie selbst ist ein Algorithmus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466089/">https://habr.com/ru/post/de466089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466069/index.html">So bringen Sie das Team dazu, nach produktiveren Ideen zu suchen</a></li>
<li><a href="../de466071/index.html">10,3 Sekunden pro Hash: Mining auf dem Bordsteuerungscomputer des Apollo-Raumfahrzeugs</a></li>
<li><a href="../de466075/index.html">Wie ich die Grundlagenforschung in einem Startup verlassen habe</a></li>
<li><a href="../de466077/index.html">Broadcast Techdir Day in St. Petersburg</a></li>
<li><a href="../de466081/index.html">3. September</a></li>
<li><a href="../de466093/index.html">Wie funktioniert kubectl exec?</a></li>
<li><a href="../de466097/index.html">√úberwachen von .NET-Anwendungen</a></li>
<li><a href="../de466099/index.html">Funktionen zum Testen einer Webanwendung f√ºr den Videodienst</a></li>
<li><a href="../de466103/index.html">√úberwachung der Cloud-Sicherheit</a></li>
<li><a href="../de466105/index.html">√úbertakten der Magento Rest API mit RoadRunner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>