<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💝 🦃 🐢 Algorithmus des Denkens und Bewusstseins, Teil 2 👨🏼‍🏭 Ⓜ️ 💺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Text enthält Erklärungen für den Algorithmus aus meinem ersten Artikel „Algorithmus des Denkens und Bewusstseins“ . Thesen des ersten Artikels:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmus des Denkens und Bewusstseins, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466089/">  Dieser Text enthält Erklärungen für den Algorithmus aus meinem ersten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Algorithmus des Denkens und Bewusstseins“</a> .  Thesen des ersten Artikels: <br><br><ul><li>  Das Phänomen des subjektiven Denkens kann algorithmisiert werden. </li><li>  Der im Artikel vorgestellte Algorithmus denkt und dies kann praktisch verwendet werden. </li><li>  Mit dem Denkalgorithmus können wir Bewusstsein in einer asymptotischen Form definieren. </li></ul><a name="habracut"></a><br>  <b>Ansicht des Autors im Allgemeinen</b> .  Zunächst gehe ich davon aus, dass Rationalität und Komplexität ein und dasselbe sind.  Infolgedessen geht die Logik der Komplexität, was auch immer sie im Wesentlichen sein mag, jeder anderen Art von Logik voraus und ist daher absolut.  Unter diesem Gesichtspunkt ist mein vorgeschlagener Algorithmus vernünftig, da er jede strukturelle Komplexität in einem formalen Rechenprozess erreichen kann. <br><br>  Der Denkalgorithmus basiert auf der formalen Logik der Komplexität mit den folgenden Eigenschaften: <br><br><ol><li>  Die Objekte der Logik sind abstrakte Theorien. </li><li>  Jede Theorie hat Komplexität und diese Komplexität kann klar verifiziert werden. </li><li>  Aus jeder Theorie kann eine komplexere Theorie abgeleitet werden. </li><li>  Aus jeder komplexen Theorie kann eine einfache Theorie abgeleitet werden. </li><li>  Es wird unterschiedliche Schlussfolgerungen aus zwei verschiedenen Theorien geben. </li><li>  Jede Theorie ist sinnvoll.  Eine Theorie heißt sinnvoll, wenn sie einzigartig und unendlich komplex ist.  In der Praxis bedeutet dies, dass eine potenziell unendliche Kette von Schlussfolgerungen aus einer aussagekräftigen Theorie konstruiert werden kann, sodass alle Schlussfolgerungen in der Kette eindeutig sind und jede nachfolgende Schlussfolgerung komplizierter ist als die vorherige. </li></ol><br>  Der Übergang von einer einfachen zu einer komplexeren Theorie mit vielen wesentlichen Theorien entspricht intuitiv dem Konzept des idealen Denkens.  Die konstruktive Umsetzung einer solchen Logik wird unter anderem die konstruktive Theorie des Denkens sein. <br><br>  <b>Mehr über abstrakte Theorien</b> .  Abstrakte Theorien sind alles, worüber nur bekannt ist, dass sie der konstruktiven Komplexität inhärent sind, weil diese Komplexität eindeutig verifiziert werden kann.  Und es ist auch bekannt, dass von so etwas ein konstruktiver Übergang zu anderen, komplexeren Stücken möglich ist und dies auch überprüft werden kann. <br><br>  <b>Informell über konstruktive Komplexität</b> .  Ein komplexes Objekt kann eindeutig in einfache Objekte zerlegt werden.  Je einfacher Objekte in einem komplexen Objekt enthalten sind, desto komplexer ist dieses Objekt.  Einfache Objekte können nicht auf einzigartige Weise erkannt werden.  Die Komplexität aller einfachen Objekte ist gleich. <br><br>  Dementsprechend werden abstrakte Theorien in zwei Typen unterteilt: einfach und komplex.  Eine Theorie wird als komplex bezeichnet, wenn mit einem bestimmten Verfahren eine eindeutige Reihe einfacher Theorien daraus abgeleitet werden kann.  Für alle einfachen Theorien liefert dasselbe Verfahren wiederum ein konstantes Ergebnis, und daher ist die Komplexität einfacher Theorien gleich.  Aufgrund der Tatsache, dass die Komplexität der betrachteten Logik konstruktiv bestimmt wird, kann sie berechnet und verglichen werden.  Zwei Theorien haben die gleiche Komplexität, wenn sie in die gleiche Anzahl einfacher Theorien zerlegt werden können.  Je einfacher die Theorien sind, desto komplexer ist die ursprüngliche Theorie. <br><br>  <b>Formale Definition von Komplexität</b> .  Auf der Menge der Theorien <b>S</b> = <b>P</b> ∪ <b>C</b> , wobei <b>P</b> = {s ∈ <b>S</b> |  A [s] = ∅} ist eine Teilmenge einfacher Theorien, <b>C</b> = {s ∈ <b>S</b> |  A [s] ≠ ≠} ist eine Teilmenge komplexer Theorien, der Operator A: <b>S</b> → 2 <sup><b>P</b></sup> definiert die Komplexität, wenn ∀ (c <sub>1</sub> , c <sub>2</sub> ) ∈ <b>C</b> , c <sub>1</sub> ≠ c <sub>2</sub> , A [c <sub>1</sub> ] ≠ A [c <sub>2</sub> ] ;;  Das heißt, für jede komplexe Theorie gibt es eine einzigartige Zerlegung in einfache.  | A [s] |: ein numerisches Maß für die Komplexität s. <br><br>  <b>Die Logik der Komplexität</b> .  Die Menge der Theorien <b>S</b> , der Operator A und der Operator D: <b>S</b> → <b>S,</b> so dass ∀s ∈ <b>S</b> , | A [s] |  &lt;| A [D [s]] | und ∀ (s <sub>1</sub> , s <sub>2</sub> ) ∈ <b>S</b> , s <sub>1</sub> ≠ s <sub>2</sub> , D [s <sub>1</sub> ] ≠ D [s <sub>2</sub> ] definieren die Logik der Komplexität.  Der Operator D leitet aus einer gegebenen Theorie eine neue, garantiert kompliziertere ab. <br><br>  <b>Die Umsetzung der Logik der Komplexität</b> .  Die oben beschriebene Logik kann in formalen Operationen an Zeichenfolgen einer besonderen Art ausgedrückt werden.  Im ersten Artikel finden Sie eine detaillierte Beschreibung der Implementierung.  Nachfolgend finden Sie nur eine vereinfachte, schematische Beschreibung der Implementierung. <br><br>  <b>Viele Theorien</b> .  Zur Darstellung von Theorien werden Zeichenfolgen verwendet, die aus einer beliebigen Folge von Klammern '(', ')' und beliebigen grafischen Bezeichnern in den Klammern bestehen.  Der Kürze halber wird jeder Buchstabe als separate Kennung betrachtet.  Der gesamte Inhalt der Zeichenfolge muss in gemeinsamen äußeren Klammern stehen.  Für jede Öffnung sollte die Klammer in der Leitung schließen.  Beispiel: Zeile <b>((b) a (e)) ist</b> korrekt, während die Zeilen <b>(b) a (e)</b> , <b>(a (b (e))</b> falsch sind. <br><br>  Viele <b>S-</b> Theorien bestehen aus allen möglichen regulären Linien. <br><br>  Zwei Linien sind gleich, wenn sie bis zu einer Permutation unteilbarer Elemente in Teilzeichenfolgen zusammenfallen.  Ein Beispiel, wie Sie die Elemente neu anordnen können: (ab (cd)) ≡ ((cd) ab) ≡ (b (dc) a) ≡ ... ≡ ((dc) ba).  Leere Teilzeichenfolgen sind nicht signifikant und werden weggeworfen, z. B. (a ()) ≡ (a). <br><br>  <b>Auszahlungsregeln</b> .  Auf der Menge <b>S sind</b> drei Inferenzregeln angegeben. <br><br>  <b>Abstraktionsregel</b> .  Gilt für Teilzeichenfolgen einer bestimmten Zeichenfolge.  Ermöglicht es Ihnen, denselben Inhalt in Klammern zu setzen.  Aus jeder Gruppe von Klammern auf derselben Ebene können identische Teilzeichenfolgen nach folgendem Prinzip aus Klammern entnommen werden: <br><br> <code>((ab)(ac)) ⇒ (a(bc)); <br> <br> ((ab)(abc)) ⇒ { (a(bbc)), (b(aac)), (ab(c )) }; <br> <br> ((ab)(ac)(ae)) ⇒ { (a(bce)), (a(bc)(ae)), (a(ab)(ce)) };</code> <br> <br>  Nach der Abstraktionsregel sind die Ergebnisse immer einfacher als die ursprüngliche Zeichenfolge.  Bei einfachen Zeichenfolgen, z. B. ((a) (b)), ist das Ergebnis der Anwendung der Abstraktionsregel leer.  Die rekursive Anwendung der Abstraktionsregel ermöglicht es Ihnen, komplexe Zeichenfolgen in einfache zu zerlegen. <br><br>  <b>Die Regel des Abzugs</b> .  Nach dieser Regel können Sie aus der ursprünglichen Zeile so viele neue Zeilen abrufen, wie Sie möchten, indem Sie alle Elemente in der ursprünglichen Zeile nach dem folgenden Prinzip beliebig oft duplizieren: <br><br> <code>(a) ⇒ { ((aa)(aa)), ((aaa)(aaa)(aaa)), ((aaaa)(aaaa)(aaaa)(aaaa)), …}; <br> <br> (a(b)) ⇒ { ((aa(bb)(bb))(aa(bb)(bb))), ((aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))), …}; <br> <br> (a(b(cc))) ⇒ { (aa(bb(cccc)(cccc))(bb(cccc)(cccc)))(aa(bb(cccc)(cccc))(bb(cccc)(cccc))), …};</code> <br> <br>  <b>Kompositionsregel</b>  Jeder Satz von Zeilen von <b>S</b> kann zu einer Zeile kombiniert werden.  Zum Beispiel: (a), (b), (e) ⇒ ((a) (b) (e)). <br><br>  <b>Operator</b> A. Das Ergebnis des Operators ist ein eindeutiger Satz einfacher Zeichenfolgen.  Die rekursive Anwendung der Abstraktionsregel auf eine bestimmte Zeile, bis sie stoppt, wenn alle möglichen Zerlegungsoptionen ausgeschöpft sind, entspricht der Aktion von Operator A. <br><br>  Ich möchte darauf hinweisen, dass der Abstraktionsoperator im Hauptartikel im Gegensatz zu dem Operator A im Ergebnis seiner Arbeit nicht nur einfache, sondern im Allgemeinen alle Zeilen enthält, die gemäß der Abstraktionsregel angezeigt werden können. <br><br>  <b>Operator</b> D. Eine Abzugsregel mit einem bestimmten Duplizierungsparameter entspricht der Aktion des Operators D. Aus einer bestimmten Zeile kann eine komplexere Zeile aus der Abzugsregel abgeleitet werden, und diese Tatsache kann mit Operator A überprüft werden. <br><br>  <b>Kompositionsoperator</b> ().  Entspricht der Aktion der Kompositionsregel. <br><br>  Somit wird ein formales System erhalten, das die Definition der Komplexitätslogik erfüllt. <br><br>  <b>Der Inhalt von Theorien</b> .  In der Logik der Komplexität ist jede Theorie sinnvoll.  Da ∀s ∈ <b>S ist,</b> gibt es eine eindeutige Kette von Schlussfolgerungen t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]) mit zunehmender und möglicherweise unendlicher Komplexität. <br><br>  <b>Die Unlösbarkeitshypothese</b> .  Mengen der allgemeinen Form T <sub>s</sub> = {p ∈ <b>S</b> |  ∀n ∈ <b>N</b> , p ∈ A [D [t <sub>n</sub> ]];  t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]);  t <sub>0</sub> = s} Ich halte das für unlösbar.  Die Menge T <sub>s</sub> enthält alle einfachen Zeichenfolgen, die von der rekursiven Funktion t <sub>n</sub> aus der Startzeile s abgeleitet werden.  Angesichts der Unlösbarkeit von T <sub>s</sub> ist die Ausgabe t <sub>n</sub> algorithmisch zufällig.  Es gibt keine Beweise. <br><br>  <b>Denken</b>  t <sub>n</sub> hat den Charakter der Komplexität wie im idealen Denken und ist auf dieser Basis eine Form des idealen Denkens.  Bei jeder Iteration t <sub>n</sub> gibt es einen klaren Übergang von einer weniger komplexen Theorie zu einer neuen, komplexeren Theorie, jeder dieser Übergänge ist einzigartig und dieser Prozess ist möglicherweise endlos. <br><br>  Das Denken verwirklicht das Bewusstsein in einer asymptotischen Form.  Grob gesagt ist „Bewusstsein der Theorie“ der ultimative, unendlich komplexe Inhalt, den t <sub>n</sub> im Computerprozess anstrebt. <br><br>  <b>Subjektive Erfahrung</b> .  Subjektive Erfahrungen sind das Vorrecht des Bewusstseins.  Bewusstsein ist nicht konstruktiv. <br><br>  Wird der Computer während des Rechnens überleben?  Nein.  In den Ergebnissen der Berechnungen können jedoch Erfahrungen auf Kosten des Computers auftreten. <br><br>  <b>Fazit</b>  Ich glaube, jeder weiß, wie viel Fantasie es braucht, um etwas wirklich Komplexes aufzubauen.  Nicht nur groß, sondern auch komplex.  Und für unendliche Komplexität braucht man endlose Fantasie.  Woher bekommt der Algorithmus so viel Vorstellungskraft?  Es sei denn, die Fantasie selbst ist ein Algorithmus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466089/">https://habr.com/ru/post/de466089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466069/index.html">So bringen Sie das Team dazu, nach produktiveren Ideen zu suchen</a></li>
<li><a href="../de466071/index.html">10,3 Sekunden pro Hash: Mining auf dem Bordsteuerungscomputer des Apollo-Raumfahrzeugs</a></li>
<li><a href="../de466075/index.html">Wie ich die Grundlagenforschung in einem Startup verlassen habe</a></li>
<li><a href="../de466077/index.html">Broadcast Techdir Day in St. Petersburg</a></li>
<li><a href="../de466081/index.html">3. September</a></li>
<li><a href="../de466093/index.html">Wie funktioniert kubectl exec?</a></li>
<li><a href="../de466097/index.html">Überwachen von .NET-Anwendungen</a></li>
<li><a href="../de466099/index.html">Funktionen zum Testen einer Webanwendung für den Videodienst</a></li>
<li><a href="../de466103/index.html">Überwachung der Cloud-Sicherheit</a></li>
<li><a href="../de466105/index.html">Übertakten der Magento Rest API mit RoadRunner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>