<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš˜ ğŸ›³ï¸ ğŸ¤’ Memerangi kompleksitas dalam pengembangan perangkat lunak ğŸ—“ï¸ ğŸ‘š ğŸ•´ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tentang apa ini? 


 Setelah mengerjakan proyek yang berbeda, saya perhatikan bahwa masing-masing dari mereka memiliki beberapa masalah umum, terlepas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memerangi kompleksitas dalam pengembangan perangkat lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458730/"><h2 id="whats-this-about">  Tentang apa ini? </h2><br><p>  Setelah mengerjakan proyek yang berbeda, saya perhatikan bahwa masing-masing dari mereka memiliki beberapa masalah umum, terlepas dari domain, arsitektur, konvensi kode dan sebagainya.  Masalah-masalah itu tidak menantang, hanya rutinitas yang membosankan: memastikan Anda tidak melewatkan sesuatu yang bodoh dan jelas.  Alih-alih melakukan rutinitas ini setiap hari, saya menjadi terobsesi untuk mencari solusi: beberapa pendekatan pengembangan atau konvensi kode atau apa pun yang akan membantu saya merancang proyek dengan cara yang akan mencegah masalah itu terjadi, sehingga saya dapat fokus pada hal-hal menarik .  Itulah tujuan dari artikel ini: untuk menggambarkan masalah-masalah itu dan menunjukkan kepada Anda campuran alat dan pendekatan yang saya temukan untuk menyelesaikannya. </p><a name="habracut"></a><br><h2 id="problems-we-face">  Masalah yang kita hadapi </h2><br><p>  Saat mengembangkan perangkat lunak, kami menghadapi banyak kesulitan: persyaratan yang tidak jelas, miskomunikasi, proses pengembangan yang buruk, dan sebagainya. </p><br><p>  Kami juga menghadapi beberapa kesulitan teknis: kode lama memperlambat kami, penskalaan rumit, beberapa keputusan buruk di masa lalu menendang gigi kami hari ini. </p><br><p>  Semuanya bisa jika tidak dihilangkan kemudian dikurangi secara signifikan, tetapi ada satu masalah mendasar yang tidak dapat Anda lakukan: kompleksitas sistem Anda. </p><br><p>  Gagasan tentang sistem yang Anda kembangkan sendiri selalu kompleks, apakah Anda memahaminya atau tidak. <br>  Bahkan ketika Anda membuat <em>aplikasi CRUD lain</em> , selalu ada beberapa kasus tepi, beberapa hal rumit, dan dari waktu ke waktu seseorang bertanya, "Hei, apa yang akan terjadi jika saya melakukan ini dan ini dalam keadaan seperti ini?"  dan Anda berkata, "Hm, itu pertanyaan yang sangat bagus." </p><br><p>  Kasus rumit, teduh logika, validasi dan pengelolaan akses - semua itu menambah ide besar Anda. <br>  Cukup sering bahwa gagasan itu sangat besar sehingga tidak cocok di satu kepala, dan fakta itu sendiri membawa masalah seperti miskomunikasi. </p><br><p>  Tetapi mari kita bermurah hati dan berasumsi bahwa tim pakar domain dan analis bisnis ini berkomunikasi dengan jelas dan menghasilkan persyaratan konsisten yang baik. </p><br><p>  Sekarang kita harus mengimplementasikannya, untuk mengekspresikan ide rumit itu dalam kode kita.  Sekarang kode itu adalah sistem lain, jauh lebih rumit daripada ide asli yang ada dalam pikiran kita. </p><br><p>  Bagaimana bisa begitu?  Menghadapi kenyataan: keterbatasan teknis memaksa Anda untuk menangani beban tinggi, konsistensi data, dan ketersediaan selain menerapkan logika bisnis yang sebenarnya. </p><br><p>  Seperti yang Anda lihat tugasnya cukup menantang, dan sekarang kami membutuhkan alat yang tepat untuk menghadapinya. <br>  Bahasa pemrograman hanyalah alat lain, dan seperti halnya alat lainnya, ini bukan hanya tentang kualitasnya, itu mungkin lebih banyak lagi tentang alat yang sesuai dengan pekerjaan.  Anda mungkin memiliki obeng terbaik, tetapi jika Anda perlu memasukkan paku ke kayu, palu jelek akan lebih baik, bukan? </p><br><h2 id="technical-aspects">  Aspek teknis </h2><br><p>  Sebagian besar bahasa populer saat ini berorientasi objek.  Ketika seseorang membuat pengantar untuk OOP mereka biasanya menggunakan contoh: <br>  Pertimbangkan sebuah mobil, yang merupakan objek dari dunia nyata.  Ini memiliki berbagai sifat seperti merek, berat, warna, kecepatan maks, kecepatan saat ini dan sebagainya. </p><br><p>  Untuk mencerminkan objek ini dalam program kami, kami mengumpulkan properti-properti itu dalam satu kelas.  Properti bisa permanen atau bisa berubah, yang bersama-sama membentuk keadaan saat ini dari objek ini dan beberapa batas di mana ia dapat bervariasi.  Namun menggabungkan sifat-sifat itu tidak cukup, karena kita harus memeriksa bahwa keadaan saat ini masuk akal, misalnya kecepatan saat ini tidak melebihi kecepatan maks.  Untuk memastikan bahwa kami melampirkan beberapa logika ke kelas ini, tandai properti sebagai pribadi untuk mencegah siapa pun membuat keadaan ilegal. <br>  Seperti yang Anda lihat benda adalah tentang keadaan internal dan siklus hidup mereka. </p><br><p>  Jadi ketiga pilar OOP masuk akal dalam konteks ini: kami menggunakan warisan untuk menggunakan kembali manipulasi negara tertentu, enkapsulasi untuk perlindungan negara dan polimorfisme untuk memperlakukan objek serupa dengan cara yang sama.  Mutabilitas sebagai default juga masuk akal, karena dalam konteks ini objek yang tidak dapat diubah tidak dapat memiliki siklus hidup dan selalu memiliki satu keadaan, yang bukan kasus yang paling umum. </p><br><p> Masalahnya adalah ketika Anda melihat aplikasi web khas hari ini, itu tidak berurusan dengan objek.  Hampir semua yang ada dalam kode kita memiliki masa hidup yang abadi atau tidak memiliki masa hidup yang baik sama sekali.  Dua jenis "objek" yang paling umum adalah semacam layanan seperti <code>UserService</code> , <code>EmployeeRepository</code> atau beberapa model / entitas / DTO atau apa pun namanya.  Layanan tidak memiliki keadaan logis di dalamnya, mereka mati dan dilahirkan kembali persis sama, kami hanya membuat kembali grafik ketergantungan dengan koneksi database baru. </p><br><p>  Entitas dan model tidak memiliki perilaku yang menyertainya, mereka hanya kumpulan data, ketidakmampuan mereka tidak membantu tetapi justru sebaliknya. </p><br><p>  Oleh karena itu fitur utama OOP tidak terlalu berguna untuk mengembangkan aplikasi semacam ini. </p><br><p>  Apa yang terjadi dalam aplikasi web biasa adalah data mengalir: validasi, transformasi, evaluasi, dan sebagainya.  Dan ada paradigma yang sangat cocok untuk pekerjaan semacam itu: pemrograman fungsional.  Dan ada bukti untuk itu: semua fitur modern dalam bahasa populer saat ini berasal dari sana: <code>async/await</code> , lambdas dan delegate, pemrograman reaktif, serikat yang didiskriminasi (enum dengan cepat atau karat, tidak perlu bingung dengan enum di java atau .net ), tuple - semua itu dari FP. </p><br><p>  Namun itu hanya hancur, itu sangat bagus untuk memilikinya, tetapi ada lebih banyak, lebih banyak lagi. </p><br><p>  Sebelum saya melangkah lebih dalam, ada satu hal yang harus dibuat.  Beralih ke bahasa baru, terutama paradigma baru, adalah investasi untuk pengembang dan karenanya untuk bisnis.  Melakukan investasi bodoh tidak akan memberi Anda apa pun selain masalah, tetapi investasi yang masuk akal mungkin adalah hal yang akan membuat Anda bertahan. </p><br><h2 id="tools-we-have-and-what-they-give-us">  Alat yang kita miliki dan apa yang mereka berikan kepada kita </h2><br><p>  Banyak dari kita lebih suka bahasa dengan pengetikan statis.  Alasannya sederhana: kompiler menangani pemeriksaan yang membosankan seperti melewatkan parameter yang tepat ke fungsi, membangun entitas kita dengan benar dan seterusnya.  Cek ini gratis.  Sekarang, untuk hal-hal yang tidak dapat diperiksa oleh kompiler, kami punya pilihan: berharap yang terbaik atau melakukan beberapa tes.  Tes menulis berarti uang, dan Anda tidak membayar hanya sekali per tes, Anda harus mempertahankannya.  Selain itu, orang menjadi ceroboh, jadi sesekali kita mendapatkan hasil positif palsu dan negatif palsu.  Semakin banyak tes yang Anda tulis, semakin rendah kualitas rata-rata tes tersebut.  Ada masalah lain: untuk menguji sesuatu, Anda harus tahu dan ingat bahwa hal itu harus diuji, tetapi semakin besar sistem Anda semakin mudah untuk melewatkan sesuatu. </p><br><p>  Namun kompiler hanya sebagus jenis sistem bahasa.  Jika tidak memungkinkan Anda untuk mengekspresikan sesuatu dengan cara statis, Anda harus melakukannya saat runtime.  Yang artinya tes, ya.  Ini bukan hanya tentang jenis sistem, sintaks dan fitur gula kecil juga sangat penting, karena pada akhirnya kami ingin menulis kode sesedikit mungkin, jadi jika beberapa pendekatan mengharuskan Anda untuk menulis sepuluh kali lebih banyak baris, yah, tidak ada yang akan menggunakannya.  Itulah mengapa penting bahwa bahasa yang Anda pilih memiliki serangkaian fitur dan trik yang pas - well, fokus yang tepat secara keseluruhan.  Jika tidak - alih-alih menggunakan fitur-fiturnya untuk melawan tantangan asli seperti kompleksitas sistem Anda dan mengubah persyaratan, Anda juga akan melawan bahasa.  Dan semuanya bergantung pada uang, karena Anda membayar pengembang untuk waktu mereka.  Semakin banyak masalah yang harus mereka selesaikan, semakin banyak waktu yang mereka butuhkan dan semakin banyak pengembang yang akan Anda butuhkan. </p><br><p>  Akhirnya kita akan melihat beberapa kode untuk membuktikan semua itu.  Saya kebetulan adalah pengembang .NET, jadi sampel kode akan menggunakan C # dan F #, tetapi gambaran umum akan terlihat kurang lebih sama dalam bahasa OOP dan FP populer lainnya. </p><br><h2 id="let-the-coding-begin">  Biarkan pengkodean dimulai </h2><br><p>  Kami akan membangun aplikasi web untuk mengelola kartu kredit. </p><br><p>  Persyaratan dasar: </p><br><ul><li>  Buat / Baca pengguna </li><li>  Buat / Baca kartu kredit </li><li>  Aktifkan / Nonaktifkan kartu kredit </li><li>  Tetapkan batas harian untuk kartu </li><li>  Saldo isi ulang </li><li>  Pembayaran proses (mempertimbangkan saldo, tanggal kedaluwarsa kartu, status aktif / dinonaktifkan, dan batas harian) </li></ul><br><p>  Demi kesederhanaan kami akan menggunakan satu kartu per akun dan kami akan melewati otorisasi.  Tetapi untuk sisanya kita akan membangun aplikasi yang mampu dengan validasi, penanganan kesalahan, database dan api web.  Jadi mari kita mulai dengan tugas pertama kita: mendesain kartu kredit. </p><br><p>  Pertama, mari kita lihat seperti apa bentuknya di C # </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Card</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CardNumber {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExpirationMonth {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExpirationYear {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AccountInfo AccountInfo {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AccountInfo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> Balance {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CardNumber {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> DailyLimit {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre> <br><p>  Tapi itu tidak cukup, kita harus menambahkan validasi, dan umumnya itu dilakukan di beberapa <code>Validator</code> , seperti yang ada di <code>FluentValidation</code> . </p><br><p>  Aturannya sederhana: </p><br><ul><li>  Nomor kartu diperlukan dan harus berupa string 16 digit. </li><li>  Nama diperlukan dan harus hanya berisi huruf dan dapat berisi spasi di tengah. </li><li>  Bulan dan tahun harus memenuhi batas. </li><li>  Info akun harus ada saat kartu aktif dan tidak ada saat kartu dinonaktifkan.  Jika Anda bertanya-tanya mengapa, itu sederhana: ketika kartu dinonaktifkan, seharusnya tidak mungkin untuk mengubah saldo atau batas harian. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CardValidator</span></span> : <span class="hljs-title"><span class="hljs-title">IValidator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CardNumberRegex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"^[0-9]{16}$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> NameRegex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"^[\w]+[\w ]+[\w]+$"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CardValidator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RuleFor(x =&gt; x.CardNumber) .Must(c =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(c) &amp;&amp; CardNumberRegex.IsMatch(c)) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh my"</span></span>); RuleFor(x =&gt; x.Name) .Must(c =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(c) &amp;&amp; NameRegex.IsMatch(c)) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh no"</span></span>); RuleFor(x =&gt; x.ExpirationMonth) .Must(x =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); RuleFor(x =&gt; x.ExpirationYear) .Must(x =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">2019</span></span> &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">2023</span></span>) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); RuleFor(x =&gt; x.AccountInfo) .Null() .When(x =&gt; !x.IsActive) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); RuleFor(x =&gt; x.AccountInfo) .NotNull() .When(x =&gt; x.IsActive) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); } }</code> </pre> <br><p>  Sekarang ada beberapa masalah dengan pendekatan ini: </p><br><ul><li>  Validasi dipisahkan dari deklarasi tipe, yang berarti untuk melihat gambaran lengkap dari <em>kartu apa yang sebenarnya</em> harus kita navigasikan melalui kode dan membuat ulang gambar ini di kepala kita.  Ini bukan masalah besar ketika itu terjadi hanya sekali, tetapi ketika kita harus melakukan itu untuk setiap entitas dalam proyek besar, yah, itu sangat memakan waktu. </li><li>  Validasi ini tidak dipaksakan, kita harus ingat untuk menggunakannya di mana-mana.  Kami dapat memastikan ini dengan tes, tetapi sekali lagi, Anda harus mengingatnya saat Anda menulis tes. </li><li>  Ketika kami ingin memvalidasi nomor kartu di tempat lain, kami harus melakukan hal yang sama lagi.  Tentu, kami dapat menyimpan regex di tempat yang sama, tetapi kami masih harus menyebutnya di setiap validator. </li></ul><br><p>  Dalam F # kita bisa melakukannya dengan cara yang berbeda: </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- First we define a type for CardNumber with private constructor and public factory which receives string and returns `Result&lt;CardNumber, string&gt;`. Normally we would use `ValidationError` instead, but string is good enough for example -}</span></span>*) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> = private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> of string with member this.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Value</span></span></span><span class="hljs-class"> = match this with </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> s -&gt; s static member create str = match str with | (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">|"") -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error</span></span></span><span class="hljs-class"> "card number can't be empty" | str -&gt; if cardNumberRegex.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsMatch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">str</span></span></span><span class="hljs-class">) then </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> str |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class"> else </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error</span></span></span><span class="hljs-class"> "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> number must be a 16 digits string" (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- Then in here we express this logic "when card is deactivated, balance and daily limit manipulations aren't available". Note that this is way easier to grasp that reading `RuleFor()` in validators. -}</span></span></span><span class="hljs-class">*) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardAccountInfo</span></span></span><span class="hljs-class"> = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Active</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Deactivated</span></span></span><span class="hljs-class"> (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- And then that's it. The whole set of rules is here, and it's described in a static way. We don't need tests for that, the compiler is our test. And we can't accidentally miss this validation. -}</span></span></span><span class="hljs-class">*) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class"> //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- LetterString is another type with built-in validation HolderId: UserId Expiration: (Month * Year) AccountDetails: CardAccountInfo }</span></span></span></span></code> </pre> <br><p>  Tentu saja beberapa hal dari sini bisa kita lakukan di C #.  Kita dapat membuat kelas <code>CardNumber</code> yang akan melempar <code>ValidationException</code> di sana juga.  Tetapi trik dengan <code>CardAccountInfo</code> tidak dapat dilakukan dalam C # dengan cara mudah. <br>  Hal lain - C # sangat bergantung pada pengecualian.  Ada beberapa masalah dengan itu: </p><br><ul><li>  Pengecualian memiliki "pergi ke" semantik.  Satu saat Anda di sini dalam metode ini, yang lain - Anda berakhir di beberapa penangan global. </li><li>  Mereka tidak muncul dalam tanda tangan metode.  Pengecualian seperti <code>ValidationException</code> atau <code>InvalidUserOperationException</code> adalah bagian dari kontrak, tetapi Anda tidak tahu itu sampai Anda membaca <em>implementasi</em> .  Dan itu masalah besar, karena cukup sering Anda harus menggunakan kode yang ditulis oleh orang lain, dan alih-alih membaca hanya tanda tangan, Anda harus menavigasi sampai ke bagian bawah tumpukan panggilan, yang membutuhkan banyak waktu. </li></ul><br><p>  Dan inilah yang mengganggu saya: setiap kali saya menerapkan beberapa fitur baru, proses implementasi itu sendiri tidak memakan banyak waktu, sebagian besar pergi ke dua hal: </p><br><ul><li>  Membaca kode orang lain dan mencari tahu aturan logika bisnis. </li><li>  Memastikan tidak ada yang rusak. </li></ul><br><p>  Ini mungkin terdengar seperti gejala desain kode yang buruk, tetapi hal yang sama terjadi pada proyek yang ditulis dengan baik. <br>  Oke, tapi kita bisa mencoba menggunakan hasil yang sama di C #.  Implementasi yang paling jelas akan terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TOk Ok {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TError Error {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre> <br><p>  dan itu adalah sampah murni, itu tidak mencegah kita dari pengaturan baik <code>Ok</code> dan <code>Error</code> dan memungkinkan kesalahan diabaikan sepenuhnya.  Versi yang tepat akan menjadi seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsOk { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OkResult</span></span> : <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TOk _ok; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OkResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TOk ok</span></span></span><span class="hljs-function">)</span></span> { _ok = ok; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsOk =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ErrorResult</span></span> : <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TError _error; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrorResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TError error</span></span></span><span class="hljs-function">)</span></span> { _error = error; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsOk =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Result&lt;TOk, TError&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ok</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TOk ok</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OkResult(ok); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Result&lt;TOk, TError&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TError error</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ErrorResult(error); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Result&lt;T, TError&gt; Map&lt;T&gt;(Func&lt;TOk, T&gt; map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsOk) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((OkResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;T, TError&gt;.Ok(map(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((ErrorResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._error; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;T, TError&gt;.Error(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Result&lt;TOk, T&gt; MapError&lt;T&gt;(Func&lt;TError, T&gt; mapError) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsOk) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((OkResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;TOk, T&gt;.Ok(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((ErrorResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._error; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;TOk, T&gt;.Error(mapError(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } } }</code> </pre> <br><p>  Cukup rumit, bukan?  Dan saya bahkan tidak mengimplementasikan versi <code>void</code> untuk <code>Map</code> dan <code>MapError</code> .  Penggunaannya akan terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> squareResult = result.Map(x =&gt; x * x); }</code> </pre> <br><p>  Tidak terlalu buruk, eh?  Nah, sekarang bayangkan Anda memiliki tiga hasil dan Anda ingin melakukan sesuatu dengan mereka ketika semuanya <code>Ok</code> .  Jahat.  Jadi itu bukan pilihan. <br>  Versi F #: </p><br><pre> <code class="haskell hljs">//<span class="hljs-comment"><span class="hljs-comment">-- this type is in standard library, but declaration looks like this: type Result&lt;'ok, 'error&gt; = | Ok of 'ok | Error of 'error //-- and usage: let test res1 res2 res3 = match res1, res2, res3 with | Ok ok1, Ok ok2, Ok ok3 -&gt; printfn "1: %A 2: %A 3: %A" ok1 ok2 ok3 | _ -&gt; printfn "fail"</span></span></code> </pre> <br><p>  Pada dasarnya, Anda harus memilih apakah Anda menulis kode dalam jumlah yang wajar, tetapi kodenya tidak jelas, bergantung pada pengecualian, refleksi, ekspresi, dan "sihir" lainnya, atau Anda menulis lebih banyak kode, yang sulit dibaca, tetapi lebih tahan lama dan lurus ke depan.  Ketika proyek seperti itu menjadi besar, Anda tidak bisa melawannya, tidak dalam bahasa dengan sistem tipe mirip C #.  Mari kita pertimbangkan skenario sederhana: Anda memiliki beberapa entitas di basis kode Anda untuk sementara waktu.  Hari ini Anda ingin menambahkan bidang wajib baru.  Tentu saja Anda perlu menginisialisasi bidang ini di mana pun entitas ini dibuat, tetapi kompiler tidak membantu Anda sama sekali, karena kelas bisa berubah dan <code>null</code> adalah nilai yang valid.  Dan perpustakaan seperti <code>AutoMapper</code> membuatnya lebih sulit.  Mutabilitas ini memungkinkan kita untuk menginisialisasi sebagian objek di satu tempat, lalu mendorongnya ke tempat lain dan melanjutkan inisialisasi di sana.  Itu sumber bug lain. </p><br><p>  Sementara perbandingan fitur bahasa itu bagus, namun ini bukan tentang artikel ini.  Jika Anda tertarik, saya membahas topik itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  Tetapi fitur bahasa itu sendiri seharusnya tidak menjadi alasan untuk beralih teknologi. </p><br><p>  Jadi itu membawa kita ke pertanyaan-pertanyaan ini: </p><br><ol><li>  Mengapa kita benar-benar perlu beralih dari OOP modern? </li><li>  Mengapa kita harus beralih ke FP? </li></ol><br><p>  Jawaban untuk pertanyaan pertama adalah menggunakan bahasa OOP umum untuk aplikasi modern memberi Anda banyak masalah, karena mereka dirancang untuk tujuan yang berbeda.  Ini menghasilkan waktu dan uang yang Anda habiskan untuk melawan desain mereka bersama dengan kompleksitas perjuangan aplikasi Anda. </p><br><p>  Dan jawaban kedua adalah bahasa FP memberi Anda cara mudah untuk merancang fitur Anda sehingga mereka bekerja seperti jam, dan jika fitur baru istirahat logika yang ada, itu memecahkan kode, maka Anda segera tahu itu. </p><br><hr><br><p>  Namun jawaban itu tidak cukup.  Seperti yang ditunjukkan teman saya dalam salah satu diskusi kami, beralih ke FP akan sia-sia ketika Anda tidak tahu praktik terbaik.  Industri besar kami menghasilkan banyak artikel, buku, dan tutorial tentang merancang aplikasi OOP, dan kami memiliki pengalaman produksi dengan OOP, jadi kami tahu apa yang diharapkan dari berbagai pendekatan.  Sayangnya, ini bukan kasus untuk pemrograman fungsional, jadi bahkan jika Anda beralih ke FP, upaya pertama Anda kemungkinan besar akan terasa canggung dan tentu saja tidak akan memberi Anda hasil yang diinginkan: pengembangan sistem kompleks yang cepat dan tidak menyakitkan. </p><br><p>  Nah, itulah tepatnya artikel ini.  Seperti yang saya katakan, kita akan membangun aplikasi seperti produksi untuk melihat perbedaannya. </p><br><h2 id="how-do-we-design-application">  Bagaimana kita mendesain aplikasi? </h2><br><p>  Banyak ide yang saya gunakan dalam proses desain yang saya pinjam dari buku besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Domain Modeling Made Functional</a> , jadi saya sangat menyarankan Anda untuk membacanya. </p><br><p>  Kode sumber lengkap dengan komentar ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Secara alami, saya tidak akan memasukkan semuanya ke sini, jadi saya akan membahas poin-poin penting saja. </p><br><p>  Kami akan memiliki 4 proyek utama: lapisan bisnis, lapisan akses data, infrastruktur dan, tentu saja, umum.  Setiap solusi memilikinya, bukan? </p><br><p>  Kami mulai dengan memodelkan domain kami.  Saat ini kami tidak tahu dan tidak peduli tentang database.  Ini dilakukan dengan sengaja, karena dengan mengingat basis data tertentu, kami cenderung merancang domain kami sesuai dengan itu, kami membawa hubungan entitas-tabel ini di lapisan bisnis, yang kemudian membawa masalah.  Anda hanya perlu menerapkan pemetaan <code>domain -&gt; DAL</code> sekali, sementara desain yang salah akan terus-menerus mengganggu kami sampai titik kami memperbaikinya.  Jadi inilah yang kami lakukan: kami membuat proyek bernama <code>CardManagement</code> (sangat kreatif, saya tahu), dan segera mengaktifkan pengaturan <code>&lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt;</code> dalam file proyek.  Mengapa kita membutuhkan ini?  Baiklah, kita akan menggunakan banyak serikat yang didiskriminasi, dan ketika Anda melakukan pencocokan pola, kompiler memberi kami peringatan, jika kami tidak mencakup semua kemungkinan kasus: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> fail result = match result with | <span class="hljs-type"><span class="hljs-type">Ok</span></span> v -&gt; printfn <span class="hljs-string"><span class="hljs-string">"%A"</span></span> v //<span class="hljs-comment"><span class="hljs-comment">-- warning: Incomplete pattern matches on this expression. //-- For example, the value 'Error' may indicate a case not covered by the pattern(s).</span></span></code> </pre> <br><p>  Dengan pengaturan ini, kode ini tidak dapat dikompilasi, yang persis seperti yang kita butuhkan, ketika kita memperluas fungsionalitas yang ada dan ingin disesuaikan di mana-mana.  Hal berikutnya yang kita lakukan adalah membuat modul (dikompilasi dalam kelas statis) <code>CardDomain</code> .  Dalam file ini kami menjelaskan jenis domain dan tidak lebih.  Ingatlah bahwa dalam F #, kode dan urutan file penting: secara default Anda hanya dapat menggunakan apa yang Anda nyatakan sebelumnya. </p><br><h3 id="domain-types">  Jenis domain </h3><br><p>  Kami mulai mendefinisikan jenis kami dengan <code>CardNumber</code> saya tunjukkan sebelumnya, meskipun kami akan membutuhkan <code>Error</code> lebih praktis daripada hanya string, jadi kami akan menggunakan <code>ValidationError</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidationError</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FieldPath</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } let validationError field message = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FieldPath</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class"> } (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- Actually we should use here Luhn's algorithm, but I leave it to you as an exercise, so you can see for yourself how easy is updating code to new requirements. -}</span></span></span><span class="hljs-class">*) let private cardNumberRegex = new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Regex</span></span></span><span class="hljs-class">("^[0-9]{16}$", </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegexOptions</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Compiled</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> = private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> of string with member this.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Value</span></span></span><span class="hljs-class"> = match this with </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> s -&gt; s static member create fieldName str = match str with | (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">|"") -&gt; validationError fieldName "card number can't be empty" | str -&gt; if cardNumberRegex.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsMatch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">str</span></span></span><span class="hljs-class">) then </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> str |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class"> else validationError fieldName "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> number must be a 16 digits string"</span></span></code> </pre> <br><p>  Maka tentu saja kami mendefinisikan <code>Card</code> yang merupakan jantung dari domain kami.  Kita tahu bahwa kartu memiliki beberapa atribut permanen seperti nomor, tanggal kedaluwarsa dan nama pada kartu, dan beberapa informasi yang dapat diubah seperti saldo dan batas harian, jadi kami merangkum informasi yang dapat diubah dalam jenis lain: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HolderId</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Balance</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Money</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DailyLimit</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DailyLimit</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HolderId</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expiration</span></span></span><span class="hljs-class">: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Month</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Year</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountDetails</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardAccountInfo</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Sekarang, ada beberapa jenis di sini, yang belum kami nyatakan: </p><br><ol><li><p>  <strong>Uang</strong> </p><br><p>  Kita dapat menggunakan <code>decimal</code> (dan akan, tetapi tidak secara langsung), tetapi <code>decimal</code> kurang deskriptif.  Selain itu, dapat digunakan untuk representasi hal-hal lain selain uang, dan kami tidak ingin itu tercampur.  Jadi kami menggunakan tipe <code>type [&lt;Struct&gt;] Money = Money of decimal</code> . </p><br></li><li><p>  <strong>Dailylimit</strong> </p><br><p>  Batas harian dapat diatur ke jumlah tertentu atau tidak ada sama sekali.  Jika ada, pasti positif.  Alih-alih menggunakan <code>decimal</code> atau <code>Money</code> kami mendefinisikan jenis ini: </p><br><pre> <code class="haskell hljs">[&lt;<span class="hljs-type"><span class="hljs-type">Struct</span></span>&gt;] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DailyLimit</span></span></span><span class="hljs-class"> = private //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- private constructor so it can't be created directly outside of module | Limit of Money | Unlimited with static member ofDecimal dec = if dec &gt; 0m then Money dec |&gt; Limit else Unlimited member this.ToDecimalOption() = match this with | Unlimited -&gt; None | Limit limit -&gt; Some limit.Value</span></span></span></span></code> </pre> <br><p>  Ini lebih deskriptif daripada hanya menyiratkan bahwa <code>0M</code> berarti bahwa tidak ada batasan, karena itu juga bisa berarti bahwa Anda tidak dapat menghabiskan uang untuk kartu ini.  Satu-satunya masalah adalah karena kami menyembunyikan konstruktor, kami tidak dapat melakukan pencocokan pola.  Tapi jangan khawatir, kita bisa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pola Aktif</a> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (|<span class="hljs-type"><span class="hljs-type">Limit</span></span>|<span class="hljs-type"><span class="hljs-type">Unlimited</span></span>|) limit = match limit with | <span class="hljs-type"><span class="hljs-type">Limit</span></span> dec -&gt; <span class="hljs-type"><span class="hljs-type">Limit</span></span> dec | <span class="hljs-type"><span class="hljs-type">Unlimited</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Unlimited</span></span></code> </pre> <br><p>  Sekarang kita dapat mencocokkan pola <code>DailyLimit</code> mana-mana sebagai DU biasa. </p><br></li><li><p>  <strong>Letterstring</strong> </p><br><p>  Yang itu sederhana.  Kami menggunakan teknik yang sama seperti di <code>CardNumber</code> .  Satu hal kecil: <code>LetterString</code> bukan tentang kartu kredit, itu agak dan kita harus memindahkannya dalam proyek <code>Common</code> dalam modul <code>CommonTypes</code> .  Tiba saatnya kita memindahkan <code>ValidationError</code> ke tempat yang terpisah juga. </p><br></li><li><p>  <strong>Userid</strong> </p><br><p>  Yang itu hanyalah <code>type UserId = System.Guid</code> alias <code>type UserId = System.Guid</code> .  Kami menggunakannya untuk deskripsi saja. </p><br></li><li><p>  <strong>Bulan dan Tahun</strong> </p><br><p>  Mereka juga harus pergi ke <code>Common</code> .  <code>Month</code> akan menjadi serikat terdiskriminasi dengan metode untuk mengubahnya ke dan dari <code>unsigned int16</code> , <code>Year</code> akan menjadi seperti <code>CardNumber</code> tetapi untuk <code>uint16</code> bukan string. </p><br></li></ol><br><p>  Sekarang mari kita selesaikan deklarasi tipe domain kita.  Kami membutuhkan <code>User</code> dengan beberapa informasi pengguna dan pengumpulan kartu, kami membutuhkan operasi keseimbangan untuk pengisian dan pembayaran. </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cards</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> } [&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Struct</span></span></span><span class="hljs-class">&gt;] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceChange</span></span></span><span class="hljs-class"> = //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- another common type with validation for positive amount | Increase of increase: MoneyTransaction | Decrease of decrease: MoneyTransaction with member this.ToDecimal() = match this with | Increase i -&gt; i.Value | Decrease d -&gt; -d.Value [&lt;Struct&gt;] type BalanceOperation = { CardNumber: CardNumber Timestamp: DateTimeOffset BalanceChange: BalanceChange NewBalance: Money }</span></span></span></span></code> </pre> <br><p>  Bagus, kami mendesain tipe kami dengan cara yang tidak valid tidak dapat ditampilkan.  Sekarang setiap kali kita berurusan dengan instance dari salah satu dari jenis ini, kami yakin bahwa data di sana valid dan kami tidak perlu memvalidasinya lagi.  Sekarang kita dapat melanjutkan ke logika bisnis! </p><br><h3 id="business-logic">  Logika bisnis </h3><br><p>  Kami akan memiliki aturan yang tidak bisa dipecahkan di sini: semua logika bisnis akan dikodekan dalam <strong>fungsi murni</strong> .  Fungsi murni adalah fungsi yang memenuhi kriteria berikut: </p><br><ul><li>  Satu-satunya hal yang dilakukannya adalah menghitung nilai output.  Tidak memiliki efek samping sama sekali. </li><li>  Selalu menghasilkan output yang sama untuk input yang sama. </li></ul><br><p>  Karenanya fungsi murni tidak membuang pengecualian, tidak menghasilkan nilai acak, tidak berinteraksi dengan dunia luar dalam bentuk apa pun, baik itu basis data atau <code>DateTime.Now</code> sederhana. Sekarang.  Tentu saja berinteraksi dengan fungsi tidak murni secara otomatis membuat fungsi panggilan tidak murni.  Jadi apa yang akan kita terapkan? </p><br><p>  Berikut daftar persyaratan yang kami miliki: </p><br><ul><li><p>  <strong>Aktifkan / nonaktifkan kartu</strong> </p><br></li><li><p>  <strong>Memproses pembayaran</strong> </p><br><p>  Kami dapat memproses pembayaran jika: </p><br><ol><li>  Kartu tidak kedaluwarsa </li><li>  Kartu aktif </li><li>  Ada cukup uang untuk pembayaran </li><li>  Pengeluaran untuk hari ini belum melampaui batas harian. </li></ol><br></li><li><p>  <strong>Saldo isi ulang</strong> </p><br><p>  Kami dapat menambah saldo untuk kartu aktif dan tidak kedaluwarsa. </p><br></li><li><p>  <strong>Tetapkan batas harian</strong> </p><br><p>  Pengguna dapat menetapkan batas harian jika kartu tidak kedaluwarsa dan aktif. </p><br></li></ul><br><p>  Ketika operasi tidak dapat diselesaikan kita harus mengembalikan kesalahan, jadi kita perlu mendefinisikan <code>OperationNotAllowedError</code> : </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationNotAllowedError</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reason</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- and a helper function to wrap it in `Error` which is a case for `Result&lt;'ok,'error&gt; type let operationNotAllowed operation reason = { Operation = operation; Reason = reason } |&gt; Error</span></span></span></span></code> </pre> <br><p>  Dalam modul ini dengan logika bisnis yang akan menjadi <em>satu-satunya</em> jenis kesalahan yang kita kembalikan.  Kami tidak melakukan validasi di sini, jangan berinteraksi dengan basis data - hanya menjalankan operasi jika kami bisa mengembalikan <code>OperationNotAllowedError</code> . </p><br><p>  Modul lengkap dapat ditemukan di <a href="">sini</a> .  Saya akan daftar di sini kasus paling sulit di sini: <code>processPayment</code> .  Kita harus memeriksa kedaluwarsa, status aktif / dinonaktifkan, uang yang dihabiskan hari ini dan saldo saat ini.  Karena kita tidak dapat berinteraksi dengan dunia luar, kita harus memberikan semua informasi yang diperlukan sebagai parameter.  Dengan begitu <em>logika</em> ini akan sangat mudah untuk diuji, dan memungkinkan Anda untuk melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian berbasis properti</a> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> processPayment (currentDate: <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span>) (spentToday: <span class="hljs-type"><span class="hljs-type">Money</span></span>) card (paymentAmount: <span class="hljs-type"><span class="hljs-type">MoneyTransaction</span></span>) = //<span class="hljs-comment"><span class="hljs-comment">-- first check for expiration if isCardExpired currentDate card then cardExpiredMessage card.CardNumber |&gt; processPaymentNotAllowed else //-- then active/deactivated match card.AccountDetails with | Deactivated -&gt; cardDeactivatedMessage card.CardNumber |&gt; processPaymentNotAllowed | Active accInfo -&gt; //-- if active then check balance if paymentAmount.Value &gt; accInfo.Balance.Value then sprintf "Insufficent funds on card %s" card.CardNumber.Value |&gt; processPaymentNotAllowed else //-- if balance is ok check limit and money spent today match accInfo.DailyLimit with | Limit limit when limit &lt; spentToday + paymentAmount -&gt; sprintf "Daily limit is exceeded for card %s with daily limit %M. Today was spent %M" card.CardNumber.Value limit.Value spentToday.Value |&gt; processPaymentNotAllowed (*{- We could use here the ultimate wild card case like this: | _ -&gt; but it's dangerous because if a new case appears in `DailyLimit` type, we won't get a compile error here, which would remind us to process this new case in here. So this is a safe way to do the same thing. -}*) | Limit _ | Unlimited -&gt; let newBalance = accInfo.Balance - paymentAmount let updatedCard = { card with AccountDetails = Active { accInfo with Balance = newBalance } } //-- note that we have to return balance operation, //-- so it can be stored to DB later. let balanceOperation = { Timestamp = currentDate CardNumber = card.CardNumber NewBalance = newBalance BalanceChange = Decrease paymentAmount } Ok (updatedCard, balanceOperation)</span></span></code> </pre> <br><p>  Ini <code>spentToday</code> Ini - kita harus menghitungnya dari koleksi <code>BalanceOperation</code> akan kita simpan di basis data.  Jadi kita perlu modul untuk itu, yang pada dasarnya akan memiliki 1 fungsi publik: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> private isDecrease change = match change with | <span class="hljs-type"><span class="hljs-type">Increase</span></span> _ -&gt; false | <span class="hljs-type"><span class="hljs-type">Decrease</span></span> _ -&gt; true <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spentAtDate (date: <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span>) cardNumber operations = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = date.<span class="hljs-type"><span class="hljs-type">Date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> operationFilter { <span class="hljs-type"><span class="hljs-type">CardNumber</span></span> = number; <span class="hljs-type"><span class="hljs-type">BalanceChange</span></span> = change; <span class="hljs-type"><span class="hljs-type">Timestamp</span></span> = timestamp } = isDecrease change &amp;&amp; number = cardNumber &amp;&amp; timestamp.<span class="hljs-type"><span class="hljs-type">Date</span></span> = date <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spendings = <span class="hljs-type"><span class="hljs-type">List</span></span>.filter operationFilter operations <span class="hljs-type"><span class="hljs-type">List</span></span>.sumBy (fun s -&gt; -s.<span class="hljs-type"><span class="hljs-type">BalanceChange</span></span>.<span class="hljs-type"><span class="hljs-type">ToDecimal</span></span>()) spendings |&gt; <span class="hljs-type"><span class="hljs-type">Money</span></span></code> </pre> <br><p>  Bagus  Sekarang kita sudah selesai dengan semua implementasi logika bisnis, saatnya memikirkan pemetaan.  Banyak tipe kami menggunakan serikat yang didiskriminasi, beberapa tipe kami tidak memiliki konstruktor publik, jadi kami tidak bisa mengekspos mereka seperti halnya ke dunia luar.  Kita harus berurusan dengan serialisasi (de).  Selain itu, saat ini kami hanya memiliki satu konteks terbatas dalam aplikasi kami, tetapi di kemudian hari dalam kehidupan nyata Anda ingin membangun sistem yang lebih besar dengan berbagai konteks terikat, dan mereka harus berinteraksi satu sama lain melalui kontrak publik, yang harus dapat dipahami. untuk semua orang, termasuk bahasa pemrograman lain. </p><br><p>  Kita harus melakukan pemetaan dua arah: dari model publik ke domain dan sebaliknya.  Sementara pemetaan dari domain ke model cukup maju, arah lain memiliki sedikit acar: model dapat memiliki data yang tidak valid, setelah semua kita menggunakan tipe polos yang dapat diserialisasi ke json.  Jangan khawatir, kita harus membangun validasi kami dalam pemetaan itu.  Fakta bahwa kami menggunakan tipe berbeda untuk data dan data yang mungkin tidak valid, itu <strong>selalu</strong> berarti valid, bahwa kompiler tidak akan membiarkan kami lupa untuk melakukan validasi. </p><br><p>  Begini tampilannya: </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- You can use type aliases to annotate your functions. This is just an example, but sometimes it makes code more readable -}</span></span>*) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidateCreateCardCommand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCardCommandModel</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidationResult</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">&gt; let validateCreateCardCommand : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidateCreateCardCommand</span></span></span><span class="hljs-class"> = fun cmd -&gt; (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- that's a computation expression for `Result&lt;&gt;` type. Thanks to this we don't have to chose between short code and strait forward one, like we have to do in C# -}</span></span></span><span class="hljs-class">*) result { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cardNumber</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">month</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Month</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expirationMonth</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationMonth</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">year</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Year</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expirationYear</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationYear</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HolderId</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expiration</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">month</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">year</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountDetails</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Default</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Active</span></span></span><span class="hljs-class"> } }</span></span></code> </pre> <br><p>  Modul lengkap untuk pemetaan dan validasi ada di <a href="">sini</a> dan modul untuk memetakan ke model ada di <a href="">sini</a> . </p><br><p>  Pada titik ini kami memiliki implementasi untuk semua logika bisnis, pemetaan, validasi, dan sebagainya, dan sejauh ini semuanya benar-benar terisolasi dari dunia nyata: semuanya ditulis dalam fungsi murni sepenuhnya.  Sekarang Anda mungkin bertanya-tanya, bagaimana tepatnya kita akan memanfaatkan ini?  Karena kita memang harus berinteraksi dengan dunia luar.  Lebih dari itu, selama eksekusi alur kerja kita harus membuat beberapa keputusan berdasarkan hasil dari interaksi dunia nyata itu.  Jadi pertanyaannya adalah bagaimana kita mengumpulkan semua ini?  Dalam OOP mereka menggunakan wadah IoC untuk menangani itu, tetapi di sini kita tidak dapat melakukan itu, karena kita bahkan tidak memiliki objek, kita memiliki fungsi statis. </p><br><p>  Kita akan menggunakan <code>Interpreter pattern</code> untuk itu!  Agak sulit, sebagian besar karena tidak dikenal, tetapi saya akan melakukan yang terbaik untuk menjelaskan pola ini.  Pertama, mari kita bicara tentang komposisi fungsi.  Misalnya kita memiliki fungsi <code>int -&gt; string</code> .  Ini berarti bahwa fungsi mengharapkan <code>int</code> sebagai parameter dan mengembalikan string.  Sekarang katakanlah kita memiliki <code>string -&gt; char</code> fungsi lain <code>string -&gt; char</code> .  Pada titik ini kita dapat mengaitkannya, mis. Jalankan yang pertama, ambil outputnya dan beri makan ke fungsi kedua, dan bahkan ada operator untuk itu: <code>&gt;&gt;</code> .  Begini cara kerjanya: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> intToString (i: int) = i.<span class="hljs-type"><span class="hljs-type">ToString</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstCharOrSpace (s: string) = match s with | (null| <span class="hljs-string"><span class="hljs-string">""</span></span>) -&gt; ' ' | s -&gt; s.[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstDigitAsChar = intToString &gt;&gt; firstCharOrSpace //<span class="hljs-comment"><span class="hljs-comment">-- And you can chain as many functions as you like let alwaysTrue = intToString &gt;&gt; firstCharOrSpace &gt;&gt; Char.IsDigit</span></span></code> </pre> <br><p>  Namun kami tidak dapat menggunakan perangkaian sederhana dalam beberapa skenario, misalnya mengaktifkan kartu.  Berikut urutan tindakan: </p><br><ul><li>  memvalidasi nomor kartu input.  Jika itu valid, maka </li><li>  coba dapatkan kartu dengan nomor ini.  Jika ada </li><li>  aktifkan itu. </li><li>  simpan hasil.  Jika tidak apa-apa maka </li><li>  memetakan untuk memodelkan dan kembali. </li></ul><br><p>  Dua langkah pertama memiliki itu <code>If it's ok then...</code>  Itulah alasan mengapa rantai langsung tidak bekerja. </p><br><p>  Kami cukup menyuntikkan sebagai parameter fungsi-fungsi tersebut, seperti ini: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> activateCard getCardAsync saveCardAsync cardNumber = ...</code> </pre> <br><p>  Tapi ada masalah tertentu dengan itu.  Pertama, jumlah dependensi dapat tumbuh besar dan fungsi tanda tangan akan terlihat jelek.  Kedua, kita terikat dengan efek khusus di sini: kita harus memilih apakah itu <code>Task</code> atau <code>Async</code> atau sekadar panggilan sinkronisasi.  Ketiga, mudah untuk mengacaukan segalanya ketika Anda memiliki banyak fungsi untuk dilewati: mis. <code>replaceUserAsync</code> dan <code>replaceUserAsync</code> memiliki tanda tangan yang sama tetapi efek yang berbeda, jadi ketika Anda harus melewatinya ratusan kali Anda dapat membuat kesalahan dengan gejala yang sangat aneh.  Karena alasan itulah kami mencari penerjemah. </p><br><p>  Idenya adalah kita membagi kode komposisi kita menjadi 2 bagian: pohon eksekusi dan juru bahasa untuk pohon itu.  Setiap node di pohon ini adalah tempat untuk fungsi dengan efek yang ingin kita suntikkan, seperti <code>getUserFromDatabase</code> .  Node-node tersebut didefinisikan berdasarkan nama, mis. <code>getCard</code> , tipe parameter input, mis. <code>CardNumber</code> dan tipe return, mis. <code>Card option</code> .  Kami tidak menentukan di sini <code>Task</code> atau <code>Async</code> , itu bukan bagian dari pohon, <em>itu adalah bagian dari juru bahasa</em> .  Setiap tepi pohon ini adalah serangkaian transformasi murni, seperti eksekusi validasi atau fungsi logika bisnis.  Tepi juga memiliki beberapa input, misalnya nomor kartu string mentah, kemudian ada validasi, yang dapat memberi kita kesalahan atau nomor kartu yang valid.  Jika ada kesalahan, kita akan memotong tepi itu, jika tidak, itu akan membawa kita ke simpul berikutnya: <code>getCard</code> .  Jika simpul ini akan mengembalikan <code>Some card</code> , kita dapat melanjutkan ke tepi berikutnya, yang akan menjadi aktivasi, dan seterusnya. </p><br><p>  Untuk setiap skenario seperti <code>topUp</code> atau <code>topUp</code> atau <code>topUp</code> kita akan membangun pohon terpisah.  Ketika pohon-pohon itu dibangun, simpul mereka agak kosong, mereka tidak memiliki fungsi nyata di dalamnya, <em>mereka memiliki tempat</em> untuk fungsi-fungsi itu.  Tujuan penerjemah adalah mengisi simpul-simpul itu, sesederhana itu.  Penerjemah tahu efek yang kita gunakan, mis. <code>Task</code> , dan ia tahu fungsi mana yang sebenarnya dimasukkan ke dalam simpul yang diberikan.  Ketika mengunjungi sebuah node, ia mengeksekusi fungsi nyata yang sesuai, menunggu dalam kasus <code>Task</code> atau <code>Async</code> , dan meneruskan hasilnya ke tepi berikutnya.  Tepi itu dapat mengarah ke simpul lain, dan kemudian itu adalah pekerjaan untuk penerjemah lagi, sampai penerjemah ini mencapai titik berhenti, bagian bawah rekursi kita, di mana kita hanya mengembalikan hasil dari seluruh eksekusi pohon kita. </p><br><p>  Seluruh pohon akan diwakili dengan serikat terdiskriminasi, dan sebuah simpul akan terlihat seperti ini: </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'a&gt; = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- &lt;- THE NODE | ... //-- ANOTHER NODE</span></span></span></span></code> </pre> <br><p>  Itu akan selalu menjadi tuple, di mana elemen pertama adalah input untuk ketergantungan Anda, dan elemen terakhir adalah <em>fungsi</em> , yang menerima hasil dari dependensi itu.  "Ruang" antara elemen-elemen tuple adalah tempat ketergantungan Anda akan cocok, seperti dalam contoh komposisi, di mana Anda memiliki fungsi <code>'a -&gt; 'b</code> , <code>'c -&gt; 'd</code> dan Anda perlu meletakkan yang lain <code>'b -&gt; 'c</code> di antara untuk menghubungkan mereka. </p><br><p>  Karena kita berada di dalam konteks terbatas kita, kita seharusnya tidak memiliki terlalu banyak dependensi, dan jika kita lakukan - mungkin inilah saatnya untuk membagi konteks kita menjadi yang lebih kecil. </p><br><p>  Begini tampilannya, sumber lengkap ada di <a href="">sini</a> : </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'a&gt; = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * ((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">) option -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'a&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> of (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">) * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> of (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DateTimeOffset</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DateTimeOffset</span></span></span><span class="hljs-class">) * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceOperation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceOperation</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> of 'a (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- This bind function allows you to pass a continuation for current node of your expression tree the code is basically a boiler plate, as you can see. -}</span></span></span><span class="hljs-class">*) let rec bind f instruction = match instruction with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> x -&gt; fx (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- This is a set of basic functions. Use them in your expression tree builder to represent dependency call -}</span></span></span><span class="hljs-class">*) let stop x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> x let getCardByNumber number = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let getCardWithAccountInfo number = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let createNewCard (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">), stop) let replaceCard card = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let getUserById id = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let createNewUser user = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let getBalanceOperations (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fromDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toDate</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fromDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toDate</span></span></span><span class="hljs-class">), stop) let saveBalanceOperation op = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> With a help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">computation expressions</a> , we now have a very easy way to build our workflows without having to care about implementation of real-world interactions. We do that in <a href="">CardWorkflow module</a> : </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- `program` is the name of our computation expression. In every `let!` binding we unwrap the result of operation, which can be either `Program&lt;'a&gt;` or `Program&lt;Result&lt;'a, Error&gt;&gt;`. What we unwrap would be of type 'a. If, however, an operation returns `Error`, we stop the execution at this very step and return it. The only thing we have to take care of is making sure that type of error is the same in every operation we call -}</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> processPayment (currentDate: <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span>, payment) = program { (*<span class="hljs-comment"><span class="hljs-comment">{- You can see these `expectValidationError` and `expectDataRelatedErrors` functions here. What they do is map different errors into `Error` type, since every execution branch must return the same type, in this case `Result&lt;'a, Error&gt;`. They also help you quickly understand what's going on in every line of code: validation, logic or calling external storage. -}</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! cmd = validateProcessPaymentCommand payment |&gt; expectValidationError <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! card = tryGetCard cmd.<span class="hljs-type"><span class="hljs-type">CardNumber</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> today = currentDate.<span class="hljs-type"><span class="hljs-type">Date</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tomorrow = currentDate.<span class="hljs-type"><span class="hljs-type">Date</span></span>.<span class="hljs-type"><span class="hljs-type">AddDays</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! operations = getBalanceOperations (cmd.<span class="hljs-type"><span class="hljs-type">CardNumber</span></span>, today, tomorrow) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spentToday = <span class="hljs-type"><span class="hljs-type">BalanceOperation</span></span>.spentAtDate currentDate cmd.<span class="hljs-type"><span class="hljs-type">CardNumber</span></span> operations <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! (card, op) = <span class="hljs-type"><span class="hljs-type">CardActions</span></span>.processPayment currentDate spentToday card cmd.<span class="hljs-type"><span class="hljs-type">PaymentAmount</span></span> |&gt; expectOperationNotAllowedError <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>! saveBalanceOperation op |&gt; expectDataRelatedErrorProgram <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>! replaceCard card |&gt; expectDataRelatedErrorProgram return card |&gt; toCardInfoModel |&gt; <span class="hljs-type"><span class="hljs-type">Ok</span></span> }</code> </pre> <br><p> This module is the last thing we need to implement in business layer. Also, I've done some refactoring: I moved errors and common types to <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Common project</a> . About time we moved on to implementing data access layer. </p><br><h3 id="data-access-layer"> Data access layer </h3><br><p> The design of entities in this layer may depend on our database or framework we use to interact with it. Therefore domain layer doesn't know anything about these entities, which means we have to take care of mapping to and from domain models in here. Which is quite convenient for consumers of our DAL API. For this application I've chosen MongoDB, not because it's a best choice for this kind of task, but because there're many examples of using SQL DBs already and I wanted to add something different. We are gonna use C# driver. </p><br><p> For the most part it's gonna be pretty strait forward, the only tricky moment is with <code>Card</code> . When it's active it has an <code>AccountInfo</code> inside, when it's not it doesn't. So we have to split it in two documents: <code>CardEntity</code> and <code>CardAccountInfoEntity</code> , so that deactivating card doesn't erase information about balance and daily limit. </p><br><p> Other than that we just gonna use primitive types instead of discriminated unions and types with built-in validation. </p><br><p> There're also few things we need to take care of, since we are using C# library: </p><br><ul><li> Convert <code>null</code> s to <code>Option&lt;'a&gt;</code> </li><li> Catch expected exceptions and convert them to our errors and wrap it in <code>Result&lt;_,_&gt;</code> </li></ul><br><p> We start with <a href="">CardDomainEntities module</a> , where we define our entities: </p><br><pre> <code class="haskell hljs"> [&lt;<span class="hljs-type"><span class="hljs-type">CLIMutable</span></span>&gt;] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardEntity</span></span></span><span class="hljs-class"> = { [&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BsonId</span></span></span><span class="hljs-class">&gt;] </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsActive</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationMonth</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint16</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationYear</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint16</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> } with //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- we're gonna need this in every entity for error messages member this.EntityId = this.CardNumber.ToString() (*{- we use this Id comparer quotation (F# alternative to C# Expression) for updating entity by id, since for different entities identifier has different name and type -}*) member this.IdComparer = &lt;@ System.Func&lt;_,_&gt; (fun c -&gt; c.CardNumber = this.CardNumber) @&gt;</span></span></span></span></code> </pre> <br><p> Those fields <code>EntityId</code> and <code>IdComparer</code> we are gonna use with a help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SRTP</a> . We'll define functions that will retrieve them from any type that has those fields define, without forcing every entity to implement some interface: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline (|<span class="hljs-type"><span class="hljs-type">HasEntityId</span></span>|) x = fun () -&gt; (^a : (member <span class="hljs-type"><span class="hljs-type">EntityId</span></span>: string) x) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline entityId (<span class="hljs-type"><span class="hljs-type">HasEntityId</span></span> f) = f() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline (|<span class="hljs-type"><span class="hljs-type">HasIdComparer</span></span>|) x = fun () -&gt; (^a : (member <span class="hljs-type"><span class="hljs-type">IdComparer</span></span>: <span class="hljs-type"><span class="hljs-type">Quotations</span></span>.<span class="hljs-type"><span class="hljs-type">Expr</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Func</span></span>&lt; ^a, bool&gt;&gt;) x) //<span class="hljs-comment"><span class="hljs-comment">-- We need to convert F# quotations to C# expressions //-- which C# mongo db driver understands. let inline idComparer (HasIdComparer id) = id() |&gt; LeafExpressionConverter.QuotationToExpression |&gt; unbox&lt;Expression&lt;Func&lt;_,_&gt;&gt;&gt;</span></span></code> </pre> <br><p> As for <code>null</code> and <code>Option</code> thing, since we use record types, F# compiler doesn't allow using <code>null</code> value, neither for assigning nor for comparison. At the same time record types are just another CLR types, so technically we can and will get a <code>null</code> value, thanks to C# and design of this library. We can solve this in 2 ways: use <code>AllowNullLiteral</code> attribute, or use <code>Unchecked.defaultof&lt;'a&gt;</code> . I went for the second choice since this <code>null</code> situation should be localized as much as possible: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isNullUnsafe (arg: 'a when 'a: not struct) = arg = <span class="hljs-type"><span class="hljs-type">Unchecked</span></span>.defaultof&lt;'a&gt; //<span class="hljs-comment"><span class="hljs-comment">-- then we have this function to convert nulls to option, //-- therefore we limited this toxic null thing in here. let unsafeNullToOption a = if isNullUnsafe a then None else Some a</span></span></code> </pre> <br><p> In order to deal with expected exception for duplicate key, we use Active Patterns again: </p><br><pre> <code class="haskell hljs"> //<span class="hljs-comment"><span class="hljs-comment">-- First we define a function which checks, whether exception is about duplicate key let private isDuplicateKeyException (ex: Exception) = ex :? MongoWriteException &amp;&amp; (ex :?&gt; MongoWriteException).WriteError.Category = ServerErrorCategory.DuplicateKey //-- Then we have to check wrapping exceptions for this let rec private (|DuplicateKey|_|) (ex: Exception) = match ex with | :? MongoWriteException as ex when isDuplicateKeyException ex -&gt; Some ex | :? MongoBulkWriteException as bex when bex.InnerException |&gt; isDuplicateKeyException -&gt; Some (bex.InnerException :?&gt; MongoWriteException) | :? AggregateException as aex when aex.InnerException |&gt; isDuplicateKeyException -&gt; Some (aex.InnerException :?&gt; MongoWriteException) | _ -&gt; None //-- And here's the usage: let inline private executeInsertAsync (func: 'a -&gt; Async&lt;unit&gt;) arg = async { try do! func(arg) return Ok () with | DuplicateKey ex -&gt; return EntityAlreadyExists (arg.GetType().Name, (entityId arg)) |&gt; Error }</span></span></code> </pre> <br><p> After mapping is implemented we have everything we need to assemble <a href="">API for our data access layer</a> , which looks like this: </p><br><pre> <code class="haskell hljs"> //<span class="hljs-comment"><span class="hljs-comment">-- `MongoDb` is a type alias for `IMongoDatabase` let replaceUserAsync (mongoDb: MongoDb) : ReplaceUserAsync = fun user -&gt; user |&gt; DomainToEntityMapping.mapUserToEntity |&gt; CommandRepository.replaceUserAsync mongoDb let getUserInfoAsync (mongoDb: MongoDb) : GetUserInfoAsync = fun userId -&gt; async { let! userInfo = QueryRepository.getUserInfoAsync mongoDb userId return userInfo |&gt; Option.map EntityToDomainMapping.mapUserInfoEntity }</span></span></code> </pre> <br><p> The last moment I mention is when we do mapping <code>Entity -&gt; Domain</code> , we have to instantiate types with built-in validation, so there can be validation errors. In this case we won't use <code>Result&lt;_,_&gt;</code> because if we've got invalid data in DB, it's a bug, not something we expect. So we just throw an exception. Other than that nothing really interesting is happening in here. The full source code of data access layer you'll find <a href="">here</a> . </p><br><h3 id="composition-logging-and-all-the-rest"> Composition, logging and all the rest </h3><br><p> As you remember, we're not gonna use DI framework, we went for interpreter pattern. If you want to know why, here's some reasons: </p><br><ul><li> IoC container operates in runtime. So until you run your program you can't know that all the dependencies are satisfied. </li><li> It's a powerful tool which is very easy to abuse: you can do property injection, use lazy dependencies, and sometimes even some business logic can find it's way in dependency registering/resolving (yeah, I've witnessed it). All of that makes code maintaining extremely hard. </li></ul><br><p> That means we need a place for that functionality. We could place it on a top level in our Web Api, but in my opinion it's not a best choice: right now we are dealing with only 1 bounded context, but if there's more, this global place with all the interpreters for each context will become cumbersome. Besides, there's single responsibility rule, and web api project should be responsible for web, right? So we create <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CardManagement.Infrastructure project</a> . </p><br><p> Here we will do several things: </p><br><ul><li> Composing our functionality </li><li> App configuration </li><li> Logging </li></ul><br><p> If we had more than 1 context, app configuration and log configuration should be moved to global infrastructure project, and the only thing happening in this project would be assembling API for our bounded context, but in our case this separation is not necessary. </p><br><p> Let's get down to composition. We've built execution trees in our domain layer, now we have to interpret them. Every node in that tree represents some dependency call, in our case a call to database. If we had a need to interact with 3rd party api, that would be in here also. So our interpreter has to know how to handle every node in that tree, which is verified in compile time, thanks to <code>&lt;TreatWarningsAsErrors&gt;</code> setting. Here's what it looks like: </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- Those `bindAsync (next &gt;&gt; interpretCardProgram mongoDb)` work pretty simple: we execute async function to the left of this expression, await that operation and pass the result to the next node, after which we interpret that node as well, until we reach the bottom of this recursion: `Stop a` node. -}</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> private interpretCardProgram mongoDb prog = match prog with | <span class="hljs-type"><span class="hljs-type">GetCard</span></span> (cardNumber, next) -&gt; cardNumber |&gt; getCardAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">GetCardWithAccountInfo</span></span> (number, next) -&gt; number |&gt; getCardWithAccInfoAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">CreateCard</span></span> ((card,acc), next) -&gt; (card, acc) |&gt; createCardAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">ReplaceCard</span></span> (card, next) -&gt; card |&gt; replaceCardAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">GetUser</span></span> (id, next) -&gt; getUserAsync mongoDb id |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">CreateUser</span></span> (user, next) -&gt; user |&gt; createUserAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">GetBalanceOperations</span></span> (request, next) -&gt; getBalanceOperationsAsync mongoDb request |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">SaveBalanceOperation</span></span> (op, next) -&gt; saveBalanceOperationAsync mongoDb op |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">Stop</span></span> a -&gt; async.<span class="hljs-type"><span class="hljs-type">Return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interpret prog = try <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interpret = interpretCardProgram (getMongoDb()) interpret prog with | failure -&gt; <span class="hljs-type"><span class="hljs-type">Bug</span></span> failure |&gt; <span class="hljs-type"><span class="hljs-type">Error</span></span> |&gt; async.<span class="hljs-type"><span class="hljs-type">Return</span></span></code> </pre> <br><p> Note that this interpreter is the place where we have this <code>async</code> thing. We can do another interpreter with <code>Task</code> or just a plain sync version of it. Now you're probably wondering, how we can cover this with unit-test, since familiar mock libraries ain't gonna help us. Well, it's easy: you have to make another interpreter. Here's what it can look like: </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;unit, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TestInterpreterConfig</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class">: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceOperation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> } let defaultConfig = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accountInfo</span></span></span><span class="hljs-class">) |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">balanceOperations</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() } let testInject a = fun _ -&gt; a let rec interpretCardProgram config (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prog</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) = match prog with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cardNumber</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; cardNumber |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; number |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">), next) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">) |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; card |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; id |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; user |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> request |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> op |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> a -&gt; a</span></span></code> </pre> <br><p> We've created <code>TestInterpreterConfig</code> which holds desired results of every operation we want to inject. You can easily change that config for every given test and then just run interpreter. This interpreter is sync, since there's no reason to bother with <code>Task</code> or <code>Async</code> . </p><br><p> There's nothing really tricky about the logging, but you can find it in <a href="">this module</a> . The approach is that we wrap the function in logging: we log function name, parameters and log result. If result is ok, it's info, if error it's a warning and if it's a <code>Bug</code> then it's an error. That's pretty much it. </p><br><p> One last thing is to make a facade, since we don't want to expose raw interpreter calls. Here's the whole thing: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> createUser arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.createUser &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.createUser"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> createCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.createCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.createCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activateCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.activateCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.activateCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> deactivateCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.deactivateCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.deactivateCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> processPayment arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.processPayment &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.processPayment"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topUp arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.topUp &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.topUp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> setDailyLimit arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.setDailyLimit &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.setDailyLimit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> getCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.getCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.getCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> getUser arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.getUser &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpretSimple |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.getUser"</span></span>)</code> </pre> <br><p> All the dependencies here are injected, logging is taken care of, no exceptions is thrown â€” that's it. For web api I used <a href="">Giraffe</a> framework. Web project is <a href="">here</a> . </p><br><h2 id="conclusion">  Kesimpulan </h2><br><p> We have built an application with validation, error handling, logging, business logic â€” all those things you usually have in your application. The difference is this code is way more durable and easy to refactor. Note that we haven't used reflection or code generation, no exceptions, but still our code isn't verbose. It's easy to read, easy to understand and hard to break. As soon as you add another field in your model, or another case in one of our union types, the code won't compile until you update every usage. Sure it doesn't mean you're totally safe or that you don't need any kind of testing at all, it just means that you're gonna have fewer problems when you develope new features or do some refactoring. The development process will be both cheaper and more interesting, because this tool allows you to focus on your domain and business tasks, instead of drugging focus on keeping an eye out that nothing is broken. </p><br><p> Another thing: I don't claim that OOP is completely useless and we don't need it, that's not true. I'm saying that we don't need it for solving <em>every single task</em> we have, and that a big portion of our tasks can be better solved with FP. And truth is, as always, in balance: we can't solve everything efficiently with only one tool, so a good programming language should have a decent support of both FP and OOP. And, unfortunately, a lot of most popular languages today have only lambdas and async programming from functional world. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458730/">https://habr.com/ru/post/id458730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458718/index.html">Wawancara besar dengan Cliff Click, bapak kompilasi JIT di Jawa</a></li>
<li><a href="../id458720/index.html">Sekolah programmer hh.ru untuk ke-10 kalinya membuka serangkaian spesialis IT</a></li>
<li><a href="../id458724/index.html">Jaringan saraf dan pembelajaran mendalam, bab 3, bagian 1: meningkatkan cara jaringan saraf dilatih</a></li>
<li><a href="../id458726/index.html">Habr Special // Podcast dengan penulis Invasion. Sejarah Singkat Peretas Rusia</a></li>
<li><a href="../id458728/index.html">Apa itu sepeda listrik (tinjauan kelompok dari lima model dari dua pabrikan), bagian 2</a></li>
<li><a href="../id458732/index.html">SIG? atau non-GIS? Itu pertanyaannya</a></li>
<li><a href="../id458734/index.html">Hari kerja pusat data: hal sepele yang tidak terlihat selama 7 tahun beroperasi. Dan kelanjutan tentang tikus</a></li>
<li><a href="../id458738/index.html">Materi dan antimateri: apa itu, apa bedanya dan apa yang harus dilakukan oleh neutrino dengannya</a></li>
<li><a href="../id458740/index.html">Dan Tuhan memerintahkan: "Wawancarai dan terima tawarannya"</a></li>
<li><a href="../id458742/index.html">Kirill Tolkachev dan Maxim Gorelikov tentang Boot Musim Semi di jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>