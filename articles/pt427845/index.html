<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèª ü¶à üç£ Como encaixar um milh√£o de estrelas em um iPhone ‚òïÔ∏è ‚ñ´Ô∏è üññüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma coisa rom√¢ntica como um c√©u estrelado e uma coisa t√£o grave como otimizar o consumo de mem√≥ria por um aplicativo iOS podem muito bem andar juntos:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como encaixar um milh√£o de estrelas em um iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/427845/"><img src="https://habrastorage.org/webt/q7/xz/3_/q7xz3_mzwjft238rwmzhjpbnwqm.jpeg"><br><br>  Uma coisa rom√¢ntica como um c√©u estrelado e uma coisa t√£o grave como otimizar o consumo de mem√≥ria por um aplicativo iOS podem muito bem andar juntos: vale a pena tentar colocar esse c√©u estrelado em um aplicativo de recupera√ß√£o de direitos autorais, e a pergunta sobre o mesmo consumo surgir√° imediatamente. <br><br>  Minimizar o uso da mem√≥ria ser√° √∫til em muitos outros casos.  Portanto, este texto no exemplo de um projeto pequeno mostra m√©todos de otimiza√ß√£o que podem ser √∫teis em aplicativos iOS completamente diferentes (e n√£o apenas no iOS). <br><a name="habracut"></a><br>  A publica√ß√£o foi preparada com base em uma transcri√ß√£o <b>do</b> relat√≥rio de <b>Conrad Filer da</b> confer√™ncia Mobius 2018 Piter.  Anexamos o v√≠deo e, em seguida, uma vers√£o em texto na primeira pessoa: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/51PJjrh9yTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Fico feliz em receber todos!  Meu nome √© Conrad Filer e, com o nome espetacular de "Um milh√£o de estrelas em um iPhone", discutiremos como voc√™ pode minimizar o tamanho da mem√≥ria ocupada pelo seu aplicativo iOS.  Colorido e em exemplos. <br><br><h2>  Por que otimizar? </h2><br>  O que geralmente nos encoraja a fazer otimiza√ß√£o, o que exatamente gostar√≠amos de alcan√ßar?  N√≥s n√£o queremos isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54b/0ef/fbf/54b0effbffa93a27e65a50000242046d.gif"></div><br><br>  N√£o queremos que o usu√°rio espere.  Ou seja, o primeiro motivo √© <b>reduzir o tempo de inicializa√ß√£o</b> . <br><br>  Outra raz√£o √© <b>melhorar a qualidade</b> . <br><br><img src="https://habrastorage.org/webt/dj/6i/0w/dj6i0wxgzgv87xkdvnkiy6ddy48.jpeg"><br><br>  Podemos falar sobre a qualidade das imagens, som e at√© AI.  ‚ÄúIA otimizada‚Äù significa que voc√™ pode conseguir mais - por exemplo, calcule o jogo para um n√∫mero maior de movimentos adiante. <br><br>  A terceira raz√£o √© muito importante: <b>economizando energia da bateria</b> .  A otimiza√ß√£o ajuda a drenar menos a bateria.  Aqui est√° uma compara√ß√£o interessante, embora do mundo Android.  Aqui, comparamos o Vulkan e o OpenGL ES: <br><br><img src="https://habrastorage.org/webt/9n/ni/dx/9nnidxssdqtw_t2ibkdatsaapfm.jpeg"><br><br>  O segundo √© pior otimizado para plataformas m√≥veis.  Observando a velocidade do consumo de energia da bateria, voc√™ pode ver que, para uma imagem semelhante, o OpenGL ES gastou muito mais recursos que o Vulkan. <br><br>  Que tipo de otimiza√ß√£o pode ajudar aqui?  Por exemplo, em um jogo baseado em turnos, quando o usu√°rio pensa em sua jogada, voc√™ pode reduzir o FPS a zero.  Se voc√™ possui um mecanismo 3D, √© totalmente sensato desligar tudo enquanto o usu√°rio apenas olha para a tela. <br><br>  Al√©m disso, h√° momentos em que, sem uma abordagem otimizada, voc√™ n√£o poder√° implementar um ou outro recurso avan√ßado: ele simplesmente n√£o ser√° puxado. <br><br><h2>  Sem fanatismo </h2><br>  Falando sobre otimiza√ß√£o, n√£o podemos deixar de lembrar a tese de Donald Knuth: ‚ÄúDevemos esquecer a baixa efici√™ncia, digamos, em 97% dos casos: a otimiza√ß√£o prematura √© a raiz de todos os males.  Embora n√£o devamos desistir de nossas capacidades nesses 3% cr√≠ticos ". <br><br>  Em 97% dos casos, n√£o devemos nos preocupar com efici√™ncia, mas antes de tudo sobre como tornar nosso c√≥digo compreens√≠vel, seguro e test√°vel.  Ainda estamos desenvolvendo para dispositivos m√≥veis, e n√£o para naves espaciais.  As empresas em que trabalhamos n√£o devem pagar a mais pelo suporte ao c√≥digo que escrevemos.  Al√©m disso, o tempo de trabalho do desenvolvedor tem um custo e, se voc√™ o gasta na otimiza√ß√£o de algo n√£o essencial, gasta o dinheiro da empresa.  Bem, o fato de que c√≥digo bem otimizado tende a ser mais dif√≠cil de entender, voc√™ pode ver os exemplos que mostrarei hoje. <br><br>  Em geral, priorize e otimize significativamente, conforme necess√°rio. <br><br><h2>  As abordagens </h2><br>  Ao trabalhar na otimiza√ß√£o, geralmente monitoramos o desempenho (leitura: carga do processador) ou a quantidade de mem√≥ria usada.  Freq√ºentemente, essas duas op√ß√µes entram em conflito e voc√™ precisa encontrar um equil√≠brio entre elas. <br><br>  No caso do processador, podemos reduzir o n√∫mero de ciclos do processador exigidos por nossas opera√ß√µes.  Como voc√™ sabe, menos ciclos do processador nos proporcionam menos tempo de carregamento, menos consumo de bateria, capacidade de fornecer melhor qualidade etc. <br><br>  Para desenvolvedores de iOS, o Xcode Instruments possui uma ferramenta √∫til, o Time Profiler.  Ele permite que voc√™ acompanhe o n√∫mero de ciclos da CPU gastos por diferentes partes do seu aplicativo.  Este relat√≥rio n√£o √© sobre ferramentas, por isso n√£o vou entrar em detalhes agora, houve um bom v√≠deo da WWDC sobre isso. <br><br>  Voc√™ pode escolher outro objetivo - otimiza√ß√£o em prol da mem√≥ria.  Vamos tentar garantir que, na inicializa√ß√£o, nosso aplicativo se encaixe no menor n√∫mero poss√≠vel de c√©lulas RAM.  Lembre-se de que as aplica√ß√µes mais volumosas s√£o os primeiros candidatos a um desligamento for√ßado durante a limpeza, que o sistema operacional √© for√ßado a executar.  Portanto, isso afeta por quanto tempo seu aplicativo permanece em segundo plano. <br><br>  Tamb√©m √© importante que o recurso de RAM para dispositivos diferentes tamb√©m seja diferente.  Se voc√™, por exemplo, decidiu desenvolver para o Apple Watch, n√£o h√° mem√≥ria suficiente e isso tamb√©m o otimiza. <br><br>  Finalmente, √†s vezes, uma pequena quantidade de mem√≥ria tamb√©m torna o programa muito r√°pido.  Eu darei um exemplo  Aqui est√£o as estruturas de v√°rios tamanhos em bytes: <br><br><img src="https://habrastorage.org/webt/mg/2c/_2/mg2c_2se8rpo_gwwnqlfbcaf2ks.jpeg"><br><br>  Element8 cont√©m 8 bytes, Element16-16, e assim por diante. <br><br><img src="https://habrastorage.org/webt/ot/hq/l3/othql3uj6cujllgs99m_ypmkok8.jpeg"><br><br>  Criaremos matrizes, uma para cada um dos nossos tipos de estruturas.  A dimens√£o de todas as matrizes √© a mesma - 10.000 elementos.  Cada estrutura cont√©m um n√∫mero diferente de campos (crescente);  o campo n √© o primeiro e, portanto, est√° presente em todas as estruturas. <br><br>  Agora vamos tentar o seguinte: para cada matriz, calcularemos a soma de todos os seus campos n.  Ou seja, cada vez que somarmos o mesmo n√∫mero de elementos (10.000 pe√ßas).  A √∫nica diferen√ßa √© que, para cada soma, a vari√°vel n ser√° extra√≠da de estruturas de tamanhos diferentes.  Estamos interessados ‚Äã‚Äãem saber se o somat√≥rio leva o mesmo tempo. <br><br>  O resultado √© o seguinte: <br><br><img src="https://habrastorage.org/webt/el/mu/k1/elmuk1tm_yaku9exe4xgbaw8gp4.jpeg"><br><br>  O gr√°fico mostra a depend√™ncia do tempo de soma no tamanho da estrutura usada na matriz.  Acontece que obter o campo n de uma estrutura maior √© mais longo e, portanto, a opera√ß√£o de soma leva mais tempo. <br>  Muitos de voc√™s j√° entenderam por que isso est√° acontecendo. <br><br>  O processador possui caches L1, L2 (√†s vezes at√© L3 e L4).  O processador acessa esse tipo de mem√≥ria direta e rapidamente. <br><br><img src="https://habrastorage.org/webt/u1/yy/r9/u1yyr9z2pxbwcffecy8i_xoa5qq.jpeg"><br><br>  Existem caches para acelerar a reutiliza√ß√£o de dados.  Suponha que estamos trabalhando com matrizes.  Se a matriz necess√°ria para o processador j√° estiver presente em qualquer um dos caches, ela j√° foi solicitada anteriormente pelo processador.  Naquele momento, ele os solicitou da mem√≥ria principal, colocou-os no cache, executou todas as opera√ß√µes necess√°rias com eles, ap√≥s o que esses dados permaneceram em repouso (n√£o tiveram tempo de serem apagados por outros). <br><br><img src="https://habrastorage.org/webt/qt/cd/om/qtcdomuam8uo4cz2tnkevtmvxuk.jpeg"><br><br>  Os tamanhos dos caches L1, L2 n√£o s√£o t√£o grandes.  A matriz necess√°ria para o processador funcionar pode ser maior.  Para executar totalmente a opera√ß√£o em uma matriz desse tipo, teremos que descarreg√°-la no cache em partes e operar essas partes uma a uma.  Devido a constantes solicita√ß√µes √† mem√≥ria principal, o processamento de nossa matriz levar√° muito mais tempo. <br><br>  Ao programar estruturas de dados, tente manter os caches em mente.  √â poss√≠vel que, ao reduzir o tamanho da sua estrutura de dados, voc√™ atinja a capacidade de cache bem-sucedida e acelere as opera√ß√µes que ser√£o executadas no futuro.  A intera√ß√£o com a mem√≥ria principal sempre foi, √© e provavelmente continuar√° sendo um fator significativo de produtividade - mesmo quando voc√™ escreve no Swift para dispositivos modernos de alto desempenho. <br><br><h2>  CPU vs RAM: inicializa√ß√£o lenta </h2><br>  Embora em alguns casos, quando a mem√≥ria usada seja reduzida, o programa comece a funcionar mais rapidamente, h√° casos em que essas duas m√©tricas, pelo contr√°rio, entram em conflito.  Vou dar um exemplo com o conceito de inicializa√ß√£o lenta. <br><br>  Suponha que tenhamos um m√©todo makeHeavyObject () que retorna algum objeto grande.  Este m√©todo inicializar√° a vari√°vel lazilyCalculated. <br><br><img src="https://habrastorage.org/webt/-y/2v/4l/-y2v4lzluwid2sxmelau-qp9yiu.jpeg"><br><br>  O modificador lento define a vari√°vel lazilyCalculated como inicializa√ß√£o lenta.  Isso significa que um valor ser√° atribu√≠do a ele somente quando a primeira chamada ocorrer durante a execu√ß√£o.  √â ent√£o que o m√©todo makeHeavyObject () funcionar√° e o objeto resultante ser√° atribu√≠do √† vari√°vel lazilyCalculated. <br><br>  Qual √© a vantagem aqui?  A partir do momento da inicializa√ß√£o (ainda que mais tarde, mas ser√° executado), temos um objeto localizado na mem√≥ria.  Seu valor √© contado, est√° pronto para uso - basta fazer uma solicita√ß√£o.  Outra coisa √© que nosso objeto √© grande e, a partir do momento da inicializa√ß√£o, ocupar√° na mem√≥ria a maior parte das c√©lulas. <br><br>  Voc√™ pode seguir o outro caminho - n√£o armazene o valor do campo: <br><br><img src="https://habrastorage.org/webt/rd/dj/td/rddjtdebqiiyidg1vravbwzreli.jpeg"><br><br>  Com todos os links para o campo lazilyCalculated, o m√©todo makeHeavyObject () ser√° executado novamente.  O valor ser√° retornado ao ponto de consulta, enquanto n√£o ser√° colocado na mem√≥ria.  Como voc√™ pode ver, o armazenamento de uma vari√°vel √© opcional. <br><br>  O que √© mais caro - armazenar um objeto grande na mem√≥ria, mas n√£o perder tempo na CPU, ou chamar o m√©todo toda vez que precisarmos do nosso campo, economizando mem√≥ria?  Voc√™ deve ter um valor pronto em m√£os ou calcul√°-lo em tempo real?  Esse tipo de dilema surge com frequ√™ncia, onde quer que voc√™ fa√ßa seus c√°lculos - em um servidor remoto ou em sua m√°quina local, independentemente do cache com o qual voc√™ tenha que trabalhar.  Voc√™ precisa tomar uma decis√£o com base nas limita√ß√µes do sistema nesse caso espec√≠fico. <br><br><h2>  Ciclo de otimiza√ß√£o </h2><br><br><img src="https://habrastorage.org/webt/3y/jb/tz/3yjbtzvba5c5cmvdmyxws4ubev8.jpeg"><br><br>  Tudo o que voc√™ otimizar, seu trabalho, em regra, ser√° constru√≠do no mesmo algoritmo.  Primeiro, voc√™ examina o c√≥digo, perfil / medida (no Xcode usando as ferramentas apropriadas), tentando identificar seus gargalos.  Essencialmente, organize os m√©todos por quanto tempo eles levam para serem executados.  E, em seguida, observe as linhas principais para determinar o que otimizar. <br><br>  Ao escolher um objeto, voc√™ define a tarefa (ou, falando cientificamente, prop√µe uma hip√≥tese): aplicando esses ou outros m√©todos de otimiza√ß√£o, voc√™ pode fazer o c√≥digo selecionado trabalhar mais r√°pido. <br><br>  Em seguida, voc√™ tenta otimizar.  Ap√≥s cada modifica√ß√£o, voc√™ analisa os indicadores de desempenho, avaliando a efic√°cia da modifica√ß√£o e o quanto conseguiu avan√ßar. <br><br>  Assim como em um trabalho cient√≠fico: especula√ß√£o, experimento, an√°lise de resultados.  Voc√™ passa por esse ciclo de a√ß√µes repetidamente.  A pr√°tica mostra que o trabalho constru√≠do dessa maneira realmente permite eliminar os botneks um por um. <br><br><h2>  Testes unit√°rios </h2><br><br><img src="https://habrastorage.org/webt/yp/c3/zl/ypc3zlrxtbnbkp9cwekladdj-ug.jpeg"><br><br>  Resumidamente sobre testes de unidade: temos algumas fun√ß√µes que estamos testando, algumas entradas de dados de entrada e sa√≠da de dados de sa√≠da;  recebendo entrada como entrada, nossa fun√ß√£o sempre deve retornar a sa√≠da e nenhuma de nossas otimiza√ß√µes deve violar essa propriedade. <br><br>  Os testes de unidade nos ajudam a rastrear o colapso.  Se, em resposta √† entrada, nossa fun√ß√£o parou de retornar a sa√≠da, ent√£o, direta ou indiretamente, alteramos o curso antigo do trabalho de nossa fun√ß√£o. <br><br>  Nem tente iniciar a otimiza√ß√£o se voc√™ n√£o tiver escrito uma parte generosa dos testes de unidade no seu c√≥digo.  Voc√™ deve poder fazer o teste de regress√£o.  Se voc√™ olhar no GitHub my commits no meu exemplo de aplica√ß√£o, para o qual continuarei, voc√™ pode ver que algumas das minhas otimiza√ß√µes trouxeram bugs. <br><br>  E agora a parte divertida, vamos para as estrelas. <br><br><h2>  Milh√µes de estrelas </h2><br>  H√° um grande (enorme) banco de dados descrevendo um milh√£o de estrelas.  Al√©m disso, criei v√°rios aplicativos.  Um deles usa a realidade aumentada, em tempo real, desenhando estrelas em cima da imagem da c√¢mera do telefone.  Agora vou demonstr√°-lo em a√ß√£o: <br><br><img src="https://habrastorage.org/webt/cr/rs/jv/crrsjv1iezyd2hzyxdxpjricu0u.png"><br><br>  Na aus√™ncia de luzes da cidade, uma pessoa pode distinguir at√© 8.000 estrelas no c√©u.  Eu precisaria de 1,8 MB para armazenar 8.000 registros.  Em princ√≠pio, aceit√°vel.  Mas eu queria adicionar aquelas estrelas que uma pessoa pode ver atrav√©s de um telesc√≥pio - resultaram em cerca de 120.000 estrelas (de acordo com o chamado cat√°logo de Hipparcos, agora obsoleto).  Isso j√° requer 27 MB.  E entre os cat√°logos modernos de dom√≠nio p√∫blico, voc√™ pode encontrar um que contar√° com cerca de 2.500.000 estrelas.  Esse banco de dados j√° ocuparia cerca de 560 MB.  Como voc√™ pode ver, muita mem√≥ria j√° √© necess√°ria.  Mas n√£o queremos apenas um banco de dados, mas um aplicativo baseado nele, onde haver√° ARKit, SceneKit e outras coisas que tamb√©m exigem mem√≥ria. <br><br>  O que fazer? <br>  Vamos otimizar as estrelas. <br><br><h2>  Ferramenta MemoryLayout </h2><br>  Voc√™ pode avaliar o tamanho do programa como um todo.  Mas, para trabalhos de joalheria, como otimiza√ß√£o, voc√™ precisar√° de ferramentas para estimar o tamanho de cada estrutura de dados individual. <br><br>  Swift permite que voc√™ fa√ßa isso de maneira simples - usando objetos MemoryLayout &lt;&gt;.  Voc√™ declara um MemoryLayout &lt;&gt;, especificando a estrutura de dados de seu interesse como o tipo gen√©rico.  Agora, referindo-se √†s propriedades do objeto recebido, voc√™ pode receber uma variedade de informa√ß√µes √∫teis sobre sua estrutura. <br><br><img src="https://habrastorage.org/webt/4b/dy/ki/4bdykiugciapow4d-avqvmfhp7e.jpeg"><br><br>  A propriedade size nos fornece o n√∫mero de bytes ocupados por uma inst√¢ncia da estrutura. <br>  Agora sobre a propriedade stride.  Voc√™ deve ter notado que o tamanho da matriz, em regra, n√£o √© igual √† soma dos tamanhos de seus elementos constituintes, mas excede-o.  Obviamente, um pouco de "ar" √© deixado entre os elementos na mem√≥ria.  Para estimar a dist√¢ncia entre elementos consecutivos em uma matriz adjacente, usamos a propriedade stride.  Se voc√™ o multiplicar pelo n√∫mero de elementos na matriz, obt√©m seu tamanho. <br><br><img src="https://habrastorage.org/webt/vo/9x/6i/vo9x6ivnzz5-nzdhowe4cvtox3u.jpeg"><br><br>  StarData, nossa estrutura experimental, em seu estado inicial n√£o otimizado: <br><br><img src="https://habrastorage.org/webt/no/ku/51/noku51vmtamzm8yk1cclohg1-ea.jpeg"><br><br>  Aqui est√° uma estrutura de dados projetada para armazenar dados sobre uma estrela.  Voc√™ n√£o precisa se aprofundar no significado de cada um desses elementos.  Agora √© mais importante prestar aten√ß√£o aos tipos: vari√°veis ‚Äã‚Äãflutuantes que armazenam as coordenadas da estrela (de fato, latitude e longitude), v√°rios Int32 para v√°rios IDs, String para armazenar nomes e nomes de v√°rias classifica√ß√µes;  h√° dist√¢ncia, cor e outras quantidades necess√°rias para a exibi√ß√£o correta de uma estrela. <br><br>  Solicitamos a propriedade stride: <br><br><img src="https://habrastorage.org/webt/ob/pu/l-/obpul-qs28mwnfqhfnay3b5ml-m.jpeg"><br><br>  No momento, nossa estrutura pesa 208 bytes.  Um milh√£o dessas estruturas exigir√° 250 MB - isso, como voc√™ sabe, √© demais.  Portanto, √© necess√°rio otimizar. <br><br><h2>  Int correto </h2><br>  O fato de existirem diferentes variedades de Int √© relatado nas primeiras li√ß√µes de programa√ß√£o.  O Int mais familiar para n√≥s no Swift √© chamado Int8.  Ocupa 8 bits (1 byte) e pode armazenar valores de -128 a 127 inclusive.  Existem tamb√©m outros Ints: <br><ul><li>  Int16 no tamanho de 2 bytes, o intervalo de valores √© de -32.768 a 32.767; </li><li>  Int32 no tamanho de 4 bytes, o intervalo de valores √© de -2.147.483.648 a 2.147.483.647; </li><li>  Int64 (ou apenas Int) tem 8 bytes de tamanho, o intervalo de valores √© de -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807. </li></ul><br><br>  Provavelmente, aqueles que se envolveram no desenvolvimento da Web e lidaram com o SQL j√° est√£o pensando nisso.  Mas sim, antes de tudo, escolha o Int ideal.  Neste projeto, mesmo antes de pensar em otimiza√ß√£o, entrei em um pouco de otimiza√ß√£o prematura (que, como acabei de lhe dizer, n√£o √© necess√°rio). <br><br>  Vejamos, por exemplo, campos com ID.  Sabemos que teremos cerca de um milh√£o de estrelas - n√£o algumas dezenas de milhares, mas n√£o um bilh√£o.  Portanto, para esses campos, √© melhor escolher Int32.  Ent√£o percebi que 4 bytes s√£o suficientes para o Float aqui.  Double ocupar√° 8, String cada 24, adicione tudo - resulta 152 bytes.  Se voc√™ se lembra, o MemoryLayout anterior nos disse que 208. Por qu√™?  N√≥s devemos cavar mais fundo. <br><br><img src="https://habrastorage.org/webt/ss/pd/-d/sspd-d52ece7xuninv1aivvbapi.jpeg"><br><br>  Primeiro, vejamos Opcional.  Os tipos opcionais diferem no fato de que, se n√£o houver valor atribu√≠do, eles armazenam nulo.  Isso garante seguran√ßa na intera√ß√£o com objetos.  Mas, como voc√™ sabe, essa medida n√£o custa de gra√ßa: ao solicitar a propriedade size de qualquer tipo opcional, voc√™ ver√° que esse tipo sempre leva um byte a mais.  Pagamos pela capacidade de registrar-se no campo nulo. <br><br>  N√£o gostar√≠amos de gastar um byte extra em uma vari√°vel.  Ao mesmo tempo, gostamos muito da ideia incorporada em opcional.  O que fazer?  Vamos tentar implementar nossa estrutura. <br><br>  Vamos escolher um valor que possa razoavelmente ser considerado "inv√°lido" para um determinado campo, enquanto √© adequado para o tipo declarado.  Para getHipId (Int32), pode ser, por exemplo, o valor "-1".  Isso significa que nosso campo n√£o √© inicializado.  Aqui est√° uma bicicleta opcional, que dispensa um byte extra em nada. <br><br>  Claramente, com esse truque, tamb√©m temos uma potencial vulnerabilidade.  Para nos proteger de erros, criaremos um getter para o campo, que gerenciar√° independentemente nossa nova l√≥gica e verificar√° a validade do valor do campo. <br><br><img src="https://habrastorage.org/webt/f8/_7/ar/f8_7ar0uns7lzeude7do0avszaw.jpeg"><br><br>  Esse invasor abstrai completamente de n√≥s a complexidade de uma solu√ß√£o inventada. <br>  V√° para o nosso StarData.  Substitua todos os tipos opcionais pelos tipos regulares e veja o que mostra a passada: <br><br><img src="https://habrastorage.org/webt/bw/v4/rf/bwv4rfqgdjkyle-jziflwtbdgjq.jpeg"><br>  Acontece que, ao eliminar as op√ß√µes, salvamos n√£o 9 bytes (um byte para cada uma das nove op√ß√µes), mas at√© 48. A surpresa √© agrad√°vel, mas eu gostaria de saber por que isso aconteceu.  E isso aconteceu por causa do alinhamento de dados na mem√≥ria. <br><br><h2>  Alinhamento de dados </h2><br>  Lembre-se de que antes de Swift escrev√≠amos no Objective-C, e era baseado em C - e essa situa√ß√£o tamb√©m remonta a C. <br><br>  Ao colocar todas as estruturas na mem√≥ria, os processadores modernos colocam seus elementos n√£o em um fluxo cont√≠nuo (n√£o "ombro a ombro"), mas em alguma grade reduzida de maneira homog√™nea pelos vazios.  Este √© o alinhamento de dados.  Permite simplificar e acelerar o acesso aos elementos de dados necess√°rios na mem√≥ria. <br>  As regras de alinhamento de dados se aplicam a cada vari√°vel, dependendo do seu tipo: <br><br><ul><li>  uma vari√°vel do tipo char pode come√ßar do 1¬∫, 2¬∫, 3¬∫, 4¬∫ etc.  bytes, pois leva apenas um byte em si; </li><li>  uma vari√°vel curta ocupa 2 bytes, para que possa come√ßar do 2¬∫, 4¬∫, 6¬∫, 8¬∫ etc.  um byte (isto √©, de cada byte par); </li><li>  uma vari√°vel do tipo float ocupa 4 bytes, o que significa que pode come√ßar a cada 4, 8, 12, 16, etc.  um byte (isto √©, cada quarto byte); </li><li>  vari√°veis ‚Äã‚Äãdo tipo Double e String ocupam 8 bytes cada, para que possam come√ßar com os dias 8, 16, 24, 32, etc.  bytes </li><li>  etc. </li></ul><br><br>  Os objetos MemoryLayout &lt;&gt; t√™m uma propriedade de alinhamento que retorna a regra de alinhamento correspondente para o tipo especificado. <br><br>  Poder√≠amos aplicar o conhecimento das regras de alinhamento para otimizar o c√≥digo?  Vejamos um exemplo.  Existe uma estrutura de usu√°rio: para firstName e lastName, usamos uma String regular, para middleName - uma String opcional (o usu√°rio pode n√£o ter esse nome).  Na mem√≥ria, uma inst√¢ncia dessa estrutura ser√° colocada da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/ah/2y/iz/ah2yizmjxwar-9d6gycudjcspv0.jpeg"><br><br>  Como voc√™ pode ver, como o middleName opcional ocupa 25 bytes (em vez de m√∫ltiplos de 8 24 bytes), as regras de alinhamento obrigam voc√™ a pular os pr√≥ximos 7 bytes e gastar 80 bytes em toda a estrutura.  Aqui, n√£o importa como voc√™ troque blocos com strings, √© imposs√≠vel contar com um n√∫mero menor de bytes. <br><br>  E agora um exemplo de falha no alinhamento: <br><br><img src="https://habrastorage.org/webt/ea/ag/ch/eaagch2qax-7hpbvfbvrbkd4xog.jpeg"><br><br>  BadAligned   isHidden  Bool (1 ),  size  Double (8 ), isInteractable  bool (1 )   age  Int ( 8 ).    ,        ,     32 . <br><br>      ‚Äî         ,     . <br><br><img src="https://habrastorage.org/webt/qt/de/mw/qtdemwpwvb_tvkd-gnhmx1pfnbm.jpeg"><br><br>     32 ,  24.   25%. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece um jogo de Tetris, n√£o √©? Para coisas de baixo n√≠vel, Swift deve a linguagem C ao seu ancestral. Ao declarar campos em uma grande estrutura de dados aleatoriamente, √© mais prov√°vel que voc√™ use mais mem√≥ria do que poderia, dadas as regras de alinhamento. Portanto, tente lembr√°-los e considere ao escrever c√≥digo - isso n√£o √© t√£o dif√≠cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar ao nosso StarData novamente. Vamos tentar organizar seus campos em ordem crescente de volume ocupado. </font></font><br><br><img src="https://habrastorage.org/webt/4r/jj/po/4rjjpozl7hnmfcnx9yb_e4q66xm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, Float e Int32, depois Double e String. N√£o √© t√£o complicado Tetris! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O passo que recebemos √© de 152 bytes. Ou seja, otimizando a implementa√ß√£o de op√ß√µes e trabalhando com alinhamento, conseguimos reduzir o tamanho da estrutura de 208 para 152 bytes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos nos aproximando do limite de nossos recursos de otimiza√ß√£o? </font><font style="vertical-align: inherit;">Provavelmente sim. </font><font style="vertical-align: inherit;">No entanto, h√° algo mais que voc√™ e eu n√£o tentamos - algo √© uma ordem de magnitude mais complicada, mas √†s vezes pode surpreend√™-lo com o resultado.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contabilidade da L√≥gica de Dom√≠nio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente se concentrar nas especificidades inerentes ao seu servi√ßo. </font><font style="vertical-align: inherit;">Lembre-se do meu exemplo com o xadrez: a id√©ia de variar o indicador FPS quando nada muda na tela √© apenas uma otimiza√ß√£o, levando em considera√ß√£o a l√≥gica de dom√≠nio do aplicativo.</font></font><br><br>    StarData.   ¬´ ¬ª ‚Äî   String,      .     :        !    146   ¬´¬ª ,     properName.  gl_id ‚Äî ID      ,   3801 ,    . bayer_flamstedt ‚Äî   ‚Äî   3064- .   spectralType ‚Äî 4307-. ,         ,     24  . <br><br>      .       .    ‚Äî     Int16,   ,     - ‚Äî   ,  -1. <br><br>   StarData  properName, gl_id, bayer_flamstedt  spectralType   ,    .       -,       .     ‚Äî     : <br><br><img src="https://habrastorage.org/webt/n7/i5/bi/n7i5bilqodef52ninsnoilrneci.jpeg"><br><br>     ‚Äî       .      private,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, esta solu√ß√£o tem um sinal de menos. A economia de mem√≥ria n√£o pode deixar de afetar a carga do processador. Com esse esquema, somos for√ßados a acessar constantemente nossa matriz associativa; e na maioria dos casos - em v√£o, j√° que a maioria das linhas permanecer√° vazia e as solicita√ß√µes retornar√£o "-1". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, tive que mudar um pouco o conceito do aplicativo. Foi decidido fornecer ao usu√°rio informa√ß√µes sobre a estrela somente quando elas clicarem nela - somente ent√£o a consulta ao array associativo ser√° executada e os dados recebidos ser√£o exibidos na tela.</font></font><br><br>    ,  ,          .      .     unit- ‚Äî ,          . <br><br> : stride    64 ! <br><br>   ? ,       :    Int16 . <br><br><img src="https://habrastorage.org/webt/qs/yh/hs/qsyhhsoleaji_jnucoeew5fjguq.jpeg"><br><br>   .  ,               StarData  208  56 .      500 ,  130.    ! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o se esque√ßa dos perigos da otimiza√ß√£o prematura. </font><font style="vertical-align: inherit;">Se sua estrutura de dados de usu√°rio for usada para cerca de 20 usu√°rios, voc√™ n√£o ganhar√° tanto assim que faz sentido faz√™-lo. </font><font style="vertical-align: inherit;">Mais importante, √© conveniente para o pr√≥ximo desenvolvedor depois que voc√™ manter o c√≥digo. </font><font style="vertical-align: inherit;">Por favor, n√£o diga mais tarde "esse cara na confer√™ncia disse que a ordem deveria ser exatamente isso"! </font><font style="vertical-align: inherit;">N√£o fa√ßa isso apenas por divers√£o. </font><font style="vertical-align: inherit;">Bem, para mim, essas coisas s√£o um bom entretenimento, n√£o sei como fazer para voc√™.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otimiza√ß√£o r√°pida do compilador </font></font></h2><br>       ( )  .        ,      ,    . <br><br>      -     .    ,      . <br><br>      Xcode.       : <br><br><img src="https://habrastorage.org/webt/1x/36/j6/1x36j61elqsczwzbjldxjmdewtq.jpeg"><br><br>   ,  xCode           culprits.txt.    . <br><br><img src="https://habrastorage.org/webt/zz/ht/rp/zzhtrpbqbipvucqydinougkyzhu.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando meu instrumento simples, eu pude observar coisas interessantes. </font><font style="vertical-align: inherit;">Alguns m√©todos podem ser compilados por at√© 2 segundos, enquanto cont√™m apenas tr√™s linhas de c√≥digo. </font><font style="vertical-align: inherit;">Qual poderia ser o motivo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, algo como sa√≠da do compilador de tipo. </font><font style="vertical-align: inherit;">Se voc√™ n√£o especificar tipos explicitamente, o Swift ser√° for√ßado a detect√°-los. </font><font style="vertical-align: inherit;">Essa opera√ß√£o (devo dizer, n√£o trivial) requer tempo do processador; portanto, do ponto de vista do compilador, √© sempre melhor indicar o tipo. </font><font style="vertical-align: inherit;">Apenas escrevendo explicitamente os tipos, fui capaz de reduzir o tempo de compila√ß√£o do aplicativo de 5 para 2 (!) Minutos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas existe um "mas": c√≥digo sem tipos ainda √© mais leg√≠vel. </font><font style="vertical-align: inherit;">E n√≥s j√° conversamos sobre prioridades. </font><font style="vertical-align: inherit;">N√£o otimize antecipadamente: a princ√≠pio, a legibilidade do c√≥digo ser√° mais cara.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Op√ß√£o de servidor </font></font></h2><br>            .             Swift.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   GitHub</a> .  API-,           .          ,      ARkit.           :      500 ,         Bluemix.  ,      . <br><br><h2>   </h2><br>  ,    ,      : <br><br><ul><li>       .      .      ,          ,     ,           ? </li><li>    ,     unit-. ,          unit-.    ,          . Unit-    ,     . </li><li>   .      ,        .   ,   :   ‚Äî  . </li><li>      .         .   ,    ‚Äî   ,   ¬´¬ª . </li><li> RAM vs. CPU.           .     ,           . </li></ul><br><br><blockquote>        Mobius ‚Äî  ,  8-9   <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mobius 2018 Moscow</a></b> ,     .  1    ,       ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427845/">https://habr.com/ru/post/pt427845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427833/index.html">Relat√≥rio da Confer√™ncia Joker de 2018</a></li>
<li><a href="../pt427837/index.html">Os primeiros dias na equipe de desenvolvimento - como acontece conosco</a></li>
<li><a href="../pt427839/index.html">Autoriza√ß√£o de usu√°rio no Django atrav√©s do GSSAPI e delega√ß√£o de direitos de usu√°rio no servidor</a></li>
<li><a href="../pt427841/index.html">Golpe de salto m√°gico</a></li>
<li><a href="../pt427843/index.html">Como dormir certo e errado</a></li>
<li><a href="../pt427847/index.html">Curiosidade e procrastina√ß√£o no aprendizado de m√°quina</a></li>
<li><a href="../pt427849/index.html">Linha reta com TM. v3.0</a></li>
<li><a href="../pt427853/index.html">Reflex√µes sobre TDD. Por que essa metodologia n√£o √© amplamente reconhecida</a></li>
<li><a href="../pt427855/index.html">Mitaps do MOSDROID no FunCorp</a></li>
<li><a href="../pt427857/index.html">Quest√µes fiscais e legais para freelancers iniciantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>