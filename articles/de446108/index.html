<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèæ üí° ‚è±Ô∏è Bausteine ‚Äã‚Äãverteilter Anwendungen. Erster Ansatz üë≤üèº üëí üîá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel haben wir die theoretischen Grundlagen der reaktiven Architektur untersucht. Es ist Zeit, √ºber Datenstr√∂me, M√∂glichkeiten zur Imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bausteine ‚Äã‚Äãverteilter Anwendungen. Erster Ansatz</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446108/"><p><img src="https://habrastorage.org/webt/id/fv/eo/idfveo9cmr8y2uyidusx29gwvtc.jpeg"></p><br><p> Im letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel haben</a> wir die theoretischen Grundlagen der reaktiven Architektur untersucht.  Es ist Zeit, √ºber Datenstr√∂me, M√∂glichkeiten zur Implementierung reaktiver Erlang / Elixir-Systeme und Messaging-Muster zu sprechen: </p><br><ul><li>  Antwort anfordern </li><li>  Request-Chunked-Antwort </li><li>  Antwort mit Anfrage </li><li>  Ver√∂ffentlichen-Abonnieren </li><li>  Inverted Publish-Subscribe </li><li>  Aufgabenverteilung <a name="habracut"></a></li></ul><br><h2 id="soa-msa-i-obmen-soobscheniyami">  SOA, MSA und Messaging </h2><br><p>  SOA, MSA - Systemarchitekturen, die die Regeln f√ºr das Erstellen von Systemen definieren, w√§hrend Messaging Grundelemente f√ºr deren Implementierung bereitstellt. </p><br><p>  Ich m√∂chte diese oder jene Architektur von Geb√§udesystemen nicht f√∂rdern.  Ich bin f√ºr die Anwendung der effektivsten und n√ºtzlichsten Praktiken f√ºr ein bestimmtes Projekt und Gesch√§ft.  Welches Paradigma wir auch w√§hlen, es ist besser, Systembl√∂cke mit Blick auf den Unix-Weg zu erstellen: Komponenten mit minimaler Konnektivit√§t, die f√ºr einzelne Entit√§ten verantwortlich sind.  API-Methoden f√ºhren die einfachsten Aktionen mit Entit√§ten aus. </p><br><p>  Messaging - wie der Name schon sagt, ist ein Nachrichtenbroker.  Sein Hauptzweck ist es, Nachrichten zu empfangen und zu geben.  Er ist verantwortlich f√ºr die Schnittstellen zum Senden von Informationen, die Bildung logischer Kan√§le f√ºr die √úbertragung von Informationen innerhalb des Systems, das Routing und den Ausgleich sowie die Verarbeitung von Fehlern auf Systemebene. <br>  Das zu entwickelnde Messaging versucht nicht, mit rabbitmq zu konkurrieren oder es zu ersetzen.  Seine Hauptmerkmale: </p><br><ul><li>  Verteilung <br>  Austauschpunkte k√∂nnen auf allen Knoten des Clusters so nahe wie m√∂glich an dem Code erstellt werden, der sie verwendet. </li><li>  Einfachheit. <br>  Konzentrieren Sie sich auf die Minimierung des Boilerplate-Codes und der Benutzerfreundlichkeit. </li><li>  Die beste Leistung. <br>  Wir versuchen nicht, die Funktionalit√§t von rabbitmq zu wiederholen, sondern heben nur die Architektur- und Transportschicht hervor, die in OTP so einfach wie m√∂glich ist, um die Kosten zu minimieren. </li><li>  Flexibilit√§t. <br>  Jeder Dienst kann viele Austauschvorlagen kombinieren. </li><li>  Fehlertoleranz im Design. </li><li>  Skalierbarkeit. <br>  Messaging w√§chst mit der Anwendung.  Mit zunehmender Last k√∂nnen Sie die Austauschpunkte auf einzelne Maschinen verschieben. </li></ul><br><p>  <em>Bemerkung.</em>  Aus Sicht der Code-Organisation eignen sich Metaprojekte gut f√ºr komplexe Systeme mit Erlang / Elixir.  Der gesamte Projektcode befindet sich in einem Repository - einem Dachprojekt.  Gleichzeitig sind Microservices so isoliert wie m√∂glich und f√ºhren einfache Vorg√§nge aus, die f√ºr eine separate Einheit verantwortlich sind.  Mit diesem Ansatz ist es einfach, die API des gesamten Systems zu unterst√ºtzen. Nehmen Sie einfach √Ñnderungen vor. Es ist bequem, Einheiten und Integrationstests zu schreiben. </p><br><p>  Systemkomponenten interagieren direkt oder √ºber einen Broker.  Aus Messaging-Sicht hat jeder Dienst mehrere Lebensphasen: </p><br><ul><li>  Service-Initialisierung. <br>  In dieser Phase erfolgt die Konfiguration und der Start des Dienstes, der den Prozess und die Abh√§ngigkeiten ausf√ºhrt. </li><li>  Einen Austauschpunkt erstellen. <br>  Der Dienst kann den in der Konfiguration des Knotens angegebenen statischen Austauschpunkt verwenden oder Austauschpunkte dynamisch erstellen. </li><li>  Serviceregistrierung. <br>  Damit der Dienst Anfragen bearbeiten kann, muss er an der Vermittlungsstelle registriert sein. </li><li>  Normale Funktion. <br>  Service produziert n√ºtzliche Arbeit. </li><li>  Herunterfahren. <br>  Es gibt zwei Arten des Herunterfahrens: regul√§res und Notfall.  Bei einem regul√§ren Service wird die Verbindung zum Wechselpunkt getrennt und angehalten.  In Notf√§llen f√ºhrt Messaging eines der Failover-Szenarien aus. </li></ul><br><p>  Es sieht ziemlich kompliziert aus, aber nicht alles ist im Code so be√§ngstigend.  Beispiele f√ºr Code mit Kommentaren werden etwas sp√§ter in der Analyse von Vorlagen angegeben. </p><br><h2 id="exchanges">  B√∂rsen </h2><br><p>  Ein Austauschpunkt ist ein Messaging-Prozess, der die Logik der Interaktion mit Komponenten in einer Messaging-Vorlage implementiert.  In allen folgenden Beispielen interagieren die Komponenten √ºber Austauschpunkte, deren Kombination Messaging bildet. </p><br><h2 id="message-exchange-patterns-meps">  Nachrichtenaustauschmuster (MEPs) </h2><br><p>  Das Teilen von Mustern kann global in zwei Richtungen und eine Richtung unterteilt werden.  Ersteres impliziert eine Antwort auf die empfangene Nachricht, letzteres nicht.  Ein klassisches Beispiel f√ºr ein Zwei-Wege-Muster in einer Client-Server-Architektur ist das Request-Response-Muster.  Betrachten Sie die Vorlage und ihre √Ñnderungen. </p><br><h3 id="requestresponse-ili-rpc">  Anfrage - Antwort oder RPC </h3><br><p>  RPC wird verwendet, wenn wir eine Antwort von einem anderen Prozess erhalten m√ºssen.  Dieser Prozess kann am selben Standort oder auf einem anderen Kontinent gestartet werden.  Unten sehen Sie ein Diagramm der Interaktion von Client und Server durch Messaging. </p><br><p><img src="https://habrastorage.org/webt/pz/x9/hx/pzx9hxfkk0szgfugtdbpc1hwrak.png"></p><br><p>  Da das Messaging vollst√§ndig asynchron ist, ist der Austausch f√ºr den Client in zwei Phasen unterteilt: </p><br><ol><li><p>  Einreichung anfordern </p><br><pre><code class="erlang hljs">messaging:request(Exchange, ResponseMatchingTag, RequestDefinition, HandlerProcess).</code> </pre> <br><p>  <em>Austausch</em> - ein eindeutiger Name f√ºr den Austauschpunkt <br>  <em>ResponseMatchingTag</em> - Die lokale Bezeichnung f√ºr die Antwort.  Zum Beispiel beim Senden mehrerer identischer Anfragen, die verschiedenen Benutzern geh√∂ren. <br>  <em>RequestDefinition</em> - <em>Anfragetext</em> <br>  <em>HandlerProcess</em> - PID-Handler.  Dieser Prozess erh√§lt eine Antwort vom Server. </p><br></li><li><p>  Antwortverarbeitung </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = EXCHANGE, tag = ResponseMatchingTag,message = ResponsePayload}, State)</span></span></span></span></code> </pre> <br><p>  <em>ResponsePayload</em> - Serverantwort. </p><br></li></ol><br><p>  F√ºr den Server besteht der Prozess auch aus 2 Phasen: </p><br><ol><li>  Exchange Point-Initialisierung </li><li>  Eingehende Anfragen bearbeiten </li></ol><br><p>  Lassen Sie uns diese Vorlage mit Code veranschaulichen.  Angenommen, wir m√ºssen einen einfachen Dienst implementieren, der die einzig genaue Zeitmethode bietet. </p><br><h4 id="kod-servera">  Servercode </h4><br><p>  Nehmen Sie die Definition der Service-API in api.hrl heraus: </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% ===================================================== %% entities %% ===================================================== -record(time, { unixtime :: non_neg_integer(), datetime :: binary() }). -record(time_error, { code :: non_neg_integer(), error :: term() }). %% ===================================================== %% methods %% ===================================================== -record(time_req, { opts :: term() }). -record(time_resp, { result :: #time{} | #time_error{} }).</span></span></code> </pre> <br><p>  Definieren Sie einen Service Controller in time_controller.erl </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%%      .     gen_server    . %%  gen_server init(Args) -&gt; %%     messaging:monitor_exchange(req_resp, ?EXCHANGE, default, self()) {ok, #{}}. %%       .    ,      . handle_info(#exchange_die{exchange = ?EXCHANGE}, State) -&gt; erlang:send(self(), monitor_exchange), {noreply, State}; %%  API handle_info(#time_req{opts = _Opts}, State) -&gt; messaging:response_once(Client, #time_resp{ result = #time{ unixtime = time_utils:unixtime(now()), datetime = time_utils:iso8601_fmt(now())} }); {noreply, State}; %%   gen_server terminate(_Reason, _State) -&gt; messaging:demonitor_exchange(req_resp, ?EXCHANGE, default, self()), ok.</span></span></code> </pre> <br><h4 id="kod-klienta">  Kundencode </h4><br><p>  Um eine Anforderung an einen Dienst zu senden, k√∂nnen Sie die Messaging-Anforderungs-API an einer beliebigen Stelle im Client aufrufen: </p><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> messaging:request(?EXCHANGE, tag, #time_req{opts = #{}}, self()) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; ok; _ -&gt; <span class="hljs-comment"><span class="hljs-comment">%% repeat or fail logic end</span></span></code> </pre> <br><p>  In einem verteilten System kann die Konfiguration der Komponenten sehr unterschiedlich sein und zum Zeitpunkt der Anforderung wird das Messaging m√∂glicherweise noch nicht gestartet, oder der Service-Controller ist nicht bereit, die Anforderung zu bearbeiten.  Daher m√ºssen wir die Messaging-Antwort √ºberpr√ºfen und den Fehlerfall behandeln. <br>  Nach erfolgreichem Senden erh√§lt der Client eine Antwort oder einen Fehler vom Dienst. <br>  Behandeln Sie beide F√§lle in handle_info: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time{unixtime = Utime}}}, State)</span></span></span><span class="hljs-function"> -&gt;</span></span> ?debugVal(Utime), {noreply, State}; handle_info(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time_error{code = ErrorCode}}}, State) -&gt; ?debugVal({error, ErrorCode}), {noreply, State};</code> </pre> <br><h3 id="request-chunked-response">  Request-Chunked-Antwort </h3><br><p>  Besser nicht die √úbertragung gro√üer Nachrichten zulassen.  Davon h√§ngt die Reaktionsf√§higkeit und der stabile Betrieb des gesamten Systems ab.  Wenn die Antwort auf die Anforderung viel Speicherplatz beansprucht, ist eine Aufteilung in Teile obligatorisch. </p><br><p><img src="https://habrastorage.org/webt/dj/zv/6_/djzv6_lvreaj-iieegxoqemx-vi.png"></p><br><p>  Ich werde einige Beispiele f√ºr solche F√§lle geben: </p><br><ul><li>  Komponenten tauschen Bin√§rdaten aus, z. B. Dateien.  Wenn Sie die Antwort in kleine Teile unterteilen, k√∂nnen Sie effizient mit Dateien jeder Gr√∂√üe arbeiten und keine Speicher√ºberl√§ufe feststellen. </li><li>  Auflistungen.  Zum Beispiel m√ºssen wir alle Datens√§tze aus einer riesigen Tabelle in der Datenbank ausw√§hlen und auf eine andere Komponente √ºbertragen. </li></ul><br><p>  Ich nenne diese Antworten eine Lokomotive.  In jedem Fall sind 1024 1-MB-Nachrichten besser als eine einzelne 1-GB-Nachricht. </p><br><p>  Im Erlang-Cluster erhalten wir einen zus√§tzlichen Gewinn, der die Belastung des Vermittlungspunkts und des Netzwerks verringert, da die Antworten sofort an den Empf√§nger gesendet werden und der Vermittlungspunkt umgangen wird. </p><br><h3 id="response-with-request">  Antwort mit Anfrage </h3><br><p>  Dies ist eine ziemlich seltene Modifikation des RPC-Musters zum Erstellen interaktiver Systeme. </p><br><p><img src="https://habrastorage.org/webt/dg/t5/kt/dgt5ktnzqdttmiqv8jne7h6lneg.png"></p><br><h3 id="publish-subscribe-data-distribution-tree">  Publish-Subscribe (Datenverteilungsbaum) </h3><br><p>  Ereignisorientierte Systeme liefern Daten an Verbraucher, sobald Daten verf√ºgbar sind.  Daher sind Systeme anf√§lliger f√ºr Push-Modelle als f√ºr Pull oder Poll.  Mit dieser Funktion k√∂nnen Sie keine Ressourcen verschwenden, indem Sie st√§ndig Daten abfragen und darauf warten. <br>  Die Abbildung zeigt den Prozess der Verteilung einer Nachricht an Verbraucher, die ein bestimmtes Thema abonniert haben. </p><br><p><img src="https://habrastorage.org/webt/yg/sp/lx/ygsplxxerjwdvci5gk3hhdn2jay.png"></p><br><p>  Klassische Beispiele f√ºr die Verwendung dieser Vorlage sind die Verteilung des Staates: die Spielewelt in Computerspielen, Marktdaten √ºber B√∂rsen, n√ºtzliche Informationen in Datenfeeds. </p><br><p>  Betrachten Sie den Teilnehmercode: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Args)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%%   ,  = key messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {ok, #{}}. handle_info(#exchange_die{exchange = ?SUBSCRIPTION}, State) -&gt; %%    ,    messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {noreply, State}; %%    handle_info(#'$msg'{exchange = ?SUBSCRIPTION, message = Msg}, State) -&gt; ?debugVal(Msg), {noreply, State}; %%    -     terminate(_Reason, _State) -&gt; messaging:unsubscribe(?SUBSCRIPTION, key, tag, self()), ok.</span></span></code> </pre> <br><p>  Die Quelle kann die Funktion nach der Ver√∂ffentlichung an einem beliebigen Ort aufrufen: </p><br><pre> <code class="erlang hljs">messaging:publish_message(Exchange, Key, Message).</code> </pre> <br><p>  <em>Austausch</em> - der Name des Austauschpunkts, <br>  <em>Schl√ºssel</em> - Routing-Schl√ºssel <br>  <em>Nachricht</em> - Nutzlast </p><br><h2 id="inverted-publish-subscribe">  Inverted Publish-Subscribe </h2><br><p><img src="https://habrastorage.org/webt/5h/qz/uq/5hqzuqda_rzuvaphv2q3nqjnvcg.png"></p><br><p>  Durch Erweitern von pub-sub erhalten Sie ein Muster, das f√ºr die Protokollierung geeignet ist.  Die Quellen und Verbraucher k√∂nnen v√∂llig unterschiedlich sein.  Die Abbildung zeigt einen Fall mit einem Verbraucher und mehreren Quellen. </p><br><h2 id="task-distribution-pattern">  Aufgabenverteilungsmuster </h2><br><p>  In fast jedem Projekt treten Aufgaben der verz√∂gerten Verarbeitung auf, z. B. das Generieren von Berichten, das √úbermitteln von Benachrichtigungen und das Empfangen von Daten von Systemen von Drittanbietern.  Der Durchsatz eines Systems, das diese Aufgaben ausf√ºhrt, kann durch Hinzuf√ºgen von Handlern leicht skaliert werden.  Wir m√ºssen nur noch eine Gruppe von Handlern bilden und die Aufgaben gleichm√§√üig auf sie verteilen. </p><br><p>  Betrachten Sie die Situationen, die am Beispiel von 3 Handlern auftreten.  Bereits in der Phase der Aufgabenverteilung stellt sich die Frage nach der Fairness der Verteilung und dem √úberlauf der Prozessoren.  Die Round-Robin-Verteilung ist f√ºr die Gerechtigkeit verantwortlich. Um ein √úberlaufen der Handler zu vermeiden, f√ºhren wir die Einschr√§nkung <em>prefetch_limit ein</em> .  In √úbergangsmodi verhindert <em>prefetch_limit</em> , dass ein Handler alle Aufgaben empf√§ngt. </p><br><p>  Messaging verwaltet Warteschlangen und Verarbeitungspriorit√§ten.  Handler erhalten Aufgaben, sobald sie verf√ºgbar sind.  Die Aufgabe kann erfolgreich sein oder fehlschlagen: </p><br><ul><li>  <code>messaging:ack(Tack)</code> - <code>messaging:ack(Tack)</code> bei erfolgreicher Nachrichtenverarbeitung aufgerufen </li><li>  <code>messaging:nack(Tack)</code> - wird in allen Notfallsituationen aufgerufen.  Nachdem die Aufgabe zur√ºckgekehrt ist, wird sie durch Messaging an einen anderen Handler √ºbertragen. </li></ul><br><p><img src="https://habrastorage.org/webt/w6/yi/hc/w6yihc6yyunvigevthjggejkwjq.png"></p><br><p>  Angenommen, w√§hrend der Verarbeitung von drei Aufgaben ist ein komplexer Fehler aufgetreten: Handler 1 st√ºrzte nach dem Empfang der Aufgabe ab, bevor er mit dem Austauschpunkt kommunizieren konnte.  In diesem Fall √ºbertr√§gt der Austauschpunkt nach Ablauf des Best√§tigungszeitlimits den Job an einen anderen Handler.  Handler 3 lehnte die Aufgabe aus irgendeinem Grund ab und sendete nack. Infolgedessen wurde die Aufgabe auch an einen anderen Handler √ºbergeben, der sie erfolgreich abgeschlossen hat. </p><br><h2 id="predvaritelnyy-itog">  Vorl√§ufiges Ergebnis </h2><br><p>  Wir haben die Grundbausteine ‚Äã‚Äãverteilter Systeme auseinander genommen und ein grundlegendes Verst√§ndnis ihrer Anwendung in Erlang / Elixir erhalten. </p><br><p>  Durch die Kombination grundlegender Muster k√∂nnen Sie komplexe Paradigmen zur L√∂sung neu auftretender Probleme erstellen. </p><br><p>  Im letzten Teil des Zyklus werden wir die allgemeinen Fragen der Organisation von Diensten, des Routings und des Ausgleichs betrachten und auch √ºber die praktische Seite der Skalierbarkeit und Fehlertoleranz von Systemen sprechen. </p><br><p>  Das Ende des zweiten Teils. </p><br><p>  Foto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marius Christensen</a> <br>  Illustrationen erstellt von websequencediagrams.com </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446108/">https://habr.com/ru/post/de446108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446096/index.html">Das Buch ‚ÄûTasteVill: Wie man im Einzelhandel eine Revolution macht und alles falsch macht‚Äú</a></li>
<li><a href="../de446098/index.html">Sowjetisches Flugkontrollzentrum aus der Zeit von "Wostok" und "Sonnenaufgang"</a></li>
<li><a href="../de446100/index.html">Erstellen Sie automatisch Android- und iOS-Lokalisierungsdateien aus einer Excel-Tabelle</a></li>
<li><a href="../de446104/index.html">Das Python-Paradoxon</a></li>
<li><a href="../de446106/index.html">Oleg Shelaev √ºber GraalVM auf jug.msk.ru</a></li>
<li><a href="../de446110/index.html">WavesKit - PHP Waves Blockchain Framework</a></li>
<li><a href="../de446112/index.html">WavesKit - PHP-Framework f√ºr die Arbeit mit Waves Platform</a></li>
<li><a href="../de446114/index.html">50 Jahre altes Modem: Ein Einblick</a></li>
<li><a href="../de446116/index.html">Eine Auswahl von B√ºchern zum Lernen, Denken und Treffen effektiver Entscheidungen</a></li>
<li><a href="../de446118/index.html">Open Rack v3: Was erwartet Sie vom neuen Standard f√ºr die Server-Rack-Architektur?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>