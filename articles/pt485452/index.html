<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèø üòï üåπ Por que a Rust lidera o benchmark do TechEmpower Framework üßìüèΩ üìà üéÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na verdade, n√£o pretendia ver de que cor eram as entranhas de Rust. Peguei um projeto de hobby no Go, fui ao GitHub para ver o estado do fasthttp: est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que a Rust lidera o benchmark do TechEmpower Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485452/"><p>  Na verdade, n√£o pretendia ver de que cor eram as entranhas de Rust.  Peguei um projeto de hobby no Go, fui ao GitHub para ver o estado do fasthttp: est√° em desenvolvimento?  Bem, pelo menos suportado?  Cresceu.  Fui, procurei onde o fasthttp fica nos benchmarks do <a href="https://www.techempower.com/benchmarks/" rel="nofollow">TechEmpower</a> .  Eu olho: e l√° fasthttp mal mostra metade do que o l√≠der obt√©m - algumas a√ß√µes em alguns Rust.  Que dor. </p><br><p>  Aqui eu cruzava os bra√ßos, batia a cabe√ßa no ch√£o (tr√™s vezes) e gritava: "Aleluia, na verdade Rust √© um deus verdadeiro, qu√£o cego eu era antes!".  Mas as al√ßas n√£o deram certo ou a testa se arrependeu ... Em vez disso, entrei no c√≥digo dos testes escritos em Go e nos testes actix-web no Rust.  Para resolver isso. </p><br><p>  Depois de algumas horas, descobri: </p><br><ol><li>  por que a estrutura actix-web Rust ocupa o primeiro lugar em todos os testes TechEmpower, </li><li>  como o Java inicia o Script. </li></ol><br><p>  Agora vou contar tudo em ordem. </p><a name="habracut"></a><br><h2 id="chto-za-techempower-framework-benchmark">  O que √© o TechEmpower Framework Benchmark? </h2><br><p>  Se uma estrutura da web demonstrar se vai ou, digamos, √†s vezes pensar em sussurrar para os amigos "eu sou r√°pido", ela certamente cair√° no benchmark do TechEmpower Framework.  Um local popular para medir o desempenho. </p><br><p>  O site tem um design peculiar: as guias de filtros, rodadas, condi√ß√µes e resultados para diferentes tipos de testes est√£o espalhados na p√°gina com uma m√£o generosa.  T√£o generoso e abrangente que voc√™ nem percebe.  Mas vale a pena clicar nas guias, as informa√ß√µes por tr√°s delas s√£o √∫teis. </p><br><p>  A maneira mais f√°cil √© obter os resultados dos testes em texto simples, "Ol√°, mundo!"  para servidores web.  Os autores da estrutura geralmente fornecem um link para ela: supostamente estamos nos mantendo nos primeiros cem.  O caso est√° correto e √∫til.  Em geral, dar texto claro √© bom para muitos, e os l√≠deres entram em um grupo restrito. </p><br><p>  Nas proximidades, nessas mesmas guias, est√£o os resultados de testes de outros tipos (cen√°rios).  Existem sete deles, mais detalhes podem ser encontrados <a href="https://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview" rel="nofollow">aqui</a> .  Esses scripts testam n√£o apenas como a estrutura / plataforma lida com o processamento de uma solicita√ß√£o HTTP simples, mas uma combina√ß√£o com um cliente de banco de dados, mecanismo de modelo ou serializador JSON. </p><br><p>  Existem dados de teste em um ambiente virtual, em um hardware f√≠sico.  Al√©m dos gr√°ficos, existem dados tabulares.  Em geral, muitas coisas interessantes, vale a pena procurar, n√£o apenas olhando para a posi√ß√£o da "sua" plataforma. </p><br><p>  A primeira coisa que me veio √† mente depois de passar pelos resultados dos testes: "Por que tudo √© T√ÉO T√ÉO diferente do texto simples?!".  Em texto simples, os l√≠deres entram em um grupo restrito, mas quando se trata de trabalhar com o banco de dados, o actix-web lidera por uma margem significativa.  Ao mesmo tempo, mostra um tempo est√°vel de processamento de solicita√ß√µes.  Shaitan. </p><br><p>  Outra anomalia: uma solu√ß√£o JavaScript incrivelmente poderosa.  √â chamado ex4x.  Aconteceu que o c√≥digo dele era um pouco menos do que completamente escrito em Java.  Utilizado pelo Java Runtime, JDBC.  O c√≥digo JavaScript √© traduzido em bytecode e cola as bibliotecas Java.  Eles literalmente o pegaram - e anexaram o Script ao Java.  Os truques dos rostos p√°lidos n√£o t√™m limites. </p><br><h2 id="kak-posmotret-kod-i-chto-tam-vnutri">  Como ver o c√≥digo e o que h√° dentro </h2><br><p>  O c√≥digo para todos os testes est√° no GitHub.  Tudo est√° em um √∫nico reposit√≥rio, o que √© muito conveniente.  Voc√™ pode clonar e assistir, voc√™ pode assistir diretamente no GitHub.  O teste envolve mais de 300 combina√ß√µes diferentes da estrutura com serializadores, mecanismos de modelo e o cliente de banco de dados.  Em diferentes linguagens de programa√ß√£o, com uma abordagem diferente para o desenvolvimento.  As implementa√ß√µes em um idioma est√£o pr√≥ximas e podem ser comparadas com a implementa√ß√£o em outros idiomas.  O c√≥digo √© mantido pela comunidade, n√£o √© o trabalho de uma pessoa ou equipe. </p><br><p>  O c√≥digo de refer√™ncia √© um √≥timo lugar para ampliar seus horizontes.  √â interessante analisar como pessoas diferentes resolvem os mesmos problemas.  N√£o h√° muito c√≥digo, as bibliotecas e solu√ß√µes usadas s√£o f√°ceis de distinguir.  N√£o me arrependo de tudo que cheguei l√°.  Eu aprendi muito  Primeiro de tudo sobre Rust. </p><br><p>  Antes de Rust, eu tinha uma ideia muito vaga.  Qualquer artigo sobre C, C ++, D e especialmente Go certamente contar√° com alguns comentadores que explicam detalhadamente e com ang√∫stia que vaidade, bobagem e estupidez s√£o escritas em outra coisa, desde que exista. <del>  Gasconha </del>  Ferrugem.  √Äs vezes, eles se empolgam tanto que d√£o exemplos de c√≥digo do que uma pessoa despreparada <del>  ou poucos aceitando </del>  levado a um estupor: "Por que, por que, por que todos esses s√≠mbolos?!" </p><br><p>  Portanto, abrir o c√≥digo foi assustador. </p><br><p>  Eu olhei  Acontece que os programas no Rust podem ser lidos.  Al√©m disso, o c√≥digo √© lido t√£o bem que eu at√© instalei o Rust, tentei compilar o teste e mexer um pouco nele. </p><br><p>  Aqui quase abandonei esse neg√≥cio, porque a compila√ß√£o dura muito tempo.  Muito tempo.  Se eu fosse D'Artagnan, ou mesmo um col√©rico, teria corrido para a Gasconha, e mil dem√¥nios seguiriam desanimados.  Mas eu consegui.  Tomei ch√° de novo.  Parece que nem uma x√≠cara: no meu laptop, a primeira compila√ß√£o levou cerca de 20 minutos e, no entanto, tudo ficou mais divertido.  Talvez at√© a pr√≥xima grande atualiza√ß√£o. </p><br><h2 id="a-razve-delo-ne-v-samom-rust">  Mas n√£o √© o pr√≥prio Rust? </h2><br><p>  N√£o.  N√£o √© uma linguagem de programa√ß√£o. </p><br><p>  Claro, Rust √© uma linguagem maravilhosa.  Poderoso, flex√≠vel, embora por h√°bito e detalhado.  Mas a pr√≥pria linguagem n√£o escrever√° c√≥digo r√°pido.  A linguagem √© uma das ferramentas, uma das decis√µes tomadas pelo programador. </p><br><p>  Como eu disse - doar texto simples √© rapidamente obtido por muitos.  O desempenho das estruturas actix-web, fasthttp e uma d√∫zia de outras ao processar uma solicita√ß√£o simples √© bastante compar√°vel, ou seja, outros idiomas t√™m a capacidade t√©cnica de competir com o Rust. </p><br><p>  A pr√≥pria Actix-web, √© claro, √© ‚Äúculpada‚Äù: um produto r√°pido, pragm√°tico e excelente.  A serializa√ß√£o √© conveniente, o mecanismo de modelo √© bom - tamb√©m ajuda muito. </p><br><p>  Mais notavelmente, os resultados dos testes que trabalham com o banco de dados diferem. </p><br><p>  Depois de cavar um pouco no c√≥digo, destaquei tr√™s principais diferen√ßas que (me parece) ajudaram os testes actix a se distanciarem dos concorrentes nos testes sint√©ticos: </p><br><ol><li>  Modo de opera√ß√£o tokio-postgres em pipeline em pipeline; </li><li>  Usando uma √∫nica conex√£o com um teste de Rust em vez de um pool de conex√µes com um teste escrito em Go; </li><li>  Atualizando benchmarks actix com um √∫nico comando enviado por meio de uma consulta simples em vez de enviar v√°rios comandos UPDATE. </li></ol><br><h2 id="chto-esche-za-konveyernyy-rezhim">  Que tipo de modo de transporte? </h2><br><p>  Aqui est√° um trecho da documenta√ß√£o do tokio-postgres (usada no benchmark da biblioteca do cliente PostgreSQL) explicando o que seus desenvolvedores significam: </p><br><pre><code class="plaintext hljs">Sequential Pipelined | Client | PostgreSQL | | Client | PostgreSQL | |----------------|-----------------| |----------------|-----------------| | send query 1 | | | send query 1 | | | | process query 1 | | send query 2 | process query 1 | | receive rows 1 | | | send query 3 | process query 2 | | send query 2 | | | receive rows 1 | process query 3 | | | process query 2 | | receive rows 2 | | | receive rows 2 | | | receive rows 3 | | | send query 3 | | | | process query 3 | | receive rows 3 | |</code> </pre> <br><p>  O cliente no modo pipelined (pipelined) n√£o espera uma resposta do PostgreSQL, mas envia a pr√≥xima consulta enquanto o PostgreSQL est√° processando a anterior.  Pode-se observar que dessa maneira √© poss√≠vel processar a mesma sequ√™ncia de consultas ao banco de dados significativamente mais rapidamente. </p><br><p>  Se a conex√£o no modo pipelined for duplex (oferecendo a possibilidade de obter resultados em paralelo com o envio), esse tempo poder√° ser ligeiramente reduzido.  Parece que j√° existe uma vers√£o experimental do tokio-postgres em que uma conex√£o duplex √© aberta. </p><br><p>  Como o cliente PostgreSQL envia v√°rias mensagens (Parse, Bind, Execute e Sync) para cada consulta SQL enviada para execu√ß√£o e recebe uma resposta, o modo em pipeline ser√° mais eficaz, mesmo ao processar consultas √∫nicas. </p><br><h2 id="a-pochemu-v-go-ne-tak">  E por que n√£o est√° no Go? </h2><br><p>  Porque o Go geralmente usa pools de conex√£o com o banco de dados.  As conex√µes n√£o devem ser usadas em paralelo. </p><br><p>  Se voc√™ executar as mesmas consultas SQL por meio de um pool, em vez de uma conex√£o, teoricamente poder√° obter um tempo de execu√ß√£o ainda mais curto com um cliente serial comum do que quando estiver trabalhando em uma √∫nica conex√£o, seja tr√™s vezes em pipeline: </p><br><pre> <code class="plaintext hljs">| Connection | Connection 2 | Connection 3 | PostgreSQL | |----------------|----------------|----------------|-----------------| | send query 1 | | | | | | send query 2 | | process query 1 | | receive rows 1 | | send query 3 | process query 2 | | | receive rows 2 | | process query 3 | | | receive rows 3 | |</code> </pre><br><p>  Parece que a pele de carneiro (modo de transporte) n√£o vale a pena. </p><br><p>  Somente sob carga alta, o n√∫mero de conex√µes com o servidor PostgreSQL pode ser um problema. </p><br><h2 id="a-pri-chyom-tut-voobsche-kolichestvo-soedineniy">  E o que o n√∫mero de conex√µes tem a ver com isso? </h2><br><p>  O ponto aqui √© como o servidor PostgreSQL responde a um aumento no n√∫mero de conex√µes. </p><br><p>  O grupo esquerdo de colunas mostra a ascens√£o e queda do desempenho do PostgreSQL, dependendo do n√∫mero de conex√µes abertas: </p><br><p><img src="https://habrastorage.org/webt/nj/rl/io/njrlior5dxzdovhnxrv4spx8q_w.png"></p><br><p>  <em>( <a href="https://www.percona.com/blog/2018/06/27/scaling-postgresql-with-pgbouncer-you-may-need-a-connection-pooler-sooner-than-you-expect/" rel="nofollow">Adaptado do post Percona</a> )</em> </p><br><p>  Pode-se observar que, com um aumento no n√∫mero de conex√µes abertas, o desempenho do servidor PostgreSQL est√° caindo rapidamente. </p><br><p>  Al√©m disso, abrir uma conex√£o direta n√£o √© "gratuito".  Imediatamente ap√≥s a abertura, o cliente envia informa√ß√µes de servi√ßo "concorda" com o servidor PostgreSQL sobre como as solicita√ß√µes ser√£o processadas. </p><br><p>  Portanto, na pr√°tica, voc√™ deve limitar o n√∫mero de conex√µes ativas com o PostgreSQL, frequentemente passando-as adicionalmente pelo pgbouncer ou outra odiss√©ia. </p><br><h2 id="tak-pochemu-actix-web-okazalsya-bystree">  Ent√£o, por que o Actix-Web foi mais r√°pido? </h2><br><p>  Primeiro, o pr√≥prio Actix-Web √© bastante r√°pido.  √â ele quem estabelece o "teto", e ele √© um pouco mais alto que o dos outros.  Outras bibliotecas usadas (serde, yarde) tamb√©m s√£o muito, muito produtivas.  Mas parece-me que, em testes que trabalham com o PostgreSQL, foi poss√≠vel sair porque o servidor actix-web inicia um encadeamento no n√∫cleo do processador.  Cada thread abre apenas uma conex√£o com o PostgreSQL. </p><br><p>  Quanto menos conex√µes ativas, mais r√°pido o PostgreSQL funciona (veja os gr√°ficos acima). </p><br><p>  O cliente que opera no modo pipelined (tokio-postgres) permite que voc√™ use efetivamente uma conex√£o com o PostgreSQL para processamento paralelo de consultas de usu√°rios.  Os manipuladores de solicita√ß√£o HTTP despejam seus comandos SQL em uma fila e alinham em outra para receber resultados.  Os resultados s√£o divertidos, os atrasos s√£o m√≠nimos, todos est√£o felizes.  O desempenho geral √© superior a um sistema com um pool de conex√µes. </p><br><p>  Ent√£o voc√™ precisa abandonar a piscina, escrever um cliente de pipeline do PostgreSQL e a felicidade e a velocidade incr√≠vel surgir√£o imediatamente? </p><br><p>  Possivelmente.  Mas n√£o de uma s√≥ vez. </p><br><h2 id="kogda-konveyernyy-rezhim-vryad-li-spaset-i-uzh-tochno-ne-sohranit">  Quando √© improv√°vel que o modo transportador seja salvo e certamente n√£o ser√° salvo </h2><br><p>  O esquema usado no c√≥digo de refer√™ncia n√£o funcionar√° com transa√ß√µes do PostgreSQL. </p><br><p>  No benchmark, as transa√ß√µes n√£o s√£o necess√°rias e o c√≥digo √© escrito levando em considera√ß√£o que n√£o haver√° transa√ß√µes.  Na pr√°tica, eles acontecem. </p><br><p>  Se o c√≥digo de back-end abrir uma transa√ß√£o do PostgreSQL (por exemplo, para alterar at√¥micas duas tabelas diferentes), todos os comandos enviados por essa conex√£o ser√£o executados dentro dessa transa√ß√£o. </p><br><p>  Como a conex√£o com o PostgreSQL √© usada em paralelo, tudo se confunde.  Os comandos que devem ser executados em uma transa√ß√£o projetada pelo desenvolvedor s√£o combinados com comandos sql iniciados por manipuladores de solicita√ß√£o http paralelos.  Receberemos perda aleat√≥ria de dados e problemas com sua integridade. </p><br><p>  Ent√£o, ol√° transa√ß√£o - adeus uso paralelo de uma conex√£o.  Voc√™ precisar√° garantir que a conex√£o n√£o seja usada por outros manipuladores de solicita√ß√£o http.  Voc√™ precisar√° interromper o processamento de solicita√ß√µes HTTP recebidas antes de fechar a transa√ß√£o ou usar um pool para transa√ß√µes, abrindo v√°rias conex√µes com o servidor de banco de dados.  Existem v√°rias implementa√ß√µes de pool para o Rust, e n√£o uma.  Al√©m disso, eles existem no Rust separadamente da implementa√ß√£o do cliente de banco de dados.  Voc√™ pode escolher de acordo com o gosto, cor, cheiro ou aleatoriamente.  Ir n√£o funciona dessa maneira.  O poder dos gen√©ricos, sim. </p><br><p>  Um ponto importante: no teste, cujo c√≥digo eu procurei, as transa√ß√µes n√£o abrem.  Esta quest√£o simplesmente n√£o vale a pena.  O c√≥digo de refer√™ncia √© otimizado para uma tarefa espec√≠fica e condi√ß√µes operacionais muito espec√≠ficas da aplica√ß√£o.  A decis√£o de usar uma conex√£o por fluxo de servidor provavelmente foi tomada conscientemente e mostrou-se muito eficaz. </p><br><h2 id="est-v-kode-benchmarka-esche-chto-to-interesnoe">  Existe algo mais interessante no c√≥digo de refer√™ncia? </h2><br><p>  Sim </p><br><p>  O cen√°rio para medir o desempenho √© detalhado em detalhes.  Bem como os crit√©rios que o c√≥digo que participa dos testes deve atender.  Uma delas √© que todas as consultas ao servidor de banco de dados devem ser executadas seq√ºencialmente. </p><br><p>  O seguinte fragmento de c√≥digo (um pouco abreviado) parece que n√£o atende aos crit√©rios: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> worlds = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(num); <span class="hljs-comment"><span class="hljs-comment">//  num    PostgreSQL for _ in 0..num { let w_id: i32 = self.rng.gen_range(1, 10_001); worlds.push( self.cl .query(&amp;self.world, &amp;[&amp;w_id]) .into_future() .map(move |(row, _)| { // ... }), ); } //     stream::futures_unordered(worlds) .collect() .and_then(move |worlds| { // ... })</span></span></code> </pre> <br><p>  Tudo parece um lan√ßamento t√≠pico de processos paralelos.  Por√©m, como uma conex√£o com o PostgreSQL √© usada, as consultas ao servidor de banco de dados s√£o enviadas seq√ºencialmente.  Um por um.  Conforme necess√°rio.  Nenhum crime. </p><br><p>  Porque  Bem, em primeiro lugar, no c√≥digo (que foi dado na reda√ß√£o, que funcionou na 18¬™ rodada), async / wait ainda n√£o √© usado, mas apareceu em Rust mais tarde.  E, atrav√©s de futuros, √© mais f√°cil enviar consultas SQL "em paralelo" - como no c√≥digo acima.  Isso permite que voc√™ obtenha um aumento de desempenho adicional: enquanto o PostgreSQL aceita e processa a primeira consulta SQL, o restante √© alimentado a ela.  O servidor da Web n√£o espera o resultado de cada um, mas alterna para outras tarefas e retorna ao processamento da solicita√ß√£o http apenas quando todas as consultas SQL forem conclu√≠das. </p><br><p>  Para o PostgreSQL, o b√¥nus √© que o mesmo tipo de consulta no mesmo contexto (conex√£o) seja seguido.  A probabilidade de o plano de consulta n√£o ser reconstru√≠do aumenta. </p><br><p>  Acontece que as vantagens do modo de pipeline (consulte o diagrama da documenta√ß√£o do tokio-postgres) s√£o totalmente exploradas, mesmo ao processar uma √∫nica solicita√ß√£o http. </p><br><p>  O que mais? </p><br><h2 id="ispolzovanie-uproschennogo-protokola-simple-query-dlya-paketnogo-obnovleniya">  Usando o protocolo de consulta simples para atualiza√ß√µes em lote </h2><br><p>  O protocolo de comunica√ß√£o entre o cliente e o servidor PostgreSQL permite m√©todos alternativos para executar comandos SQL.  O protocolo usual (Consulta estendida) envolve o envio de v√°rias mensagens ao cliente: Analisar, Vincular, Executar e Sincronizar.  Uma alternativa √© o protocolo Simple Query, segundo o qual uma √∫nica mensagem √© suficiente para executar um comando e obter resultados - Consulta. </p><br><p>  A principal diferen√ßa entre o protocolo usual √© a transfer√™ncia de par√¢metros de solicita√ß√£o: eles s√£o transmitidos separadamente do pr√≥prio comando.  √â mais seguro  O protocolo simplificado assume que todos os par√¢metros da consulta SQL ser√£o convertidos em uma sequ√™ncia e inclu√≠dos no corpo da consulta. </p><br><p>  Uma solu√ß√£o interessante usada nos benchmarks actix-web foi atualizar v√°rias entradas da tabela com um √∫nico comando enviado pelo protocolo Simple Query. </p><br><p>  De acordo com a refer√™ncia, ao processar uma solicita√ß√£o do usu√°rio, o servidor da web deve atualizar v√°rios registros na tabela, escrever n√∫meros aleat√≥rios.  Obviamente, atualizar registros sucessivamente com consultas seq√ºenciais leva mais tempo do que uma √∫nica consulta atualizando todos os registros de uma s√≥ vez. </p><br><p>  A solicita√ß√£o gerada no c√≥digo de teste √© mais ou menos assim: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> world <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> randomnumber = temp.randomnumber <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> temp(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, randomnumber) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temp.id = world.id</code> </pre> <br><p>  Onde <code>(1, 2), (2, 3)</code> s√£o os pares de identificadores de linha / novo valor do campo n√∫mero aleat√≥rio. </p><br><p>  O n√∫mero de registros atualizados √© vari√°vel, n√£o fazendo sentido preparar a solicita√ß√£o (PREPARE) antecipadamente.  Como os dados para atualiza√ß√£o s√£o num√©ricos e a fonte pode ser confi√°vel (o pr√≥prio c√≥digo de teste), n√£o h√° risco de inje√ß√£o de SQL, os dados s√£o simplesmente inclu√≠dos no corpo do SQL e tudo √© enviado usando o protocolo Simple Query. </p><br><p>  H√° rumores de consulta simples.  Encontrei uma recomenda√ß√£o: "Trabalhe apenas no protocolo Simple Query, e tudo ser√° r√°pido e bom".  Eu a percebo com muito ceticismo.  A Consulta Simples permite reduzir o n√∫mero de mensagens enviadas ao servidor PostgreSQL movendo o processamento dos par√¢metros de consulta para o lado do cliente.  Voc√™ pode ver o ganho para consultas geradas dinamicamente com um n√∫mero vari√°vel de par√¢metros.  Para o mesmo tipo de consultas SQL (que s√£o mais comuns), o ganho n√£o √© √≥bvio.  Bem, e qu√£o seguro ser√° o processamento dos par√¢metros da consulta, no caso da Consulta Simples, ela determina a implementa√ß√£o da biblioteca do cliente. </p><br><p>  Como escrevi acima, neste caso, o corpo da consulta SQL √© gerado dinamicamente, os dados s√£o num√©ricos e gerados pelo pr√≥prio servidor.  A combina√ß√£o perfeita para consulta simples.  Mas, mesmo neste caso, vale a pena testar outras op√ß√µes.  As alternativas dependem da plataforma PostgreSQL e do cliente: o pgx (client for Go) permite enviar um pacote de comandos, JDBC - para executar um comando v√°rias vezes seguidas com par√¢metros diferentes.  Ambas as solu√ß√µes podem ser executadas na mesma velocidade ou at√© mais r√°pidas. </p><br><h2 id="tak-pochemu-rust-lidiruet">  Ent√£o, por que a Rust est√° liderando? </h2><br><p>  O l√≠der, √© claro, n√£o √© Rust.  Os testes baseados no actix-web est√£o liderando - √© ele quem define o "teto" do desempenho.  Existem, por exemplo, foguetes e ferro, que ocupam posi√ß√µes modestas.  Mas, no momento, √© o actix-web que determina o potencial de uso do Rust no desenvolvimento da web.  Quanto a mim, o potencial √© muito alto. </p><br><p>  Outro servidor "secreto" n√£o √≥bvio, mas importante, baseado no actix-web, que permitiu ocupar o primeiro lugar em todos os benchmarks do TechEmpower - em como ele funciona com o PostgreSQL: </p><br><ol><li>  Somente uma conex√£o com o PostgreSQL por fluxo do servidor da web √© aberta.  Essa conex√£o usa o modo em pipeline, o que permite que seja efetivamente usada para processamento paralelo de solicita√ß√µes de usu√°rios. </li><li>  Quanto menos conex√µes ativas, mais r√°pido o PostgreSQL responde.  A velocidade do processamento de solicita√ß√µes do usu√°rio aumenta.  Ao mesmo tempo, sob carga, todo o sistema funciona mais est√°vel (os atrasos no processamento de solicita√ß√µes de entrada s√£o mais baixos, crescem mais lentamente). </li></ol><br><p>  Onde a velocidade √© importante, essa op√ß√£o provavelmente ser√° mais r√°pida do que o uso de multiplexadores (como pgbouncer e odyssey).  E certamente ele foi mais r√°pido nos benchmarks. </p><br><p>  √â muito interessante como async / waitit, que apareceu em Rust, e o recente drama com o actix-web afetar√° a popularidade do Rust no desenvolvimento da web.  Tamb√©m √© interessante como os resultados do teste ser√£o alterados ap√≥s process√°-los no modo ass√≠ncrono / aguardado. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485452/">https://habr.com/ru/post/pt485452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485428/index.html">O misterioso programa LyX. Parte 5</a></li>
<li><a href="../pt485430/index.html">Editor de texto multiusu√°rio simples com criptografia de ponta a ponta</a></li>
<li><a href="../pt485438/index.html">Testando componentes da interface do usu√°rio do React</a></li>
<li><a href="../pt485448/index.html">Outro r√°dio FM no RDA5807 executando o Arduino</a></li>
<li><a href="../pt485450/index.html">O que h√° de novo no SObjectizer-5.7.0 e o que est√° aguardando este projeto a seguir?</a></li>
<li><a href="../pt485454/index.html">Introdu√ß√£o √†s devolu√ß√µes do usu√°rio: dicas para o modelo com gancho</a></li>
<li><a href="../pt485458/index.html">Silencioso obus</a></li>
<li><a href="../pt485460/index.html">20 bibliotecas para um aplicativo iOS espetacular</a></li>
<li><a href="../pt485462/index.html">Lidamos com eSIM (+ entrevista com um especialista)</a></li>
<li><a href="../pt485464/index.html">Meu primeiro jogo html5, de Alice Yandex e premia√ß√µes a aplicativos m√≥veis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>