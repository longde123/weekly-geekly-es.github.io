<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏻 👦🏻 🎤 Ce qui apporte la combinaison des tests manuels et automatisés: l'expérience Wrike 👶🏽 🧚🏻 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En lisant des articles sur le thème des tests Web, deux sujets apparaissent sous condition: 1) les tests manuels sont en voie de disparition, les auto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ce qui apporte la combinaison des tests manuels et automatisés: l'expérience Wrike</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wrike/blog/474216/"><img src="https://habrastorage.org/webt/jg/uo/3e/jguo3eeblu6l26megn468bzw7tw.png"><br>  En lisant des articles sur le thème des tests Web, deux sujets apparaissent sous condition: 1) les tests manuels sont en voie de disparition, les autotests (ci-après dénommés autotests sont les tests Selenium UI et REST) ​​sont notre tout;  2) les tests automatiques ne sont pas une panacée; les tests manuels sont indispensables.  Dans le même temps, les articles tendent à augmenter les exigences de qualité logicielle et de vitesse de développement des produits.  Wrike est juste le cas lorsque ces exigences sont essentielles. <br><br>  Le produit a déjà 12 ans, mais il est toujours en pleine croissance.  Les déploiements ont lieu une fois par jour, et parfois deux.  Par conséquent, il est extrêmement important pour nous que la régression soit effectuée exclusivement sur les autotests.  Cependant, à Wrike (dans l'entreprise), il y a plus de 30 équipes de mêlée, et le personnel de l'équipe d'automatisation n'est pas en caoutchouc.  Dans de telles circonstances, pour attendre au mieux l'automatisation des scénarios manuels, un ou deux sprints ne sont pas une option.  L'expérience de notre entreprise indique qu'un testeur manuel peut écrire des autotests indépendamment, sous réserve de certaines nuances.  Dans l'article, je vais en parler et pourquoi, à mon avis, cette capacité aide non seulement à suivre les tendances, mais sera également utile pour le testeur lui-même. <br><a name="habracut"></a><br><h2>  <font color="#9fd326">Processus standard</font> </h2><br><img src="https://habrastorage.org/webt/-e/ai/sw/-eaisw_2cqiyashkplwfnu3o360.png"><br>  À quel processus de nombreuses équipes sont-elles habituées?  Cela varie d'un cas à l'autre, mais les caractéristiques communes sont à peu près les mêmes.  Il existe des départements de tests automatiques et manuels.  Les testeurs manuels peuvent être répartis entre les commandes Scrum.  Dans ce cas, l'automatisation, en règle générale, n'a aucun rapport avec une équipe spécifique. <br><br>  Lorsqu'il travaille avec de nouvelles fonctionnalités, le testeur crée des scripts de test, dont certains il marque d'une manière prédéterminée pour les automates.  En outre, s'il existe déjà des cas dans lesquels des ajustements sont effectués, ils sont également notés afin de mettre à jour le code.  Les tests marqués sont ensuite transférés au service d'automatisation.  Une équipe d'ingénieurs en automatisation se charge de corriger les problèmes actuels et d'écrire de nouveaux autotests dans l'un des sprints suivants.  En plus de la programmation des scénarios de test, les tâches de l'automate comprennent l'exécution d'autotests, l'analyse des résultats, ainsi que le support et le développement du projet de test.  Il s'avère que le département d'automatisation agit comme un exécuteur externe, et les testeurs manuels sont une sorte de clients. <br><br>  Le client passe également du temps à compiler un mandat détaillé et précis, à discuter périodiquement des méthodes de mise en œuvre et à sélectionner les tests nécessaires.  Il existe également des risques que, en l'absence d'autotests, les bogues soient ignorés.  N'oubliez pas qu'il existe une couche de problèmes techniques qui ne peuvent être cumulés que sur des tests automatiques, ce qui permettrait de gagner beaucoup de temps.  Ces tâches devront être vérifiées à la main dans la partie où l'automatisation manque encore. <br><br>  L'entrepreneur, peu plongé dans les fonctionnalités de l'équipe, prendra le temps de s'immerger superficiellement dans la tâche et dans la connaissance du mandat.  Dans le même temps, il est probable que le test ne soit pas correctement traduit dans le code, car il ne vérifiera pas ce que nous souhaiterions.  En conséquence, l'efficacité de la base de test est réduite. <br><br>  L'équipe d'automatisation, étant le seul contributeur au projet de test, a un contrôle total sur sa base de code, ce qui lui permet d'être facilement développé dans toutes les directions.  Cependant, le temps pour cela devient insuffisant en raison de la charge croissante des autres équipes.  Le problème peut être résolu en augmentant le personnel, mais le coût de l'automatisation dépassera alors son efficacité.  Même si vous supprimez une partie de la charge, donnant aux testeurs manuels la possibilité d'exécuter des tests et d'analyser ceux qui sont tombés, cela n'apportera pas le bon résultat.  Comme ils ne disposent pas d'outils pour déboguer les tests, ils peuvent ne pas comprendre que le test a planté en raison d'un changement de xpath et ainsi de suite. <br><br>  En conséquence, à la sortie, nous obtenons que les autotests avec ce schéma ne suivent pas la croissance du produit, ce qui conduit à une mauvaise couverture du code.  En raison d'une interprétation inexacte des savoirs traditionnels, les tests peuvent ignorer les bogues.  Lorsqu'ils sont obsolètes depuis longtemps, ceux qui sont tombés ne sont pas réparés immédiatement, et il est difficile pour les testeurs manuels de déterminer immédiatement quelle partie du système est bien couverte par l'automatisation.  Les autotests deviennent une sorte de boîte noire, à laquelle les testeurs se méfient.  Par conséquent, le nombre de vérifications manuelles inutiles augmente, les termes des tâches sont allongés et la qualité diminue à long terme. <br><br>  Vous pouvez travailler avec ces lacunes, mais plus le produit et l'entreprise sont grands, plus les participants au processus sont pénibles et, surtout, il est difficile de suivre la tendance à l'augmentation de la vitesse et à l'amélioration de la qualité.  Le testeur lui-même devient otage de la routine et ne reste pratiquement pas sur le développement du temps. <br><br><h2>  <font color="#9fd326">Wrike way</font> </h2><br><img src="https://habrastorage.org/webt/aw/1s/s5/aw1ss5krkgydvvudfelgilp-bvu.png"><br>  Alors, comment ça marche sur l'exemple de l'équipe dans laquelle je travaille.  Il existe des équipes de tests automatiques et manuels.  Les données initiales sont toujours similaires, mais les différences commencent alors.  Les testeurs manuels sont répartis entre leurs équipes de mêlée.  Chaque équipe Scrum a son propre autotesteur.  Parfois, il peut être attribué non pas à une mais à deux équipes, si la charge le permet. <br><br>  Lorsqu'il travaille avec de nouvelles fonctionnalités, le testeur rédige des listes de contrôle, selon lesquelles il effectue ensuite des contrôles manuels.  La partie minimale requise des tests de cette liste de contrôle est automatisée.  Le testeur écrit lui-même ces autotests au moment où la fonctionnalité est en cours de développement ou de test.  De plus, le code écrit est remis au réviseur pour révision.  À de rares exceptions près, une tâche sans autotests ne peut pas être émise. <br><br>  Bien sûr, Wrike n'est pas obligé d'écrire des autotests par des testeurs manuels.  Cela reste à la discrétion de l'équipe.  Vous pouvez tout donner à l'automatisation.  Vous pouvez vous limiter à réparer les tests interrompus et / ou à écrire de nouveaux tests par analogie, et déléguer des tâches plus complexes (création de nouveaux tests ou extension d'anciennes poignées principales, objet de page ou étapes et classes de test) à un outil d'automatisation dédié.  Tout dépend de vous, mais il est stupide de passer à côté des avantages qu'offre l'écriture indépendante de tests automatiques. <br><br>  Toute notre régression est basée sur des autotests, et les responsabilités des testeurs manuels incluent l'exécution et l'analyse des échecs d'autotest.  Pour chaque branche sur laquelle l'équipe travaille, ils effectuent des auto-tests en tant que garant initial et final de la qualité.  Par conséquent, il est beaucoup plus facile pour ceux qui écrivent eux-mêmes les autotests de comprendre pourquoi un test exécuté sur leur branche s'est écrasé.  Parfois, des outils tels que la réexécution et un rapport dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allure sont</a> vraiment suffisants, où vous pouvez comprendre la raison de l'échec du test à partir de la capture d'écran et des étapes.  Cependant, le meilleur assistant est souvent la possibilité d'exécuter des tests localement, de jouer avec les étapes ou de les exécuter en mode débogage, voir le xpath attendu et réel.  Sans expérience de travail avec un projet de test, cela prendra beaucoup de temps ou il faudra distraire l'outil d'automatisation dédié. <br><br>  De plus, l'écriture indépendante des autotests permet de les exécuter avant même la sortie de la fonctionnalité.  Le testeur connaît toujours le degré de couverture de sa partie du système, et les tâches techniques se déroulent uniquement lors des tests automatiques, ce qui économise considérablement du temps et des ressources pour l'équipe.  Les tests eux-mêmes sont toujours pertinents, car les plantages sont ajustés avant la publication.  Les tests cassés sont corrigés immédiatement dans la même branche où de nouveaux sont écrits. <br><br>  Le testeur manuel est immergé au maximum dans la tâche de l'équipe, par conséquent, le minimum nécessaire de tests automatiques est sélectionné, couvrant la plupart des cas.  L'échantillon est révisé plusieurs fois pendant le test, car lors des vérifications manuelles, la fonctionnalité est étudiée plus en détail avec toutes les nuances.  En conséquence, l'efficacité de ces tests augmente.  L'écriture d'autotests vous permet de mieux comprendre l'architecture de l'application, les composants utilisés et l'interaction front-end avec le back-end.  En fin de compte, ces connaissances aident à une approche plus consciente et plus efficace des tests de produits.  Par exemple, si une commande apporte des modifications au composant général, il est plus probable que vous sachiez à l'avance si votre portée sera ou non affectée, car lorsque vous travaillez avec xpath, vous comprenez quels composants sont utilisés dans votre partie de l'application. <br><br>  On peut soutenir que l'écriture des autotests prend du temps.  Oui, les tâches seront publiées un à trois jours plus tard que d'habitude, mais à long terme, cela rapporte.  De plus, il existe des méthodes d'optimisation.  Par exemple, pendant qu'une fonctionnalité est en cours de développement, vous pouvez établir les listes de contrôle nécessaires et faire un blanc pour les tests, ce qui permet de gagner du temps.  Si vous disposez d'une infrastructure de fonctionnalités prête à l'emploi, il est possible d'ajouter ou de corriger des xpath existants, si nécessaire, de créer un nouvel objet Page ou d'ajuster les étapes.  Ensuite, au stade de l'écriture des autotests, après des vérifications manuelles, il vous suffit d'ajouter les blocs de code dans le bon ordre. <br><br>  Grâce au framework développé par notre équipe d'automatisation, l'écriture d'autotests représente pour la plupart la compilation de code à partir de blocs - comme Lego.  Cette simplicité vous permet de vous adapter rapidement aux testeurs manuels et de commencer à écrire des autotests par analogie avec ceux existants.  D'après ma propre expérience, je dirai qu'il a fallu environ deux semaines entre le moment où je suis allé travailler chez Wrike et les premiers autotests que j'ai écrits, ainsi que d'autres tâches. <br><br>  Le contrôle de la qualité des tests automatisés écrits est effectué par la révision du code.  Pas une seule branche de test n'entre dans la version sans examen.  C'est un bon moment de formation, car le testeur tire des informations utiles des commentaires sur son code et construit l'expérience de bonnes solutions: par exemple, il gère plus efficacement la bibliothèque Java standard ou définit xpath plus précisément.  La prochaine fois, il sera clair comment travailler au mieux avec une situation particulière. <br><br>  Bien sûr, le développement d'un projet de test, d'un framework, et la formation de testeurs manuels prennent les moyens de l'automatisation, surtout au stade initial, mais il me semble que ces efforts sont pleinement récompensés.  Nous avons de nombreuses améliorations dans l'environnement de test automatisé qui facilitent notre travail.  Le produit lui-même a une bonne couverture, vous pouvez donc compter sur la régression.  Cela permet d'accélérer le processus de déploiement des fonctionnalités dans l'environnement utilisateur et protège considérablement les nerfs des testeurs. <br><br>  Selon l'expérience de notre équipe, c'est l'un des meilleurs processus pour travailler avec un produit volumineux et en développement rapide dans une grande entreprise.  De plus, il est conforme aux tendances actuelles en matière d'amélioration de la qualité des logiciels et de la rapidité de leur livraison aux utilisateurs.  Le testeur lui-même se débarrasse pratiquement de la routine, se développe dans plusieurs directions et regarde l'application sous plusieurs angles. <br><br><h2>  <font color="#9fd326">En bref sur l'essentiel</font> </h2><br>  Pour plus de commodité, je vais souligner les avantages d'un testeur manuel en un seul endroit, afin qu'il soit plus facile de réaliser leur signification individuellement ou tous ensemble: <br><br><ul><li>  Une image plus complète se forme sur le niveau et la qualité de l'automatisation de vos oscilloscopes; </li><li>  Les autotests sont disponibles avant la sortie de la fonctionnalité, ce qui permet de vérifier rapidement sa qualité à tout moment; </li><li>  L'efficacité des autotests augmente, tout comme l'efficacité des tests en général; </li><li>  Une approche plus éclairée et plus efficace des tests est en cours d'élaboration; </li><li>  Se débarrasser des régressions manuelles monotones et des longs tests d'évaluation; </li><li>  Croissance personnelle et développement des compétences. </li></ul><br><h2>  <font color="#9fd326">Pour résumer</font> </h2><br>  Bien sûr, il n'y a pas de solution miracle.  Ce qui convient à une entreprise peut être fortement rejeté par une autre.  Dans le cas de Wrike, le produit se développe extrêmement rapidement et il n'y a pas de temps pour de longues régressions manuelles et des tests d'évaluation.  Nous avons ce rôle joué par les autotests, qui couvrent presque tous les composants d'un énorme produit.  Cela permet de maintenir la qualité, d'optimiser les ressources et de fournir plus rapidement de nouvelles fonctionnalités aux utilisateurs. <br><br>  La mauvaise nouvelle est qu'elle ne peut pas se passer de bugs, mais dans notre cas, le plus souvent, ce sont des cas extrêmes.  La bonne nouvelle est que les bogues lors des corrections sont également envahis par les autotests. <br>  Pour une raison quelconque, il est devenu si courant dans la communauté que l'idée d'écrire des autotests par des testeurs manuels est rejetée.  Il y a deux arguments les plus populaires de la part des testeurs: "Ils ne paient pas de supplément pour cela" et "Nous avons déjà assez de travail."  Pour moi personnellement, les deux arguments s'effondrent lorsque je me rends compte que je peux exécuter des auto-tests au moment où une fonctionnalité est développée et en peu de temps comprendre comment cela fonctionne correctement.  Ça vaut beaucoup.  Notre travail consiste à améliorer et à maintenir la qualité du produit, afin que chaque opportunité soit utilisée pour le faciliter.  À partir du moment où j'ai commencé à écrire des autotests, la routine de mon travail est devenue de moins en moins consciente. <br><br>  PS Cet article ne reflète que l'expérience de notre équipe et peut ne pas correspondre à vos convictions.  Par conséquent, je serai heureux de connaître les approches qui vous guident dans votre travail.  Je serai également satisfait de critiques saines et de la possibilité de discuter de l'article dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474216/">https://habr.com/ru/post/fr474216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474200/index.html">Windows Terminal Preview 1910 Release</a></li>
<li><a href="../fr474202/index.html">Le succès n'est pas sans l'aide de quelqu'un d'autre: comment «faire grandir» un projet fini pour le marché grâce à un pré-accélérateur</a></li>
<li><a href="../fr474204/index.html">Dites un mot sur les différentes tiques ou comment ne pas obtenir d'erreur dans Powershell lorsque vous travaillez avec Get-Date</a></li>
<li><a href="../fr474208/index.html">Longhorn, Rancher a distribué le stockage des K8, transféré à la CNCF</a></li>
<li><a href="../fr474212/index.html">Python dans un mois</a></li>
<li><a href="../fr474220/index.html">Habr Weekly # 25 / Travail d'équipe informel, employés autistes et critique des télégrammes</a></li>
<li><a href="../fr474222/index.html">Yurchik - un petit mais formidable mutant (histoire N.-F.)</a></li>
<li><a href="../fr474224/index.html">Kotlin vs Swift: Android et iOS évoluent-ils vers un langage universel?</a></li>
<li><a href="../fr474226/index.html">Présentation d'Orléans 3.0</a></li>
<li><a href="../fr474228/index.html">Une licence de projet open source qui oblige les utilisateurs à «ne pas nuire»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>