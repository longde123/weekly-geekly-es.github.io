<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–ğŸ½ ğŸ¥ ğŸ´ Kami merumuskan strategi untuk bekerja dengan kesalahan dalam Bereaksi ğŸ‘‡ğŸ¾ ğŸ¤°ğŸ» ğŸŒ‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara membuat jatuh lembut? 


 Saya tidak menemukan panduan komprehensif untuk penanganan kesalahan dalam aplikasi Bereaksi, jadi saya memut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami merumuskan strategi untuk bekerja dengan kesalahan dalam Bereaksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476284/"><h2>  Bagaimana cara membuat jatuh lembut? </h2><br><img src="https://habrastorage.org/webt/74/fa/c-/74fac--ati8ide9e4o946p1r-4g.jpeg"><br><br>  Saya tidak menemukan panduan komprehensif untuk penanganan kesalahan dalam aplikasi Bereaksi, jadi saya memutuskan untuk berbagi pengalaman yang diperoleh dalam artikel ini.  Artikel ini ditujukan untuk pengembang pemula dan dapat menjadi titik awal untuk mensistematisasikan penanganan kesalahan dalam aplikasi. <br><a name="habracut"></a><br><h3>  Masalah dan Penentuan Sasaran </h3><br>  Senin pagi, Anda dengan tenang minum kopi dan membanggakan bahwa Anda telah memperbaiki lebih banyak bug daripada minggu lalu dan kemudian manajer datang berlari dan melambaikan tangannya - â€œkami jatuh, semuanya sangat sedih, kami kehilangan uangâ€.  Anda menjalankan dan membuka Mac Anda, pergi ke versi produksi SPA Anda, buat beberapa klik untuk memutar bug, lihat layar putih dan hanya Yang Mahakuasa yang tahu apa yang terjadi di sana, naik ke konsol, mulai menggali, di dalam komponen t ada komponen dengan nama yang berbicara b, di mana kesalahan tidak dapat membaca getId properti dari undefined.  N jam penelitian dan Anda bergegas dengan teriakan menang untuk melempar hotfix.  Penggerebekan semacam itu terjadi dengan beberapa frekuensi dan telah menjadi norma, tetapi bagaimana jika saya mengatakan bahwa semuanya bisa berbeda?  Bagaimana cara mengurangi waktu untuk kesalahan debug dan membangun proses sehingga klien secara praktis tidak melihat kesalahan perhitungan selama pengembangan yang tidak terhindarkan? <br><br>  <b>Mari kita periksa agar masalah yang kita hadapi:</b> <br><br><ol><li>  <u>Bahkan jika kesalahan tidak signifikan atau terlokalisasi dalam modul, dalam hal apapun seluruh aplikasi menjadi tidak beroperasi</u> <br>  Sebelum Bereaksi versi 16, pengembang tidak memiliki mekanisme perangkap kesalahan standar tunggal, dan ada situasi ketika korupsi data menyebabkan penurunan rendering hanya pada langkah berikutnya atau perilaku aplikasi aneh.  Setiap pengembang menangani kesalahan karena ia terbiasa dengan hal itu, dan model imperatif dengan coba / tangkap umumnya tidak sesuai dengan prinsip deklaratif Bereaksi.  Di versi 16, alat Batas Batas muncul, yang mencoba menyelesaikan masalah ini, kami akan mempertimbangkan cara menerapkannya. </li><li>  <u>Kesalahan hanya direproduksi di lingkungan produksi atau tidak dapat direproduksi tanpa data tambahan.</u> <br>  Di dunia yang ideal, lingkungan pengembangan sama dengan produksi, dan kami dapat mereproduksi bug apa pun secara lokal, tetapi kami hidup di dunia nyata.  Tidak ada alat debugging pada sistem pertempuran.  Sulit dan tidak produktif untuk menggali kejadian seperti itu, pada dasarnya Anda harus berurusan dengan kode yang dikaburkan dan kurangnya informasi tentang kesalahan, dan bukan dengan esensi masalah.  Kami tidak akan mempertimbangkan masalah tentang cara memperkirakan kondisi lingkungan pengembangan dengan kondisi produksi, namun, kami akan mempertimbangkan alat yang memungkinkan Anda untuk mendapatkan informasi terperinci tentang insiden yang telah terjadi. </li></ol><br>  Semua ini mengurangi kecepatan pengembangan dan loyalitas pengguna terhadap produk perangkat lunak, jadi saya menetapkan sendiri 3 tujuan paling penting: <br><br><ol><li>  Tingkatkan pengalaman pengguna dengan aplikasi jika terjadi kesalahan; </li><li>  Kurangi waktu antara kesalahan masuk ke produksi dan deteksi; </li><li>  Mempercepat proses menemukan dan men-debug masalah dalam aplikasi untuk pengembang. </li></ol><br>  <b>Tugas apa yang perlu diselesaikan?</b> <br><br><ol><li>  <u>Menangani kesalahan kritis dengan Batas Kesalahan</u> <br>  Untuk meningkatkan pengalaman pengguna dengan aplikasi, kita harus mencegat kesalahan UI kritis dan memprosesnya.  Dalam kasus di mana aplikasi terdiri dari komponen independen, strategi seperti itu akan memungkinkan pengguna untuk bekerja dengan seluruh sistem.  Kami juga dapat mencoba mengambil langkah untuk memulihkan aplikasi setelah macet, jika memungkinkan. <br></li><li>  <u>Simpan informasi kesalahan yang diperluas</u> <br>  Jika terjadi kesalahan, kirim informasi debug ke server pemantauan, yang akan memfilter, menyimpan, dan menampilkan informasi tentang insiden.  Ini akan membantu kami dengan cepat mendeteksi dan men-debug kesalahan dengan mudah setelah pemasangan. <br></li></ol><br>  <b>Penanganan kesalahan kritis</b> <br><br>  Dimulai dengan versi 16, React telah mengubah perilaku penanganan kesalahan standar.  Sekarang, pengecualian yang tidak tertangkap menggunakan Boundary Kesalahan akan menyebabkan unmount seluruh pohon Bereaksi dan, sebagai akibatnya, menjadi tidak dapat dijalankannya seluruh aplikasi.  Keputusan ini diperdebatkan oleh fakta bahwa lebih baik tidak menunjukkan apa pun daripada memberi pengguna kesempatan untuk mendapatkan hasil yang tidak terduga.  Anda dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi Bereaksi resmi</a> . <br><br><img src="https://habrastorage.org/webt/jz/-o/ik/jz-oik4v7a3skcbdxn_pttvugq8.png"><br><br>  Juga, banyak yang bingung dengan catatan bahwa Batas Kesalahan tidak menangkap kesalahan dari penangan acara dan kode asinkron, tetapi jika Anda memikirkannya, penangan mana pun akhirnya dapat mengubah keadaan, berdasarkan pada mana siklus render baru akan dipanggil, yang pada akhirnya akun dapat menyebabkan kesalahan dalam kode UI.  Kalau tidak, ini bukan kesalahan kritis untuk UI dan dapat ditangani dengan cara tertentu di dalam handler. <br><br>  Dari sudut pandang kami, kesalahan kritis adalah pengecualian yang terjadi di dalam kode UI dan jika tidak diproses, maka seluruh pohon Bereaksi akan di-unmount.  Kesalahan yang tersisa tidak kritis dan dapat diproses sesuai dengan logika aplikasi, misalnya, menggunakan notifikasi. <br><br>  Dalam artikel ini, kami akan fokus pada penanganan kesalahan kritis, meskipun fakta bahwa kesalahan tidak kritis juga dapat menyebabkan ketidakmampuan antarmuka dalam kasus terburuk.  Pemrosesan mereka sulit untuk dipisahkan menjadi blok umum dan setiap kasus individu memerlukan keputusan tergantung pada logika aplikasi. <br><br>  Secara umum, kesalahan non-kritis bisa sangat kritis (seperti pelesetan), sehingga informasi tentang mereka harus dicatat dengan cara yang sama seperti untuk kesalahan yang kritis. <br><br>  Sekarang kami sedang merancang Batas Kesalahan untuk aplikasi sederhana kami, ini akan terdiri dari bilah navigasi, header, dan ruang kerja utama.  Cukup sederhana untuk fokus hanya pada penanganan kesalahan, tetapi memiliki struktur khas untuk banyak aplikasi. <br><br><img src="https://habrastorage.org/webt/q6/my/hd/q6myhdx0kjcwrwxe2q7b3sxdweu.png"><br><br>  Kami memiliki panel navigasi yang terdiri dari 3 tautan, yang masing-masing mengarah ke komponen yang tidak saling bergantung satu sama lain, sehingga kami ingin mencapai perilaku sedemikian sehingga bahkan jika salah satu komponen tidak berfungsi, kami dapat terus bekerja dengan yang lain. <br><br>  Akibatnya, kami akan memiliki ErrorBoundary untuk setiap komponen yang dapat diakses melalui menu navigasi dan ErrorBoundary umum, yang menginformasikan tentang jatuhnya seluruh aplikasi, jika terjadi kesalahan pada komponen header, panel nav atau di dalam ErrorBoundary, tetapi kami tidak menyelesaikannya proses dan buang lebih lanjut. <br><br>  Pertimbangkan untuk mendaftarkan seluruh aplikasi yang dibungkus dengan ErrorBoundary <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppWithBoundary = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">errorMessage</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Application has crashed"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    &lt;Router&gt;      &lt;Layout&gt;        &lt;Sider width={200}&gt;          &lt;SideNavigation /&gt;        &lt;/Sider&gt;        &lt;Layout&gt;          &lt;Header&gt;            &lt;ActionPanel /&gt;          &lt;/Header&gt;          &lt;Content&gt;            &lt;Switch&gt;              &lt;Route path="/link1"&gt;                &lt;Page1                  title="Link 1 content page"                  errorMessage="Page for link 1 crashed"                /&gt;              &lt;/Route&gt;              &lt;Route path="/link2"&gt;                &lt;Page2                  title="Link 2 content page"                  errorMessage="Page for link 2 crashed"                /&gt;              &lt;/Route&gt;              &lt;Route path="/link3"&gt;                &lt;Page3                  title="Link 3 content page"                  errorMessage="Page for link 3 crashed"                /&gt;              &lt;/Route&gt;              &lt;Route path="/"&gt;                &lt;MainPage                  title="Main page"                  errorMessage="Only main page crashed"                /&gt;              &lt;/Route&gt;            &lt;/Switch&gt;          &lt;/Content&gt;        &lt;/Layout&gt;      &lt;/Layout&gt;    &lt;/Router&gt;  ); }</code> </pre> <br>  Tidak ada keajaiban di ErrorBoundary, itu hanya komponen kelas di mana metode componentDidCatch didefinisikan, yaitu komponen apa pun dapat dibuat ErrorBoundary, jika Anda mendefinisikan metode ini di dalamnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorBoundary</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{  state = {    <span class="hljs-attr"><span class="hljs-attr">hasError</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,  }  componentDidCatch(error) {    <span class="hljs-comment"><span class="hljs-comment">//            this.setState({ hasError: true });  }  render() {    if (this.state.hasError) {      return (        &lt;Result          status="warning"          title={this.props.errorMessage}          extra={            &lt;Button type="primary" key="console"&gt;              Some action to recover            &lt;/Button&gt;          }  /&gt;      );    }    return this.props.children;  } };</span></span></code> </pre><br>  Inilah yang tampak seperti ErrorBoundary untuk komponen Halaman, yang akan dirender ke dalam blok Konten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageBody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ title }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  &lt;Content title={title}&gt;    &lt;Empty className="content-empty" /&gt;  &lt;/Content&gt; ); const MainPage = ({ errorMessage, title }) =&gt; (  &lt;ErrorBoundary errorMessage={errorMessage}&gt;    &lt;PageBody title={title} /&gt;  &lt;/ErrorBoundary&gt;</code> </pre><br>  Karena ErrorBoundary adalah komponen Bereaksi reguler, kita dapat menggunakan komponen ErrorBoundary yang sama untuk membungkus setiap halaman dalam handlernya sendiri, cukup dengan memberikan parameter yang berbeda ke ErrorBoundary, karena ini adalah contoh yang berbeda dari kelas, keadaan mereka tidak akan saling bergantung satu sama lain . <br><br>  <b>PENTING: ErrorBoundary hanya dapat menangkap kesalahan dalam komponen yang ada di bawahnya di hierarki.</b> <br><br>  Dalam daftar di bawah ini, kesalahan tidak akan dicegat oleh ErrorBoundary lokal, tetapi akan dibuang dan dicegat oleh pawang di atas pohon: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ errorMessage }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">errorMessage</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{errorMessage}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    {null.toString()}  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre><br>  Dan di sini kesalahan ditangkap oleh ErrorBoundary lokal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrorProneComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>.toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ errorMessage }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">errorMessage</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{errorMessage}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorProneComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ErrorBoundary</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br>  Setelah membungkus setiap komponen yang terpisah di ErrorBoundary kami, kami mencapai perilaku yang diperlukan, memasukkan kode yang keliru dengan sengaja ke dalam komponen menggunakan tautan3 dan melihat apa yang terjadi.  Kami sengaja lupa untuk melewati parameter langkah-langkah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageBody = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ title, steps }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  &lt;Content title={title}&gt;    &lt;Steps current={2} direction="vertical"&gt;      {steps.map(({ title, description }) =&gt; (&lt;Step title={title} description={description} /&gt;))}    &lt;/Steps&gt;  &lt;/Content&gt; ); const Page = ({ errorMessage, title }) =&gt; (  &lt;ErrorBoundary errorMessage={errorMessage}&gt;    &lt;PageBody title={title} /&gt;  &lt;/ErrorBoundary&gt; );</code> </pre><br><img src="https://habrastorage.org/webt/6g/9g/fv/6g9gfvuuusmxrbedlytcmezyghe.png"><br><br>  Aplikasi akan memberi tahu kami bahwa telah terjadi kesalahan, tetapi tidak akan sepenuhnya jatuh, kami dapat menavigasi menu navigasi dan bekerja dengan bagian lain. <br><br><img src="https://habrastorage.org/webt/4w/os/zh/4woszhf9ahhcl-uzdfwthj-d6a0.png"><br><br>  Konfigurasi yang sedemikian sederhana memungkinkan kita untuk dengan mudah mencapai tujuan kita, tetapi dalam praktiknya, hanya sedikit orang yang memperhatikan penanganan kesalahan, hanya merencanakan eksekusi aplikasi secara teratur. <br><br>  <b>Menyimpan Informasi Kesalahan</b> <br><br>  Sekarang kita telah menempatkan cukup ErrorBoundary di aplikasi kita, maka perlu untuk menyimpan informasi tentang kesalahan untuk mendeteksi dan memperbaikinya secepat mungkin.  Cara termudah adalah dengan menggunakan layanan SaaS, seperti Sentry atau Rollbar.  Mereka memiliki fungsi yang sangat mirip, sehingga Anda dapat menggunakan layanan pemantauan kesalahan apa pun. <br><br>  Saya akan menunjukkan contoh dasar pada Sentry, karena hanya dalam satu menit Anda bisa mendapatkan fungsionalitas minimal.  Pada saat yang sama, Sentry sendiri menangkap pengecualian dan bahkan memodifikasi console.log untuk mendapatkan semua informasi kesalahan.  Setelah itu, semua kesalahan yang akan terjadi dalam aplikasi akan dikirim dan disimpan di server.  Sentry memiliki mekanisme untuk menyaring acara, mengaburkan data pribadi, menautkan ke rilis, dan banyak lagi.  Kami hanya akan mempertimbangkan skenario integrasi dasar. <br><br>  Untuk terhubung, Anda harus mendaftar di situs web resmi mereka dan pergi melalui panduan memulai cepat, yang akan segera mengarahkan Anda setelah pendaftaran. <br><br>  Dalam aplikasi kami, kami hanya menambahkan beberapa baris dan semuanya lepas landas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Sentry <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@sentry/browser'</span></span>; Sentry.init({<span class="hljs-attr"><span class="hljs-attr">dsn</span></span>: â€œhttps:<span class="hljs-comment"><span class="hljs-comment">//12345f@sentry.io/12345â€});</span></span></code> </pre><br>  Sekali lagi, klik pada tautan / tautan3 di aplikasi kita dan dapatkan layar kesalahan, setelah itu kita pergi ke antarmuka penjaga, tampaknya suatu peristiwa telah terjadi dan gagal di dalam. <br><br><img src="https://habrastorage.org/webt/qx/4p/bm/qx4pbm5d1dgv3gvxpabgeydwpoa.png"><br><br>  Kesalahan secara otomatis dikelompokkan berdasarkan jenis, frekuensi dan waktu terjadinya, berbagai filter dapat diterapkan.  Kami memiliki satu peristiwa - kami jatuh ke dalamnya dan di layar berikutnya kami melihat banyak informasi yang berguna, misalnya, tumpukan jejak <br><br><img src="https://habrastorage.org/webt/bq/o8/ed/bqo8ed5grqrsme3yw8wa4rftwhu.png"><br><br>  dan tindakan pengguna terakhir sebelum kesalahan (remah roti). <br><br><img src="https://habrastorage.org/webt/bq/o8/ed/bqo8ed5grqrsme3yw8wa4rftwhu.png"><br><br>  Bahkan dengan konfigurasi yang sederhana, kami dapat mengakumulasi dan menganalisis informasi kesalahan dan menggunakannya untuk debugging lebih lanjut.  Dalam contoh ini, kesalahan dikirim dari klien dalam mode pengembangan, sehingga kami dapat mengamati informasi lengkap tentang komponen dan kesalahan.  Untuk mendapatkan informasi serupa dari mode produksi, Anda juga harus mengkonfigurasi sinkronisasi data rilis dengan Sentry, yang akan menyimpan sourcemap itu sendiri, sehingga Anda dapat menyimpan informasi yang cukup tanpa menambah ukuran bundel.  Kami tidak akan mempertimbangkan konfigurasi seperti itu dalam kerangka artikel ini, tetapi saya akan mencoba untuk berbicara tentang jebakan solusi semacam itu dalam artikel terpisah setelah penerapannya. <br><br>  <b>Hasilnya:</b> <br><br>  Penanganan kesalahan menggunakan ErrorBoundary memungkinkan kita untuk memperhalus sudut dengan sebagian crash aplikasi, sehingga meningkatkan pengalaman pengguna sistem, dan penggunaan sistem pemantauan kesalahan khusus untuk mengurangi waktu deteksi dan debugging masalah. <br><br>  Dengan hati-hati memikirkan strategi untuk memproses dan memantau kesalahan aplikasi Anda, di masa depan ini akan menghemat banyak waktu dan usaha.  <b>Strategi yang dipikirkan dengan matang terutama akan meningkatkan proses bekerja dengan insiden, dan hanya dengan demikian akan mempengaruhi struktur kode.</b> <br><br>  <i>PS</i> Anda dapat mencoba berbagai opsi konfigurasi ErrorBoundary atau menghubungkan Sentry ke aplikasi sendiri di cabang feature_sentry, mengganti kunci dengan yang diperoleh saat pendaftaran di situs. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi demo Git-hub</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Batas Kesalahan resmi React</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476284/">https://habr.com/ru/post/id476284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476270/index.html">Kemenangan kami: TopCoder Open 2019</a></li>
<li><a href="../id476272/index.html">Jawaban untuk tugas-tugas dari stan PVS-Studio di konferensi 2018-2019</a></li>
<li><a href="../id476276/index.html">Menulis penyeimbang sederhana di Go</a></li>
<li><a href="../id476278/index.html">Konferensi BLACK HAT USA. Kaya atau mati: hasilkan uang di Internet menggunakan Black Hat. Bagian 3</a></li>
<li><a href="../id476280/index.html">Melalui duri ke DOS: empat floppy disk yang mengubah dunia</a></li>
<li><a href="../id476286/index.html">5 kerangka JS Top untuk pengembangan front-end pada tahun 2020. Bagian 1</a></li>
<li><a href="../id476288/index.html">5 kerangka JS Top untuk pengembangan front-end pada tahun 2020. Bagian 2</a></li>
<li><a href="../id476290/index.html">Kesalahan dalam Menangani Express</a></li>
<li><a href="../id476292/index.html">SVG atau kanvas?</a></li>
<li><a href="../id476294/index.html">Jaringan game yang didistribusikan sebagai alternatif untuk GFN: bagaimana dan mengapa itu bisa lepas landas, di mana ia sudah bekerja di Federasi Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>