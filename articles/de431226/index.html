<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèΩ üöØ üë´ Das Snake-Spiel f√ºr FPGA Cyclone IV (mit VGA- und SPI-Joystick) üòõ üéÑ üì°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Erinnerst du dich an das Schlangenspiel aus der Kindheit, bei dem eine Schlange auf dem Bildschirm l√§uft und versucht, einen Apfel zu e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Snake-Spiel f√ºr FPGA Cyclone IV (mit VGA- und SPI-Joystick)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431226/"><h2 id="introduction">  Einf√ºhrung </h2><br><p>  Erinnerst du dich an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlangenspiel</a> aus der Kindheit, bei dem eine Schlange auf dem Bildschirm l√§uft und versucht, einen Apfel zu essen?  Dieser Artikel beschreibt unsere Implementierung des Spiels auf einem FPGA <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a></sup> . </p><br><p><img src="https://github.com/Sitiritis/SnakeGame_FPGA/blob/master/text/img/gameplay.gif?raw=true" alt="Gameplay.gif"><br>  <strong>Abbildung 1.</strong> Gameplay </p><a name="habracut"></a><br><p>  Stellen wir uns zun√§chst vor und erl√§utern die Gr√ºnde, warum wir an dem Projekt gearbeitet haben.  Wir sind zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritt</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tymur Lysenko</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daniil Manakovskiy</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sergey Makarov</a> .  Als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studienanf√§nger</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Innopolis University</a> hatten wir einen Kurs in "Computerarchitektur", der professionell unterrichtet wird und es dem Lernenden erm√∂glicht, die Struktur eines Computers auf niedriger Ebene zu verstehen.  Irgendwann w√§hrend des Kurses gaben uns die Instruktoren die M√∂glichkeit, ein Projekt f√ºr ein FPGA f√ºr zus√§tzliche Punkte im Kurs zu entwickeln.  Unsere Motivation war nicht nur die Note, sondern auch unser Interesse, mehr Erfahrung im Hardware-Design zu sammeln, die Ergebnisse zu teilen und schlie√ülich ein unterhaltsames Spiel zu haben. </p><br><p>  Lassen Sie uns nun auf dunkle, tiefe Details eingehen. </p><br><h2 id="project-overview">  Projekt√ºbersicht </h2><br><p>  F√ºr unser Projekt haben wir ein einfach zu implementierendes und unterhaltsames Spiel ausgew√§hlt, n√§mlich die "Schlange".  Die Struktur der Implementierung sieht wie folgt aus: Zuerst wird eine Eingabe von einem SPI-Joystick genommen, dann verarbeitet, und schlie√ülich wird ein Bild an einen VGA-Monitor ausgegeben und eine Punktzahl wird auf einer 7-Segment-Anzeige (in hexadezimaler Darstellung) angezeigt.  Obwohl die Spielelogik intuitiv und unkompliziert ist, waren VGA und der Joystick interessante Herausforderungen und ihre Implementierung hat zu einem guten Spielerlebnis gef√ºhrt. </p><br><p>  Das Spiel hat die folgenden Regeln.  Ein Spieler beginnt mit einem einzelnen Schlangenkopf.  Das Ziel ist es, √Ñpfel zu essen, die zuf√§llig auf dem Bildschirm erzeugt werden, nachdem der vorherige gegessen wurde.  Au√üerdem wird die Schlange nach Befriedigung des Hungers um 1 Schwanz verl√§ngert.  Die Schw√§nze bewegen sich nacheinander und folgen dem Kopf.  Die Schlange bewegt sich immer.  Wenn die Bildschirmr√§nder erreicht sind, wird die Schlange auf eine andere Seite des Bildschirms √ºbertragen.  Wenn der Kopf den Schwanz trifft, ist das Spiel vorbei. </p><br><h2 id="tools-used">  Verwendete Werkzeuge </h2><br><ul><li>  Altera Cyclone IV (EP4CE6E22C8N) mit 6272 logischen Elementen, integriertem 50-MHz-Takt, 3-Bit-Farb-VGA, 8-stelliger 7-Segment-Anzeige.  Das FPGA kann keinen analogen Eingang an seine Pins anschlie√üen. </li><li>  SPI-Joystick (KY-023) </li><li>  Ein VGA-Monitor, der eine Bildwiederholfrequenz von 60 Hz unterst√ºtzt </li><li>  Quartus Prime Lite Edition 18.0.0 Build 614 </li><li>  Verilog HDL IEEE 1364-2001 </li><li>  Steckbrett </li><li>  Elektrische Elemente: <br><ul><li>  8 Stecker-Buchsen </li><li>  1 Buchse-Buchse </li><li>  1 Stecker-Stecker </li><li>  4 Widerst√§nde (4,7 KŒ©) </li></ul></li></ul><br><h2 id="architecture-overview">  Architektur√ºbersicht </h2><br><p>  Die Architektur des Projekts ist ein wichtiger Faktor.  Abbildung 2 zeigt diese Architektur aus Sicht der obersten Ebene: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c92/2a4/4b2/c922a44b20cdc085b7061e7b5c5f8cd4.png" alt="Design.png"><br>  <strong>Abbildung 2.</strong> Ansicht des Entwurfs auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oberster</a> Ebene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pdf</a> ) </p><br><p>  Wie Sie sehen k√∂nnen, gibt es viele Ein- und Ausg√§nge sowie einige Module.  In diesem Abschnitt wird beschrieben, was jedes Element bedeutet, und es wird angegeben, welche Pins auf der Karte f√ºr die Ports verwendet werden. </p><br><h3 id="main-inputs">  Haupteing√§nge </h3><br><p>  Die f√ºr die Implementierung <em>erforderlichen</em> <em>Haupteingaben</em> sind <em>res_x_one</em> , <em>res_x_two</em> , <em>res_y_one</em> , <em>res_y_two</em> , die zum Empfangen einer aktuellen Richtung eines Joysticks verwendet werden.  Abbildung 3 zeigt die Zuordnung zwischen ihren Werten und den Richtungen. </p><br><table><thead><tr><th>  Eingabe </th><th>  Links </th><th>  Richtig </th><th>  Auf </th><th>  Runter </th><th>  Keine Richtungs√§nderung </th></tr></thead><tbody><tr><td>  res_x_one (PIN_30) </td><td>  1 </td><td>  0 </td><td>  x </td><td>  x </td><td>  1 </td></tr><tr><td>  res_x_two (PIN_52) </td><td>  1 </td><td>  0 </td><td>  x </td><td>  x </td><td>  0 </td></tr><tr><td>  res_y_one (PIN_39) </td><td>  x </td><td>  x </td><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  res_y_two (PIN_44) </td><td>  x </td><td>  x </td><td>  1 </td><td>  0 </td><td>  0 </td></tr></tbody></table><br><p>  <strong>Abbildung 3.</strong> Zuordnung von Joystick-Eingaben und -Richtungen </p><br><h3 id="other-inputs">  Andere Eing√§nge </h3><br><ul><li>  <em>clk</em> - die Kartenuhr (PIN_23) </li><li>  <em>reset</em> - Signal zum Zur√ºcksetzen des Spiels und zum Beenden des Druckvorgangs (PIN_58) </li><li>  <em>Farbe</em> - Wenn 1, werden alle m√∂glichen Farben auf dem Bildschirm ausgegeben und nur zu Demonstrationszwecken verwendet (PIN_68). </li></ul><br><h3 id="main-modules">  Hauptmodule </h3><br><h4 id="joystick_input">  joystick_input </h4><br><p>  <em>joystick_input</em> wird verwendet, um einen Richtungscode basierend auf einer Eingabe vom Joystick zu erzeugen. </p><br><h4 id="game_logic">  game_logic </h4><br><p>  <em>game_logic</em> enth√§lt die gesamte Logik, die zum Spielen eines Spiels erforderlich ist.  Das Modul bewegt eine Schlange in eine bestimmte Richtung.  Dar√ºber hinaus ist es f√ºr das Apfelfressen und die Kollisionserkennung verantwortlich.  Dar√ºber hinaus empf√§ngt es die aktuellen x- und y-Koordinaten eines Pixels auf dem Bildschirm und gibt eine an der Position platzierte Entit√§t zur√ºck. </p><br><h4 id="vga_draw">  VGA_Draw </h4><br><p>  Die Schublade setzt die Farbe eines Pixels basierend auf der aktuellen Position ( <em>iVGA_X, iVGA_Y</em> ) und der aktuellen Entit√§t ( <em>ent</em> ) auf einen bestimmten Wert. </p><br><h4 id="vga_ctrl">  VGA_Ctrl </h4><br><p>  Erzeugt einen <em>Steuerbitstrom</em> zum VGA-Ausgang ( <em>V_Sync, H_Sync, R, G, B</em> ). </p><br><h4 id="sseg_displaysup22sup">  SSEG_Display <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a></sup> </h4><br><p>  <em>SSEG_Display</em> ist ein Treiber zur Ausgabe der aktuellen Punktzahl auf der 7-Segment-Anzeige. </p><br><h4 id="vga_clk">  Vga_clk </h4><br><p>  <em>VGA_clk</em> empf√§ngt einen 50-MHz-Takt und reduziert ihn auf 25,175 MHz. </p><br><h4 id="game_upd_clk">  game_upd_clk </h4><br><p>  <em>game_upd_clk</em> ist ein Modul, das eine spezielle Uhr generiert, die eine Aktualisierung eines Spielstatus ausl√∂st. </p><br><h3 id="outputs">  Ausg√§nge </h3><br><ul><li>  <em>VGA_B</em> - Blauer VGA-Pin (PIN_144) </li><li>  <em>VGA_G</em> - Gr√ºner VGA-Pin (PIN_1) </li><li>  <em>VGA_R</em> - Roter VGA-Pin (PIN_2) </li><li>  <em>VGA_HS</em> - Horizontale VGA-Synchronisation (PIN_142) </li><li>  <em>VGA_VS</em> - Vertikale VGA-Synchronisation (PIN_143) </li><li>  <em>sseg_a_to_dp</em> - <em>Gibt</em> an, welches der 8 Segmente beleuchtet werden soll (PIN_115, PIN_119, PIN_120, PIN_121, PIN_124, PIN_125, PIN_126, PIN_127). </li><li>  <em>sseg_an</em> - <em>Gibt</em> an, welche der 4 7-Segment-Anzeigen verwendet werden sollen (PIN_128, PIN_129, PIN_132, PIN_133). </li></ul><br><h2 id="implementation">  Implementierung </h2><br><h3 id="input-with-spi-joystick">  Eingabe mit SPI-Joystick </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e3f/4ab/fc4/e3f4abfc45c5a87151db34738e9c3a92.jpg" alt="stick.jpg"></p><br><p>  <strong>Abbildung 4.</strong> SPI-Joystick (KY-023) </p><br><p>  Bei der Implementierung eines Eingangsmoduls haben wir festgestellt, dass der Stick ein analoges Signal erzeugt.  Der Joystick hat 3 Positionen f√ºr jede Achse: </p><br><ul><li>  top - ~ 5V Ausgang </li><li>  Mitte - ~ 2,5V Ausgang </li><li>  niedrig - ~ 0V Ausgang </li></ul><br><p> Die Eingabe ist dem tern√§ren System sehr √§hnlich: F√ºr die X-Achse haben wir <code>true</code> (links), <code>false</code> (rechts) und einen <code>undetermined</code> Zustand, in dem sich der Joystick weder links noch rechts befindet.  Das Problem ist, dass die FPGA-Karte nur einen digitalen Eingang verarbeiten kann.  Daher k√∂nnen wir diese tern√§re Logik nicht einfach durch Schreiben von Code in eine Bin√§rlogik konvertieren.  Die erste vorgeschlagene L√∂sung bestand darin, einen Analog-Digital-Wandler zu finden. Dann beschlossen wir, unsere schulischen Kenntnisse der Physik zu nutzen und den Spannungsteiler <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3 zu</a></sup> implementieren.  Um die drei Zust√§nde zu definieren, ben√∂tigen wir zwei Bits: 00 ist <code>false</code> , 01 ist <code>undefined</code> und 11 ist <code>true</code> .  Nach einigen Messungen stellten wir fest, dass auf unserer Platine die Grenze zwischen Null und Eins ungef√§hr 1,7 V betr√§gt.  Daher haben wir das folgende Schema erstellt (Bild erstellt mit Circuitlab <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4</a></sup> ): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/009/36c/a43/00936ca435f219d64f7078bec64e9b8c.png" alt="Stick_connection.png"></p><br><p>  <strong>Abbildung 5.</strong> Schaltung f√ºr ADC f√ºr Joystick </p><br><p>  Die physische Implementierung basiert auf Arduino-Kit-Elementen und sieht wie folgt aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3eb/34b/c9e/3eb34bc9e0210b8f336a7fd8ba89f1a9.jpg" alt="stick_imp"></p><br><p>  <strong>Abbildung 6.</strong> ADC-Implementierung </p><br><p>  Unsere Schaltung nimmt einen Eingang f√ºr jede Achse und erzeugt zwei Ausg√§nge: Der erste kommt direkt vom Stick und wird nur dann Null, wenn der Joystick <code>zero</code> ausgibt.  Die Sekunde ist 0 im <code>undetermined</code> Zustand, aber immer noch 1 im <code>true</code> Zustand.  Dies ist das genaue Ergebnis, das wir erwartet haben. </p><br><p>  Die Logik des Eingangsmoduls lautet: </p><br><ol><li>  Wir √ºbersetzen unsere tern√§re Logik in einfache Bin√§rdr√§hte f√ºr jede Richtung; </li><li>  Bei jedem Taktzyklus pr√ºfen wir, ob nur eine Richtung <code>true</code> (die Schlange kann nicht diagonal gehen); </li><li>  Wir vergleichen unsere neue Richtung mit der vorherigen, um zu verhindern, dass sich die Schlange selbst frisst, indem wir dem Spieler nicht erlauben, die Richtung in die entgegengesetzte Richtung zu √§ndern. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Ein Teil des Eingabemodulcodes</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">reg left, right, up, down; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `TOP_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //<span class="hljs-number"><span class="hljs-number">1</span></span> left = two_resistors_x; right = ~one_resistor_x; up = two_resistors_y; down = ~one_resistor_y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left + right + up + down == <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b001</span></span>) //<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &amp;&amp; (direction != `RIGHT_DIR)) //<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `LEFT_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //same code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> other directions <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-vga">  Ausgabe an VGA </h3><br><p>  Wir haben uns f√ºr eine Ausgabe mit einer Aufl√∂sung von 640 x 480 auf einem 60-Hz-Bildschirm mit 60 FPS entschieden. </p><br><p>  Das VGA-Modul besteht aus 2 Hauptteilen: einem <strong>Treiber</strong> und einer <strong>Schublade</strong> .  Der Treiber erzeugt einen Bitstrom, der aus vertikalen, horizontalen Synchronisationssignalen und einer Farbe besteht, die den VGA-Ausg√§ngen zugewiesen wird.  Ein Artikel <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5</a></sup> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@SlavikMIPT</a> beschreibt die Grundprinzipien der Arbeit mit VGA.  Wir haben den Treiber aus dem Artikel an unser Board angepasst. </p><br><p>  Wir haben beschlossen, den Bildschirm in ein Raster von 40 x 30 Elementen zu unterteilen, das aus Quadraten von 16 x 16 Pixel besteht.  Jedes Element steht f√ºr 1 Spieleinheit: entweder einen Apfel, einen Schlangenkopf, einen Schwanz oder nichts. </p><br><p>  Der n√§chste Schritt in unserer Implementierung bestand darin, Sprites f√ºr die Entit√§ten zu erstellen. </p><br><p>  Cyclone IV hat nur 3 Bits, um eine Farbe auf VGA darzustellen (1 f√ºr Rot, 1 f√ºr Gr√ºn und 1 f√ºr Blau).  Aufgrund dieser Einschr√§nkung mussten wir einen Konverter implementieren, um die Farben der Bilder an die verf√ºgbaren anzupassen.  Zu diesem Zweck haben wir ein Python-Skript erstellt, das einen RGB-Wert jedes Pixels durch 128 teilt. </p><br><div class="spoiler">  <b class="spoiler_title">Das Python-Skript</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageDraw filename = <span class="hljs-string"><span class="hljs-string">"snake_head"</span></span> index = <span class="hljs-number"><span class="hljs-number">1</span></span> im = Image.open(filename + <span class="hljs-string"><span class="hljs-string">".png"</span></span>) n = Image.new(<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)) d = ImageDraw.Draw(n) pix = im.load() size = im.size data = [] code = <span class="hljs-string"><span class="hljs-string">"sp["</span></span> + str(index) + <span class="hljs-string"><span class="hljs-string">"][{i}][{j}] = 3'b{RGB};\\\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"code_"</span></span> + filename + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): tmp = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): clr = im.getpixel((i, j)) vg = <span class="hljs-string"><span class="hljs-string">"{0}{1}{2}"</span></span>.format(int(clr[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">128</span></span>), <span class="hljs-comment"><span class="hljs-comment"># an array representation for pixel int(clr[1] / 128), # since clr[*] in range [0, 255], int(clr[2] / 128)) # clr[*]/128 is either 0 or 1 tmp.append(vg) f.write(code.format(i=i, j=j, RGB=vg)) # Verilog code to initialization d.point((i, j), tuple([int(vg[0]) * 255, int(vg[1]) * 255, int(vg[2]) * 255])) # Visualize final image data.append(tmp) n.save(filename + "_3bit.png") for el in data: print(" ".join(el))</span></span></code> </pre></div></div><br><table><tbody><tr><td align="center">  Original </td><td align="center">  Nach dem Skript </td></tr><tr><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/720/34d/b40/72034db4092a25711654562bc4523661.png" width="128" height="128"><br></td><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/529/254/02e/52925402e158986901bc6278d7d0bb28.png" width="128" height="128"><br></td></tr></tbody></table><br><p>  <strong>Abbildung 7.</strong> Vergleich zwischen Eingabe und Ausgabe </p><br><p>  Der Hauptzweck der Schublade besteht darin, eine Farbe eines Pixels basierend auf der aktuellen Position ( <em>iVGA_X, iVGA_Y</em> ) und der aktuellen Entit√§t ( <em>ent</em> ) an VGA zu senden.  Alle Sprites sind fest codiert, k√∂nnen jedoch leicht ge√§ndert werden, indem mit dem obigen Skript ein neuer Code generiert wird. </p><br><div class="spoiler">  <b class="spoiler_title">Schubladenlogik</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">always @(posedge iVGA_CLK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // DRAW CURRENT STATE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ent == `ENT_NOTHING) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Drawing a particular pixel from sprite oRed &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">0</span></span>]; oGreen &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">1</span></span>]; oBlue &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-the-7-segment-display">  Ausgabe an die 7-Segment-Anzeige </h3><br><p>  Um dem Spieler die Anzeige seiner Punktzahl zu erm√∂glichen, haben wir beschlossen, eine Spielpunktzahl auf der 7-Segment-Anzeige auszugeben.  Aus Zeitgr√ºnden haben wir den Code aus EP4CE6 Starter Board Documentation <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 verwendet</a></sup> .  Dieses Modul gibt eine Hexadezimalzahl an die Anzeige aus. </p><br><h3 id="game-logic">  Spielelogik </h3><br><p>  W√§hrend der Entwicklung haben wir verschiedene Ans√§tze ausprobiert. Am Ende haben wir jedoch einen Ansatz gefunden, der nur wenig Speicher ben√∂tigt, einfach in Hardware zu implementieren ist und von parallelen Berechnungen profitieren kann. </p><br><p>  Das Modul f√ºhrt mehrere Funktionen aus.  Da VGA bei jedem Taktzyklus ein Pixel zeichnet, beginnend vom oberen linken zum unteren rechten, muss das VGA_Draw-Modul, das f√ºr die Erzeugung einer Farbe f√ºr ein Pixel verantwortlich ist, identifizieren, welche Farbe f√ºr die aktuellen Koordinaten verwendet werden soll.  Das sollte das Spielelogikmodul ausgeben - einen Entit√§tscode f√ºr die angegebenen Koordinaten. <br>  Au√üerdem muss der Spielstatus erst aktualisiert werden, nachdem der Vollbildmodus gezeichnet wurde.  Ein vom Modul <em>game_upd_clk</em> erzeugtes Signal wird verwendet, um zu bestimmen, wann aktualisiert werden soll. </p><br><h4 id="game-state">  Spielstatus </h4><br><p>  Der Spielstatus besteht aus: </p><br><ul><li>  Koordinaten des Schlangenkopfes </li><li>  Eine Reihe von Koordinaten des Schwanzes der Schlange.  Das Array ist in unserer Implementierung durch 128 Elemente begrenzt </li><li>  Anzahl der Schw√§nze </li><li>  Koordinaten eines Apfels </li><li>  Spiel √ºber Flagge </li><li>  Spiel gewann Flagge </li></ul><br><p>  Die Aktualisierung des Spielstatus umfasst mehrere Phasen: </p><br><ol><li>  Bewegen Sie den Kopf der Schlange basierend auf einer bestimmten Richtung zu neuen Koordinaten.  Wenn sich herausstellt, dass sich eine Koordinate an ihrer Kante befindet und weiter ge√§ndert werden muss, muss der Kopf zu einer anderen Kante des Bildschirms springen.  Beispielsweise wird eine Richtung nach links festgelegt und die aktuelle X-Koordinate ist 0. Daher sollte die neue X-Koordinate gleich der letzten horizontalen Adresse werden. </li><li>  Neue Koordinaten des Schlangenkopfes werden gegen Apfelkoordinaten getestet: <br>  2.1.  Wenn sie gleich sind und das Array nicht voll ist, f√ºgen Sie dem Array einen neuen Schwanz hinzu und erh√∂hen Sie den Schwanzz√§hler.  Wenn der Z√§hler seinen h√∂chsten Wert erreicht (in unserem Fall 128), wird die Flagge f√ºr das gewonnene Spiel eingerichtet und das bedeutet, dass die Schlange nicht mehr wachsen kann und das Spiel weiterhin fortgesetzt wird.  Der neue Schwanz wird auf die vorherigen Koordinaten des Schlangenkopfes gelegt.  Zuf√§llige Koordinaten f√ºr X und Y sollten verwendet werden, um dort einen Apfel zu platzieren. <br>  2.2.  Falls sie nicht gleich sind, vertauschen Sie nacheinander die Koordinaten der benachbarten Schw√§nze.  (n + 1) -ter Schwanz sollte Koordinaten von n-ten erhalten, falls der n-te Schwanz vor (n + 1) -ten hinzugef√ºgt wurde.  Der erste Schwanz erh√§lt alte Koordinaten des Kopfes. </li><li>  √úberpr√ºfen Sie, ob die neuen Koordinaten des Kopfes der Schlange mit den Koordinaten eines Schwanzes √ºbereinstimmen.  In diesem Fall wird das Spiel √ºber der Flagge gehisst und das Spiel gestoppt. </li></ol><br><h4 id="random-coordinate-generation">  Zuf√§llige Koordinatengenerierung </h4><br><p>  Zufallszahlen, die durch Aufnehmen von Zufallsbits erzeugt werden, die von 6-Bit <em>-Schieberegistern mit linearer R√ºckkopplung (LFSR)</em> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6 erzeugt werden</a></sup> .  Um die Zahlen in einen Bildschirm einzupassen, werden sie durch die Abmessungen des Spielgitters geteilt und der Rest wird genommen. </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Nach 8 Wochen Arbeit wurde das Projekt erfolgreich umgesetzt.  Wir haben einige Erfahrung in der Spieleentwicklung und haben eine unterhaltsame Version eines "Snake" -Spiels f√ºr ein FPGA erhalten.  Das Spiel ist spielbar und unsere F√§higkeiten beim Programmieren, Entwerfen einer Architektur und Soft Skills haben sich verbessert. </p><br><h2 id="acknowledgments">  Anerkannte Segmente </h2><br><p>  Wir m√∂chten unseren Professoren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Muhammad Fahim</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Tormasov</a> unseren besonderen Dank und Dank daf√ºr aussprechen, dass sie uns das profunde Wissen und die M√∂glichkeit gegeben haben, es in die Praxis umzusetzen.  Wir danken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vladislav Ostankovich von</a> Herzen f√ºr die Bereitstellung der im Projekt verwendeten Hardware und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Temur Kholmatov</a> f√ºr die Unterst√ºtzung beim Debuggen.  Wir w√ºrden nicht vergessen, uns daran zu erinnern, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anastassiya Boiko</a> wundersch√∂ne Sprites f√ºr das Spiel gezeichnet hat.  Wir m√∂chten auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rabab Marouf</a> f√ºr das Korrekturlesen und Bearbeiten dieses Artikels unsere aufrichtige Wertsch√§tzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aussprechen</a> . </p><br><p>  Vielen Dank f√ºr all diejenigen, die uns geholfen haben, das Spiel zu testen und einen Rekord aufzustellen.  Ich hoffe es gef√§llt euch! </p><br><h2 id="references">  Referenzen </h2><br><p>  [1]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt auf dem Github</a> <br>  [2]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[FPGA] EP4CE6 Starter Board-Dokumentation</a> <br>  [3]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spannungsteiler</a> <br>  [4]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Werkzeug zur Modellierung von Schaltkreisen</a> <br>  [5]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VGA-Adapter f√ºr FPGA Altera Cyclone III</a> <br>  [6]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linear-Feedback-Schieberegister (LFSR) auf Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LFSR in einem FPGA - VHDL &amp; Verilog Code</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Apfeltextur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee, Zufallszahlen zu generieren</a> <br>  Palnitkar, S. (2003).  <em>Verilog HDL: Ein Leitfaden f√ºr digitales Design und Synthese, zweite Ausgabe.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431226/">https://habr.com/ru/post/de431226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431212/index.html">Caching-Paginierung in Android</a></li>
<li><a href="../de431216/index.html">Snom D345 IP-Telefon Bewertung</a></li>
<li><a href="../de431218/index.html">Wie ich ein Lovecraft-Comic gemacht habe</a></li>
<li><a href="../de431220/index.html">Der Blick eines Biologen auf die Wurzeln unseres Alterns</a></li>
<li><a href="../de431222/index.html">Website-Archivierung</a></li>
<li><a href="../de431228/index.html">Hindernislauf f√ºr Licht: Fl√ºssigkristalle helfen</a></li>
<li><a href="../de431230/index.html">Speicher f√ºr HPC-Infrastruktur oder wie wir 65 PB-Speicher im RIKEN Japan Research Center gesammelt haben</a></li>
<li><a href="../de431232/index.html">Wir generieren wundersch√∂ne SVG-Platzhalter auf Node.js.</a></li>
<li><a href="../de431234/index.html">11. Dezember, Moskau - Alfa JS MeetUp</a></li>
<li><a href="../de431236/index.html">Wie schreibe ich 2018 auf Objective-C? Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>