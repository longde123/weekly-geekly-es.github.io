<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ƒï¸ ğŸŒ¥ï¸ ğŸ“± Rak Tanpa Server ğŸ‘©ğŸ»â€ğŸ“ â†˜ï¸ ğŸ‘³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serverless bukan tentang ketiadaan fisik server. Ini bukan "pembunuh" kontainer dan bukan tren yang lewat. Ini adalah pendekatan baru untuk membangun ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rak Tanpa Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/452266/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/40/f2/jb40f22sdsdaapg5pvd_wlcj81w.png"></div><br>  Serverless bukan tentang ketiadaan fisik server.  Ini bukan "pembunuh" kontainer dan bukan tren yang lewat.  Ini adalah pendekatan baru untuk membangun sistem di cloud.  Pada artikel hari ini, kita akan menyentuh arsitektur aplikasi Serverless, lihat apa peran penyedia layanan Serverless dan proyek sumber terbuka.  Pada akhirnya, kita akan berbicara tentang Serverless. <br><a name="habracut"></a><br>  Saya ingin menulis sisi server dari aplikasi (ya bahkan toko online).  Ini bisa berupa obrolan, layanan untuk menerbitkan konten, atau penyeimbang beban.  Bagaimanapun, akan ada banyak sakit kepala: Anda harus menyiapkan infrastruktur, menentukan ketergantungan aplikasi, dan memikirkan sistem operasi host.  Maka Anda perlu memperbarui komponen kecil yang tidak mempengaruhi pekerjaan monolit lainnya.  Nah, jangan lupa tentang penskalaan di bawah beban. <br><br>  Tetapi bagaimana jika kita mengambil wadah sementara di mana dependensi yang diperlukan sudah diinstal sebelumnya, dan wadah itu sendiri terisolasi satu sama lain dan dari OS host?  Kami akan memecah monolith menjadi layanan microser, yang masing-masing dapat diperbarui dan diskalakan secara terpisah dari yang lain.  Setelah menempatkan kode dalam wadah seperti itu, saya dapat menjalankannya pada infrastruktur apa pun.  Sudah lebih baik. <br><br>  Dan jika Anda tidak ingin mengkonfigurasi kontainer?  Saya tidak ingin berpikir tentang meningkatkan aplikasi.  Saya tidak ingin membayar kontainer yang tidak digunakan saat beban pada layanan minimal.  Saya ingin menulis kode.  Fokus pada logika bisnis dan produk pasar dengan kecepatan cahaya. <br><br>  Pikiran-pikiran seperti itu menuntun saya ke komputasi tanpa server.  Serverless dalam hal ini <em>tidak</em> berarti <em>tidak adanya server secara fisik, tetapi tidak adanya sakit kepala untuk manajemen infrastruktur.</em> <br><br>  Idenya adalah bahwa logika aplikasi dipecah menjadi fungsi-fungsi independen.  Mereka memiliki struktur acara.  Masing-masing fungsi melakukan satu "mikrotask".  Semua yang diperlukan dari pengembang adalah memuat fungsi ke konsol yang disediakan oleh penyedia cloud dan menghubungkannya dengan sumber acara.  Kode akan dieksekusi berdasarkan permintaan dalam wadah yang disiapkan secara otomatis, dan saya hanya akan membayar untuk waktu eksekusi. <br><br>  Mari kita lihat bagaimana proses pengembangan aplikasi sekarang. <br><br><h2>  Dari pengembang </h2><br>  Sebelumnya, kami mulai berbicara tentang aplikasi untuk toko online.  Dalam pendekatan tradisional, logika utama sistem dilakukan oleh aplikasi monolitik.  Dan server dengan aplikasi terus berjalan, bahkan jika tidak ada beban. <br><br>  <strong>Untuk beralih ke serverless, kami memecah aplikasi menjadi mikrotasks.</strong>  Di bawah masing-masing dari mereka kita menulis fungsi kita sendiri.  Fungsi independen satu sama lain dan tidak menyimpan informasi negara.  Mereka bahkan dapat ditulis dalam berbagai bahasa.  Jika salah satunya macet, seluruh aplikasi tidak akan berhenti.  Arsitektur aplikasi akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/1_/yj/pm1_yj5fd2s0f99zcirrpofsura.png" title="Arsitektur aplikasi tanpa server. Diagram menunjukkan bahwa Anda perlu menghubungkan sumber daya tambahan (ini dia database dan server otentikasi)"></div><br>  Pembagian fungsi di Serverless mirip dengan bekerja dengan layanan microser.  Tetapi sebuah layanan mikro dapat melakukan beberapa tugas, dan idealnya, suatu fungsi harus melakukan satu.  Bayangkan bahwa tugasnya adalah untuk mengumpulkan statistik dan ditampilkan atas permintaan pengguna.  Dalam pendekatan microservice, tugas dilakukan oleh satu layanan dengan dua titik masuk: menulis dan membaca.  Dalam komputasi tanpa server, ini akan menjadi dua fungsi berbeda yang tidak saling berhubungan.  Pengembang menyimpan sumber daya komputasi jika, misalnya, statistik diperbarui lebih sering daripada yang diunduh. <br><br>  Fungsi tanpa server harus dijalankan dalam waktu singkat (batas waktu), yang ditentukan oleh penyedia layanan.  Misalnya, untuk AWS, batas waktu adalah 15 menit.  Ini berarti bahwa fungsi yang berumur panjang (berumur panjang) harus diubah untuk memenuhi persyaratan - Serverless ini berbeda dari teknologi lain yang populer saat ini (wadah dan Platform sebagai Layanan). <br><br>  <strong>Kami menetapkan suatu acara untuk setiap fungsi.</strong>  Suatu peristiwa adalah pemicu suatu tindakan: <br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Acara</strong> </td><td>  <strong>Tindakan yang dilakukan fungsi</strong> </td></tr><tr><td>  Gambar produk diunggah ke toko </td><td>  Kompres gambar dan unggah ke katalog </td></tr><tr><td>  Alamat toko fisik telah diperbarui dalam database </td><td>  Unggah lokasi baru ke peta </td></tr><tr><td>  Pelanggan membayar barang </td><td>  Mulai pemrosesan pembayaran </td></tr></tbody></table></div>  Acara dapat berupa permintaan HTTP, streaming data, antrian pesan, dan sebagainya.  Sumber peristiwa adalah perubahan atau tampilan data.  Selain itu, fungsi dapat dijalankan oleh timer. <br><br>  Arsitekturnya berfungsi, dan aplikasi hampir menjadi serverless.  Selanjutnya kita pergi ke penyedia layanan. <br><br><h2>  Dari provider </h2><br>  Komputasi tanpa server biasanya ditawarkan oleh penyedia layanan cloud.  Mereka menyebutnya secara berbeda: Fungsi Azure, AWS Lambda, Fungsi Google Cloud, Fungsi IBM Cloud. <br><br>  Kami akan menggunakan layanan melalui konsol atau akun pribadi penyedia.  Kode fungsi dapat diunduh dengan salah satu cara berikut: <br><br><ul><li>  tulis kode dalam editor bawaan melalui konsol web, </li><li>  Unduh arsip dengan kodenya, </li><li>  bekerja dengan repositori git publik atau pribadi. </li></ul><br>  Di sini kita mengkonfigurasi peristiwa yang memanggil fungsi.  Penyedia yang berbeda mungkin memiliki rangkaian acara yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iv/qc/f2/ivqcf25p7y6nha_iduzvjursray.png" title="Antarmuka Konsol Platform Google Cloud"></div><br><br>  Penyedia infrastrukturnya telah membangun dan mengotomatiskan sistem Function as a Service (FaaS): <br><br><ol><li>  Kode fungsi sampai ke repositori di sisi penyedia. </li><li>  Ketika suatu peristiwa terjadi, wadah dengan lingkungan yang disiapkan secara otomatis dikerahkan ke server.  Setiap instance fungsi memiliki wadah tersendiri. </li><li>  Dari penyimpanan, fungsi dikirim ke wadah, dihitung, mengembalikan hasilnya. </li><li>  Jumlah peristiwa paralel meningkat - jumlah kontainer bertambah.  Sistem secara otomatis berskala.  Jika pengguna tidak mengakses fungsi, itu akan menjadi tidak aktif. </li><li>  Penyedia mengatur waktu idle wadah - jika selama ini fungsi tidak muncul dalam wadah, itu dihancurkan. </li></ol><br>  Jadi kita mendapatkan Serverless di luar kotak.  Kami akan membayar layanan sesuai dengan model pay-as-you-go dan hanya untuk fungsi-fungsi yang digunakan, dan hanya untuk saat mereka digunakan. <br><br>  Untuk memperkenalkan pengembang ke layanan, penyedia menawarkan hingga 12 bulan pengujian gratis, tetapi mereka membatasi waktu komputasi total, jumlah permintaan per bulan, uang atau konsumsi daya. <br><br>  Keuntungan utama bekerja dengan penyedia adalah kemampuan untuk tidak khawatir tentang infrastruktur (server, mesin virtual, wadah).  Untuk bagiannya, penyedia dapat menerapkan FaaS baik pada pengembangannya sendiri, dan menggunakan alat open-source.  Kami akan membicarakannya lebih lanjut. <br><br><h2>  Dari sumber terbuka </h2><br>  Selama beberapa tahun terakhir, komunitas open-source telah secara aktif mengerjakan alat Serverless.  Secara khusus, pemain pasar terbesar berkontribusi pada pengembangan platform tanpa server: <br><br><ul><li>  <strong>Google</strong> menawarkan pengembangnya alat open-source - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Knative</a> .  Pengembangannya melibatkan IBM, RedHat, Pivotal dan SAP; </li><li>  <strong>IBM</strong> bekerja pada platform OpenWhisk Serverless, yang kemudian menjadi proyek Apache Foundation; </li><li>  <strong>Microsoft</strong> membuka sebagian kode platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Azure Functions</a> . </li></ul><br>  Pengembangan juga dilakukan ke arah kerangka serverless.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Kubeless</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Fission</a> dikerahkan dalam kluster Kubernet yang telah disiapkan sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">OpenFaaS</a> bekerja dengan Kubernetes dan Docker Swarm.  Kerangka kerja bertindak sebagai semacam pengontrol - atas permintaan, ia menyiapkan runtime di dalam cluster, kemudian menjalankan fungsi di sana. <br><br>  Kerangka kerja memberikan ruang untuk konfigurasi alat agar sesuai dengan kebutuhan Anda.  Jadi, di Kubeless, pengembang dapat mengatur batas waktu untuk fungsi yang akan dieksekusi (nilai default adalah 180 detik).  Fisi dalam upaya untuk memecahkan masalah penawaran mulai dingin agar bagian wadah tetap berjalan sepanjang waktu (meskipun ini memerlukan biaya waktu henti).  Dan OpenFaaS menawarkan serangkaian pemicu untuk setiap rasa dan warna: HTTP, Kafka, Redis, MQTT, Cron, AWS SQS, NATs dan lainnya. <br><br>  Instruksi untuk memulai dapat ditemukan dalam dokumentasi resmi kerangka kerja.  Bekerja dengan mereka menyiratkan sedikit lebih banyak keterampilan daripada bekerja dengan penyedia - ini setidaknya kemampuan untuk memulai cluster Kubernetes melalui CLI.  Maksimum, termasuk alat sumber terbuka lainnya (misalnya, manajer antrian Kafka). <br><br>  Terlepas dari bagaimana kami bekerja dengan Serverless - melalui penyedia atau menggunakan open-source, kami mendapatkan sejumlah keuntungan dan kerugian dari pendekatan Serverless. <br><br><h2>  Dari perspektif kelebihan dan kekurangan </h2><br>  Serverless mengembangkan ide-ide infrastruktur wadah dan pendekatan layanan mikro, di mana tim dapat bekerja dalam mode multibahasa, tanpa terikat pada satu platform.  Membangun sistem disederhanakan, dan memperbaiki kesalahan menjadi lebih mudah.  Arsitektur Microservice memungkinkan Anda untuk menambahkan fungsionalitas baru ke sistem jauh lebih cepat daripada dalam kasus aplikasi monolitik. <br><br>  <strong>Tanpa server mengurangi waktu pengembangan lebih jauh dengan</strong> membiarkan pengembang hanya berfokus pada logika dan pengkodean aplikasi bisnis.  Akibatnya, waktu ke pasar untuk pengembangan berkurang. <br><br>  <strong>Sebagai bonus, kami mendapatkan penskalaan otomatis ke beban,</strong> dan kami hanya membayar sumber daya yang digunakan dan hanya pada saat mereka digunakan. <br><br>  Seperti halnya teknologi apa pun, Serverless memiliki kelemahan. <br><br>  <em>Misalnya, kelemahan seperti itu bisa menjadi waktu mulai yang dingin (rata-rata hingga 1 detik untuk bahasa seperti JavaScript, Python, Go, Java, Ruby).</em> <br><br>  Di satu sisi, pada kenyataannya, waktu mulai dingin tergantung pada banyak variabel: bahasa di mana fungsi ditulis, jumlah perpustakaan, jumlah kode, komunikasi dengan sumber daya tambahan (database yang sama atau server otentikasi).  Karena pengembang mengontrol variabel-variabel ini, ia dapat mempersingkat waktu mulai.  Tetapi di sisi lain, pengembang tidak dapat mengontrol waktu peluncuran wadah - semuanya tergantung pada penyedia. <br><br>  Awal yang dingin dapat berubah menjadi hangat ketika fungsi menggunakan kembali wadah yang diluncurkan oleh acara sebelumnya.  Situasi ini akan terjadi dalam tiga kasus: <br><br><ul><li>  jika pelanggan sering menggunakan layanan ini dan jumlah panggilan ke fungsi bertambah; </li><li>  jika penyedia, platform atau kerangka kerja memungkinkan Anda untuk menjaga agar bagian dari wadah tetap berjalan sepanjang waktu; </li><li>  jika pengembang menjalankan fungsi timer (katakanlah, setiap 3 menit). </li></ul><br>  Untuk banyak aplikasi, awal yang dingin tidak menjadi masalah.  Di sini Anda perlu membangun pada jenis dan tugas layanan.  Awal yang tertunda selama sedetik tidak selalu penting untuk aplikasi bisnis, tetapi dapat menjadi penting untuk layanan medis.  Mungkin, dalam hal ini, pendekatan tanpa server tidak lagi cocok. <br><br>  <em>Kelemahan berikutnya dari Serverless adalah masa pakai fungsi yang singkat (batas waktu untuk fungsi yang harus dijalankan).</em> <br><br>  Tetapi, jika Anda harus bekerja dengan tugas yang berumur panjang, Anda dapat menggunakan arsitektur hybrid - menggabungkan Serverless dengan teknologi lainnya. <br><br>  <em>Tidak semua sistem akan dapat bekerja sesuai dengan skema Serverless.</em> <br><br>  Beberapa aplikasi masih akan menyimpan data dan status saat runtime.  Beberapa arsitektur akan tetap monolitik, dan beberapa fungsi akan berumur panjang.  Namun (seperti teknologi cloud dulu, dan kemudian wadah), Serverless adalah teknologi dengan masa depan yang hebat. <br><br>  Dalam nada ini, saya ingin beralih ke masalah penerapan pendekatan Serverless. <br><br><h2>  Di sisi aplikasi </h2><br>  Pada 2018, persentase penggunaan Tanpa Server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">meningkat satu setengah kali</a> .  Di antara perusahaan yang telah menerapkan teknologi dalam layanan mereka, ada raksasa pasar seperti Twitter, PayPal, Netflix, T-Mobile, Coca-Cola.  Pada saat yang sama, Anda perlu memahami bahwa Serverless bukanlah obat mujarab, tetapi alat untuk menyelesaikan berbagai tugas: <br><br><ul><li>  <strong>Kurangi sumber daya waktu henti.</strong>  Anda tidak perlu terus-menerus menjaga mesin virtual di bawah layanan yang tidak banyak diakses. </li><li>  <strong>"On the fly" memproses data.</strong>  Kompres gambar, memotong latar belakang, mengubah pengkodean video, bekerja dengan sensor IoT, melakukan operasi matematika. <br></li><li>  <strong>Rekatkan layanan lain.</strong>  Git repositori dengan program internal, chat bot di Slack with Jira dan dengan kalender. </li><li>  <strong>Seimbangkan beban.</strong>  Di sini kita tinggal lebih detail. </li></ul><br>  Katakanlah ada layanan yang dihadiri 50 orang.  Di bawahnya adalah mesin virtual dengan perangkat keras yang lemah.  Secara berkala, beban pada layanan meningkat secara signifikan.  Maka besi yang lemah tidak bisa mengatasinya. <br><br>  Anda dapat memasukkan penyeimbang dalam sistem yang akan mendistribusikan beban, katakanlah, ke tiga mesin virtual.  Pada tahap ini, kami tidak dapat secara akurat memprediksi beban, jadi kami menjaga sejumlah sumber daya berjalan â€œdalam cadanganâ€.  Dan membayar lebih untuk downtime. <br><br>  Dalam situasi ini, kita dapat mengoptimalkan sistem melalui pendekatan hybrid: untuk penyeimbang beban kita meninggalkan satu mesin virtual dan menempatkan tautan ke Serverless Endpoint dengan fungsi.  Jika beban melebihi ambang batas, penyeimbang meluncurkan contoh fungsi yang mengambil bagian dari pemrosesan permintaan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r6/xv/ew/r6xvewex6fwzcnjiaciro92xeuy.png" title="Arsitektur penyeimbang beban hybrid"></div><br>  Dengan demikian, Serverless dapat digunakan di tempat yang tidak terlalu sering, tetapi untuk memproses sejumlah besar permintaan secara intensif.  Dalam hal ini, menjalankan beberapa fungsi selama 15 menit lebih menguntungkan daripada memegang mesin atau server virtual sepanjang waktu. <br><br>  Dengan semua keunggulan komputasi tanpa server, sebelum menerapkannya, Anda harus terlebih dahulu mengevaluasi logika aplikasi dan memahami tugas-tugas yang dapat diselesaikan Serverless dalam kasus tertentu. <br><br><h2>  Tanpa Server dan Selectel </h2><br>  Di Selectel, kami telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">membuat bekerja dengan Kubernetes</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">cloud pribadi virtual</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">lebih mudah</a> melalui panel kontrol kami.  Sekarang kami sedang membangun platform FaaS kami sendiri.  Kami ingin pengembang dapat menyelesaikan masalah mereka dengan Serverless melalui antarmuka yang nyaman dan fleksibel. <br><br>  Ingin mengikuti proses pengembangan platform FaaS baru?  Berlangganan buletin Selectel â€œCloud Functionsâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di halaman layanan</a> .  Kami akan berbicara tentang proses pengembangan dan mengumumkan rilis Cloud Functions. <br><br>  Jika Anda memiliki ide apa platform FaaS ideal seharusnya dan bagaimana Anda ingin menggunakan Serverless dalam proyek Anda, bagikan dalam komentar.  Kami akan mempertimbangkan keinginan Anda saat mengembangkan platform. <br><br>  Bahan yang digunakan dalam artikel: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Pemanfaatan tanpa server naik 1,5 kali (Laporan RightScale Penuh)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener noreferrer">Bagaimana waktu mulai dingin tergantung pada bahasa aplikasi</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452266/">https://habr.com/ru/post/id452266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452252/index.html">Keamanan bergaya Google</a></li>
<li><a href="../id452254/index.html">Tip & Trik Forensik Digital: Cara Menemukan Koin Keberuntungan Penyelundup</a></li>
<li><a href="../id452258/index.html">Corda - open source blockchain untuk bisnis</a></li>
<li><a href="../id452262/index.html">Angular: membuat dan menerbitkan perpustakaan</a></li>
<li><a href="../id452264/index.html">Bagaimana kami membuat situs untuk penghargaan mobil Mascot</a></li>
<li><a href="../id452268/index.html">C # WPF analogue Window.ShowDialog () atau berurusan dengan DispatcherFrame</a></li>
<li><a href="../id452270/index.html">Dokumentasi Xamarin API sekarang tersedia untuk umum</a></li>
<li><a href="../id452272/index.html">Gadis di bawah air terjun</a></li>
<li><a href="../id452276/index.html">Rekayasa Terbalik Klien Dropbox</a></li>
<li><a href="../id452278/index.html">Bluetooth LE tidak begitu menakutkan, atau Bagaimana meningkatkan pengalaman pengguna tanpa banyak usaha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>