<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲 🙎🏻 🤰🏽 AI di Hase und Igel: minimax for three 🦏 🏆 🙆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah booming nyata permainan papan di akhir tahun 00-an, keluarga meninggalkan beberapa kotak dengan permainan. Salah satunya adalah game "Hare and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI di Hase und Igel: minimax for three</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432382/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/z2/ng/inz2ngydxteyo76jh1r9du9oxx8.jpeg"></div><br>  Setelah booming nyata permainan papan di akhir tahun 00-an, keluarga meninggalkan beberapa kotak dengan permainan.  Salah satunya adalah game "Hare and Hedgehog" dalam versi asli Jerman.  Sebuah permainan untuk beberapa pemain, di mana unsur keacakan diminimalkan, dan perhitungan yang bijaksana dan kemampuan pemain untuk "melihat ke depan" dengan beberapa langkah menang. <br><br>  Kekalahan saya yang sering terjadi dalam permainan membuat saya menulis "kecerdasan" komputer untuk memilih langkah terbaik.  Kecerdasan, idealnya mampu melawan grandmaster Hare dan Hedgehog (dan apa, teh, bukan catur, permainan akan lebih mudah).  Sisa artikel ini menjelaskan proses pengembangan, logika AI, dan tautan ke sumber. <br><a name="habracut"></a><br><h1>  Aturan permainan Hare dan Hedgehog </h1><br>  Di lapangan bermain 65 sel ada beberapa chip pemain, dari 2 hingga 6 peserta (gambar saya, non-kanonik, penampilan, tentu saja, biasa saja): <br><br><img src="https://habrastorage.org/webt/rf/8w/8x/rf8w8xapxkminuwc_r78qrwlr_c.png"><br><br>  Terlepas dari sel dengan indeks 0 (mulai) dan 64 (selesai), hanya satu pemain dapat ditempatkan di masing-masing sel.  Tujuan setiap pemain adalah bergerak maju ke sel finish, di depan para pesaing. <br><br>  "Bahan bakar" untuk bergerak maju adalah wortel - " <b>mata uang</b> " permainan.  Pada awalnya, setiap pemain menerima 68 wortel, yang ia berikan (dan kadang-kadang menerima) saat ia bergerak. <br><br>  Selain wortel, pada awalnya pemain menerima 3 kartu salad.  Salad adalah "artefak" khusus yang harus <b>disingkirkan</b> seorang pemain sebelum selesai.  Menyingkirkan selada (dan ini hanya bisa dilakukan pada selada khusus, seperti ini: <br><img src="https://habrastorage.org/webt/yk/ie/c9/ykiec9ojz0bdaawaedp8yo2lsy4.png" align="left"><br>  ), pemain, termasuk, menerima wortel tambahan.  Sebelum itu, lewati langkah Anda.  Semakin banyak pemain di depan salad yang meninggalkan kartu, semakin banyak wortel yang akan diterima pemain: 10 x (posisi pemain di lapangan relatif terhadap pemain lain).  Artinya, pemain yang berdiri di atas lapangan kedua akan menerima 20 wortel, meninggalkan sangkar salad. <br><br>  Sel dengan angka 1 - 4 dapat membawa beberapa puluh wortel jika posisi pemain bertepatan dengan angka pada sel (1 - 4, sel dengan nomor 1 juga cocok untuk posisi ke-4 dan ke-6 di lapangan), dengan analogi dengan sel selada. <br><br>  Pemain dapat melewatkan langkah, tetap di kandang dengan gambar wortel dan menerima atau memberikan 10 wortel untuk tindakan ini.  Mengapa pemain harus memberi "bahan bakar"?  Faktanya adalah bahwa seorang pemain dapat menyelesaikan hanya memiliki 10 wortel setelah langkah terakhirnya (20 jika Anda finis kedua, 30 jika Anda finis ketiga, dll.). <br><br>  Akhirnya, pemain bisa mendapatkan 10 x N wortel dengan mengambil langkah N di landak <b>gratis terdekat</b> (jika landak terdekat sibuk, langkah seperti itu tidak mungkin). <br><br>  Biaya bergerak maju dihitung tidak proporsional dengan jumlah gerakan, sesuai dengan rumus (dengan pembulatan ke atas): <br><br><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi><mo>+</mo><msup><mi>N</mi><mn>2</mn></msup></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.388ex" height="2.78ex" viewBox="0 -935.7 6194.9 1197.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2B" x="1110" y="0"></use><g transform="translate(2111,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-4E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-32" x="1292" y="513"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-32" x="5694" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>N</mi><mo>+</mo><msup><mi>N</mi><mn>2</mn></msup></mrow><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ frac {N + N ^ 2} {2} </script>  , <br>  di mana N adalah jumlah langkah maju. <br><br>  Jadi untuk melangkah maju satu sel, pemain memberikan 1 wortel, 3 wortel untuk 2 sel, 6 wortel untuk 3 sel, 10 untuk 4, ..., 210 wortel untuk memindahkan 20 sel ke depan. <br><br>  Sel terakhir - sel dengan gambar kelinci - memperkenalkan unsur keacakan ke dalam permainan.  Setelah berdiri di kandang dengan kelinci, pemain mengambil kartu khusus dari tumpukan, setelah itu beberapa tindakan dilakukan.  Bergantung pada kartu dan situasi permainan, pemain dapat kehilangan beberapa wortel, mendapatkan wortel ekstra atau melewatkan satu putaran.  Perlu dicatat bahwa di antara kartu dengan "efek" ada beberapa skenario negatif bagi pemain, yang mendorong permainan untuk berhati-hati dan dihitung. <br><br><h2>  <font color="#3050ff">Implementasi tanpa AI</font> </h2><br>  Dalam implementasi pertama, yang kemudian akan menjadi dasar untuk pengembangan "kecerdasan" gaming, saya membatasi diri pada opsi di mana setiap pemain membuat gerakan - seseorang. <br><br>  Saya memutuskan untuk mengimplementasikan game sebagai klien - situs web satu halaman statis, semua "logika" yang diimplementasikan pada JS dan server - aplikasi WEB API.  Server ditulis dalam .NET Core 2.1 dan menghasilkan satu artefak perakitan - file dll, yang dapat dijalankan di bawah Windows / Linux / Mac OS. <br><br>  "Logika" dari bagian klien diminimalkan (serta UX, karena GUI adalah murni utilitarian).  Misalnya, klien web tidak melakukan pemeriksaan sendiri untuk melihat apakah aturan yang diminta oleh pemain dapat diterima.  Pemeriksaan ini dilakukan di server.  Server memberi tahu klien tentang gerakan apa yang dapat dilakukan pemain dari posisi permainan saat ini. <br><br>  Server adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin Moore</a> klasik.  Logika server tidak memiliki konsep seperti "klien yang terhubung", "sesi permainan", dll. <br><br>  Yang dilakukan server hanyalah memproses perintah yang diterima (HTTP POST).  Pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"perintah"</a> diterapkan di server.  Klien dapat meminta eksekusi salah satu dari perintah berikut: <br><br><ul><li>  memulai permainan baru, mis.  "Tempatkan" chip dari jumlah pemain yang ditentukan di papan "bersih" </li><li>  lakukan langkah yang ditunjukkan dalam perintah </li></ul><br>  Untuk tim kedua, klien mengirimkan server posisi permainan saat ini (objek dari kelas Disposisi), yaitu, deskripsi bentuk berikut: <br><br><ul><li>  posisi, jumlah wortel, dan selada untuk masing-masing kelinci, ditambah bidang Boolean tambahan yang menunjukkan bahwa kelinci tersebut kehilangan gilirannya </li><li>  indeks kelinci membuat langkah. </li></ul><br>  Server tidak perlu mengirim informasi tambahan - misalnya, informasi tentang lapangan permainan.  Sama seperti untuk merekam sketsa catur, Anda tidak perlu mengecat susunan sel hitam dan putih di papan tulis - informasi ini diambil sebagai konstanta. <br><br>  Sebagai tanggapan, server menunjukkan apakah perintah berhasil diselesaikan.  Secara teknis, klien dapat, misalnya, meminta langkah yang tidak valid.  Atau coba buat game baru untuk satu peserta, yang jelas tidak masuk akal. <br><br>  Jika tim berhasil, respons akan berisi <b>posisi</b> permainan baru, serta daftar gerakan yang dapat dilakukan oleh pemain berikutnya dalam antrian (saat ini untuk posisi baru). <br><br>  Selain itu, respons server berisi beberapa bidang layanan.  Misalnya, teks kartu seekor kelinci “ditarik keluar” oleh pemain pada langkah di kandang yang sesuai. <br><br><h4>  Putar Pemain </h4><br>  Giliran pemain dikodekan sebagai bilangan bulat: <br><br><ol><li>  0, jika pemain dipaksa untuk tetap di sel saat ini, <br>  1, 2, ... N untuk 1, ... N melangkah maju, </li><li>  -1, -2, ... -M untuk memindahkan 1 ... sel M kembali ke landak gratis terdekat, </li><li>  1001, 1002 - kode khusus untuk pemain yang memutuskan untuk tetap di sel wortel dan menerima (1001) atau memberikan (1002) 10 wortel untuk itu. </li></ol><br><h3>  Implementasi perangkat lunak </h3><br>  Server menerima JSON dari perintah yang diminta, mem-parsingnya ke dalam salah satu kelas permintaan yang sesuai, dan melakukan tindakan yang diminta. <br><br>  Jika klien (pemain) diminta untuk bergerak dengan kode CMD dari posisi (POS) yang ditransfer ke tim, server melakukan tindakan berikut: <br><br><ul><li>  memeriksa apakah langkah seperti itu mungkin dilakukan </li><li>  menciptakan posisi baru dari yang sekarang, menerapkan modifikasi yang sesuai dengannya, <br>  mendapat banyak kemungkinan gerakan untuk posisi baru.  Biarkan saya mengingatkan Anda bahwa indeks pemain yang bergerak sudah termasuk dalam objek yang menggambarkan <abbr title="Keadaan khusus, penyelarasan kekuatan, 'potret' permainan">posisi</abbr> , </li><li>  mengembalikan kepada klien jawaban dengan posisi baru, kemungkinan gerakan atau tanda sukses sama dengan false, dan deskripsi kesalahan. </li></ul><br>  Logika mengecek diterimanya langkah yang diminta (CMD) dan membangun posisi baru ternyata sedikit lebih dekat terhubung daripada yang kita inginkan.  Dengan logika ini, metode untuk menemukan gerakan yang dapat diterima memiliki kesamaan.  Semua fungsi ini diimplementasikan oleh kelas TurnChecker. <br><br>  Pada input metode pemeriksaan / eksekusi, TurnChecker menerima objek dari kelas posisi permainan (Disposisi).  Objek Disposisi berisi larik data pemain (Haze [] hazes), indeks pemain yang bergerak + beberapa informasi layanan yang diisi selama pengoperasian objek TurnChecker. <br><br>  Lapangan bermain menggambarkan kelas FieldMap, yang diimplementasikan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">singleton</a> .  Kelas berisi array sel + beberapa informasi overhead yang digunakan untuk menyederhanakan / mempercepat perhitungan selanjutnya. <br><br><div class="spoiler">  <b class="spoiler_title">Pertimbangan Kinerja</b> <div class="spoiler_text">  Dalam implementasi kelas TurnChecker, saya mencoba untuk menghindari loop sebanyak mungkin.  Faktanya adalah bahwa metode untuk memperoleh seperangkat gerakan yang diizinkan / eksekusi langkah selanjutnya akan disebut ribuan (puluhan ribu) kali selama prosedur pencarian untuk langkah kuasi-optimal. <br><br>  Jadi, misalnya, saya menghitung berapa banyak sel yang pemain dapat maju dengan N wortel, menggunakan rumus: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Pow(<span class="hljs-number"><span class="hljs-number">8</span></span> * N + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Memeriksa apakah sel saya ditempati oleh salah satu pemain, saya tidak melihat daftar pemain (karena tindakan ini mungkin harus dilakukan berkali-kali), tetapi saya beralih ke kamus formulir <i>[cell_index, busy_cage_ flag] yang</i> diisi terlebih dahulu. <br><br>  Saat memeriksa apakah sel landak yang ditentukan adalah yang terdekat (di belakang) dengan sel saat ini yang ditempati oleh pemain, saya juga membandingkan posisi yang diminta dengan nilai dari kamus formulir <i>[cell_index, terdekat_back_dezh] _index]</i> - informasi statis. <br></div></div><br><h2>  <font color="#3050ff">Implementasi dengan AI</font> </h2><br>  Satu perintah ditambahkan ke daftar perintah yang diproses oleh server: jalankan langkah kuasi-optimal yang dipilih oleh program.  Tim ini adalah modifikasi kecil dari perintah "gerakan pemain", yang darinya, bidang gerakan ( <abbr title="Kode numerik dari perintah, misalnya, untuk bergerak 4 sel maju, 0 untuk menunggu, 1002 - memberikan 10 wortel ...">CMD</abbr> ) telah dihapus. <br><br>  Keputusan pertama yang muncul dalam pikiran adalah menggunakan heuristik untuk memilih langkah "terbaik".  Dengan analogi dengan catur, kita dapat mengevaluasi setiap posisi permainan yang diperoleh dengan langkah kita dengan menetapkan semacam peringkat untuk posisi ini. <br><br><h3>  Evaluasi posisi heuristik </h3><br>  Sebagai contoh, dalam catur, untuk membuat penilaian (tanpa merangkak ke dalam belantara bukaan) cukup sederhana: minimal, Anda dapat menghitung total "biaya" dari potongan-potongan dengan mengambil nilai ksatria / uskup untuk 3 pion, nilai rook menjadi 5 pion, ratu ke 9, dan raja untuk <i>int .MaxValue</i> pion.  Mudah untuk meningkatkan taksiran, misalnya, menambahnya (dengan faktor koreksi - faktor / eksponen atau fungsi lainnya): <br><br><ul><li>  jumlah kemungkinan gerakan dari posisi saat ini, </li><li>  rasio ancaman terhadap angka musuh / ancaman dari musuh. </li></ul><br>  Penilaian khusus diberikan pada posisi mat: <i>int.MaxValue</i> , jika skakmat menempatkan komputer, <i>int.MinValue</i> jika skakmat menempatkan orang tersebut. <br><br>  Jika Anda memesan prosesor catur untuk memilih langkah berikutnya, hanya dipandu oleh penilaian seperti itu, prosesor mungkin akan memilih bukan gerakan terburuk.  Khususnya: <br><br><ul><li>  Jangan lewatkan kesempatan untuk mengambil bagian yang lebih besar atau skakmat, </li><li>  kemungkinan besar, itu tidak akan mendorong angka-angka di sudut-sudut, </li><li>  Itu tidak membuat angka diserang lagi (mengingat jumlah ancaman dalam penilaian). </li></ul><br>  Tentu saja, gerakan komputer seperti itu tidak akan memberinya peluang sukses dengan lawan yang membuat gerakannya dalam arti sekecil apa pun.  Komputer akan mengabaikan salah satu colokan.  Selain itu, dia mungkin tidak ragu untuk menukar ratu dengan pion. <br><br>  Namun demikian, algoritma untuk evaluasi heuristik dari posisi bermain saat ini dalam catur (tanpa mengklaim kemenangan program juara) cukup transparan.  Anda tidak bisa mengatakan tentang game Hare dan Hedgehog. <br><br>  Dalam kasus umum, dalam game the Hare and the Hedgehog, pepatah yang agak kabur bekerja: " <b><i>lebih baik melangkah lebih jauh dengan lebih banyak wortel dan lebih sedikit selada</i></b> "  Namun, tidak semuanya begitu mudah.  Katakanlah, jika seorang pemain memiliki 1 kartu salad di tengah permainan, opsi ini bisa sangat bagus.  Tetapi pemain yang berdiri di garis finish dengan kartu salad jelas akan berada dalam situasi kalah.  Selain algoritma evaluasi, saya juga ingin dapat "mengintip" selangkah lebih maju, sama seperti ancaman terhadap potongan dapat dihitung dalam evaluasi heuristik dari posisi catur.  Sebagai contoh, ada baiknya mempertimbangkan bonus wortel yang diterima oleh pemain yang meninggalkan sel sel / posisi sel (1 ... 4), dengan mempertimbangkan jumlah pemain di depan. <br><br>  Saya menyimpulkan nilai akhir sebagai fungsi: <br><br>  <abbr title="E (stimulasi), nilai akhir">E</abbr> = Ks * S + Kc * C + Kp * P, <br><br>  di mana S, C, P adalah nilai yang dihitung menggunakan kartu salad (S) dan wortel © di tangan pemain, P adalah nilai yang diberikan kepada pemain untuk jarak yang ditempuh. <br><br>  Ks, Kc, Kp adalah faktor koreksi yang sesuai (mereka akan dibahas nanti). <br><br>  Cara termudah adalah saya menentukan tanda untuk <b>jalur yang dilalui</b> : <br>  P = i * 3, di mana i adalah indeks sel tempat pemain berada. <br><br>  Grading C (wortel) sudah lebih sulit. <br><br>  Untuk mendapatkan nilai C tertentu, saya memilih satu dari 3 fungsi <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mn>0</mn></msub><mo>,</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.216ex" height="2.419ex" viewBox="0 -780.1 4398.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="1011" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2C" x="1169" y="0"></use><g transform="translate(1614,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-31" x="1011" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2C" x="2783" y="0"></use><g transform="translate(3229,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-32" x="1011" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>0</mn></msub><mo>,</mo><msub><mi>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi>C</mi><mn>2</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> C_0, C_1, C_2 </script>  dari satu argumen (jumlah wortel di tangan).  Indeks fungsi C ([0, 1, 2]) ditentukan oleh posisi relatif pemain di lapangan bermain: <br><br><ul><li>  [0] jika pemain telah menyelesaikan kurang dari setengah lapangan bermain, </li><li>  [2] jika seorang pemain memiliki cukup (mb, bahkan banyak) wortel untuk diselesaikan, </li><li>  [1] dalam kasus lain. </li></ul><br><img src="https://habrastorage.org/webt/fo/cv/hr/focvhrlzpl_xuxxd8dmuw9atok8.png"><br><br>  Fungsi 0 dan 1 serupa: “nilai” setiap wortel di tangan pemain secara bertahap berkurang dengan meningkatnya jumlah wortel di tangan.  Gim ini jarang mendorong Plyushkins.  Dalam kasus 1 (setengah dari bidang berlalu), nilai wortel berkurang sedikit lebih cepat. <br><br>  Fungsi 2 (pemain dapat menyelesaikan), sebaliknya, mengenakan denda besar (nilai koefisien negatif) pada setiap wortel di tangan pemain - semakin banyak wortel, semakin besar koefisien penalti.  Karena dengan kelebihan wortel, hasil akhir dilarang oleh aturan permainan. <br><br>  Sebelum menghitung jumlah wortel di tangan pemain ditentukan dengan memperhitungkan wortel per langkah dari sel sel / nomor 1 ... 4. <br><br>  " <b>Selada</b> " kelas S disimpulkan dengan cara yang sama.  Bergantung pada jumlah salad di tangan pemain (0 ... 3), fungsi dipilih <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>S</mi><mn>0</mn></msub><mo>,</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.505ex" height="2.419ex" viewBox="0 -780.1 4092.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="867" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2C" x="1067" y="0"></use><g transform="translate(1512,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-31" x="867" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2C" x="2579" y="0"></use><g transform="translate(3025,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-32" x="867" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mn>0</mn></msub><mo>,</mo><msub><mi>S</mi><mn>1</mn></msub><mo>,</mo><msub><mi>S</mi><mn>2</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> S_0, S_1, S_2 </script>  atau <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>S</mi><mn>3</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.479ex" height="2.419ex" viewBox="0 -780.1 1067.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-33" x="867" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mn>3</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> S_3 </script>  .  Argumen fungsi <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>S</mi><mn>0</mn></msub><mo>&amp;#x2212;</mo><msub><mi>S</mi><mn>3</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.799ex" height="2.419ex" viewBox="0 -780.1 3357.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="867" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2212" x="1289" y="0"></use><g transform="translate(2290,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-33" x="867" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mn>0</mn></msub><mo>−</mo><msub><mi>S</mi><mn>3</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> S_0 - S_3 </script>  .  - lagi, jalur "relatif" yang dilalui oleh pemain.  Yaitu, jumlah sel dengan salad yang tersisa di depan (relatif terhadap sel yang ditempati oleh pemain): <br><br><img src="https://habrastorage.org/webt/91/as/ra/91asraqadihe0n0dgtruyw1efuc.png"><br><br>  Kurva <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>S</mi><mn>0</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.479ex" height="2.419ex" viewBox="0 -780.1 1067.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="867" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mn>0</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-6"> S_0 </script>  - fungsi evaluasi (S) pada jumlah sel selada di depan pemain (0 ... 5), untuk pemain dengan 0 kartu selada di tangan, <br>  kurva <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>S</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.479ex" height="2.298ex" viewBox="0 -780.1 1067.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-31" x="867" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>S</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> S_1 </script>  - fungsi yang sama untuk pemain dengan satu kartu salad, dll. <br><br>  Nilai akhir (E = Ks * S + Kc * C + Kp * P) dengan demikian memperhitungkan: <br><br><ul><li>  jumlah tambahan wortel yang akan diterima pemain segera sebelum kepindahannya sendiri, </li><li>  jalur pemain </li><li>  jumlah wortel dan selada di tangan yang mempengaruhi skor secara nonlinier. </li></ul><br>  Dan inilah cara komputer bermain, memilih langkah selanjutnya dengan skor heuristik maksimum: <br><br><img src="https://habrastorage.org/webt/nz/ze/4g/nzze4g5o3vbfug20cspijmdmnlg.gif"><br><br>  Pada prinsipnya, debutnya tidak terlalu buruk.  Namun, kita seharusnya tidak mengharapkan game yang bagus dari AI seperti itu: di tengah permainan, "robot" hijau mulai membuat gerakan berulang, dan pada akhirnya membuat beberapa iterasi bergerak maju - mundur ke landak, sampai akhirnya selesai.  Sebagian karena kebetulan, ia akan finis di belakang pemain - seseorang dengan selusin gerakan. <br><br><div class="spoiler">  <b class="spoiler_title">Catatan Implementasi</b> <div class="spoiler_text">  Perhitungan penilaian dikelola oleh kelas khusus - EstimationCalculator.  Fungsi untuk mengevaluasi posisi relatif terhadap kartu salad wortel dimuat ke dalam array di konstruktor <b>statis</b> dari kelas kalkulator.  Metode estimasi posisi menerima objek posisi itu sendiri dan indeks pemain, dari "sudut pandang" yang posisinya dievaluasi oleh algoritma.  Artinya, posisi permainan yang sama dapat menerima beberapa peringkat berbeda, tergantung pada pemain mana poin virtual dipertimbangkan. <br></div></div><br><h2>  <font color="#3050ff">Decision Tree dan Algoritma Minimax</font> </h2><br>  Kami menggunakan algoritma pengambilan keputusan dalam game Minimax yang antagonis.  Sangat bagus, menurut saya, algoritma ini dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini (terjemahan)</a> . <br><br>  Kami mengajarkan program untuk "melihat" beberapa langkah ke depan.  Misalkan, dari posisi saat ini (dan latar belakang tidak penting untuk algoritma - seperti yang kita ingat, program berfungsi sebagai <abbr title="Algoritme tidak memiliki 'keadaan internal'">mesin Moore</abbr> ), diberi nomor dengan angka 1, program dapat membuat dua gerakan.  Kami mendapatkan dua posisi yang memungkinkan, 2 dan 3. Selanjutnya adalah giliran pemain - orang (dalam kasus umum - musuh).  Dari posisi 2, lawan memiliki 3 gerakan, dari yang ketiga - hanya dua gerakan.  Selanjutnya, giliran untuk bergerak kembali ke program, yang, secara total, dapat membuat 10 gerakan dari 5 posisi yang memungkinkan: <br><br><img src="https://habrastorage.org/webt/j8/1p/yf/j81pyfcci31ot27y3xgfafiuqc4.gif"><br><br>  Misalkan, setelah langkah kedua komputer, permainan berakhir dan masing-masing posisi yang diterima dievaluasi dari sudut pandang pemain pertama dan kedua.  Dan kami sudah menerapkan algoritma evaluasi.  Mari kita evaluasi setiap posisi akhir (daun pohon 9 ... 18) dalam bentuk vektor <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><msub><mi>v</mi><mn>0</mn></msub><mo>,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.691ex" height="2.66ex" viewBox="0 -832 2881 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-5B" x="0" y="0"></use><g transform="translate(278,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="686" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2C" x="1217" y="0"></use><g transform="translate(1663,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-31" x="686" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-5D" x="2602" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><msub><mi>v</mi><mn>0</mn></msub><mo>,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-8"> [v_0, v_1] </script>  , <br>  dimana <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>v</mi><mn>0</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.182ex" height="1.817ex" viewBox="0 -520.7 939.4 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="686" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>v</mi><mn>0</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> v_0 </script>  - skor dihitung untuk pemain pertama, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>v</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.182ex" height="1.696ex" viewBox="0 -520.7 939.4 730.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-31" x="686" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>v</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-10"> v_1 </script>  - skor pemain kedua: <br><br><img src="https://habrastorage.org/webt/xk/g5/yw/xkg5ywgzotdosiz4e4soubsrava.png"><br><br>  Karena komputer membuat langkah terakhir, itu jelas akan memilih opsi di masing-masing sub pohon ([9, 10], [11], [12, 13], [14, 15, 16], [17, 18]) yang memberinya peringkat yang lebih baik.  Pertanyaan segera muncul: dengan prinsip apa seseorang harus memilih posisi "terbaik"? <br><br>  Misalnya, ada dua gerakan, setelah itu kami memiliki posisi dengan peringkat [5;  5] dan [2;  1].  Mengevaluasi pemain pertama.  Dua alternatif sudah jelas: <br><br><ul><li>  pemilihan posisi dengan nilai <b>absolut</b> maksimum dari skor ke-i untuk pemain ke-i.  Dengan kata lain, pembalap mulia Leslie, ingin sekali menang, tanpa memperhatikan pesaing.  Dalam hal ini, posisi dengan perkiraan [5;  5]. </li><li>  pilihan posisi dengan peringkat maksimum <b>relatif terhadap perkiraan pesaing</b> adalah profesor Iman yang licik, yang tidak melewatkan kesempatan untuk memberikan trik kotor pada musuh.  Misalnya, sengaja ketinggalan perencanaan pemain untuk memulai dari posisi kedua.  Item dengan peringkat [2;  1]. </li></ul><br>  Dalam implementasi perangkat lunak saya, saya membuat algoritme pemilihan tingkat (fungsi yang memetakan vektor tingkat ke nilai skalar untuk pemain ith) sebagai parameter khusus.  Tes lebih lanjut menunjukkan, yang mengejutkan saya, keunggulan strategi pertama - pilihan posisi dengan nilai absolut maksimum <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>v</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.927ex" height="1.817ex" viewBox="0 -520.7 829.8 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-69" x="686" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>v</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-11"> v_i </script>  . <br><br><div class="spoiler">  <b class="spoiler_title">Fitur implementasi perangkat lunak</b> <div class="spoiler_text">  Jika opsi pertama untuk memilih kelas terbaik ditentukan dalam pengaturan AI (kelas TurnMaker), kode metode yang sesuai akan berbentuk: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContractEstimateByAbsMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] estimationVector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> estimationVector[playerIndex]; }</code> </pre><br>  Metode kedua - relatif relatif terhadap posisi pesaing - diterapkan sedikit lebih rumit: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContractEstimateByRelativeNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[]eVector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> player</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? min = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pVal = eVector[player]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; eVector.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == player) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = pVal - eVector[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!min.HasValue || min.Value &gt; val) min = val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min.Value; }</code> </pre><br></div></div><br>  Estimasi yang dipilih (digarisbawahi dalam gambar) ditransfer ke tingkat atas.  Sekarang musuh harus memilih posisi, mengetahui posisi selanjutnya yang akan dipilih algoritma: <br><br><img src="https://habrastorage.org/webt/hf/pr/ox/hfproxjzdo7-_7ll2f90na7p5ky.png"><br><br>  Musuh, tentu saja, akan memilih posisi dengan peringkat terbaik untuk dirinya sendiri (yang mana <b>koordinat kedua</b> vektor mengambil nilai terbesar).  Perkiraan ini sekali lagi digarisbawahi dalam grafik. <br><br>  Akhirnya, kami kembali ke langkah pertama.  Komputer memilih, dan dia lebih suka bergerak dengan koordinat pertama terbesar dari vektor: <br><br><img src="https://habrastorage.org/webt/dr/f1/y-/drf1y-8s_h-orz173pj8fx2tam0.png"><br><br>  Dengan demikian, masalah terpecahkan - langkah kuasi-optimal ditemukan.  Misalkan skor heuristik 100% pada posisi daun pada pohon menunjukkan pemenang di masa depan.  Maka algoritma kami akan dengan tegas memilih langkah terbaik yang mungkin. <br><br>  Namun, skor heuristik adalah 100% akurat hanya ketika posisi <b>akhir</b> permainan dievaluasi - satu (atau beberapa) pemain telah selesai, pemenang ditentukan.  Oleh karena itu, memiliki kesempatan untuk melihat ke depan gerakan N - sebanyak yang diperlukan untuk memenangkan saingan dengan kekuatan yang sama, Anda dapat memilih langkah yang optimal. <br><br>  Tapi permainan tipikal untuk 2 pemain berlangsung rata-rata sekitar 30 - 40 gerakan (untuk tiga pemain - sekitar 60 gerakan, dll.).  Dari setiap posisi, seorang pemain biasanya dapat membuat sekitar 8 gerakan.  Akibatnya, pohon lengkap posisi yang memungkinkan untuk 30 gerakan akan terdiri dari sekitar <br><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>8</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>30</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-38" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>8</mn><mrow class="MJX-TeXAtom-ORD"><mn>30</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-12"> 8 ^ {30} </script>  = 1237940039285380274899124224 puncak! <br><br>  Dalam praktiknya, membangun dan "mem-parsing" pohon dengan ~ 100.000 posisi pada PC saya membutuhkan waktu sekitar 300 milidetik.  Yang memberi kita batas pada kedalaman pohon di level 7 - 8 (bergerak), jika kita ingin mengharapkan respons komputer tidak lebih dari satu detik. <br><br><div class="spoiler">  <b class="spoiler_title">Fitur implementasi perangkat lunak</b> <div class="spoiler_text">  Jelas, metode rekursif diperlukan untuk membangun pohon posisi dan menemukan langkah terbaik.  Pada input metode - posisi saat ini (di mana, seperti yang kita ingat, pemain sudah bergerak) dan level pohon saat ini (nomor langkah).  Segera setelah kami turun ke level maksimum yang diizinkan oleh pengaturan algoritma, fungsi mengembalikan vektor estimasi posisi heuristik dari "sudut pandang" masing-masing pemain. <br><br>  <b><font color="#ff0000">Tambahan penting</font></b> : keturunan di bawah pohon juga harus dihentikan ketika pemain saat ini selesai.  Kalau tidak (jika algoritma untuk memilih posisi terbaik relatif terhadap posisi pemain lain dipilih), program dapat "menginjak" di finish untuk waktu yang lama, "mengejek" lawan.  Selain itu, dengan cara ini kita akan sedikit mengurangi ukuran pohon di endgame. <br><br>  Jika kita belum berada pada level rekursi tertinggi, maka kita memilih gerakan yang mungkin, buat posisi baru untuk setiap gerakan dan meneruskannya ke panggilan rekursif dari metode saat ini. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Mengapa Minimax?</b> <div class="spoiler_text">  Dalam interpretasi asli para pemain selalu dua.  Program ini menghitung skor secara eksklusif dari posisi pemain pertama.  Dengan demikian, ketika memilih posisi "terbaik", pemain dengan indeks 0 mencari posisi dengan peringkat maksimum, pemain dengan indeks 1 mencari minimum. <br><br>  Dalam kasus kami, peringkat harus berupa vektor sehingga masing-masing pemain N dapat mengevaluasinya dari "sudut pandang", karena peringkat naik ke pohon. <br></div></div><br><h2>  <font color="#3050ff">Tuning AI</font> </h2><br>  Praktek saya bermain melawan komputer telah menunjukkan bahwa algoritma tidak begitu buruk, tetapi masih kalah dengan manusia.  Saya memutuskan untuk meningkatkan AI dalam dua cara: <br><br><ul><li>  mengoptimalkan konstruksi / traversal dari pohon keputusan, </li><li>  meningkatkan heuristik. </li></ul><br><h3>  Optimasi algoritma Minimax </h3><br>  Pada contoh di atas, kita dapat menolak untuk mempertimbangkan posisi 8 dan “menyimpan” 2 - 3 simpul pohon: <br><br><img src="https://habrastorage.org/webt/-h/ce/hb/-hcehbcs1t-bcynqfe7j_cmnjp4.png"><br><br>  Kami berjalan di sekitar pohon dari atas ke bawah, dari kiri ke kanan.  Melewati subtree mulai dari posisi 2, kami menyimpulkan perkiraan terbaik untuk langkah 1 -&gt; 2: [3, 2].  Memotong subtree dengan root di posisi 7, kami menentukan peringkat saat ini (terbaik untuk bergerak 3 -&gt; 7): [2, 4].  Dari sudut pandang komputer (pemain pertama), skor [2, 4] lebih buruk daripada skor [3, 2].  Dan karena lawan komputer memilih langkah dari posisi 3, berapa pun skor untuk posisi 8, skor akhir untuk posisi 3 akan lebih buruk daripada skor yang diperoleh untuk posisi ketiga.  Dengan demikian, subtree dengan root di posisi 8 tidak dapat dibangun dan tidak dievaluasi. <br><br>  Versi optimal dari algoritma Minimax, yang memungkinkan Anda untuk memotong sub-sub pohon berlebih, disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma kliping alpha-beta</a> .  Menerapkan algoritma ini akan memerlukan modifikasi kecil pada kode sumber. <br><br><div class="spoiler">  <b class="spoiler_title">Fitur implementasi perangkat lunak</b> <div class="spoiler_text">  Dua parameter integer juga diteruskan ke metode CalcEstimate dari kelas TurnMaker - alpha, yang sama dengan int.MinValue awalnya dan beta, yaitu int.MaxValue.  Lebih lanjut, setelah menerima estimasi pergerakan saat ini dalam pertimbangan, pseudocode dari form dieksekusi: <br><br><pre> <code class="1c hljs"> e = _[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//        (  )  (e &gt; alpha) alpha = e   (e &lt; beta) beta = e  (beta &lt;= alpha)    </span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fitur penting dari implementasi perangkat lunak</b> <div class="spoiler_text">  metode kliping alpha-beta, menurut definisi, mengarah ke solusi yang sama dengan algoritma Minimax "bersih".  Untuk memeriksa apakah logika pengambilan keputusan telah berubah (atau lebih tepatnya, hasilnya bergerak), saya menulis tes unit di mana robot membuat 8 gerakan untuk masing-masing 2 lawan (total 16 gerakan) dan menyimpan serangkaian gerakan yang dihasilkan - dengan opsi kliping <b>dinonaktifkan</b> . <br><br>  Kemudian, dalam tes yang sama, prosedur diulangi dengan opsi kliping <b>dihidupkan</b> .  Setelah itu, urutan gerakan dibandingkan.  Perbedaan dalam gerakan menunjukkan kesalahan dalam implementasi algoritma kliping alpha-beta (tes gagal). <br></div></div><br><h3>  Optimalisasi kliping alpha-beta kecil </h3><br>  Dengan opsi kliping diaktifkan di pengaturan AI, jumlah simpul di pohon posisi berkurang rata-rata 3 kali.  Hasil ini bisa agak ditingkatkan. <br><br>  Dalam contoh di atas: <br><br><img src="https://habrastorage.org/webt/-h/ce/hb/-hcehbcs1t-bcynqfe7j_cmnjp4.png"><br><br>  begitu berhasil "bertepatan" sehingga, sebelum subtree dengan vertex di posisi 3, kami memeriksa subtree dengan vertex di posisi 2. Jika urutannya berbeda, kita bisa mulai dengan subtree "terburuk" dan tidak menyimpulkan bahwa tidak ada gunanya mempertimbangkan posisi berikutnya. . <br><br>  Sebagai aturan, kliping pada pohon ternyata lebih “ekonomis”, simpul turunannya pada level yang sama (yaitu, semua kemungkinan pergerakan dari posisi-i) sudah diurutkan berdasarkan estimasi posisi saat ini (tanpa melihat ke dalam).  Dengan kata lain, kami menganggap bahwa langkah terbaik (dari sudut pandang heuristik) lebih mungkin untuk mendapatkan nilai akhir yang lebih baik.  Jadi, kami, dengan beberapa kemungkinan, mengurutkan pohon sehingga subtree "terbaik" akan dipertimbangkan sebelum yang "terburuk", yang akan memungkinkan kami untuk memotong lebih banyak opsi. <br><br>  Penilaian posisi saat ini adalah prosedur yang mahal.  Jika sebelumnya cukup bagi kita untuk mengevaluasi hanya posisi terminal (daun), maka sekarang penilaian dibuat untuk semua simpul pohon.  Namun, seperti yang ditunjukkan oleh tes, jumlah perkiraan yang dibuat masih sedikit kurang dari dalam versi tanpa penyortiran awal dari kemungkinan langkah. <br><br><div class="spoiler">  <b class="spoiler_title">Fitur implementasi perangkat lunak</b> <div class="spoiler_text">  Algoritme kliping alpha-beta mengembalikan langkah yang sama dengan algoritma Minimax asli.  Ini memeriksa unit test yang kami tulis, membandingkan dua urutan gerakan (untuk algoritma dengan kliping dan tanpa).  Pemangkasan alfa-beta <b>dengan penyortiran</b> , dalam kasus umum, dapat mengindikasikan <b>perpindahan berbeda</b> sebagai kuasi-optimal. <br><br>  Untuk menguji operasi yang benar dari algoritma yang dimodifikasi, Anda perlu tes baru.  Meskipun ada modifikasi, algoritma dengan pengurutan harus menghasilkan <b>vektor estimasi akhir yang</b> persis sama ([3, 2] pada contoh pada gambar) sebagai algoritma tanpa pengurutan seperti algoritma Minimax asli. <br><br>  Dalam pengujian, saya membuat serangkaian posisi uji dan memilih dari masing-masing sesuai dengan gerakan "terbaik", menghidupkan dan mematikan opsi pengurutan.  Kemudian ia membandingkan vektor evaluasi yang diperoleh dengan dua cara. <br></div></div><br>  Selain itu, karena posisi untuk masing-masing gerakan yang mungkin dalam simpul pohon saat ini diurutkan berdasarkan evaluasi heuristik, itu memunculkan ide untuk segera membuang beberapa opsi terburuk.  Sebagai contoh, seorang pemain catur dapat mempertimbangkan gerakan di mana ia mengganti bentengnya untuk pukulan gadai.  Namun, dengan "membuka gulungan" situasi secara mendalam dengan 3, 4 ... maju bergerak, ia akan segera melihat opsi ketika, misalnya, lawan menempatkan uskup ratu diserang. <br><br>  Dalam pengaturan AI, saya mengatur vektor "kliping opsi terburuk".  Misalnya, vektor formulir [0, 0, 8, 8, 4] berarti bahwa: <br><br><ul><li>  melihat satu [0] dan dua [0] langkah maju, program akan mempertimbangkan semua kemungkinan langkah, karena 0   , </li><li>    [8]   [8]  ,    8 “” ,    , , </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melihat lima atau lebih langkah ke depan [4], program ini akan mengevaluasi tidak lebih dari 4 gerakan "terbaik". </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan penyortiran diaktifkan untuk algoritma kliping alfa-beta dan vektor yang serupa dalam pengaturan kliping, program mulai menghabiskan sekitar 300 milidetik untuk memilih langkah semu-optimal, “melangkah lebih dalam” 8 langkah maju. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimalisasi Heuristik </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari jumlah posisi vertex yang layak yang diulang di pohon dan "dalam" memandang ke depan untuk mencari langkah kuasi-optimal, AI memiliki beberapa kelemahan. </font><font style="vertical-align: inherit;">Saya mendefinisikan salah satu dari mereka sebagai " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perangkap kelinci</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkap kelinci</font></font></b> <div class="spoiler_text">       .   ( 8 — 10   15),     .     “”          (   !): <br><br><ul><li>           7, </li><li>    ,    ,  .   ,  ,    ,      . </li></ul><br>        .  : <br><br><img src="https://habrastorage.org/webt/qn/y-/wr/qny-wrq0dgtlr16wwj1ibekhk5g.png"><br><br>     54   (43),      —   10     55 .  AI,   ,      (61),  28 .       ,   6          9 (      10 ). <br><br>   ,       ( ),         ,        4 — 6 .   , ,          , AI     ? <br><br>   ,     <b> </b> ,   . AI      .            ,      ,    .      “ ”  : <br><br>                  65 —    “”  , ,      .         ,            ,  ,    ()    . <br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faktor Koreksi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, memberikan rumus untuk estimasi heuristik dari posisi saat ini </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E = Ks * S + Kc * C + Kp * P, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saya sebutkan, tetapi tidak menjelaskan, faktor koreksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya adalah bahwa rumus itu sendiri dan set fungsi</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>C</mi><mn>0</mn></msub><mo>.</mo><mo>.</mo><msub><mi>C</mi><mn>2</mn></msub><mo>,</mo><msub><mi>S</mi><mn>0</mn></msub><mo>.</mo><mo>.</mo><msub><mi>S</mi><mn>5</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.56ex" height="2.419ex" viewBox="0 -780.1 6699.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="1011" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2E" x="1169" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2E" x="1614" y="0"></use><g transform="translate(2059,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-43" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-32" x="1011" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2C" x="3229" y="0"></use><g transform="translate(3674,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-30" x="867" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2E" x="4741" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-2E" x="5186" y="0"></use><g transform="translate(5632,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMATHI-53" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-35" x="867" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>0</mn></msub><mo>.</mo><mo>.</mo><msub><mi>C</mi><mn>2</mn></msub><mo>,</mo><msub><mi>S</mi><mn>0</mn></msub><mo>.</mo><mo>.</mo><msub><mi>S</mi><mn>5</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-13">C_0 .. C_2, S_0 .. S_5</script><br><br><br><br><br><br><pre> <code class="cs hljs"> <span class="hljs-number"><span class="hljs-number">45</span></span>;<span class="hljs-number"><span class="hljs-number">26</span></span>;<span class="hljs-number"><span class="hljs-number">2</span></span>;f;<span class="hljs-number"><span class="hljs-number">29</span></span>;<span class="hljs-number"><span class="hljs-number">19</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;f;<span class="hljs-number"><span class="hljs-number">2</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baris ini secara harfiah berarti yang berikut: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemain pertama berada di kotak 45, ia memiliki 26 kartu wortel dan 2 kartu salad di tangannya, pemain tidak ketinggalan langkah (f = false). </font><font style="vertical-align: inherit;">Hak untuk bergerak selalu menjadi pemain pertama.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pemain kedua pada sel 29 dengan 19 kartu wortel dan tanpa kartu salad, tidak ketinggalan bergerak. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angka dua berarti bahwa, "memutuskan" studi, saya berasumsi bahwa pemain kedua berada dalam situasi kemenangan. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memasukkan 20 sketsa ke dalam program, saya “mengunduhnya” di game web-client, dan kemudian mengurutkan masing-masing sketsa. </font><font style="vertical-align: inherit;">Menganalisis sketsa, saya bergantian membuat gerakan untuk masing-masing pemain, sampai saya memutuskan "pemenang". </font><font style="vertical-align: inherit;">Setelah menyelesaikan penilaian, saya mengirimkannya dalam tim khusus ke server. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mengevaluasi 20 etudes (tentu saja, akan bermanfaat untuk menganalisis lebih banyak dari mereka), saya mengevaluasi masing-masing etudes oleh program. </font><font style="vertical-align: inherit;">Dalam evaluasi, nilai masing-masing faktor koreksi, dari 0,5 menjadi 2 dalam peningkatan 0,1 - total</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>16</mn><mn>3</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.379ex" height="2.419ex" viewBox="0 -935.7 1454.9 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-36" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/432382/&amp;usg=ALkJrhg6BGMDIDCQzrrQjYFC6JpXpfPc4g#MJMAIN-33" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>16</mn><mn>3</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-14">16^3</script><br><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ringkasan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, saya mendapatkan program yang berfungsi, yang, sebagai aturan, mengalahkan saya dalam versi satu-satu terhadap komputer. Statistik kemenangan dan kekalahan yang serius untuk versi program saat ini belum diakumulasikan. Mungkin penyetelan AI mudah berikutnya akan membuat kemenangan saya tidak mungkin. Atau hampir mustahil, karena faktor sel kelinci masih tetap ada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, dalam logika memilih peringkat (maksimum absolut atau relatif relatif terhadap pemain lain), saya pasti akan mencoba opsi perantara. Paling tidak, jika nilai absolut dari skor pemain ith adalah sama, masuk akal untuk memilih langkah yang mengarah ke posisi dengan nilai relatif yang lebih besar dari skor (gabungan dari bangsawan Leslie dan Feith yang berbahaya).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program ini berfungsi penuh untuk versi dengan 3 pemain. </font><font style="vertical-align: inherit;">Namun, ada kecurigaan bahwa “kualitas” pergerakan AI untuk bermain dengan 3 pemain lebih rendah daripada untuk bermain dengan dua pemain. </font><font style="vertical-align: inherit;">Namun, selama tes terakhir saya kehilangan komputer - mungkin karena kelalaian, dengan santai mengevaluasi jumlah wortel di tangan saya dan datang ke garis finish dengan kelebihan "bahan bakar". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, pengembangan lebih lanjut dari AI terhambat oleh kurangnya seseorang - "tester", yaitu, lawan hidup dari "jenius" komputer. </font><font style="vertical-align: inherit;">Saya sendiri memainkan cukup banyak Hare dan Hedgehog untuk mual dan dipaksa untuk mengganggu pada tahap saat ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ Tautan ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori dengan sumber</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432382/">https://habr.com/ru/post/id432382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432370/index.html">AlphaZero mengalahkan Stockfish dalam pertandingan 1.000 pertandingan</a></li>
<li><a href="../id432372/index.html">Microsoft telah secara resmi mengkonfirmasi bahwa Edge beralih ke mesin Chromium</a></li>
<li><a href="../id432374/index.html">Elasticsearch yang sangat mudah diakses dan dapat diukur di Kubernetes</a></li>
<li><a href="../id432378/index.html">Siswa kelas 10 dari Siberia ingin menjadi perancang prosesor. Mengapa tidak membuat akselerator saraf FPGA?</a></li>
<li><a href="../id432380/index.html">Enam tahun hidup dengan iPhone yang tidak mengganggu saya</a></li>
<li><a href="../id432384/index.html">Studi: 22% pengguna Tumblr pergi ke situs porno, terutama anak perempuan</a></li>
<li><a href="../id432386/index.html">Meja bundar "Arsitek proyek TI", September 2018</a></li>
<li><a href="../id432392/index.html">Kami memiliki permainan jadul dan beberapa jamur: misi selesai</a></li>
<li><a href="../id432394/index.html">9 Lamoda Automation Lap Gudang Otomasi</a></li>
<li><a href="../id432398/index.html">Mode bootloader STM32 DFU menggunakan CubeMX. Petunjuk langkah demi langkah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>