<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèΩ üóæ üíº Enth√§lt Profiling-Programme in C ++ ü§¥üèº üôáüèª ‚õÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manchmal kann es erforderlich sein, die Programmleistung oder den Speicherverbrauch in einem C ++ - Programm zu profilieren. Leider ist dies oft nicht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enth√§lt Profiling-Programme in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482040/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/sv/vy/xjsvvy62rgww5jixemahqzaz0yi.jpeg"></div><br>  Manchmal kann es erforderlich sein, die Programmleistung oder den Speicherverbrauch in einem C ++ - Programm zu profilieren.  Leider ist dies oft nicht so einfach, wie es scheint. <br><br>  Hier werden die Funktionen von Profiling-Programmen mit den <b>Tools</b> <b>valgrind</b> und <b>google perftools erl√§utert</b> .  Das Material erwies sich als nicht sehr strukturiert, es ist eher ein Versuch, eine Wissensbasis ‚Äûf√ºr pers√∂nliche Zwecke‚Äú aufzubauen, damit Sie sich in Zukunft nicht verzweifelt daran erinnern m√ºssen, ‚Äûwarum dies nicht funktioniert‚Äú oder ‚Äûwie es geht‚Äú.  H√∂chstwahrscheinlich sind hier nicht alle nicht offensichtlichen F√§lle betroffen. Wenn Sie etwas hinzuzuf√ºgen haben, schreiben Sie dies bitte in die Kommentare. <br><br>  Alle Beispiele laufen auf dem Linux-System. <a name="habracut"></a><br><br><h2>  Laufzeit-Profilerstellung </h2><br><h3>  Vorbereitung </h3><br>  Um die Funktionen der Profilerstellung zu analysieren, f√ºhre ich kleine Programme aus, die normalerweise aus einer main.cpp-Datei und einer func.cpp-Datei zusammen mit der Aufnahme bestehen. <br>  Ich werde sie mit dem <b>G ++ 8.3.0 Compiler kompilieren</b> . <br><br>  Da das <b>Erstellen von</b> Profilen f√ºr nicht optimierte Programme eine ziemlich seltsame Aufgabe ist, kompilieren wir mit der Option <b>-Ofast.</b> Um Debug-Zeichen in der Ausgabe zu erhalten, vergessen wir nicht, die Option <b>-g</b> hinzuzuf√ºgen.  Manchmal werden jedoch anstelle von normalen Funktionsnamen nur nicht h√∂rbare Anrufadressen angezeigt.  Dies bedeutet, dass eine "Randomisierung der Adressraumzuweisung" stattgefunden hat.  Dies kann durch Aufrufen des Befehls <b>nm</b> in der Bin√§rdatei ermittelt werden.  Wenn die meisten Adressen so aussehen wie 00000000000030e0 (eine gro√üe Anzahl von Nullen am Anfang), ist dies h√∂chstwahrscheinlich der Fall.  In einem normalen Programm sehen die Adressen wie folgt aus: 0000000000402fa0.  Daher m√ºssen Sie die Option <b>-no-pie</b> hinzuf√ºgen.  Infolgedessen sieht der vollst√§ndige Optionssatz folgenderma√üen aus: <br>  <b>-Ofast -g -no-pie</b> <br><br>  Um die Ergebnisse anzuzeigen, verwenden wir das Programm <b>KCachegrind</b> , das mit dem <b>Callgrind-</b> Berichtsformat arbeiten kann <br><br><h3>  Callgrind </h3><br>  Das erste Dienstprogramm, das wir uns heute ansehen werden, ist <b>callgrind</b> .  Dieses Dienstprogramm ist Teil des valgrind-Tools.  Es emuliert jede ausf√ºhrbare Anweisung des Programms und gibt auf der Grundlage interner Metriken zu den ‚ÄûKosten‚Äú jeder Anweisung die Schlussfolgerung aus, die wir ben√∂tigen.  Aufgrund dieser Vorgehensweise kann es vorkommen, dass Callgrind den n√§chsten Befehl nicht erkennt und mit einem Fehler ausf√§llt <br>  <i>Nicht erkannte Anweisung an Adresse</i> <br>  Der einzige Ausweg aus dieser Situation ist, alle Kompilierungsoptionen zu √ºberdenken und zu versuchen, die St√∂rung zu finden <br><br>  Erstellen wir ein Programm zum Testen dieses Tools, das aus einer gemeinsam genutzten Bibliothek und einer statischen Bibliothek besteht (Bibliotheken werden sp√§ter in anderen Tests aufgegeben).  Jede Bibliothek sowie das Programm selbst bieten eine einfache Rechenfunktion, beispielsweise die Berechnung der Fibonacci-Sequenz. <br><br><div class="spoiler">  <b class="spoiler_title">static_lib</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////////// // static_lib.h // ////////////////// #ifndef SERVER_STATIC_LIB_H #define SERVER_STATIC_LIB_H int func_static_lib(int arg); #endif //SERVER_STATIC_LIB_H //////////////////// // static_lib.cpp // /////////////////// #include "static_lib.h" #include "static_func.h" #include &lt;cstddef&gt; int func_static_lib(int arg) { return static_func(arg); } /////////////////// // static_func.h // /////////////////// #ifndef TEST_PROFILER_STATIC_FUNC_H #define TEST_PROFILER_STATIC_FUNC_H int static_func(int arg); #endif //TEST_PROFILER_STATIC_FUNC_H ///////////////////// // static_func.cpp // ///////////////////// #include "static_func.h" int static_func(int arg) { int fst = 0; int snd = 1; for (int i = 0; i &lt; arg; i++) { int tmp = (fst + snd) % 17769897; fst = snd; snd = tmp; } return fst; }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">shared_lib</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////////// // shared_lib.h // ////////////////// #ifndef TEST_PROFILER_SHARED_LIB_H #define TEST_PROFILER_SHARED_LIB_H int func_shared_lib(int arg); #endif //TEST_PROFILER_SHARED_LIB_H //////////////////// // shared_lib.cpp // //////////////////// #include "shared_lib.h" #include "shared_func.h" int func_shared_lib(int arg) { return shared_func(arg); } /////////////////// // shared_func.h // /////////////////// #ifndef TEST_PROFILER_SHARED_FUNC_H #define TEST_PROFILER_SHARED_FUNC_H int shared_func(int arg); #endif //TEST_PROFILER_SHARED_FUNC_H ///////////////////// // shared_func.cpp // ///////////////////// #include "shared_func.h" int shared_func(int arg) { int result = 1; for (int i = 1; i &lt; arg; i++) { result = (int)(((long long)result * i) % 19637856977); } return result; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////// // main.cpp // ////////////// #include &lt;iostream&gt; #include "static_lib.h" #include "shared_lib.h" #include "func.h" int main(int argc, char **argv) { if (argc != 2) { std::cout &lt;&lt; "Incorrect args"; return -1; } const int arg = std::atoi(argv[1]); std::cout &lt;&lt; "result: " &lt;&lt; func_static_lib(arg) &lt;&lt; " " &lt;&lt; func_shared_lib(arg) &lt;&lt; " " &lt;&lt; func(arg); return 0; } //////////// // func.h // //////////// #ifndef TEST_PROFILER_FUNC_H #define TEST_PROFILER_FUNC_H int func(int arg); #endif //TEST_PROFILER_FUNC_H ////////////// // func.cpp // ////////////// #include "func.h" int func(int arg) { int fst = 1; int snd = 1; for (int i = 0; i &lt; arg; i++) { int res = (fst + snd + 1) % 19845689; fst = snd; snd = res; } return fst; }</span></span></code> </pre><br></div></div><br>  Wir kompilieren das Programm und f√ºhren valgrind folgenderma√üen aus: <br><br><pre> <code class="bash hljs">valgrind --tool=callgrind ./test_profiler 100000000</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/i7/xa/tt/i7xattm3xphucvb3x5ogxlbpv20.png"></a> <br>  Wir sehen, dass f√ºr eine statische Bibliothek und eine regul√§re Funktion das Ergebnis dem erwarteten √§hnlich ist.  In der dynamischen Bibliothek konnte callgrind die Funktion jedoch nicht vollst√§ndig aufl√∂sen. <br><br>  Um dies zu beheben, m√ºssen Sie beim Starten des Programms die Variable <b>LD_BIND_NOW</b> wie <b>folgt</b> auf 1 setzen: <br><br><pre> <code class="bash hljs">LD_BIND_NOW=1 valgrind --tool=callgrind ./test_profiler 100000000</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/nb/l2/yb/nbl2ybqiy6atyd5cak6evogfbem.png"></a> <br>  Und jetzt ist, wie Sie sehen, alles in Ordnung <br><br>  Das n√§chste Callgrind-Problem bei der Profilerstellung durch Emulation von Anweisungen besteht darin, dass die Programmausf√ºhrung erheblich verlangsamt wird.  Dies kann eine falsche relative Sch√§tzung der Ausf√ºhrungszeit verschiedener Teile des Codes enthalten. <br><br>  Schauen wir uns diesen Code an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fst = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> snd = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ofstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"tmp.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = (fst + snd + <span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">19845689</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(res); file &lt;&lt; res; file.flush(); fst = snd; snd = res + r.size(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fst; }</code> </pre><br>  Hier habe ich f√ºr jede Iteration der Schleife eine kleine Datenmenge zu einer Datei hinzugef√ºgt.  Da das Schreiben in eine Datei als Gegengewicht ziemlich langwierig ist, habe ich zu jeder Iteration der Schleife eine Zeilengenerierung aus einer Zahl hinzugef√ºgt.  Offensichtlich dauert in diesem Fall der Schreibvorgang in die Datei l√§nger als der Rest der Logik der Funktion.  Aber callgrind denkt anders: <br> <a href=""><img src="https://habrastorage.org/webt/hn/pg/zt/hnpgztqrtptlu7_g0tmr5frgbuy.png"></a> <br><br>  Es ist auch zu bedenken, dass Callgrind die Kosten einer Funktion nur messen kann, wenn sie funktioniert.  Die Funktion funktioniert nicht - daher steigen die Kosten nicht.  Dies erschwert das Debuggen von Programmen, die von Zeit zu Zeit in die Sperre eintreten oder mit einem blockierenden Dateisystem / Netzwerk arbeiten.  Lassen Sie uns √ºberpr√ºfen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; static std::mutex mutex; int funcImpl(int arg) { std::lock_guard&lt;std::mutex&gt; lock(mutex); int fst = 1; int snd = 1; for (int i = 0; i &lt; arg; i++) { int res = (fst + snd + 1) % 19845689; fst = snd; snd = res; } return fst; } int func2(int arg){ return funcImpl(arg); } int func(int arg) { return funcImpl(arg); } int main(int argc, char **argv) { if (argc != 2) { std::cout &lt;&lt; "Incorrect args"; return -1; } const int arg = std::atoi(argv[1]); auto future = std::async(std::launch::async, &amp;func2, arg); std::cout &lt;&lt; "result: " &lt;&lt; func(arg) &lt;&lt; std::endl; std::cout &lt;&lt; "second result " &lt;&lt; future.get() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Hier haben wir die gesamte Funktionsausf√ºhrung in die Sperre des Mutex eingeschlossen und diese Funktion aus zwei verschiedenen Threads aufgerufen.  Das Ergebnis von Callgrind ist ziemlich vorhersehbar - er sieht kein Problem beim Erfassen eines Mutex: <br> <a href=""><img src="https://habrastorage.org/webt/be/eh/nj/beehnjstn0h_kjbjjq2by_randc.png"></a> <br><br>  Daher haben wir einige Probleme bei der Verwendung des Callgrind-Profilers untersucht.  Fahren wir mit dem n√§chsten Testthema fort - dem Google Perftools Profiler <br><br><h3>  Google Perftools </h3><br>  Im Gegensatz zu Callgrind arbeitet der Google Profiler nach einem anderen Prinzip. <br>  Anstatt jeden Befehl des ausf√ºhrbaren Programms zu analysieren, unterbricht es das Programm in regelm√§√üigen Abst√§nden und versucht festzustellen, in welcher Funktion es sich gerade befindet.  Infolgedessen wirkt sich dies fast nicht auf die Leistung der ausgef√ºhrten Anwendung aus.  Dieser Ansatz hat aber auch seine Schw√§chen. <br><br>  Beginnen wir mit der Profilerstellung des ersten Programms mit zwei Bibliotheken. <br><br>  In der Regel m√ºssen Sie zum Starten der Profilerstellung mit diesem Dienstprogramm die Bibliothek libprofiler.so vorab laden, die Abtastfrequenz festlegen und die Datei angeben, in der der Speicherauszug gespeichert werden soll.  Leider muss der Profiler das Programm "von selbst" beenden.  Bei erzwungener Beendigung des Programms wird der Bericht einfach nicht gel√∂scht.  Dies ist unpraktisch, wenn Sie ein Profil f√ºr langlebige Programme erstellen, die selbst nicht angehalten werden, z. B. Daemons.  Um dieses Hindernis zu umgehen, habe ich folgendes Skript erstellt: <br><br><div class="spoiler">  <b class="spoiler_title">gprof.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs">rnd=<span class="hljs-variable"><span class="hljs-variable">$RANDOM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$#</span></span> -eq 0 ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"./gprof.sh command args"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Run with variable N_STOP=true if hand stop required"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> libprofiler=$( dirname <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASH_SOURCE[0]}</span></span></span><span class="hljs-string">"</span></span> ) arg=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> nostop=<span class="hljs-variable"><span class="hljs-variable">$N_STOP</span></span> profileName=callgrind.out.<span class="hljs-variable"><span class="hljs-variable">$rnd</span></span>.g gperftoolProfile=./gperftool.<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$rnd</span></span></span><span class="hljs-string">"</span></span>.txt touch <span class="hljs-variable"><span class="hljs-variable">$profileName</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Profile name </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$profileName</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$nostop</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"without stop"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> <span class="hljs-string"><span class="hljs-string">'echo trap &amp;&amp; kill -12 $PID &amp;&amp; sleep 1 &amp;&amp; kill -TERM $PID'</span></span> TERM INT <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> <span class="hljs-string"><span class="hljs-string">'echo trap &amp;&amp; kill -TERM $PID'</span></span> TERM INT <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$nostop</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CPUPROFILESIGNAL=12 CPUPROFILE_FREQUENCY=1000000 CPUPROFILE=<span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span> LD_PRELOAD=<span class="hljs-variable"><span class="hljs-variable">${libprofiler}</span></span>/libprofiler.so <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${@:1}</span></span></span><span class="hljs-string">"</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CPUPROFILE_FREQUENCY=1000000 CPUPROFILE=<span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span> LD_PRELOAD=<span class="hljs-variable"><span class="hljs-variable">${libprofiler}</span></span>/libprofiler.so <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${@:1}</span></span></span><span class="hljs-string">"</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> PID=$! <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$nostop</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ]] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> sleep 1 <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -12 <span class="hljs-variable"><span class="hljs-variable">$PID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-variable"><span class="hljs-variable">$PID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> - TERM INT <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-variable"><span class="hljs-variable">$PID</span></span> EXIT_STATUS=$? <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span> <span class="hljs-variable"><span class="hljs-variable">${libprofiler}</span></span>/pprof --callgrind <span class="hljs-variable"><span class="hljs-variable">$arg</span></span> <span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span>* &gt; <span class="hljs-variable"><span class="hljs-variable">$profileName</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Profile name </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$profileName</span></span></span><span class="hljs-string">"</span></span> rm -f <span class="hljs-variable"><span class="hljs-variable">$gperftoolProfile</span></span>*</code> </pre><br></div></div><br>  Dieses Dienstprogramm muss ausgef√ºhrt werden und als Parameter den Namen der ausf√ºhrbaren Datei und eine Liste ihrer Parameter √ºbergeben.  Au√üerdem wird davon ausgegangen, dass sich neben dem Skript die Dateien befinden, die libprofiler.so und pprof ben√∂tigen.  Wenn das Programm langlebig ist und die Ausf√ºhrung unterbricht, m√ºssen Sie die Variable N_STOP auf true setzen. Beispiel: <br><pre> <code class="bash hljs">N_STOP=<span class="hljs-literal"><span class="hljs-literal">true</span></span> ./gprof.sh ./test_profiler 10000000000</code> </pre> <br>  Am Ende der Arbeit generiert das Skript einen Bericht in meinem bevorzugten Callgrind-Format. <br><br>  Lassen Sie uns also unser Programm unter diesem Profiler ausf√ºhren. <br><pre> <code class="bash hljs">./gprof.sh ./test_profiler 1000000000</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/qg/q_/sw/qgq_sw__etaj7mmmrgzvgw_b70c.png"></a> <br>  Im Prinzip ist alles ziemlich klar. <br><br>  Wie gesagt, der Google Profiler beendet die Ausf√ºhrung des Programms und berechnet die aktuelle Funktion.  Wie macht er das?  Dazu dreht er den Stapel auf.  Aber was ist, wenn das Programm zum Zeitpunkt der Stapelaktion den Stapel selbst abwickelt?  Nun, offensichtlich wird nichts Gutes passieren.  Lass es uns ausprobieren.  Schreiben wir eine solche Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runExcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res % <span class="hljs-number"><span class="hljs-number">13</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"Exception"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fst = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> snd = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = (fst + snd + <span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">19845689</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = runExcept(res); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;e) { res = res - <span class="hljs-number"><span class="hljs-number">1</span></span>; } fst = snd; snd = res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fst; }</code> </pre><br>  F√ºhren Sie die Profilerstellung aus.  Das Programm friert ziemlich schnell ein. <br><br>  Es gibt ein weiteres Problem im Zusammenhang mit der Besonderheit der Profiler-Operation.  Angenommen, wir haben es geschafft, den Stapel aufzuheben, und jetzt m√ºssen wir die Adressen mit den spezifischen Funktionen des Programms abgleichen.  Dies kann sehr untrivial sein, da in C ++ eine ziemlich gro√üe Anzahl von Funktionen inline sind.  Schauen wir uns ein Beispiel an: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> static int func1(int arg) { std::cout &lt;&lt; 1 &lt;&lt; std::endl; return func(arg); } static int func2(int arg) { std::cout &lt;&lt; 2 &lt;&lt; std::endl; return func(arg); } static int func3(int arg) { std::cout &lt;&lt; 3 &lt;&lt; std::endl; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg % 2 == 0) { return func2(arg); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { return func1(arg); } } int main(int argc, char **argv) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 2) { std::cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Incorrect args"</span></span></span><span class="hljs-meta">; return -1; } const int arg = std::atoi(argv[1]); int arg2 = func3(arg); int arg3 = func(arg); std::cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"result: "</span></span></span><span class="hljs-meta"> &lt;&lt; arg2 + arg3; return 0; }</span></span></code> </pre><br>  Wenn Sie das Programm beispielsweise folgenderma√üen ausf√ºhren: <br><pre> <code class="bash hljs">./gprof.sh ./test_profiler 1000000000</code> </pre> <br>  dann wird die Funktion func1 niemals aufgerufen.  Aber der Profiler denkt anders: <br> <a href=""><img src="https://habrastorage.org/webt/8-/0o/ny/8-0onyayanqwvdarg94cd92srzc.png"></a> <br>  (√úbrigens hat sich valgrind hier entschlossen, bescheiden zu schweigen und nicht anzugeben, von welcher bestimmten Funktion der Aufruf kam). <br><br><h2>  Speicherprofilerstellung </h2><br>  Oft gibt es Situationen, in denen der Speicher von der Anwendung irgendwo "flie√üt".  Wenn dies auf eine fehlende Ressourcenbereinigung zur√ºckzuf√ºhren ist, sollte Memcheck helfen, das Problem zu identifizieren.  In modernem C ++ ist es jedoch nicht so schwierig, auf manuelles Ressourcenmanagement zu verzichten.  unique_ptr, shared_ptr, vector, map machen Bare-Point-Manipulation sinnlos. <br><br>  In solchen Anwendungen tritt jedoch ein Speicherverlust auf.  Wie l√§uft das  Ganz einfach, es ist in der Regel so etwas wie "den Wert in eine langlebige Karte einf√ºgen, aber vergessen, sie zu l√∂schen".  Lassen Sie uns versuchen, diese Situation zu verfolgen. <br><br>  Dazu schreiben wir unsere Testfunktion auf diese Weise um <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"func.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;deque&gt; #include &lt;string&gt; #include &lt;map&gt; static std::deque&lt;std::string&gt; deque; static std::map&lt;int, std::string&gt; map; int func(int arg) { int fst = 1; int snd = 1; for (int i = 0; i &lt; arg; i++) { int res = (fst + snd + 1) % 19845689; fst = snd; snd = res; deque.emplace_back(std::to_string(res) + " integer"); map[i] = "integer " + std::to_string(res); deque.pop_front(); if (res % 200 != 0) { map.erase(i - 1); } } return fst; }</span></span></span></span></code> </pre><br>  Hier f√ºgen wir bei jeder Iteration einige Elemente zur Karte hinzu, und versehentlich (wahr, wahr) vergessen wir, sie manchmal von dort zu entfernen.  Um unsere Augen abzuwenden, foltern wir au√üerdem std :: deque ein bisschen. <br><br>  Wir werden Speicherlecks mit zwei Tools <b>beheben</b> - <b>Valgrind Massif</b> und <b>Google Heapdump</b> . <br><br><h3>  Massif </h3><br>  F√ºhren Sie das Programm mit diesem Befehl aus <br><pre> <code class="bash hljs">valgrind --tool=massif ./test_profiler 1000000</code> </pre> <br>  Und wir sehen so etwas wie <br><br><div class="spoiler">  <b class="spoiler_title">Massif</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">1277949333</span></span> mem_heap_B=<span class="hljs-number"><span class="hljs-number">313518</span></span> mem_heap_extra_B=<span class="hljs-number"><span class="hljs-number">58266</span></span> mem_stacks_B=<span class="hljs-number"><span class="hljs-number">0</span></span> heap_tree=detailed n4: <span class="hljs-number"><span class="hljs-number">313518</span></span> (heap allocation functions) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[], --alloc-fns, etc. n1: <span class="hljs-number"><span class="hljs-number">195696</span></span> <span class="hljs-number"><span class="hljs-number">0x109A69</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (new_allocator.h:<span class="hljs-number"><span class="hljs-number">111</span></span>) n0: <span class="hljs-number"><span class="hljs-number">195696</span></span> <span class="hljs-number"><span class="hljs-number">0x10947A</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x52BA414</span></span>: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.25</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x4010731</span></span>: _dl_init (dl-init.c:<span class="hljs-number"><span class="hljs-number">72</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x40010C8</span></span>: ??? (in /lib/x86_64-linux-gnu/ld<span class="hljs-number"><span class="hljs-number">-2.27</span></span>.so) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span>: ??? n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000D1</span></span>: ??? n0: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000E1</span></span>: ??? n2: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x10A7EC</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_mutate(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (new_allocator.h:<span class="hljs-number"><span class="hljs-number">111</span></span>) n1: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x10AAD9</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_replace(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (basic_string.tcc:<span class="hljs-number"><span class="hljs-number">466</span></span>) n1: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x1099D4</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (basic_string.h:<span class="hljs-number"><span class="hljs-number">1932</span></span>) n0: <span class="hljs-number"><span class="hljs-number">42966</span></span> <span class="hljs-number"><span class="hljs-number">0x10947A</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n0: <span class="hljs-number"><span class="hljs-number">0</span></span> in <span class="hljs-number"><span class="hljs-number">2</span></span> places, all below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%) n0: <span class="hljs-number"><span class="hljs-number">2152</span></span> in <span class="hljs-number"><span class="hljs-number">10</span></span> places, all below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%)</code> </pre> <br></div></div><br>  Es ist zu erkennen, dass das Massiv eine Undichtigkeit in der Funktion feststellen konnte, es ist jedoch noch nicht klar, wo.  Lassen Sie uns das Programm mit dem <b>Flag -fno-inline</b> neu <b>erstellen</b> und die Analyse erneut ausf√ºhren <br><br><div class="spoiler">  <b class="spoiler_title">Massiv</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">3160199549</span></span> mem_heap_B=<span class="hljs-number"><span class="hljs-number">345142</span></span> mem_heap_extra_B=<span class="hljs-number"><span class="hljs-number">65986</span></span> mem_stacks_B=<span class="hljs-number"><span class="hljs-number">0</span></span> heap_tree=detailed n4: <span class="hljs-number"><span class="hljs-number">345142</span></span> (heap allocation functions) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[], --alloc-fns, etc. n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10CDBC</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;* <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Select1st&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; &gt;::_M_create_node&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt; &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;&amp;&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt;&amp;&amp;) [clone .isra<span class="hljs-number"><span class="hljs-number">.81</span></span>] (stl_tree.h:<span class="hljs-number"><span class="hljs-number">653</span></span>) n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10CE0C</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree_iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Select1st&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; &gt;::_M_emplace_hint_unique&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt; &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Rb_tree_const_iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;&gt;&amp;&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;&gt;&amp;&amp;) [clone .constprop<span class="hljs-number"><span class="hljs-number">.87</span></span>] (stl_tree.h:<span class="hljs-number"><span class="hljs-number">2414</span></span>) n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10CF2B</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; &gt; &gt; &gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) (stl_map.h:<span class="hljs-number"><span class="hljs-number">499</span></span>) n1: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x10A7F5</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (func.cpp:<span class="hljs-number"><span class="hljs-number">20</span></span>) n0: <span class="hljs-number"><span class="hljs-number">221616</span></span> <span class="hljs-number"><span class="hljs-number">0x109F8E</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x52BA414</span></span>: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.25</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x4010731</span></span>: _dl_init (dl-init.c:<span class="hljs-number"><span class="hljs-number">72</span></span>) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x40010C8</span></span>: ??? (in /lib/x86_64-linux-gnu/ld<span class="hljs-number"><span class="hljs-number">-2.27</span></span>.so) n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span>: ??? n1: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000D1</span></span>: ??? n0: <span class="hljs-number"><span class="hljs-number">72704</span></span> <span class="hljs-number"><span class="hljs-number">0x1FFF0000E1</span></span>: ??? n2: <span class="hljs-number"><span class="hljs-number">48670</span></span> <span class="hljs-number"><span class="hljs-number">0x10B866</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_mutate(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (basic_string.tcc:<span class="hljs-number"><span class="hljs-number">317</span></span>) n1: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x10BB2C</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::_M_replace(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) (basic_string.tcc:<span class="hljs-number"><span class="hljs-number">466</span></span>) n1: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x10A643</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__cxx11::basic_string&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::char_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;&amp;&amp;) [clone .constprop<span class="hljs-number"><span class="hljs-number">.86</span></span>] (basic_string.h:<span class="hljs-number"><span class="hljs-number">6018</span></span>) n1: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x10A7E5</span></span>: func(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (func.cpp:<span class="hljs-number"><span class="hljs-number">20</span></span>) n0: <span class="hljs-number"><span class="hljs-number">48639</span></span> <span class="hljs-number"><span class="hljs-number">0x109F8E</span></span>: main (main.cpp:<span class="hljs-number"><span class="hljs-number">18</span></span>) n0: <span class="hljs-number"><span class="hljs-number">31</span></span> in <span class="hljs-number"><span class="hljs-number">1</span></span> place, below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%) n0: <span class="hljs-number"><span class="hljs-number">2152</span></span> in <span class="hljs-number"><span class="hljs-number">10</span></span> places, all below massif's threshold (<span class="hljs-number"><span class="hljs-number">1.00</span></span>%)</code> </pre> <br></div></div><br>  Jetzt ist klar, wo sich das Leck beim Hinzuf√ºgen des Kartenelements befindet.  Das Massif kann kurzlebige Objekte erkennen, sodass Manipulationen mit std :: deque in diesem Dump nicht sichtbar sind. <br><br><h3>  Heapdump </h3><br>  Damit Google Heapdump funktioniert, m√ºssen Sie die <b>tcmalloc-</b> Bibliothek verkn√ºpfen oder <b>vorab laden</b> .  Diese Bibliothek ersetzt die Standardfunktionen der Speicherzuweisung malloc, free, ... Sie kann auch Informationen √ºber die Verwendung dieser Funktionen sammeln, die wir bei der Analyse des Programms verwenden werden. <br><br>  Da diese Methode sehr langsam arbeitet (auch im Vergleich zum Massiv), empfehle ich, die Kompilierung von Funktionen beim Kompilieren sofort mit der Option <b>-fno-inline zu</b> deaktivieren.  Also bauen wir unsere Anwendung neu auf und laufen mit dem Team <br><pre> <code class="bash hljs">HEAPPROFILESIGNAL=23 HEAPPROFILE=./heap ./test_profiler 100000000</code> </pre> <br>  Hier wird davon ausgegangen, dass die tcmalloc-Bibliothek mit unserer Anwendung verkn√ºpft ist. <br><br>  Nun warten wir einige Zeit, bis sich ein merkliches Leck gebildet hat, und senden unserem Prozess ein Signal 23 <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -23 &lt;pid&gt;</code> </pre> <br>  Als Ergebnis wird eine Datei mit dem Namen heap.0001.heap angezeigt, die wir mit dem Befehl in das Callgrind-Format konvertieren <br><br><pre> <code class="bash hljs">pprof ./test_profiler <span class="hljs-string"><span class="hljs-string">"./heap.0001.heap"</span></span> --inuse_space --callgrind &gt; callgrind.out.4</code> </pre> <br>  Beachten Sie auch die pprof-Optionen.  Sie k√∂nnen zwischen den Optionen <b>inuse_space</b> , <b>inuse_objects</b> , <b>alloc_space</b> und <b>alloc_objects w√§hlen</b> , die den verwendeten Speicherplatz bzw. die verwendeten Objekte oder den f√ºr die gesamte Programmdauer zugewiesenen Speicherplatz bzw. die zugewiesenen Objekte <b>anzeigen</b> .  Wir sind an der Option inuse_space interessiert, die den aktuell verwendeten Speicherplatz anzeigt. <br><br>  √ñffnen Sie unser Lieblings-kCacheGrind und sehen Sie <br> <a href=""><img src="https://habrastorage.org/webt/of/z2/j8/ofz2j88agvmi4bhfyhigracbn-i.png"></a> <br>  std :: map hat zu viel Speicher verbraucht.  Wahrscheinlich eine Undichtigkeit. <br><br><h2>  Schlussfolgerungen </h2><br>  Das Profiling in C ++ ist eine sehr schwierige Aufgabe.  Hier haben wir es mit Inlining-Funktionen, nicht unterst√ºtzten Anweisungen, falschen Ergebnissen usw. zu tun.  Es ist nicht immer m√∂glich, den Ergebnissen des Profilers zu vertrauen. <br><br>  Zus√§tzlich zu den oben vorgeschlagenen Funktionen gibt es andere Tools f√ºr die Profilerstellung - Perf, Intel VTune und andere.  Sie zeigen aber auch einige dieser M√§ngel.  Vergessen Sie daher nicht die "Grandfather" -Profilierungsmethode, bei der die Ausf√ºhrungszeit von Funktionen gemessen und im Protokoll angezeigt wird. <br><br>  Wenn Sie interessante Techniken zur Profilerstellung f√ºr Ihren Code haben, ver√∂ffentlichen Sie diese bitte in den Kommentaren </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482040/">https://habr.com/ru/post/de482040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482022/index.html">Schau einfach! 20 Filme √ºber Wissenschaft und Wissenschaftler</a></li>
<li><a href="../de482028/index.html">Zwei rote Kn√∂pfe, L√∂tkolben und React: Wie wir uns f√ºr eine IT-Konferenz entschieden haben</a></li>
<li><a href="../de482030/index.html">Vue.js: Lifecycle-Hooks f√ºr Ihre und Komponenten von Drittanbietern</a></li>
<li><a href="../de482034/index.html">Yandex: Es gibt alles ... √ºber Benutzer</a></li>
<li><a href="../de482038/index.html">Wir fassen die Ergebnisse von 2019 bei Haber Career zusammen</a></li>
<li><a href="../de482042/index.html">Arbeiten mit der Newtonsoft.Json-Bibliothek anhand eines realen Beispiels. Teil 2</a></li>
<li><a href="../de482044/index.html">10 Best Practices zum Sichern von Docker-Images. Teil 2</a></li>
<li><a href="../de482050/index.html">Jedi Convolution Network Reduction-Technik - Beschneiden</a></li>
<li><a href="../de482052/index.html">Neujahrs-Datensatz 2019: offenes Tonw√∂rterbuch der russischen Sprache</a></li>
<li><a href="../de482054/index.html">3. Elastic Stack: Sicherheitsprotokollanalyse. Dashboards</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>