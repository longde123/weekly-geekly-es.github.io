<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕕 🧗🏾 🎃 Lazy Upgrade: Wie PostgreSQL 12 die Leistung verbessert 🤸🏾 🤦🏾 👨🏿‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL 12 , die neueste Version der "weltweit besten relationalen Open-Source-Datenbank", erscheint in ein paar Wochen (wenn alles nach Plan läuft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lazy Upgrade: Wie PostgreSQL 12 die Leistung verbessert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/466727/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/7-/ry/vy/7-ryvyiostwo2zvf3mg7rlaiyro.gif"></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL 12</a> , die neueste Version der "weltweit besten relationalen Open-Source-Datenbank", erscheint in ein paar Wochen (wenn alles nach Plan läuft).  Dies entspricht dem üblichen Zeitplan - einmal im Jahr erscheint eine neue Version mit vielen neuen Funktionen, die ehrlich gesagt beeindruckend ist.  Daher wurde ich ein aktives Mitglied der PostgreSQL-Community. </p><br><p>  Meiner Meinung nach enthält PostgreSQL 12 im Gegensatz zu früheren Versionen keine oder zwei revolutionäre Funktionen (wie Partitionierung oder Parallelität von Abfragen).  Ich habe einmal gescherzt, dass das Hauptmerkmal von PostgreSQL 12 mehr Stabilität ist.  Benötigen Sie das nicht, wenn Sie wichtige Geschäftsdaten verwalten? </p><br><p>  PostgreSQL 12 ist jedoch nicht darauf beschränkt: Mit neuen Funktionen und Verbesserungen funktionieren Anwendungen besser <em>und Sie müssen nur ein Upgrade durchführen!</em> </p><br><p>  (Nun, vielleicht sogar die Indizes neu erstellen, aber in dieser Version ist es nicht mehr so ​​beängstigend wie früher.) </p><a name="habracut"></a><br><p> Es wird großartig sein, PostgreSQL zu aktualisieren und sofort signifikante Verbesserungen ohne unnötige Gesten zu genießen.  Vor einigen Jahren habe ich das Upgrade von PostgreSQL 9.4 auf PostgreSQL 10 analysiert und festgestellt, wie sich die Anwendung aufgrund der verbesserten Abfrageparallelität in PostgreSQL 10 beschleunigt hat. Und vor allem war für mich fast nichts erforderlich (setzen Sie einfach den Konfigurationsparameter <code>max_parallel_workers</code> ). </p><br><p>  Stimmen Sie zu, es ist praktisch, wenn Anwendungen direkt nach dem Upgrade besser funktionieren.  Und wir bemühen uns sehr, den Benutzern zu gefallen, da PostgreSQL mehr davon hat. </p><br><p>  Und wie macht Sie ein einfaches Upgrade auf PostgreSQL 12 glücklich?  Ich werde es dir jetzt sagen. </p><br><h3 id="sereznye-uluchsheniya-indeksirovaniya">  Wichtige Indizierungsverbesserungen </h3><br><p>  Ohne Indizierung geht die Datenbank nicht weit.  Und wie kann man sonst schnell Informationen finden?  Das grundlegende PostgreSQL-Indizierungssystem heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Tree</a> .  Diese Art von Index ist für Speichersysteme optimiert. </p><br><p>  Wir verwenden nur die <code>CREATE INDEX ON some_table (some_column)</code> , und PostgreSQL hält den Index hervorragend auf dem neuesten Stand, während wir ständig Werte einfügen, aktualisieren und löschen.  Alles funktioniert von selbst wie von Zauberhand. </p><br><p>  PostgreSQL-Indizes haben jedoch ein Problem: Sie werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgebläht</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beanspruchen</a> zusätzlichen Speicherplatz, und die Leistung beim Abrufen und Aktualisieren von Daten wird verringert.  Mit "Aufblähen" meine ich die ineffektive Aufrechterhaltung der Indexstruktur.  Es kann an Mülltupeln liegen, die VACUUM entfernt (danke für die Informationen an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peter Geoghegan</a> ).  Das Aufblähen des Index macht sich insbesondere bei Workloads bemerkbar, bei denen sich der Index aktiv ändert. </p><br><p>  PostgreSQL 12 verbessert die Leistung von B-Tree-Indizes erheblich, und Experimente mit Tests wie TPC-C haben gezeigt, dass der Speicherplatz jetzt durchschnittlich um 40% weniger genutzt wird.  Jetzt verbringen wir weniger Zeit nicht nur mit der Pflege von B-Tree-Indizes (dh mit Schreibvorgängen), sondern auch mit dem Extrahieren von Daten, da die Indizes viel kleiner geworden sind. </p><br><p>  Anwendungen, die ihre Tabellen aktiv aktualisieren - normalerweise OLTP-Anwendungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echtzeit-Transaktionsverarbeitung</a> ) - sind bei der Verwendung der Festplatte und der Verarbeitung von Anforderungen wesentlich effizienter.  Je mehr Speicherplatz vorhanden ist, desto mehr Speicherplatz verfügt die Datenbank für Wachstum, ohne die Infrastruktur zu aktualisieren. </p><br><p>  Bei einigen Upgrade-Strategien müssen B-Tree-Indizes neu erstellt werden, um diese nutzen zu können (z. B. erstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_upgrade</a> Indizes nicht automatisch neu).  In früheren Versionen von PostgreSQL führte die Neuerstellung großer Indizes in Tabellen zu erheblichen Ausfallzeiten, da zu diesem Zeitpunkt keine Änderungen möglich waren.  PostgreSQL 12 hat jedoch noch einen weiteren coolen Trick: Sie können jetzt Indizes parallel zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehl REINDEX CONCURRENTLY neu erstellen</a> , um Ausfallzeiten vollständig zu vermeiden. </p><br><p>  PostgreSQL 12 bietet weitere Verbesserungen an der Indizierungsinfrastruktur.  Eine andere Sache, die ohne Magie nicht auskommen könnte, ist das Write-Ahead-Protokoll, das auch WAL (Write-Ahead-Protokoll) ist.  Ein Write-Ahead-Protokoll zeichnet jede Transaktion in PostgreSQL im Falle eines Fehlers und einer Replikation auf.  Anwendungen verwenden es zum Sichern und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiederherstellen zu einem bestimmten Zeitpunkt</a> .  Natürlich wird das Write-Ahead-Protokoll auf die Festplatte geschrieben, was die Leistung beeinträchtigen kann. </p><br><p>  PostgreSQL 12 hat den Overhead von WALs reduziert, die von den Indizes GiST, GIN und SP-GiST beim Erstellen des Index erstellt wurden.  Dies bietet mehrere greifbare Vorteile: WAL-Datensätze belegen weniger Speicherplatz und Daten werden schneller reproduziert, z. B. während der Wiederherstellung nach einem Fehler oder zu einem bestimmten Zeitpunkt.  Wenn Sie solche Indizes in Ihren Anwendungen verwenden (z. B. verwenden PostGIS-basierte Geodatenanwendungen häufig den GiST-Index), ist dies eine weitere Funktion, die die Leistung ohne Ihren Aufwand erheblich verbessert. </p><br><h3 id="sekcionirovanie--bolshe-luchshe-bystree">  Partitionierung - größer, besser, schneller </h3><br><p>  PostgreSQL 10 führte die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deklarative Partitionierung ein</a> .  PostgreSQL 11 hat die Verwendung erheblich vereinfacht.  In PostgreSQL 12 können Sie die Skalierung von Abschnitten ändern. </p><br><p>  In PostgreSQL 12 ist die Leistung des Partitionierungssystems viel besser, insbesondere wenn die Tabelle Tausende von Abschnitten enthält.  Wenn eine Abfrage beispielsweise nur wenige Abschnitte in einer Tabelle betrifft, in denen Tausende vorhanden sind, wird sie viel schneller ausgeführt.  Die Leistung wurde nicht nur für diese Art von Abfragen verbessert.  Sie werden auch feststellen, wie sich INSERT-Operationen in Tabellen mit vielen Partitionen beschleunigt haben. </p><br><p>  Das Schreiben von Daten mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">COPY</a> - dies ist übrigens eine großartige Möglichkeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten in</a> großen Mengen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">laden,</a> und hier ein Beispiel für den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Empfang von JSON</a> - in partitionierten Tabellen in PostgreSQL 12 ist ebenfalls effizienter geworden.  Mit COPY war alles so schnell, aber in PostgreSQL 12 fliegt es. </p><br><p>  Dank dieser Vorteile kann PostgreSQL noch größere Datensätze speichern und das Abrufen erleichtern.  Und keine Anstrengung von Ihrer Seite.  Wenn die Anwendung beispielsweise viele Abschnitte enthält, werden Zeitreihendaten aufgezeichnet. Durch ein einfaches Upgrade wird die Leistung erheblich verbessert. </p><br><p>  Und obwohl diese Verbesserung nicht ausschließlich aus der Kategorie „Upgrade und Freude“ stammt, können Sie in PostgreSQL 12 Fremdschlüssel erstellen, die auf partitionierte Tabellen verweisen, sodass die Arbeit mit der Partitionierung ein Vergnügen ist. </p><br><h3 id="zaprosy-with-stali-gorazdo-luchshe">  MIT Abfragen sind viel besser </h3><br><p>  Als der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch auf die integrierten generischen Tabellenausdrücke angewendet wurde</a> (es handelt sich um CTEs, es handelt sich auch um WITH-Abfragen), wollte ich unbedingt einen Artikel darüber schreiben, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">begeistert Anwendungsentwickler mit PostgreSQL waren</a> .  Dies ist eine dieser Funktionen, die die Anwendung beschleunigen.  Es sei denn, Sie verwenden natürlich CTE. </p><br><p>  Ich stelle oft fest, dass SQL-Neulinge gerne CTE verwenden: Wenn Sie sie auf eine bestimmte Weise schreiben, haben Sie direkt das Gefühl, ein zwingendes Programm zu schreiben.  Ich persönlich habe es geliebt, diese Abfragen neu zu schreiben, um auf CTE zu verzichten und die Leistung zu steigern.  Jetzt ist alles anders. </p><br><p>  Mit PostgreSQL 12 können Sie einen bestimmten CTE-Typ ohne Nebenwirkungen ( <code>SELECT</code> ) einbetten, der gegen Ende der Abfrage nur einmal verwendet wird.  Wenn ich Statistiken über Anfragen mit CTEs führen würde, die ich neu geschrieben habe, würden die meisten von ihnen in diese Kategorie fallen.  Dies hilft Entwicklern, verständlichen Code zu schreiben, der jetzt auch schnell funktioniert. </p><br><p>  Darüber hinaus optimiert PostgreSQL 12 die Ausführung von SQL selbst, Sie müssen nichts tun.  Und obwohl ich solche Abfragen jetzt wahrscheinlich nicht optimieren muss, ist es großartig, dass PostgreSQL weiterhin an der Abfrageoptimierung arbeitet. </p><br><h3 id="just-in-time-jit--teper-po-umolchaniyu">  Just-in-Time (JIT) - Jetzt Standard </h3><br><p>  Auf PostgreSQL 12-Systemen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM-</a> Unterstützung ist die JIT-Kompilierung standardmäßig aktiviert.  Erstens erhalten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JIT-</a> Unterstützung für einige interne Operationen und zweitens Abfragen mit Ausdrücken (das einfachste Beispiel ist x + y) in den Auswahllisten (die Sie nach SELECT haben), Aggregaten, Ausdrücken mit WHERE-Klauseln und anderen kann JIT verwenden, um die Leistung zu verbessern. </p><br><p>  Da JIT standardmäßig in PostgreSQL 12 enthalten ist, verbessert sich die Leistung von selbst. Ich empfehle jedoch, die Anwendung in PostgreSQL 11 zu testen, wo JIT gerade erschienen ist, um die Abfrageleistung zu messen und festzustellen, ob Sie etwas optimieren müssen. </p><br><h3 id="a-kak-zhe-ostalnye-novye-fichi-postgresql-12">  Aber was ist mit den anderen neuen Funktionen von PostgreSQL 12? </h3><br><p>  PostgreSQL bietet 12 Tonnen cooler neuer Funktionen - von der Möglichkeit, JSON-Daten mithilfe von Standard-SQL / JSON-Routenausdrücken zu untersuchen, bis hin zur Multi-Faktor-Authentifizierung mit dem Parameter <code>clientcert=verify-full</code> , erstellten Spalten und vielem mehr.  Genug für einen separaten Beitrag. </p><br><p>  Wie PostgreSQL 10 verbessert PostgreSQL 12 die Gesamtleistung direkt nach dem Upgrade.  Natürlich können Sie Ihren eigenen Weg gehen - testen Sie die Anwendung unter ähnlichen Bedingungen im Arbeitssystem, bevor Sie die Verbesserungen aktivieren, wie ich es mit PostgreSQL 10 getan habe. Auch wenn PostgreSQL 12 bereits stabiler ist als erwartet, sollten Sie nicht faul sein, die Anwendungsqualität zu testen. bevor sie in der Produktion freigegeben werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466727/">https://habr.com/ru/post/de466727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466713/index.html">Ist es in 1C möglich, die Technologie externer Komponenten nicht zu beobachten? Oder wie man Kollegen mit 1C gratuliert?</a></li>
<li><a href="../de466719/index.html">Superlight Velocity Profiling: Theorie und Praxis. Teil 1</a></li>
<li><a href="../de466721/index.html">[Ekaterinburg, Ankündigung] java.ural.Meetup @ 3 - Ankündigung der dritten Java Mitap + Video-Berichte von java.ural.Meetup @ 2</a></li>
<li><a href="../de466723/index.html">Apple Text Broadcast - 10. September 2019</a></li>
<li><a href="../de466725/index.html">Dolch 2 ist elementar (Teil 1)</a></li>
<li><a href="../de466729/index.html">Das Buch "Data Mining. Informationen von Facebook, Twitter, LinkedIn, Instagram, GitHub abrufen »</a></li>
<li><a href="../de466731/index.html">Extravaganz. Der September steigt</a></li>
<li><a href="../de466733/index.html">Willkommen zu DINS Java ABEND am 18. September</a></li>
<li><a href="../de466735/index.html">Eine einfache Möglichkeit, einen Sprachalarm im Home Automation-System („Smart Home“) zu erstellen.</a></li>
<li><a href="../de466737/index.html">Warum das soziale Netzwerk von Google+ fehlgeschlagen ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>