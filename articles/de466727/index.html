<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïï üßóüèæ üéÉ Lazy Upgrade: Wie PostgreSQL 12 die Leistung verbessert ü§∏üèæ ü§¶üèæ üë®üèø‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL 12 , die neueste Version der "weltweit besten relationalen Open-Source-Datenbank", erscheint in ein paar Wochen (wenn alles nach Plan l√§uft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lazy Upgrade: Wie PostgreSQL 12 die Leistung verbessert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/466727/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/7-/ry/vy/7-ryvyiostwo2zvf3mg7rlaiyro.gif"></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL 12</a> , die neueste Version der "weltweit besten relationalen Open-Source-Datenbank", erscheint in ein paar Wochen (wenn alles nach Plan l√§uft).  Dies entspricht dem √ºblichen Zeitplan - einmal im Jahr erscheint eine neue Version mit vielen neuen Funktionen, die ehrlich gesagt beeindruckend ist.  Daher wurde ich ein aktives Mitglied der PostgreSQL-Community. </p><br><p>  Meiner Meinung nach enth√§lt PostgreSQL 12 im Gegensatz zu fr√ºheren Versionen keine oder zwei revolution√§re Funktionen (wie Partitionierung oder Parallelit√§t von Abfragen).  Ich habe einmal gescherzt, dass das Hauptmerkmal von PostgreSQL 12 mehr Stabilit√§t ist.  Ben√∂tigen Sie das nicht, wenn Sie wichtige Gesch√§ftsdaten verwalten? </p><br><p>  PostgreSQL 12 ist jedoch nicht darauf beschr√§nkt: Mit neuen Funktionen und Verbesserungen funktionieren Anwendungen besser <em>und Sie m√ºssen nur ein Upgrade durchf√ºhren!</em> </p><br><p>  (Nun, vielleicht sogar die Indizes neu erstellen, aber in dieser Version ist es nicht mehr so ‚Äã‚Äãbe√§ngstigend wie fr√ºher.) </p><a name="habracut"></a><br><p> Es wird gro√üartig sein, PostgreSQL zu aktualisieren und sofort signifikante Verbesserungen ohne unn√∂tige Gesten zu genie√üen.  Vor einigen Jahren habe ich das Upgrade von PostgreSQL 9.4 auf PostgreSQL 10 analysiert und festgestellt, wie sich die Anwendung aufgrund der verbesserten Abfrageparallelit√§t in PostgreSQL 10 beschleunigt hat. Und vor allem war f√ºr mich fast nichts erforderlich (setzen Sie einfach den Konfigurationsparameter <code>max_parallel_workers</code> ). </p><br><p>  Stimmen Sie zu, es ist praktisch, wenn Anwendungen direkt nach dem Upgrade besser funktionieren.  Und wir bem√ºhen uns sehr, den Benutzern zu gefallen, da PostgreSQL mehr davon hat. </p><br><p>  Und wie macht Sie ein einfaches Upgrade auf PostgreSQL 12 gl√ºcklich?  Ich werde es dir jetzt sagen. </p><br><h3 id="sereznye-uluchsheniya-indeksirovaniya">  Wichtige Indizierungsverbesserungen </h3><br><p>  Ohne Indizierung geht die Datenbank nicht weit.  Und wie kann man sonst schnell Informationen finden?  Das grundlegende PostgreSQL-Indizierungssystem hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Tree</a> .  Diese Art von Index ist f√ºr Speichersysteme optimiert. </p><br><p>  Wir verwenden nur die <code>CREATE INDEX ON some_table (some_column)</code> , und PostgreSQL h√§lt den Index hervorragend auf dem neuesten Stand, w√§hrend wir st√§ndig Werte einf√ºgen, aktualisieren und l√∂schen.  Alles funktioniert von selbst wie von Zauberhand. </p><br><p>  PostgreSQL-Indizes haben jedoch ein Problem: Sie werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgebl√§ht</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beanspruchen</a> zus√§tzlichen Speicherplatz, und die Leistung beim Abrufen und Aktualisieren von Daten wird verringert.  Mit "Aufbl√§hen" meine ich die ineffektive Aufrechterhaltung der Indexstruktur.  Es kann an M√ºlltupeln liegen, die VACUUM entfernt (danke f√ºr die Informationen an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peter Geoghegan</a> ).  Das Aufbl√§hen des Index macht sich insbesondere bei Workloads bemerkbar, bei denen sich der Index aktiv √§ndert. </p><br><p>  PostgreSQL 12 verbessert die Leistung von B-Tree-Indizes erheblich, und Experimente mit Tests wie TPC-C haben gezeigt, dass der Speicherplatz jetzt durchschnittlich um 40% weniger genutzt wird.  Jetzt verbringen wir weniger Zeit nicht nur mit der Pflege von B-Tree-Indizes (dh mit Schreibvorg√§ngen), sondern auch mit dem Extrahieren von Daten, da die Indizes viel kleiner geworden sind. </p><br><p>  Anwendungen, die ihre Tabellen aktiv aktualisieren - normalerweise OLTP-Anwendungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echtzeit-Transaktionsverarbeitung</a> ) - sind bei der Verwendung der Festplatte und der Verarbeitung von Anforderungen wesentlich effizienter.  Je mehr Speicherplatz vorhanden ist, desto mehr Speicherplatz verf√ºgt die Datenbank f√ºr Wachstum, ohne die Infrastruktur zu aktualisieren. </p><br><p>  Bei einigen Upgrade-Strategien m√ºssen B-Tree-Indizes neu erstellt werden, um diese nutzen zu k√∂nnen (z. B. erstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_upgrade</a> Indizes nicht automatisch neu).  In fr√ºheren Versionen von PostgreSQL f√ºhrte die Neuerstellung gro√üer Indizes in Tabellen zu erheblichen Ausfallzeiten, da zu diesem Zeitpunkt keine √Ñnderungen m√∂glich waren.  PostgreSQL 12 hat jedoch noch einen weiteren coolen Trick: Sie k√∂nnen jetzt Indizes parallel zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehl REINDEX CONCURRENTLY neu erstellen</a> , um Ausfallzeiten vollst√§ndig zu vermeiden. </p><br><p>  PostgreSQL 12 bietet weitere Verbesserungen an der Indizierungsinfrastruktur.  Eine andere Sache, die ohne Magie nicht auskommen k√∂nnte, ist das Write-Ahead-Protokoll, das auch WAL (Write-Ahead-Protokoll) ist.  Ein Write-Ahead-Protokoll zeichnet jede Transaktion in PostgreSQL im Falle eines Fehlers und einer Replikation auf.  Anwendungen verwenden es zum Sichern und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiederherstellen zu einem bestimmten Zeitpunkt</a> .  Nat√ºrlich wird das Write-Ahead-Protokoll auf die Festplatte geschrieben, was die Leistung beeintr√§chtigen kann. </p><br><p>  PostgreSQL 12 hat den Overhead von WALs reduziert, die von den Indizes GiST, GIN und SP-GiST beim Erstellen des Index erstellt wurden.  Dies bietet mehrere greifbare Vorteile: WAL-Datens√§tze belegen weniger Speicherplatz und Daten werden schneller reproduziert, z. B. w√§hrend der Wiederherstellung nach einem Fehler oder zu einem bestimmten Zeitpunkt.  Wenn Sie solche Indizes in Ihren Anwendungen verwenden (z. B. verwenden PostGIS-basierte Geodatenanwendungen h√§ufig den GiST-Index), ist dies eine weitere Funktion, die die Leistung ohne Ihren Aufwand erheblich verbessert. </p><br><h3 id="sekcionirovanie--bolshe-luchshe-bystree">  Partitionierung - gr√∂√üer, besser, schneller </h3><br><p>  PostgreSQL 10 f√ºhrte die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deklarative Partitionierung ein</a> .  PostgreSQL 11 hat die Verwendung erheblich vereinfacht.  In PostgreSQL 12 k√∂nnen Sie die Skalierung von Abschnitten √§ndern. </p><br><p>  In PostgreSQL 12 ist die Leistung des Partitionierungssystems viel besser, insbesondere wenn die Tabelle Tausende von Abschnitten enth√§lt.  Wenn eine Abfrage beispielsweise nur wenige Abschnitte in einer Tabelle betrifft, in denen Tausende vorhanden sind, wird sie viel schneller ausgef√ºhrt.  Die Leistung wurde nicht nur f√ºr diese Art von Abfragen verbessert.  Sie werden auch feststellen, wie sich INSERT-Operationen in Tabellen mit vielen Partitionen beschleunigt haben. </p><br><p>  Das Schreiben von Daten mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">COPY</a> - dies ist √ºbrigens eine gro√üartige M√∂glichkeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten in</a> gro√üen Mengen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">laden,</a> und hier ein Beispiel f√ºr den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Empfang von JSON</a> - in partitionierten Tabellen in PostgreSQL 12 ist ebenfalls effizienter geworden.  Mit COPY war alles so schnell, aber in PostgreSQL 12 fliegt es. </p><br><p>  Dank dieser Vorteile kann PostgreSQL noch gr√∂√üere Datens√§tze speichern und das Abrufen erleichtern.  Und keine Anstrengung von Ihrer Seite.  Wenn die Anwendung beispielsweise viele Abschnitte enth√§lt, werden Zeitreihendaten aufgezeichnet. Durch ein einfaches Upgrade wird die Leistung erheblich verbessert. </p><br><p>  Und obwohl diese Verbesserung nicht ausschlie√ülich aus der Kategorie ‚ÄûUpgrade und Freude‚Äú stammt, k√∂nnen Sie in PostgreSQL 12 Fremdschl√ºssel erstellen, die auf partitionierte Tabellen verweisen, sodass die Arbeit mit der Partitionierung ein Vergn√ºgen ist. </p><br><h3 id="zaprosy-with-stali-gorazdo-luchshe">  MIT Abfragen sind viel besser </h3><br><p>  Als der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch auf die integrierten generischen Tabellenausdr√ºcke angewendet wurde</a> (es handelt sich um CTEs, es handelt sich auch um WITH-Abfragen), wollte ich unbedingt einen Artikel dar√ºber schreiben, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">begeistert Anwendungsentwickler mit PostgreSQL waren</a> .  Dies ist eine dieser Funktionen, die die Anwendung beschleunigen.  Es sei denn, Sie verwenden nat√ºrlich CTE. </p><br><p>  Ich stelle oft fest, dass SQL-Neulinge gerne CTE verwenden: Wenn Sie sie auf eine bestimmte Weise schreiben, haben Sie direkt das Gef√ºhl, ein zwingendes Programm zu schreiben.  Ich pers√∂nlich habe es geliebt, diese Abfragen neu zu schreiben, um auf CTE zu verzichten und die Leistung zu steigern.  Jetzt ist alles anders. </p><br><p>  Mit PostgreSQL 12 k√∂nnen Sie einen bestimmten CTE-Typ ohne Nebenwirkungen ( <code>SELECT</code> ) einbetten, der gegen Ende der Abfrage nur einmal verwendet wird.  Wenn ich Statistiken √ºber Anfragen mit CTEs f√ºhren w√ºrde, die ich neu geschrieben habe, w√ºrden die meisten von ihnen in diese Kategorie fallen.  Dies hilft Entwicklern, verst√§ndlichen Code zu schreiben, der jetzt auch schnell funktioniert. </p><br><p>  Dar√ºber hinaus optimiert PostgreSQL 12 die Ausf√ºhrung von SQL selbst, Sie m√ºssen nichts tun.  Und obwohl ich solche Abfragen jetzt wahrscheinlich nicht optimieren muss, ist es gro√üartig, dass PostgreSQL weiterhin an der Abfrageoptimierung arbeitet. </p><br><h3 id="just-in-time-jit--teper-po-umolchaniyu">  Just-in-Time (JIT) - Jetzt Standard </h3><br><p>  Auf PostgreSQL 12-Systemen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM-</a> Unterst√ºtzung ist die JIT-Kompilierung standardm√§√üig aktiviert.  Erstens erhalten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JIT-</a> Unterst√ºtzung f√ºr einige interne Operationen und zweitens Abfragen mit Ausdr√ºcken (das einfachste Beispiel ist x + y) in den Auswahllisten (die Sie nach SELECT haben), Aggregaten, Ausdr√ºcken mit WHERE-Klauseln und anderen kann JIT verwenden, um die Leistung zu verbessern. </p><br><p>  Da JIT standardm√§√üig in PostgreSQL 12 enthalten ist, verbessert sich die Leistung von selbst. Ich empfehle jedoch, die Anwendung in PostgreSQL 11 zu testen, wo JIT gerade erschienen ist, um die Abfrageleistung zu messen und festzustellen, ob Sie etwas optimieren m√ºssen. </p><br><h3 id="a-kak-zhe-ostalnye-novye-fichi-postgresql-12">  Aber was ist mit den anderen neuen Funktionen von PostgreSQL 12? </h3><br><p>  PostgreSQL bietet 12 Tonnen cooler neuer Funktionen - von der M√∂glichkeit, JSON-Daten mithilfe von Standard-SQL / JSON-Routenausdr√ºcken zu untersuchen, bis hin zur Multi-Faktor-Authentifizierung mit dem Parameter <code>clientcert=verify-full</code> , erstellten Spalten und vielem mehr.  Genug f√ºr einen separaten Beitrag. </p><br><p>  Wie PostgreSQL 10 verbessert PostgreSQL 12 die Gesamtleistung direkt nach dem Upgrade.  Nat√ºrlich k√∂nnen Sie Ihren eigenen Weg gehen - testen Sie die Anwendung unter √§hnlichen Bedingungen im Arbeitssystem, bevor Sie die Verbesserungen aktivieren, wie ich es mit PostgreSQL 10 getan habe. Auch wenn PostgreSQL 12 bereits stabiler ist als erwartet, sollten Sie nicht faul sein, die Anwendungsqualit√§t zu testen. bevor sie in der Produktion freigegeben werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466727/">https://habr.com/ru/post/de466727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466713/index.html">Ist es in 1C m√∂glich, die Technologie externer Komponenten nicht zu beobachten? Oder wie man Kollegen mit 1C gratuliert?</a></li>
<li><a href="../de466719/index.html">Superlight Velocity Profiling: Theorie und Praxis. Teil 1</a></li>
<li><a href="../de466721/index.html">[Ekaterinburg, Ank√ºndigung] java.ural.Meetup @ 3 - Ank√ºndigung der dritten Java Mitap + Video-Berichte von java.ural.Meetup @ 2</a></li>
<li><a href="../de466723/index.html">Apple Text Broadcast - 10. September 2019</a></li>
<li><a href="../de466725/index.html">Dolch 2 ist elementar (Teil 1)</a></li>
<li><a href="../de466729/index.html">Das Buch "Data Mining. Informationen von Facebook, Twitter, LinkedIn, Instagram, GitHub abrufen ¬ª</a></li>
<li><a href="../de466731/index.html">Extravaganz. Der September steigt</a></li>
<li><a href="../de466733/index.html">Willkommen zu DINS Java ABEND am 18. September</a></li>
<li><a href="../de466735/index.html">Eine einfache M√∂glichkeit, einen Sprachalarm im Home Automation-System (‚ÄûSmart Home‚Äú) zu erstellen.</a></li>
<li><a href="../de466737/index.html">Warum das soziale Netzwerk von Google+ fehlgeschlagen ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>