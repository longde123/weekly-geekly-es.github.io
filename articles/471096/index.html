<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèæ üë©üèΩ‚Äçüé® üë¶üèø Prueba p√∫blica: soluci√≥n para privacidad y escalabilidad en Ethereum üî≠ üèÇüèΩ üíé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain es una tecnolog√≠a innovadora que promete mejorar muchas √°reas de la vida humana. Transfiere procesos y productos reales al espacio digital,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba p√∫blica: soluci√≥n para privacidad y escalabilidad en Ethereum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471096/">  <b>Blockchain</b> es una tecnolog√≠a innovadora que promete mejorar muchas √°reas de la vida humana.  Transfiere procesos y productos reales al espacio digital, garantiza la velocidad y la fiabilidad de las transacciones financieras, reduce su costo y tambi√©n le permite crear aplicaciones DAPP modernas utilizando contratos inteligentes en redes descentralizadas. <br><br>  Dadas las muchas ventajas y los diversos usos de blockchain, puede parecer extra√±o que esta prometedora tecnolog√≠a a√∫n no haya penetrado en todos los sectores.  El problema es que las cadenas de bloques modernas descentralizadas carecen de escalabilidad.  Ethereum procesa alrededor de 20 transacciones por segundo, lo que no es suficiente para satisfacer las necesidades del negocio din√°mico actual.  Al mismo tiempo, las empresas que usan la tecnolog√≠a blockchain no se atreven a abandonar Ethereum debido a su alto grado de protecci√≥n contra pirater√≠a inform√°tica y fallas en la red. <br><br>  Para garantizar la descentralizaci√≥n, la seguridad y la escalabilidad en la cadena de bloques, resolviendo as√≠ el Trilema de la escalabilidad, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">equipo de</a> desarrollo de Opporty cre√≥ Plasma Cash, una cadena secundaria que consiste en un contrato inteligente y una red privada basada en Node.js, que transfiere peri√≥dicamente su estado a la cadena ra√≠z ( Ethereum). <br><br><img src="https://habrastorage.org/webt/tc/kv/lg/tckvlgw0bbppuvkdlaght7jdwfa.jpeg"><br><a name="habracut"></a><br><h2>  Procesos clave en Plasma Cash </h2><br>  <b>1. El</b> usuario llama a la funci√≥n del contrato inteligente 'dep√≥sito', transfiriendo la cantidad en ETH, que quiere poner en el token de Plasma Cash.  La funci√≥n de contrato inteligente crea un token y genera un evento al respecto. <br><br>  <b>2.</b> Los nodos de Plasma Cash suscritos a los eventos del contrato inteligente reciben un evento sobre la creaci√≥n de un dep√≥sito y agregan una transacci√≥n sobre la creaci√≥n de un token al grupo. <br><br>  <b>3.</b> Peri√≥dicamente, los nodos especiales de Plasma Cash toman todas las transacciones del grupo (hasta 1 mill√≥n) y forman un bloque a partir de ellas, calculan el √°rbol Merkle y, en consecuencia, el hash.  Este bloque se env√≠a a otros nodos para su verificaci√≥n.  Los nodos verifican si el hash Merkle es v√°lido, si las transacciones son v√°lidas (por ejemplo, si el remitente del token es su propietario).  Despu√©s de verificar el bloque, el nodo llama a la funci√≥n `submitBlock` del contrato inteligente, que almacena el n√∫mero y el hash Merkle del bloque en la cadena de rastreo.  Un contrato inteligente genera un evento sobre la adici√≥n exitosa de un bloque.  Las transacciones se eliminan del grupo. <br><br>  <b>4. Los</b> nodos que recibieron el evento sobre el env√≠o del bloque comienzan a aplicar las transacciones que se agregaron al bloque. <br><br>  <b>5.</b> En alg√∫n momento, el propietario (o no propietario) del token quiere retirarlo de Plasma Cash.  Para hacer esto, llama a la funci√≥n `startExit`, pasando informaci√≥n sobre las √∫ltimas 2 transacciones en el token, que confirman que √©l es el propietario del token.  El contrato inteligente, utilizando el hash Merkle, verifica las transacciones en bloques y env√≠a un token a la salida, lo que suceder√° en dos semanas. <br><br>  <b>6.</b> Si la operaci√≥n de extracci√≥n del token se produjo con violaciones (el token se gast√≥ despu√©s del inicio del procedimiento de retiro o el token ya era un extra√±o antes del retiro), el propietario del token puede refutar el retiro dentro de dos semanas. <br><br><img src="https://habrastorage.org/webt/xm/hy/ks/xmhyksifhph5pfmw5ibsnoh_keq.jpeg"><br><br><h2>  La privacidad se logra de dos maneras. </h2><br>  <b>1. La</b> cadena ra√≠z no sabe nada sobre las transacciones que se forman y reenv√≠an dentro de la cadena secundaria.  Queda informaci√≥n sobre qui√©n comenz√≥ y retir√≥ ETH a / desde Plasma Cash. <br><br>  <b>2.</b> La cadena secundaria le permite organizar transacciones an√≥nimas utilizando zk-SNARKs. <br><br><h2>  Pila tecnol√≥gica </h2><br><ul><li>  NodeJS </li><li>  Redis </li><li>  Ethereum </li><li>  Soild </li></ul><br><h2>  Prueba </h2><br>  Al desarrollar Plasma Cash, probamos la velocidad del sistema y obtuvimos los siguientes resultados: <br><br><ul><li>  se agregan hasta 35,000 transacciones por segundo al grupo; </li><li>  Se pueden almacenar hasta 1,000,000 de transacciones en el bloque. </li></ul><br>  Se realizaron pruebas en los siguientes 3 servidores: <br><br>  <i>1. Intel Core i7-6700 Quad-Core Skylake incl.</i>  <i>NVMe SSD: 512 GB, 64 GB de RAM DDR4</i> <br>  Se generaron 3 nodos de Plasma Cash validados. <br><br>  <i>2. AMD Ryzen 7 1700X Octa-Core ‚ÄúSummit Ridge‚Äù (Zen), SSD SATA - 500 GB, 64 GB de RAM DDR4</i> <br>  Se levant√≥ el nodo ETH Ropsten testnet. <br>  Se generaron 3 nodos de Plasma Cash validados. <br><br>  <i>3. Intel Core i9-9900K Octa-Core incl.</i>  <i>NVMe SSD: 1 TB, 64 GB de RAM DDR4</i> <br>  1 Se envi√≥ el nodo de Plasma Cash. <br>  Se generaron 3 nodos de Plasma Cash validados. <br>  Se lanz√≥ una prueba para agregar transacciones a la red de Plasma Cash. <br><br>  <b>Total:</b> 10 nodos de Plasma Cash en una red privada. <br><br><h3>  Prueba 1 </h3><br>  Hay un l√≠mite de 1 mill√≥n de transacciones por bloque.  Por lo tanto, 1 mill√≥n de transacciones se dividen en 2 bloques (ya que el sistema logra tomar parte de las transacciones y las env√≠a mientras se env√≠an). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VhJAtRlmXVE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Estado inicial: √∫ltimo bloque # 7;  1 mill√≥n de transacciones y tokens se almacenan en la base de datos. <br><br>  00:00 - inicia el script de generaci√≥n de transacciones <br>  01:37 - Se crearon 1 mill√≥n de transacciones y comenz√≥ el env√≠o al nodo <br>  01:46 - el nodo de env√≠o tom√≥ 240k transacciones del grupo y forma el bloque # 8.  Tambi√©n vemos que se agregan 320k transacciones al grupo en 10 segundos <br>  01:58 - el bloque # 8 se firma y se env√≠a para su validaci√≥n <br>  02:03 - el bloque # 8 se valida y la funci√≥n `submitBlock` del contrato inteligente con el hash Merkle y el n√∫mero de bloque se llama <br>  02:10 - el script de demostraci√≥n termin√≥ de funcionar, lo que envi√≥ 1 mill√≥n de transacciones en 32 segundos <br>  02:33 - los nodos comenzaron a recibir informaci√≥n que el bloque # 8 fue agregado a la cadena ra√≠z, y comenz√≥ a realizar 240k transacciones <br>  02:40 - Se borraron 240k transacciones del grupo, que ya est√°n en el bloque # 8 <br>  02:56 - el nodo de env√≠o tom√≥ las 760k transacciones restantes del grupo y comenz√≥ a calcular el hash Merkle y firmar el bloque # 9 <br>  03:20 - todos los nodos contienen 1 mln de 240k transacciones y tokens <br>  03:35 - el bloque # 9 se firma y se env√≠a para su validaci√≥n a otros nodos <br>  03:41 - se ha producido un error de red <br>  04:40 - por tiempo de espera, la espera para la validaci√≥n del bloque # 9 se ha detenido <br>  04:54 - el nodo de env√≠o tom√≥ las 760k transacciones restantes del grupo y comenz√≥ a calcular el hash Merkle y firmar el bloque # 9 <br>  05:32 - el bloque # 9 se firma y se env√≠a para su validaci√≥n a otros nodos <br>  05:53 - el bloque # 9 se valida y se env√≠a a la cadena ra√≠z <br>  06:17 - los nodos comenzaron a recibir informaci√≥n que el bloque # 9 se agreg√≥ a la cadena ra√≠z y comenz√≥ a realizar transacciones de 760k <br>  06:47 - el grupo se borr√≥ de las transacciones que est√°n en el bloque # 9 <br>  09:06 - todos los nodos contienen 2 millones de transacciones y tokens <br><br><h3>  Prueba 2 </h3><br>  Hay un l√≠mite de 350k por bloque.  Como resultado, tenemos 3 bloques. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4BNpSYkwRvE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Estado inicial: √∫ltimo bloque # 9;  2 millones de transacciones y tokens almacenados en la base de datos <br><br>  00:00 - el script de generaci√≥n de transacciones ya se est√° ejecutando <br>  00:44 - Se crearon 1 mill√≥n de transacciones y comenz√≥ el env√≠o al nodo <br>  00:56 - el nodo de env√≠o tom√≥ 320k transacciones del grupo y forma el bloque # 10.  Tambi√©n vemos que se agregan 320k transacciones al grupo en 10 segundos <br>  01:12 - el bloque # 10 se firma y se env√≠a a otros nodos para su validaci√≥n <br>  01:18 - el script de demostraci√≥n termin√≥ de funcionar, lo que envi√≥ 1 mill√≥n de transacciones en 34 segundos <br>  01:20 - el bloque # 10 se valida y se env√≠a a la cadena ra√≠z <br>  01:51 - todos los nodos recibieron informaci√≥n de la cadena ra√≠z que se ha agregado el bloque # 10, y est√°n comenzando a aplicar 320k transacciones <br>  02:01 - el grupo se borr√≥ para 320k transacciones que se agregaron al bloque # 10 <br>  02:15 - el nodo de env√≠o tom√≥ 350k transacciones del grupo y forma el bloque # 11 <br>  02:34 - el bloque # 11 se firma y se env√≠a a otros nodos para su validaci√≥n <br>  02:51 - el bloque # 11 se valida y se env√≠a a la cadena ra√≠z <br>  02:55 - el √∫ltimo nodo ejecut√≥ transacciones desde el bloque # 10 <br>  10:59 - durante mucho tiempo, se ejecut√≥ una transacci√≥n en la cadena ra√≠z con el env√≠o del bloque # 9, pero se complet√≥ y todos los nodos recibieron informaci√≥n sobre esto y comenzaron a ejecutar 350k transacciones <br>  11:05 - el grupo se borr√≥ para 320k transacciones que se agregaron al bloque # 11 <br>  12:10: todos los nodos contienen 1 mill√≥n de transacciones y tokens de 670k <br>  12:17 - el nodo de env√≠o tom√≥ 330k transacciones del grupo y forma el bloque # 12 <br>  12:32 - el bloque # 12 se firma y se env√≠a a otros nodos para su validaci√≥n <br>  12:39 - el bloque # 12 se valida y se env√≠a a la cadena ra√≠z <br>  13:44 - todos los nodos recibieron informaci√≥n de la cadena ra√≠z que el bloque # 12 ha sido agregado y est√°n comenzando a aplicar transacciones de 330k <br>  14:50 - todos los nodos contienen 2 millones de transacciones y tokens <br><br><h3>  Prueba 3 </h3><br>  En el primer y segundo servidor, un nodo de validaci√≥n fue reemplazado por un nodo de env√≠o. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w5QHab3heIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Estado inicial: √∫ltimo bloque # 84;  0 transacciones y tokens se almacenan en la base de datos <br><br>  00:00 - Se lanzan 3 scripts que generan y env√≠an 1 mill√≥n de transacciones <br>  01:38 - Se crearon 1 mill√≥n de transacciones y comenz√≥ el env√≠o para enviar el nodo # 3 <br>  01:50 - el nodo de env√≠o # 3 tom√≥ 330k transacciones del grupo y forma el bloque # 85 (f21).  Tambi√©n vemos que se agregan 350k transacciones al grupo en 10 segundos <br>  01:53 - Se crearon 1 mill√≥n de transacciones y comenz√≥ el env√≠o para enviar el nodo # 1 <br>  01:50 - el nodo de env√≠o # 3 tom√≥ 330k transacciones del grupo y forma el bloque # 85 (f21).  Tambi√©n vemos que se agregan 350k transacciones al grupo en 10 segundos <br>  02:01 - el nodo de env√≠o # 1 tom√≥ 250k transacciones del grupo y forma el bloque # 85 (65e) <br>  02:06 - el bloque # 85 (f21) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  02:08 - el script de demostraci√≥n del servidor # 3 ha terminado de funcionar, lo que envi√≥ 1 mln de transacciones en 30 segundos <br>  02:14 - el bloque # 85 (f21) se valida y se env√≠a a la cadena ra√≠z <br>  02:19 - el bloque # 85 (65e) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  02:22 - Se crearon 1 mill√≥n de transacciones y comenz√≥ el env√≠o para enviar el nodo # 2 <br>  02:27 - el bloque # 85 (65e) se valida y se env√≠a a la cadena ra√≠z <br>  02:29 - el nodo de env√≠o # 2 tom√≥ del grupo 111855 transacciones y forma el bloque # 85 (256). <br>  02:36 - el bloque # 85 (256) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  02:36 - el script de demostraci√≥n del servidor # 1 termin√≥ de funcionar, lo que envi√≥ 1 mln de transacciones en 42.5 segundos <br>  02:38 - el bloque # 85 (256) se valida y se env√≠a a la cadena ra√≠z <br>  03:08 - el script del servidor # 2, que envi√≥ 1 mill√≥n de transacciones en 47 segundos, termin√≥ de funcionar <br>  03:38 - todos los nodos recibieron informaci√≥n de la cadena ra√≠z de que los bloques # 85 (f21), # 86 (65e), # 87 (256) se agregaron y comenzaron a aplicar transacciones de 330k, 250k, 111855 <br>  03:49 - el grupo se borr√≥ en 330k, 250k, 111855 transacciones que se agregaron a los bloques # 85 (f21), # 86 (65e), # 87 (256) <br>  03:59 - el nodo de env√≠o # 1 tom√≥ del grupo 888145 transacciones y formularios bloque # 88 (214), el nodo de env√≠o # 2 tom√≥ del grupo 750k transacciones y el bloque de formularios # 88 (50a), el nodo de env√≠o # 3 tom√≥ del grupo 670k transacciones y Bloque de formas # 88 (d3b) <br>  04:44 - el bloque # 88 (d3b) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  04:58 - el bloque # 88 (214) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  05:11 - el bloque # 88 (50a) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  05:11 - el bloque # 85 (d3b) se valida y se env√≠a a la cadena ra√≠z <br>  05:36 - el bloque # 85 (214) se valida y se env√≠a a la cadena ra√≠z <br>  05:43 - todos los nodos recibieron informaci√≥n de la cadena ra√≠z que bloquea los bloques # 88 (d3b), # 89 (214) y se agregaron 670k, 750k transacciones <br>  06:50 - debido a una desconexi√≥n, el bloque # 85 (50a) no fue validado <br>  06:55 - el nodo de env√≠o # 2 tom√≥ 888145 transacciones del grupo y forma el bloque # 90 (50a) <br>  08:14 - el bloque # 90 (50a) se firma y se env√≠a a otros nodos para su validaci√≥n <br>  09:04 - el bloque # 90 (50a) se valida y se env√≠a a la cadena ra√≠z <br>  11:23 - todos los nodos recibieron informaci√≥n de la cadena ra√≠z que se agreg√≥ el bloque # 90 (50a), y comenzaron a aplicarse 888145 transacciones.  Al mismo tiempo, el servidor n. ¬∞ 3 ha aplicado durante mucho tiempo las transacciones de los bloques n. ¬∞ 88 (d3b), n. ¬∞ 89 (214) <br>  12:11 - todas las piscinas est√°n vac√≠as <br>  13:41 - todos los nodos del servidor # 3 contienen 3 millones de transacciones y tokens <br>  14:35 - todos los nodos del servidor # 1 contienen 3 millones de transacciones y tokens <br>  19:24 - todos los nodos del servidor # 2 contienen 3 millones de transacciones y tokens <br><br><h2>  Los obst√°culos </h2><br>  Durante el desarrollo de Plasma Cash, encontramos los siguientes problemas, que gradualmente resolvimos y estamos resolviendo: <br><br>  <b>1.</b> El conflicto de interacci√≥n de varias funciones del sistema.  Por ejemplo, la funci√≥n de agregar transacciones al grupo bloque√≥ el env√≠o y la validaci√≥n de bloques, y viceversa, lo que condujo a una disminuci√≥n de la velocidad. <br><br>  <b>2.</b> No estaba claro de inmediato c√≥mo enviar una gran cantidad de transacciones y, al mismo tiempo, minimizar el costo de la transferencia de datos. <br><br>  <b>3.</b> No estaba claro c√≥mo y d√≥nde almacenar los datos para lograr altos resultados. <br><br>  <b>4.</b> No estaba claro c√≥mo organizar una red entre nodos, ya que el tama√±o del bloque con 1 mill√≥n de transacciones toma aproximadamente 100 MB. <br><br>  <b>5.</b> Trabajar en modo de subproceso √∫nico interrumpe la conexi√≥n entre nodos cuando se realizan c√°lculos largos (por ejemplo, construir un √°rbol Merkle y calcular su hash). <br><br><h2>  ¬øC√≥mo lidiamos con todo esto? </h2><br>  La primera versi√≥n del nodo Plasma Cash era una especie de combinaci√≥n que pod√≠a hacer todo al mismo tiempo: aceptar transacciones, enviar y validar bloques, proporcionar una API para acceder a los datos.  Dado que NodeJS fue inicialmente de un solo subproceso, la pesada funci√≥n de c√°lculo del √°rbol de Merkle bloque√≥ la funci√≥n de agregar transacci√≥n.  Vimos dos opciones para resolver este problema: <br><br>  <b>1.</b> Ejecute varios procesos NodeJS, cada uno de los cuales realiza ciertas funciones. <br><br>  <b>2.</b> Use worker_threads y ponga la ejecuci√≥n del c√≥digo en hilos. <br><br>  Como resultado, utilizamos ambas opciones al mismo tiempo: dividimos l√≥gicamente un nodo en 3 partes, que pueden funcionar por separado, pero al mismo tiempo sincr√≥nicamente <br><br>  <b>1.</b> Env√≠e un nodo que acepte transacciones al grupo y cree bloques. <br><br>  <b>2.</b> Validar el nodo que verifica la validez de los nodos. <br><br>  <b>3.</b> API de nodo: proporciona una API para acceder a los datos. <br><br>  Al mismo tiempo, puede conectarse a cada nodo a trav√©s de un socket Unix usando CLI. <br><br>  Operaciones pesadas, como el c√°lculo del √°rbol Merkle, lo colocamos en una secuencia separada. <br><br>  Por lo tanto, logramos el funcionamiento normal de todas las funciones de Plasma Cash simult√°neamente y sin fallas. <br><br>  Tan pronto como el sistema funcion√≥ funcionalmente, comenzamos a probar la velocidad y, desafortunadamente, obtuvimos resultados insatisfactorios: 5,000 transacciones por segundo y hasta 50,000 transacciones en un bloque.  Ten√≠a que averiguar qu√© se implement√≥ incorrectamente. <br><br>  Para empezar, comenzamos a probar el mecanismo de comunicaci√≥n con Plasma Cash para descubrir la capacidad m√°xima del sistema.  Anteriormente escribimos que el nodo Plasma Cash proporciona una interfaz de socket unix.  Originalmente era textual.  Los objetos json se enviaron usando `JSON.parse ()` y `JSON.stringify ()`. <br><br><pre><code class="plaintext hljs">```json { "action": "sendTransaction", "payload":{ "prevHash": "0x8a88cc4217745fd0b4eb161f6923235da10593be66b841d47da86b9cd95d93e0", "prevBlock": 41, "tokenId": "57570139642005649136210751546585740989890521125187435281313126554130572876445", "newOwner": "0x200eabe5b26e547446ae5821622892291632d4f4", "type": "pay", "data": "", "signature": "0xd1107d0c6df15e01e168e631a386363c72206cb75b233f8f3cf883134854967e1cd9b3306cc5c0ce58f0a7397ae9b2487501b56695fe3a3c90ec0f61c7ea4a721c" } } ```</code> </pre> <br>  Medimos la velocidad de transferencia de dichos objetos y recibimos ~ 130k por segundo.  Intentaron reemplazar las funciones est√°ndar con json, pero el rendimiento no mejor√≥.  Debe haber un motor V8 bien optimizado para estas operaciones. <br><br>  El trabajo con transacciones, tokens, bloques se realiz√≥ a trav√©s de clases.  Al crear tales clases, el rendimiento se redujo 2 veces, lo que indica: OOP no es adecuado para nosotros.  Tuve que reescribir todo con un enfoque puramente funcional. <br><br><h2>  Escribir en la base de datos </h2><br>  Inicialmente, Redis fue elegida para el almacenamiento de datos como una de las soluciones m√°s productivas que satisface nuestros requisitos: almacenamiento de valor clave, trabajo con tablas hash y muchas m√°s.  Lanzamos Redis-benchmark y obtuvimos ~ 80k operaciones por segundo en 1 modo de canalizaci√≥n. <br><br>  Para un alto rendimiento, ajustamos Redis m√°s finamente: <br><br><ul><li>  Estableci√≥ una conexi√≥n de socket unix. </li><li>  Deshabilite el guardado de estado en el disco (para mayor confiabilidad, puede configurar la r√©plica y guardarla en el disco en un Redis separado). </li></ul><br>  En Redis, un grupo es una tabla hash, ya que necesitamos la capacidad de recibir todas las transacciones en una solicitud y eliminar las transacciones una por una.  Intentamos usar una lista regular, pero funciona m√°s lentamente al descargar la lista completa. <br><br>  Usando la biblioteca est√°ndar NodeJS, las bibliotecas Redis lograron un rendimiento de 18k transacciones por segundo.  La velocidad cay√≥ 9 veces. <br><br>  Como el punto de referencia nos mostr√≥ las posibilidades claramente 5 veces m√°s, comenzaron a optimizar.  Cambiamos la biblioteca a ioredis y obtuvimos un rendimiento de 25k por segundo.  Agregamos transacciones una por una usando el comando `hset`.  Por lo tanto, generamos muchas solicitudes en Redis.  Hubo una idea de fusionar transacciones en paquetes y enviarlas con un comando hmset.  El resultado es 32k por segundo. <br><br>  Por varias razones, que se describir√°n a continuaci√≥n, trabajamos con datos usando `Buffer` y, como se vio despu√©s, si lo traduce a texto (` buffer.toString ('hex') `) antes de escribir, puede obtener un rendimiento adicional.  Por lo tanto, la velocidad se increment√≥ a 35k por segundo.  Por el momento, decidimos suspender a√∫n m√°s la optimizaci√≥n. <br><br>  Tuvimos que cambiar al protocolo binario porque: <br><br>  <b>1.</b> El sistema a menudo calcula hashes, firmas, etc., y para esto necesita datos en `Buffer. <br><br>  <b>2.</b> Al transferir entre servicios, los datos binarios pesan menos que el texto.  Por ejemplo, al enviar un bloque con 1 mill√≥n de transacciones, los datos en el texto pueden ocupar m√°s de 300 megabytes. <br><br>  <b>3.</b> La conversi√≥n continua de datos afecta el rendimiento. <br><br>  Por lo tanto, tomamos como base nuestro propio protocolo binario para almacenar y transmitir datos, desarrollado sobre la base de la maravillosa biblioteca de datos binarios. <br><br>  Como resultado, tenemos las siguientes estructuras de datos: <br><br><h3>  - Transacci√≥n </h3><br><pre> <code class="plaintext hljs"> ```json { prevHash: BD.types.buffer(20), prevBlock: BD.types.uint24le, tokenId: BD.types.string(null), type: BD.types.uint8, newOwner: BD.types.buffer(20), dataLength: BD.types.uint24le, data: BD.types.buffer(({current}) =&gt; current.dataLength), signature: BD.types.buffer(65), hash: BD.types.buffer(32), blockNumber: BD.types.uint24le, timestamp: BD.types.uint48le, } ```</code> </pre><br><h3>  - Token </h3><br><pre> <code class="plaintext hljs"> ```json { id: BD.types.string(null), owner: BD.types.buffer(20), block: BD.types.uint24le, amount: BD.types.string(null), } ```</code> </pre><br><h3>  - bloque </h3><br><pre> <code class="plaintext hljs"> ```json { number: BD.types.uint24le, merkleRootHash: BD.types.buffer(32), signature: BD.types.buffer(65), countTx: BD.types.uint24le, transactions: BD.types.array(Transaction.Protocol, ({current}) =&gt; current.countTx), timestamp: BD.types.uint48le, } ```</code> </pre><br>  Mediante los comandos habituales `BD.encode (block, Protocol) .slice ();` y `BD.decode (buffer, Protocol)`, convertimos los datos a `Buffer` para guardarlos en Redis o enviar otro nodo y recuperar los datos. <br><br>  Tambi√©n tenemos 2 protocolos binarios para transferir datos entre servicios: <br><br>  <i>- Protocolo para interactuar con Plasma Node a trav√©s de unix socket</i> <br><br><pre> <code class="plaintext hljs"> ```json { type: BD.types.uint8, messageId: BD.types.uint24le, error: BD.types.uint8, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  donde: <br><br><ul><li>  <b>`type`</b> - acci√≥n a realizar, por ejemplo, 1 - sendTransaction, 2 - getTransaction; </li><li>  <b>`payload '</b> - datos a transferir a la funci√≥n correspondiente; </li><li>  <b>`messageId`</b> - ID del mensaje para que se pueda identificar la respuesta. </li></ul><br>  <i>- Protocolo de interacci√≥n entre nodos</i> <br><br><pre> <code class="plaintext hljs"> ```json { code: BD.types.uint8, versionProtocol: BD.types.uint24le, seq: BD.types.uint8, countChunk: BD.types.uint24le, chunkNumber: BD.types.uint24le, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  donde: <br><br><ul><li>  <b>`code`</b> - c√≥digo de mensaje, por ejemplo 6 - PREPARE_NEW_BLOCK, 7 - BLOCK_VALID, 8 - BLOCK_COMMIT; </li><li>  <b>`versionProtocol`</b> - versi√≥n de protocolo, ya que los nodos con diferentes versiones se pueden generar en la red y pueden funcionar de diferentes maneras; </li><li>  <b>`seq`</b> - identificador de mensaje; </li><li>  <b>`countChunk` y`</b> <b>chunkNumber` son</b> necesarios para dividir mensajes grandes; </li><li>  <b>`length` y`</b> <b>payload` la</b> longitud y los datos en s√≠. </li></ul><br>  Como escribimos los datos de antemano, el sistema final es mucho m√°s r√°pido que la biblioteca `rlp` de Ethereum.  Desafortunadamente, a√∫n no hemos podido rechazarlo, ya que es necesario finalizar el contrato inteligente, que planeamos hacer en el futuro. <br><br>  Si logramos alcanzar una velocidad de <b>35,000</b> transacciones por segundo, tambi√©n debemos procesarlas en un tiempo √≥ptimo.  Dado que el tiempo aproximado de formaci√≥n del bloque toma 30 segundos, necesitamos incluir <b>1,000,000 de</b> transacciones en el bloque, lo que significa enviar m√°s de <b>100</b> mb de datos. <br><br>  Inicialmente, utilizamos la biblioteca `ethereumjs-devp2p` para comunicar nodos, pero no pod√≠a hacer frente a tantos datos.  Como resultado, utilizamos la biblioteca `ws` y configuramos la transferencia de datos binarios en websocket.  Por supuesto, tambi√©n encontramos problemas al enviar grandes paquetes de datos, pero los dividimos en fragmentos y ahora no existen tales problemas. <br><br>  Adem√°s, la formaci√≥n del √°rbol Merkle y el c√°lculo del hash <b>de 1,000,000 de</b> transacciones requiere aproximadamente <b>10</b> segundos de c√°lculo continuo.  Durante este tiempo, la conexi√≥n con todos los nodos logra romperse.  Se decidi√≥ transferir este c√°lculo a un hilo separado. <br><br><h2>  Conclusiones: </h2><br>  De hecho, nuestros hallazgos no son nuevos, pero por alguna raz√≥n, muchos expertos se olvidan de ellos durante el desarrollo. <br><br><ul><li>  El uso de la programaci√≥n funcional en lugar de la programaci√≥n orientada a objetos aumenta el rendimiento. </li><li>  Un monolito es peor que una arquitectura de servicio para un sistema de producci√≥n en NodeJS. </li><li>  El uso de `worker_threads` para computaci√≥n pesada mejora la capacidad de respuesta del sistema, especialmente cuando se trabaja con operaciones de E / S. </li><li>  Unix socket es m√°s estable y m√°s r√°pido que las solicitudes http. </li><li>  Si necesita transferir r√°pidamente datos de gran tama√±o a trav√©s de la red, es mejor usar sockets web y enviar datos binarios, divididos en fragmentos, que pueden reenviarse si no llegan y luego fusionarse en un solo mensaje. </li></ul><br>  Te invitamos a visitar el proyecto <b>GitHub</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/opporty-com/Plasma-Cash/tree/new-version</a> <br><br>  El art√≠culo fue coescrito por <i>Alexander Nashivan</i> , desarrollador senior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clever Solution Inc.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471096/">https://habr.com/ru/post/471096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471086/index.html">Generador de portadas de m√∫sica Python en Blender</a></li>
<li><a href="../471088/index.html">Burn Out IT-especialistas: 4 historias del gerente, desarrollador, producto y administrador. Y la receta de Southbridge.</a></li>
<li><a href="../471090/index.html">[No] use CDN</a></li>
<li><a href="../471092/index.html">Comando cp: copiar carpetas de archivos a * nix correctamente</a></li>
<li><a href="../471094/index.html">Tutu.ru y el Club de Programadores de Mosc√∫ est√°n invitados a una reuni√≥n de fondo el 17 de octubre</a></li>
<li><a href="../471098/index.html">Avance digital: c√≥mo fue</a></li>
<li><a href="../471100/index.html">Interacci√≥n entre componentes angulares usando RxJS</a></li>
<li><a href="../471102/index.html">DNS din√°mico personalizado con CloudFlare</a></li>
<li><a href="../471104/index.html">Resumen de eventos de TI de octubre (segunda parte)</a></li>
<li><a href="../471112/index.html">Est√∫pida raz√≥n por la cual su astuta aplicaci√≥n de visi√≥n artificial no funciona: orientaci√≥n en EXIF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>