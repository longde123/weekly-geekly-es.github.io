<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎷 🚕 🎄 我们根据某些规则在识别的图像上显示内容 🐣 👩‍👩‍👦‍👦 🥦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有时，当您阅读技术任务并设定实施期限时，会低估解决特定问题所花费的时间和精力。 碰巧一个点（按每周的时间估算）在一个小时完成，有时反之亦然。 但是这篇文章不是关于这个的。 这是对问题解决方案演变的演示。 从成立到实施。 



  使用条款 


- 标记或标记-上传到AR引擎的图像，可由设备的相机...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们根据某些规则在识别的图像上显示内容</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p> 有时，当您阅读技术任务并设定实施期限时，会低估解决特定问题所花费的时间和精力。 碰巧一个点（按每周的时间估算）在一个小时完成，有时反之亦然。 但是这篇文章不是关于这个的。 这是对问题解决方案演变的演示。 从成立到实施。 </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br>
<h1 id="ispolzuemye-terminy"> 使用条款 </h1><br><ul><li><p> 标记或标记-上传到AR引擎的图像，可由设备的相机（平板电脑或智能手机）识别，并且可以唯一地标识 </p><br></li><li><p> 找到-在相机视野中检测到的标记状态 </p><br></li><li><p> 丢失-从相机视图丢失时的标记状态 </p><br></li><li><p> 它可以显示-找到标记后，我们将显示标记所附加的内容 </p><br></li><li><p> 无法显示-找到标记时，不显示内容-标记所附加的内容-可以附加到标记上并因此将被显示的任何对象（3D模型，子画面，粒子系统等）在屏幕上是否找到标记 </p><br></li><li><p> 标记，标记，发现，丢失-提供识别功能的所有引擎固有的基本状态 </p><br></li><li><p> 它可以显示而不能显示-用于解决此问题的状态 </p><br><p>  <strong>一个例子：</strong> </p><br><ul><li> 下载应用程序=&gt;可以识别所有下载的品牌 </li><li> 我们正在尝试识别=&gt;标记的状态更改为“找到” </li><li> 如果标记可以显示=&gt;状态，则标记为“找到”，我们将显示附加到标记的模型 </li><li> 如果无法显示标记=&gt;标记的状态为“找到”，但不显示附加的模型 </li><li> 品牌从相机的视野中消失了=&gt;我们将状态更改为“丢失” </li></ul><br></li></ul><br><h1 id="vvedenie"> 引言 </h1><br><p> 有一张A4大小的大明信片。 它分为4个相等的部分（A5格式的一部分），在每个这些部分上有： </p><br><ul><li>  1个完整的角标记（1） </li><li> 底边标记的一半（5） </li><li> 顶部标记的一半（8） </li><li> 四分之一中心马克（9） </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="图片"></p><br><p>如果您使用任何识别引擎（例如Vuforia），那么您可能知道不存在“识别质量”之类的东西。 标记被识别或未被识别。 因此，如果引擎“看到”品牌，则将状态更改为<code>Find</code>并<code>OnSuccess()</code>方法；如果引擎“丢失”，状态将更改为<code>Lost</code>并<code>OnLost()</code>方法。 因此，根据现有条件和输入数据，当拥有一部分卡（一半或四分之一）时出现了一种情况，便有可能识别该品牌。 </p><br><p> 事实是，根据技术任务，计划逐步解锁角色。 在这种情况下，可以逐步解锁，但是鉴于没有人试图识别该品牌的四分之一或一半。 </p><br><h1 id="formulirovka-zadachi"> 任务说明 </h1><br><p> 有必要以程序代码的形式实现逻辑，以确保逐渐释放附加在标记上的内容。 从卡上元素的位置可以知道，标记1、2、3、4最初可用于显示。 </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="图片"></p><br><p> 如果已读取内容并将其显示在2个标记（例如2和3）上，则我们允许在标记6上显示内容。如果尚未读取标记1，则将关闭对标记5的访问。 进一步类推。 我们仅在读取相邻的角标记时才允许在侧标记处显示内容。 </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="图片"></p><br><p> 如果找到并找到了1到8个标记，则打开标记9上的内容以进行显示，每个标记具有2个状态-内容可用，不可用于显示，由<code>public bool IsActive;</code>字段负责<code>public bool IsActive;</code> </p><br><p> 马上很清楚，这应该是在状态之间进行转换的状态机，或者是“状态​​”模式的实现。 </p><br><div class="spoiler">  <b class="spoiler_title">扰流板</b> <div class="spoiler_text"><p> 结果不是一个，不是另一个。 我不能说这是一个拐杖，因为该解决方案完全满足了本文开头的要求。 但是你可以和我争论。 </p></div></div><br><p> 在此基础上，我让您有机会自己考虑一下此任务的可能解决方案和实现。 我花了大约5个小时才意识到并确定了决定的图片。 </p><br><p> 为了清楚起见，我录制了一段视频，上面已经捕获了算法的最终结果（如果可以调用它的话）。 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu"> 解决方法 </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1.从角标记到中心 </h2><br><p> 首先想到的是呈现从角落到中心的标记之间的相互作用。 在图形形式中，它看起来像这样： </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="图片"></p><br><p> 问题： </p><br><ol><li> 如何确定要更改状态的哪一侧标签？ 左边还是右边的那个？ 我们还强迫每个标记“知道”中心标记的存在。 </li><li> 有必要从类别中添加非显而易见的依赖项：侧面标记订阅了IsChangedEventCallback（）角标记事件，必须对中央标记执行类似的操作。 </li><li> 如果我们将每种类型的标记都视为一个实体，则在这些实体的层次结构中，我们将从下至上转发状态更改命令。 这不是很好，因为我们将数字与角度标记紧密绑定在一起，在这种情况下，角度标记失去了缩放的能力。 </li></ol><br><p> 由于存在许多极端情况和感知的复杂性，无法将上述解决方案付诸实践，我改变了选择依赖项开始扩散的标记的方法。 </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2.侧面知道中心和角落 </h2><br><p> 考虑到前一种方法的第3段的解决方案，想法是改变标记的类型，其他标记的状态也从此开始改变。 作为主要的侧面标记。 在这种情况下，通信（依赖项）如下所示： </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="图片"></p><br><p> 从这里可以立即清楚地看到，从横向到中心的连接是多余的，因为横向标记不需要了解任何有关中心标记的信息，因此该方法立即转变为最终方法。 </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3.中央的人知道每个人，侧面的人知道角落 </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="图片"></p><br><p> 最终的解决方案是，当侧面标记知道拐角时，这些拐角“过自己的生活”，而中心标记知道所有标记的状态。 </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="图片"></p><br><p> 使用明信片视图不是很方便。 实体之间的关系看起来不够清晰，无法轻松地将其转换为代码。 尝试以二叉树的形式进行解释可能会带来一些歧义。 但是这里二叉树的属性之一被破坏了，因此歧义立即消失了。 从中我们可以得出结论，可以清楚地解释此表示形式，并以图形方式表示问题的解决方案。 基于这些结论，我们将使用图形符号，即： </p><br><ul><li> 角度标记-角度节点（级别3） </li><li> 侧面标记-侧面节点（级别2） </li><li> 中心标记-中心节点（级别1） </li></ul><br><p> 优点： </p><br><ol><li> 标记之间的依赖性是显而易见的。 </li><li> 每个级别可以以3个实体的形式表示，每个实体都由基本部分组成，但是每个级别都具有其固有的附加功能 </li><li> 要扩展，您只需要添加具有自己特征的新型节点 </li><li> 这种解决方案很容易以OO（面向对象）风格来想象 </li></ol><br><h1 id="realizaciya"> 实作 </h1><br><h2 id="bazovye-suschnosti"> 基础实体 </h2><br><p> 让我们创建一个包含每个实体（名称，状态）固有元素的接口： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p> 接下来，我们描述每个节点的本质： </p><br><ul><li>  <strong>CornerNode-</strong>一个角度节点。 只需实现<code>INode</code>接口： </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p> 为什么<code>IsActive = true</code> ？ </p><br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"><p> 根据问题的情况，角标记的内容最初可用于识别。 </p></div></div><br><ul><li>  <strong>SideNode-</strong>侧节点。 我们实现了<code>INode</code>接口，但添加了<code>LeftCornerNode</code>和<code>RightCornerNode</code> 。 因此，侧节点保持其自身状态并且仅知道侧节点的存在。 </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong>是中央节点。 和前面的一样，我们实现了<code>INode</code> 。 添加类型为<code>List&lt;INode&gt;</code>的字段。 </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard"> 开卡类 </h2><br><h3 id="privatnye-metody-i-polya"> 私有方法和字段 </h3><br><p> 现在，我们已经创建了所制作的卡片的所有元素（各种标记），我们可以开始描述卡片本身的本质。 我不习惯用构造函数开始类。 我总是从特定实体固有的基本方法开始。 让我们从私有字段和私有方法开始。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p> 使用字段，一切都非常简单。  2个列表，其中包含角节点，侧节点和中心节点的一个字段。 </p><br><p> 接下来，您需要澄清一下。 事实是标记本身是可<code>Trackable</code>的类型，并且不知道（也不应该）它是那里其他逻辑的一部分。 因此，我们可以用来控制显示的全部就是他的名字。 因此，如果标记本身没有存储它所属的节点的类型，那么我们必须将此责任转移给我们的<code>OpenCard</code>类。 基于此，我们首先描述三种负责确定节点类型的私有方法。 </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p> 但是，直接使用这些方法没有意义。 当您使用另一个抽象级别的对象时，使用布尔值进行操作并不方便。 因此，我们将创建一个简单的<code>enum NodeType</code>和一个私有方法<code>GetNodeType()</code> ，该方法本身封装了与确定节点类型相关的所有逻辑。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody"> 公开方法 </h3><br><ul><li>  <code>IsExist</code>是一种返回布尔值的方法，该值指示我们的品牌是否属于明信片。 这是一种辅助方法，可以这样做，以便如果标记不属于任何卡，我们就可以在其上显示内容。 </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code>一种方法（顾名思义），其中我们检查节点的当前状态并更改其状态。 </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor"> 建设者 </h3><br><p> 当所有卡片都放在桌子上时，我们终于可以去构造函数了。 初始化可以有几种方法。 但是我决定尽可能多地摆脱<code>OpenCard</code>类不必要的手势。 它应该向我们回答内容是否可以显示。 因此，我们只要求输入2种类型的节点和一个中心节点的输入列表。 </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p> 请注意，由于中央节点仅需要检查所有其他<code>true</code>节点的条件，对于我们而言， <code>INode</code>构造函数中<code>INode</code>成角度的中央节点隐式<code>INode</code>为<code>INode</code>类型就足够了。 </p><br><h3 id="inicializaciya"> 初始化 </h3><br><p> 创建不需要附加到GameObject的对象（例如<code>MonoBehaviour</code>组件）的最便捷方法是什么？  -对， <code>ScriptableObject</code> 。 另外，为方便起见，添加<code>MenuItem</code>属性，该属性将简化新卡的创建。 </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p> 我们创作的最后一个和弦将是通过添加的（如果有） <code>ScriptableObject</code>数组以及从中创建明信片的过程。 在那之后，我们只需在<code>Update</code>方法中检查是否可以显示内容即可。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody"> 结论 </h1><br><p> 对我个人而言，结论如下： </p><br><ol><li> 在尝试解决问题时，您需要尝试将其元素分解为原子部分。 此外，考虑这些原子部分之间相互作用的所有可能选择，您需要从可能会产生更多连接的对象开始。 换句话说，它可以表述为：努力开始使用可能不太可靠的元素来解决问题 </li><li> 如果可能，您应尝试以其他形式显示源数据。 就我而言，图形表示对我有很大帮助。 </li><li> 每个实体彼此之间的间隔可能来自于该实体之间的连接数。 </li><li> 可以通过OO样式表示许多更习惯于通过编写算法来解决的应用任务 </li><li> 具有环依赖性的解决方案是一个糟糕的解决方案 </li><li> 如果很难将所有物体之间的连接保持在脑海中，这是一个错误的决定 </li><li> 如果您不能记住对象交互的逻辑，这是一个错误的决定 </li><li> 拐杖并不总是一个错误的决定 </li></ol><br><p> 您知道其他解决方案吗？  -在评论中写。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454452/">https://habr.com/ru/post/zh-CN454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454440/index.html">小趣味小游戏＃2：Starlette</a></li>
<li><a href="../zh-CN454442/index.html">如何为您的企业选择代理网络：3个实用技巧</a></li>
<li><a href="../zh-CN454444/index.html">我们分析了Habr的加载或页面上189个请求的呈现影响力</a></li>
<li><a href="../zh-CN454446/index.html">C＃8有什么新功能？</a></li>
<li><a href="../zh-CN454450/index.html">爱迪生如何发明无线技术却一无所知</a></li>
<li><a href="../zh-CN454456/index.html">培训Cisco 200-125 CCNA v3.0。 第7天。</a></li>
<li><a href="../zh-CN454458/index.html">变形测试：为什么几乎没人知道这一有前途的技术</a></li>
<li><a href="../zh-CN454460/index.html">＃300移动开发人员的有趣材料摘要（5月27日-6月2日）</a></li>
<li><a href="../zh-CN454462/index.html">没有照片纸的照片</a></li>
<li><a href="../zh-CN454464/index.html">基于双子座和故事书的视觉测试开发</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>