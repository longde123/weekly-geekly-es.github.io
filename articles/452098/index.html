<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍝 🐭 🧚 Registros del desarrollador front-end Habr: refactor y reflex ♉️ 🚛 😶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siempre me interesó cómo se organiza el Habr desde adentro, cómo se construye el flujo de trabajo, cómo se construyen las comunicaciones, qué estándar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Registros del desarrollador front-end Habr: refactor y reflex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/habr/blog/452098/"><img src="https://habrastorage.org/webt/bu/8e/tl/bu8etlfvktvmkcjotmzz6al7rgg.jpeg"><br><br>  Siempre me interesó cómo se organiza el Habr desde adentro, cómo se construye el flujo de trabajo, cómo se construyen las comunicaciones, qué estándares se aplican y cómo se escribe el código aquí.  Afortunadamente, tal oportunidad se me apareció, porque recientemente me convertí en parte del comando habra.  Usando el ejemplo de una pequeña refactorización de la versión móvil, trataré de responder la pregunta: ¿cómo es trabajar aquí en el frente?  En el programa: Node, Vue, Vuex y SSR con salsa de notas sobre experiencia personal en Habré. <a name="habracut"></a><br><br>  Lo primero que debe saber sobre el equipo de desarrollo es que somos pocos.  Pocos son tres frentes, dos respaldos y técnicas de todo Habr - Bucksley.  Por supuesto, también hay un probador, diseñador, tres Vadim, una escoba milagrosa, un vendedor y otros Bumburums.  Pero solo hay seis contribuyentes directos al género Habra.  Esto es bastante raro: un proyecto con una audiencia multimillonaria que parece una empresa gigantesca desde el exterior es en realidad más como una startup acogedora con la estructura organizativa más plana. <br><br>  Al igual que muchas otras empresas de TI, Habr profesa las ideas de Agile, la práctica de CI y eso es todo.  Pero según mis sentimientos, Habr, como producto, se desarrolla de manera más ondulante que continua.  Entonces, durante varios sprints seguidos, estamos trabajando arduamente para codificar, diseñar y rediseñar, romper algo y arreglar, resolver boletos y comenzar nuevos, pisar el rastrillo y dispararnos en las piernas para finalmente lanzar la función en producción.  Y luego viene una pausa, un período de reurbanización, el tiempo para hacer lo que está en el cuadrante "importante-no urgente". <br><br>  A continuación se tratará sobre un sprint fuera de temporada.  Esta vez consiguió refactorizar la versión móvil de Habr.  En general, la compañía tiene grandes esperanzas y, en el futuro, debería reemplazar todo el zoológico de encarnación Habr y convertirse en una solución universal multiplataforma.  Algún día aparecerá un diseño adaptativo y PWA, y el modo fuera de línea, y la personalización del usuario, y muchas cosas interesantes. <br><br><h3>  Nosotros establecemos la tarea </h3><br>  Una vez, en un stand-up ordinario, uno de los frentes habló sobre problemas en la arquitectura del componente de comentarios de la versión móvil.  A partir de esta presentación, organizamos una micro reunión en el formato de psicoterapia grupal.  A su vez, cada uno decía dónde tenía dolor, todo estaba arreglado en papel, simpatizaba, entendía, excepto que nadie aplaudía.  El resultado fue una lista de 20 problemas, lo que dejó en claro que el Habr móvil debe recorrer un camino largo y espinoso hacia el éxito. <br><br>  Mi principal preocupación era la eficiencia de los recursos y lo que se llama una interfaz fluida.  Todos los días, en la ruta "hogar-trabajo-hogar", veía mi viejo teléfono tratando desesperadamente de mostrar 20 títulos en la secuencia.  Se parecía a esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/v8/zr/nvv8zr5uneyynf4ntntk9sp3gzs.gif" alt="imagen"></div>  <sub><font color="grey"><i>Interfaz móvil Habr antes de refactorizar</i></font></sub> <br><br>  ¿Qué está pasando aquí?  En resumen, el servidor proporcionó la página HTML a todos de la misma manera, independientemente de si el usuario inició sesión o no.  Luego, el cliente JS se carga y nuevamente solicita los datos necesarios, pero con una enmienda para la autorización.  Es decir, de hecho, hicimos el mismo trabajo dos veces.  La interfaz parpadeó y el usuario descargó unos cien kilobytes adicionales.  En detalles, todo parecía aún más espeluznante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/py/d8/0kpyd8h81q0_sgb8dd2gt7wfhvw.jpeg"></div>  <sub><font color="grey"><i>Antiguo circuito SSR-CSR.</i></font></sub>  <sub><font color="grey"><i>La autorización solo es posible en las etapas C3 y C4, cuando el Nodo JS no está ocupado generando HTML y puede proxy de solicitudes de API.</i></font></sub> <br><br>  Nuestra arquitectura de esa época fue descrita con mucha precisión por uno de los usuarios de Habr: <br><blockquote>  La versión móvil es una mierda.  Yo hablo tal como es.  Una terrible combinación de SSR junto con CSR. </blockquote><br>  Tuvimos que admitirlo, por triste que sea. <br><br>  Descubrí las opciones, me puse un boleto en el "Jira" con una descripción en el nivel de "Ahora está mal, haz las reglas" y con trazos amplios descompuse la tarea: <br><br><ul><li>  reutilizar datos </li><li>  minimizar el número de redibujos, </li><li>  excluir solicitudes duplicadas </li><li>  hacer que el proceso de carga sea más obvio. </li></ul><br><h3>  Reutilizar datos </h3><br>  En teoría, la representación del lado del servidor está diseñada para resolver dos problemas: no sufrir las limitaciones de los motores de búsqueda con respecto a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">indexación de SPA</a> y mejorar la métrica de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FMP</a> (inevitablemente empeoramiento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TTI</a> ).  En el escenario clásico, que finalmente se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formuló en Airbnb en 2013</a> (en Backbone.js), SSR es la misma aplicación JS isomorfa que se ejecuta en el entorno Node.  El servidor simplemente devuelve el diseño generado como respuesta a la solicitud.  Luego se produce la rehidratación en el lado del cliente, y luego todo funciona sin recargar la página.  Para Habr, así como para muchos otros recursos llenos de texto, la representación del servidor es un elemento crítico en la construcción de relaciones amigables con los motores de búsqueda. <br><br>  A pesar del hecho de que han pasado más de seis años desde el advenimiento de la tecnología, y durante este tiempo, realmente ha fluido mucha agua en el mundo frontend, para muchos desarrolladores esta idea todavía está cubierta por un velo de secreto.  No nos hicimos a un lado y lanzamos una aplicación Vue con soporte SSR para el producto, sin un pequeño detalle: no lanzamos el estado inicial al cliente. <br><br>  Por qué  No hay una respuesta exacta a esta pregunta.  O no querían aumentar el tamaño de la respuesta del servidor, o debido a un montón de otros problemas arquitectónicos, o simplemente no despegaron.  De una forma u otra, arrojar estado y reutilizar todo lo que hizo el servidor parece ser bastante apropiado y útil.  La tarea es realmente trivial: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estado simplemente se inyecta</a> en el contexto de ejecución y Vue lo agrega automáticamente al diseño generado como una variable global: <code>window.__INITIAL_STATE__</code> . <br><br>  Uno de los problemas que surgió fue la incapacidad de convertir estructuras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">circulares</a> a JSON;  se resolvió simplemente reemplazando tales estructuras con sus análogos planos. <br><br>  Además, al tratar con contenido UGC, recuerde que los datos deben convertirse a entidades HTML para no romper el HTML.  Para estos fines usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">él</a> . <br><br><h3>  Minimizar redibujos </h3><br>  Como se puede ver en el diagrama anterior, en nuestro caso, una instancia de Node JS realiza dos funciones: SSR y "proxy" en la API, donde el usuario está autorizado.  Esta circunstancia hace que la autorización sea imposible en el momento de la ejecución del código JS en el servidor, ya que el nodo tiene un solo subproceso y la función SSR es síncrona.  Es decir, el servidor simplemente no puede enviarse solicitudes a sí mismo mientras la pila de llamadas está ocupada con algo.  Resultó que omitimos el estado, pero la interfaz no dejó de contraerse, ya que los datos del cliente deberían actualizarse teniendo en cuenta la sesión del usuario.  Era necesario enseñar a nuestra aplicación a poner los datos correctos en el estado inicial, teniendo en cuenta el inicio de sesión del usuario. <br><br>  Solo había dos soluciones al problema: <br><br><ul><li>  para aferrar datos de autorización a solicitudes entre servidores; </li><li>  Divida las capas de Nodo JS en dos instancias separadas. </li></ul><br>  La primera solución requirió el uso de variables globales en el servidor, y la segunda extendió el tiempo necesario para completar la tarea al menos un mes. <br><br>  ¿Cómo hacer una elección?  Habr a menudo se mueve por el camino de menor resistencia.  Informalmente, existe un cierto deseo general de minimizar el ciclo de la idea al prototipo.  El modelo de actitud hacia el producto recuerda un poco a los postulados de booking.com, con la única diferencia de que Habr es mucho más serio acerca de los comentarios de los usuarios y confía en la adopción de tales decisiones como desarrollador. <br><br>  Siguiendo esta lógica y mi propio deseo de resolver rápidamente el problema, elegí variables globales.  Y, como esto sucede a menudo, tarde o temprano tienen que pagar por ellos.  Pagamos casi de inmediato: trabajamos el fin de semana, recogimos las consecuencias, escribimos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">post mortem</a> y comenzamos a dividir el servidor en dos partes.  El error fue muy estúpido, y el error con su participación no fue fácil de reproducir.  Y sí, por vergüenza, pero de alguna manera, tropezando y gruñendo, mi PoC con variables globales todavía entró en producción y funciona con bastante éxito en previsión de pasar a una nueva arquitectura de "dos días".  Este fue un paso importante, porque formalmente se logró el objetivo: el SSR aprendió a dar una página que estaba completamente lista para usar, y la interfaz de usuario se volvió mucho más tranquila. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/rx/d-/rmrxd-fkzne7vbcj-jxxrbbwid8.gif" alt="imagen"></div>  <sub><font color="grey"><i>Interfaz móvil Habr después de la primera etapa de refactorización</i></font></sub> <br><br>  Finalmente, la arquitectura de la versión móvil SSR-CSR lleva a esta imagen: <br><br>  ￼ <div style="text-align:center;"><img src="https://habrastorage.org/webt/7t/jb/km/7tjbkmkiq4n5atanzsj3ylkwrke.jpeg" alt="imagen"></div>  <sub><font color="grey"><i>Esquema SSR-CSR de "dos días".</i></font></sub>  <sub><font color="grey"><i>Nodo JS API siempre está listo para E / S asíncronas y no está bloqueado por la función SSR, ya que este último se encuentra en una instancia separada.</i></font></sub>  <sub><font color="grey"><i>La cadena de consulta # 3 no es necesaria.</i></font></sub> <br><br><h3>  Excluir solicitudes duplicadas </h3><br>  Después de las manipulaciones, la presentación inicial de la página dejó de provocar epilepsia.  Pero el uso posterior de Habr en el modo SPA todavía causó desconcierto. <br><br>  Dado que el flujo de usuarios se basa en las transiciones de la <i>lista de artículos → artículo → comentarios</i> y viceversa, fue importante optimizar el consumo de recursos de esta cadena en primer lugar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/eo/01/ukeo01u79_olhiv1eo9vxao4yv4.gif" alt="imagen"></div>  <sub><font color="grey"><i>Un regreso al feed posterior provoca una nueva solicitud de datos</i></font></sub> <br><br>  No tuve que cavar profundo.  En el screencast anterior, se puede ver que la aplicación vuelve a consultar la lista de artículos cuando se desliza hacia atrás, y durante la solicitud no vemos el artículo, por lo que los datos anteriores desaparecen en algún lugar.  Parece que el componente de la lista de artículos usa un estado local y lo pierde al destruir.  De hecho, la aplicación utilizaba el estado global, pero la arquitectura Vuex se creó en la frente: los módulos están vinculados a páginas, que a su vez están vinculadas a rutas.  Además, todos los módulos son "únicos": cada visita posterior a la página reescribió todo el módulo: <br><br><pre> <code class="javascript hljs">ArticlesList: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">PageArticle</span></span>: { ArticleFull1 },</code> </pre><br>  En total, teníamos el módulo <i>ArticlesList</i> , que contiene objetos del tipo <i>Article</i> y el módulo <i>PageArticle</i> , que era una versión extendida del objeto <i>Article</i> , una especie de <i>ArticleFull</i> .  En general, esta implementación no conlleva nada terrible en sí misma: es muy simple, incluso se podría decir ingenuamente, pero es extremadamente clara.  Si recorta la puesta a cero del módulo con cada cambio de la ruta, incluso puede vivir con él.  Sin embargo, la transición entre feeds de artículos, por ejemplo <i>/ feed → / all</i> , garantiza descartar todo lo relacionado con el feed personal, ya que solo tenemos una lista de <i>artículos</i> en la que colocar nuevos datos.  Esto nuevamente conduce a consultas duplicadas. <br><br>  Al reunir todo lo que logré descubrir sobre el tema, formulé una nueva estructura estatal y se la presenté a mis colegas.  Las discusiones fueron largas, pero al final, los argumentos "a favor" superaron las dudas, y comencé la implementación. <br><br>  La lógica de la solución se revela mejor en dos etapas.  Primero, intentamos desatar el módulo Vuex de las páginas y vincularlo directamente a las rutas.  Sí, habrá un poco más de datos en la tienda, los captadores se volverán un poco más complicados, pero no cargaremos los artículos dos veces.  Para la versión móvil, este es quizás el argumento más fuerte.  Se verá más o menos así: <br><br><pre> <code class="javascript hljs">ArticlesList: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ { Article2 }, ... ], }</code> </pre><br>  Pero, ¿qué sucede si las listas de artículos pueden superponerse entre múltiples rutas, y qué sucede si queremos reutilizar los datos de un objeto <i>Artículo</i> para representar una página de publicación, convirtiéndola en <i>Artículo Completo</i> ?  En este caso, sería más lógico utilizar dicha estructura: <br><br><pre> <code class="javascript hljs">ArticlesIds: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, ... ], }, <span class="hljs-attr"><span class="hljs-attr">ArticlesList</span></span>: { <span class="hljs-string"><span class="hljs-string">'1'</span></span>: { Article1 }, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: { Article2 }, ... }</code> </pre><br>  <i>La lista de artículos</i> aquí es solo una especie de repositorio de artículos.  Todos los artículos que se cargaron durante la sesión del usuario.  Los tratamos con el mayor cuidado posible, porque este es el tráfico que puede haber sido cargado a través del dolor en algún lugar del metro entre estaciones, y definitivamente no queremos causarle al usuario este dolor nuevamente, forzándolo a cargar los datos que ya ha descargado.  El objeto <i>ArticlesIds</i> es solo una matriz de identificadores (como "enlaces") para objetos <i>Article</i> .  Esta estructura le permite no duplicar los datos comunes a las rutas y reutilizar el objeto <i>Artículo</i> al representar una página de publicación al fusionar datos extendidos en ella. <br><br>  El resultado de la lista de artículos también se ha vuelto más transparente: el componente iterador itera sobre la matriz con ID de artículo y dibuja el componente teaser del artículo, pasando Id como accesorios, y el componente hijo a su vez recupera los datos necesarios de la <i>Lista de artículos</i> .  Cuando va a la página de publicación, obtenemos la fecha existente de la lista de <i>artículos</i> , solicitamos los datos que faltan y simplemente los agregamos al objeto existente. <br><br>  ¿Por qué es mejor este enfoque?  Como escribí anteriormente, este enfoque es más cuidadoso en relación con los datos descargados y le permite reutilizarlos.  Pero además de esto, abre el camino a nuevas oportunidades que encajan perfectamente en dicha arquitectura.  Por ejemplo, sondear y subir artículos al feed tal como aparecen.  Simplemente podemos agregar nuevas publicaciones a la "tienda" de <i>ArticlesList</i> , guardar una lista separada de nuevos ID en <i>ArticlesIds</i> y notificar al usuario sobre esto.  Cuando hace clic en el botón "Mostrar nuevas publicaciones", simplemente insertamos un nuevo Id al comienzo de la matriz de la lista actual de artículos y todo funcionará casi mágicamente. <br><br><h3>  Hacer la descarga más agradable </h3><br>  La guinda del pastel de refactorización fue el concepto de esqueletos, lo que hace que el proceso de descarga de contenido en Internet sea un poco menos desagradable.  No hubo discusiones sobre este tema, el viaje de la idea al prototipo tomó literalmente dos horas.  El diseño fue dibujado casi por nosotros mismos, y enseñamos a nuestros componentes cómo renderizar bloques div sin pretensiones, apenas parpadeantes mientras esperamos datos.  Subjetivamente, este enfoque de carga realmente reduce la cantidad de hormonas del estrés en el cuerpo del usuario.  El esqueleto se ve así: <br><br><img src="https://habrastorage.org/webt/yn/gn/ey/yngneyh8sftpmyyyj4ur_ihjo2c.jpeg" alt="imagen"><br>  <sub><font color="grey"><i>Habraloading</i></font></sub> <br><br><h3>  Reflexionar </h3><br>  Llevo seis meses trabajando en Habré y mis amigos todavía me preguntan: bueno, ¿qué te parece?  Bien, cómodo, sí.  Pero hay algo que distingue este trabajo de los demás.  Trabajé en equipos que eran completamente indiferentes a su producto, no sabían y no entendían quiénes eran sus usuarios.  Pero aquí todo es diferente.  Aquí te sientes responsable de lo que estás haciendo.  En el proceso de desarrollo de una función, se convierte parcialmente en su propietario, participa en todas las reuniones de productos relacionadas con su funcionalidad, hace sugerencias y toma decisiones usted mismo.  Hacer un producto que usa usted mismo a diario es muy bueno, y escribir código para las personas que pueden ser mejores es simplemente una sensación increíble (sin sarcasmo). <br><br>  Después del lanzamiento de todos estos cambios, recibimos una respuesta positiva, y fue muy, muy agradable.  Es inspirador.  Gracias  Escribe más <br><br>  Permítame recordarle que después de las variables globales, decidimos cambiar la arquitectura y separar la capa proxy en una instancia separada.  La arquitectura de "dos días" ya ha llegado al lanzamiento en forma de pruebas beta públicas.  Ahora cualquiera puede cambiar y ayudarnos a mejorar el Habr móvil.  Eso es todo por hoy.  Estaré encantado de responder todas sus preguntas en los comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452098/">https://habr.com/ru/post/452098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452086/index.html">Qué hay en mi píxel para ti: crear nanopíxeles usando metasuperficies de plasmón</a></li>
<li><a href="../452088/index.html">Reconocimiento de carreteras mediante segmentación semántica.</a></li>
<li><a href="../452090/index.html">Crear un generador de rompecabezas procesal</a></li>
<li><a href="../452092/index.html">Actualizaciones en la aplicación: acelerar las actualizaciones de aplicaciones de Android</a></li>
<li><a href="../452094/index.html">.NET: Herramientas para trabajar con subprocesos múltiples y asincronía. Parte 1</a></li>
<li><a href="../452102/index.html">Juego de fotos para quienes gustan de los drones: brevemente sobre AirSelfie 2</a></li>
<li><a href="../452106/index.html">Invitamos a los oradores a la reunión de verano de bricolaje el 16 de junio de 2019</a></li>
<li><a href="../452108/index.html">Docker: consejos inofensivos</a></li>
<li><a href="../452110/index.html">Automatice el reemplazo del disco con Ansible</a></li>
<li><a href="../452112/index.html">CRM ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>