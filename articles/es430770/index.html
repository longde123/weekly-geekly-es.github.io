<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíñ ü•ô üë®üèæ‚Äçüéì Copia de seguridad para Linux, o c√≥mo crear una instant√°nea ü•¢ üõãÔ∏è ü§∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Trabajo en Veeam en el proyecto Veeam Agent para Linux. Con este producto, puede hacer una copia de seguridad de una m√°quina Linux. "Age...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copia de seguridad para Linux, o c√≥mo crear una instant√°nea</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/430770/">  Hola a todos!  Trabajo en Veeam en el proyecto Veeam Agent para Linux.  Con este producto, puede hacer una copia de seguridad de una m√°quina Linux.  "Agente" en el nombre significa que el programa le permite hacer copias de seguridad de m√°quinas f√≠sicas.  Virtualalkans tambi√©n realiza copias de seguridad, pero se encuentra en el sistema operativo invitado. <br><br>  La inspiraci√≥n para este art√≠culo fue mi informe en la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linux Piter</a> , que decid√≠ publicar como un art√≠culo para todos los interesados ‚Äã‚Äãhabragiteli. <br><br>  En este art√≠culo, revelar√© el tema de la creaci√≥n de una instant√°nea que le permite realizar copias de seguridad y hablar sobre los problemas que encontramos al crear nuestro propio mecanismo para crear instant√°neas de dispositivos de bloque. <br><br>  Todos los interesados ‚Äã‚Äãpor favor pidan un corte! <br><br><img src="https://habrastorage.org/webt/7w/qi/zh/7wqizhorjrpayiif7gin7adkisk.png"><br><a name="habracut"></a><br><h2>  Un poco de teor√≠a al principio </h2><br>  Hist√≥ricamente, hay dos enfoques para crear copias de seguridad: copia de seguridad de archivos y copia de seguridad de volumen.  En el primer caso, copiamos cada archivo como un objeto separado, en el segundo, copiamos todo el contenido del volumen como una especie de imagen. <br><br>  Ambos m√©todos tienen muchas ventajas y desventajas, pero los consideraremos a trav√©s del prisma de recuperaci√≥n del fracaso: <br><br><ul><li>  En el caso de la copia de seguridad de archivos, para recuperar completamente el servidor completo, primero tendremos que instalar el sistema operativo, luego los servicios necesarios, y solo luego restaurar los archivos de la copia de seguridad. </li><li>  En el caso de la copia de seguridad de volumen, para una recuperaci√≥n completa, es suficiente simplemente restaurar todos los vol√∫menes de una m√°quina sin esfuerzos innecesarios por parte de una persona. </li></ul><br>  Obviamente, en el caso de la copia de seguridad de volumen, puede restaurar el sistema m√°s r√°pido, y esta es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caracter√≠stica</a> importante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del sistema</a> .  Por lo tanto, para nosotros, notamos la copia de seguridad de volumen como la opci√≥n preferida. <br><br>  ¬øC√≥mo tomamos y guardamos todo el volumen?  Por supuesto, simplemente copiando no lograremos nada bueno.  Durante la copia, se producir√° alguna actividad con datos en el volumen, como resultado, los datos inconsistentes aparecer√°n en la copia de seguridad.  Se violar√° la estructura del sistema de archivos, se da√±ar√°n los archivos de la base de datos, as√≠ como otros archivos con los que se realizar√°n operaciones durante la copia. <br><br>  Para evitar todos estos problemas, a la humanidad progresiva se le ocurri√≥ una tecnolog√≠a de instant√°nea: instant√°nea.  En teor√≠a, todo es simple: creamos una copia sin cambios, una instant√°nea, y respaldamos los datos.  Cuando finaliza la copia de seguridad, destruimos la instant√°nea.  Suena simple, pero, como siempre, hay matices. <br><br>  Gracias a ellos, nacieron muchas implementaciones de esta tecnolog√≠a.  Por ejemplo, las soluciones basadas en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mapeador de dispositivos</a> , como LVM y Thin provisioning, proporcionan instant√°neas de volumen completo, pero requieren un dise√±o de disco especial en la etapa de instalaci√≥n del sistema, lo que significa que, en general, no son adecuadas. <br><br>  BTRFS y ZFS hacen posible crear instant√°neas de las subestructuras del sistema de archivos, lo cual es muy bueno, pero en este momento su participaci√≥n en los servidores es peque√±a, y estamos tratando de hacer una soluci√≥n universal. <br><br>  Supongamos que hay un EXT banal en nuestro dispositivo de bloque.  En este caso, podemos usar <a href="">dm-snap</a> (por cierto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dm-bow</a> se est√° desarrollando ahora), pero aqu√≠ est√° su propio matiz.  Debe tener un dispositivo de bloque libre listo para que pueda colocar datos de instant√°neas donde sea. <br>  Al prestar atenci√≥n a las soluciones alternativas de respaldo, notamos que, por regla general, usan su m√≥dulo de kernel para crear instant√°neas de dispositivos de bloque.  Decidimos seguir este camino, escribiendo nuestro m√≥dulo.  Se decidi√≥ distribuirlo bajo la licencia GPL, para que est√© disponible p√∫blicamente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . <br><br><h2>  C√≥mo funciona, en teor√≠a </h2><br><h3>  Instant√°nea del microscopio </h3><br>  Por lo tanto, ahora consideraremos el principio general del funcionamiento del m√≥dulo y nos detendremos en cuestiones clave con m√°s detalle. <br><br>  De hecho, veeamsnap (como lo llamamos nuestro m√≥dulo del n√∫cleo) es un filtro de controlador de dispositivo de bloque. <br><br><img src="https://habrastorage.org/webt/gi/kg/ct/gikgctn2xian0bhuauiogpqqe5c.png"><br><br>  Su trabajo es interceptar las solicitudes de un controlador de dispositivo de bloque. <br><br>  Despu√©s de interceptar una solicitud de escritura, el m√≥dulo copia datos del dispositivo de bloque original al √°rea de datos de la instant√°nea.  Llamamos a esta √°rea snapstore. <br><br><img src="https://habrastorage.org/webt/cl/hz/lt/clhzltlt564esinieyefu9gwqka.png"><br><br>  ¬øY cu√°l es la instant√°nea en s√≠ misma?  Este es un dispositivo de bloque virtual, una copia del dispositivo original en un punto particular en el tiempo.  Al acceder a los bloques de datos en este dispositivo, se pueden leer desde el complemento o desde el dispositivo original. <br><br>  Quiero se√±alar que la instant√°nea es exactamente el dispositivo de bloque que es completamente id√©ntico al original en el momento en que se elimin√≥ la instant√°nea.  Gracias a esto, podemos montar el sistema de archivos en una instant√°nea y realizar el preprocesamiento necesario. <br><br>  Por ejemplo, podemos obtener un mapa de bloques ocupados del sistema de archivos.  La forma m√°s f√°cil de hacer esto es usar ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GETFSMAP</a> . <br>  Los datos en bloques ocupados le permiten leer solo los √∫ltimos datos de una instant√°nea. <br><br>  Tambi√©n puede excluir algunos archivos.  Bueno, una acci√≥n completamente opcional: indexar los archivos que caen en la copia de seguridad, para la posibilidad de un restaurante granular en el futuro. <br><br><h3>  CoW vs RoW </h3><br>  Deteng√°monos un poco en la elecci√≥n del algoritmo de instant√°nea.  La elecci√≥n aqu√≠ no es muy extensa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copiar al escribir o Redirigir al escribir</a> . <br><br>  Redirect-on-Write al interceptar una solicitud de escritura lo redireccionar√° al complemento, despu√©s de lo cual todas las solicitudes para leer este bloque tambi√©n ir√°n all√≠.  Un gran algoritmo para sistemas de almacenamiento basados ‚Äã‚Äãen √°rboles B +, como BTRFS, ZFS y Thin Provisioning.  La tecnolog√≠a es tan antigua como el mundo, pero se manifiesta especialmente bien en hipervisores, donde puede crear un nuevo archivo y escribir nuevos bloques all√≠ durante la instant√°nea.  El rendimiento es excelente en comparaci√≥n con la vaca.  Pero hay un gran inconveniente: la estructura del dispositivo original cambia, y al eliminar la instant√°nea, debe copiar todos los bloques del complemento a la ubicaci√≥n original. <br><br>  Copy-on-Write, cuando intercepta una solicitud, copia datos en el almac√©n de instant√°neas que debe sufrir un cambio, despu√©s de lo cual permite que se sobrescriban en el lugar original.  Se usa para crear instant√°neas para vol√∫menes LVM y instant√°neas de VSS.  Obviamente, es m√°s adecuado para crear instant√°neas de dispositivos de bloque, porque  no cambia la estructura del dispositivo original, y cuando elimina (o bloquea) la instant√°nea simplemente puede descartarse sin arriesgar datos.  La desventaja de este enfoque es la degradaci√≥n del rendimiento, ya que se agregan un par de operaciones de lectura / escritura a cada operaci√≥n de escritura. <br><br>  Dado que la seguridad de los datos es nuestra principal prioridad, nos centramos en CoW. <br><br>  Hasta ahora, todo parece simple, as√≠ que repasemos los problemas de la vida real. <br><br><h2>  C√≥mo funciona: en la pr√°ctica </h2><br><h3>  Condici√≥n consistente </h3><br>  Por su bien, todo fue concebido. <br>  Por ejemplo, si al momento de crear una instant√°nea (en una primera aproximaci√≥n, podemos suponer que se cre√≥ instant√°neamente) se grabar√° un registro en alg√∫n archivo, entonces en una instant√°nea el archivo estar√° incompleto, lo que significa que estar√° da√±ado y carecer√° de sentido.  La situaci√≥n es similar con los archivos de base de datos y el sistema de archivos en s√≠. <br><br>  ¬°Pero vivimos en el siglo XXI!  ¬°Existen mecanismos de registro que protegen contra tales problemas!  Es cierto, la verdad es que hay un importante "pero": esta protecci√≥n no es del fracaso, sino de sus consecuencias.  Al restaurar a un estado consistente de acuerdo con el registro, las operaciones incompletas se descartar√°n, lo que significa que se perder√°n.  Por lo tanto, es importante cambiar la prioridad a la protecci√≥n de la causa, en lugar de tratar las consecuencias. <br><br>  Se puede advertir al sistema que ahora se crear√° una instant√°nea.  Para esto, el n√∫cleo tiene las funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">freeze_bdev</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">thaw_bdev</a> .  Extraen las funciones del sistema de archivos freeze_fs y unfreeze_fs.  Cuando llama al primero, el sistema debe restablecer la memoria cach√©, suspender la creaci√≥n de nuevas solicitudes para el dispositivo de bloqueo y esperar la finalizaci√≥n de todas las solicitudes generadas previamente.  Y cuando se llama a unfreeze_fs, el sistema de archivos restaura su funcionamiento normal. <br><br>  Resulta que podemos advertir al sistema de archivos.  ¬øQu√© pasa con las aplicaciones?  Aqu√≠, desafortunadamente, todo est√° mal.  Mientras que en Windows hay un mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VSS</a> que, con la ayuda de Writers, proporciona interacci√≥n con otros productos, en Linux cada uno sigue su propio camino.  Por el momento, esto ha llevado a la situaci√≥n de que la tarea del administrador del sistema de escribir (copiar, <s>robar</s> , comprar, etc.) guiones de precongelaci√≥n y descongelaci√≥n por su cuenta, lo que preparar√° su aplicaci√≥n para la instant√°nea.  Por nuestra parte, en la pr√≥xima versi√≥n presentaremos soporte para Oracle Application Processing, como la caracter√≠stica m√°s solicitada por nuestros clientes.  Entonces, otras aplicaciones pueden ser compatibles, pero en general la situaci√≥n es bastante triste. <br><br><h3>  ¬øD√≥nde colocar el complemento? </h3><br>  Este es el segundo problema que se interpone en nuestro camino.  A primera vista, el problema no es obvio, pero despu√©s de un poco de comprensi√≥n, vemos que esto sigue siendo una astilla. <br><br>  Por supuesto, la soluci√≥n m√°s f√°cil es colocar el complemento en la RAM.  Para el desarrollador, ¬°la opci√≥n es simplemente genial!  Todo es r√°pido, muy conveniente para depurar, pero hay una jamba: la RAM es un recurso valioso, y nadie nos dar√° una gran oportunidad all√≠. <br><br>  Bien, hagamos que el archivo instant√°neo sea un archivo normal.  Pero surge otro problema: no puede hacer una copia de seguridad del volumen en el que se encuentra la instant√°nea.  La raz√≥n es simple: interceptamos solicitudes de grabaci√≥n, lo que significa que interceptaremos nuestras propias solicitudes de grabaci√≥n en el complemento.  Los caballos corr√≠an de manera cient√≠fica: punto muerto.  Luego, existe un gran deseo de utilizar un disco separado para esto, pero nadie agregar√° discos a nuestro servidor por nuestro bien.  Debes poder trabajar en lo que es. <br><br>  Posicionar remotamente el complemento es una excelente idea, pero se puede implementar en c√≠rculos muy estrechos de redes con gran ancho de banda y latencias microsc√≥picas.  De lo contrario, mientras mantiene la instant√°nea en la m√°quina, habr√° una estrategia por turnos. <br><br>  Por lo tanto, debe colocar de alguna manera dif√≠cil el complemento en el disco local.  Pero, por regla general, todo el espacio en los discos locales ya est√° distribuido entre los sistemas de archivos y, al mismo tiempo, debe pensar detenidamente c√≥mo solucionar el problema del punto muerto. <br><br>  La direcci√≥n para la reflexi√≥n, en principio, es una: necesita asignar espacio de alguna manera en el sistema de archivos, pero trabajar directamente con el dispositivo de bloque.  La soluci√≥n a este problema se implement√≥ en el c√≥digo de espacio de usuario, en el servicio. <br><br>  Hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada al</a> sistema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Falcocate</a> que le permite crear un archivo vac√≠o del tama√±o deseado.  Sin embargo, de hecho, solo se crean metadatos en el sistema de archivos que describen la ubicaci√≥n del archivo en el volumen.  Y ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FIEMAP</a> nos permite obtener un mapa de la ubicaci√≥n de los bloques de archivos. <br><br>  Y listo: creamos un archivo instant√°neo usando Falocate, FIEMAP nos da un mapa de la ubicaci√≥n de los bloques de este archivo, que podemos transferir para trabajar en nuestro m√≥dulo veeamsnap.  Adem√°s, al acceder al snapstor, el m√≥dulo realiza solicitudes directamente al dispositivo de bloque en bloques que conocemos, y sin puntos muertos. <br><br>  Pero hay un matiz.  La llamada al sistema de Falcocate solo es compatible con XFS, EXT4 y BTRFS.  Para otros sistemas de archivos como EXT3, debe escribirlo completamente para asignar el archivo.  La funcionalidad se ve afectada por un aumento en el tiempo para preparar snappads, pero no hay otra opci√≥n.  Nuevamente, necesitas poder trabajar en lo que es. <br><br>  ¬øQu√© sucede si ioctl FIEMAP tampoco es compatible?  Esta es la realidad de NTFS y FAT32, donde ni siquiera hay soporte para el antiguo FIBMAP.  Tuve que implementar un cierto algoritmo gen√©rico, cuya operaci√≥n no depende de las caracter√≠sticas del sistema de archivos.  En pocas palabras, el algoritmo es: <br><br><ol><li>  El servicio crea un archivo y comienza a escribirle un patr√≥n espec√≠fico. </li><li>  El m√≥dulo intercepta las solicitudes de escritura, verifica los datos que se escriben. </li><li>  Si los datos del bloque coinciden con el patr√≥n dado, entonces el bloque se marca como perteneciente al snapstop. </li></ol><br>  S√≠, dif√≠cil, s√≠, lentamente, pero mejor que nada.  Se utiliza en casos excepcionales para sistemas de archivos sin soporte FIEMAP y FIBMAP. <br><br><h3>  Desbordamiento de instant√°nea </h3><br>  M√°s bien, el lugar que asignamos en la tienda de instant√°neas termina.  La esencia del problema es que no hay ning√∫n lugar para descartar nuevos datos, lo que significa que la instant√°nea queda inutilizable. <br>  Que hacer <br><br>  Obviamente, necesita aumentar el tama√±o de los snappants.  Cuanto?  La forma m√°s f√°cil de establecer el tama√±o de los snappants es determinar el porcentaje de espacio libre en el volumen (como se hizo para VSS).  Para un volumen de 20 TB, el 10% ser√° de 2 TB, que es mucho para un servidor descargado.  Para un volumen de 200 GB, el 10% es 20 GB, lo que puede ser muy poco para un servidor que est√° actualizando sus datos de manera intensiva.  Y todav√≠a hay vol√∫menes delgados ... <br><br>  En general, solo el administrador del sistema del servidor puede determinar el tama√±o √≥ptimo del complemento requerido por adelantado, es decir, debe hacer que la persona piense y dar su opini√≥n experta.  Esto no cumple con el principio de "Simplemente funciona". <br><br>  Para resolver este problema, desarrollamos el algoritmo de instant√°nea de estiramiento.  La idea es dividir el complemento en porciones.  Al mismo tiempo, se crean nuevas porciones despu√©s de la creaci√≥n de una instant√°nea seg√∫n sea necesario. <br><br><img src="https://habrastorage.org/webt/7l/wi/72/7lwi72wjiwrmq9-jms-tartz6go.png"><br><br>  Nuevamente, brevemente el algoritmo: <br><br><ol><li>  Antes de crear una instant√°nea, la primera parte de la instant√°nea se crea y se entrega al m√≥dulo. </li><li>  Cuando se crea la instant√°nea, la porci√≥n comenzar√° a llenarse. </li><li>  Tan pronto como la mitad de la porci√≥n est√© llena, se env√≠a una solicitud al servicio para crear una nueva. </li><li>  El servicio lo crea, entrega los datos al m√≥dulo. </li><li>  El m√≥dulo comienza a llenar el siguiente lote. </li><li>  El algoritmo se repite hasta que se complete la copia de seguridad o hasta que alcancemos el l√≠mite en el uso de espacio libre en disco. </li></ol><br>  Es importante tener en cuenta que el m√≥dulo debe tener tiempo para crear nuevas porciones de snapposts seg√∫n sea necesario; de lo contrario, desbordamiento, reinicio de instant√°neas y sin respaldo.  Por lo tanto, la operaci√≥n de dicho algoritmo solo es posible en sistemas de archivos con soporte de Falcocate, donde puede crear r√°pidamente un archivo vac√≠o. <br><br>  ¬øQu√© hacer en otros casos?  Estamos tratando de adivinar el tama√±o requerido y crear todo el snappast completo.  Pero seg√∫n nuestras estad√≠sticas, la gran mayor√≠a de los servidores Linux ahora usan EXT4 y XFS.  EXT3 se encuentra en m√°quinas m√°s antiguas.  Pero en SLES / openSUSE puede tropezar con BTRFS. <br><br><h3>  Cambiar seguimiento de bloque (CBT) </h3><br>  Copia de seguridad incremental o diferencial (por cierto, el r√°bano picante de r√°bano picante es m√°s dulce o no, sugiero leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ); sin √©l, no puede imaginar ning√∫n producto de copia de seguridad para adultos.  Y para que esto funcione, necesita CBT.  Si alguien se perdi√≥: CBT le permite realizar un seguimiento de los cambios y escribir en la copia de seguridad solo los datos modificados desde la √∫ltima copia de seguridad. <br><br><img src="https://habrastorage.org/webt/fk/mf/z0/fkmfz0-pa9lbjdktlu2yovstkuk.png"><br><br>  Muchos tienen su propia experiencia en esta √°rea.  Por ejemplo, en VMware vSphere, esta caracter√≠stica ha estado disponible desde la versi√≥n 4 en 2009.  En Hyper-V, se introdujo la compatibilidad con Windows Server 2016, y para admitir versiones anteriores, su propio controlador VeeamFCT se desarroll√≥ en 2012.  Por lo tanto, para nuestro m√≥dulo no nos convertimos en originales y utilizamos algoritmos que ya funcionan. <br>  Sobre c√≥mo funciona. <br><br><img src="https://habrastorage.org/webt/hs/fn/vj/hsfnvjyzfywjynwynlh9jkibaug.png"><br><br>  Todo el volumen rastreado se divide en bloques.  El m√≥dulo simplemente realiza un seguimiento de todas las solicitudes de escritura, marcando los bloques modificados en la tabla.  De hecho, la tabla CBT es una matriz de bytes, donde cada byte corresponde a un bloque y contiene el n√∫mero de la instant√°nea en la que se modific√≥. <br>  Durante la copia de seguridad, el n√∫mero de instant√°nea se registra en los metadatos de la copia de seguridad.  Por lo tanto, conociendo los n√∫meros de la instant√°nea actual y de la que se realiz√≥ la copia de seguridad exitosa anterior, puede calcular el mapa de la ubicaci√≥n de los bloques modificados. <br><br>  Hay dos matices. <br><br>  Como dije, se asigna un byte para el n√∫mero de instant√°nea en la tabla CBT, lo que significa que la longitud m√°xima de la cadena incremental no puede ser superior a 255. Cuando se alcanza este umbral, la tabla se restablece y se produce una copia de seguridad completa.  Puede parecer inconveniente, pero de hecho, una cadena de 255 incrementos est√° lejos de ser la mejor soluci√≥n al crear un plan de respaldo. <br>  La segunda caracter√≠stica es el almacenamiento de la tabla CBT solo en RAM.  Por lo tanto, cuando reinicie la m√°quina de destino o descargue el m√≥dulo, se reiniciar√° y, de nuevo, deber√° crear una copia de seguridad completa.  Tal soluci√≥n permite no resolver el problema del inicio del m√≥dulo al inicio del sistema.  Adem√°s, no es necesario guardar las tablas CBT cuando apaga el sistema. <br><br><h3>  Problema de rendimiento </h3><br>  La copia de seguridad siempre es una buena carga para el IO de su equipo.  Si ya hay suficientes tareas activas, el proceso de copia de seguridad puede convertir su sistema en una especie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pereza</a> . <br>  A ver por qu√©. <br><br>  Imagine que el servidor simplemente escribe linealmente algunos datos.  La velocidad de grabaci√≥n en este caso es m√°xima, todos los retrasos se minimizan, el rendimiento tiende al m√°ximo.  Ahora agregamos el proceso de copia de seguridad aqu√≠, que en cada escritura a√∫n necesita completar el algoritmo de Copia en escritura, y esta es una operaci√≥n de lectura adicional con escritura posterior.  Y no olvide que para la copia de seguridad a√∫n necesita leer datos del mismo volumen.  En una palabra, su hermoso acceso lineal se convierte en un acceso aleatorio despiadado con todas las consecuencias. <br><br>  Obviamente, tenemos que hacer algo con esto, e implementamos una canalizaci√≥n para procesar las solicitudes, no una a la vez, sino en paquetes completos.  Funciona asi. <br><br><img src="https://habrastorage.org/webt/br/js/pz/brjspz1fvl7yjtk_hqc_hyupb1a.png"><br><br>  Al interceptar solicitudes, se colocan en una cola, donde una secuencia especial los toma en porciones.  En este momento, se crean solicitudes CoW, que tambi√©n se procesan en lotes.  Cuando se procesan solicitudes CoW, primero se realizan todas las operaciones de lectura para toda la porci√≥n, luego de lo cual se realizan las operaciones de escritura.  Solo despu√©s de que se complete el procesamiento de toda la parte de las solicitudes de CoW, se ejecutan las solicitudes interceptadas.  Tal transportador proporciona acceso al disco en grandes porciones de datos, lo que minimiza las p√©rdidas de tiempo. <br><br><h3>  Estrangulamiento </h3><br>  Ya en la etapa de depuraci√≥n, surgi√≥ otro matiz.  Durante la copia de seguridad, el sistema dej√≥ de responder, es decir  Las solicitudes de E / S del sistema comenzaron a ejecutarse con largas demoras.  Pero, las solicitudes de lectura de datos de una instant√°nea se realizaron a una velocidad cercana al m√°ximo. <br>  Tuve que estrangular un poco el proceso de copia de seguridad implementando el mecanismo de aceleraci√≥n.  Para hacer esto, el proceso de lectura de la imagen de la instant√°nea se pone en estado de espera si la cola de solicitudes interceptadas no est√° vac√≠a.  Como era de esperar, el sistema cobr√≥ vida. <br><br><img src="https://habrastorage.org/webt/6c/f1/cj/6cf1cjerzumb96qaeslvikyobpo.png"><br><br>  Como resultado, si la carga en el sistema de E / S aumenta bruscamente, el proceso de lectura de la instant√°nea esperar√°.  Aqu√≠ decidimos guiarnos por el principio de que es mejor finalizar la copia de seguridad con un error que interrumpir el servidor. <br><br><h3>  Punto muerto </h3><br>  Creo que debemos explicar con m√°s detalle de qu√© se trata. <br><br>  Ya en la etapa de prueba, comenzamos a encontrar situaciones de un bloqueo total del sistema con un diagn√≥stico de siete problemas: un reinicio. <br><br>  Ellos comenzaron a entender.  Result√≥ que esta situaci√≥n se puede observar si, por ejemplo, crea una instant√°nea del dispositivo de bloque en el que se encuentra el volumen LVM y coloca la instant√°nea en el mismo volumen LVM.  Perm√≠tame recordarle que LVM usa el m√≥dulo del kernel del mapeador de dispositivos. <br><br><img src="https://habrastorage.org/webt/xs/n7/ac/xsn7ac1peh0sefyanlbk_2yrvb8.png"><br><br>  En esta situaci√≥n, al interceptar una solicitud de escritura, el m√≥dulo, copiando los datos en el complemento, enviar√° la solicitud de escritura al volumen LVM.  El mapeador de dispositivos redirigir√° esta solicitud al dispositivo de bloque.  Una solicitud del mapeador de dispositivos ser√° nuevamente interceptada por el m√≥dulo.  Pero una nueva solicitud no se puede procesar hasta que se haya procesado la anterior.  Como resultado, el procesamiento de la solicitud est√° bloqueado, el punto muerto lo recibe. <br><br>  Para evitar esta situaci√≥n, el m√≥dulo del kernel proporciona un tiempo de espera para la operaci√≥n de copiar datos en el complemento.  Esto le permite detectar el punto muerto y la copia de seguridad de bloqueo.  La l√≥gica aqu√≠ es la misma: es mejor no hacer una copia de seguridad que suspender el servidor. <br><br><h3>  Base de datos Round Robin </h3><br>  Esto ya es un problema lanzado por los usuarios despu√©s del lanzamiento de la primera versi√≥n. <br>  Result√≥ que existen tales servicios que solo se dedican a sobrescribir constantemente los mismos bloques.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo sorprendente son los servicios de monitoreo, que constantemente generan datos sobre el estado del sistema y los sobrescriben en un c√≠rculo. </font><font style="vertical-align: inherit;">Para tales tareas, use bases de datos c√≠clicas especializadas ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result√≥ que con una copia de seguridad de tales bases se garantiza que la instant√°nea se desborde. </font><font style="vertical-align: inherit;">En un estudio detallado del problema, encontramos una falla en la implementaci√≥n del algoritmo CoW. </font><font style="vertical-align: inherit;">Si se sobrescribi√≥ el mismo bloque, los datos se copiaron en el complemento cada vez. </font><font style="vertical-align: inherit;">Resultado: duplicaci√≥n de datos en el complemento. </font></font><br><br><img src="https://habrastorage.org/webt/tk/vf/ox/tkvfox_gygmf4gxh0cz_igw_jzw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturalmente, cambiamos el algoritmo. </font><font style="vertical-align: inherit;">Ahora el volumen se divide en bloques y los datos se copian en el bloque de ajuste. </font><font style="vertical-align: inherit;">Si el bloque ya se ha copiado una vez, este proceso no se repite.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selecci√≥n de tama√±o de bloque </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando el snapstrap se divide en bloques, surge la pregunta: ¬øcu√°l es, de hecho, el tama√±o de los bloques para dividir las snappastes? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema es doble. Si el bloque se hace grande, es m√°s f√°cil para ellos operar, pero si al menos un sector cambia, debe enviar todo el bloque a la plataforma y, como resultado, aumentan las posibilidades de sobrellenar la plataforma. </font></font><br><br><img src="https://habrastorage.org/webt/dk/fy/a_/dkfya_bevzkd5mx10_pnkbxbajm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, cuanto menor sea el tama√±o del bloque, mayor ser√° el porcentaje de datos √∫tiles enviados al almac√©n de instant√°neas, pero ¬øc√≥mo afectar√° el rendimiento? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buscaron la verdad emp√≠ricamente y obtuvieron 16KiB. Tambi√©n tenga en cuenta que Windows VSS tambi√©n utiliza 16 bloques KiB.</font></font><br><br><h2>  En lugar de una conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso es todo por ahora. </font><font style="vertical-align: inherit;">Dejar√© muchos otros problemas, no menos interesantes, como la dependencia de las versiones del kernel, la elecci√≥n de las opciones de distribuci√≥n del m√≥dulo, la compatibilidad de kABI, el trabajo en condiciones de backport, etc. </font><font style="vertical-align: inherit;">El art√≠culo result√≥ ser voluminoso, as√≠ que decid√≠ detenerme en los problemas m√°s interesantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora nos estamos preparando para la versi√≥n de lanzamiento 3.0, el c√≥digo del m√≥dulo est√° en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y cualquiera puede usarlo bajo la licencia GPL.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430770/">https://habr.com/ru/post/es430770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430754/index.html">Agregue profundidad a sprites 2D utilizando mapas normales dibujados a mano</a></li>
<li><a href="../es430756/index.html">Hacer el WX-Mouse en el Nova Slider 600</a></li>
<li><a href="../es430762/index.html">C√≥mo elegir un UPS para optimizar costos</a></li>
<li><a href="../es430766/index.html">Se trata de Agile 1: mitos de la agenda popular</a></li>
<li><a href="../es430768/index.html">Entrevista con el creador de ADOM Thomas Biscap</a></li>
<li><a href="../es430774/index.html">¬øEst√°s listo para la IA en las vallas publicitarias?</a></li>
<li><a href="../es430776/index.html">Hacer una IP es la √∫nica forma</a></li>
<li><a href="../es430778/index.html">Proceso de dise√±o de sistema el√©ctrico de extremo a extremo de 3DEXPERIENCE</a></li>
<li><a href="../es430780/index.html">Secuencia a secuencia Modelos de la Parte 1</a></li>
<li><a href="../es430782/index.html">¬øCu√°ntos programadores necesitas para soportar c√≥digo escrito previamente?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>