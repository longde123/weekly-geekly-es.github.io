<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèæ ü§õüèæ üóëÔ∏è SSEGWSW: Server-Sent Events Gateway von Service Workern üî£ ‚§¥Ô∏è üê≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! 

 Mein Name ist Sasha und ich arbeite als Architekt bei Tinkoff Business. 

 In diesem Artikel m√∂chte ich dar√ºber sprechen, wie Sie das Browse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SSEGWSW: Server-Sent Events Gateway von Service Workern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/471718/">  Hallo! <br><br>  Mein Name ist Sasha und ich arbeite als Architekt bei Tinkoff Business. <br><br>  In diesem Artikel m√∂chte ich dar√ºber sprechen, wie Sie das Browser-Limit f√ºr die Anzahl offener, langlebiger HTTP-Verbindungen innerhalb derselben Dom√§ne mithilfe von Service Worker √ºberwinden k√∂nnen. <br><br>  Wenn Sie m√∂chten, k√∂nnen Sie den Hintergrund und die Beschreibung des Problems √ºberspringen, nach einer L√∂sung suchen und sofort mit dem Ergebnis fortfahren. <br><br><img src="https://habrastorage.org/webt/y0/bo/yc/y0boycn5hjiaplzub_5g7rviwpu.png" alt="SSEGWSW"><br><a name="habracut"></a><br><h3>  Hintergrund </h3><br>  Es war einmal bei Tinkoff Business ein Chat, der auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Websocket funktionierte</a> . <br><br>  Nach einiger Zeit passte er nicht mehr in die Gestaltung seines pers√∂nlichen Kontos und bat im Allgemeinen lange um eine Neufassung von Winkel 1,6 auf Winkel 2+.  Ich entschied, dass es Zeit war, mit der Aktualisierung zu beginnen.  Ein Kollege-Backender fand heraus, dass sich das Chat-Frontend √§ndern wird, und schlug gleichzeitig vor, insbesondere die API zu wiederholen - den Transport von Websocket zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSE zu</a> √§ndern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(vom Server gesendete Ereignisse)</a> .  Er schlug dies vor, da beim Aktualisieren der NGINX-Konfiguration alle Verbindungen unterbrochen wurden, was dann schmerzhaft wiederherzustellen war. <br><br>  Wir haben die Architektur der neuen L√∂sung besprochen und sind zu dem Schluss gekommen, dass wir Daten √ºber regul√§re HTTP-Anforderungen empfangen und senden werden.  Senden Sie beispielsweise eine <i>POST: / api / send-message-Nachricht</i> , rufen Sie eine Liste der <i>GET-</i> Dialoge ab <i>: / api / gespr√§chsliste</i> usw.  Und asynchrone Ereignisse wie "eine neue Nachricht vom Gespr√§chspartner" werden √ºber SSE gesendet.  Daher erh√∂hen wir die Fehlertoleranz der Anwendung: Wenn die SSE-Verbindung unterbrochen wird, funktioniert der Chat weiterhin, nur werden keine Echtzeitbenachrichtigungen empfangen. <br><br>  Zus√§tzlich zum Chat im Websocket haben wir Ereignisse f√ºr die Komponente "Thin Notifications" verfolgt.  Mit dieser Komponente k√∂nnen Sie verschiedene Benachrichtigungen an das pers√∂nliche Konto des Benutzers senden, z. B. dass der Import von Konten, der einige Minuten dauern kann, erfolgreich abgeschlossen wurde.  Um den Websocket vollst√§ndig aufzugeben, haben wir diese Komponente in eine separate SSE-Verbindung verschoben. <br><br><h3>  Das Problem </h3><br>  Wenn Sie eine Browser-Registerkarte √∂ffnen, werden zwei SSE-Verbindungen erstellt: eine f√ºr den Chat und eine f√ºr subtile Benachrichtigungen.  Nun, lass sie erschaffen werden.  Entschuldigung oder was?  Es tut uns nicht leid, aber Browser tun uns leid!  Sie haben eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Begrenzung f√ºr die Anzahl gleichzeitiger persistenter Verbindungen f√ºr eine Dom√§ne</a> .  Ratet mal, wie viel in Chrome ist?  Richtig, sechs!  Ich habe drei Registerkarten ge√∂ffnet. Ich habe den gesamten Verbindungspool bewertet und Sie k√∂nnen keine HTTP-Anforderungen mehr stellen.  Dies gilt f√ºr das HTTP / 1.x-Protokoll.  In HTTP / 2 gibt es kein solches Problem aufgrund von Multiplexing. <br><br>  Es gibt verschiedene M√∂glichkeiten, um dieses Problem auf Infrastrukturebene zu l√∂sen: <br><br><ol><li>  <a href="">Domain-Sharding.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://developers.google.com/web/fundamentals/performance/">HTTP / 2.</a> </li></ol><br>  Beide Methoden schienen teuer zu sein, da viele Infrastrukturen betroffen sein m√ºssten. <br><br>  Daher haben wir zun√§chst versucht, das Problem auf der Browserseite zu l√∂sen.  Die erste Idee war, eine Art Transport zwischen den Registerkarten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchzuf√ºhren</a> , beispielsweise √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LocalStorage-</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broadcast Channel-API</a> . <br><br>  Die Bedeutung ist folgende: Wir √∂ffnen SSE-Verbindungen in nur einer Registerkarte und senden die Daten an den Rest.  Diese L√∂sung sah auch nicht optimal aus, da alle 50 SPA, aus denen das pers√∂nliche Konto von Tinkoff Business besteht, freigegeben werden m√ºssten.  Die Ver√∂ffentlichung von 50 Anwendungen ist ebenfalls teuer, daher habe ich weiter nach anderen M√∂glichkeiten gesucht. <br><br><h3>  L√∂sung </h3><br>  Ich habe k√ºrzlich mit Servicemitarbeitern gearbeitet und dachte: Ist es m√∂glich, sie in dieser Situation anzuwenden? <br><br>  Um diese Frage zu beantworten, m√ºssen Sie zun√§chst verstehen, was Servicemitarbeiter im Allgemeinen tun.  Sie k√∂nnen Anfragen per Proxy stellen, es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = self.caches.open(<span class="hljs-string"><span class="hljs-string">'example'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caches</span></span></span><span class="hljs-function"> =&gt;</span></span> caches.match(event.request)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response || fetch(event.request)); event.respondWith(response); });</code> </pre> <br>  Wir h√∂ren Ereignisse f√ºr HTTP-Anfragen ab und antworten, wie wir m√∂chten.  In diesem Fall versuchen wir, aus dem Cache zu antworten. Wenn dies nicht funktioniert, senden wir eine Anfrage an den Server. <br><br>  Ok, versuchen wir, die SSE-Verbindung abzufangen und zu beantworten: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } event.respondWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>)); });</code> </pre><br>  In Netzwerkanfragen sehen wir das folgende Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/101/629/3b8/1016293b8b2996a1a3e53478b69eaff6.png" alt="Bild"><br><br>  Und in der Konsole: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/22e/b05/1d322eb0533cf21a456790c4d9bef519.png" alt="Bild"><br><br>  Schon nicht schlecht.  Die Anfrage wurde abgefangen, aber die SSE m√∂chte keine Antwort in Form von <i>Text / Plain</i> , sondern <i>Text / Event-Stream</i> .  Wie erstelle ich jetzt einen Stream?  Aber kann ich √ºberhaupt mit einem Stream von einem Servicemitarbeiter antworten?  Na mal sehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/c87/efd/ab8c87efd887d4693c2d6d9cddd986ee.png" alt="Bild"><br><br>  Gro√üartig!  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Response-</a> Klasse nimmt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Text ReadableStream</a> .  Nachdem Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> gelesen haben, k√∂nnen Sie feststellen, dass <i>ReadableStream</i> √ºber einen Controller mit einer <i>enqueue ()</i> -Methode verf√ºgt. Mithilfe dieser Funktion k√∂nnen Sie Daten streamen.  Passend, nimm es! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/35b/6a3/40b35b6a369d02e804e34c2179c0f273.png" alt="Bild"><br><br>  Es liegt kein Fehler vor, die Verbindung bleibt im Status "Ausstehend" und es kommen keine Daten auf der Clientseite an.  Beim Vergleich meiner Anfrage mit einer echten Serveranfrage wurde mir klar, dass sich die Antwort in den Headern befand.  F√ºr SSE-Anforderungen m√ºssen die folgenden Header angegeben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, };</code> </pre><br>  Wenn Sie diese Header hinzuf√ºgen, wird die Verbindung erfolgreich ge√∂ffnet, die Daten werden jedoch nicht auf der Clientseite empfangen.  Dies ist offensichtlich, da Sie nicht nur zuf√§lligen Text senden k√∂nnen - es muss ein Format vorhanden sein. <br><br>  In javascript.info ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Datenformat gut beschrieben,</a> in dem Daten vom Server gesendet werden m√ºssen.  Es kann leicht mit einer Funktion beschrieben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data: string, event?: string, retry?: number, id?: number</span></span></span><span class="hljs-function">): </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>;</code> </pre><br>  Um dem SSE-Format zu entsprechen, muss der Server Nachrichten senden, die durch einen doppelten Zeilenumbruch getrennt sind <i>\ n \ n</i> . <br><br>  Die Nachricht besteht aus folgenden Feldern: <br><br><ul><li>  <b>Daten</b> - Nachrichtentext, mehrere Daten in einer Zeile werden als eine Nachricht interpretiert, getrennt durch Zeilenumbr√ºche \ n; </li><li>  <b>id</b> - Aktualisiert die lastEventId-Eigenschaft, die beim erneuten Herstellen der Verbindung im Last-Event-ID-Header gesendet wird. </li><li>  <b>Wiederholen</b> - Die empfohlene Verz√∂gerung vor dem erneuten <b>Herstellen</b> der Verbindung in Millisekunden kann nicht mit JavaScript festgelegt werden. </li><li>  <b>Ereignis</b> - Der Name des Benutzerereignisses, der vor den Daten angegeben wird. </li></ul><br>  F√ºgen Sie die erforderlichen √úberschriften hinzu, √§ndern Sie die Antwort in das gew√ºnschte Format und sehen Sie, was passiert: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, event, retry, id</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = sseChunkData(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream, {<span class="hljs-attr"><span class="hljs-attr">headers</span></span>: sseHeaders}); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/216/ecb/010/216ecb0104e296f91267f3d18ab21ff0.png" alt="Bild"><br><br>  Oh mein Globus!  Ja, ich habe eine SSE-Verbindung ohne Server hergestellt! <br><br><h3>  Ergebnis </h3><br>  Jetzt k√∂nnen wir die SSE-Anfrage erfolgreich abfangen und darauf antworten, ohne √ºber den Browser hinauszugehen. <br><br>  Urspr√ºnglich bestand die Idee darin, eine Verbindung zum Server herzustellen, aber nur eines - und daraus Daten an Registerkarten zu senden.  Lass es uns tun! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers, url} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   SSE- if (!isSSERequest) { return; } //    SSE const sseHeaders = { 'content-type': 'text/event-stream', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', }; // ,    SSE const sseChunkData = (data, event, retry, id) =&gt; Object.entries({event, id, data, retry}) .filter(([, value]) =&gt; ![undefined, null].includes(value)) .map(([key, value]) =&gt; `${key}: ${value}`) .join('\n') + '\n\n'; //    ,   ‚Äî url,  ‚Äî EventSource const serverConnections = {}; //   url             const getServerConnection = url =&gt; { if (!serverConnections[url]) serverConnections[url] = new EventSource(url); return serverConnections[url]; }; //          const onServerMessage = (controller, {data, type, retry, lastEventId}) =&gt; { const responseText = sseChunkData(data, type, retry, lastEventId); const responseData = Uint8Array.from(responseText, x =&gt; x.charCodeAt(0)); controller.enqueue(responseData); }; const stream = new ReadableStream({ start: controller =&gt; getServerConnection(url).onmessage = onServerMessage.bind(null, controller) }); const response = new Response(stream, {headers: sseHeaders}); event.respondWith(response); });</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der gleiche Code auf Github.</a> <br>  Ich habe eine ziemlich einfache L√∂sung f√ºr eine nicht so triviale Aufgabe.  Aber nat√ºrlich gibt es noch viele Nuancen.  Beispielsweise m√ºssen Sie die Verbindung zum Server schlie√üen, wenn Sie alle Registerkarten schlie√üen, das SSE-Protokoll vollst√§ndig unterst√ºtzen usw. <br><br>  Wir haben das alles erfolgreich entschieden - ich bin sicher, es wird nicht schwierig f√ºr Sie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471718/">https://habr.com/ru/post/de471718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471704/index.html">Das Buch ‚ÄûEgoistische Mitochondrien. Wie man die Gesundheit erh√§lt und das Alter bewegt "</a></li>
<li><a href="../de471706/index.html">9 typische Netzwerkprobleme, die mithilfe der NetFlow-Analyse erkannt werden k√∂nnen (am Beispiel Flowmon)</a></li>
<li><a href="../de471708/index.html">Storypoints sind gef√§hrlich f√ºr die Entwicklung von Client-Server-Anwendungen</a></li>
<li><a href="../de471712/index.html">Erstellen einer mobilen Chat-Anwendung in React Native</a></li>
<li><a href="../de471716/index.html">Technologieausstellung GITEX 2019 - wie es war</a></li>
<li><a href="../de471722/index.html">Wie ein 17-j√§hriger Mann einen Arcade-Hit aus den 80ern auf Computer portierte</a></li>
<li><a href="../de471724/index.html">Agile und Gehirnbed√ºrfnisse: Stressmanagement</a></li>
<li><a href="../de471726/index.html">Moderne Methode zur Messung der Impulsantwort und der nichtlinearen Verzerrung</a></li>
<li><a href="../de471728/index.html">Avalonia meine Vor- und Nachteile</a></li>
<li><a href="../de471736/index.html">Ber√ºhrungsloser Ethernet-Sensor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>