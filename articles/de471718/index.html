<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏾 🤛🏾 🗑️ SSEGWSW: Server-Sent Events Gateway von Service Workern 🔣 ⤴️ 🐳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! 

 Mein Name ist Sasha und ich arbeite als Architekt bei Tinkoff Business. 

 In diesem Artikel möchte ich darüber sprechen, wie Sie das Browse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SSEGWSW: Server-Sent Events Gateway von Service Workern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/471718/">  Hallo! <br><br>  Mein Name ist Sasha und ich arbeite als Architekt bei Tinkoff Business. <br><br>  In diesem Artikel möchte ich darüber sprechen, wie Sie das Browser-Limit für die Anzahl offener, langlebiger HTTP-Verbindungen innerhalb derselben Domäne mithilfe von Service Worker überwinden können. <br><br>  Wenn Sie möchten, können Sie den Hintergrund und die Beschreibung des Problems überspringen, nach einer Lösung suchen und sofort mit dem Ergebnis fortfahren. <br><br><img src="https://habrastorage.org/webt/y0/bo/yc/y0boycn5hjiaplzub_5g7rviwpu.png" alt="SSEGWSW"><br><a name="habracut"></a><br><h3>  Hintergrund </h3><br>  Es war einmal bei Tinkoff Business ein Chat, der auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Websocket funktionierte</a> . <br><br>  Nach einiger Zeit passte er nicht mehr in die Gestaltung seines persönlichen Kontos und bat im Allgemeinen lange um eine Neufassung von Winkel 1,6 auf Winkel 2+.  Ich entschied, dass es Zeit war, mit der Aktualisierung zu beginnen.  Ein Kollege-Backender fand heraus, dass sich das Chat-Frontend ändern wird, und schlug gleichzeitig vor, insbesondere die API zu wiederholen - den Transport von Websocket zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSE zu</a> ändern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(vom Server gesendete Ereignisse)</a> .  Er schlug dies vor, da beim Aktualisieren der NGINX-Konfiguration alle Verbindungen unterbrochen wurden, was dann schmerzhaft wiederherzustellen war. <br><br>  Wir haben die Architektur der neuen Lösung besprochen und sind zu dem Schluss gekommen, dass wir Daten über reguläre HTTP-Anforderungen empfangen und senden werden.  Senden Sie beispielsweise eine <i>POST: / api / send-message-Nachricht</i> , rufen Sie eine Liste der <i>GET-</i> Dialoge ab <i>: / api / gesprächsliste</i> usw.  Und asynchrone Ereignisse wie "eine neue Nachricht vom Gesprächspartner" werden über SSE gesendet.  Daher erhöhen wir die Fehlertoleranz der Anwendung: Wenn die SSE-Verbindung unterbrochen wird, funktioniert der Chat weiterhin, nur werden keine Echtzeitbenachrichtigungen empfangen. <br><br>  Zusätzlich zum Chat im Websocket haben wir Ereignisse für die Komponente "Thin Notifications" verfolgt.  Mit dieser Komponente können Sie verschiedene Benachrichtigungen an das persönliche Konto des Benutzers senden, z. B. dass der Import von Konten, der einige Minuten dauern kann, erfolgreich abgeschlossen wurde.  Um den Websocket vollständig aufzugeben, haben wir diese Komponente in eine separate SSE-Verbindung verschoben. <br><br><h3>  Das Problem </h3><br>  Wenn Sie eine Browser-Registerkarte öffnen, werden zwei SSE-Verbindungen erstellt: eine für den Chat und eine für subtile Benachrichtigungen.  Nun, lass sie erschaffen werden.  Entschuldigung oder was?  Es tut uns nicht leid, aber Browser tun uns leid!  Sie haben eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Begrenzung für die Anzahl gleichzeitiger persistenter Verbindungen für eine Domäne</a> .  Ratet mal, wie viel in Chrome ist?  Richtig, sechs!  Ich habe drei Registerkarten geöffnet. Ich habe den gesamten Verbindungspool bewertet und Sie können keine HTTP-Anforderungen mehr stellen.  Dies gilt für das HTTP / 1.x-Protokoll.  In HTTP / 2 gibt es kein solches Problem aufgrund von Multiplexing. <br><br>  Es gibt verschiedene Möglichkeiten, um dieses Problem auf Infrastrukturebene zu lösen: <br><br><ol><li>  <a href="">Domain-Sharding.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://developers.google.com/web/fundamentals/performance/">HTTP / 2.</a> </li></ol><br>  Beide Methoden schienen teuer zu sein, da viele Infrastrukturen betroffen sein müssten. <br><br>  Daher haben wir zunächst versucht, das Problem auf der Browserseite zu lösen.  Die erste Idee war, eine Art Transport zwischen den Registerkarten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchzuführen</a> , beispielsweise über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LocalStorage-</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broadcast Channel-API</a> . <br><br>  Die Bedeutung ist folgende: Wir öffnen SSE-Verbindungen in nur einer Registerkarte und senden die Daten an den Rest.  Diese Lösung sah auch nicht optimal aus, da alle 50 SPA, aus denen das persönliche Konto von Tinkoff Business besteht, freigegeben werden müssten.  Die Veröffentlichung von 50 Anwendungen ist ebenfalls teuer, daher habe ich weiter nach anderen Möglichkeiten gesucht. <br><br><h3>  Lösung </h3><br>  Ich habe kürzlich mit Servicemitarbeitern gearbeitet und dachte: Ist es möglich, sie in dieser Situation anzuwenden? <br><br>  Um diese Frage zu beantworten, müssen Sie zunächst verstehen, was Servicemitarbeiter im Allgemeinen tun.  Sie können Anfragen per Proxy stellen, es sieht ungefähr so ​​aus: <br><br><pre><code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = self.caches.open(<span class="hljs-string"><span class="hljs-string">'example'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caches</span></span></span><span class="hljs-function"> =&gt;</span></span> caches.match(event.request)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response || fetch(event.request)); event.respondWith(response); });</code> </pre> <br>  Wir hören Ereignisse für HTTP-Anfragen ab und antworten, wie wir möchten.  In diesem Fall versuchen wir, aus dem Cache zu antworten. Wenn dies nicht funktioniert, senden wir eine Anfrage an den Server. <br><br>  Ok, versuchen wir, die SSE-Verbindung abzufangen und zu beantworten: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } event.respondWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>)); });</code> </pre><br>  In Netzwerkanfragen sehen wir das folgende Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/101/629/3b8/1016293b8b2996a1a3e53478b69eaff6.png" alt="Bild"><br><br>  Und in der Konsole: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/22e/b05/1d322eb0533cf21a456790c4d9bef519.png" alt="Bild"><br><br>  Schon nicht schlecht.  Die Anfrage wurde abgefangen, aber die SSE möchte keine Antwort in Form von <i>Text / Plain</i> , sondern <i>Text / Event-Stream</i> .  Wie erstelle ich jetzt einen Stream?  Aber kann ich überhaupt mit einem Stream von einem Servicemitarbeiter antworten?  Na mal sehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/c87/efd/ab8c87efd887d4693c2d6d9cddd986ee.png" alt="Bild"><br><br>  Großartig!  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Response-</a> Klasse nimmt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Text ReadableStream</a> .  Nachdem Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> gelesen haben, können Sie feststellen, dass <i>ReadableStream</i> über einen Controller mit einer <i>enqueue ()</i> -Methode verfügt. Mithilfe dieser Funktion können Sie Daten streamen.  Passend, nimm es! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/35b/6a3/40b35b6a369d02e804e34c2179c0f273.png" alt="Bild"><br><br>  Es liegt kein Fehler vor, die Verbindung bleibt im Status "Ausstehend" und es kommen keine Daten auf der Clientseite an.  Beim Vergleich meiner Anfrage mit einer echten Serveranfrage wurde mir klar, dass sich die Antwort in den Headern befand.  Für SSE-Anforderungen müssen die folgenden Header angegeben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, };</code> </pre><br>  Wenn Sie diese Header hinzufügen, wird die Verbindung erfolgreich geöffnet, die Daten werden jedoch nicht auf der Clientseite empfangen.  Dies ist offensichtlich, da Sie nicht nur zufälligen Text senden können - es muss ein Format vorhanden sein. <br><br>  In javascript.info ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Datenformat gut beschrieben,</a> in dem Daten vom Server gesendet werden müssen.  Es kann leicht mit einer Funktion beschrieben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data: string, event?: string, retry?: number, id?: number</span></span></span><span class="hljs-function">): </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>;</code> </pre><br>  Um dem SSE-Format zu entsprechen, muss der Server Nachrichten senden, die durch einen doppelten Zeilenumbruch getrennt sind <i>\ n \ n</i> . <br><br>  Die Nachricht besteht aus folgenden Feldern: <br><br><ul><li>  <b>Daten</b> - Nachrichtentext, mehrere Daten in einer Zeile werden als eine Nachricht interpretiert, getrennt durch Zeilenumbrüche \ n; </li><li>  <b>id</b> - Aktualisiert die lastEventId-Eigenschaft, die beim erneuten Herstellen der Verbindung im Last-Event-ID-Header gesendet wird. </li><li>  <b>Wiederholen</b> - Die empfohlene Verzögerung vor dem erneuten <b>Herstellen</b> der Verbindung in Millisekunden kann nicht mit JavaScript festgelegt werden. </li><li>  <b>Ereignis</b> - Der Name des Benutzerereignisses, der vor den Daten angegeben wird. </li></ul><br>  Fügen Sie die erforderlichen Überschriften hinzu, ändern Sie die Antwort in das gewünschte Format und sehen Sie, was passiert: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, event, retry, id</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = sseChunkData(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream, {<span class="hljs-attr"><span class="hljs-attr">headers</span></span>: sseHeaders}); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/216/ecb/010/216ecb0104e296f91267f3d18ab21ff0.png" alt="Bild"><br><br>  Oh mein Globus!  Ja, ich habe eine SSE-Verbindung ohne Server hergestellt! <br><br><h3>  Ergebnis </h3><br>  Jetzt können wir die SSE-Anfrage erfolgreich abfangen und darauf antworten, ohne über den Browser hinauszugehen. <br><br>  Ursprünglich bestand die Idee darin, eine Verbindung zum Server herzustellen, aber nur eines - und daraus Daten an Registerkarten zu senden.  Lass es uns tun! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers, url} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   SSE- if (!isSSERequest) { return; } //    SSE const sseHeaders = { 'content-type': 'text/event-stream', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', }; // ,    SSE const sseChunkData = (data, event, retry, id) =&gt; Object.entries({event, id, data, retry}) .filter(([, value]) =&gt; ![undefined, null].includes(value)) .map(([key, value]) =&gt; `${key}: ${value}`) .join('\n') + '\n\n'; //    ,   — url,  — EventSource const serverConnections = {}; //   url             const getServerConnection = url =&gt; { if (!serverConnections[url]) serverConnections[url] = new EventSource(url); return serverConnections[url]; }; //          const onServerMessage = (controller, {data, type, retry, lastEventId}) =&gt; { const responseText = sseChunkData(data, type, retry, lastEventId); const responseData = Uint8Array.from(responseText, x =&gt; x.charCodeAt(0)); controller.enqueue(responseData); }; const stream = new ReadableStream({ start: controller =&gt; getServerConnection(url).onmessage = onServerMessage.bind(null, controller) }); const response = new Response(stream, {headers: sseHeaders}); event.respondWith(response); });</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der gleiche Code auf Github.</a> <br>  Ich habe eine ziemlich einfache Lösung für eine nicht so triviale Aufgabe.  Aber natürlich gibt es noch viele Nuancen.  Beispielsweise müssen Sie die Verbindung zum Server schließen, wenn Sie alle Registerkarten schließen, das SSE-Protokoll vollständig unterstützen usw. <br><br>  Wir haben das alles erfolgreich entschieden - ich bin sicher, es wird nicht schwierig für Sie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471718/">https://habr.com/ru/post/de471718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471704/index.html">Das Buch „Egoistische Mitochondrien. Wie man die Gesundheit erhält und das Alter bewegt "</a></li>
<li><a href="../de471706/index.html">9 typische Netzwerkprobleme, die mithilfe der NetFlow-Analyse erkannt werden können (am Beispiel Flowmon)</a></li>
<li><a href="../de471708/index.html">Storypoints sind gefährlich für die Entwicklung von Client-Server-Anwendungen</a></li>
<li><a href="../de471712/index.html">Erstellen einer mobilen Chat-Anwendung in React Native</a></li>
<li><a href="../de471716/index.html">Technologieausstellung GITEX 2019 - wie es war</a></li>
<li><a href="../de471722/index.html">Wie ein 17-jähriger Mann einen Arcade-Hit aus den 80ern auf Computer portierte</a></li>
<li><a href="../de471724/index.html">Agile und Gehirnbedürfnisse: Stressmanagement</a></li>
<li><a href="../de471726/index.html">Moderne Methode zur Messung der Impulsantwort und der nichtlinearen Verzerrung</a></li>
<li><a href="../de471728/index.html">Avalonia meine Vor- und Nachteile</a></li>
<li><a href="../de471736/index.html">Berührungsloser Ethernet-Sensor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>