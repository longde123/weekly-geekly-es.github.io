<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš½ ğŸ„ ğŸ¡ Reverse Engineering Fantastic Dizzy ğŸ¦‹ ğŸ§™ğŸ½ âœŒğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fantastic Dizzy adalah game platformer puzzle yang dibuat pada tahun 1991 oleh Codemasters. Dia adalah bagian dari Seri Dizzy . Terlepas dari kenyataa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reverse Engineering Fantastic Dizzy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436674/"> Fantastic Dizzy adalah game platformer puzzle yang dibuat pada tahun 1991 oleh Codemasters.  Dia adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seri Dizzy</a> .  Terlepas dari kenyataan bahwa seri Dizzy masih populer, dan itu menciptakan game amatir ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dizzy Age</a> ), tampaknya tidak ada yang terlibat dalam pengembangan terbalik dari game asli. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/2bd/953/4662bd9537c41cceb388a841523b8669.png"></div><br>  Saya menulis beberapa alat sederhana untuk mengekstrak, melihat, dan mengemas sumber daya dari gim asli.  Alat diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h2>  Membongkar EXE </h2><br>  File biner PCDIZZY.EXE dikemas dalam format Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EXEPack</a> .  Meskipun ada banyak alat Linux yang dapat mendekompresi executable tersebut, tidak ada satupun yang mendukung versi yang digunakan untuk Fantastic Dizzy.  Oleh karena itu, untuk membongkar file yang dapat dieksekusi, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UNP</a> versi DOS.  Setelah membongkar file yang dapat dieksekusi, itu bisa diunduh ke IDA.  Mudahnya, versi file biner yang belum dibongkar masih bekerja dengan baik, sehingga bisa didebug menggunakan debugger DOSBox. <br><a name="habracut"></a><br><h2>  File data </h2><br>  Ada dua file data dalam game: DIZZY.NDX dan DIZZY.RES.  Ekstensi, serta ukuran file, memberi kami petunjuk tentang apa yang mungkin dikandungnya.  File NDX adalah sekitar 8 KB, dan file RES sekitar 800 KB.  Karena game ini ditulis dalam C, kita dapat mencari panggilan fopen di IDA untuk melihat di mana file data terbuka.  Dalam game DOS yang ditulis assembler, untuk ini Anda perlu mencari instruksi int 21j (untuk membuka file ah = 3d).  Biner Dizzy berisi fungsi pembungkus di sekitar fopen yang memungkinkan Anda menentukan nama utama dan ekstensi file.  Ini membawa kita ke blok kode berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/2a5/cdc/d502a5cdc3e09675a1edf6aac432ecc5.png"></div><br>  Ini memuat file DIZZY.RES dan DIZZY.NDX, dan juga menyimpan pointer file dalam variabel global.  Ketika merekayasa balik binari DOS, muncul masalah yang menjengkelkan: register di dalamnya 16-bit, tetapi pointer dalam beberapa kasus bisa 32-bit.  Di sini pointer FILE * berukuran 32 bit dan dikembalikan dari do_open_file ke ax: dx.  Perhatikan bahwa string juga merupakan pointer 32-bit, dan dizzy_basename diteruskan ke fungsi panggilan pada stack (dan analisis otomatis IDA yang membingungkan ini - itu dianggap sebagai argumen mode untuk fopen). <br><br>  Dengan mencari kemunculan g_dizzy_res / ndx di xrefs, Anda dapat menemukan di mana file dibaca.  Debugger DOSBox berguna pada titik ini, karena ada kemungkinan besar banyak operasi pembacaan file acak, dan menggunakan IDA untuk menentukan offset baca akan menjadi proses yang cukup monoton.  Panduan yang baik untuk membangun dan menggunakan debugger DOSBox dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Ketika menggunakan IDA dan debugger DOSBox bersama-sama, menjadi jelas bahwa file NDX digunakan sebagai indeks untuk file RES.  Setiap entri dalam file NDX membutuhkan 16 byte;  ini menyimpan pengidentifikasi fragmen, ukurannya dan offset dalam file RES.  Melihat bagaimana data RES dibaca, Anda dapat melihat bahwa flag flag diperiksa pertama kali dalam file NDX.  Jika bit 0x80 tidak diatur, maka data dibaca langsung dari file RES, jika tidak, jalur kode yang lebih kompleks dijalankan.  Bendera diatur untuk sebagian besar fragmen, sehingga dengan tingkat probabilitas tinggi kita dapat mengasumsikan bahwa itu menunjukkan semacam kompresi yang digunakan untuk fragmen-fragmen ini. <br><br><h2>  Kompresi </h2><br>  Jalur kompresi dimulai dengan membaca dari dasar fragmen RES dua kata 32-bit yang menunjukkan ukuran awal dan akhir, dan kemudian fungsi dekompresi disebut.  Pada tahun 1991, pengodean panjang run sederhana (RLE) dan kompresi kamus sangat populer, seperti berbagai algoritma Liv-Zempel.  Awal siklus pembongkaran terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/244/d0e/e15/244d0ee1533c6191ad5b6aed18b97081.png"></div><br>  Token untuk membongkar diperoleh menggunakan fungsi get_next_token, yang membaca bagian selanjutnya dari sumber data di ax: dx dengan shift oleh cl.  Register cl digunakan sebagai posisi bit shift, kembali ke nol setelah mencapai delapan.  Di awal siklus, token dibaca dan bit yang lebih rendah diperiksa.  Jika flag diatur, maka kodenya sederhana: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/1cb/a2b/c431cba2b710290e6dab47b4b711b6d1.png"></div><br>  Itu hanya menyimpan byte saat ini, menerima token berikutnya dan terus bekerja.  Jika flag dihapus, jalur kode yang lebih panjang dipilih, yang berakhir dengan instruksi rep movsb.  Ini menunjukkan bahwa beberapa jenis kamus digunakan dalam kompresi. <br><br>  Algoritma kompresi menarik karena beberapa alasan.  Pertama, ia menggunakan pengodean panjang bit variabel.  Nilai absolut dikodekan sebagai 1 flag dan nilai data 8-bit.  Anehnya, bitstream dikodekan sebagai endian kecil.  Ini mempersulit analisis dekompresi sedikit dengan mengamati file RES di hex editor.  Misalnya, jika tiga byte pertama fragmen dikodekan sebagai nilai absolut, maka data disusun sebagai berikut: <br><br><pre> <code class="hljs">: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD  1: 6543210F 7  2: 543210F 76  3: 43210F 765</code> </pre> <br>  Selain itu, unpacker dapat melewati byte saat membaca, jika counter cl kembali ke nol setelah menerima token berikutnya.  Saya tidak tahu apakah ini optimasi, atau bug, atau retasan yang dibuat oleh pengembang game untuk memperbaiki masalah dengan alat saya. <br><br>  Jika flag dihapus, unpacker melakukan penyalinan dari bagian awal data yang sudah dibongkar.  Dalam hal ini, bit-bit berikut menyandikan panjang dan mengimbangi dari yang akan disalin.  Offset dikodekan dalam 10 atau 13 bit, dan opsi yang diinginkan menunjukkan bendera.  Ini sepertinya pilihan yang sangat aneh, karena sedikit menyulitkan kode, dan paling-paling hanya menyimpan 2 bit. <br><br>  Pengkodean panjang seri terlihat sedikit aneh.  Unpacker membaca bit sampai mencapai bit nol.  Maka jumlah bit yang digunakan untuk mengkodekan panjangnya adalah dua ditambah jumlah bit yang tidak nol.  Misalnya, saat menyandikan panjang 58 (0x3a), bitstreamnya terlihat seperti ini: <br><br><pre> <code class="hljs">11110 111010</code> </pre> <br>  Pengkodean membutuhkan 11 bit.  Panjang kecil lebih baik disandikan karena panjang bit minimum adalah 2. Panjang penyalinan hingga 3 hanya membutuhkan 3 bit untuk mengkodekan, hingga 7 membutuhkan 5 bit, dan seterusnya.  Saya tidak tahu pasti apakah jenis pengkodean ini adalah teknik yang umum. <br><br>  Debugger DOSBox juga sangat berguna untuk merekonstruksi algoritma dekompresi.  Jika Anda tidak tahu seperti apa data dekompresi seharusnya, maka sulit untuk memahami apakah pengurai terbuka berfungsi dengan benar.  Menggunakan debugger, Anda dapat melangkah melalui seluruh algoritma dekompresi dan menyimpan tumpukan memori yang belum dibongkar untuk perbandingan. <br><br>  Fitur lain yang bermanfaat adalah tanda pada file NDX, yang menunjukkan bahwa sumber daya dikompresi.  Karena gim asli mendukung sumber daya yang tidak dibongkar, kami dapat mengemas kembali file RES tanpa perlu algoritma kompresi.  Memodifikasi dan mengemas ulang fragmen dengan peluncuran game selanjutnya adalah cara yang baik untuk menguji asumsi kami tentang format data. <br><br><h2>  Tingkat </h2><br>  Fantastic Dizzy adalah game dengan dunia terbuka.  Level adalah area dengan pengguliran vertikal atau horizontal.  Pemain bergerak di antara level, mencapai ujung level atau memasuki dan meninggalkan bangunan.  Meskipun referensi ke fragmen dalam file RES dibuat melalui pengidentifikasi 16-bit (ID), file biner dari game tersebut sebenarnya berisi tabel nama level yang cocok dengan pengidentifikasi fragmen.  Setiap level terdiri dari beberapa fragmen: judul, satu atau lebih layer, tileset dan palet.  Ada sedikit redundansi di sini, karena beberapa level menggunakan palet dan tileset yang sama, tetapi jangan menggunakan kembali fragmen yang sama, sehingga file RES berisi banyak sumber daya rangkap. <br><br>  Layers mengkodekan ubin untuk level.  Untuk bagian dunia yang berbeda atau untuk lapisan latar belakang, Anda dapat menggunakan lapisan tambahan.  Misalnya, pada tingkat tree1.stg, ada delapan lapisan untuk bagian berbeda dari puncak pohon dan satu lapisan latar belakang umum.  Namun, level bawah laut dibagi menjadi sea1.stg dan sea2.stg, yang masing-masing memiliki satu lapisan latar depan dan satu lapisan latar belakang. <br><br>  Lapisan latar belakang adalah latar belakang lebar-tetap tanpa menggulir, misalnya, hutan di bagian gim dengan puncak pohon.  Ubin latar depan dan latar belakang, yang terletak di depan dan di belakang karakter, dikodekan dalam lapisan yang sama dengan ubin yang Anda bisa berjalan.  Misalnya, tangkapan layar menunjukkan tingkat dari puncak pohon sejak awal permainan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/2bd/953/4662bd9537c41cceb388a841523b8669.png"></div><br>  <i>Tingkat puncak pohon</i> <br><br>  Ini adalah lapisan ketujuh tree1.stg: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5b/240/54a/f5b24054aa7e9ff6abb055a47c069109.png"></div><br>  <i>Tree level level ketujuh .stg</i> <br><br>  Perlu dicatat bahwa pemain bisa lewat di depan gubuk, tetapi di belakang dua pohon.  Semua informasi ubin terdapat dalam satu larik peta ubin yang terletak di satu lapisan.  Ubin dalam fragmen lapisan dikodekan dalam dua byte, dan 9 bit yang lebih rendah digunakan untuk indeks ubin.  Saya tidak sepenuhnya memahami bit atas, tetapi setidaknya mereka mengandung informasi tentang pergeseran palet untuk ubin dan, mungkin, informasi tentang tabrakan. <br><br>  Seperti level dalam game, adegan cutscene, potret karakter, dan layar kontrol inventaris juga disimpan.  Tampaknya teknik ini standar untuk game DOS, mungkin karena meminimalkan jumlah kode yang diperlukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/4f6/1e9/39a4f61e972a82f34d44f5d5781345ad.png"></div><br>  <i>"Level" manajemen persediaan</i> <br><br><h2>  Sprite </h2><br>  Format sprite tidak terlalu menarik.  Setiap sprite adalah bitmap dengan satu byte per piksel, tetapi dengan hanya 16 warna per sprite.  Menggunakan jumlah warna yang terbatas adalah teknik umum di era 256-warna VGA, karena untuk sprite mudah untuk melakukan pergeseran palet atau menggunakannya dalam level dengan palet lain;  selain itu, menghemat ruang yang dialokasikan untuk sprite. <br><br>  Sprite memiliki ukuran yang berbeda, sehingga sebuah fragmen terpisah berisi informasi tentang ukuran sprite dan perpindahannya dalam x dan y.  Sprite dikelompokkan ke dalam set, tetapi pengelompokannya terlihat cukup sewenang-wenang.  Misalnya, satu set sprite berisi gambar screen saver, objek inventaris, serta beberapa karakter non-pemain.  Ini membuat pengaturan tampilan sprite sedikit rumit karena paletnya tidak sama untuk semua sprite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/107/fa0/1a2/107fa01a2c5bbd0ecd53df2ba4e70b43.png"></div><br>  <i>Sprite Karakter Pemain</i> <br><br><h2>  Apa lagi yang tersisa? </h2><br>  Masih untuk merekayasa balik beberapa hal lagi.  Sebagian besar saya tertarik pada format file data, tetapi ada beberapa aspek yang saya tidak mengerti: <br><br><ul><li>  Di mana lokasi objek (kunci, buah, dll).  Tampaknya mereka tidak ditulis dalam fragmen level.  Mungkin mereka disimpan dalam file biner permainan, karena pemain dapat mengambil objek di satu level dan melemparkannya di yang lain. </li><li>  Cara kerja level collision.  Seorang pemain dapat berjalan di depan atau di belakang beberapa ubin, dan lantainya mungkin datar atau miring. </li><li>  Bagaimana level terhubung.  Informasi ini dapat disimpan dalam biner game. </li><li>  Pergeseran palet untuk ubin di tingkat tidak sepenuhnya benar.  Beberapa ubin menampilkan warna yang salah. </li><li>  Setiap set sprite memiliki tiga fragmen: header, tabel dan data.  Fragmen dengan tabel dan data jelas bagi saya, tetapi beberapa informasi tentang sprite disertakan dalam header, misalnya, offset dengan x dan y.  Saya tidak mengerti formatnya sepenuhnya. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436674/">https://habr.com/ru/post/id436674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436660/index.html">Peta Jalan Kode VS 2019 - DRAFT</a></li>
<li><a href="../id436662/index.html">1 Februari 2019 situs Anda mungkin berhenti berfungsi</a></li>
<li><a href="../id436664/index.html">Memperkenalkan Seri Standup Komunitas .NET</a></li>
<li><a href="../id436668/index.html">Bisakah statistik dibaca dengan sejumlah kecil data?</a></li>
<li><a href="../id436670/index.html">Cara menggulung pembaruan dalam produksi secara otomatis</a></li>
<li><a href="../id436676/index.html">Bagaimana cara DDoS seluruh negara</a></li>
<li><a href="../id436682/index.html">Jangan membuat JL (DSL) Anda sendiri untuk memperluas fungsionalitas aplikasi</a></li>
<li><a href="../id436684/index.html">Hari Jadi Android 10 (Q). Apa yang diketahui sekarang?</a></li>
<li><a href="../id436686/index.html">JPEG dari dunia 3D. Apa itu glTF?</a></li>
<li><a href="../id436688/index.html">Raksasa IT meninggalkan pasar untuk chip untuk pusat data - beri tahu kami apa artinya bagi industri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>