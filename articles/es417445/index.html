<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüíº ü¶é üéê Optimizaci√≥n de la representaci√≥n de una escena de la caricatura de Disney "Moana". Parte 2 üòç üí¥ üê¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspirado por la primera victoria de an√°lisis con una descripci√≥n de una escena de la isla de la caricatura de Moana de Disney, profundic√© en el estud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n de la representaci√≥n de una escena de la caricatura de Disney "Moana". Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417445/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg" alt="imagen"></div><br>  Inspirado por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera victoria de</a> an√°lisis con una descripci√≥n de una escena de la isla de <em>la</em> caricatura de <em>Moana</em> de Disney, profundic√© en el estudio del uso de la memoria.  A√∫n se pod√≠a hacer mucho con el tiempo de entrega, pero decid√≠ que ser√≠a √∫til investigar primero la situaci√≥n. <br><br>  Comenc√© la investigaci√≥n de tiempo de ejecuci√≥n con las estad√≠sticas pbrt incorporadas;  pbrt tiene una configuraci√≥n manual para asignaciones de memoria significativas para rastrear el uso de memoria, y despu√©s de que se completa la representaci√≥n, se muestra un informe de asignaci√≥n de memoria.  Esto es lo que originalmente era el informe de asignaci√≥n de memoria para esta escena: <br><br> <code> <br> BVH- 9,01  <br>  1,44  <br> MIP- 2,00  <br>   11,02 </code> <br> <br>  En cuanto al tiempo de ejecuci√≥n, las estad√≠sticas integradas resultaron ser breves y solo informaron la asignaci√≥n de memoria para objetos conocidos de 24 GB de tama√±o.  <code>top</code> dijo que, de hecho, se utilizaron unos 70 GB de memoria, es decir, 45 GB no se tuvieron en cuenta en las estad√≠sticas.  Las peque√±as desviaciones son bastante comprensibles: los asignadores de memoria din√°mica requieren espacio adicional para registrar el uso de recursos, algunos se pierden debido a la fragmentaci√≥n, etc.  ¬øPero 45 GB?  Algo malo definitivamente se esconde aqu√≠. <br><a name="habracut"></a><br>  Para comprender lo que nos falta (y para asegurarnos de que lo rastreamos correctamente), utilic√© el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">macizo</a> para rastrear la asignaci√≥n real de la memoria din√°mica.  Es bastante lento, pero al menos funciona bien. <br><br><h2>  Primitivas </h2><br>  Lo primero que encontr√© al rastrear el macizo fue dos l√≠neas de c√≥digo que asignaban instancias de la clase base <code>Primitive</code> , que no se tiene en cuenta en las estad√≠sticas, en la memoria.  Un peque√±o descuido que es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bastante f√°cil de solucionar</a> .  Despu√©s de eso, vemos lo siguiente: <br><br> <code>Primitives 24,67 </code> <br> <br>  Ups  Entonces, ¬øqu√© es un primitivo y por qu√© toda esta memoria? <br><br>  pbrt distingue entre <code>Shape</code> , que es geometr√≠a pura (esfera, tri√°ngulo, etc.) y <code>Primitive</code> , que es una combinaci√≥n de geometr√≠a, material, a veces la funci√≥n de la radiaci√≥n y el medio involucrado dentro y fuera de la superficie de la geometr√≠a. <br><br>  Hay <a href="">varias opciones para la</a> clase base <code>Primitive</code> : <code>GeometricPrimitive</code> , que es un caso est√°ndar: una combinaci√≥n "vainilla" de geometr√≠a, material, etc., as√≠ como <code>TransformedPrimitive</code> , que es una primitiva con transformaciones aplicadas, ya sea como una instancia de un objeto o para mover primitivas con transformaciones que cambian con el tiempo.  Resulta que en esta escena ambos tipos son una p√©rdida de espacio. <br><br><h3>  Geom√©trico: 50% de espacio extra </h3><br>  <em>Nota: se hacen algunas suposiciones err√≥neas en este an√°lisis;</em>  <em>son revisados ‚Äã‚Äãen el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuarto post de la serie</a> .</em> <br><br>  4,3 GB utilizados en <code>GeometricPrimitive</code> .  Es divertido vivir en un mundo donde 4.3 GB de RAM usada no es su mayor problema, pero veamos de d√≥nde obtuvimos 4.3 GB de <code>GeometricPrimitive</code> .  Aqu√≠ est√°n las partes relevantes de la definici√≥n de clase: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeometricPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface; };</code> </pre> <br>  Tenemos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puntero a vtable</a> , tres punteros m√°s, y luego una <code>MediumInterface</code> contiene dos punteros m√°s con un tama√±o total de 48 bytes.  Solo hay unas pocas mallas emisoras de luz en esta escena, por lo que <code>areaLight</code> casi siempre es un puntero nulo, y no hay entorno que afecte la escena, por lo que ambos punteros de <code>mediumInterface</code> tambi√©n <code>mediumInterface</code> nulos.  Por lo tanto, si tuvi√©ramos una implementaci√≥n especializada de la clase <code>Primitive</code> , que podr√≠a usarse en ausencia de las funciones de radiaci√≥n y medio, ahorrar√≠amos casi la mitad del espacio en disco ocupado por <code>GeometricPrimitive</code> , en nuestro caso, aproximadamente 2 GB. <br><br>  Sin embargo, no lo arregl√© y agregu√© una nueva implementaci√≥n <code>Primitive</code> a pbrt.  Nos esforzamos por minimizar las diferencias entre el c√≥digo fuente pbrt-v3 en github y el sistema descrito en mi libro, por una raz√≥n muy simple: mantenerlos sincronizados facilita la lectura del libro y el trabajo con el c√≥digo.  En este caso, decid√≠ que la implementaci√≥n completamente nueva de <code>Primitive</code> , nunca mencionada en el libro, ser√≠a una gran diferencia.  Pero esta soluci√≥n definitivamente aparecer√° en la nueva versi√≥n de pbrt. <br><br>  Antes de continuar, hagamos un render de prueba: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/b62/44e/1c6b6244e438a4f3a7431ba49f089525.jpg"></div><br>  <i>Playa de la isla de la pel√≠cula "Moana" renderizada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pbrt-v3</a> con una resoluci√≥n de 2048x858 y 256 muestras por p√≠xel.</i>  <i>El tiempo total de representaci√≥n en la instancia de 12 n√∫cleos / 24 hilos de Google Compute Engine con una frecuencia de 2 GHz con la √∫ltima versi√≥n de pbrt-v3 fue de 2 horas 25 minutos 43 segundos.</i> <br><br><h3>  Primitivos transformados: 95% de espacio desperdiciado </h3><br>  La memoria asignada por debajo de 4.3 GB <code>GeometricPrimitive</code> fue un √©xito bastante doloroso, pero ¬øqu√© pasa con 17.4 GB bajo <code>TransformedPrimitive</code> ? <br><br>  Como se mencion√≥ anteriormente, <code>TransformedPrimitive</code> usa tanto para transformaciones con un cambio en el tiempo como para instancias de objetos.  En ambos casos, necesitamos aplicar una transformaci√≥n adicional al <code>Primitive</code> existente.  Solo hay dos miembros en la clase <code>TransformedPrimitive</code> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Primitive&gt; primitive; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatedTransform PrimitiveToWorld;</code> </pre> <br>  Hasta ahora todo bien: un puntero a una primitiva y una transformaci√≥n que cambia con el tiempo.  Pero, ¬øqu√© se almacena realmente en <code>AnimatedTransform</code> ? <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Transform *startTransform, *endTransform; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Float startTime, endTime; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> actuallyAnimated; Vector3f T[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Quaternion R[<span class="hljs-number"><span class="hljs-number">2</span></span>]; Matrix4x4 S[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRotation; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DerivativeTerm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... Float kc, kx, ky, kz; }; DerivativeTerm c1[3], c2[3], c3[3], c4[3], c5[3];</span></span></code> </pre> <br>  Adem√°s de los punteros a dos matrices de transici√≥n y el tiempo asociado con ellas, tambi√©n hay una descomposici√≥n de las matrices en componentes de transporte, rotaci√≥n y escala, as√≠ como valores precalculados utilizados para limitar el volumen ocupado moviendo cuadros delimitadores (consulte la secci√≥n 2.4.9 de nuestro libro). <em>Representaci√≥n basada en la f√≠sica</em> ).  Todo esto suma hasta 456 bytes. <br><br>  Pero <em>nada se mueve</em> en esta escena.  Desde el punto de vista de las transformaciones para instancias de objetos, necesitamos un puntero a la transformaci√≥n, y no se necesitan los valores para descomposici√≥n y cuadros de l√≠mite m√≥viles.  (Es decir, solo se necesitan 8 bytes).  Si crea una implementaci√≥n <code>Primitive</code> separada para instancias fijas de objetos, 17.4 GB se comprimen en total a 900 MB (!). <br><br>  En cuanto a <code>GeometricPrimitive</code> , arreglarlo es un cambio no trivial en comparaci√≥n con lo que se describe en el libro, por lo que tambi√©n lo pospondremos en la pr√≥xima versi√≥n de pbrt.  Al menos ahora entendemos lo que est√° sucediendo con el caos de 24.7 GB de memoria <code>Primitive</code> . <br><br><h2>  Problemas con la cach√© de conversi√≥n </h2><br>  El siguiente bloque m√°s grande de memoria no contabilizada definido por macizo fue <code>TransformCache</code> , que ocupaba aproximadamente 16 GB.  (Aqu√≠ hay un enlace a la <a href="">implementaci√≥n original</a> ). La idea es que la misma matriz de transformaci√≥n a menudo se usa varias veces en la escena, por lo que es mejor tener una sola copia en la memoria, para que todos los elementos que la usan simplemente almacenen un puntero a la misma cosa conversi√≥n <br><br>  <code>TransformCache</code> us√≥ <code>std::map</code> para almacenar el cach√©, y macizo inform√≥ que 6 de 16 GB se usaron para nodos de √°rbol negro-rojo en <code>std::map</code> .  Este es un lote horrible: el 60% de este volumen se usa para las transformaciones en s√≠.  Veamos la declaraci√≥n para esta distribuci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Transform, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;Transform *, Transform *&gt;&gt; cache;</code> </pre> <br>  Aqu√≠, el trabajo se hace a la perfecci√≥n: <code>Transform</code> utiliza por completo como claves para la distribuci√≥n.  A√∫n mejor, pbrt <code>Transform</code> almacena dos matrices 4x4 (la matriz de transformaci√≥n y su matriz inversa), lo que resulta en 128 bytes almacenados en cada nodo del √°rbol.  Todo esto es absolutamente innecesario para el valor almacenado para √©l. <br><br>  Quiz√°s tal estructura es bastante normal en un mundo donde es importante para nosotros que se use la misma matriz de transformaci√≥n en cientos o miles de primitivas, y en general no hay muchas matrices de transformaci√≥n.  Pero para una escena con un mont√≥n de matrices de transformaci√≥n en su mayor√≠a √∫nicas, como en nuestro caso, este es solo un enfoque terrible. <br><br>  Adem√°s del hecho de que el espacio se desperdicia en las teclas, una b√∫squeda en <code>std::map</code> para atravesar el √°rbol rojo-negro implica muchas operaciones de puntero, por lo que parece l√≥gico intentar algo completamente nuevo.  Afortunadamente, poco se escribe sobre <code>TransformCache</code> en el libro, por lo que es completamente aceptable reescribirlo por completo. <br><br>  Y por √∫ltimo, antes de comenzar: despu√©s de examinar la firma del m√©todo <code>Lookup()</code> , se hace evidente otro problema: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transform &amp;t, Transform **tCached, Transform **tCachedInverse)</span></span></span></span></code> </pre> <br>  Cuando la funci√≥n de llamada proporciona <code>Transform</code> , el cach√© guarda y devuelve punteros de conversi√≥n iguales al pasado, pero tambi√©n pasa la matriz inversa.  Para hacer esto posible, en la implementaci√≥n original, al agregar una transformaci√≥n a la memoria cach√©, la matriz inversa siempre se calcula y almacena para que pueda devolverse. <br><br>  Lo est√∫pido aqu√≠ es que la mayor√≠a de los pares de marcado que usan el cach√© de transformaci√≥n no consultan ni usan la matriz inversa.  Es decir, se desperdician diferentes tipos de memoria en transformaciones inversas inaplicables. <br><br>  En la <a href="">nueva implementaci√≥n</a> , se agregan las siguientes mejoras: <br><br><ul><li>  Utiliza una tabla hash para acelerar la b√∫squeda y no requiere almacenamiento de otra cosa que no sea la matriz <code>Transform *</code> , lo que, en esencia, reduce la cantidad de memoria utilizada al valor realmente necesario para almacenar todas las <code>Transform</code> . </li><li>  La firma del m√©todo de b√∫squeda ahora se ve como <code>Transform *Lookup(const Transform <br> &amp;t)</code> <code>Transform *Lookup(const Transform <br> &amp;t)</code>  <code>Transform *Lookup(const Transform <br> &amp;t)</code> ;  en un lugar donde la funci√≥n de llamada quiere obtener la matriz inversa del cach√©, solo llama a <code>Lookup()</code> dos veces. </li></ul><br>  Para el hash, utilic√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funci√≥n hash FNV1a</a> .  Despu√©s de su implementaci√≥n, encontr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicaci√≥n de Aras sobre funciones hash</a> ;  quiz√°s deber√≠a haber usado xxHash o CityHash porque su rendimiento es mejor;  quiz√°s alg√∫n d√≠a mi verg√ºenza gane y la arregle. <br><br>  Gracias a la nueva implementaci√≥n de <code>TransformCache</code> , el tiempo total de inicio del sistema ha disminuido significativamente, hasta 21 min 42 s.  Es decir, ahorramos otros 5 minutos y 7 segundos, o aceleramos 1.27 veces.  Adem√°s, el uso m√°s eficiente de la memoria ha reducido el espacio ocupado por las matrices de transformaci√≥n de 16 a 5,7 GB, que es casi igual a la cantidad de datos almacenados.  Esto nos permiti√≥ no tratar de aprovechar el hecho de que en realidad no son proyectivos, y almacenar matrices de 3x4 en lugar de 4x4.  (En el caso habitual, ser√≠a esc√©ptico sobre la importancia de este tipo de optimizaci√≥n, pero aqu√≠ nos ahorrar√≠a m√°s de un gigabyte, ¬°mucha memoria! Definitivamente vale la pena hacerlo en el procesador de producci√≥n). <br><br><h2>  Peque√±a optimizaci√≥n de rendimiento para completar </h2><br>  Una estructura <code>TransformedPrimitive</code> demasiado generalizada nos cuesta memoria y tiempo: el generador de perfiles dijo que una parte significativa del tiempo al inicio se gast√≥ en la funci√≥n <code>AnimatedTransform::Decompose()</code> , que descompone la transformaci√≥n de la matriz en rotaci√≥n, transferencia y escala de cuaterniones.  Como nada se mueve en esta escena, este trabajo es innecesario, y una verificaci√≥n exhaustiva de la implementaci√≥n de <code>AnimatedTransform</code> ha demostrado que no se accede a ninguno de estos valores si las dos matrices de transformaci√≥n son realmente id√©nticas. <br><br>  A√±adiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos l√≠neas</a> al constructor para que las descomposiciones de las transformaciones no se realicen cuando no son necesarias, guardamos otros 1 min 31 del tiempo de inicio: como resultado, llegamos a 20 min 9 s, es decir, en general se aceleraron 1.73 veces. <br><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pr√≥ximo art√≠culo,</a> abordaremos seriamente el analizador y analizaremos lo que se volvi√≥ importante cuando aceleramos el trabajo de otras partes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417445/">https://habr.com/ru/post/es417445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417435/index.html">Se encontr√≥ un error tipogr√°fico en la configuraci√≥n de Aliens: Colonial Marines, debido a que la IA del juego estuvo defectuosa durante cuatro a√±os</a></li>
<li><a href="../es417437/index.html">Proyector vs panel plano. Nos probamos la bata de un oftalm√≥logo y descubrimos por qu√© el tama√±o importa</a></li>
<li><a href="../es417439/index.html">El Intel Core i7-8086K (parte 1)</a></li>
<li><a href="../es417441/index.html">C√≥mo detuvimos a jugadores comunes y para DDoS o nuestros servidores: una gu√≠a pr√°ctica</a></li>
<li><a href="../es417443/index.html">Los compuestos org√°nicos en Marte podr√≠an descubrirse hace 40 a√±os si se usara un m√©todo de an√°lisis diferente</a></li>
<li><a href="../es417447/index.html">Expedici√≥n a los misteriosos c√≠rculos de hadas en el desierto de Namib</a></li>
<li><a href="../es417449/index.html">Mundo Jur√°sico: ¬øPodemos realmente resucitar dinosaurios?</a></li>
<li><a href="../es417451/index.html">Cinco errores comunes para principiantes</a></li>
<li><a href="../es417453/index.html">Organizaci√≥n de pasant√≠as para estudiantes: rastrillo y trucos.</a></li>
<li><a href="../es417457/index.html">Frontend Conf Moscow: entrada y salida del lado del cliente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>