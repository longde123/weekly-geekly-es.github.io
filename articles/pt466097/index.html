<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüåæ ü•ó üåÄ Monitorando aplicativos .NET üíÉüèª üë©üèΩ‚Äçüîß üëÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET √© um tempo de execu√ß√£o gerenciado . Isso significa que ele cont√©m fun√ß√µes de alto n√≠vel que controlam seu programa para voc√™ (de Introdu√ß√£o ao Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monitorando aplicativos .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/466097/"><p>  .NET √© um <em>tempo de execu√ß√£o gerenciado</em> .  Isso significa que ele cont√©m fun√ß√µes de alto n√≠vel que controlam seu programa para voc√™ (de <a href="">Introdu√ß√£o ao Common Language Runtime (CLR), 2007</a> ): </p><br><blockquote>  O tempo de execu√ß√£o oferece muitas fun√ß√µes, portanto, √© conveniente dividi-las nas seguintes categorias: <br><br><ol><li>  <b>As principais fun√ß√µes</b> que afetam o dispositivo de outras pessoas.  Estes incluem: <ol><li>  coleta de lixo; </li><li>  protegendo o acesso √† mem√≥ria e digite a seguran√ßa do sistema; </li><li>  suporte de alto n√≠vel para linguagens de programa√ß√£o. </li></ol></li><li>  <b>Fun√ß√µes adicionais</b> - trabalhe com base nas principais.  Muitos programas √∫teis ficam sem eles.  Essas fun√ß√µes incluem: <ol><li>  Isolando aplicativos usando AppDomains </li><li>  prote√ß√£o de aplicativos e isolamento de sandbox. </li></ol></li><li>  <b>Outras fun√ß√µes</b> s√£o necess√°rias em todos os tempos de execu√ß√£o, mas elas n√£o usam as fun√ß√µes b√°sicas do CLR.  Tais recursos refletem o desejo de criar um ambiente de programa√ß√£o completo.  Estes incluem: <br><ol><li>  controle de vers√£o; </li><li>  depura√ß√£o / cria√ß√£o de perfil; </li><li>  garantindo intera√ß√£o. </li></ol></li></ol></blockquote><p>  Pode-se observar que, embora a depura√ß√£o e a cria√ß√£o de perfil n√£o sejam as fun√ß√µes principais ou adicionais, elas est√£o na lista devido ao " <em>desejo de criar um ambiente de programa√ß√£o completo</em> ". </p><br><p><img src="https://habrastorage.org/webt/mh/eq/nn/mheqnnqmnlkhoroovhqseskeyba.jpeg"></p><a name="habracut"></a><br><p>  <strong>O restante da publica√ß√£o descreve quais recursos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">monitoramento</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">observabilidade</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introspec√ß√£o</a> existem no Core CLR, por que s√£o √∫teis e como o ambiente os fornece.</strong> </p><br><h2 id="diagnostika">  Diagn√≥stico </h2><br><p>  Primeiro, d√™ uma olhada nas informa√ß√µes de diagn√≥stico fornecidas pelo CLR.  Tradicionalmente, o Rastreamento de Eventos para Windows (ETW) √© usado para isso. <br>  Existem muitos eventos sobre os quais o CLR fornece informa√ß√µes.  Eles est√£o associados a: </p><br><ul><li>  coleta de lixo (GC); </li><li>  Compila√ß√£o JIT; </li><li>  m√≥dulos e dom√≠nios de aplicativo; </li><li>  trabalhe com threads e conflitos ao bloquear; </li><li>  assim como muitos outros. </li></ul><br><p>  Por exemplo, aqui um <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">evento</a> ocorre <a href="https://github.com/dotnet/coreclr/blob/release/2.1/src/vm/corhost.cpp#">durante o carregamento no AppDomain</a> , aqui o <a href="">evento est√° associado ao lan√ßamento de uma exce√ß√£o</a> e aqui ao <a href="">ciclo de aloca√ß√£o de mem√≥ria pelo coletor de lixo</a> . </p><br><h3 id="perf-view">  Visualiza√ß√£o Perf </h3><br><p> Se voc√™ deseja ver os eventos no sistema de rastreamento (ETW) relacionados aos seus aplicativos .NET, recomendo usar a excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta PerfView</a> e come√ßar com esses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deos de treinamento</a> ou com esta apresenta√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfView: The Ultimate .NET Performance Tool</a> .  O PerfView foi amplamente reconhecido por fornecer informa√ß√µes valiosas.  Por exemplo, os engenheiros da Microsoft costumam us√°-lo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">analisar o desempenho</a> . </p><br><h3 id="obschaya-infrastruktura">  Infraestrutura comum </h3><br><p>  Se de repente o nome n√£o estiver claro, o rastreamento de eventos no ETW estar√° dispon√≠vel apenas no Windows, o que n√£o se encaixa muito bem no mundo entre plataformas do .NET Core.  Voc√™ pode usar o <a href="">PerfView para analisar o desempenho no Linux</a> (usando LTTng).  No entanto, essa ferramenta de linha de comando, chamada PerfCollect, coleta apenas dados.  Atualmente, os recursos de an√°lise e uma interface de usu√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">avan√ßada</a> (incluindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gr√°ficos de flama</a> ) est√£o dispon√≠veis apenas nas solu√ß√µes Windows. </p><br><p>  Mas se voc√™ ainda deseja analisar o desempenho do .NET no Linux, h√° outras abordagens: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Obtendo pilhas para eventos LTTng com o .NET Core no Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problema de desempenho do Linux</a> </li></ul><br><p>  O segundo link acima leva a uma discuss√£o sobre a nova <strong>infraestrutura EventPipe</strong> , que est√° sendo trabalhada no .NET Core (al√©m de EventSources &amp; EventListeners).  Seus objetivos de desenvolvimento podem ser encontrados no documento <a href="">Design de monitoramento de desempenho de plataforma cruzada</a> .  Em um n√≠vel alto, essa infraestrutura criar√° um √∫nico local para o qual o CLR enviar√° eventos relacionados ao diagn√≥stico e desempenho.  Em seguida, esses eventos ser√£o redirecionados para um ou mais registradores, que, por exemplo, podem incluir ETW, LTTng e BPF.  O criador de logs necess√°rio ser√° determinado dependendo do sistema operacional ou plataforma em que o CLR est√° sendo executado.  Para obter uma explica√ß√£o detalhada dos pr√≥s e contras de v√°rias tecnologias de log, consulte o <a href="">.NET Cross-Plat Performance and Eventing Design</a> . </p><br><p>  O progresso dos EventPipes √© monitorado atrav√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do projeto de Monitoramento de Desempenho</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos problemas</a> relacionados ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">'EventPipe'</a> . </p><br><h3 id="plany-na-buduschee">  Planos futuros </h3><br><p>  Por fim, h√° planos para criar um <a href="">Performance Profiling Controller</a> , que possui as seguintes tarefas: </p><br><p>  O controlador deve gerenciar a infraestrutura de cria√ß√£o de perfil e apresentar os dados de desempenho gerados pelos componentes .NET respons√°veis ‚Äã‚Äãpelo diagn√≥stico de desempenho de maneira simples e em v√°rias plataformas. </p><br><p>  De acordo com o plano, o controlador deve fornecer a <a href="">seguinte funcionalidade por meio do servidor HTTP</a> , recebendo todos os dados necess√°rios da infraestrutura do EventPipes: </p><br><p>  <strong>APIs REST</strong> </p><br><ul><li>  Princ√≠pio 1: cria√ß√£o de perfil simples: perfile o tempo de execu√ß√£o ao longo do per√≠odo X e retorne o rastreio. </li><li>  Princ√≠pio 1: cria√ß√£o de perfil avan√ßado: inicie o rastreamento (junto com a configura√ß√£o) </li><li>  Princ√≠pio 1: cria√ß√£o de perfil avan√ßado: rastreamento completo (a resposta a esta chamada ser√° o pr√≥prio rastreamento). </li><li>  Princ√≠pio 2: obtenha estat√≠sticas associadas a todos os EventCounters ou a um EventCounter espec√≠fico. </li></ul><br><p>  <strong>P√°ginas naveg√°veis ‚Äã‚Äãem HTML</strong> </p><br><ul><li>  Princ√≠pio 1: Uma representa√ß√£o textual de todas as pilhas de c√≥digo gerenciado em um processo. <br><ul><li>  Cria capturas instant√¢neas de processos em execu√ß√£o para serem usadas como um relat√≥rio de diagn√≥stico simples. </li></ul></li><li>  Princ√≠pio 2: exibindo o estado atual (possivelmente com um hist√≥rico) dos contadores EventCounters. <br><ul><li>  Fornece uma vis√£o geral dos contadores existentes e seus valores. </li><li>  PROBLEMA N√ÉO RESOLVIDO: acho que n√£o h√° APIs p√∫blicas necess√°rias para contar os EventCounters. </li></ul></li></ul><br><p>  Eu realmente quero ver o que acontece com o controlador de perfil de desempenho (PPC?).  Eu acho que se for incorporado ao CLR, trar√° muitos benef√≠cios para o .NET.  Essa funcionalidade existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em outros tempos de execu√ß√£o</a> . </p><br><h2 id="profilirovanie">  Cria√ß√£o de perfil </h2><br><p>  Outra ferramenta eficaz que o CLR possui √© uma API de cria√ß√£o de perfil.  √â (principalmente) usado por ferramentas de terceiros para conectar-se ao tempo de execu√ß√£o em um n√≠vel baixo.  Voc√™ pode aprender mais sobre a API <a href="">nesta revis√£o</a> , mas em um n√≠vel alto, pode us√°-la para fazer retornos de chamada que s√£o ativados se: </p><br><ul><li>  eventos relacionados ao coletor de lixo; </li><li>  exce√ß√µes s√£o lan√ßadas; </li><li>  montagens s√£o carregadas / descarregadas; </li><li>  <a href="">e muito mais</a> </li></ul><br><p>  <em>Imagem da <a href="">p√°gina da API de cria√ß√£o de perfil</a> do <a href="">BOTR - Vis√£o geral</a></em> </p><br><p>  Al√©m disso, possui outros recursos eficazes.  Primeiro, voc√™ pode configurar manipuladores que s√£o chamados toda vez que o m√©todo .NET √© executado, seja no pr√≥prio ambiente ou no c√≥digo do usu√°rio.  Esses retornos de chamada s√£o conhecidos como manipuladores Enter / Leave.  Aqui est√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bom exemplo de</a> como us√°-los.  No entanto, para isso, √© necess√°rio entender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as conven√ß√µes de chamada para diferentes arquiteturas de SO e CPU</a> , o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nem sempre √© f√°cil</a> .  Al√©m disso, lembre-se de que a API de cria√ß√£o de perfil √© um componente COM que s√≥ pode ser acessado pelo c√≥digo C / C ++, mas n√£o pelo C # / F # / VB.NET. </p><br><p>  Em segundo lugar, o criador de perfil pode reescrever o c√≥digo IL de qualquer m√©todo .NET antes da compila√ß√£o JIT usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API SetILFunctionBody ()</a> .  Essa API √© realmente eficiente.  Est√° subjacente a muitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramentas .NET do APM</a> .  Voc√™ pode aprender mais sobre o seu uso no meu post <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como zombar de classes seladas e m√©todos est√°ticos</a> e c√≥digos relacionados. </p><br><h3 id="icorprofiler-api">  API ICorProfiler </h3><br><p>  Acontece que a API de cria√ß√£o de perfil funcionou, deve haver todos os tipos de truques no ambiente de tempo de execu√ß√£o.  Veja a discuss√£o na p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Permitir rejei√ß√£o no anexo</a> (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReJIT: um guia de</a> instru√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para</a> obter mais informa√ß√µes sobre ReJIT). </p><br><p> Uma defini√ß√£o completa de todas as interfaces e retornos de chamada da API de cria√ß√£o de perfil pode ser encontrada em <a href="">\ vm \ inc \ corprof.idl</a> (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linguagem de descri√ß√£o da interface</a> ).  √â dividido em 2 partes l√≥gicas.  Uma parte √© a interface <strong>Profiler -&gt; Runtime Environment (EE)</strong> , conhecida como <code>ICorProfilerInfo</code> : </p><br><pre> <code class="plaintext hljs">//  ,    ICorProfilerInfo*,  //     .  ,  DLL   //          ,     //    .</code> </pre> <br><p>  Isso √© implementado nos seguintes arquivos: </p><br><ul><li>  <a href="">\ vm \ proftoeeinterfaceimpl.h</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.inl</a> </li><li>  <a href="">\ vm \ proftoeeinterfaceimpl.cpp</a> </li></ul><br><p>  A outra parte principal s√£o os retornos de chamada Runtime -&gt; Profiler, que s√£o agrupados na interface <code>ICorProfilerCallback</code> : </p><br><pre> <code class="plaintext hljs">//       //  ICorProfilerCallaback* .       // ,     EEToProfInterfaceImpl.</code> </pre> <br><p>  Esses retornos de chamada s√£o implementados nos seguintes arquivos: </p><br><ul><li>  <a href="">vm \ eetoprofinterfaceimpl.h</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.inl</a> </li><li>  <a href="">vm \ eetoprofinterfaceimpl.cpp</a> </li><li>  <a href="">vm \ eetoprofinterfacewrapper.inl</a> </li></ul><br><p>  Por fim, vale ressaltar que as APIs de cria√ß√£o de perfil podem n√£o funcionar em todos os SO e arquiteturas executando o .NET Core.  Aqui est√° um exemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problemas de stub de chamada ELT no Linux</a> .  Consulte o <a href="">Status das APIs do CoreCLR Profiler</a> para obter mais informa√ß√µes. </p><br><h3 id="profiling-v-debugging">  Cria√ß√£o de perfil v.  Depura√ß√£o </h3><br><p>  Como uma pequena digress√£o, devo dizer que a cria√ß√£o de perfil e a depura√ß√£o ainda se sobrep√µem um pouco.  Portanto, √© √∫til entender o que as diferentes APIs fornecem no contexto do .NET Runtime (extra√≠do de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CLR Debugging vs. CLR Profiling</a> ). </p><br><p>  <strong>A diferen√ßa entre depura√ß√£o e cria√ß√£o de perfil no CLR</strong> </p><br><div class="scrollable-table"><table><thead><tr><th>  Depura√ß√£o </th><th>  Cria√ß√£o de perfil </th></tr></thead><tbody><tr><td>  Projetado para encontrar problemas com a corre√ß√£o do c√≥digo. </td><td>  Projetado para diagnosticar e solucionar problemas de desempenho. </td></tr><tr><td>  Pode ter um n√≠vel muito alto de interfer√™ncia. </td><td>  Geralmente, tem um baixo n√≠vel de interven√ß√£o.  Embora o criador de perfil suporte a modifica√ß√£o do c√≥digo IL ou a instala√ß√£o de manipuladores enter / leave, tudo isso √© para instrumenta√ß√£o, n√£o para altera√ß√µes radicais no c√≥digo. </td></tr><tr><td>  A tarefa principal √© o controle completo do alvo.  Isso inclui inspe√ß√£o, controle de execu√ß√£o (por exemplo, o comando set-next-statement) e modifica√ß√µes (fun√ß√£o Edit-and-Continue). </td><td>  A principal tarefa √© inspecionar o alvo.  Para isso, √© fornecida instrumenta√ß√£o (altera√ß√£o do c√≥digo IL, instala√ß√£o de manipuladores de entrada / sa√≠da) </td></tr><tr><td>  API extensa e um modelo de objeto espesso preenchido com abstra√ß√µes. </td><td>  Uma pequena API.  Existem poucas ou nenhuma abstra√ß√£o. </td></tr><tr><td>  Alto n√≠vel de interatividade: as a√ß√µes do depurador s√£o controladas pelo usu√°rio (ou algoritmo).  De fato, editores e depuradores s√£o frequentemente integrados (IDEs). </td><td>  Sem interatividade: os dados geralmente s√£o coletados sem a interven√ß√£o do usu√°rio e depois analisados. </td></tr><tr><td>  Um pequeno n√∫mero de altera√ß√µes cr√≠ticas se a compatibilidade com vers√µes anteriores for necess√°ria.  Pensamos que migrar da vers√£o 1.1 para a vers√£o 2.0 do criador de perfil ser√° uma tarefa simples ou n√£o muito dif√≠cil. </td><td>  Um grande n√∫mero de altera√ß√µes cr√≠ticas se a compatibilidade com vers√µes anteriores for necess√°ria.  Acreditamos que migrar da vers√£o 1.1 para a vers√£o 2.0 do criador de perfil ser√° uma tarefa dif√≠cil, id√™ntica √† reescrev√™-la completamente. </td></tr></tbody></table></div><br><h2 id="otladka">  Depura√ß√£o </h2><br><p>  Os desenvolvedores entendem de maneira diferente o que √© depura√ß√£o.  Por exemplo, perguntei no Twitter "como voc√™ depura programas .NET" e obtive <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">respostas diferentes</a> .  Ao mesmo tempo, as respostas continham uma boa lista de ferramentas e m√©todos, por isso recomendo analis√°-las.  Obrigado #LazyWeb </p><br><p>  Eu acho que o melhor de toda a ess√™ncia da depura√ß√£o reflete esta mensagem: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="399339918213652480"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  O CLR fornece uma extensa lista de recursos relacionados √† depura√ß√£o.  No entanto, por que esses fundos s√£o necess√°rios?  Pelo menos tr√™s raz√µes s√£o mencionadas nesta √≥tima postagem. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Por que a depura√ß√£o gerenciada √© diferente da depura√ß√£o nativa?</a>  : </p><br><ol><li>  A depura√ß√£o de c√≥digo n√£o gerenciado pode ser abstra√≠da no n√≠vel do hardware, mas o c√≥digo gerenciado de depura√ß√£o deve ser abstra√≠do no n√≠vel do c√≥digo IL. </li><li>  A depura√ß√£o do c√≥digo gerenciado requer muitas informa√ß√µes que n√£o est√£o dispon√≠veis antes da execu√ß√£o. </li><li>  O depurador de c√≥digo gerenciado deve coordenar-se com o coletor de lixo (GC) </li></ol><br><p>  Portanto, para facilitar o uso, o CLR deve fornecer uma API de depura√ß√£o de alto n√≠vel conhecida como <code>ICorDebug</code> .  √â mostrado na figura abaixo, mostrando um cen√°rio geral de depura√ß√£o (fonte: BOTR): </p><br><h3 id="icordebug-api">  API ICorDebug </h3><br><p>  O princ√≠pio de implementa√ß√£o e a descri√ß√£o dos v√°rios componentes s√£o extra√≠dos da <a href="">CLR Debugging, uma breve introdu√ß√£o</a> : </p><br><blockquote>  Todo o suporte √† depura√ß√£o no .Net √© implementado na parte superior da biblioteca DLL, que chamamos de DAC.  Esse arquivo (geralmente chamado <code>mscordacwks.dll</code> ) √© um elemento estrutural da API de depura√ß√£o p√∫blica ( <code>ICorDebug</code> ) e de duas APIs de depura√ß√£o privadas: SOS-Dac API e IXCLR. <br>  Em um mundo ideal, todos usariam o <code>ICorDebug</code> , nossa API p√∫blica.  No entanto, o <code>ICorDebug</code> n√£o possui muitos dos recursos que os desenvolvedores de ferramentas precisam.  Este √© o problema que estamos tentando corrigir onde pudermos.  No entanto, esses aprimoramentos est√£o presentes apenas no CL.v.next, mas n√£o nas vers√µes anteriores do CLR.  De fato, o suporte √† depura√ß√£o de despejo de mem√≥ria apareceu na API <code>ICorDebug</code> apenas com o lan√ßamento do CLR v4.  Todo mundo que usa despejos de mem√≥ria para depura√ß√£o no CLR v2 n√£o poder√° aplicar o <code>ICorDebug</code> . </blockquote><p>  <em>(Consulte SOS e ICorDebug para obter mais informa√ß√µes)</em> </p><br><p>  De fato, a API <code>ICorDebug</code> √© dividida em mais de 70 interfaces.  N√£o darei a todos, mas mostrarei por quais categorias eles podem ser divididos.  Para mais informa√ß√µes, consulte a Parti√ß√£o do ICorDebug, onde esta lista foi publicada. </p><br><ul><li>  <strong>N√≠vel superior</strong> : ICorDebug + ICorDebug2 - interfaces de n√≠vel superior que servem perfeitamente como uma cole√ß√£o de objetos ICorDebugProcess. </li><li>  Retornos de chamada: os eventos de depura√ß√£o de c√≥digo gerenciado s√£o enviados por m√©todos ao objeto de retorno de chamada implementado pelo depurador. </li><li>  <strong>Processo</strong> : esse conjunto de interfaces representa o c√≥digo de trabalho e inclui APIs relacionadas a eventos. </li><li>  <strong>Inspe√ß√£o de c√≥digo / tipo</strong> : funciona principalmente com imagens est√°ticas de PE, mas existem m√©todos convenientes para dados reais. </li><li>  <strong>Controle de execu√ß√£o</strong> : capacidade de monitorar o progresso do encadeamento.  Na pr√°tica, isso significa a capacidade de definir pontos de interrup√ß√£o (F9) e percorrer o c√≥digo (entrada do c√≥digo F11, desvio do c√≥digo F10, sa√≠da do c√≥digo S + F11).  A fun√ß√£o de controle de execu√ß√£o ICorDebug funciona apenas no c√≥digo gerenciado. </li><li>  <strong>Threads + pilhas de chamadas</strong> : as <strong>pilhas de chamadas</strong> s√£o a base para as fun√ß√µes de inspe√ß√£o implementadas pelo depurador.  O trabalho com a pilha de chamadas √© realizado usando as seguintes interfaces.  O ICorDebug suporta apenas a depura√ß√£o de c√≥digo gerenciado e, portanto, voc√™ pode rastrear a pilha de apenas c√≥digo gerenciado. </li><li>  <strong>Inspe√ß√£o de objetos</strong> : a <strong>inspe√ß√£o de objetos</strong> faz parte da API que permite ver os valores das vari√°veis ‚Äã‚Äãno c√≥digo depurado.  Para cada interface, dou o m√©todo MVP, que, ao que me parece, deve descrever brevemente o objetivo dessa interface. </li></ul><br><p>  Como nas APIs de cria√ß√£o de perfil, os n√≠veis de suporte √† API de depura√ß√£o variam de acordo com a arquitetura do SO e do processador.  Por exemplo, em agosto de 2018, ainda n√£o havia solu√ß√£o Linux ARM para diagnosticar e depurar c√≥digo gerenciado.  Para obter mais informa√ß√µes sobre o suporte ao Linux, consulte a publica√ß√£o Debugging .NET Core no Linux com LLDB e o reposit√≥rio Diagnostics da Microsoft, que visa facilitar a depura√ß√£o de programas .NET para Linux. </p><br><p>  Por fim, se voc√™ quiser ver como a API do <code>ICorDebug</code> aparece em C #, d√™ uma olhada nos wrappers da biblioteca CLRMD, incluindo todos os retornos de chamada dispon√≠veis (mais sobre CLRMD ser√° discutido mais adiante nesta postagem). </p><br><h3 id="sos-i-dac">  SOS e DAC </h3><br><p>  O Data Access Component (DAC) √© discutido em detalhes na <a href="">p√°gina BOTR</a> .  Essencialmente, fornece acesso fora de processo √†s estruturas de dados do CLR, para que as informa√ß√µes contidas nelas possam ser lidas em outro processo.  Assim, o depurador (via <code>ICorDebug</code> ) ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a extens√£o 'Son of Strike' (SOS)</a> pode acessar a inst√¢ncia CLR ou despejo de mem√≥ria em execu√ß√£o e encontrar, por exemplo: </p><br><ul><li>  todos os threads em execu√ß√£o; </li><li>  objetos de heap gerenciado </li><li>  informa√ß√µes completas sobre o m√©todo, incluindo c√≥digo de m√°quina; </li><li>  rastreamento de pilha atual. </li></ul><br><p>  <strong>Uma pequena digress√£o</strong> : se voc√™ quiser descobrir de onde esses nomes estranhos vieram e obter uma pequena li√ß√£o na hist√≥ria do .NET, confira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta resposta no Stack Overflow</a> . </p><br><p>  A lista completa de comandos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SOS</a> √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">impressionante</a> .  Se voc√™ us√°-lo junto com o WinDBG, poder√° descobrir o que est√° acontecendo dentro do seu programa e do CLR em um n√≠vel muito baixo.  Para ver como tudo √© implementado, vejamos o <code>!HeapStat</code> , que exibe uma descri√ß√£o dos tamanhos dos v√°rios heaps que o .NET GC usa: </p><br><p>  (Imagem retirada do SOS: A pr√≥xima vers√£o possui alguns novos comandos - HeapStat) </p><br><p>  Aqui est√° um fluxo de c√≥digo que mostra como o SOS e o DAC funcionam juntos: </p><br><ul><li>  Equipe completa do <strong>SOS</strong> <code>!HeapStat</code> ( <a href="">link</a> ) </li><li>  C√≥digo <strong>SOS</strong> no <code>!HeapStat</code> que funciona com o GC da Esta√ß√£o de Trabalho (link) </li><li>  Fun√ß√£o <strong>SOS</strong> <code>GCHeapUsageStats(..)</code> , que executa a parte mais dif√≠cil do trabalho ( <a href="">link</a> ) </li><li>  <code>DacpGcHeapDetails</code> dados <strong>compartilhada</strong> <code>DacpGcHeapDetails</code> que cont√©m ponteiros para os dados principais no heap do GC, como segmentos, m√°scaras de bits e gera√ß√µes individuais ( <a href="">refer√™ncia</a> ). </li><li>  <code>GetGCHeapStaticData</code> <strong>DAC</strong> <code>GetGCHeapStaticData</code> que preenche a estrutura <code>DacpGcHeapDetails</code> ( <a href="">link</a> ) </li><li>  <code>DacpHeapSegmentData</code> dados <strong>compartilhada</strong> <code>DacpHeapSegmentData</code> que cont√©m informa√ß√µes sobre um segmento de heap de GC individual ( <a href="">link</a> ) </li><li>  <strong>DAC</strong> <code>GetHeapSegmentData(..)</code> , que preenche a estrutura <code>DacpHeapSegmentData</code> ( <a href="">link</a> ) </li></ul><br><h3 id="storonnie-otladchiki">  Depuradores de terceiros </h3><br><p>  Desde que a Microsoft publicou a API de depura√ß√£o, os desenvolvedores de terceiros puderam usar as interfaces <code>ICorDebug</code> .  Aqui est√° uma lista dos que eu consegui encontrar: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depurador</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Samsung</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para tempo de execu√ß√£o .NET Core</a> <br><ul><li>  O depurador permite que voc√™ use a interface do adaptador de depura√ß√£o GDB / MI ou VSCode para corrigir erros nos aplicativos .NET a partir do tempo de execu√ß√£o do .NET Core. </li><li>  <em>Provavelmente</em> escrito como parte de um projeto para portar o <a href="">.NET Core para o Tizen OS</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dnSpy</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Editor de</a> depurador e assembly .NET <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma ferramenta muito poderosa</a> .  Este √© um depurador, editor de montagem, editor hexadecimal, descompilador e muito mais. </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MDbg.exe (depurador de linha de comando do .NET Framework)</a> <br><ul><li>  Dispon√≠vel como um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote NuGet</a> .  Tamb√©m pode ser baixado do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio GitHub</a> ou do site da Microsoft. </li><li>  No entanto, no momento, o MDBG parece n√£o suportar o .NET Core.  Consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Porta MDBG para CoreCLR</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ETA para portar mdbg para coreclr para obter mais informa√ß√µes</a> . </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O 'Rider' do JetBrains</a> permite depurar o .NET Core no Windows. <br><ul><li>  Houve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguns problemas de</a> licenciamento com esta ferramenta. </li><li>  Mais informa√ß√µes podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste t√≥pico do HackerNews.</a> </li></ul></li></ul><br><h3 id="dampy-pamyati">  Despejos de mem√≥ria </h3><br><p>  A √∫ltima coisa sobre a qual falaremos √© sobre despejos de mem√≥ria, que podem ser obtidos em um sistema em funcionamento e analisados ‚Äã‚Äãfora dele.  O tempo de execu√ß√£o do .NET sempre oferece suporte √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descarga de mem√≥ria no Windows</a> .  E agora que o .NET Core se tornou multiplataforma, surgiram ferramentas que executam a mesma tarefa em outros sistemas operacionais. </p><br><p>  Ao usar despejos de mem√≥ria, √†s vezes √© dif√≠cil obter as vers√µes corretas e correspondentes dos arquivos SOS e DAC.  Felizmente, a Microsoft lan√ßou recentemente a ferramenta CLI do <code>dotnet symbol</code> , que: </p><br><blockquote>  pode baixar todos os arquivos necess√°rios para depura√ß√£o (conjuntos de caracteres, m√≥dulos, arquivos SOS e DAC para um m√≥dulo coreclr espec√≠fico) para qualquer dump, minidump ou arquivos espec√≠ficos de qualquer plataforma suportada, incluindo ELF, MachO, DLL do Windows, PDB e port√°til APO </blockquote><p>  Por fim, se voc√™ estiver analisando um pouco os despejos de mem√≥ria, recomendo dar uma olhada na excelente biblioteca de CLR MD lan√ßada h√° v√°rios anos pela Microsoft.  Eu j√° escrevi sobre suas fun√ß√µes.  Em resumo, usando a biblioteca, voc√™ pode trabalhar com despejos de mem√≥ria por meio de uma API C # intuitiva que cont√©m classes que fornecem acesso ao ClrHeap, ra√≠zes de GC, threads de CLR, quadros de pilha e muito mais.  De fato, o CLR MD pode implementar a maioria (se n√£o todos) dos comandos do SOS. </p><br><p>  Voc√™ pode descobrir como funciona a partir desta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem</a> : </p><br><blockquote>  A Biblioteca gerenciada do ClrMD √© um inv√≥lucro em torno das APIs de depura√ß√£o destinadas ao uso interno apenas no CLR.  Apesar de essas APIs serem muito eficazes para o diagn√≥stico, n√£o as suportamos na forma de lan√ßamentos documentados p√∫blicos, pois seu uso √© complexo e est√° intimamente relacionado a outros recursos da implementa√ß√£o do CLR.  O ClrMD resolve esse problema fornecendo um wrapper gerenci√°vel e f√°cil de usar em torno dessas APIs de depura√ß√£o de baixo n√≠vel. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466097/">https://habr.com/ru/post/pt466097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466075/index.html">Como deixei a ci√™ncia b√°sica em uma startup</a></li>
<li><a href="../pt466077/index.html">Broadcast Techdir Day em S√£o Petersburgo</a></li>
<li><a href="../pt466081/index.html">3 de setembro</a></li>
<li><a href="../pt466089/index.html">Algoritmo de Pensamento e Consci√™ncia, Parte 2</a></li>
<li><a href="../pt466093/index.html">Como funciona o kubectl exec?</a></li>
<li><a href="../pt466099/index.html">Recursos de teste de um aplicativo Web para servi√ßo de v√≠deo</a></li>
<li><a href="../pt466103/index.html">Monitoramento de seguran√ßa na nuvem</a></li>
<li><a href="../pt466105/index.html">API de Magento Rest com Overclocking com RoadRunner</a></li>
<li><a href="../pt466107/index.html">Sistema Smart Home fa√ßa voc√™ mesmo</a></li>
<li><a href="../pt466109/index.html">Solu√ß√£o de problemas com pwnable.kr 22 - brainfuck. Ataque Ret2libc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>