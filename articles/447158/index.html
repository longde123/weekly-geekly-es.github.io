<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚öñÔ∏è üßïüèæ üçë Wireshark 3.x: an√°lisis de c√≥digo de macOS y revisi√≥n de errores üë©üèº‚Äçüåæ üò§ üé∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La Fundaci√≥n Wireshark ha lanzado la √∫ltima versi√≥n estable del popular analizador de tr√°fico de red: Wireshark 3.0.0. La nueva versi√≥n corrigi√≥ vario...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wireshark 3.x: an√°lisis de c√≥digo de macOS y revisi√≥n de errores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/447158/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/b08/9a1/e5db089a18a6e0f13aaf26e7f0c5fb91.png" alt="Imagen 1"></div><br>  La Fundaci√≥n Wireshark ha lanzado la √∫ltima versi√≥n estable del popular analizador de tr√°fico de red: Wireshark 3.0.0.  La nueva versi√≥n corrigi√≥ varios errores, implement√≥ la capacidad de analizar nuevos protocolos y reemplaz√≥ el controlador WinPcap con Npcap.  Aqu√≠ termina la cita del anuncio y comienza nuestro art√≠culo sobre errores en el proyecto.  Antes del lanzamiento, se corrigieron claramente de manera insuficiente.  Veamos algunas correcciones para que haya una raz√≥n para hacer una nueva versi√≥n :). <br><br><h2>  Introduccion </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wireshark</a> es una herramienta bien conocida para capturar y analizar el tr√°fico de red.  El programa funciona con la gran mayor√≠a de los protocolos conocidos, tiene una interfaz gr√°fica clara y l√≥gica, un potente sistema de filtro.  Wireshark: multiplataforma, funciona en sistemas operativos como: Windows, Linux, macOS, Solaris, FreeBSD, NetBSD y muchos otros. <br><br>  Para buscar errores, utilizamos el analizador est√°tico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> .  Para analizar el c√≥digo fuente, primero debe compilar el proyecto en alg√∫n sistema operativo.  La elecci√≥n fue excelente no solo por la naturaleza multiplataforma del proyecto, sino tambi√©n por la naturaleza multiplataforma del analizador.  Para el an√°lisis del proyecto, eleg√≠ macOS.  El analizador tambi√©n se puede iniciar en Windows y Linux. <br><br>  Me gustar√≠a hablar sobre la calidad del c√≥digo por separado.  Lamentablemente, no puedo llamarlo bueno.  Esta es una evaluaci√≥n subjetiva, pero como revisamos regularmente muchos proyectos, tengo algo con lo que comparar.  En este caso, una gran cantidad de advertencias de PVS-Studio en una peque√±a cantidad de c√≥digo son sorprendentes.  En total, se han emitido m√°s de 3.500 advertencias de todos los niveles para este proyecto.  Esto es t√≠pico para proyectos que no utilizan herramientas de an√°lisis est√°tico, incluso las gratuitas.  Otro factor que indica la calidad del proyecto son los errores repetidos identificados por el analizador.  Los mismos ejemplos de c√≥digo no se dar√°n en el art√≠culo, pero algunos errores id√©nticos est√°n presentes en el c√≥digo en cientos de lugares. <br><a name="habracut"></a><br>  Adem√°s, estos insertos no agregan calidad al c√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Input file: packet-acse-template.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">line</span></span></span><span class="hljs-meta"> 1 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./asn1/acse/packet-acse-template.c"</span></span></span></span></code> </pre> <br>  Hay m√°s de 1000 de ellos en todo el proyecto.  Tales insertos dificultan que el analizador compare las advertencias generadas con el archivo deseado.  Pero estoy seguro de que los desarrolladores comunes no disfrutan del soporte de dicho c√≥digo. <br><br><h2>  Errores tipogr√°ficos </h2><br>  <b>Advertencia 1</b> <br><br>  V641 El tama√±o del b√∫fer de memoria asignado no es un m√∫ltiplo del tama√±o del elemento.  mate_setup.c 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> mate_cfg_gog* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gogcfg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mate_config* mc, gchar* name)</span></span></span><span class="hljs-function"> </span></span>{ mate_cfg_gog* cfg = (mate_cfg_gog *)g_malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mate_cfg_gop)); .... }</code> </pre> <br>  Hay dos tipos de estructuras: <i>mate_cfg_gog</i> y <i>mate_cfg_gop</i> , son muy similares, pero no id√©nticas.  Lo m√°s probable es que las funciones se mezclaron en este fragmento de c√≥digo, que est√° plagado de posibles errores en el programa durante el acceso a la memoria por puntero. <br><br>  Los siguientes son fragmentos de estructuras de datos confusas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gog</span></span></span><span class="hljs-class"> {</span></span> gchar* name; GHashTable* items; guint last_id; GPtrArray* transforms; LoAL* keys; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">gop_tree_mode_t</span></span> gop_tree_mode; gboolean show_times; .... } mate_cfg_gog; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mate_cfg_gop</span></span></span><span class="hljs-class"> {</span></span> gchar* name; guint last_id; GHashTable* items; GPtrArray* transforms; gchar* on_pdu; AVPL* key; AVPL* start; AVPL* stop; AVPL* extra; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> expiration; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> idle_timeout; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lifetime; gboolean drop_unassigned; <span class="hljs-keyword"><span class="hljs-keyword">gop_pdu_tree_t</span></span> pdu_tree_mode; gboolean show_times; .... } mate_cfg_gop;</code> </pre> <br>  <b>Advertencia 2</b> <br><br>  V519 La variable 'HDR_TCP.dest_port' tiene valores asignados dos veces sucesivamente.  Quiz√°s esto sea un error.  L√≠neas de verificaci√≥n: 495, 496. text_import.c 496 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_current_packet</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... HDR_TCP.source_port =isOutbound ? g_htons(hdr_dest_port):g_htons(hdr_src_port); HDR_TCP.dest_port = isOutbound ? g_htons(hdr_src_port) :g_htons(hdr_dest_port); HDR_TCP.dest_port = g_htons(hdr_dest_port); .... }</code> </pre> <br>  En la √∫ltima l√≠nea, el valor calculado de la variable <i>HDR_TCP.dest_port no</i> est√° <i>confirmado</i> . <br><br><h2>  Errores l√≥gicos </h2><br>  En esta secci√≥n dar√© algunos ejemplos de errores en las declaraciones condicionales, y todos ellos ser√°n fundamentalmente diferentes entre s√≠. <br><br>  <b>Advertencia 1</b> <br><br>  V547 La expresi√≥n 'direction == 0' siempre es falsa.  paquete-adb.c 291 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_RECV 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P2P_DIR_SENT 0 static void save_command(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( service_data &amp;&amp; service_data-&gt;remote_id == 0 &amp;&amp; direction == P2P_DIR_RECV) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (direction == P2P_DIR_SENT) { service_data-&gt;remote_id = arg1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// unreachable code } else { service_data-&gt;remote_id = arg0; } .... } .... }</span></span></span></span></code> </pre> <br>  En la condici√≥n externa, la variable de <i>direcci√≥n</i> se compara con la constante <i>P2P_DIR_RECV</i> .  Escribir expresiones a trav√©s del operador AND significa que cuando se alcanza la condici√≥n interna, el valor de la variable de <i>direcci√≥n</i> no ser√° exactamente igual a la otra constante <i>P2P_DIR_SENT</i> . <br><br>  <b>Advertencia 2</b> <br><br>  V590 Considere inspeccionar el '(tipo == 0x1) ||  (tipo! = 0x4) 'expresi√≥n.  La expresi√≥n es excesiva o contiene un error de imprenta.  paquete-fcsb3.c 686 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_fc_sbccs</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((type == FC_SBCCS_IU_CMD_HDR) || (type != FC_SBCCS_IU_CMD_DATA)) { .... }</code> </pre> <br>  El error de este fragmento de c√≥digo es que el resultado de la condici√≥n depende de una sola expresi√≥n: <br><br><pre> <code class="cpp hljs">(type != FC_SBCCS_IU_CMD_DATA)</code> </pre> <br>  <b>Advertencia 3</b> <br><br>  V590 Considere inspeccionar esta expresi√≥n.  La expresi√≥n es excesiva o contiene un error de imprenta.  snort-config.c 40 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhiteSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *accumulated_offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Skip any leading whitespace */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (source[offset] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; source[offset] == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { offset++; } *accumulated_offset += offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source + offset; }</code> </pre> <br>  El resultado de la declaraci√≥n condicional depender√° solo de esta parte de la expresi√≥n <i>(fuente [desplazamiento] == '')</i> .  La comprobaci√≥n <i>(fuente [desplazamiento]! = '\ 0')</i> es redundante y se puede eliminar de forma segura.  Esto no es un error real, pero el c√≥digo redundante dificulta la lectura y comprensi√≥n del programa, por lo que es mejor simplificarlo. <br><br>  <b>Advertencia 4</b> <br><br>  V547 La expresi√≥n 'eras_pos! = NULL' siempre es verdadera.  reedsolomon.c 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eras_dec_rs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dtype data[NN], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eras_pos[NN-KK], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> no_eras)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;count;i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(eras_pos!= <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) eras_pos[i] = INDEX_TO_POS(loc[i]); } } .... }</code> </pre> <br>  Quiz√°s estamos lidiando con una verificaci√≥n innecesaria, y posiblemente con un error tipogr√°fico, y en uno de los ifs, algo m√°s deber√≠a verificarse. <br><br><h2>  Activos extra√±os </h2><br>  <b>Advertencia 1</b> <br><br>  V547 La expresi√≥n 'sub_dissectors! = NULL' siempre es verdadera.  capture_dissectors.c 129 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capture_dissector_add_uint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... sub_dissectors = (struct capture_dissector_table*)g_hash_table_lookup(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sub_dissectors == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"OOPS: Subdissector \"%s\" not found ... \n"</span></span>, name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getenv(<span class="hljs-string"><span class="hljs-string">"WIRESHARK_ABORT_ON_DISSECTOR_BUG"</span></span>) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } g_assert(sub_dissectors != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Verificar el puntero en <i>g_assert</i> en este punto es superfluo, ya que el puntero se verifica antes de eso.  Quiz√°s en esta funci√≥n solo hab√≠a <i>g_assert antes</i> , y se olvidaron de eliminarlo, pero tal vez aqu√≠ deber√≠a verificar alg√∫n campo de estructura. <br><br>  <b>Advertencia 2</b> <br><br>  V547 La expresi√≥n 'i &lt;count' siempre es verdadera.  packet-netflow.c 10363 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_v9_v10_template_fields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... count = tmplt_p-&gt;field_count[fields_type]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmplt_p-&gt;fields_p[fields_type] != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { DISSECTOR_ASSERT (i &lt; count); <span class="hljs-comment"><span class="hljs-comment">// &lt;= tmplt_p-&gt;fields_p[fields_type][i].type = type; tmplt_p-&gt;fields_p[fields_type][i].length = length; tmplt_p-&gt;fields_p[fields_type][i].pen = pen; tmplt_p-&gt;fields_p[fields_type][i].pen_str = pen_str; if (length != VARIABLE_LENGTH) {/ tmplt_p-&gt;length += length; } } .... } .... }</span></span></code> </pre> <br>  No est√° del todo claro por qu√© una <i>aserci√≥n est√°</i> presente en la funci√≥n, que duplica la condici√≥n del bucle.  El contador de ciclos en el cuerpo no cambia. <br><br><h2>  Errores con punteros </h2><br>  <b>Advertencia 1</b> <br><br>  V595 El puntero 'si-&gt; conv' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 2135, 2144. packet-smb2.c 2135 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissect_smb2_fid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... g_hash_table_insert(si-&gt;conv-&gt;fids, sfi, sfi); <span class="hljs-comment"><span class="hljs-comment">// &lt;= si-&gt;file = sfi; if (si-&gt;saved) { si-&gt;saved-&gt;file = sfi; si-&gt;saved-&gt;policy_hnd = policy_hnd; } if (si-&gt;conv) { // &lt;= eo_file_info = (.... *)g_hash_table_lookup(si-&gt;conv-&gt;files,&amp;policy_hnd); .... } .... }</span></span></code> </pre> <br>  El puntero <i>si-&gt; conv se</i> desreferencia varias l√≠neas antes de que se verifique si es igual a cero o no. <br><br>  <b>Advertencia 2</b> <br><br>  V774 El puntero 'protos' se us√≥ despu√©s de liberar la memoria.  paquete-k12.c 311 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k12_update_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** err)</span></span></span><span class="hljs-function"> </span></span>{ gchar** protos; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_protos; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ! (h-&gt;handles[i] = find_dissector(protos[i])) ) { h-&gt;handles[i] = data_handle; h-&gt;handles[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; g_strfreev(protos); *err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } } .... }</code> </pre> <br>  <i>protos</i> es una serie de cadenas.  Durante el procesamiento de una excepci√≥n en el programa, esta matriz primero se borra mediante la funci√≥n <i>g_strfreev</i> , y luego se usa una de las l√≠neas de esta matriz en el mensaje de error.  Lo m√°s probable es que estas l√≠neas en el c√≥digo se intercambien: <br><br><pre> <code class="cpp hljs">*err = g_strdup_printf(<span class="hljs-string"><span class="hljs-string">"Could not find dissector for: '%s'"</span></span>, protos[i]); g_strfreev(protos);</code> </pre> <br><h2>  Fugas de memoria </h2><br>  V773 Al puntero 'ptmpstr' se le asignaron valores dos veces sin liberar la memoria.  Una p√©rdida de memoria es posible.  idl2wrs.c 2436 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsetypedefunion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmpstr[BASE_BUFFER_SIZE], *ptmpstr; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(num_pointers--){ g_snprintf(tmpstr, BASE_BUFFER_SIZE, <span class="hljs-string"><span class="hljs-string">"%s_%s"</span></span>, ptmpstr, <span class="hljs-string"><span class="hljs-string">"unique"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"static int\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"...."</span></span>, tmpstr); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"{\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" ...."</span></span>, ptmpstr, ti-&gt;str); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">" return offset;\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>); FPRINTF(eth_code, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); ptmpstr=g_strdup(tmpstr); } .... }</code> </pre> <br>  Despu√©s de la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>g_strdup</i></a> , debe llamar a la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>g_free</i></a> en alg√∫n momento.  En el fragmento de c√≥digo presentado, esto no se hace, y en el ciclo en cada iteraci√≥n se asigna una nueva pieza de RAM.  Se producen m√∫ltiples p√©rdidas de memoria. <br><br>  Algunas advertencias m√°s para fragmentos de c√≥digo similares: <br><br><ul><li>  V773 Al puntero 'ptmpstr' se le asignaron valores dos veces sin liberar la memoria.  Una p√©rdida de memoria es posible.  idl2wrs.c 2447 </li><li>  V773 Al puntero 'ptmpstr' se le asignaron valores dos veces sin liberar la memoria.  Una p√©rdida de memoria es posible.  idl2wrs.c 2713 </li><li>  V773 Al puntero 'ptmpstr' se le asignaron valores dos veces sin liberar la memoria.  Una p√©rdida de memoria es posible.  idl2wrs.c 2728 </li><li>  V773 Al puntero 'ptmpstr' se le asignaron valores dos veces sin liberar la memoria.  Una p√©rdida de memoria es posible.  idl2wrs.c 2732 </li><li>  V773 Al puntero 'ptmpstr' se le asignaron valores dos veces sin liberar la memoria.  Una p√©rdida de memoria es posible.  idl2wrs.c 2745 </li></ul><br>  Desafortunadamente, hay muchos otros lugares similares en el c√≥digo donde no se libera memoria. <br><br><h2>  Miscel√°neo </h2><br>  <b>Advertencia 1</b> <br><br>  V535 La variable 'i' se est√° utilizando para este bucle y para el bucle externo.  L√≠neas de verificaci√≥n: 7716, 7798. packet-opa-mad.c 7798 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Parse GetVFInfo MAD from the Performance Admin class. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_GetVFInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; records; i++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= line 7716 .... for (i = 0; i &lt; PM_UTIL_BUCKETS; i++) { // &lt;= line 7748 GetVFInfo_Util_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; } .... for (i = 0; i &lt; PM_ERR_BUCKETS; i++) { // &lt;= line 7798 GetVFInfo_Error_Stats_Bucket_item = proto_tree_add_item(....); proto_item_set_text(....); local_offset += 4; .... } .... } .... }</span></span></code> </pre> <br>  En una funci√≥n muy larga, los desarrolladores cambian audazmente el valor del contador de bucle y lo hacen varias veces.  Es dif√≠cil decir si esto es un error o no, pero hay unos 10 ciclos de este tipo en el proyecto. <br><br>  <b>Advertencia 2</b> <br><br>  El 'elemento' del par√°metro V763 siempre se reescribe en el cuerpo de la funci√≥n antes de ser utilizado.  paquete-cdma2k.c 1324 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cdma2k_message_ORDER_IND</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(proto_item *item, ....)</span></span></span><span class="hljs-function"> </span></span>{ guint16 addRecLen = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordq = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rejectedtype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; guint16 l_offset = <span class="hljs-number"><span class="hljs-number">-1</span></span>, rsc_mode_ind = <span class="hljs-number"><span class="hljs-number">-1</span></span>, ordertype = <span class="hljs-number"><span class="hljs-number">-1</span></span>; proto_tree *subtree = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, *subtree1 = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; item = proto_tree_add_item(tree,hf_cdma2k_OrderIndMsg, tvb, ....); <span class="hljs-comment"><span class="hljs-comment">// &lt;= subtree = proto_item_add_subtree(item, ett_cdma2k_subtree1); .... }</span></span></code> </pre> <br>  El puntero del <i>elemento</i> que toma la funci√≥n se deshilacha inmediatamente por otro valor.  Esto es muy sospechoso.  Adem√°s, el c√≥digo contiene varias docenas de dichos lugares, por lo que es dif√≠cil decir si esto es un error o no.  Conoc√≠ un c√≥digo similar anteriormente en otro gran proyecto, all√≠ estaba el c√≥digo correcto, pero nadie se atrevi√≥ a cambiar la interfaz de la funci√≥n. <br><br>  <b>Advertencia 3</b> <br><br>  V762 Es posible que una funci√≥n virtual se haya anulado incorrectamente.  Vea el tercer argumento de la funci√≥n 'headerData' en la clase derivada 'PacketListModel' y la clase base 'QAbstractItemModel'.  packet_list_model.h 48 <br><br><pre> <code class="cpp hljs">QVariant QAbstractItemModel::headerData(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> section, Qt::Orientation orientation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> role = Qt::DisplayRole) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= class PacketListModel : public QAbstractItemModel { Q_OBJECT public: .... QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole | Qt::ToolTipRole) const; // &lt;= .... };</span></span></code> </pre> <br>  El analizador detect√≥ una sobrecarga incorrecta de la funci√≥n <i>headerData</i> .  Las funciones tienen un valor predeterminado diferente para el par√°metro de <i>rol</i> .  Esto puede no conducir al comportamiento que el programador esperaba. <br><br>  <b>Advertencia 4</b> <br><br>  V610 Comportamiento indefinido.  Verifique el operador de turno '&gt;&gt;'.  El operando derecho ('bithift' = [0..64]) es mayor o igual que la longitud en bits del operando izquierdo promovido.  proto.c 10941 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto_item_add_bitmask_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || len &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) g_assert_not_reached(); bitshift = (<span class="hljs-number"><span class="hljs-number">8</span></span> - (guint)len)*<span class="hljs-number"><span class="hljs-number">8</span></span>; available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift; .... }</code> </pre> <br>  Un cambio de 64 bits dar√° como resultado un comportamiento indefinido de acuerdo con el est√°ndar del idioma. <br><br>  M√°s bien, el c√≥digo correcto deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bitshift == <span class="hljs-number"><span class="hljs-number">64</span></span>) available_bits = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> available_bits = G_GUINT64_CONSTANT(<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>) &gt;&gt; bitshift;</code> </pre> <br><h2>  Conclusi√≥n </h2><br>  Puede parecer que hay pocos ejemplos de errores en la revisi√≥n, pero en el informe completo los casos presentados se repiten docenas y cientos de veces.  Las descripciones generales de advertencia de PVS-Studio son solo para fines de demostraci√≥n.  Esta es una contribuci√≥n a la calidad de los proyectos de c√≥digo abierto, pero los controles √∫nicos son la forma m√°s ineficiente de aplicar la metodolog√≠a de an√°lisis est√°tico. <br><br>  Puede obtener y analizar el informe completo usted mismo.  Para hacer esto, solo necesita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargar</a> y ejecutar el analizador PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wireshark 3.x: an√°lisis de c√≥digo bajo macOS y revisi√≥n de errores</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447158/">https://habr.com/ru/post/447158/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447148/index.html">La aplicaci√≥n (des) oficial de Habr - HabrApp 2.0: acceso</a></li>
<li><a href="../447150/index.html">Chat en el sitio y en la emisi√≥n de Yandex</a></li>
<li><a href="../447152/index.html">Lanzamiento del kit de herramientas multiplataforma .NET UI AvaloniaUI 0.8</a></li>
<li><a href="../447154/index.html">Deuda t√©cnica que conduce a una crisis empresarial.</a></li>
<li><a href="../447156/index.html">Wireshark 3.x: an√°lisis de c√≥digo bajo macOS y revisi√≥n de errores</a></li>
<li><a href="../447160/index.html">Espacio para ni√±os. Algunas ideas para el d√≠a de la cosmon√°utica</a></li>
<li><a href="../447162/index.html">No compre ERP</a></li>
<li><a href="../447164/index.html">¬øC√≥mo combinar las ventajas de una computadora port√°til y una computadora de escritorio? An√°lisis de problemas y soluciones (Parte 2)</a></li>
<li><a href="../447166/index.html">Mesa de ayuda en 3 horas. Automatice procesos comerciales simples en PowerApps, Flow y Teams</a></li>
<li><a href="../447168/index.html">Sistema local de adquisici√≥n de datos aut√≥nomos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>