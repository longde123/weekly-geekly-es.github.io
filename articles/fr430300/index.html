<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 🏑 👨🏿‍💻 Microservices on Go avec le kit Go: Introduction 🏥 🤴 🐪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je décrirai l'utilisation du kit Go, un ensemble d'outils et de bibliothèques pour créer des micro-services sur Go. Cet article est ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microservices on Go avec le kit Go: Introduction</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/"><p>  Dans cet article, je décrirai l'utilisation du kit Go, un ensemble d'outils et de bibliothèques pour créer des micro-services sur Go.  Cet article est une introduction au kit Go.  La première partie de mon blog, le code source des exemples est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><a name="habracut"></a><br><p> Go est de plus en plus choisi pour le développement de systèmes distribués modernes.  Lorsque vous développez un système distribué basé sur le cloud, vous devrez peut-être prendre en charge diverses fonctionnalités spécifiques dans vos services, telles que: divers protocoles de transport ( <em>etc. trad. HTTP, gRPC, etc.</em> ) et formats de codage des messages pour eux, fiabilité RPC, journalisation , traçage, métriques et profilage, interruption des requêtes, limitation du nombre de requêtes, intégration dans l'infrastructure, voire description de l'architecture.  Go est un langage populaire en raison de sa simplicité et de ses approches «sans magie», donc les packages Go, par exemple, une bibliothèque standard, sont déjà plus adaptés pour développer des systèmes distribués que d'utiliser un cadre à part entière avec beaucoup de «magie sous le capot».  Personnellement, je [ <em>env.</em>  <em>trans.</em>  <em>Shiju Varghese</em> ] Je ne supporte pas l'utilisation de frameworks à part entière, je préfère utiliser des bibliothèques qui donnent plus de liberté au développeur.  Le kit Go a comblé une lacune dans l'écosystème Go, permettant d'utiliser un ensemble de bibliothèques et de packages lors de la création de microservices, qui à leur tour permettent l'utilisation de bons principes pour la conception de services individuels dans des systèmes distribués. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="image"></p><br><h3 id="vvedenie-v-go-kit">  Kit d'introduction à Go </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le kit Go</a> est un ensemble de packages Go qui facilitent la création de microservices fiables et pris en charge.  Le kit Go fournit des bibliothèques pour implémenter divers composants d'une architecture d'application transparente et fiable, en utilisant des couches telles que: la journalisation, les métriques, le traçage, la limitation et l'interruption des requêtes qui sont nécessaires pour exécuter des microservices sur le prod.  Le kit Go est bon car il dispose d'outils bien mis en œuvre pour interagir avec diverses infrastructures, formats d'encodage de messages et différentes couches de transport. </p><br><p>  En plus de l'ensemble des bibliothèques pour les services du monde en développement, il fournit et encourage l'utilisation de bons principes pour concevoir l'architecture de vos services.  Le kit Go vous aide à adhérer aux principes SOLID, à l'approche orientée sujet (DDD) et à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture hexagonale</a> proposés par <em>Alistair Cockburn</em> ou à toute autre approche issue des principes architecturaux connus sous le nom de « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture oignon</a> » par <em>Jeffrey Palermo</em> et « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture propre</a> » par <em>Robert C. Martin</em> .  Bien que le kit Go ait été conçu comme un ensemble de packages pour développer des microservices, il convient également pour développer des monolithes élégants. </p><br><h3 id="arhitektura-go-kit">  Kit Architecture Go </h3><br><p>  Les trois niveaux principaux de l'architecture des applications développées à l'aide du kit Go sont: </p><br><ul><li>  niveau de transport </li><li>  niveau de point final </li><li>  niveau de service </li></ul><br><h4 id="transportnyy-uroven">  Niveau de transport </h4><br><p>  Lorsque vous écrivez des microservices pour des systèmes distribués, les services qu'ils contiennent doivent souvent communiquer entre eux à l'aide de divers protocoles de transport, tels que: HTTP ou gRPC, ou utiliser des systèmes pub / sub, tels que NATS.  La couche de transport dans le kit Go est liée à un protocole de transport spécifique (ci-après transport).  Le kit Go prend en charge divers transports pour votre service, tels que: HTTP, gRPC, NATS, AMQP et Thirft ( <em>environ. Vous pouvez également développer votre propre transport pour votre protocole</em> ).  Par conséquent, les services écrits à l'aide du kit Go se concentrent souvent sur la mise en œuvre d'une logique métier spécifique qui ne sait rien du transport utilisé, vous êtes libre d'utiliser différents transports pour le même service.  Par exemple, un service écrit dans le kit Go peut simultanément y accéder via HTTP et gRPC. </p><br><h4 id="endpointy">  Points de terminaison </h4><br><p>  Un point de terminaison ou un point de terminaison est la pierre angulaire fondamentale des services et des clients.  Dans le kit Go, le modèle de communication principal est RPC.  Le point final est présenté comme une méthode RPC distincte.  Chaque méthode de service du kit Go est convertie en point de terminaison, vous permettant de communiquer entre le serveur et le client dans le style RCP.  Chaque point de terminaison expose une méthode de service utilisant la couche Transport, qui à son tour utilise divers protocoles de transport, tels que HTTP ou gRPC.  Un point de terminaison séparé peut être exposé en dehors du service simultanément à l'aide de plusieurs transports ( <em>environ HTTP et gRPC selon différents ports</em> ). </p><br><h4 id="servisy">  Les services </h4><br><p>  La logique métier est implémentée dans la couche service.  Les services écrits avec le kit Go sont conçus comme des interfaces.  La logique métier dans la couche service contient le noyau principal de la logique métier, qui n'a besoin de rien savoir sur les points de terminaison utilisés ou un protocole de transport spécifique, comme HTTP ou gRPC, ou sur l'encodage ou le décodage des demandes et des réponses de divers types de messages.  Cela vous permettra d'adhérer à une architecture propre dans les services écrits à l'aide du kit Go.  Chaque méthode de service est convertie en point de terminaison à l'aide d'un adaptateur et exposée à l'extérieur à l'aide d'un transport spécifique.  Grâce à l'utilisation d'une architecture propre, une seule méthode peut être définie à l'aide de plusieurs transports en même temps. </p><br><h3 id="primery">  Des exemples </h3><br><p>  Et maintenant, regardons les couches décrites ci-dessus en utilisant un exemple d'application simple. </p><br><h4 id="biznes-logika-v-servise">  Logique métier au service </h4><br><p>  La logique métier du service est conçue à l'aide d'interfaces.  Nous considérerons l'exemple d'une commande en e-commerce: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  L'interface du service de commande fonctionne avec l'entité de domaine de commande: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Ici, nous implémentons l'interface du service Order: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  Demandes et réponses pour les points de terminaison RPC </h4><br><p>  Les méthodes de service sont exposées en tant que points de terminaison RPC.  Nous devons donc déterminer les types de messages ( <em>environ Per. DTO - objet de transfert de données</em> ) qui seront utilisés pour envoyer et recevoir des messages via des points de terminaison RPC.  Définissons maintenant les structures des types de demande et de réponse pour les points de terminaison RPC dans le service Order: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Aller aux points de terminaison du kit pour les méthodes de service comme les points de terminaison RPC </h4><br><p>  Le cœur de notre logique métier est séparé du reste du code et placé dans la couche de service, qui est exposée à l'aide de points de terminaison RPC, qui utilisent l'abstraction du kit Go appelée <code>Endpoint</code> . </p><br><p>  Voici à quoi ressemble le point final du kit Go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  Comme nous l'avons dit ci-dessus, le point final représente une méthode RPC distincte.  Chaque méthode de service est convertie en <code>endpoint.Endpoint</code> aide d'adaptateurs.  Faisons les kits d'extrémité du kit Go pour les méthodes de service de commande: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  L'adaptateur de point de terminaison prend l'interface comme argument à l'entrée et la convertit en <code>endpoint.Enpoint</code> kit d'abstraction Go. <code>endpoint.Enpoint</code> faisant de chaque méthode de service individuelle un point de terminaison.  Cette fonction d'adaptateur effectue des conversions de comparaison et de type pour les demandes, appelle une méthode de service et renvoie un message de réponse. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Exposer un service à l'aide de HTTP </h4><br><p>  Nous avons créé notre service et décrit les points de terminaison RPC pour exposer nos méthodes de service.  Nous devons maintenant publier notre service à l'extérieur afin que d'autres services puissent appeler des points de terminaison RCP.  Pour exposer notre service, nous devons déterminer le protocole de transport pour notre service, selon lequel il acceptera les demandes.  Le kit Go prend en charge divers transports, tels que HTTP, gRPC, NATS, AMQP et Thrift prêts à l'emploi. </p><br><p>  Par exemple, nous utilisons le transport HTTP pour notre service.  Le package go kit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> offre la possibilité de servir les requêtes HTTP.  Et la fonction <code>NewServer</code> du <code>NewServer</code> <code>transport/http</code> créera un nouveau serveur http qui implémentera <code>http.Handler</code> et <code>http.Handler</code> les points de terminaison fournis. </p><br><p>  Vous trouverez ci-dessous le code qui convertit les points de terminaison du kit Go en un transport HTTP qui sert les requêtes HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  Nous créons <code>http.Handler</code> à l'aide de la fonction <code>NewServer</code> du <code>NewServer</code> <code>transport/http</code> , qui nous fournit des points de terminaison et demande des fonctions de décodage (renvoie la valeur de <code>type DecodeRequestFunc func</code> ) et un codage de réponse (par exemple, <code>type EncodeReponseFunc func</code> ). </p><br><p>  Voici des exemples de <code>DecodeRequestFunc</code> et <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  Démarrage du serveur HTTP </h4><br><p>  Enfin, nous pouvons exécuter notre serveur HTTP pour traiter les demandes.  La fonction <code>NewService</code> décrite ci-dessus implémente l'interface <code>http.Handler</code> qui nous permet de l'exécuter en tant que serveur HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Maintenant, notre service est lancé et utilise le protocole HTTP au niveau du transport.  Le même service peut être démarré à l'aide d'un autre transport. Par exemple, un service peut être exposé à l'aide de gRPC ou d'Apache Thrift. </p><br><p>  Pour l'article d'introduction, nous avons déjà suffisamment utilisé les primitives du kit Go, mais il fournit également plus de fonctionnalités pour créer des systèmes de modèles transparents et fiables, la découverte de services, l'équilibrage de charge, etc.  Nous en discuterons et d'autres dans le kit Go dans les articles suivants. </p><br><h3 id="ishodnyy-kod">  Code source </h3><br><p>  Le code source complet pour les exemples peut être consulté sur GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </p><br><h3 id="middlewares-v-go-kit">  Kit Middlewares in Go </h3><br><p>  Le kit Go prédispose à l'utilisation de bons principes de conception de système, tels que la superposition.  L'isolement des composants de service et des points d'extrémité est possible à l'aide de middlewares ( <em>modèle de médiateur de voie environ</em> ).  Les middlewares du kit Go fournissent un mécanisme puissant par lequel vous pouvez encapsuler des services et des points de terminaison et ajouter des fonctionnalités (composants isolés), telles que la journalisation, l'interruption des demandes, la limitation du nombre de demandes, l'équilibrage de charge ou le traçage distribué. </p><br><p>  Ci-dessous, une image du site Web du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kit Go</a> , qui est décrite comme une «architecture d'oignon» typique utilisant des middlewares dans le kit Go: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="image"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices">  Méfiez-vous du syndrome des microservices Spring Boot </h3><br><p>  Comme le kit Go, Spring Boot est une boîte à outils de microservices dans le monde Java.  Mais, contrairement au kit Go, Spring Boot est un framework très mature.  En outre, de nombreux développeurs Java utilisent Spring Boot pour créer des services mondiaux à l'aide de la pile Java avec des commentaires positifs sur l'utilisation, certains d'entre eux pensent que les microservices ne concernent que l'utilisation de Spring Boot.  Je vois de nombreuses équipes de développement qui interprètent mal l'utilisation des microservices, qui ne peuvent être développées qu'en utilisant Spring Boot et OSS Netflix et ne perçoivent pas les microservices comme un modèle lors du développement de systèmes distribués. </p><br><p>  Gardez donc à l'esprit qu'avec un ensemble d'outils, comme un kit Go ou une sorte de cadre, vous orientez votre développement vers les microseurises, comme modèle de conception.  Bien que les microservices résolvent de nombreux problèmes de mise à l'échelle des commandes et des systèmes, cela crée également de nombreux problèmes car les données des systèmes basés sur les microservices sont dispersées dans diverses bases de données, ce qui crée parfois de nombreux problèmes lors de la création de requêtes transactionnelles ou de données.  Tout dépend du problème du domaine et du contexte de votre système.  Ce qui est cool, c'est que le kit Go, conçu comme un outil pour créer des microservices, était également adapté pour créer des monolithes élégants qui sont créés avec une bonne architecture pour vos systèmes. </p><br><p>  Et certaines fonctionnalités du kit Go, telles que l'interruption et la restriction des demandes, sont également disponibles sur les plates-formes de maillage de service, comme Istio.  Donc, si vous utilisez quelque chose comme Istio pour lancer vos microseurises, vous n'aurez peut-être pas besoin de certaines choses du kit Go, mais tout le monde n'aura pas assez de largeur de canal pour utiliser le maillage de service pour créer une communication interservices, car cela ajoute plus un niveau et une complexité supplémentaire. </p><br><h2 id="ps">  PS </h2><br><p>  L'auteur de la traduction peut ne pas partager l'avis de l'auteur du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">texte original</a> , cet article a été traduit à des fins éducatives uniquement pour la communauté de langue russe Go. </p><br><p>  <strong>UPD</strong> <br>  Ceci est également le premier article de la section traduction et je vous serais reconnaissant de tout commentaire sur la traduction. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430300/">https://habr.com/ru/post/fr430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430286/index.html">Détails du côté désordonné et sombre des jeux de pirates pour Nintendo Switch</a></li>
<li><a href="../fr430290/index.html">Une tentative de prédire la quatrième itération du projet SpaceX BFR</a></li>
<li><a href="../fr430292/index.html">Electronic Frontier Foundation: la performance du réseau de plaques d'immatriculation de la police américaine est de 0,5%</a></li>
<li><a href="../fr430294/index.html">10 avantages évidents de l'utilisation de Rust</a></li>
<li><a href="../fr430296/index.html">Donnez vie à vos idées. Application sans serveur - instructions étape par étape</a></li>
<li><a href="../fr430302/index.html">Une introduction à ptrace ou à l'injection de code dans sshd pour le plaisir</a></li>
<li><a href="../fr430304/index.html">Un merveilleux avant-poste en orbite</a></li>
<li><a href="../fr430306/index.html">Le premier tunnel de la société Boring foré par Ilona Mask</a></li>
<li><a href="../fr430308/index.html">Internes Python. Oeufs de Pâques</a></li>
<li><a href="../fr430312/index.html">Validation de formes complexes de React. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>