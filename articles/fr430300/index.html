<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèø üèë üë®üèø‚Äçüíª Microservices on Go avec le kit Go: Introduction üè• ü§¥ üê™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je d√©crirai l'utilisation du kit Go, un ensemble d'outils et de biblioth√®ques pour cr√©er des micro-services sur Go. Cet article est ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microservices on Go avec le kit Go: Introduction</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/"><p>  Dans cet article, je d√©crirai l'utilisation du kit Go, un ensemble d'outils et de biblioth√®ques pour cr√©er des micro-services sur Go.  Cet article est une introduction au kit Go.  La premi√®re partie de mon blog, le code source des exemples est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><a name="habracut"></a><br><p> Go est de plus en plus choisi pour le d√©veloppement de syst√®mes distribu√©s modernes.  Lorsque vous d√©veloppez un syst√®me distribu√© bas√© sur le cloud, vous devrez peut-√™tre prendre en charge diverses fonctionnalit√©s sp√©cifiques dans vos services, telles que: divers protocoles de transport ( <em>etc. trad. HTTP, gRPC, etc.</em> ) et formats de codage des messages pour eux, fiabilit√© RPC, journalisation , tra√ßage, m√©triques et profilage, interruption des requ√™tes, limitation du nombre de requ√™tes, int√©gration dans l'infrastructure, voire description de l'architecture.  Go est un langage populaire en raison de sa simplicit√© et de ses approches ¬´sans magie¬ª, donc les packages Go, par exemple, une biblioth√®que standard, sont d√©j√† plus adapt√©s pour d√©velopper des syst√®mes distribu√©s que d'utiliser un cadre √† part enti√®re avec beaucoup de ¬´magie sous le capot¬ª.  Personnellement, je [ <em>env.</em>  <em>trans.</em>  <em>Shiju Varghese</em> ] Je ne supporte pas l'utilisation de frameworks √† part enti√®re, je pr√©f√®re utiliser des biblioth√®ques qui donnent plus de libert√© au d√©veloppeur.  Le kit Go a combl√© une lacune dans l'√©cosyst√®me Go, permettant d'utiliser un ensemble de biblioth√®ques et de packages lors de la cr√©ation de microservices, qui √† leur tour permettent l'utilisation de bons principes pour la conception de services individuels dans des syst√®mes distribu√©s. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="image"></p><br><h3 id="vvedenie-v-go-kit">  Kit d'introduction √† Go </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le kit Go</a> est un ensemble de packages Go qui facilitent la cr√©ation de microservices fiables et pris en charge.  Le kit Go fournit des biblioth√®ques pour impl√©menter divers composants d'une architecture d'application transparente et fiable, en utilisant des couches telles que: la journalisation, les m√©triques, le tra√ßage, la limitation et l'interruption des requ√™tes qui sont n√©cessaires pour ex√©cuter des microservices sur le prod.  Le kit Go est bon car il dispose d'outils bien mis en ≈ìuvre pour interagir avec diverses infrastructures, formats d'encodage de messages et diff√©rentes couches de transport. </p><br><p>  En plus de l'ensemble des biblioth√®ques pour les services du monde en d√©veloppement, il fournit et encourage l'utilisation de bons principes pour concevoir l'architecture de vos services.  Le kit Go vous aide √† adh√©rer aux principes SOLID, √† l'approche orient√©e sujet (DDD) et √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture hexagonale</a> propos√©s par <em>Alistair Cockburn</em> ou √† toute autre approche issue des principes architecturaux connus sous le nom de ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture oignon</a> ¬ª par <em>Jeffrey Palermo</em> et ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture propre</a> ¬ª par <em>Robert C. Martin</em> .  Bien que le kit Go ait √©t√© con√ßu comme un ensemble de packages pour d√©velopper des microservices, il convient √©galement pour d√©velopper des monolithes √©l√©gants. </p><br><h3 id="arhitektura-go-kit">  Kit Architecture Go </h3><br><p>  Les trois niveaux principaux de l'architecture des applications d√©velopp√©es √† l'aide du kit Go sont: </p><br><ul><li>  niveau de transport </li><li>  niveau de point final </li><li>  niveau de service </li></ul><br><h4 id="transportnyy-uroven">  Niveau de transport </h4><br><p>  Lorsque vous √©crivez des microservices pour des syst√®mes distribu√©s, les services qu'ils contiennent doivent souvent communiquer entre eux √† l'aide de divers protocoles de transport, tels que: HTTP ou gRPC, ou utiliser des syst√®mes pub / sub, tels que NATS.  La couche de transport dans le kit Go est li√©e √† un protocole de transport sp√©cifique (ci-apr√®s transport).  Le kit Go prend en charge divers transports pour votre service, tels que: HTTP, gRPC, NATS, AMQP et Thirft ( <em>environ. Vous pouvez √©galement d√©velopper votre propre transport pour votre protocole</em> ).  Par cons√©quent, les services √©crits √† l'aide du kit Go se concentrent souvent sur la mise en ≈ìuvre d'une logique m√©tier sp√©cifique qui ne sait rien du transport utilis√©, vous √™tes libre d'utiliser diff√©rents transports pour le m√™me service.  Par exemple, un service √©crit dans le kit Go peut simultan√©ment y acc√©der via HTTP et gRPC. </p><br><h4 id="endpointy">  Points de terminaison </h4><br><p>  Un point de terminaison ou un point de terminaison est la pierre angulaire fondamentale des services et des clients.  Dans le kit Go, le mod√®le de communication principal est RPC.  Le point final est pr√©sent√© comme une m√©thode RPC distincte.  Chaque m√©thode de service du kit Go est convertie en point de terminaison, vous permettant de communiquer entre le serveur et le client dans le style RCP.  Chaque point de terminaison expose une m√©thode de service utilisant la couche Transport, qui √† son tour utilise divers protocoles de transport, tels que HTTP ou gRPC.  Un point de terminaison s√©par√© peut √™tre expos√© en dehors du service simultan√©ment √† l'aide de plusieurs transports ( <em>environ HTTP et gRPC selon diff√©rents ports</em> ). </p><br><h4 id="servisy">  Les services </h4><br><p>  La logique m√©tier est impl√©ment√©e dans la couche service.  Les services √©crits avec le kit Go sont con√ßus comme des interfaces.  La logique m√©tier dans la couche service contient le noyau principal de la logique m√©tier, qui n'a besoin de rien savoir sur les points de terminaison utilis√©s ou un protocole de transport sp√©cifique, comme HTTP ou gRPC, ou sur l'encodage ou le d√©codage des demandes et des r√©ponses de divers types de messages.  Cela vous permettra d'adh√©rer √† une architecture propre dans les services √©crits √† l'aide du kit Go.  Chaque m√©thode de service est convertie en point de terminaison √† l'aide d'un adaptateur et expos√©e √† l'ext√©rieur √† l'aide d'un transport sp√©cifique.  Gr√¢ce √† l'utilisation d'une architecture propre, une seule m√©thode peut √™tre d√©finie √† l'aide de plusieurs transports en m√™me temps. </p><br><h3 id="primery">  Des exemples </h3><br><p>  Et maintenant, regardons les couches d√©crites ci-dessus en utilisant un exemple d'application simple. </p><br><h4 id="biznes-logika-v-servise">  Logique m√©tier au service </h4><br><p>  La logique m√©tier du service est con√ßue √† l'aide d'interfaces.  Nous consid√©rerons l'exemple d'une commande en e-commerce: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  L'interface du service de commande fonctionne avec l'entit√© de domaine de commande: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Ici, nous impl√©mentons l'interface du service Order: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  Demandes et r√©ponses pour les points de terminaison RPC </h4><br><p>  Les m√©thodes de service sont expos√©es en tant que points de terminaison RPC.  Nous devons donc d√©terminer les types de messages ( <em>environ Per. DTO - objet de transfert de donn√©es</em> ) qui seront utilis√©s pour envoyer et recevoir des messages via des points de terminaison RPC.  D√©finissons maintenant les structures des types de demande et de r√©ponse pour les points de terminaison RPC dans le service Order: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Aller aux points de terminaison du kit pour les m√©thodes de service comme les points de terminaison RPC </h4><br><p>  Le c≈ìur de notre logique m√©tier est s√©par√© du reste du code et plac√© dans la couche de service, qui est expos√©e √† l'aide de points de terminaison RPC, qui utilisent l'abstraction du kit Go appel√©e <code>Endpoint</code> . </p><br><p>  Voici √† quoi ressemble le point final du kit Go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  Comme nous l'avons dit ci-dessus, le point final repr√©sente une m√©thode RPC distincte.  Chaque m√©thode de service est convertie en <code>endpoint.Endpoint</code> aide d'adaptateurs.  Faisons les kits d'extr√©mit√© du kit Go pour les m√©thodes de service de commande: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  L'adaptateur de point de terminaison prend l'interface comme argument √† l'entr√©e et la convertit en <code>endpoint.Enpoint</code> kit d'abstraction Go. <code>endpoint.Enpoint</code> faisant de chaque m√©thode de service individuelle un point de terminaison.  Cette fonction d'adaptateur effectue des conversions de comparaison et de type pour les demandes, appelle une m√©thode de service et renvoie un message de r√©ponse. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Exposer un service √† l'aide de HTTP </h4><br><p>  Nous avons cr√©√© notre service et d√©crit les points de terminaison RPC pour exposer nos m√©thodes de service.  Nous devons maintenant publier notre service √† l'ext√©rieur afin que d'autres services puissent appeler des points de terminaison RCP.  Pour exposer notre service, nous devons d√©terminer le protocole de transport pour notre service, selon lequel il acceptera les demandes.  Le kit Go prend en charge divers transports, tels que HTTP, gRPC, NATS, AMQP et Thrift pr√™ts √† l'emploi. </p><br><p>  Par exemple, nous utilisons le transport HTTP pour notre service.  Le package go kit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> offre la possibilit√© de servir les requ√™tes HTTP.  Et la fonction <code>NewServer</code> du <code>NewServer</code> <code>transport/http</code> cr√©era un nouveau serveur http qui impl√©mentera <code>http.Handler</code> et <code>http.Handler</code> les points de terminaison fournis. </p><br><p>  Vous trouverez ci-dessous le code qui convertit les points de terminaison du kit Go en un transport HTTP qui sert les requ√™tes HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  Nous cr√©ons <code>http.Handler</code> √† l'aide de la fonction <code>NewServer</code> du <code>NewServer</code> <code>transport/http</code> , qui nous fournit des points de terminaison et demande des fonctions de d√©codage (renvoie la valeur de <code>type DecodeRequestFunc func</code> ) et un codage de r√©ponse (par exemple, <code>type EncodeReponseFunc func</code> ). </p><br><p>  Voici des exemples de <code>DecodeRequestFunc</code> et <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  D√©marrage du serveur HTTP </h4><br><p>  Enfin, nous pouvons ex√©cuter notre serveur HTTP pour traiter les demandes.  La fonction <code>NewService</code> d√©crite ci-dessus impl√©mente l'interface <code>http.Handler</code> qui nous permet de l'ex√©cuter en tant que serveur HTTP: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Maintenant, notre service est lanc√© et utilise le protocole HTTP au niveau du transport.  Le m√™me service peut √™tre d√©marr√© √† l'aide d'un autre transport. Par exemple, un service peut √™tre expos√© √† l'aide de gRPC ou d'Apache Thrift. </p><br><p>  Pour l'article d'introduction, nous avons d√©j√† suffisamment utilis√© les primitives du kit Go, mais il fournit √©galement plus de fonctionnalit√©s pour cr√©er des syst√®mes de mod√®les transparents et fiables, la d√©couverte de services, l'√©quilibrage de charge, etc.  Nous en discuterons et d'autres dans le kit Go dans les articles suivants. </p><br><h3 id="ishodnyy-kod">  Code source </h3><br><p>  Le code source complet pour les exemples peut √™tre consult√© sur GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </p><br><h3 id="middlewares-v-go-kit">  Kit Middlewares in Go </h3><br><p>  Le kit Go pr√©dispose √† l'utilisation de bons principes de conception de syst√®me, tels que la superposition.  L'isolement des composants de service et des points d'extr√©mit√© est possible √† l'aide de middlewares ( <em>mod√®le de m√©diateur de voie environ</em> ).  Les middlewares du kit Go fournissent un m√©canisme puissant par lequel vous pouvez encapsuler des services et des points de terminaison et ajouter des fonctionnalit√©s (composants isol√©s), telles que la journalisation, l'interruption des demandes, la limitation du nombre de demandes, l'√©quilibrage de charge ou le tra√ßage distribu√©. </p><br><p>  Ci-dessous, une image du site Web du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kit Go</a> , qui est d√©crite comme une ¬´architecture d'oignon¬ª typique utilisant des middlewares dans le kit Go: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="image"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices">  M√©fiez-vous du syndrome des microservices Spring Boot </h3><br><p>  Comme le kit Go, Spring Boot est une bo√Æte √† outils de microservices dans le monde Java.  Mais, contrairement au kit Go, Spring Boot est un framework tr√®s mature.  En outre, de nombreux d√©veloppeurs Java utilisent Spring Boot pour cr√©er des services mondiaux √† l'aide de la pile Java avec des commentaires positifs sur l'utilisation, certains d'entre eux pensent que les microservices ne concernent que l'utilisation de Spring Boot.  Je vois de nombreuses √©quipes de d√©veloppement qui interpr√®tent mal l'utilisation des microservices, qui ne peuvent √™tre d√©velopp√©es qu'en utilisant Spring Boot et OSS Netflix et ne per√ßoivent pas les microservices comme un mod√®le lors du d√©veloppement de syst√®mes distribu√©s. </p><br><p>  Gardez donc √† l'esprit qu'avec un ensemble d'outils, comme un kit Go ou une sorte de cadre, vous orientez votre d√©veloppement vers les microseurises, comme mod√®le de conception.  Bien que les microservices r√©solvent de nombreux probl√®mes de mise √† l'√©chelle des commandes et des syst√®mes, cela cr√©e √©galement de nombreux probl√®mes car les donn√©es des syst√®mes bas√©s sur les microservices sont dispers√©es dans diverses bases de donn√©es, ce qui cr√©e parfois de nombreux probl√®mes lors de la cr√©ation de requ√™tes transactionnelles ou de donn√©es.  Tout d√©pend du probl√®me du domaine et du contexte de votre syst√®me.  Ce qui est cool, c'est que le kit Go, con√ßu comme un outil pour cr√©er des microservices, √©tait √©galement adapt√© pour cr√©er des monolithes √©l√©gants qui sont cr√©√©s avec une bonne architecture pour vos syst√®mes. </p><br><p>  Et certaines fonctionnalit√©s du kit Go, telles que l'interruption et la restriction des demandes, sont √©galement disponibles sur les plates-formes de maillage de service, comme Istio.  Donc, si vous utilisez quelque chose comme Istio pour lancer vos microseurises, vous n'aurez peut-√™tre pas besoin de certaines choses du kit Go, mais tout le monde n'aura pas assez de largeur de canal pour utiliser le maillage de service pour cr√©er une communication interservices, car cela ajoute plus un niveau et une complexit√© suppl√©mentaire. </p><br><h2 id="ps">  PS </h2><br><p>  L'auteur de la traduction peut ne pas partager l'avis de l'auteur du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">texte original</a> , cet article a √©t√© traduit √† des fins √©ducatives uniquement pour la communaut√© de langue russe Go. </p><br><p>  <strong>UPD</strong> <br>  Ceci est √©galement le premier article de la section traduction et je vous serais reconnaissant de tout commentaire sur la traduction. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430300/">https://habr.com/ru/post/fr430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430286/index.html">D√©tails du c√¥t√© d√©sordonn√© et sombre des jeux de pirates pour Nintendo Switch</a></li>
<li><a href="../fr430290/index.html">Une tentative de pr√©dire la quatri√®me it√©ration du projet SpaceX BFR</a></li>
<li><a href="../fr430292/index.html">Electronic Frontier Foundation: la performance du r√©seau de plaques d'immatriculation de la police am√©ricaine est de 0,5%</a></li>
<li><a href="../fr430294/index.html">10 avantages √©vidents de l'utilisation de Rust</a></li>
<li><a href="../fr430296/index.html">Donnez vie √† vos id√©es. Application sans serveur - instructions √©tape par √©tape</a></li>
<li><a href="../fr430302/index.html">Une introduction √† ptrace ou √† l'injection de code dans sshd pour le plaisir</a></li>
<li><a href="../fr430304/index.html">Un merveilleux avant-poste en orbite</a></li>
<li><a href="../fr430306/index.html">Le premier tunnel de la soci√©t√© Boring for√© par Ilona Mask</a></li>
<li><a href="../fr430308/index.html">Internes Python. Oeufs de P√¢ques</a></li>
<li><a href="../fr430312/index.html">Validation de formes complexes de React. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>