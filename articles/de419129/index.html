<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ»â€ğŸ­ ğŸ§—ğŸ¼ âœ‹ğŸ¿ Multiagentensysteme beim Aufbau virtueller RÃ¤ume ğŸ”§ ğŸš ğŸ¤›ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eines der kritischen Probleme beim Erstellen von Mehrbenutzersystemen ist die Skalierung. FÃ¼r diese Probleme gibt es verschiedene LÃ¶sungen: Sharding, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multiagentensysteme beim Aufbau virtueller RÃ¤ume</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/419129/">  Eines der kritischen Probleme beim Erstellen von Mehrbenutzersystemen ist die Skalierung.  FÃ¼r diese Probleme gibt es verschiedene LÃ¶sungen: Sharding, Servicemodell, Entity-Component-System.  Heute werden wir alle Optionen prÃ¼fen und auch einen praktischen Fall zur LÃ¶sung des Problems erÃ¶rtern.  Jetzt mitmachen! <br><br><img src="https://habrastorage.org/webt/s1/_h/go/s1_hgomg5gsnukfd8hs4gdql6so.jpeg"><a name="habracut"></a><br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1.</a></b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2.</a></b> <br><br>  <i>Ich gebe das Wort an die Autoren weiter.</i> <br><br><h2>  Traditionelle AnsÃ¤tze zum Aufbau von Mehrbenutzersystemen.  Servicearchitektur </h2><br>  In der Vergangenheit war die erste Methode zur LÃ¶sung des Skalierungsproblems das Sharding - die Aufteilung des gesamten Systems in eine Reihe von Servern nach einem beliebigen Kriterium ohne allgemeinen Zustand der Welt.  Das heiÃŸt, bis zu einer bestimmten Anzahl von Benutzern kÃ¶nnen sie sich auf demselben Server befinden, sich sehen und miteinander interagieren.  Beim HinzufÃ¼gen neuer Dateien wurden jedoch Kopien des virtuellen Speicherplatzes auf einem anderen Server ausgefÃ¼hrt und konnten dementsprechend nicht mit anderen interagieren.  Es ist klar, dass dies keine LÃ¶sung fÃ¼r das Problem ist, sondern eine Problemumgehung.  Und obwohl Sharding auch jetzt noch Sinn macht, sind in vielen FÃ¤llen AnsÃ¤tze erforderlich, die die mÃ¶gliche Belastung des Servers wirklich erhÃ¶hen kÃ¶nnen. <br><br>  Die zweite Ã¼bliche Technik ist das Servicemodell.  Der Server verfÃ¼gt Ã¼ber eine Reihe von Komponenten, die leicht dupliziert werden kÃ¶nnen.  Dies ist beispielsweise eine Datenbank, die mit ihr arbeitet, oder ein Asset-Server, der sie an einen Client oder einen Autorisierungsserver sendet.  Alle diese Dienste zeichnen sich dadurch aus, dass Sie sie in mehreren Instanzen haben und Anforderungen fÃ¼r sie parallelisieren kÃ¶nnen. <br><br><h2>  Das Hauptproblem ist der gemeinsame Zustand </h2><br>  Das Hauptproblem ist jedoch anders.  Was tun mit einem bestimmten Zustand der Welt, dem Zustand des virtuellen Raums?  Angenommen, unsere â€Weltâ€œ besteht aus einer 3D-Szene, einer Reihe von Objekten und mehreren verbundenen Benutzern.  Theoretisch kÃ¶nnen wir einige Softwarekomponenten duplizieren, die fÃ¼r die Arbeit mit der Szene auf der Serverseite verantwortlich sind.  Das Problem ist jedoch, dass der Zustand der Szene allen diesen Komponenten gemeinsam ist.  Dementsprechend mÃ¼ssen wir bei der Parallelisierung der Handler das Problem der Synchronisierung der Arbeit mit Daten irgendwie lÃ¶sen, und gleichzeitig kÃ¶nnen wir bei der Synchronisierung selbst mehr an Leistung verlieren als an ParallelitÃ¤t gewinnen. <br><br><h2>  LÃ¶sung: Entity-Component-System.  Probleme im Fernen Osten </h2><br>  Einer der relativ neuen AnsÃ¤tze fÃ¼r solche Probleme ist ECS (Entity - Component System).  In dieser Version stellen wir das Objekt des Systems als eine bestimmte EntitÃ¤t dar, die einige Eigenschaften hat.  Dies kann beispielsweise die Position eines Objekts im Raum und seine Geschwindigkeit sein.  DarÃ¼ber hinaus speichern wir nur einige Daten auf dem Objekt selbst, aber nicht die Logik, mit ihnen zu arbeiten.  Das heiÃŸt, in unserem Fall werden dem Objekt einfach sechs Zahlen zugewiesen - der Koordinatenvektor und der Geschwindigkeitsvektor. <br><br>  Der zweite Teil von ECS ist Worker, ein System, das mit einem bestimmten Komponententyp arbeitet.  In unserem Fall kann es sich beispielsweise um ein System handeln, das die Koordinaten eines Objekts jede Sekunde Ã¤ndert und ihnen Geschwindigkeit verleiht.  Die Hauptidee ist, dass der Worker nichts Ã¼ber das Objekt als solches weiÃŸ - es hat nur eine Warteschlange, eine Pipeline von Komponenten, die er nach bestimmten Regeln verarbeiten muss.  Dementsprechend kÃ¶nnen wir sowohl Arbeitnehmer als auch Dienstleistungen parallelisieren. <br><br><h2>  Agentensysteme als Methode zum Schreiben von parallelem Code </h2><br>  Der Multi-Agent-Ansatz ist ebenfalls keine besondere Neuheit, aber in letzter Zeit hat das Interesse an Agentensystemen zugenommen.  Es gibt eine Reihe ziemlich guter Artikel, die ausfÃ¼hrlich darÃ¼ber berichten. Deshalb listen wir hier nur die allgemeinsten Prinzipien solcher Systeme kurz auf: <br><br><ol><li>  Die Hauptkomponente des Systems ist eine Komponente, die als Agent oder Akteur bezeichnet wird.  In gewisser Weise Ã¤hnelt es einem Objekt, das jedem vertraut ist, aber der Schauspieler hat keine Ã¶ffentlichen Methoden. Die einzige MÃ¶glichkeit, mit ihm zu kommunizieren, besteht darin, ihm eine Nachricht zu senden. </li><li>  Um eine Nachricht an den Agenten zu senden, gibt es das Konzept der "Links".  Der Link bietet eine bestimmte Schnittstelle (in verschiedenen Implementierungen kann sie sehr unterschiedlich aussehen), Ã¼ber die Sie Nachrichten senden kÃ¶nnen.  Eine der wichtigen Eigenschaften hierbei ist die Standorttransparenz und das Vorhandensein jedes Agenten mit einer Adresse - eine Zeichenfolge, mit der Sie unabhÃ¤ngig von seinem physischen Standort eine VerknÃ¼pfung zum Agenten herstellen kÃ¶nnen, d. H.  Der Agent kann sich auf demselben Computer oder mÃ¶glicherweise auf einem anderen Computer befinden und im Agentensystem arbeiten. In diesem Fall wird die Verbindung an einer bestimmten Netzwerkadresse hergestellt. </li><li>  Der Agent verfÃ¼gt Ã¼ber eine Nachrichtenwarteschlange, die nacheinander verarbeitet wird.  Ein Agent kann eine Zustandsmaschine sein, die ZustÃ¤nde und Nachrichtenhandler in der Reihenfolge ihrer Reaktion Ã¤ndert. </li><li>  Multiagentensysteme sind in der Regel hierarchisch, dh Agenten bilden eine Art Baum.  In diesem Fall stoppt ein Fehler in einem der Agenten nicht das gesamte System, sondern nur ein bestimmter Agent wird getrennt und sendet eine Fehlermeldung an seinen Vorfahren.  Einer der gÃ¤ngigen AnsÃ¤tze zur Behandlung solcher Fehler besteht darin, sie abstÃ¼rzen zu lassen. Wenn ein Agent abstÃ¼rzt, erstellen wir einfach eine neue Kopie davon. </li><li>  Das Erstellen eines neuen Agenten ist kein ressourcenintensiver Vorgang, und das Erstellen des Systems selbst ist sehr kostspielig. </li></ol><br>  Sehr oft werden Agentensysteme nur bei der Verwendung von ECS verwendet.  Da das Agentensystem es sehr einfach macht, die erforderliche Anzahl von Mitarbeitern zu erstellen und ihre Arbeit zu parallelisieren, indem einfach der Nachrichtenfluss zwischen ihnen verteilt wird, scheint dies ein sehr vielversprechender Ansatz zu sein.  So funktioniert beispielsweise SpatialOS von Improbable. <br><br>  Probleme treten hier in einer etwas anderen Ebene auf.  Der ECS-Ansatz ist recht einfach, kann aber im Prinzip nicht als intuitiv bezeichnet werden, insbesondere fÃ¼r unerfahrene Programmierer.  Daher ist die Erstellung von Benutzercode in einem solchen System eine nicht triviale Aufgabe.  AuÃŸerdem stellen sich Fragen zur PortabilitÃ¤t verschiedener Objekte zwischen virtuellen Serverinstanzen, da wir zusammen mit dem Objekt alle Worker Ã¼bertragen mÃ¼ssen, wenn sie (fÃ¼r diesen Komponententyp) nicht auf einem anderen Server vorhanden sind.  Im Prinzip kÃ¶nnen einige Implementierungen von Agentensystemen einige dieser Probleme lÃ¶sen, aber wir haben einen anderen Ansatz gewÃ¤hlt. <br><br><h2>  Unser Fall ist die Essenz des Fernen Ostens als Agent </h2><br>  In unserem Fall ist jedes virtuelle Raumobjekt ein Agent bzw. ein Agentensystem.  Im Vergleich zum klassischen ECS kÃ¶nnen wir sagen, dass jede EntitÃ¤t in uns ein System von â€Mikroarbeiternâ€œ hat, die an das Objekt selbst gebunden sind.  Gleichzeitig bleiben alle Vorteile des Agentensystems erhalten (dh wir kÃ¶nnen ein solches Objekt in einem separaten Thread, auf einem separaten Computer usw. ausfÃ¼hren, indem wir einfach die Servereinstellungen Ã¤ndern), aber das Objekt bleibt portabel, und das Schreiben von Skripten erfordert keine ECS-Aufteilung . <br><br>  In diesem Fall wird der Zustand der Welt in den Zustand einzelner Objekte unterteilt, und jedes von ihnen kann separat verarbeitet werden.  Auf dem Client erstellen wir auch ein Agentensystem, das den Status des Servers widerspiegelt, und ordnen jeden Client-Agenten dem Server-Agenten zu.  Dies erhÃ¶ht unter anderem auch die ZuverlÃ¤ssigkeit des Systems, da bei einem Ausfall eines einzelnen Objekts nur dieses Objekt deaktiviert wird und nicht der gesamte virtuelle Raum. <br>  Im Detail sieht es so aus: <br><br><img src="https://habrastorage.org/webt/81/at/0d/81at0dd-wlkdcnx5abgrktulxv0.png"><br><br>  Jedes Space-Objekt ist ein kleines Agentensystem, das aus dem Hauptagenten der EntitÃ¤t besteht, die beim Start des Servers erstellt wird. Dies ist kein Komponentencontainer-Agent und eine Reihe von Message-Handler-Komponenten.  Zum Verbinden des Clients wird die Eigenschaft Netzwerktransparenz verwendet, dh, jedes bestimmte Objekt auf dem Client verfÃ¼gt Ã¼ber eine VerknÃ¼pfung zum Serveragentenobjekt.  Gleichzeitig wird beim Verbinden dynamisch ein neuer Agent erstellt, der ein Nachkomme des Hauptagenten ist. <br><br><img src="https://habrastorage.org/webt/sx/zc/zj/sxzczji0iavh3gibmxwv9pkitm4.png"><br><br>  Ein Agentensystem wird auch auf der Clientseite erstellt, EntitÃ¤tsagenten darin werden jedoch durch eine Nachricht von der Serverseite gebildet.  Nach der Erstellung empfÃ¤ngt der Agent einen Link zum Serveragenten und erstellt eine Nachrichtenverarbeitungskomponente, die Warteschlangen zum Empfangen und Senden von Nachrichten vom Server enthÃ¤lt.  AuÃŸerdem wird ein Unity-Objekt erstellt, und Client-Teile der Komponenten des Objekts werden von MonoBehaviour geerbt.  Gleichzeitig arbeiten der Unity-Teil und der Agent-Teil in verschiedenen Threads. Der Message-Handler ist fÃ¼r die Synchronisation verantwortlich (wenn mÃ¶glich, wird diese minimiert). <br><br>  So etwas (ohne besondere Details) sieht aus wie die Implementierung eines dynamischen virtuellen Raums in der JIF-Variante.  Im nÃ¤chsten Artikel werden wir Sie Ã¼ber persÃ¶nliche Big Data und die Arbeit mit Statistiken sowie Ã¼ber Blockchain informieren. <br><br><h2>  Die Autoren </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jedium</a> ist ein Microsoft-Partnerunternehmen, das auf dem Gebiet der virtuellen, erweiterten RealitÃ¤t und kÃ¼nstlichen Intelligenz tÃ¤tig ist.  Jedium hat ein Framework entwickelt, um die Entwicklung komplexer Projekte auf Unity zu vereinfachen, von denen ein Teil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> Ã¶ffentlich verfÃ¼gbar ist.  Jedium plant, das Repository mit neuen Framework-Modulen sowie IntegrationslÃ¶sungen mit Microsoft Azure aufzufÃ¼llen. <br><br><img src="https://habrastorage.org/webt/jh/ag/3n/jhag3namj6wkh2bvqqo6_ftaj80.png" align="left" width="70">  <b>Vitaliy Chashchin</b> - Softwareentwickler mit mehr als 10 Jahren Erfahrung im Design und der Implementierung dreidimensionaler Client-Server-Anwendungen - vom Konzept bis zur vollstÃ¤ndigen Implementierung und Integration von Anwendungen und LÃ¶sungen im Bereich der virtuellen RealitÃ¤t.  Systemarchitekt Jedium LLC, MSc in IT. <br><br><img src="https://habrastorage.org/webt/v3/pv/lq/v3pvlqbh3g0yastjzzsrckofgeo.jpeg" align="left" width="70">  <b>Alexey Sarafanov</b> <br><br>  Marketing Manager bei Jedium LLC. <br><br><img src="https://habrastorage.org/webt/-7/j2/bl/-7j2bl1twtkxgfndf1a2xmzduzs.jpeg" align="left" width="70">  <b>Sergey Kudryavtsev</b> <br><br>  CEO und GrÃ¼nder von Jedium LLC. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419129/">https://habr.com/ru/post/de419129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419117/index.html">â€Es fÃ¤llt mir schwer, die Motivation eines Datenwissenschaftlers zu verstehen, der SchÃ¶nheit in der Mathematik nicht siehtâ€œ - Kirill Danilyuk, Datenwissenschaftler</a></li>
<li><a href="../de419119/index.html">Der Montblanc Premium Smart Pen ist der bisher teuerste Smart Pen</a></li>
<li><a href="../de419123/index.html">Die Nachteile von freiberuflichen Mitarbeitern. PersÃ¶nliche Erfahrung</a></li>
<li><a href="../de419125/index.html">Die RÃ¼ckkehr der sowjetischen Station. Analyse und Dokumente</a></li>
<li><a href="../de419127/index.html">Drei Reinkarnationen eines Online-Shops. Wie man Geld, Zeit und warum Vorlagen gut sind</a></li>
<li><a href="../de419131/index.html">Der vorlÃ¤ufige Starttermin des Mondmoduls SpaceIL wurde bekannt gegeben</a></li>
<li><a href="../de419133/index.html">Freitag Webinare: Lernen, kostenlos zu programmieren</a></li>
<li><a href="../de419135/index.html">Freitag JS: 0-Zeilen-JS- und CSS-Spiel</a></li>
<li><a href="../de419137/index.html">AktivitÃ¤tsprotokollierung mit der Web Beacon-API</a></li>
<li><a href="../de419141/index.html">Sex Phishing gewinnt in den USA zunehmend an Bedeutung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>