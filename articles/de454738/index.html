<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèª üî® üõåüèº Visual Studio 2019-Unterst√ºtzung in PVS-Studio üë®üèΩ‚Äç‚öïÔ∏è üë©üèª‚Äçüî¨ üèì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Unterst√ºtzung f√ºr Visual Studio 2019 in PVS-Studio betraf sofort mehrere verschiedene Komponenten: das IDE-Plug-In selbst, die Befehlszeilenanalys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visual Studio 2019-Unterst√ºtzung in PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454738/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  Die Unterst√ºtzung f√ºr Visual Studio 2019 in PVS-Studio betraf sofort mehrere verschiedene Komponenten: das IDE-Plug-In selbst, die Befehlszeilenanalyseanwendung, C ++ - und C # -Analysatoren sowie mehrere Dienstprogramme.  Ich werde kurz darauf eingehen, auf welche Probleme wir bei der Unterst√ºtzung der neuen Version der IDE gesto√üen sind und wie sie gel√∂st werden k√∂nnen. <br><a name="habracut"></a><br>  Bevor Sie beginnen, m√∂chte ich noch einmal auf die Geschichte der Unterst√ºtzung fr√ºherer Versionen von Visual Studio zur√ºckblicken, um ein besseres Verst√§ndnis unserer Vision der Aufgabe und der in bestimmten Situationen getroffenen Entscheidungen zu erhalten. <br><br>  Beginnend mit der ersten Version des PVS-Studio-Analysators, in der das Plug-In f√ºr die Visual Studio-Umgebung erschien (damals war es die Version von Visual Studio 2005), war die Unterst√ºtzung neuer Versionen von Visual Studio f√ºr uns eine recht einfache Aufgabe - im Grunde ging es darum, die Plug-In-Projektdatei und zu aktualisieren Abh√§ngigkeiten verschiedener Visual Studio-Erweiterungs-APIs.  Manchmal war es notwendig, zus√§tzlich neue Funktionen der C ++ - Sprache zu unterst√ºtzen, die der Visual C ++ - Compiler nach und nach lernte, aber dies verursachte normalerweise auch keine Probleme unmittelbar vor der Ver√∂ffentlichung der n√§chsten Ausgabe von Visual Studio.  Und damals gab es in PVS-Studio nur einen Analysator - f√ºr die Sprachen C und C ++. <br><br>  Mit der Ver√∂ffentlichung von Visual Studio 2017 hat sich alles ge√§ndert. Zus√§tzlich zu der Tatsache, dass sich viele der Erweiterungs-APIs f√ºr diese IDE in dieser Version erheblich ge√§ndert haben, hatten wir nach dem Update Probleme, die Abw√§rtskompatibilit√§t der Arbeit des neuen C # -Analysators sicherzustellen, der zu diesem Zeitpunkt erschienen war (sowie unserer neuen C ++ - Schicht Analyzer f√ºr MSBuild-Projekte) mit √§lteren Versionen von MSBuild \ Visual Studio. <br><br>  Bevor Sie diesen Artikel lesen, empfehle ich Ihnen daher dringend, den entsprechenden Artikel √ºber die Unterst√ºtzung von Visual Studio 2017 zu lesen: "Unterst√ºtzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio 2017 und Roslyn 2.0 in PVS-Studio: Manchmal ist die Verwendung vorgefertigter L√∂sungen nicht so einfach, wie es auf den ersten Blick scheint</a> ."  Der oben erw√§hnte Artikel beschreibt die Probleme, auf die wir beim letzten Mal gesto√üen sind, sowie die Interaktionsschemata verschiedener Komponenten (z. B. PVS-Studio, MSBuild, Roslyn).  Das Verst√§ndnis dieser Interaktion ist hilfreich, wenn Sie diesen Artikel lesen. <br><br>  Letztendlich brachte die L√∂sung dieser Probleme erhebliche √Ñnderungen an unserem Analysator mit sich, und wie wir gehofft hatten, werden die neuen Ans√§tze, die wir dann angewendet haben, es erm√∂glichen, aktualisierte Versionen von Visual Studio \ MSBuild in Zukunft viel einfacher und schneller zu unterst√ºtzen.  Zum Teil wurde diese Annahme bereits durch die Ver√∂ffentlichung zahlreicher Updates f√ºr Visual Studio 2017 best√§tigt. Hat dieser neue Ansatz bei der Unterst√ºtzung von Visual Studio 2019 geholfen?  Dar√ºber unten. <br><br><h2>  PVS-Studio Plugin f√ºr Visual Studio 2019 </h2><br>  Alles begann, wie es scheint, nicht schlecht.  Es war einfach genug, das Plug-In auf Visual Studio 2019 zu portieren, wo es gestartet wurde und einwandfrei funktionierte.  Trotzdem wurden sofort 2 Probleme aufgedeckt, die zuk√ºnftige Probleme versprachen. <br><br>  Die erste ist die <i>IVsSolutionWorkspaceService-</i> Schnittstelle, die zur Unterst√ºtzung des Lightweight Solution Load-Modus verwendet wird, der √ºbrigens in einem der vorherigen Updates in Visual Studio 2017 deaktiviert wurde und mit dem Attribut " <i>Veraltet" versehen wurde</i> , das nur eine Warnung w√§hrend der Montage war, aber in Zukunft mehr versprach Probleme.  Microsoft hat diesen Modus schnell eingef√ºhrt und aufgegeben ... Wir haben dieses Problem ganz einfach gel√∂st und uns geweigert, die entsprechende Benutzeroberfl√§che zu verwenden. <br><br>  Zweitens: Beim Laden von Visual Studio mit dem Plugin wurde die folgende Meldung angezeigt: <i>Visual Studio hat eine oder mehrere Erweiterungen erkannt, die gef√§hrdet sind oder in einem Feature-VS-Update nicht funktionieren.</i> <br><br>  Beim Anzeigen der Visual Studio-Startprotokolle (ActivityLog-Datei) wurde schlie√ülich das 'i' gepunktet: <br><br>  <i>Warnung: Die Erweiterung 'PVS-Studio' verwendet die Funktion 'Synchrones automatisches Laden' von Visual Studio.</i>  <i>Diese Funktion wird in einem zuk√ºnftigen Visual Studio 2019-Update nicht mehr unterst√ºtzt. Ab diesem Zeitpunkt funktioniert diese Erweiterung nicht mehr.</i>  <i>Bitte wenden Sie sich an den Anbieter der Erweiterung, um ein Update zu erhalten.</i> <br><br>  F√ºr uns bedeutete dies eines: √Ñndern der Art und Weise, wie das Plug-In in den asynchronen Modus geladen wird.  Ich hoffe, Sie werden nicht ver√§rgert sein, wenn ich Sie nicht mit Details zur Interaktion mit COM-Schnittstellen von Visual Studio √ºberlade, und ich werde die √Ñnderungen kurz genug durchgehen. <br><br>  Microsoft hat einen Artikel zum Erstellen asynchron geladener Plugins ver√∂ffentlicht: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gewusst wie: Verwenden von AsyncPackage zum Laden von VSPackages im Hintergrund</a> ".  Gleichzeitig war allen klar, dass sich die Angelegenheit nicht auf diese √Ñnderungen beschr√§nken w√ºrde. <br><br>  Eine der wichtigsten √Ñnderungen ist die Methode zum Laden bzw. Initialisieren.  Zuvor erfolgte die erforderliche Initialisierung in zwei Methoden - der √ºberschriebenen <i>Initialisierungsmethode</i> unserer <i>Paketvererbungsklasse</i> und der <i>OnShellPropertyChange-</i> Methode.  Die Notwendigkeit, einen Teil der Logik in die <i>OnShellPropertyChange-</i> Methode zu √ºbertragen, beruht auf der Tatsache, dass Visual Studio beim synchronen Laden des Plug- <i>Ins</i> m√∂glicherweise noch nicht vollst√§ndig geladen und initialisiert ist und daher in der Phase der Plug-In-Initialisierung m√∂glicherweise nicht alle erforderlichen Aktionen ausgef√ºhrt werden konnten.  Eine Option zur L√∂sung dieses Problems besteht darin, darauf zu warten, dass Visual Studio den Status "Zombie" beendet und diese Aktionen verz√∂gert.  Dies ist die Logik und wurde in <i>OnShellPropertyChange</i> mit einer √úberpr√ºfung des Zombie-Status gerendert. <br><br>  In der abstrakten <i>AsyncPackage-</i> Klasse, von der asynchron geladene Plugins geerbt werden, verf√ºgt die <i>Initialize-</i> Methode √ºber einen <i>versiegelten</i> Modifikator. Daher muss die <i>Initialisierung</i> in der √ºberschriebenen <i>InitializeAsync-</i> Methode erfolgen, die durchgef√ºhrt wurde.  Wir mussten auch die Logik √§ndern, indem wir den 'Zombie'-Status von Visual Studio verfolgten, da wir diese Informationen nicht mehr im Plugin erhielten.  Eine Reihe von Aktionen, die nach der Initialisierung des Plugins ausgef√ºhrt werden mussten, gingen jedoch nicht verloren.  Die <i>L√∂sung</i> bestand darin, die <i>OnPackageLoaded-</i> Methode der <i>IVsPackageLoadEvents-</i> Schnittstelle zu verwenden, mit der Aktionen ausgef√ºhrt wurden, die eine verz√∂gerte Ausf√ºhrung erforderten. <br><br>  Ein weiteres Problem, das sich logischerweise aus dem asynchronen Laden des Plugins ergibt, ist das Fehlen von PVS-Studio-Plugin-Befehlen zum Zeitpunkt des Starts von Visual Studio.  Wenn Sie das Analyseprotokoll durch Doppelklicken im Dateimanager √∂ffnen (falls Sie es √ºber Visual Studio √∂ffnen m√ºssen), wurde die erforderliche Version von devenv.exe mit dem Befehl zum √ñffnen des Analyseberichts gestartet.  Der Startbefehl sah ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  Das Flag "/ command" wird hier verwendet, um einen in Visual Studio registrierten Befehl aufzurufen.  Dieser Ansatz funktionierte nun nicht mehr, da die Befehle erst verf√ºgbar waren, als das Plug-In heruntergeladen wurde.  Infolgedessen musste ich nach dem Laden des Plugins und bei einer Zeichenfolgendarstellung des Befehls zum √ñffnen des Protokolls auf einer ‚ÄûKr√ºcke‚Äú anhalten, um die Startzeile von devenv.exe zu analysieren und das Protokoll tats√§chlich zu laden.  In diesem Fall war es daher m√∂glich, die erforderliche Funktionalit√§t beizubehalten, indem das Laden des Protokolls verz√∂gert wurde, bis das Plug-In vollst√§ndig geladen ist, nachdem es sich geweigert hatte, die ‚Äûrichtige‚Äú Schnittstelle f√ºr die Arbeit mit Befehlen zu verwenden. <br><br>  Fuh, es scheint gekl√§rt zu sein und alles funktioniert - alles wird richtig geladen und ge√∂ffnet, es gibt keine Warnungen - endlich. <br><br>  Und dann passiert das Unerwartete - Pavel (Hallo!) Installiert ein Plug-In, woraufhin er fragt, warum wir nicht asynchron geladen haben? <br><br>  Zu sagen, dass wir √ºberrascht waren - ganz zu schweigen - wie?  Nein, wirklich - hier ist die neue Version des Plugins installiert, hier ist die Meldung, dass das Paket synchron heruntergeladen werden kann.  Wir installieren mit Alexander (und hallo auch Ihnen) die gleiche Version des Plugins auf unseren Maschinen - alles ist in Ordnung.  Nichts ist klar - wir haben uns entschlossen zu sehen, welche Versionen der PVS-Studio-Bibliotheken in Visual Studio geladen wurden.  Und pl√∂tzlich stellt sich heraus, dass die Versionen der PVS-Studio-Bibliotheken f√ºr Visual Studio 2017 verwendet werden, obwohl die richtige Version der Bibliotheken im VSIX-Paket enthalten ist - f√ºr Visual Studio 2019. <br><br>  Nachdem ich an VSIXInstaller herumgebastelt hatte, gelang es mir, die Ursache des Problems zu finden - den Paket-Cache.  Die Theorie wurde auch durch die Tatsache best√§tigt, dass VSIXInstaller beim Einschr√§nken der Zugriffsrechte auf das Paket im Cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) Fehlerinformationen in das Protokoll schrieb.  Wenn kein Fehler vorliegt, werden √ºberraschenderweise keine Informationen dar√ºber, dass das Paket aus dem Cache installiert wurde, nicht in das Protokoll geschrieben. <br><br>  <b>Hinweis</b>  Als er das Verhalten von VSIXInstaller und verwandten Bibliotheken untersuchte, stellte er fest, dass es sehr cool ist, dass Roslyn und MSBuild Open Source-Code haben, der das Lesen, Debuggen und Verfolgen der Arbeitslogik erleichtert. <br><br>  Infolgedessen geschah Folgendes: Bei der Installation des Plugins stellte VSIXInstaller fest, dass sich das entsprechende Paket bereits im Cache befand (es gab ein .vsix-Paket f√ºr Visual Studio 2017), und verwendete es w√§hrend der Installation anstelle des tats√§chlich installierten Pakets.  Warum dies die in .vsixmanifest beschriebenen Einschr√§nkungen / Anforderungen nicht ber√ºcksichtigt (z. B. die Version von Visual Studio, f√ºr die Sie die Erweiterung installieren k√∂nnen), ist eine offene Frage.  Aus diesem Grund stellte sich heraus, dass das f√ºr Visual Studio 2017 entwickelte Plugin auf Visual Studio 2019 installiert wurde, obwohl .vsixmanifest die erforderlichen Einschr√§nkungen enthielt. <br><br>  Das Schlimmste ist, dass eine solche Installation das Abh√§ngigkeitsdiagramm von Visual Studio gebrochen hat, und obwohl es √§u√üerlich sogar so aussieht, als ob die Entwicklungsumgebung einwandfrei funktioniert, war tats√§chlich alles sehr schlecht.  Es war unm√∂glich, Erweiterungen zu installieren und zu deinstallieren, Updates vorzunehmen usw.  Der Prozess der "Genesung" war auch ziemlich unangenehm, weil  Es war erforderlich, die Erweiterung (die entsprechenden Dateien) zu l√∂schen und die Konfigurationsdateien, in denen Informationen zum installierten Paket gespeichert sind, manuell zu bearbeiten.  Im Allgemeinen ist es nicht angenehm genug. <br><br>  Um dieses Problem zu l√∂sen und √§hnliche Situationen in Zukunft zu vermeiden, wurde beschlossen, eine GUID f√ºr das neue Paket zu erstellen, um die Pakete Visual Studio 2017 und Visual Studio 2019 genau zu trennen (bei √§lteren Paketen gibt es kein solches Problem, und sie verwendeten immer eine gemeinsame GUID). <br><br>  Und da es sich um unangenehme √úberraschungen handelte, m√∂chte ich noch eines erw√§hnen: Nach dem Update auf Vorschau 2 wurde der Men√ºpunkt unter der Registerkarte "Erweiterungen" verschoben.  Es scheint in Ordnung zu sein, aber der Zugriff auf die Funktionen des Plugins ist weniger bequem geworden.  In nachfolgenden Versionen von Visual Studio 2019, einschlie√ülich der Release-Version, wurde dieses Verhalten beibehalten.  Ich habe zum Zeitpunkt der Ver√∂ffentlichung in der Dokumentation oder im Blog keine Erw√§hnung dieses "Features" gefunden. <br><br>  Nun scheint alles zu funktionieren und mit der Plug-In-Unterst√ºtzung f√ºr Visual Studio 2019 ist fertig.  Am Tag nach der Ver√∂ffentlichung von PVS-Studio 7.02 mit Unterst√ºtzung f√ºr Visual Studio 2019 stellte sich heraus, dass dies nicht der Fall war - ein weiteres Problem mit dem asynchronen Plug-In wurde gefunden.  F√ºr den Benutzer k√∂nnte dies folgenderma√üen aussehen: Beim √ñffnen eines Fensters mit den Ergebnissen der Analyse (oder beim Starten der Analyse) wurde unser Fenster manchmal als ‚Äûleer‚Äú angezeigt - es enthielt keinen Inhalt: Schaltfl√§chen, eine Tabelle mit Warnungen des Analysators usw. <br><br>  Tats√§chlich wurde dieses Problem im Laufe der Arbeit manchmal wiederholt.  Es wurde jedoch nur auf einem Computer wiederholt und erst nach dem Update von Visual Studio in einer der ersten Versionen von 'Preview' angezeigt. Es bestand der Verdacht, dass w√§hrend der Installation / Aktualisierung ein Fehler aufgetreten war.  Im Laufe der Zeit wiederholte sich das Problem jedoch auch auf dieser Maschine nicht mehr, und wir entschieden, dass es "von selbst repariert" wurde.  Es stellte sich heraus, dass nein - nur so viel Gl√ºck.  Genauer gesagt, kein Gl√ºck. <br><br>  Es stellte sich heraus, dass die Angelegenheit in der Reihenfolge der Initialisierung des Umgebungsfensters selbst (der Nachkomme der <i>ToolWindowPane-</i> Klasse) und seines Inhalts (in der Tat unserer Steuerung mit dem Raster und den Schaltfl√§chen) lag.  Unter bestimmten Bedingungen erfolgte die Initialisierung des Steuerelements vor der Initialisierung des Bereichs. Trotz der Tatsache, dass alles fehlerfrei funktionierte, <i>funktionierte</i> die <i>FindToolWindowAsync-</i> Methode (Erstellen eines Fensters beim ersten Aufruf) ordnungsgem√§√ü, das Steuerelement blieb jedoch unsichtbar.  Wir haben dies behoben, indem wir dem Fensterf√ºllcode eine verz√∂gerte Initialisierung f√ºr unser Steuerelement hinzugef√ºgt haben. <br><br><h2>  Unterst√ºtzt C # 8.0 </h2><br>  Die Verwendung von Roslyn als Basis f√ºr den Analysator hat einen erheblichen Vorteil: Es ist nicht erforderlich, neue Sprachkonstrukte manuell zu verwalten.  All dies wird im Rahmen der Microsoft.CodeAnalysis-Bibliotheken unterst√ºtzt und implementiert - wir verwenden vorgefertigte Ergebnisse.  Daher wird die Unterst√ºtzung f√ºr die neue Syntax durch Aktualisieren der Bibliotheken implementiert. <br><br>  In Bezug auf die statische Analyse m√ºssen Sie hier nat√ºrlich bereits alles selbst tun, insbesondere um neue Sprachkonstrukte zu verarbeiten.  Ja, wir erhalten den neuen Syntaxbaum automatisch mithilfe der neueren Version von Roslyn, aber wir m√ºssen dem Analysator beibringen, wie neue / ge√§nderte Knoten des Baums wahrgenommen und verarbeitet werden. <br><br>  Ich denke, die am meisten diskutierte Innovation in C # 8 sind die nullbaren Referenztypen.  Ich werde hier nicht dar√ºber schreiben - dies ist ein ziemlich gro√ües Thema, das eines separaten Artikels w√ºrdig ist (der bereits geschrieben wird).  Im Allgemeinen haben wir uns bisher darauf festgelegt, nullf√§hige Anmerkungen in unserem Datenflussmechanismus zu ignorieren (d. H. Wir verstehen, analysieren und √ºberspringen sie).  Tatsache ist, dass Sie trotz des nicht nullbaren Referenztyps der Variablen ganz einfach (oder aus Versehen) <i>null</i> darauf schreiben k√∂nnen, was zu NRE f√ºhren kann, wenn der entsprechende Link dereferenziert wird.  In diesem Fall kann unser Analysator trotz des nicht nullbaren Referenztyps der Variablen einen √§hnlichen Fehler erkennen und eine Warnung zur Verwendung einer potenziell Nullreferenz geben (nat√ºrlich, wenn eine solche Zuordnung im Code angezeigt wird). <br><br>  Ich m√∂chte darauf hinweisen, dass die Verwendung von nullbaren Referenztypen und der zugeh√∂rigen Syntax die M√∂glichkeit er√∂ffnet, sehr interessanten Code zu schreiben.  F√ºr uns selbst nannten wir dies die "emotionale Syntax".  Der folgende Code l√§sst sich recht gut kompilieren: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  √úbrigens habe ich im Laufe meiner Arbeit einige M√∂glichkeiten gefunden, Visual Studio mit der neuen Syntax zu "f√ºllen".  Tatsache ist, dass Sie die Anzahl der Zeichen nicht auf eins beschr√§nken k√∂nnen, wenn Sie '!' Geben.  Das hei√üt, Sie k√∂nnen nicht nur einen Code des Formulars schreiben: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  aber auch: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Sie k√∂nnen pervers sein, weitermachen und so schreiben: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Dieser Code wird erfolgreich kompiliert.  Wenn Sie jedoch mithilfe des Syntax Visualizer vom .NET Compiler Platform SDK Informationen zum Syntaxbaum anfordern, st√ºrzt Visual Studio ab. <br><br>  Informationen zum Problem erhalten Sie in der Ereignisanzeige: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Wenn Sie weiter gehen und die Anzahl der Ausrufezeichen mehrmals erh√∂hen, f√§llt Visual Studio von selbst aus - die Hilfe von Syntax Visualizer wird nicht mehr ben√∂tigt.  Die Microsoft.CodeAnalysis-Bibliotheken und der csc.exe-Compiler verarbeiten diesen Code ebenfalls nicht. <br><br>  Nat√ºrlich sind dies synthetische Beispiele, aber diese Tatsache kam mir trotzdem komisch vor. <br><br><h2>  Toolset </h2><br>  <b>Hinweis</b>  Ich stehe erneut vor dem Problem, das Wort "Bewertung" im Rahmen eines Gespr√§chs √ºber MSBuild-Projekte zu √ºbersetzen.  Die √úbersetzung, die in ihrer Bedeutung am n√§chsten zu sein schien und gleichzeitig normal klang, lautete ‚Äûein Projektmodell erstellen‚Äú.  Wenn Sie alternative √úbersetzungsoptionen haben - Sie k√∂nnen mir schreiben, es wird interessant sein zu lesen. <br><br>  Es war offensichtlich, dass das Aktualisieren des Toolset die zeitaufw√§ndigste Aufgabe sein w√ºrde.  Genauer gesagt schien es von Anfang an so, aber jetzt neige ich dazu zu glauben, dass die Plugin-Unterst√ºtzung am problematischsten war.  Dies war insbesondere auf das bereits vorhandene Toolset und den Mechanismus zum Erstellen des MSBuild-Projektmodells zur√ºckzuf√ºhren, das jetzt erfolgreich funktionierte, obwohl es erweitert werden musste.  Keine Notwendigkeit, Algorithmen von Grund auf neu zu schreiben, vereinfachte die Aufgabe erheblich.  Unsere Wette auf ‚Äûunser‚Äú Toolset, die zum Zeitpunkt der Unterst√ºtzung von Visual Studio 2017 abgeschlossen wurde, war erneut gerechtfertigt. <br><br>  Traditionell beginnt alles mit der Aktualisierung von NuGet-Paketen.  Auf der Registerkarte NuGet-Paketverwaltung f√ºr L√∂sungen befindet sich eine Schaltfl√§che "Aktualisieren", die nicht funktioniert.  Beim Aktualisieren aller Pakete traten Konflikte mit mehreren Versionen auf, und die L√∂sung aller Pakete schien nicht sehr korrekt zu sein.  Eine schmerzhaftere, aber anscheinend zuverl√§ssigere Methode besteht darin, die Microsoft.Build / Microsoft.CodeAnalysis-Zielpakete St√ºck f√ºr St√ºck zu aktualisieren. <br><br>  Einer der Unterschiede wurde sofort durch Tests von Diagnoseregeln festgestellt - die Struktur des Syntaxbaums f√ºr einen bereits vorhandenen Knoten hat sich ge√§ndert.  Es ist okay, schnell korrigiert. <br><br>  Ich m√∂chte Sie daran erinnern, dass wir w√§hrend der Arbeit Analyseger√§te (C #, C ++, Java) an Open Source-Projekten testen.  Auf diese Weise k√∂nnen Sie Diagnoseregeln gut testen - beispielsweise falsch positive Ergebnisse finden oder sich ein Bild davon machen, welche anderen F√§lle nicht ber√ºcksichtigt wurden (reduzieren Sie die Anzahl falsch negativer Ergebnisse).  Diese Tests helfen auch dabei, m√∂gliche Regressionen in der Anfangsphase der Aktualisierung von Bibliotheken / Toolset zu verfolgen.  Und diesmal war dies keine Ausnahme, da eine Reihe von Problemen auftauchten. <br><br>  Ein Problem war die Verschlechterung des Verhaltens in den CodeAnalysis-Bibliotheken.  Insbesondere bei einer Reihe von Projekten im Bibliothekscode traten bei verschiedenen Vorg√§ngen Ausnahmen auf - Abrufen semantischer Informationen, √ñffnen von Projekten usw. <br><br>  Aufmerksame Leser des Artikels √ºber die Unterst√ºtzung von Visual Studio 2017 denken daran, dass unser Distributionskit einen Stub enth√§lt - die Datei MSBuild.exe hat eine Gr√∂√üe von 0 Byte. <br><br>  Diesmal musste ich noch weiter gehen - jetzt enth√§lt das Distribution Kit auch leere Compiler-Stubs - csc.exe, vbc.exe, VBCSCompiler.exe.  Warum?  Der Weg dahin begann mit der Analyse eines der Projekte in der Testbasis, bei denen die ‚ÄûUnterschiede‚Äú der Berichte auftraten - bei Verwendung der neuen Version des Analysators fehlten einige Warnungen. <br><br>  Das Problem stellte sich als bedingte Kompilierungssymbole heraus. Bei der Analyse eines Projekts mit der neuen Version des Analysators wurden einige der Symbole falsch extrahiert.  Um besser zu verstehen, was dieses Problem verursachte, musste ich in die Roslyn-Bibliotheken eintauchen. <br><br>  Verwenden Sie zum <i>Analysieren</i> von bedingten Kompilierungszeichen die <i>GetDefineConstantsSwitch-</i> Methode der <i>Csc-</i> Klasse aus der <i>Microsoft.Build.Tasks.CodeAnalysis-</i> Bibliothek.  Das Parsen wird mit der <i>String.Split-</i> Methode f√ºr eine Reihe von Trennzeichen durchgef√ºhrt: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Diese Analysemethode funktioniert einwandfrei. Alle erforderlichen bedingten Kompilierungssymbole werden erfolgreich extrahiert.  Weiter graben. <br><br>  Der n√§chste wichtige Punkt ist der Aufruf der <i>ComputePathToTool-</i> Methode der <i>ToolTask-</i> Klasse.  Diese Methode erstellt den Pfad zur ausf√ºhrbaren Datei ( <i>csc.exe</i> ) und √ºberpr√ºft deren Vorhandensein.  Wenn die Datei vorhanden ist, wird der Pfad zu ihr zur√ºckgegeben, andernfalls wird <i>null</i> zur√ºckgegeben. <br><br>  Anrufercode: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Da es keine <i>csc.exe-</i> Datei gibt (es scheint - warum brauchen wir sie?), <i>Ist PathToTool</i> zu diesem Zeitpunkt <i>null</i> und die aktuelle Methode ( <i>ToolTask.Execute</i> ) schlie√üt ihre Ausf√ºhrung mit dem Ergebnis <i>false ab</i> .  Infolgedessen werden die Ergebnisse der Aufgabe, einschlie√ülich der resultierenden bedingten Kompilierungssymbole, ignoriert. <br><br>  Mal sehen, was passiert, wenn Sie die Datei <i>csc.exe</i> am erwarteten Speicherort <i>ablegen</i> . <br><br>  In diesem Fall gibt <i>pathToTool</i> den tats√§chlichen Speicherort der vorhandenen Datei an und die Ausf√ºhrung der <i>ToolTask.Execute-</i> Methode wird fortgesetzt.  Der n√§chste wichtige Punkt ist der Aufruf der <i>ManagedCompiler.ExecuteTool-</i> Methode.  Und es beginnt wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  Die <i>SkipCompilerExecution-</i> Eigenschaft ist <i>true</i> (logischerweise kompilieren wir nicht wirklich).  Infolgedessen √ºberpr√ºft die aufrufende Methode (bereits erw√§hnte <i>ToolTask.Execute</i> ), ob der R√ºckkehrcode der <i>ExecuteTool-</i> Methode 0 ist, und schlie√üt in diesem <i>Fall</i> ihre Ausf√ºhrung mit dem Wert <i>true ab</i> .  Was Sie hinter <i>csc.exe hatten,</i> war da - der echte Compiler oder Leo Tolstois 'Krieg und Frieden' in Textform spielt keine Rolle. <br><br>  Infolgedessen ergibt sich das Hauptproblem aus der Tatsache, dass die Reihenfolge der Schritte in der folgenden Reihenfolge definiert ist: <br><br><ul><li>  √úberpr√ºfen Sie die Existenz des Compilers. </li><li>  √úberpr√ºfen Sie, ob der Compiler gestartet werden muss. </li></ul><br>  nicht umgekehrt.  Compiler-Stubs l√∂sen dieses Problem erfolgreich. <br><br>  Wie sind die Zeichen einer erfolgreichen Kompilierung entstanden, wenn die Datei csc.exe nicht erkannt wurde (und das Ergebnis der Aufgabe ignoriert wurde)? <br><br>  F√ºr diesen Fall gibt es eine Methode: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> aus der <i>Microsoft.CodeAnalysis.CSharp-</i> Bibliothek.  Das Parsen wird auch von der <i>String.Split-</i> Methode mit einer Reihe von Trennzeichen durchgef√ºhrt: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Beachten Sie den Unterschied zu den Trennzeichen der <i>Csc.GetDefineConstantsSwitch-</i> Methode?  In diesem Fall ist das Leerzeichen kein Trennzeichen.  Wenn bedingte Kompilierungszeichen mit einem Leerzeichen geschrieben wurden, werden sie durch diese Methode falsch analysiert. <br><br>  Diese Situation trat bei problematischen Projekten auf - bedingte Kompilierungszeichen wurden mit einem Leerzeichen in sie geschrieben und erfolgreich mit <i>GetDefineConstantsSwitch</i> , jedoch nicht mit <i>ParseConditionalCompilationSymbols analysiert</i> . <br><br>  Ein weiteres Problem, das sich nach der Aktualisierung der Bibliotheken zeigte, war die Verschlechterung des Verhaltens in einer Reihe von F√§llen, insbesondere bei Projekten, die nicht erfasst wurden.  Probleme traten in den Microsoft.CodeAnalysis-Bibliotheken auf und wurden in Form verschiedener Ausnahmen an uns zur√ºckgegeben - <i>ArgumentNullException</i> (einige interne Logger wurden nicht initialisiert), <i>NullReferenceException</i> und andere. <br><br>  Ich m√∂chte unten auf eines dieser Probleme eingehen - es schien mir ziemlich interessant zu sein. <br><br>  Dieses Problem ist beim √úberpr√ºfen der neuesten Version des Roslyn-Projekts <i>aufgetreten.</i> Aus dem Code einer der Bibliotheken wurde eine <i>NullReferenceException</i> ausgel√∂st.  Aufgrund ausreichend detaillierter Informationen zum Speicherort des Problems haben wir den Problemcode schnell gefunden und uns aus Gr√ºnden des Interesses entschlossen, zu pr√ºfen, ob das Problem bei der Arbeit in Visual Studio erneut auftritt. <br><br>  Nun - es war m√∂glich, es in Visual Studio zu reproduzieren (das Experiment wurde mit Visual Studio 16.0.3 durchgef√ºhrt).  Dazu ben√∂tigen wir eine Klassendefinition der folgenden Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Wir ben√∂tigen au√üerdem Syntax Visualizer (Teil des .NET Compiler Platform SDK).  Es ist erforderlich, <i>TypeSymbol</i> (Men√ºpunkt "View TypeSymbol (falls vorhanden)") vom Knoten des Syntaxbaums vom Typ <i>ConstantPatternSyntax</i> ( <i>null</i> ) anzufordern.  Danach wird Visual Studio neu gestartet und in der Ereignisanzeige k√∂nnen Sie Informationen zum Problem anzeigen, insbesondere den Stack-Trace: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Wie Sie sehen k√∂nnen, liegt die Ursache des Problems in der Dereferenzierung der Nullreferenz. <br><br>  Wie bereits erw√§hnt, ist beim Testen des Analysators das gleiche Problem aufgetreten.  Wenn Sie die Microsoft.CodeAnalysis-Debugbibliotheken zum Erstellen des Analysators verwenden, k√∂nnen Sie durch Debuggen an die genaue Stelle gelangen, indem Sie <i>TypeSymbol</i> vom gew√ºnschten Knoten im Syntaxbaum anfordern. <br><br>  Als Ergebnis gelangen wir zu der <i>ClassifyImplicitBuiltInConversionSlow-</i> Methode, die im <i>obigen</i> Stack-Trace erw√§hnt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Das Problem ist, dass der Zielparameter in diesem Fall <i>null</i> ist.  Dementsprechend wird beim Aufrufen von <i>destination.SpecialType eine</i> <i>NullReferenceException ausgel√∂st</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ja, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> h√∂her als die Dereferenzierung </font><font style="vertical-align: inherit;">, aber dies reicht nicht aus, da es tats√§chlich vor nichts sch√ºtzt - es hilft nur, das Problem in Debug-Versionen von Bibliotheken zu identifizieren. </font><font style="vertical-align: inherit;">Oder hilft nicht.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñnderungen beim Erstellen eines Modells von C ++ - Projekten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier passierte nichts besonders Interessantes - die alten Algorithmen erforderten keine wesentlichen Modifikationen, √ºber die es interessant w√§re zu sprechen. </font><font style="vertical-align: inherit;">Es gab vielleicht zwei Punkte, √ºber die es sinnvoll ist, nachzudenken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst mussten wir die Algorithmen √§ndern, die auf dem Wert von ToolsVersion beruhen, um im numerischen Format geschrieben zu werden. </font><font style="vertical-align: inherit;">Ohne auf Details einzugehen - es gibt mehrere F√§lle, in denen Sie Toolsets vergleichen und beispielsweise eine aktuellere neue Version ausw√§hlen m√ºssen. </font><font style="vertical-align: inherit;">Diese Version hatte jeweils einen h√∂heren numerischen Wert. </font><font style="vertical-align: inherit;">Es gab eine Berechnung, dass ToolsVersion, das der neuen Version von MSBuild / Visual Studio entspricht, 16.0 sein w√ºrde. </font><font style="vertical-align: inherit;">Wie auch immer ... Aus Gr√ºnden des Interesses zitiere ich eine Tabelle dar√ºber, wie sich die Werte verschiedener Eigenschaften in verschiedenen Versionen von Visual Studio ge√§ndert haben:</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio Produktname </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versionsnummer von Visual Studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tools-Version </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PlatformToolset-Version </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio 2010 </font></font><br></td><td>  10.0 <br></td><td>  4.0 <br></td><td>  100 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio 2012 </font></font><br></td><td>  11.0 <br></td><td>  4.0 <br></td><td>  110 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio 2013 </font></font><br></td><td>  12.0 <br></td><td>  12.0 <br></td><td>  120 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio 2015 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.0 </font></font><br></td><td>  140 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio 2017 </font></font><br></td><td>  15.0 <br></td><td>  15.0 <br></td><td>  141 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual Studio 2019 </font></font><br></td><td>  16.0 <br></td><td>  Strom <br></td><td>  142 <br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Witz ist nat√ºrlich veraltet, aber Sie m√ºssen sich an das √Ñndern von Windows- und Xbox-Versionen erinnern, um zu verstehen, dass die Vorhersage zuk√ºnftiger Werte (unabh√§ngig von Name und Version) im Fall von Microsoft eine wackelige Sache ist. </font></font> :) :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die L√∂sung war einfach genug: Einf√ºhrung der Priorisierung von Toolsets (Zuweisung einer separaten Priorit√§tseinheit). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Punkt sind Probleme beim Arbeiten in Visual Studio 2017 oder in einer angrenzenden Umgebung (z. B. das Vorhandensein der Umgebungsvariablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisualStudioVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Tatsache ist, dass die Berechnung der zum Erstellen eines Modells eines C ++ - Projekts erforderlichen Parameter viel komplizierter ist als das Erstellen eines Modells eines .NET-Projekts. Im Fall von .NET verwenden wir unser eigenes Toolset und den entsprechenden Wert von ToolsVersion. Im Fall von C ++ k√∂nnen wir sowohl auf unseren eigenen als auch auf vorhandenen Toolsets im System aufbauen. Beginnend mit Build - </font><font style="vertical-align: inherit;">Tool als Teil von Visual Studio 2017 toolset'y in der Datei vorgeschriebenen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSBuild.exe.config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nicht in der Registrierung. Dementsprechend k√∂nnen wir sie nicht aus der allgemeinen Liste der Toolsets abrufen (z. B. √ºber </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), im Gegensatz zu den in der Registrierung aufgezeichneten Toolsets (entsprechend &lt;= Visual Studio 2015). . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolge des Vorstehenden funktioniert es nicht, ein Projektmodell mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolsVersion 15.0 zu erstellen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , da das System das erforderliche Toolset nicht sieht. Das aktuellste Toolset - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuell</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Es wird zur gleichen Zeit verf√ºgbar sein, da dies unser eigenes Toolset ist. Daher gibt es f√ºr Visual Studio 2019 kein solches Problem. </font><font style="vertical-align: inherit;">Die L√∂sung erwies sich als einfach und erm√∂glichte es, das Problem zu l√∂sen, ohne die vorhandenen Algorithmen f√ºr die Erstellung des Projektmodells zu √§ndern. Zus√§tzlich zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current wurde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Liste der eigenen Toolsets ein </font><font style="vertical-align: inherit;">weiteres </font><font style="vertical-align: inherit;">hinzugef√ºgt </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñnderungen beim Erstellen eines Modells von C # .NET Core-Projekten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Rahmen dieser Aufgabe wurden 2 Probleme gleichzeitig gel√∂st, da sich herausstellte, dass sie miteinander zusammenh√§ngen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Hinzuf√ºgen des Toolset "Aktuell" funktionierte die Analyse von .NET Core-Projekten f√ºr Visual Studio 2017 nicht mehr. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Analyse von .NET Core-Projekten auf einem System, auf dem mindestens eine Version von Visual Studio nicht installiert war, funktionierte nicht. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem war in beiden F√§llen das gleiche - einige der grundlegenden .targets / .props-Dateien wurden falsch durchsucht. </font><font style="vertical-align: inherit;">Dies f√ºhrte dazu, dass mit unserem Toolset kein Projektmodell erstellt werden konnte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Abwesenheit von Visual Studio konnte ein solcher Fehler angezeigt werden (mit der vorherigen Version von toolset'a - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen des C # .NET Core-Modells des Projekts in Visual Studio 2017 kann das folgende Problem auftreten (mit der aktuellen Version des Toolset " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuell"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Probleme √§hnlich sind (aber es sieht so aus), k√∂nnen Sie versuchen, zwei Fliegen mit einer Klappe zu schlagen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Folgenden beschreibe ich, wie dieses Problem gel√∂st wurde, ohne auf technische Details einzugehen. Genau diese Details (zum Erstellen von Modellen f√ºr C # .NET Core-Projekte sowie zum √Ñndern der Konstruktion von Modellen in unserem Toolset) warten in einem unserer zuk√ºnftigen Artikel. √úbrigens, wenn Sie den obigen Text sorgf√§ltig lesen, werden Sie m√∂glicherweise feststellen, dass dies der zweite Verweis auf zuk√ºnftige Artikel ist.</font></font> :) :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie haben wir dieses Problem gel√∂st? Die L√∂sung bestand darin, unser eigenes Toolset auf Kosten der wichtigsten .targets / .props-Dateien aus dem .NET Core SDK ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.props</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.targets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zu erweitern. Dies erm√∂glichte uns mehr Kontrolle √ºber die Situation, mehr Flexibilit√§t bei der Verwaltung von Importen sowie bei der Erstellung eines Modells f√ºr .NET Core-Projekte im Allgemeinen. Ja, unser Toolset ist wieder etwas gewachsen, und wir mussten auch einige Logik hinzuf√ºgen, um die f√ºr die Erstellung des .NET Core-Modells erforderlichen Umgebungsprojekte einzurichten, aber es hat sich anscheinend gelohnt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher war das Arbeitsprinzip beim Erstellen eines Modells von .NET Core-Projekten wie folgt: Wir haben diese Konstruktion einfach angefordert, und dann hat alles auf Kosten von MSBuild funktioniert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nun mehr Kontrolle selbst in die Hand genommen haben, sieht es etwas anders aus:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorbereitung der Umgebung, die zum Erstellen eines Modells von .NET Core-Projekten erforderlich ist; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modellbau: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baubeginn mit .targets / .props-Dateien aus unserem Toolset'a; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fortsetzung der Konstruktion mit externen Dateien. </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus den oben beschriebenen Schritten geht hervor, dass das Einstellen der erforderlichen Umgebung zwei Hauptziele hat: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initiieren Sie die Modellbildung mit .targets / .props-Dateien aus Ihrem eigenen Toolset. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leiten Sie weitere Vorg√§nge in externe .targets / .props-Dateien um. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Suchen nach .targets / .props-Dateien, die zum Erstellen eines Modells von .NET Core-Projekten erforderlich sind, wird eine spezielle Bibliothek verwendet - Microsoft.DotNet.MSBuildSdkResolver. Die Initiierung des Erstellens mithilfe von Dateien aus unserem Toolset wurde mithilfe einer speziellen Umgebungsvariablen gel√∂st, die von dieser Bibliothek verwendet wird. Wir empfehlen, die erforderlichen Dateien (aus unserem Toolset) zu importieren. Da die Bibliothek Teil unserer Distribution ist, gibt es keine Bef√ºrchtungen, dass sich die Logik pl√∂tzlich √§ndert und nicht mehr funktioniert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden Sdk-Dateien zuerst aus unserem Toolset importiert. Da wir sie leicht √§ndern k√∂nnen, liegt die Kontrolle √ºber die weitere Logik zum Erstellen des Modells in unseren H√§nden. Daher k√∂nnen wir selbst bestimmen, welche Dateien von wo importiert werden m√ºssen. Dies gilt auch f√ºr die oben genannten Microsoft.Common.props. Wir importieren diese und andere Basisdateien aus unserem eigenen Toolset und vertrauen auf deren Verf√ºgbarkeit und Inhalt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die erforderlichen Importe abgeschlossen und eine Reihe von Eigenschaften festgelegt haben, √ºbertragen wir die weitere Steuerung der Modellbildung auf das eigentliche .NET Core SDK, wo die restlichen erforderlichen Aktionen ausgef√ºhrt werden.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen war die Unterst√ºtzung f√ºr Visual Studio 2019 einfacher als die Unterst√ºtzung f√ºr Visual Studio 2017, was meines Erachtens auf mehrere Faktoren zur√ºckzuf√ºhren ist. Erstens hat Microsoft nicht so viele Dinge ge√§ndert wie zwischen Visual Studio 2015 und Visual Studio 2017. Ja, wir haben das Haupt-Toolset ge√§ndert und begonnen, Plug-Ins f√ºr Visual Studio auf Asynchronit√§t auszurichten, aber dennoch. Die zweite - wir hatten bereits eine L√∂sung mit unserem eigenen Toolset und dem Erstellen von Projektmodellen - bestand darin, dass nicht alles neu erfunden werden musste. Es reichte aus, nur die vorhandene L√∂sung zu erweitern. Die relativ einfache Unterst√ºtzung f√ºr die Analyse von .NET Core-Projekten auf neue Bedingungen (sowie f√ºr Analysef√§lle auf einem Computer, auf dem keine Visual Studio-Instanzen installiert sind) aufgrund der Erweiterung unseres Systems zur Erstellung von Projektmodellen l√§sst auch hoffen, dass wir die richtige Wahl getroffen haben.Nachdem Sie beschlossen haben, die Kontrolle √ºber sich selbst zu √ºbernehmen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trotzdem m√∂chte ich noch einmal einen Gedanken aus dem vorherigen Artikel wiederholen - manchmal ist die Verwendung von vorgefertigten L√∂sungen nicht so einfach, wie es auf den ersten Blick scheint. </font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzung von Visual Studio 2019 in PVS-Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454738/">https://habr.com/ru/post/de454738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454728/index.html">Internetzugang ge√∂ffnet: Die LUWRAIN-Technologie hilft blinden Benutzern</a></li>
<li><a href="../de454730/index.html">Allure Server-Treffen: Videoaufzeichnungen von Berichten</a></li>
<li><a href="../de454732/index.html">5 Robuste Priorisierungstechniken f√ºr IT-Teams</a></li>
<li><a href="../de454734/index.html">Backup, Teil 4: √úbersicht und Testen von zbackup, restic, borgbackup</a></li>
<li><a href="../de454736/index.html">Unterst√ºtzung von Visual Studio 2019 in PVS-Studio</a></li>
<li><a href="../de454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../de454742/index.html">Mindestens ein Vim-Trick, von dem Sie nichts wussten</a></li>
<li><a href="../de454744/index.html">√úbersicht √ºber Java Track Reports von der RigaDevDays Konferenz</a></li>
<li><a href="../de454748/index.html">MongoDB Survival Guide</a></li>
<li><a href="../de454750/index.html">Schnelle Benutzeroberfl√§che - Galoppieren durch Europa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>