<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßê üÜì ü§ñ ¬øPor qu√© los procesadores Skylake a veces funcionan 2 veces m√°s lento? üåè üë©üèª‚Äçüè≠ ‚ôøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me informaron que en las computadoras nuevas, algunas pruebas de regresi√≥n se hicieron m√°s lentas. Una cosa com√∫n, sucede. Configuraci√≥n incorrecta en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© los procesadores Skylake a veces funcionan 2 veces m√°s lento?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415053/">  Me informaron que en las computadoras nuevas, algunas pruebas de regresi√≥n se hicieron m√°s lentas.  Una cosa com√∫n, sucede.  Configuraci√≥n incorrecta en alg√∫n lugar de Windows o no los valores m√°s √≥ptimos en el BIOS.  Pero esta vez no pudimos encontrar la misma configuraci√≥n "derribada".  Como el cambio es significativo: 9 frente a 19 segundos (en la tabla, el azul es el hierro viejo y el naranja el nuevo), tuve que cavar m√°s profundo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/6db/d57/4a96dbd573606b0a0aabc6a0874dd2fa.png"><br><a name="habracut"></a><br><h1>  Mismo sistema operativo, mismo hardware, procesador diferente: 2 veces m√°s lento </h1><br>  La ca√≠da en el rendimiento de 9.1 a 19.6 segundos definitivamente se puede llamar significativa.  Realizamos comprobaciones adicionales con un cambio en las versiones de los programas probados, la configuraci√≥n de Windows y BIOS.  Pero no, el resultado no ha cambiado.  La √∫nica diferencia apareci√≥ solo en diferentes procesadores.  A continuaci√≥n se muestra el resultado en la √∫ltima CPU. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a2/fc8/12e/6a2fc812e9f12ae4581b9ed3fd46c4b7.png"><br><br>  Y aqu√≠ est√° el que se usa para comparar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/f8b/d4f/e81f8bd4f20ffe609673ef3db6dd414d.png"><br><br>  Xeon Gold se ejecuta en una arquitectura diferente llamada Skylake, com√∫n a los nuevos procesadores Intel desde mediados de 2017.  Si compra el hardware m√°s reciente, obtendr√° un procesador con la arquitectura Skylake.  Estos son buenos autos, pero, como lo han demostrado las pruebas, la novedad y la velocidad no son lo mismo. <br><br>  Si nada m√°s ayuda, entonces necesita usar el generador de perfiles para una investigaci√≥n en profundidad.  Probemos en equipos viejos y nuevos y obtengamos algo como esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b3/6a3/98e/3b36a398e5ee9ce0950c1d940f3de9c7.png"><br><br>  La pesta√±a en Windows Performance Analyzer (WPA) muestra en la tabla la diferencia entre Trace 2 (11 s) y Trace 1 (19 s).  Una diferencia negativa en la tabla corresponde a un aumento en el consumo de CPU en una prueba m√°s lenta.  Si observa las diferencias m√°s significativas en el consumo de CPU, veremos <i>AwareLock :: Contention</i> , <i>JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel</i> y <i>ThreadNative.SpinWait</i> .  Todo indica un "giro" en la CPU [giro - un intento c√≠clico para obtener un bloqueo, aprox.  per.], cuando los hilos luchan por el bloqueo.  Pero esta es una marca falsa, porque el giro no es la raz√≥n principal de la disminuci√≥n de la productividad.  El aumento de la competencia por las cerraduras significa que algo en nuestro software se ha ralentizado y mantenido la cerradura, lo que como resultado condujo a un mayor giro en la CPU.  Verifiqu√© el tiempo de bloqueo y otros indicadores clave, como el rendimiento del disco, pero no pude encontrar nada significativo que pudiera explicar la degradaci√≥n del rendimiento.  Aunque esto no es l√≥gico, volv√≠ a aumentar la carga en la CPU en varios m√©todos. <br><br>  Ser√≠a interesante encontrar exactamente d√≥nde se atasca el procesador.  WPA tiene columnas de archivos y l√≠neas, pero solo funcionan con caracteres privados, que nosotros no tenemos, porque este es el c√≥digo de .NET Framework.  Lo mejor que podemos hacer es obtener la direcci√≥n dll donde se encuentra la instrucci√≥n llamada Image RVA.  Si carga este dll en el depurador y hace <br><br> <code>u xxx.dll+ImageRVA</code> <br> <br>  entonces deber√≠amos ver la instrucci√≥n que quema la mayor√≠a de los ciclos de la CPU, porque ser√° la √∫nica direcci√≥n "activa". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/54e/e7b/9fe54ee7bfe194a0e6fec932148f730c.png"><br><br>  Examinaremos esta direcci√≥n utilizando varios m√©todos de Windbg: <br><br> <code>0:000&gt; u clr.dll+0x19566B-10 <br> clr!AwareLock::Contention+0x135: <br> 00007ff8`0535565b f00f4cc6 lock cmovl eax,esi <br> 00007ff8`0535565f 2bf0 sub esi,eax <br> 00007ff8`05355661 eb01 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664) <br> 00007ff8`05355663 cc int 3 <br> 00007ff8`05355664 83e801 sub eax,1 <br> 00007ff8`05355667 7405 je clr!AwareLock::Contention+0x144 (00007ff8`0535566e) <br> 00007ff8`05355669 f390 pause <br> 00007ff8`0535566b ebf7 jmp clr!AwareLock::Contention+0x13f (00007ff8`05355664)</code> <br> <br>  Y con varios m√©todos JIT: <br><br> <code>0:000&gt; u clr.dll+0x2801-10 <br> clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x124: <br> 00007ff8`051c27f1 5e pop rsi <br> 00007ff8`051c27f2 c3 ret <br> 00007ff8`051c27f3 833d0679930001 cmp dword ptr [clr!g_SystemInfo+0x20 (00007ff8`05afa100)],1 <br> 00007ff8`051c27fa 7e1b jle clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x14a (00007ff8`051c2817) <br> 00007ff8`051c27fc 418bc2 mov eax,r10d <br> 00007ff8`051c27ff f390 pause <br> 00007ff8`051c2801 83e801 sub eax,1 <br> 00007ff8`051c2804 75f9 jne clr!JIT_MonEnterWorker_InlineGetThread_GetThread_PatchLabel+0x132 (00007ff8`051c27ff)</code> <br> <br>  Ahora tenemos una plantilla.  En un caso, la direcci√≥n activa es una declaraci√≥n de salto, y en el otro caso, es una resta.  Pero ambas instrucciones importantes est√°n precedidas por la misma declaraci√≥n de pausa general.  Diferentes m√©todos ejecutan la misma instrucci√≥n de procesador, que por alguna raz√≥n lleva mucho tiempo.  Midamos la velocidad de ejecuci√≥n de la declaraci√≥n de pausa y veamos si razonamos correctamente. <br><br><h1>  Si el problema est√° documentado, se convierte en una caracter√≠stica. </h1><br><table cellpadding="2" width="400" border="1"><tbody><tr><td width="224">  <strong>CPU</strong> </td><td width="176">  <strong>pausa en nanosegundos</strong> </td></tr><tr><td width="224">  Xeon E5 1620v3 3.5 GHz </td><td width="176">  4 4 </td></tr><tr><td width="224">  Xeon¬Æ Gold 6126 @ 2.60 GHz </td><td width="176">  43 </td></tr></tbody></table><br>  La pausa en los nuevos procesadores Skylake toma un orden de magnitud m√°s largo.  Por supuesto, cualquier cosa puede ser m√°s r√°pida y, a veces, un poco m√°s lenta.  ¬øPero <b>diez veces</b> m√°s lento?  Es m√°s como un error.  Una peque√±a b√∫squeda en Internet sobre las instrucciones de pausa conduce al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual de Intel</a> , que menciona expl√≠citamente la microarquitectura Skylake y las instrucciones de pausa: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ca/c9f/30c/8cac9f30cd834d8c47eeab6297dda445.png"><br><br>  No, esto no es un error, esta es una funci√≥n documentada.  Incluso hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina que</a> indica el tiempo de ejecuci√≥n de casi todas las instrucciones del procesador. <br><br><ul><li>  Puente de arena 11 </li><li>  Ivy Bridege 10 </li><li>  Haswell 9 </li><li>  Broadwell 9 </li><li>  SkylakeX 141 </li></ul><br>  El n√∫mero de ciclos de procesador se indica aqu√≠.  Para calcular el tiempo real, debe dividir el n√∫mero de ciclos por la frecuencia del procesador (generalmente en GHz) y obtener el tiempo en nanosegundos. <br><br>  Esto significa que si ejecuta aplicaciones altamente multiproceso en .NET en el √∫ltimo hardware, entonces pueden funcionar mucho m√°s lentamente.  Alguien ya not√≥ esto y en agosto de 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registr√≥ un error</a> .  El problema se <a href="">solucion√≥</a> en .NET Core 2.1 y .NET Framework 4.8 Preview. <br><br><blockquote>  Spin-wait mejorado en varias primitivas de sincronizaci√≥n para un mejor rendimiento en Intel Skylake y microarquitecturas posteriores.  [495945, mscorlib.dll, error] </blockquote><br>  Pero dado que a√∫n falta un a√±o para el lanzamiento de .NET 4.8, solicit√© que las soluciones se respalden para que .NET 4.7.2 vuelva a la velocidad normal en los nuevos procesadores.  Como hay bloqueos mutuamente excluyentes (spinlocks) en muchas partes de .NET, debe realizar un seguimiento del aumento de la carga de la CPU cuando funcionan Thread.SpinWait y otros m√©todos de spinning. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c35/a11/ec8/c35a11ec843bb50b6a4c96906fa705f1.png"><br><br>  Por ejemplo, Task.Result usa internamente spinning, por lo que anticipo un aumento significativo en la carga de la CPU y un menor rendimiento en otras pruebas. <br><br><h1>  Que tan malo es </h1><br>  Mir√© el c√≥digo .NET Core durante cu√°nto tiempo el procesador continuar√° girando si no se libera el bloqueo antes de llamar a WaitForSingleObject para pagar el cambio de contexto "costoso".  Un cambio de contexto lleva a un microsegundo o mucho m√°s si muchos hilos esperan el mismo objeto del n√∫cleo. <br><br>  Los bloqueos .NET multiplican la duraci√≥n m√°xima de giro por el n√∫mero de n√∫cleos, si tomamos el caso absoluto de que el hilo en cada n√∫cleo espera el mismo bloqueo y el giro contin√∫a el tiempo suficiente para que todos trabajen un poco antes de pagar la llamada del n√∫cleo.  Girar en .NET usa un algoritmo de envejecimiento exponencial cuando comienza con un ciclo de 50 llamadas de pausa, donde cada n√∫mero de vueltas se triplica hasta que el siguiente contador de vueltas excede su duraci√≥n m√°xima.  Calcul√© la duraci√≥n total del giro por procesador para varios procesadores y un n√∫mero diferente de n√∫cleos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/238/63b/ef9/23863bef9c09567a160f8eb3a7c2d8e7.png"><br><br>  A continuaci√≥n se muestra el c√≥digo de giro simplificado en .NET Locks: <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> how .NET <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> spinning during <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> contention minus the <span class="hljs-keyword"><span class="hljs-keyword">Lock</span></span> taking/SwitchToThread/Sleep calls /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="nCores"&gt;&lt;/param&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Spin(<span class="hljs-type"><span class="hljs-type">int</span></span> nCores) { const <span class="hljs-type"><span class="hljs-type">int</span></span> dwRepetitions = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwInitialDuration = <span class="hljs-number"><span class="hljs-number">0x32</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> dwBackOffFactor = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> dwMaximumDuration = <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> * nCores; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dwRepetitions; i++) { <span class="hljs-type"><span class="hljs-type">int</span></span> duration = dwInitialDuration; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; duration; k++) { Call_PAUSE(); } duration *= dwBackOffFactor; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (duration &lt; dwMaximumDuration); } }</code> </pre> <br>  Anteriormente, el tiempo de rotaci√≥n estaba en el intervalo de milisegundos (19 ms para 24 n√∫cleos), que ya es mucho en comparaci√≥n con el tiempo de cambio de contexto mencionado anteriormente, que es un orden de magnitud m√°s r√°pido.  Pero en los procesadores Skylake, el tiempo de rotaci√≥n total para el procesador simplemente explota hasta 246 ms en una m√°quina de 24 o 48 n√∫cleos, simplemente porque la instrucci√≥n de pausa se ralentiz√≥ 14 veces.  ¬øEs esto realmente as√≠?  Escrib√≠ un peque√±o probador para verificar el giro general en la CPU, y los n√∫meros calculados est√°n en l√≠nea con las expectativas.  Aqu√≠ hay 48 subprocesos en una CPU de 24 n√∫cleos que esperan un bloqueo, al que llam√© Monitor.PulseAll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/6ad/e20/2f96ade20f682b4e7efe8a65d760e87e.png"><br><br>  Solo un hilo ganar√° la carrera, pero 47 continuar√° girando hasta que pierdan la frecuencia card√≠aca.  Esta es una evidencia experimental de que realmente tenemos un problema de carga de CPU y que el giro muy largo es real.  Socava la escalabilidad, porque estos ciclos van en lugar del trabajo √∫til de otros subprocesos, aunque la instrucci√≥n de pausa libera algunos de los recursos compartidos de la CPU, lo que proporciona un sue√±o durante m√°s tiempo.  La raz√≥n para girar es un intento de obtener un bloqueo m√°s r√°pido sin acceder al n√∫cleo.  Si es as√≠, aumentar la carga en la CPU ser√≠a solo nominal, pero no afectar√≠a en absoluto el rendimiento, porque los n√∫cleos se dedican a otras tareas.  Pero las pruebas mostraron una disminuci√≥n en el rendimiento en operaciones de un solo subproceso, donde un subproceso agrega algo a la cola de trabajo, mientras que el subproceso de trabajo espera un resultado y luego realiza una determinada tarea con el elemento de trabajo. <br><br>  La raz√≥n es m√°s f√°cil de mostrar en el diagrama.  El giro adversario se produce con un triple de giro en cada paso.  Despu√©s de cada ronda, el bloqueo se verifica nuevamente para ver si el hilo actual puede recibirlo.  Aunque spinning trata de ser honesto y cambia de vez en cuando a otros hilos para ayudarlos a completar su trabajo.  Esto aumenta las posibilidades de liberar el bloqueo en la pr√≥xima comprobaci√≥n.  El problema es que la comprobaci√≥n de una toma solo es posible al final de una vuelta completa: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/def/1fd/decdef1fd8ee504f92375acf31eca87d.png"><br><br>  Por ejemplo, si al comienzo de la quinta vuelta, una cerradura indica disponibilidad, solo puede tomarla al final de la vuelta.  Habiendo calculado la duraci√≥n del giro de la √∫ltima ronda, podemos estimar el peor caso de retraso para nuestro flujo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/610/b07/173/610b0717341447bc0415e77efaa731c8.png"><br><br>  Muchos milisegundos de espera hasta que finalice el giro.  ¬øEs esto un problema real? <br><br>  Cre√© una aplicaci√≥n de prueba simple que implementa una cola de fabricantes de consumidores, donde el flujo de trabajo realiza cada elemento de trabajo durante 10 ms, y el consumidor tiene un retraso de 1-9 ms antes del siguiente elemento de trabajo.  Esto es suficiente para ver el efecto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/701/70c/b97/70170cb97d0ac98a07b9733664c304fb.png"><br><br>  Vemos retrasos de 1-2 ms, la duraci√≥n total es de 2.2-2.3 s, mientras que en otros casos el trabajo es m√°s r√°pido hasta 1.2 s.  Esto muestra que el giro excesivo en la CPU no es solo un problema cosm√©tico en aplicaciones sobreenhebradas.  Realmente da√±a el simple subproceso del productor-consumidor, que incluye solo dos subprocesos.  Para la ejecuci√≥n anterior, los datos de ETW hablan por s√≠ mismos: es el aumento en el giro que causa el retraso observado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/325/01e/ae932501eb724b116bc0aceac8216ef5.png"><br><br>  Si observa cuidadosamente la secci√≥n con "frenos", veremos 11 ms de giro en el √°rea roja, aunque el trabajador (azul claro) ha completado su trabajo y ha dado la cerradura hace mucho tiempo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89d/a51/030/89da5103028ac3b3285fced21f18d8bf.png"><br><br>  Un caso r√°pido no degenerativo se ve mucho mejor, aqu√≠ solo se gasta 1 ms en girar para bloquear. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/220/8a4/6ef2208a4ec2e433fc2f9c8da030adca.png"><br><br>  <i>Us√© la</i> aplicaci√≥n de prueba <i>SkylakeXPause</i> .  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo zip</a> contiene c√≥digo fuente y binarios para .NET Core y .NET 4.5.  A modo de comparaci√≥n, instal√© .NET 4.8 Preview con correcciones y .NET Core 2.0, que a√∫n implementa el comportamiento anterior.  La aplicaci√≥n est√° dise√±ada para .NET Standard 2.0 y .NET 4.5, produciendo tanto exe como dll.  Ahora puede comprobar el comportamiento de giro antiguo y nuevo lado a lado sin la necesidad de arreglar nada, es muy conveniente. <br><br><pre> <code class="hljs pgsql">readonly <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> _LockObject = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItems; <span class="hljs-type"><span class="hljs-type">int</span></span> CompletedWorkItems; Barrier SyncPoint; <span class="hljs-type"><span class="hljs-type">void</span></span> RunSlowTest() { const <span class="hljs-type"><span class="hljs-type">int</span></span> processingTimeinMs = <span class="hljs-number"><span class="hljs-number">10</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> WorkItemsToSend = <span class="hljs-number"><span class="hljs-number">100</span></span>; Console.WriteLine($"Worker thread works {processingTimeinMs} ms for {WorkItemsToSend} times"); // Test one sender one receiver thread <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> different timings <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> the sender wakes up again // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> send the next <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> item // synchronize worker <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sender. Ensure that worker starts first <span class="hljs-type"><span class="hljs-type">double</span></span>[] sendDelayTimes = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var sendDelay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sendDelayTimes) { SyncPoint = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Barrier(<span class="hljs-number"><span class="hljs-number">2</span></span>); // one sender one receiver var sw = Stopwatch.StartNew(); Parallel.Invoke(() =&gt; Sender(workItems: WorkItemsToSend, delayInMs: sendDelay), () =&gt; Worker(maxWorkItemsToWork: WorkItemsToSend, workItemProcessTimeInMs: processingTimeinMs)); sw.Stop(); Console.WriteLine($"Send Delay: {sendDelay:F1} ms Work completed in {sw.Elapsed.TotalSeconds:F3} s"); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> gap <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ETW data so we can differentiate the test runs } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Simulate a worker thread which consumes CPU which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> triggered <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the Sender thread /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Worker(<span class="hljs-type"><span class="hljs-type">int</span></span> maxWorkItemsToWork, <span class="hljs-type"><span class="hljs-type">double</span></span> workItemProcessTimeInMs) { SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (CompletedWorkItems != maxWorkItemsToWork) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WorkItems == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Monitor.Wait(_LockObject); // wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WorkItems; i++) { CompletedWorkItems++; SimulateWork(workItemProcessTimeInMs); // consume CPU under this <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> } WorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the Worker thread under a <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wake up the worker thread n times /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> Sender(<span class="hljs-type"><span class="hljs-type">int</span></span> workItems, <span class="hljs-type"><span class="hljs-type">double</span></span> delayInMs) { CompletedWorkItems = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> previous <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> SyncPoint.SignalAndWait(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workItems; i++) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_LockObject) { WorkItems++; Monitor.PulseAll(_LockObject); } SimulateWork(delayInMs); } }</code> </pre> <br><h1>  Conclusiones </h1><br>  Este no es un problema .NET.  Todas las implementaciones de spinlock que usan la declaraci√≥n de pausa se ven afectadas.  Revis√© r√°pidamente el n√∫cleo de Windows Server 2016, pero no existe tal problema en la superficie.  Parece que Intel fue lo suficientemente amable e insinu√≥ que se necesitan algunos cambios en el enfoque del giro. <br><br>  Se inform√≥ un error para .NET Core en agosto de 2017, y en septiembre de 2017 se lanz√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un parche</a> y una versi√≥n de .NET Core 2.0.3.  El enlace muestra no solo la excelente reacci√≥n del grupo .NET Core, sino tambi√©n el hecho de que hace unos d√≠as el problema se solucion√≥ en la rama principal, as√≠ como una discusi√≥n sobre optimizaciones de giro adicionales.  Desafortunadamente, Desktop .NET Framework no se est√° moviendo tan r√°pido, pero frente a .NET Framework 4.8 Preview, tenemos al menos pruebas conceptuales de que las correcciones all√≠ tambi√©n son implementables.  Ahora estoy esperando el backport para .NET 4.7.2 para usar .NET a toda velocidad y en el √∫ltimo hardware.  Este es el primer error que encontr√© que est√° directamente relacionado con los cambios de rendimiento debido a una instrucci√≥n de la CPU.  ETW sigue siendo el principal generador de perfiles en Windows.  Si pudiera, le pedir√≠a a Microsoft que porte la infraestructura ETW a Linux, porque los perfiladores de Linux actuales todav√≠a son una mierda.  Recientemente agregaron caracter√≠sticas interesantes del kernel, pero todav√≠a no hay herramientas de an√°lisis como WPA. <br><br>  Si est√° trabajando con .NET Core 2.0 o el .NET Framework de escritorio en los √∫ltimos procesadores que se han lanzado desde mediados de 2017, en caso de problemas con la degradaci√≥n del rendimiento, definitivamente debe verificar sus aplicaciones con un generador de perfiles y actualizar a .NET Core y, con suerte, pronto Escritorio .NET  Mi aplicaci√≥n de prueba le informar√° sobre la presencia o ausencia de un problema. <br><br> <code>D:\SkylakeXPause\bin\Release\netcoreapp2.0&gt;dotnet SkylakeXPause.dll -check <br> Did call pause 1,000,000 in 3.5990 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  o <br><br> <code>D:\SkylakeXPause\SkylakeXPause\bin\Release\net45&gt;SkylakeXPause.exe -check <br> Did call pause 1,000,000 in 3.6195 ms, Processors: 8 <br> No SkylakeX problem detected</code> <br> <br>  La herramienta informar√° un problema si est√° trabajando en .NET Framework sin la actualizaci√≥n adecuada y en el procesador Skylake. <br><br>  Espero que hayas encontrado la investigaci√≥n de este problema tan emocionante como yo.  Para comprender realmente el problema, debe crear un medio para reproducirlo que le permita experimentar y buscar factores influyentes.  El resto es solo un trabajo aburrido, pero ahora soy mucho mejor para comprender las causas y consecuencias de un intento c√≠clico de bloquear la CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415053/">https://habr.com/ru/post/es415053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415043/index.html">Robot volador cambia de forma en el aire</a></li>
<li><a href="../es415045/index.html">La pol√≠tica de licencias de Oracle impulsa el an√°lisis en Hadoop</a></li>
<li><a href="../es415047/index.html">Eventos digitales en Mosc√∫ del 25 de junio al 1 de julio</a></li>
<li><a href="../es415049/index.html">Crear comandos de gesti√≥n en Django</a></li>
<li><a href="../es415051/index.html">Isometr√≠a, √≠ndices z en juegos m√≥viles y su optimizaci√≥n</a></li>
<li><a href="../es415055/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 320 (18-24 de junio de 2018)</a></li>
<li><a href="../es415057/index.html">PHP Digest No. 133 (10-24 de junio de 2018)</a></li>
<li><a href="../es415059/index.html">Secretos de la cocina JavaScript: especias</a></li>
<li><a href="../es415061/index.html">De frontend a backend</a></li>
<li><a href="../es415063/index.html">Blue Origin comenzar√° a vender boletos para turistas espaciales el pr√≥ximo a√±o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>