<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦅 💔 👩🏿‍🏫 如何使用Yandex.Direct API示例（第2部分）使用并行计算来加快R语言API的工作速度 😯 🧑🏽 🙌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中，我讨论了什么是多线程，并给出了使用doSNOW ， doParallel和foreach构造与Yandex.Direct API一起使用R语言时的实现示例。 


 本文是续篇，但可以看作是R中多线程的脱机指南。第一部分收到的评论提示我写它（在此特别感谢Alexey_mosc ， S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何使用Yandex.Direct API示例（第2部分）使用并行计算来加快R语言API的工作速度</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p>在上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中，</a>我讨论了什么是多线程，并给出了使用<code>doSNOW</code> ， <code>doParallel</code>和<code>foreach</code>构造与Yandex.Direct API一起使用R语言时的实现示例。 </p><br><p> 本文是续篇，但可以看作是R中多线程的脱机指南。第一部分收到的评论提示我写它（在此特别感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Alexey_mosc</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">SatCat</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Ananiev_Genrih</a> ），在其中给了我一些软件包，这些软件包代表了一种更现代的方法R中实现多线程的实现，我们将在后面讨论。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="多线程"></p><a name="habracut"></a><br><h1 id="soderzhanie"> 目录内容 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">挑战赛</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">准备工作</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">串行处理解决方案示例，sapply函数和purrr包</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">贴身功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Purrr包装</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解决从Yandex.Direct收集关键字的任务的多线程选项</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">平行包装</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未来包装</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未来包装</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Future.apply包</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Furrr包装</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">速度测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li><li> 投票 </li></ul><br><h1 id="zadacha"> 挑战赛 </h1><br><p> 例如，我们以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前出版物中</a>考虑的问题为例。 在多线程模式下，从4个Yandex.Direct广告帐户中收集关键字列表。 </p><br><p> 要使用Yandex.Direct API，我们将使用<code>ryandexdirect</code>包。 链接的官方文档在上，但是对于所描述任务的实现，我们仅需要2个功能： </p><br><ul><li>  yadirAuth-Yandex.Direct API中的授权； </li><li>  <code>yadirGetKeyWords</code>从广告帐户下载关键字列表。 </li></ul><br><p> 不仅仅是我选择了下载关键字的过程，事实是，这是Yandex.Direct API中最冗长的操作之一。 其次，在所有帐户中，关键字的数量是不同的，因此，对于每个帐户，完成此操作的时间将非常不同，在我们的情况下为1到20秒。 </p><br><h1 id="podgotovka"> 准备工作 </h1><br><p> 最初，您需要安装本文讨论的所有软件包，为此，您可以使用下面的代码。 </p><br><div class="spoiler">  <b class="spoiler_title">代码1：安装软件包</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p> 为了使包功能可用，必须使用<code>library</code>命令将其连接。 为了方便起见，我将在每个给定的代码示例中分别连接所有必需的软件包。 </p><br><p> 我们创建一个由Yandex.Direct登录名组成的向量，稍后我们将从中请求关键字： </p><br><div class="spoiler">  <b class="spoiler_title">代码2：创建登录向量</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p> 要使用Yandex.Direct API，首先需要在每个帐户下进行授权，为此您可以使用以下设计： </p><br><div class="spoiler">  <b class="spoiler_title">代码3：Yandex.Direct API中的授权</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p> 运行上述代码后，将打开一个浏览器以使用每个帐户进行授权。 您确认<code>ryandexdirect</code>允许访问您的广告材料。 您将被重定向到需要复制验证码的页面。 通过将其输入R控制台，完成授权过程。 在创建引导程序登录名时为指定的每个登录名重复此操作。 </p><br><p> 在授权过程中，某些用户可能会因重定向到第三方资源而感到困惑，但是这样做对您的帐户没有任何危险，我在文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“使用R包与广告系统API一起使用有多安全”</a>中对此主题进行了详细描述。 </p><br><p> 接下来，我们将考虑实现所描述任务的几个示例。 每种方法都将从示例代码及其进一步说明开始。 我认为此选项最易于感知。 </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr"> 串行处理解决方案示例，sapply函数和purrr包 </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中</a> ，我引用了以<code>for</code>循环为例的解决方案。 因为我们考虑使用语法类似于循环的<code>foreach</code>包进行多线程处理，所以此示例适用于此处，尽管R的用户不欢迎使用循环。 </p><br><p> 我们将在本文中考虑的程序包更加让人联想到apply系列的语法功能；因此，我将举一个使用它们的串行模式解决方案的示例。 </p><br><h3 id="funkciya-sapply">  <code>sapply</code>功能 </h3><br><blockquote> 为了估计命令的执行时间，在每种考虑的方法中，我们将使用<code>tictoc</code>软件包。 </blockquote><br><div class="spoiler">  <b class="spoiler_title">代码4：使用sapply函数的顺序模式下的示例解决方案</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  <code>39.36 sec elapsed</code>时间： <code>39.36 sec elapsed</code> </p><br><p> 首先， <code>apply</code>系列功能的语法不像循环的语法那样易读，但实际上一切都很简单。 </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p> 其中： </p><br><ul><li>  <em>X-</em>一个对象，我们将对其元素进行迭代并在每次迭代中依次使用，在<code>for</code>循环中，它看起来像这样： <code>for(i in X)</code> ； </li><li>  <em>FUN-</em>一个函数，在该函数中，我们将依次替换对象<em>X的</em>每个元素，如果我们使用<code>for</code>进行类比，则这是循环的主体。 </li></ul><br><p> 在<strong>代码</strong>示例<strong>4中</strong> ，先前创建的<em>登录</em>向量被传递给<em>X</em>参数。  <em>登录</em>向量的每个元素依次作为传递给<em>FUN</em>参数的匿名函数<code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code>唯一参数传递。 </p><br><p> 即  <code>sapply</code>将执行<em>FUN中</em>指定的功能4次，将登录名一个接一个地替换，并以包含4个元素的列表（类<em>list的</em>对象）的形式返回结果。 每个元素都是一个表，其中包含在每次迭代中从帐户收到的关键字列表。 </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p> 使用<code>sapply</code>获得的对象具有以下结构： </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p> 在本示例的最后，命令<code>result.sapply &lt;- do.call("rbind", kw.sapply)</code>将<em>kw.sapply</em>列表的所有4个元素组合到一个<em>result.sapply</em>帧中。 </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p> 除了<code>sapply</code> ， <code>*apply</code>系列功能还包括： <code>apply</code> ， <code>lapply</code> ， <code>vapply</code> ， <code>mapply</code>等。 </p><br><h3 id="paket-purrr">  <code>purrr</code>包装 </h3><br><div class="spoiler">  <b class="spoiler_title">代码5：使用purrr包函数的示例解决方案</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  <code>35.46 sec elapsed</code>时间： <code>35.46 sec elapsed</code> </p><br><p>  <code>purrr</code>程序包是Headley Wickham编写的<code>tidyverse</code>库核心的一部分。 </p><br><p> 在含义和语法上，该软件包的主要功能与<code>sapply</code>非常相似，其主要优点如下： </p><br><ul><li> 函数分为<code>map</code> ， <code>map2</code> ， <code>pmap</code> ， <code>walk</code>等族，同一族中包含的单独函数以不同格式返回结果： <em>chr</em> ， <em>dbl</em> ， <em>int</em> ， <em>df</em>等； </li><li>  <code>map2</code>系列的功能<code>map2</code>您同时迭代两个对象的元素（迭代）。 </li><li>  <code>pmap</code>系列的功能<code>pmap</code>您同时<code>pmap</code>任意数量的对象的元素。 您可以将表传递给<em>.l</em>参数<em>（sapply中X参数的类似物）</em>的输入，该表的每一列都将包含用于迭代的值，并将其依次替换为<em>.f中</em>传递的同一函数的参数<em>（ sapply）</em> 。 </li></ul><br><p> 在什么情况下，我们需要迭代几个对象的元素。 例如，您使用多个代理帐户，想要从中获取关键字列表的广告帐户分散在它们之间。 在这种情况下，您可以根据代理商帐户的名称创建一个向量，并对其进行迭代，这与您对广告帐户的登录名进行排序的方式并行。 </p><br><div class="spoiler">  <b class="spoiler_title">代码6：使用多个代理帐户的示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p> 现在想象一下这样一种情况，当您使用不同的帐户登录时，您将带有凭据的文件保存在不同的文件夹中，然后需要立即遍历三个对象：广告帐户的登录，代理帐户的登录，带有凭据的文件的存储路径。 可以在帮助下完成。  <code>pmap</code>系列<code>pmap</code> 。 </p><br><div class="spoiler">  <b class="spoiler_title">代码7：pmap函数示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p> 因此，执行功能<code>map_df</code> ， <code>map2_df</code>和<code>pmap_df</code>是日期框架，并且在使用它们时， <code>sapply</code>使用<code>sapply</code> （ <code>do.call("rbind", kw.sapply)</code> ）的示例的最后一步。 </p><br><p> 代码变得更加紧凑，执行速度更快，但是，上述方法<code>sapply</code>和<code>purrr</code>从每个帐户顺序收集了关键字。 因此，此操作的总执行时间是来自所有四个帐户的数据收集持续时间的总和。 </p><br><p>  <strong>时间[总计]</strong> = <em>时间[登录1] +时间[登录2] +时间[登录3] +时间[登录4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt"> 解决从Yandex.Direct收集关键字的任务的多线程选项 </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p> 因此，如果您已经阅读了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章</a> ，那么您将知道多线程操作模式具有以下功能： </p><br><ul><li> 每个线程均在具有干净工作环境的单独R会话中启动。 </li><li> 出于相同的原因，在单独的运行过程中，默认情况下不会传输先前连接的数据包。 </li></ul><br><p> 导出在工作环境中创建的对象以及在每种方法中连接程序包的实现方式有所不同，然后我们将对其进行更详细的考虑。 </p><br><h3 id="paket-parallel">  <code>parallel</code>包装 </h3><br><p> 该软件包最初包含在2.14.0版的R软件包中，并且直到今天，R本身也都附带了该软件包。 </p><br><div class="spoiler">  <b class="spoiler_title">代码8：通过并行包解决问题的示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  <code>16.75 sec elapsed</code>时间： <code>16.75 sec elapsed</code> </p><br><p> 让我们尝试解析<strong>代码8</strong> 。  <code>makeCluster</code>函数创建一个由4个进程组成的集群。 我们可以使用<code>clusterExport</code>函数将对象从主要工作环境导出到创建的集群，为此，我们需要使用其参数： </p><br><ul><li>  <em>cl-</em>要将对象导出到的群集 </li><li>  <em>varlist-</em>一个文本向量，其中包含要导出到每个集群进程的对象的名称。 </li></ul><br><p> 在每个群集节点上连接正确的程序包的一种方法是使用<code>clusterEvalQ</code>函数。 在我们的示例中，我们使用它来连接程序包，但是您可以在<code>clusterEvalQ</code>内编写任何R代码，它将在每个群集节点的开始处启动。 该函数的参数非常明显，您需要指定集群以及将在其中执行的命令。 </p><br><p>  <code>parSapplyLB</code>是<code>sapply</code>函数的并行版本，在群集节点之间具有负载平衡，它们也使用它，但是您需要使用<em>cl</em>参数指定群集。 </p><br><p> 同时，还有<code>*apply</code>系列函数的其他并行版本： <code>parLapply</code> ， <code>parSapply</code> ， <code>parApply</code>等。 </p><br><p>  <code>parSapply</code>与<code>parSapply</code>不同之处仅在于，它在群集节点上没有负载平衡。 </p><br><p>  <code>stopCluster</code>函数用于停止创建的集群。 </p><br><p> 最后一个命令<code>dplyr::bind_rows(parallel.kw)</code>我们将使用<code>parSapplyLB</code>获得的<em>parallel.kw</em>对象<code>parSapplyLB</code>到一个表中。 </p><br><p> 对于Linux， <code>parallel</code>具有单独的功能： <code>mclapply</code> ， <code>mcmapply</code> ， <code>mcMap</code> 。 通常在此操作系统中，命令执行速度更快，并且代码变得更紧凑。 </p><br><div class="spoiler">  <b class="spoiler_title">代码9：针对Linux使用mclapply的解决方案</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p> 使用这些功能时，无需使用<code>makeCluster</code>启动集群。 您使用<em>mc.cores</em>参数<em>指定</em>的节点数。 也不需要连接包和导出对象；这些操作是自动执行的。 </p><br><h3 id="paket-future">  <code>future</code>包装 </h3><br><p>  R中异步编程的最现代方法之一。 </p><br><p> 可以在<code>future</code>的帮助下并行解决我们的问题的代码非常复杂，难以理解。 因此，让我们通过一个简单的示例来分析其工作，我们将从一个帐户中请求关键字列表。 </p><br><div class="spoiler">  <b class="spoiler_title">代码10：使用Future包的最简单示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p> 让我们尝试找出<strong>Code 10</strong>示例。  <code>plan</code>功能允许您设置和更改给定表达式的执行模式，以下是主要的表达式： </p><br><ul><li>  <em>顺序</em> -这是通常的R操作模式；命令在当前会话中顺序执行； </li><li>  <em>多会话</em> -并行模式，命令将在当前计算机的后台运行会话中执行，而不会阻塞您的工作会话； </li><li>  <em>cluster-</em>并行模式，命令将在当前或远程计算机上执行，类似于在<code>parallel</code>程序包中实现的方式。 </li></ul><br><p> 整个<code>future</code>程序包都基于在后台进程中执行命令而不会阻塞当前会话。 运行命令的执行将遵循具有相同名称的功能<code>future</code> ，因此当我们运行命令时： </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p> 我们当前在R中的会话没有被阻塞，并且该命令在后台执行，运行另一个R会话。 </p><br><p> 您可以使用<code>resolved</code>函数来检查给定表达式执行过程的当前状态。 最后， <code>value</code>函数用于获取<code>future</code>执行的结果。 如果您在并行运行的会话中早于<code>future</code>运行<code>value</code>函数，则当前工作会话将被阻塞，直到并行会话表达式完成。 </p><br><p> 最先进的工作示例是将Future与<code>promises</code>结合使用。 </p><br><div class="spoiler">  <b class="spoiler_title">代码11：共享`future`和`promise`包的示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  <code>promises</code>软件包提供了一组管道运算符，可以完美地补充<code>future</code>功能。 </p><br><p> 在后台的<strong>Code 11</strong>示例中，我们开始从一个广告帐户下载关键字的过程。 此外，没有阻塞工作会话的管道运算符<code>%...&gt;%</code>等待<code>future</code> ，并执行其余操作。 由于执行了代码， <code>future</code>工作完成后，指定帐户中的关键字数量将显示在控制台中： </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote> 在文章的结尾，将展示一堆关于<code>future</code>和<code>promises</code>的更具说明性的示例。 </blockquote><p> 默认情况下， <code>future</code>包本身会将整个工作空间导出到每个并行运行的会话，但是您自己可以使用<em>globals</em>参数指定要导出的对象列表。 </p><br><p> 要将软件包连接到<code>future</code>应该将包含其名称的向量传递给<em>packages</em>参数。 </p><br><p> 现在回到我们的任务，以下并行模式的代码示例将从4个帐户中加载关键字列表： </p><br><div class="spoiler">  <b class="spoiler_title">代码12：使用future包解决问题的示例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p> 前置时间： <code>14.83 sec elapsed</code> </p><br><p> 要从<em>引导登录中</em>列出的所有广告帐户中以多线程模式下载关键字列表<em>，</em>您需要在后台运行单独的Future。 在<strong>代码</strong>示例<strong>12中，</strong>我们使用<code>lapply</code>函数实现了这一点。 </p><br><p> 努力工作的结果是<code>future</code>推出的清单。 您可以使用<code>sapply(futs, resolved)</code>命令检查每个命令的状态，该命令将返回逻辑向量，其中<em>TRUE</em>表示<code>future</code>实现，而<em>FALSE</em>表示<code>future</code>正在进行中。 </p><br><p> 为了从每个<code>future</code>获得结果，在他们的工作完成之后，我们使用<code>lapply(futs, value)</code>命令。 </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    . 即   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> —     <code>%&gt;%</code> ,     . 即   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> —  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% —      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="图片"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448404/">https://habr.com/ru/post/zh-CN448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448392/index.html">构造活动图表的两种方法</a></li>
<li><a href="../zh-CN448394/index.html">第12版今天发布！ （这对Wolfram语言和Mathematica来说是一个巨大的飞跃）</a></li>
<li><a href="../zh-CN448396/index.html">为macOS Mojave上的强化运行时和公证服务做好准备</a></li>
<li><a href="../zh-CN448400/index.html">Netplan以及如何正确烹饪</a></li>
<li><a href="../zh-CN448402/index.html">证书颁发机构（CA）从Windows 2008R到Windows 2012 R2的迁移失败</a></li>
<li><a href="../zh-CN448408/index.html">DCIM-数据中心管理的关键</a></li>
<li><a href="../zh-CN448410/index.html">Google的跟踪器已内置在许多俄罗斯官方电子资源中</a></li>
<li><a href="../zh-CN448414/index.html">用于自控的家庭实验室，或使用怪胎套件购买的物品</a></li>
<li><a href="../zh-CN448416/index.html">在iOS应用程序中进行聊天的最简单方法</a></li>
<li><a href="../zh-CN448420/index.html">Kubernetes的生活：西班牙人HTTP服务器如何不抱怨</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>