<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸšˆ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ ğŸŒœ Buka Sesi Dalam Tampilan di Boot Spring: The Phantom Menace ğŸ‘¶ğŸ¼ ğŸ¤µğŸ¼ ğŸ‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap orang di sini benar, masing-masing dengan caranya sendiri, dan karena itu setiap orang di sini salah. 
 "The Tale of the Three" (A. dan B. Stru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buka Sesi Dalam Tampilan di Boot Spring: The Phantom Menace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440734/"><blockquote> Setiap orang di sini benar, masing-masing dengan caranya sendiri, dan karena itu setiap orang di sini salah. <br>  <strong>"The Tale of the Three" (A. dan B. Strugatsky)</strong> </blockquote><p>  Jika Anda menggunakan Spring Data JPA, kemudian setelah memperbarui ke Spring Boot 2, saat Anda memulai aplikasi, Anda mungkin melihat peringatan baru di log: </p><br><blockquote>  spring.jpa.open-in-view diaktifkan secara default.  Oleh karena itu, permintaan basis data dapat dilakukan selama rendering tampilan.  Konfigurasikan spring.jpa.open-in-view secara eksplisit untuk menonaktifkan peringatan ini. </blockquote><p>  Dalam artikel ini saya akan mencoba menjelaskan apa artinya, siapa yang harus disalahkan dan apa yang harus dilakukan. </p><br><p> Untuk memunculkan aplikasi lengkap pada Boot Musim Semi, hanya diperlukan satu penjelasan <code>@SpringBootApplication</code> .  Untuk memungkinkan ini, kerangka kerja menggunakan sejumlah besar konfigurasi otomatis dan pengaturan default.  Selain itu, untuk bekerja di luar kotak, pengembang Spring Boot harus memilih beberapa konsep pengembangan aplikasi dari beberapa opsi alternatif untuk masing-masing, sehingga pengguna tidak perlu memilihnya secara eksplisit.  Di satu sisi, ini bagus untuk memulai cepat dan pengembangan mudah, tetapi di sisi lain, setelah beberapa saat mungkin ternyata beberapa konsep / paradigma / pengaturan default tidak cocok untuk proyek, dan banyak pekerjaan yang harus dilakukan untuk mengabaikannya.  Salah satu konsep tersebut adalah <strong>mode Open Session In View (OSIV)</strong> , yang disertakan secara default di Spring Boot. </p><a name="habracut"></a><br><p>  Dalam mode ini, sesi Hibernasi tetap terbuka sepanjang waktu permintaan HTTP diproses, termasuk tahap pembuatan Lihat (sumber JSON atau halaman HTML).  Ini memungkinkan untuk memuat data dengan malas di lapisan presentasi setelah melakukan transaksi di lapisan logika bisnis.  Sebagai contoh, kami meminta entitas <code>Article</code> dari database.  Artikel harus ditampilkan bersama dengan komentar.  OSIV memungkinkan Anda cukup memanggil metode entitas <code>getComments()</code> saat merender HTML, dan komentar akan dimuat dalam permintaan terpisah.  Ketika mode OSIV dinonaktifkan, kita akan mendapatkan <code>LazyInitializationException</code> , karena sesi sudah ditutup dan entitas <code>Article</code> tidak lagi dikelola oleh Hibernate.  Sebagian besar pengembang Hibernate mengalami <code>LazyInitializationException</code> ;  OSIV memungkinkan Anda untuk menghindarinya dengan memuat data seperlunya pada setiap tahap pemrosesan permintaan HTTP. </p><br><p>  OSIV di Spring Boot diimplementasikan menggunakan <code>OpenEntityManagerInViewInterceptor</code> permintaan web <code>OpenEntityManagerInViewInterceptor</code> .  Tidak seperti Spring murni, ini diaktifkan secara default. </p><br><p>  OSIV dianggap antipattern.  Yang terbaik dari semuanya, sisi berbahaya dari artikelnya dijelaskan oleh Vlad Mihalcea, salah satu pengembang Hibernate: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sesi Terbuka Dalam Pandangan Anti-Pola</a> .  Poin-poin penting: </p><br><ul><li>  Permintaan basis data tanpa transaksi berfungsi dalam mode komit otomatis, memuatnya dengan berat. </li><li>  Tidak ada pemisahan tanggung jawab, lapisan aplikasi apa pun dapat menghasilkan kueri SQL, yang membuat pengujian menjadi sulit. </li><li>  Ada masalah n +1 ketika setiap koleksi terkait dengan entitas dimuat dalam permintaan terpisah. </li><li>  Koneksi yang lama ke database sekali lagi menambah beban di dalamnya dan mengurangi throughput. </li></ul><br><p>  Ini adalah masalah yang cukup tidak menyenangkan dari mode OSIV dan, tampaknya, argumen kuat untuk tidak menggunakannya.  Namun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam permintaan untuk menonaktifkannya secara default</a> , pengembang Spring Boot juga membuat alasan bagus mengapa OSIV harus diaktifkan untuk proyek-proyek baru: </p><br><ul><li>  Kompatibilitas mundur.  Aplikasi yang ada saat meningkatkan ke Spring Boot 2 mungkin mengalami kesalahan dan bug karena OSIV dinonaktifkan.  Untuk menghindari ini, Anda hanya perlu mengatur nilai tunggal <code>spring.jpa.open-in-view</code> , tetapi ini juga membuatnya sulit untuk beralih ke versi baru. </li><li>  Kemudahan penggunaan untuk pemula dan awal yang cepat penting untuk Spring Boot.  Jika OSIV dinonaktifkan, mungkin tidak jelas bagi pemula mengapa hal yang diharapkan secara intuitif seperti menerima koleksi elemen terkait saat mengakses metode entitas tidak berfungsi.  Sebagai gantinya, pengguna akan menerima <code>LazyInitializationException</code> , ini akan memperlambat jalannya ke aplikasi yang sedang berjalan. </li><li>  OSIV memungkinkan Anda untuk meningkatkan kesederhanaan kode, kegunaan, dan kecepatan pengembangan. </li><li>  Sulit untuk menemukan contoh sederhana tentang bagaimana suatu aplikasi harus dibangun tanpa OSIV. </li><li>  Tanpa OSIV, lapisan logika bisnis perlu tahu bagaimana data akan disajikan di UI, yaitu, DTO apa yang dibutuhkan atau data terkait apa yang harus dimuat bersama dengan entitas root.  Lagi-lagi ini tidak ada pembagian tanggung jawab. </li></ul><br><p>  Jadi, kita bisa membedakan dua pandangan tentang masalah ini.  Dari sudut pandang arsitek basis data (DBA), Open Session In View tentu saja tidak dapat diterima, karena interaksi aplikasi dengan database tidak diatur secara optimal dan menghasilkan peningkatan beban.  Tetapi kami sering menggunakan solusi yang kurang optimal untuk kecepatan, kemudahan pengembangan dan kemudahan alat pembelajaran - kami menulis dalam bahasa yang dikelola, kami menggunakan format data teks untuk interaksi jaringan dan sebagainya.  Dari posisi pengembang kerangka kerja, untuk menyederhanakan pengembangan dan mulai cepat pemula, OSIV memungkinkan Anda untuk mengurangi beban kognitif, sejumlah konsep yang diperlukan untuk mulai mengembangkan aplikasi.  Jika pengembang memilih JPA, dia sudah menyetujui beberapa penurunan kinerja dengan imbalan kenyamanan pengembangan.  JPA membantu berteman dengan objek dan model data relasional.  Ketika bekerja dalam gaya objek untuk mendapatkan elemen terkait, kita cukup beralih ke metode entitas (bahkan jika dalam lapisan presentasi), itu sederhana, logis dan secara intuitif diharapkan, meskipun kesederhanaan ini menipu. </p><br><p>  Ada banyak contoh dan tutorial untuk bekerja dalam mode Sesi Terbuka Dalam mode Tampilan, arsitektur secara keseluruhan jelas: lapisan layanan meminta entitas JPA, lapisan presentasi secara bersambung di JSON secara langsung, melalui DTO perantara, atau menggunakan data darinya untuk membuat halaman HTML. </p><br><p>  Yang kurang jelas adalah bagaimana bekerja tanpa OSIV.  Salah satu pengembang Spring dalam permintaan tersebut mengeluh tentang hal ini, mereka mengatakan banyak teriakan tentang antipattern, tetapi tidak ada contoh sederhana tentang bagaimana hidup tanpanya.  Dalam varian ini, entitas hanya dapat digunakan untuk menulis, dan untuk membaca - beberapa DTO, terpisah untuk setiap set data di UI, yang dipetakan langsung dari database.  Atau kueri SQL khusus yang menggambarkan gabungan dari koleksi terkait yang diperlukan untuk kueri web tertentu.  Artinya, lebih banyak boilerplate dan deskripsi kebutuhan UI di lapisan logika bisnis.  Dengan OSIV dinonaktifkan, abstraksi JPA mulai mengalir, aplikasi menjelaskan lebih detail teknis berinteraksi dengan database. </p><br><p>  Dengan demikian, pengembangan dengan OSIV lebih sederhana.  Tetapi masalahnya adalah jika di masa depan Anda ingin meninggalkannya, Anda harus mengulang banyak hal, konsep bekerja dengan database dalam proyek dengan menetapkan satu properti tidak dapat diubah.  Anda mungkin perlu mengulang seluruh arsitektur aplikasi.  Namun, mengabaikan OSIV mungkin merupakan pengoptimalan prematur, yang akan memperlambat kecepatan pengembangan, yang mungkin sangat penting untuk startup, misalnya.  Anda dapat menggunakan OSIV dan mengoptimalkan kueri basis data hanya di tempat paling lambat.  Misalnya, kueri koleksi entitas paling menderita dari masalah n +1, ketika setiap entitas menarik beberapa kueri dari koleksi terkait. </p><br><p>  Jadi, jika Anda ingin melakukannya dengan benar, Anda perlu mengembangkan tanpa OSIV.  Tetapi jika kecepatan pengembangan dan kesederhanaan kode penting, Anda dapat menggunakan mode ini, mengundurkan diri ke beberapa kehilangan kinerja. </p><br><p>  Masalah utamanya adalah masalah kinerja ini tidak berubah menjadi hutang teknis yang besar setelah beberapa tahun.  Sangat berbahaya ketika pengembang tidak curiga bahwa utang ini menumpuk di dalamnya, karena Spring Boot diam-diam memilih konsep Open Session In View untuk mereka.  Oleh karena itu, sangat baik bahwa, sebagai hasil dari permintaan yang disebutkan di atas, diputuskan untuk menampilkan di log peringatan tentang mode yang digunakan, yang saya kutip di awal artikel. </p><br><p>  Saya harap peringatan dan artikel tentang dia ini akan membantu pengembang membuat keputusan yang lebih tepat - apakah akan menggunakan konsep Open Session In View dalam aplikasi pada Spring Boot.  Saya telah mengutip dan membahas argumen utama untuk dan menentang, dan saya juga menyarankan untuk membaca diskusi asli.  Masalah ini menunjukkan bahwa sejumlah besar konfigurasi dan default otomatis di Spring / Spring Boot dapat berbahaya bagi pengembang yang lalai. </p><br><p>  Apakah Anda menggunakan OSIV dalam aplikasi Boot Musim Semi?  Jika tidak, bagaimana arsitektur untuk interaksi lapisan presentasi dengan database diatur?  Teknik dan / atau perpustakaan apa yang digunakan untuk ini? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440734/">https://habr.com/ru/post/id440734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440722/index.html">Sedikit latihan pemrograman fungsional di Swift untuk pemula</a></li>
<li><a href="../id440724/index.html">Seleksi: 4 layanan bermanfaat untuk imigran potensial ke AS, Eropa dan negara-negara lain</a></li>
<li><a href="../id440726/index.html">The Game of Archetypes: Bagaimana Mendongeng Bekerja untuk Merek Teknologi</a></li>
<li><a href="../id440728/index.html">Pengembangan ponsel: dari ide hingga estimasi biaya</a></li>
<li><a href="../id440732/index.html">Tingkatkan papan debug dengan prosesor Baikal-T1: tambahkan kartu SD</a></li>
<li><a href="../id440736/index.html">Saya merusak kehidupan pengembang dengan ulasan kode saya dan saya minta maaf</a></li>
<li><a href="../id440740/index.html">Buka webinar â€œPerjalanan Pelanggan: lalu lintas apa dan ke mana harus memimpinâ€</a></li>
<li><a href="../id440742/index.html">AMP dan Halaman Turbo: Pro, Kontra, dan Hasil Implementasi</a></li>
<li><a href="../id440744/index.html">PHP untuk pemula. Menangani kesalahan</a></li>
<li><a href="../id440746/index.html">Siklus Teknologi Manajemen Pengetahuan Gartner Menggunakan Studi Kasus di KnowledgeConf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>