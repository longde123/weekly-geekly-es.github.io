<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¶Ô∏è üßë‚Äçü§ù‚Äçüßë üö™ √Ä propos de [[trivial_abi]] √† Clang üò∑ ‚ÜôÔ∏è ü§πüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enfin, j'ai √©crit un article sur [[trivial_abi]]! 

 Il s'agit d'une nouvelle fonctionnalit√© propri√©taire dans le tronc Clang, nouvelle √† partir de f√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä propos de [[trivial_abi]] √† Clang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  Enfin, j'ai √©crit un article sur [[trivial_abi]]! <br><br>  Il s'agit d'une nouvelle fonctionnalit√© propri√©taire dans le tronc Clang, nouvelle √† partir de f√©vrier 2018. Il s'agit d'une extension du fournisseur du langage C ++, ce n'est pas du C ++ standard, il n'est pas pris en charge par le tronc GCC, et il n'y a aucune proposition active du WG21 pour l'inclure dans le standard C ++, pour autant que je sache. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  Je n'ai pas particip√© √† l'impl√©mentation de cette fonctionnalit√©.  J'ai juste regard√© les patchs sur la liste de diffusion cfe-commits et j'ai applaudi silencieusement.  Mais c'est une fonctionnalit√© tellement cool que je pense que tout le monde devrait le savoir. <br><a name="habracut"></a><br>  Donc, la premi√®re chose que nous allons commencer: ce n'est pas un attribut standard, et le tronc Clang ne prend pas en charge l'orthographe standard de l'attribut [[trivial_abi]] pour lui.  Au lieu de cela, vous devez l'√©crire dans l'ancien style, comme indiqu√© ci-dessous: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  Et, comme il s'agit d'un attribut, le compilateur est tr√®s pointilleux sur l'endroit o√π vous le collez et passivement agressivement silencieux si vous le collez au mauvais endroit (car les attributs non reconnus sont simplement ignor√©s sans messages).  Ce n'est pas un bug, c'est une fonctionnalit√©.  La syntaxe correcte est la suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  Quel probl√®me cela r√©sout-il? </h3><br><br>  Rappelez-vous mon post du 17/04/2018 o√π j'ai montr√© deux versions de la classe? <br><br><blockquote>  Remarque  perev: √âtant donn√© que l'article du 17/04/2018 a un petit volume, je ne l'ai pas publi√© s√©par√©ment, mais je l'ai ins√©r√© ici sous le spoiler. <br></blockquote><div class="spoiler">  <b class="spoiler_title">poste √† partir du 17/04/2018</b> <div class="spoiler_text"><h3>  Inconv√©nients de l'appel Trivial Destructor manquant </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voir la liste de diffusion de proposition standard C ++.</a>  Laquelle des deux fonctions, foo ou bar, aura le meilleur code g√©n√©r√© par le compilateur? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compilation</a> avec GCC et libstdc ++.  Devinez non? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Voici ce qui se passe ici: GCC est suffisamment intelligent pour comprendre que lorsqu'un destructeur pour une zone m√©moire est d√©marr√©, sa dur√©e de vie se termine et toutes les entr√©es pr√©c√©dentes dans cette zone m√©moire sont ¬´mortes¬ª.  Mais GCC est √©galement assez intelligent pour comprendre qu'un destructeur trivial (comme le pseudo destructeur ~ int ()) ne fait rien et ne produit aucun effet. <br><br>  Ainsi, la fonction bar appelle pop_back, qui ex√©cute ~ Integer (), ce qui rend vec.back () mort, et GCC supprime compl√®tement la multiplication par 0xDEADBEEF. <br><br>  D'autre part, foo appelle pop_back, qui lance le pseudo-destructeur ~ int () (il peut ignorer compl√®tement l'appel, mais ne le fait pas), GCC voit qu'il est vide et l'oublie.  Par cons√©quent, GCC ne voit pas que vec.back () est mort et ne supprime pas la multiplication par 0xDEADBEEF. <br><br>  Cela se produit pour un destructeur trivial, mais pas pour un pseudo destructeur tel que ~ int ().  Remplacez notre ~ Integer () {} par ~ Integer () = default;  et voyez √† quel point l‚Äôinstruction est apparue √† nouveau! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  Dans cet article, le code est donn√© dans lequel le compilateur a g√©n√©r√© du code pour Foo pire que pour Bar.  Il vaut la peine de discuter de la raison pour laquelle cela √©tait inattendu.  Les programmeurs s'attendent intuitivement √† ce que le code ¬´trivial¬ª soit meilleur que le code ¬´non trivial¬ª.  C'est le cas dans la plupart des situations.  C'est notamment le cas lorsque nous effectuons un appel de fonction ou un retour: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compile</a> le code suivant: <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commande</a> x86 qui signifie ¬´ajouter¬ª.) Nous voyons que notre obj de 4 octets est pass√© √† incr dans le registre% edi, et nous ajoutons 1 √† sa valeur et le renvoyons √†% eax.  Quatre octets en entr√©e, quatre octets en sortie, facile et simple. <br><br>  Voyons maintenant incr (le cas d'un destructeur non trivial). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Ici, obj n'est pas pass√© dans le registre, malgr√© le fait qu'ici les m√™mes 4 octets avec la m√™me s√©mantique.  Ici obj est pass√© et renvoy√© √† l'adresse.  Ici, l'appelant r√©serve de l'espace pour la valeur de retour et nous transmet un pointeur vers cet espace dans rdi, et l'appelant nous donne un pointeur pour la valeur de retour obj dans le prochain registre d'arguments% rsi.  Nous extrayons la valeur de (% rsi), ajoutons 1, la sauvegardons dans (% rsi) pour mettre √† jour la valeur de obj lui-m√™me, puis copions (trivialement) 4 octets d'obj dans l'emplacement pour la valeur de retour point√©e par% rdi.  Enfin, nous copions le pointeur d'origine pass√© par l'appelant de% rdi vers% rax, puisque le document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ABI x86-64</a> (p. 22) nous dit de le faire. <br><br>  La raison pour laquelle Bar est si diff√©rent de Foo est que Bar a un destructeur non trivial, et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ABI x86-64</a> (p. 19) indique sp√©cifiquement: <br><br><blockquote>  Si un objet C ++ a un constructeur de copie non trivial ou un destructeur non trivial, il est transmis via un lien invisible (l'objet est remplac√© par un pointeur [...] dans la liste des param√®tres) </blockquote><br>  Un document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Itanium C ++ ABI</a> ult√©rieur d√©finit les √©l√©ments suivants: <br><blockquote>  Si le type de param√®tre n'est pas trivial aux fins de l'appel, l'appelant doit allouer un espace temporaire et transmettre un lien vers cet espace temporaire: <br>  [...] <br>  Un type est consid√©r√© comme non trivial aux fins de l'appel si: <br><br>  Il a un constructeur de copie non trivial, un constructeur en mouvement, un destructeur ou tous ses constructeurs en mouvement et en copie sont supprim√©s. </blockquote><br>  Cela explique donc tout: Bar a une g√©n√©ration de code moins bonne car elle est transmise via un lien invisible.  Il est transmis via un lien invisible car une combinaison malchanceuse de deux circonstances ind√©pendantes s'est produite: <br><ul><li>  Le document ABI indique que les objets avec destructeur non trivial sont pass√©s par des liens invisibles </li><li>  Bar a un destructeur non trivial. </li></ul><br>  Il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syllogisme</a> classique: le premier point est la pr√©misse principale, le second est priv√©.  En cons√©quence, Bar est transmis via un lien invisible. <br><br>  Laissez quelqu'un nous donner un syllogisme: <br><ul><li>  Tout le monde est mortel </li><li>  Socrate est un homme. </li><li>  Par cons√©quent, Socrate est mortel. </li></ul><br><br>  Si nous voulons r√©futer la conclusion ¬´Socrate est mortel¬ª, nous devons r√©futer l'une des pr√©misses: soit pour r√©futer l'essentiel (peut-√™tre que certaines personnes ne sont pas mortelles), soit pour r√©futer le priv√© (peut-√™tre que Socrate n'est pas une personne). <br><br>  Pour que Bar soit pass√© dans un registre (comme Foo), nous devons r√©futer l'un des deux pr√©misses.  Le chemin C ++ standard consiste √† donner √† Bar un destructeur trivial, d√©truisant le local priv√©.  Mais il y a une autre fa√ßon! <br><br><h3>  Comment [[trivial_abi]] r√©sout le probl√®me </h3><br>  Le nouvel attribut Clang d√©truit la pr√©misse principale.  Clang √©tend le document ABI comme suit: <br><blockquote>  Si le type de param√®tre n'est pas trivial aux fins de l'appel, l'appelant doit allouer un espace temporaire et transmettre un lien vers cet espace temporaire: <br>  [...] <br>  Un type est consid√©r√© comme non trivial aux fins de l'appel s'il est marqu√© comme [[trivial_abi]] et: <br>  Il a un constructeur de copie non trivial, un constructeur en mouvement, un destructeur ou tous ses constructeurs en mouvement et en copie sont supprim√©s. <br></blockquote><br>  M√™me si une classe avec un constructeur ou destructeur en mouvement non trivial peut √™tre consid√©r√©e comme triviale aux fins de l'appel, si elle est marqu√©e comme [[trivial_abi]]. <br><br>  Alors maintenant, en utilisant Clang, nous pouvons √©crire comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  compilez incr &lt;Baz&gt;, et obtenez le m√™me code que incr &lt;Foo&gt;! <br><h3>  Avertissement # 1: [[trivial_abi]] ne fait parfois rien </h3><br>  J'esp√®re que nous pourrions cr√©er des wrappers ¬´triviaux pour les appels¬ª sur les types de biblioth√®ques standard, comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  H√©las, cela ne fonctionne pas.  Si votre classe poss√®de une classe de base ou des champs non statiques qui ne sont ¬´pas triviaux aux fins de l'appel¬ª, l'extension Clang sous la forme dans laquelle elle est √©crite rend votre classe ¬´irr√©versiblement non triviale¬ª et l'attribut n'aura aucun effet.  (Aucun message de diagnostic n'est √©mis. Cela signifie que vous pouvez utiliser [[trivial_abi]] dans le mod√®le de classe comme attribut facultatif, et la classe sera ¬´conditionnellement triviale¬ª, ce qui est parfois utile. L'inconv√©nient, bien s√ªr, est que vous pouvez marquez la classe comme triviale, puis trouvez que le compilateur l'a corrig√©e tranquillement.) <br><br>  L'attribut est ignor√© sans messages si votre classe a une classe de base virtuelle ou des fonctions virtuelles.  Dans ces cas, il peut ne pas entrer dans les registres, et je ne sais pas ce que vous voulez obtenir en le passant par valeur, mais vous le savez probablement. <br><br>  Donc, pour autant que je sache, la seule fa√ßon d'utiliser TRIVIAL_ABI pour les ¬´types d'utilitaires standard¬ª tels que &lt;T&gt; facultatif, unique_ptr &lt;T&gt; et shared_ptr &lt;T&gt; est <br><ul><li>  impl√©mentez-les vous-m√™me √† partir de z√©ro et appliquez l'attribut, ou </li><li>  p√©n√©trer dans votre copie locale de libc ++ et y ins√©rer l'attribut avec vos mains </li></ul><br>  (dans le monde open source, les deux m√©thodes sont essentiellement les m√™mes) <br><br><h3>  Avertissement # 2: responsabilit√© du destructeur </h3><br>  Dans l'exemple avec Foo / Bar, la classe a un destructeur vide.  Laissez notre classe avoir un destructeur non trivial. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Cela devrait vous √™tre familier, c'est unique_ptr &lt;int&gt;, simplifi√© √† la limite, avec le message imprim√© lorsqu'il est supprim√©. <br><br>  Sans TRIVIAL_ABI, incr &lt;Up1&gt; ressemble juste √† incr &lt;Bar&gt;: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  Avec TRIVIAL_ABI, incr semble <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus gros et plus effrayant</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  Dans la convention d'appel traditionnelle, les types avec un destructeur non trivial sont toujours pass√©s par un lien invisible, ce qui signifie que le c√¥t√© r√©cepteur (incr dans ce cas) accepte toujours un pointeur vers un objet param√®tre sans poss√©der cet objet.  L'objet appartient √† l'appelant, ce qui fait fonctionner l'√©lision! <br><br>  Lorsqu'un type avec [[trivial_abi]] est pass√© dans les registres, nous faisons essentiellement une copie de l'objet param√®tre. <br><br>  Comme x86-64 n'a qu'un seul registre √† renvoyer (applaudissements), la fonction appel√©e n'a aucun moyen de renvoyer l'objet √† la fin.  La fonction appel√©e doit s'approprier l'objet que nous lui avons transmis!  Cela signifie que la fonction appel√©e doit appeler le destructeur de l'objet param√®tre √† la fin. <br><br>  Dans notre exemple pr√©c√©dent, Foo / Bar / Baz, le destructeur est appel√©, mais il √©tait vide et nous ne l'avons pas remarqu√©.  Maintenant, dans incr &lt;Up2&gt;, nous voyons du code suppl√©mentaire g√©n√©r√© par le destructeur du c√¥t√© de la fonction appel√©e. <br><br>  On peut supposer que ce code suppl√©mentaire peut √™tre g√©n√©r√© dans certains cas d'utilisateur.  Mais, au contraire, l'appel du destructeur n'appara√Æt nulle part!  Il est appel√© en incr car il n'est <i>pas</i> appel√© dans la fonction appelante.  Et en g√©n√©ral, le prix et les avantages seront √©quilibr√©s. <br><br><h3>  Avertissement n ¬∞ 3: Ordonnance du destructeur </h3><br>  Le destructeur d'un param√®tre avec un ABI trivial sera appel√© par la fonction appel√©e, et non par la fonction appelante (avertissement n ¬∞ 2).  Richard Smith souligne que cela signifie que cela signifie qu'il ne sera pas appel√© dans l'ordre dans lequel se trouvent les destructeurs des autres param√®tres. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Ce code imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  lorsque TRIVIAL_ABI est d√©fini comme [[clang :: trivial_abi]], il affiche: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Relation avec un objet ¬´trivialement relocalisable¬ª / ¬´move-relocates¬ª </h3><br>  Aucune relation ..., hein? <br><br>  Comme vous pouvez le voir, il n'y a aucune exigence pour que la classe [[trivial_abi]] ait une s√©mantique sp√©cifique pour un constructeur en mouvement, un destructeur ou un constructeur par d√©faut.  Toute classe particuli√®re sera probablement relocalisable de mani√®re triviale, simplement parce que la plupart des classes sont relocalisables de mani√®re triviale. <br><br>  Nous pouvons simplement rendre la classe offset_ptr afin qu'elle ne soit pas relocalisable trivialement: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Voici le code complet.</a> <br>  Lorsque TRIVIAL_ABI est d√©fini, le tronc de Clang passe ce test √† -O0 et -O1, mais √† -O2 (c'est-√†-dire d√®s qu'il essaie d'inciter les appels √† trivial_offset_ptr :: operator + = et au constructeur de copie), il se bloque lors de l'assertion. <br><br>  Un dernier avertissement.  Si votre type fait quelque chose de si fou avec un pointeur this, vous ne voudrez probablement pas le passer dans les registres. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bogue 37319</a> , en fait, une demande de documentation.  Dans ce cas, il s'av√®re qu'il n'y a aucun moyen de faire fonctionner le code comme le souhaite le programmeur.  Nous disons que la valeur de value_ devrait d√©pendre de la valeur du pointeur this, mais √† la fronti√®re entre les fonctions appelante et appel√©e, l'objet est dans les registres et le pointeur vers celui-ci n'existe pas!  Par cons√©quent, la fonction appelante l'√©crit dans la m√©moire et transmet √† nouveau le pointeur this, et comment la fonction appel√©e doit-elle calculer la valeur correcte afin de l'√©crire dans value_?  Peut-√™tre vaut-il mieux se demander comment √ßa marche m√™me √† -O0?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ce code ne devrait pas fonctionner du tout.</a> <br><br>  Donc, si vous souhaitez utiliser [[trivial_abi]], vous devez √©viter les fonctions membres (pas seulement sp√©ciales, mais en g√©n√©ral) qui d√©pendent fortement de la propre adresse de l'objet (avec une signification ind√©finie du mot ¬´essentiel¬ª). <br><br>  Intuitivement, quand une classe est marqu√©e comme [[trivial_abi]], chaque fois que vous vous attendez √† copier, vous pouvez obtenir copie plus memcpy.  Et de m√™me, lorsque vous vous attendez √† un d√©m√©nagement, vous pouvez r√©ellement obtenir le mouvement plus memcpy. <br><br>  Lorsqu'un type est ¬´trivialement relocalisable¬ª (tel que d√©fini par moi en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Now</a> ), √† chaque fois que vous vous attendez √† copier et √† d√©truire, vous pouvez r√©ellement obtenir memcpy.  Et de la m√™me mani√®re, lorsque vous vous attendez √† un d√©placement et √† une destruction, vous pouvez en fait obtenir de la m√©moire.  En fait, les appels √† des fonctions sp√©ciales sont perdus si nous parlons de ¬´relocalisation triviale¬ª, mais lorsque la classe a l'attribut [[trivial_abi]] de Clang, les appels ne sont pas perdus.  Vous obtenez juste (pour ainsi dire) memcpy en plus des appels que vous attendiez.  Cette (sorte de) memcpy est le prix √† payer pour une convention d'enregistrement des appels plus rapide. <br><br><h3>  Liens pour plus de lecture: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le fil cfe-dev d'Akira Hatanaka de novembre 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation officielle de Clang</a> <br>  <a href="">Les tests unitaires pour trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bogue 37319: trivial_offset_ptr ne peut pas fonctionner</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468759/">https://habr.com/ru/post/fr468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468741/index.html">Internet dans la ville intelligente</a></li>
<li><a href="../fr468747/index.html">Comment j'ai pass√© l'√©t√© sur VK</a></li>
<li><a href="../fr468749/index.html">√âv√©nements Android LiveData</a></li>
<li><a href="../fr468753/index.html">Daltonien - ami de l'homme (le minist√®re de la Sant√© n'a pas raison)</a></li>
<li><a href="../fr468757/index.html">Connexion MySQL apr√®s l'erreur 1040: trop de connexions</a></li>
<li><a href="../fr468761/index.html">R√©solution de probl√®mes avec pwnable.kr 24 - connexion simple. Superposition du cadre de pile</a></li>
<li><a href="../fr468765/index.html">L'importance de confirmer les commandes de contr√¥le en utilisant Delimobile comme exemple</a></li>
<li><a href="../fr468767/index.html">Jouets en bois, deuxi√®me partie - 1986-1988</a></li>
<li><a href="../fr468769/index.html">Xavier Noria sur Rails 6, conseil et plus</a></li>
<li><a href="../fr468773/index.html">La soci√©t√© d'√©nergie indienne NTPC construira un parc solaire de 5 000 m√©gawatts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>