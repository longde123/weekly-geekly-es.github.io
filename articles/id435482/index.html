<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèë üêµ üë®üèΩ‚Äçüî¨ Sorot zirkon: vDSO (Objek Bersama Dinamis virtual) ‚õÑÔ∏è üñïüèº üéÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zirkon? Apa ini 


 Pada Agustus 2016, tanpa pengumuman resmi dari Google, sumber sistem operasi baru ditemukan  Fuchsia. OS ini didasarkan pada micro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sorot zirkon: vDSO (Objek Bersama Dinamis virtual)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435482/"><h2 id="zircon-chto-eto">  Zirkon?  Apa ini </h2><br><p>  Pada Agustus 2016, tanpa pengumuman resmi dari Google, sumber sistem operasi baru ditemukan <img src="https://habrastorage.org/webt/s3/vk/vq/s3vkvqkdg0wsatckxecdfekkdyk.png">  Fuchsia.  OS ini didasarkan pada microkernel yang disebut Zircon, yang pada gilirannya didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LK (Little Kernel)</a> . </p><br><blockquote>  Fuchsia bukan Linux </blockquote><br><div class="spoiler">  <b class="spoiler_title">Catatan Penerjemah</b> <div class="spoiler_text"><p>  Saya tidak <del>  tukang las yang nyata </del>  Saya seorang pengembang dan / atau ahli di Zircon.  Teks di bawah potongan adalah <em>kompilasi dari</em> terjemahan parsial: <a href="">dokumentasi Zircon vDSO resmi</a> dan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengagumi Zircon Bagian 1: Memahami Pembuatan Proses Minimal</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@depletionmode</a> , di mana sedikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lelucon telah</a> ditambahkan (yang dihapus untuk spoiler).  Oleh karena itu, saran konstruktif untuk meningkatkan artikel, seperti biasa, dipersilakan </p></div></div><br><h2 id="o-chem-poydet-rech-v-state">  Apa yang akan dibahas dalam artikel? </h2><br><p>  vDSO di Zircon adalah <strong>satu</strong> - <strong>satunya</strong> cara mengakses <a href="">panggilan sistem (syscalls)</a> . </p><br><p>  Apakah benar-benar mustahil untuk langsung menghubungi instruksi prosesor SYSENTER / SYSCALL dari kode kami?  Tidak, instruksi prosesor ini bukan bagian dari sistem ABI.  Kode pengguna dilarang untuk langsung mengikuti instruksi ini. </p><br><p>  Mereka yang ingin mengetahui lebih detail tentang langkah arsitektur seperti itu, saya mengundang Anda ke Cat. </p><br><p><img src="https://habrastorage.org/webt/ns/64/h3/ns64h3y_inuxdxyycmdcmedcjba.png"></p><a name="habracut"></a><br><h2 id="zircon-vdso-virtual-dynamic-shared-object">  Zircon vDSO (Objek Bersama Dinamis virtual) </h2><br><p>  Singkatan vDSO adalah singkatan dari irtual <strong>D</strong> ynamic <strong>S</strong> hared <strong>O</strong> bject: </p><br><ul><li>  Dynamic Shared Object adalah istilah yang digunakan untuk merujuk ke perpustakaan bersama untuk format ELF (file .so). </li><li>  Objek ini virtual karena tidak memuat dari file terpisah yang ada di sistem file.  Gambar vDSO disediakan langsung oleh kernel. </li></ul><br><h2 id="podderzhka-so-storony-yadra">  Dukungan kernel </h2><br><p>  Dukungan untuk vDSO sebagai satu-satunya ABI yang dikontrol untuk aplikasi mode pengguna diimplementasikan dalam dua cara: </p><br><ol><li><p> Memproyeksikan objek memori virtual ( <a href="">VMO, Objek Memori Virtual</a> ). <br><br>  Ketika <a href="">zx_vmar_map</a> memproses VMO untuk vDSO (dan <code>ZX_VM_PERM_EXECUTE</code> diminta dalam argumen), kernel mensyaratkan bahwa offset dan ukuran secara ketat sesuai dengan segmen vDSO yang dapat dieksekusi.  Ini (termasuk) menjamin hanya satu proyeksi vDSO ke dalam memori proses.  Setelah proyeksi sukses pertama vDSO ke dalam proses, itu tidak lagi dapat dihapus.  Dan upaya untuk memproyeksikan ulang vDSO ke dalam memori proses, upaya untuk menghapus VMO yang diproyeksikan untuk vDSO atau proyek dengan offset yang salah dan / atau ukuran gagal dengan kesalahan <code>ZX_ERR_ACCESS_DENIED</code> . <br>  Offset dan ukuran kode vDSO diekstraksi pada tahap kompilasi dari file ELF dan kemudian digunakan dalam kode kernel untuk melakukan pemeriksaan di atas.  Setelah proyeksi vDSO pertama yang berhasil, kernel OS akan mengingat alamat untuk proses target untuk mempercepat pemeriksaan. </p><br></li><li><p>  Periksa alamat pengirim untuk fungsi-fungsi panggilan sistem. <br><br>  Ketika kode mode pengguna memanggil kernel, nomor panggilan sistem tingkat rendah ditransmisikan dalam register.  Panggilan sistem tingkat rendah adalah antarmuka internal (pribadi) antara vDSO dan inti Zircon.  Beberapa (sebagian besar) secara langsung berhubungan dengan panggilan sistem ABI publik, sementara yang lain tidak. <br>  Untuk setiap panggilan sistem tingkat rendah dalam kode vDSO, ada set offset tetap dalam kode yang melakukan panggilan ini.  Kode sumber untuk vDSO mendefinisikan karakter internal yang mengidentifikasi setiap lokasi tersebut.  Pada waktu kompilasi, lokasi ini diambil dari tabel simbol vDSO dan digunakan untuk menghasilkan kode kernel yang menentukan prediksi validitas alamat kode untuk setiap panggilan sistem tingkat rendah.  Predikat ini memungkinkan Anda untuk dengan cepat memeriksa kode panggilan untuk validitas, mengingat offset dari awal segmen kode vDSO. <br>  Jika predikat menentukan bahwa kode panggilan tidak diperbolehkan untuk membuat panggilan sistem, pengecualian sintetis dilemparkan, mirip dengan yang sama seperti jika kode panggilan mencoba untuk menjalankan instruksi yang tidak ada atau istimewa. </p><br></li></ol><br><h2 id="vdso-pri-sozdanii-novogo-processa">  vDSO saat membuat proses baru </h2><br><p>  Untuk memulai eksekusi utas pertama dari proses yang baru dibuat, panggilan sistem <a href="">zx_process_start digunakan</a> .  Parameter terakhir dari panggilan sistem ini (lihat arg2 dalam dokumentasi) melewati argumen untuk utas pertama dari proses yang dibuat.  Menurut perjanjian yang diterima, program loader memetakan vDSO ke ruang alamat proses baru (ke tempat acak yang dipilih oleh sistem) dan mentransfer alamat basis pemetaan dengan argumen arg2 ke utas pertama dari proses yang dibuat.  Alamat ini adalah alamat header file ELF, di mana fungsi-fungsi bernama yang diperlukan dapat ditemukan untuk melakukan panggilan sistem. </p><br><h2 id="karta-pamyati-layout-vdso">  Kartu memori (tata letak) vDSO </h2><br><p>  vDSO adalah pustaka bersama EFL biasa yang dapat dianggap seperti yang lain.  Tetapi untuk vDSO, sebagian kecil dari seluruh format ELF sengaja dipilih.  Ini memiliki beberapa keunggulan: </p><br><ul><li>  Pemetaan ELF seperti itu ke dalam proses itu sederhana dan tidak termasuk kasus batas kompleks yang diperlukan untuk sepenuhnya mendukung program ELF. </li><li>  Menggunakan vDSO tidak membutuhkan pengikatan ELF dinamis yang berfungsi penuh.  Secara khusus, vDSO tidak memiliki relokasi dinamis.  Memproyeksikan segmen PT_LOAD dari file ELF adalah satu-satunya tindakan yang diperlukan. </li><li>  Kode vDSO adalah stateless dan reentrant.  Ini bekerja secara eksklusif dengan register prosesor dan tumpukan.  Ini membuatnya cocok untuk digunakan dalam berbagai konteks dengan pembatasan minimal, yang sesuai dengan sistem operasi ABI wajib.  Ini juga menyederhanakan analisis kode dan verifikasi untuk keandalan dan keamanan. </li></ul><br><p>  Semua memori vDSO diwakili oleh dua segmen berurutan, yang masing-masing berisi seluruh halaman yang selaras: </p><br><ol><li>  Segmen pertama adalah hanya-baca dan termasuk header ELF serta data konstan. </li><li>  Segmen kedua dapat dieksekusi dan berisi kode vDSO. </li></ol><br><p>  Seluruh gambar vDSO hanya terdiri dari halaman dari dua segmen ini.  Hanya dua nilai yang diekstrak dari header ELF diperlukan untuk menampilkan memori vDSO: jumlah halaman di setiap segmen. </p><br><h2 id="konstantnye-dannye-vremeni-zagruzki-os">  Data konstan waktu boot OS </h2><br><p>  Beberapa panggilan sistem mengembalikan nilai yang konstan (nilai harus diminta saat runtime dan tidak dapat dikompilasi ke dalam kode mode pengguna).  Nilai-nilai ini ditetapkan dalam kernel pada waktu kompilasi, atau ditentukan oleh kernel pada saat boot (parameter boot dan parameter perangkat keras).  Misalnya: <a href="">zx_system_get_version ()</a> , <a href="">zx_system_get_num_cpus ()</a> dan <a href="">zx_ticks_per_second ()</a> .  Nilai kembali dari fungsi terakhir, misalnya, dipengaruhi oleh parameter <a href="">baris perintah kernel</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Tunggu, apakah jumlah CPU konstan?</b> <div class="spoiler_text"><p>  Menariknya, deskripsi fungsi <a href="">zx_system_get_num_cpus ()</a> juga secara eksplisit menyatakan bahwa OS tidak mendukung <em>hot-</em> <a href="">swapping</a> jumlah prosesor: </p><br><blockquote>  Jumlah ini tidak dapat berubah selama menjalankan sistem, hanya pada saat boot. </blockquote><p>  Ini, setidaknya, secara tidak langsung menunjukkan bahwa OS tidak diposisikan sebagai server. </p></div></div><br><p>  Karena nilai-nilai ini konstan, tidak masuk akal untuk membayar panggilan sistem nyata ke kernel OS.  Sebaliknya, implementasinya adalah fungsi C ++ sederhana yang mengembalikan data yang dibaca dari segmen konstan vDSO.  Nilai yang diambil selama kompilasi (seperti string versi sistem) dikompilasi ke dalam vDSO. </p><br><p>  Untuk nilai yang ditentukan saat boot, kernel harus memodifikasi konten vDSO.  Ini dilakukan dengan menggunakan kode yang dapat dieksekusi lebih awal yang membentuk VMO vDSO sebelum kernel memulai proses pengguna pertama (dan memberikannya deskriptor VMO).  Selama kompilasi, offset dari gambar vDSO ( <a href="">vdso_constants</a> ) diekstraksi dari file ELF dan kemudian disematkan ke dalam kernel.  Dan pada saat boot, kernel sementara menampilkan halaman yang mencakup <a href="">vdso_constants</a> di ruang alamatnya sendiri untuk pra-inisialisasi struktur dengan nilai-nilai yang benar (untuk startup sistem saat ini). </p><br><h2 id="k-chemu-vsya-eta-golovnaya-bol">  Kenapa semua <em>sakit kepala</em> ini? </h2><br><p>  Salah satu alasan terpenting adalah keamanan.  Artinya, jika penyerang berhasil mengeksekusi kode arbitrer (shell-), ia harus menggunakan fungsi vDSO untuk memanggil fungsi sistem.  Rintangan pertama adalah pengacakan alamat boot vDSO tersebut untuk setiap proses yang dibuat.  Dan karena kernel OS bertanggung jawab untuk VMO vDSO (objek memori virtual), ia dapat memilih untuk memetakan vDSO yang sama sekali berbeda untuk proses tertentu, sehingga melarang panggilan sistem yang berbahaya (dan tidak diperlukan untuk proses tertentu).  Misalnya: Anda dapat mencegah <a href="">driver</a> memunculkan proses anak atau menangani memproyeksikan area MMIO.  Ini adalah alat yang hebat untuk mengurangi permukaan serangan. </p><br><p>  Catatan: Saat ini, dukungan untuk beberapa vDSO sedang dikembangkan secara aktif.  Sudah ada implementasi konsep bukti dan tes sederhana, tetapi lebih banyak pekerjaan diperlukan untuk meningkatkan keandalan implementasi dan menentukan opsi mana yang tersedia.  Konsep saat ini menyediakan opsi gambar vDSO yang hanya mengekspor subset dari antarmuka panggilan sistem vDSO lengkap. </p><br><div class="spoiler">  <b class="spoiler_title">Bagaimana dengan sistem operasi lain?</b> <div class="spoiler_text"><p>  Perlu dicatat bahwa teknik serupa telah berhasil digunakan dalam sistem operasi lain.  Misalnya, pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windows ada ProcessSystemCallDisablePolicy</a> : </p><br><blockquote>  Win32k System Call Disable Restriction untuk membatasi kemampuan menggunakan NTUser dan GDI </blockquote></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435482/">https://habr.com/ru/post/id435482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435466/index.html">React Tutorial Bagian 6: Beberapa Fitur Kursus, JSX, dan JavaScript</a></li>
<li><a href="../id435468/index.html">Bereaksi Tutorial Bagian 7: Gaya Inline</a></li>
<li><a href="../id435470/index.html">Bereaksi Tutorial, Bagian 8: Melanjutkan Pekerjaan pada Aplikasi TODO, Memperkenalkan Properti Komponen</a></li>
<li><a href="../id435476/index.html">Mkcert: sertifikat HTTPS yang valid untuk localhost</a></li>
<li><a href="../id435480/index.html">Microsoft dan Kroger akan memberikan perlawanan kepada Amazon di bidang ... perdagangan makanan</a></li>
<li><a href="../id435484/index.html">Gaya fuzzing 1989</a></li>
<li><a href="../id435488/index.html">Mengolok-olok, bertopik dan mata-mata di Kerangka Kerja Spock</a></li>
<li><a href="../id435490/index.html">Perubahan pajak Google pada 2019</a></li>
<li><a href="../id435494/index.html">Server klien yang mulus</a></li>
<li><a href="../id435496/index.html">Tesla menggugat karena kecelakaan di mana pengemudi dan penumpang Model S meninggal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>