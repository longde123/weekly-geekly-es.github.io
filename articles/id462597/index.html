<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÇ üßõüèΩ üíÖüèΩ Mengetik naskah dan bereaksi üôéüèª üíô ‚öóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perkembangan Javascript terkadang menjadi seperti seorang detektif. Bagaimana cara memahami kode orang lain? Ada baiknya jika pengembang memiliki kete...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengetik naskah dan bereaksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462597/"><p> Perkembangan Javascript terkadang menjadi seperti seorang detektif.  Bagaimana cara memahami kode orang lain?  Ada baiknya jika pengembang memiliki keterampilan halus dalam penamaan variabel sehingga orang lain mengerti maksudnya.  Tetapi bagaimana jika anggota tim masih tidak selalu dapat memahami maksud rekan mereka?  Bagaimana memahami apa yang menjadi argumen dari suatu fungsi? </p><br><p>  Misalkan argumen fungsi disebut kesalahan.  Mungkin kesalahan adalah array.  Garis yang paling mungkin?  Nah, array itu bisa dimengerti.  Lagi pula, panjangnya diperiksa lebih lanjut.  Tetapi properti panjang juga memiliki string.  Tampaknya untuk mengetahui dengan tepat, Anda harus meletakkan breakpoint dan menjalankan skrip.  Lalu, lewati skrip di UI sepenuhnya (misalnya, kita perlu langkah terakhir dari formulir).  Sekarang di devtools dapat dilihat bahwa kesalahan adalah objek dengan seperangkat bidang tertentu, termasuk bidang panjang. </p><br><p>  Ketidakjelasan dalam penguraian kode javascript menyebabkan pemborosan waktu pengembang.  Solusi yang baik dalam hal ini bisa berupa naskah (selanjutnya disebut ts).  Anda dapat menggunakannya di proyek berikutnya, atau bahkan lebih baik, membuat dukungan di yang sudah ada.  Setelah itu, waktu untuk memahami kode orang lain akan berkurang secara signifikan.  Memang, untuk memahami struktur data apa pun, cukup satu klik saja sudah cukup.  Anda dapat berkonsentrasi pada logika bekerja dengan data dan kapan saja tahu bahwa Anda memahami kode dengan jelas. </p><a name="habracut"></a><br><p>  Beberapa keunggulan ts harus diperhatikan.  Ini banyak digunakan dalam berbagai kerangka kerja dan terkait erat dengan javascript.  Pengembangan ts ditentukan oleh kebutuhan pengembang frontend. </p><br><p>  Artikel ini menyajikan pengembangan aplikasi todo, tetapi hanya uraian singkat tentang poin-poin menarik.  Kode lengkap dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Saya menggunakan reaksi, naskah dan mobx.  Mobx adalah alat yang fleksibel untuk mengelola keadaan aplikasi.  Mobx ringkas.  Ini memungkinkan Anda untuk bekerja dengan keadaan komponen reaksi dalam gaya sinkron.  Tidak masalah seperti: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'another string'</span></span>}); alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name);</code> </pre> <br><p>  Dalam hal ini, state.name lama ditampilkan. </p><br><p>  Selain itu, mobx nyaman dan tidak mengganggu bekerja dengan tipe ts.  Anda dapat menggambarkan status sebagai kelas terpisah atau langsung di dalam komponen reaksi. </p><br><p>  Untuk mempermudah, semua komponen ditempatkan di folder komponen.  Kelas didefinisikan dalam folder komponen dengan deskripsi keadaan yang secara logis dikaitkan dengan tampilan dan operasi komponen. </p><br><p>  Folder TodoItem berisi file dengan komponen reaksi TodoItem.tsx, file dengan gaya TodoItem.module.scss, dan file status TodoItemState.ts. </p><br><p>  TodoItemState.ts menjelaskan bidang untuk menyimpan data, cara mengaksesnya, dan aturan untuk mengubahnya.  Berbagai kemungkinan sangat besar berkat OOP dan ts.  Sebagian dari data dapat bersifat pribadi, sebagian hanya-baca dan sebagainya.  Menggunakan @o dekorator, bidang yang dapat diamati ditentukan.  Bereaksi komponen bereaksi terhadap perubahannya.  Dekorator @a ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">aksi</a> ) digunakan dalam metode untuk mengubah status. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// TodoItemState.ts import { action as a, observable as o } from 'mobx'; export interface ITodoItem { id: string; name: string; completed: boolean; } export class TodoItemState { @o public readonly value: ITodoItem; @o public isEditMode: boolean = false; constructor(value: ITodoItem) { this.value = value; } @a public setIsEditMode = (value: boolean = true) =&gt; { this.isEditMode = value; }; @a public editName = (name: string) =&gt; { this.value.name = name; }; @a public editCompleted = (completed: boolean) =&gt; { this.value.completed = completed; }; }</span></span></code> </pre> <br><p>  Di TodoItem.tsx, hanya dua properti yang diteruskan ke properti.  Dalam mobx, optimal untuk kinerja keseluruhan aplikasi untuk mentransfer struktur data yang kompleks ke komponen reaksi alat peraga.  Karena kita menggunakan ts, kita dapat secara tepat menunjukkan jenis objek yang diterima oleh komponen. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// TodoItem.tsx import React, { ChangeEventHandler } from 'react'; import { observer } from 'mobx-react'; import { TodoItemState } from './TodoItemState'; import { EditModal } from 'components/EditModal'; import classNames from 'classnames'; import classes from './TodoItem.module.scss'; export interface ITodoItemProps { todo: TodoItemState; onDelete: (id: string) =&gt; void; } @observer export class TodoItem extends React.Component&lt;ITodoItemProps&gt; { private handleCompletedChange: ChangeEventHandler&lt;HTMLInputElement&gt; = e =&gt; { const { todo: { editCompleted }, } = this.props; editCompleted(e.target.checked); }; private handleDelete = () =&gt; { const { onDelete, todo } = this.props; onDelete(todo.value.id); }; private get editModal() { const { todo } = this.props; if (!todo.isEditMode) return null; return ( &lt;EditModal name={todo.value.name} onSubmit={this.handleSubmitEditName} onClose={this.closeEditModal} /&gt; ); } private handleSubmitEditName = (name: string) =&gt; { const { todo } = this.props; todo.editName(name); this.closeEditModal(); }; private closeEditModal = () =&gt; { const { todo } = this.props; todo.setIsEditMode(false); }; private openEditModal = () =&gt; { const { todo } = this.props; todo.setIsEditMode(); }; render() { const { todo } = this.props; const { name, completed } = todo.value; return ( &lt;div className={classes.root}&gt; &lt;input className={classes.chackbox} type="checkbox" checked={completed} onChange={this.handleCompletedChange} /&gt; &lt;div onClick={this.openEditModal} className={classNames( classes.name, completed &amp;&amp; classes.completedName )}&gt; {name} &lt;/div&gt; &lt;button onClick={this.handleDelete}&gt;del&lt;/button&gt; {this.editModal} &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Antarmuka ITodoItemProps menjelaskan properti todo tipe TodoItemState.  Jadi, di dalam komponen reaksi, kami diberikan data untuk tampilan dan metode untuk mengubahnya.  Selain itu, pembatasan mengubah data dapat dijelaskan baik di kelas negara dan dalam metode komponen reaksi, tergantung pada tugas. </p><br><p>  Komponen TodoList mirip dengan TodoItem.  Di TodoListState.ts, Anda dapat melihat getter dengan dekorator @c (@computed).  Ini adalah getter kelas biasa, hanya nilainya yang di-memo dan diceritakan kembali ketika dependensinya berubah.  Dihitung dengan desain mirip dengan penyeleksi redux.  Mudahnya, tidak perlu, seperti React.memo atau pilih kembali, untuk secara eksplisit melewati daftar dependensi.  Bereaksi komponen menanggapi perubahan yang dihitung serta perubahan yang dapat diamati.  Fitur yang menarik adalah bahwa penghitungan ulang nilai tidak terjadi jika dihitung saat ini tidak terlibat dalam rendering (yang menghemat sumber daya).  Oleh karena itu, meskipun mempertahankan nilai ketergantungan konstan, dihitung dapat dihitung ulang (ada cara untuk secara eksplisit memberitahu mobx untuk menyimpan nilai yang dihitung). </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// TodoListState.ts import { action as a, observable as o, computed as c } from 'mobx'; import { ITodoItem, TodoItemState } from 'components/TodoItem'; export enum TCurrentView { completed, active, all, } export class TodoListState { @o public currentView: TCurrentView = TCurrentView.all; @o private _todos: TodoItemState[] = []; @c public get todos(): TodoItemState[] { switch (this.currentView) { case TCurrentView.active: return this.activeTodos; case TCurrentView.completed: return this.completedTodos; default: return this._todos; } } @c public get completedTodos() { return this._todos.filter(t =&gt; t.value.completed); } @c public get activeTodos() { return this._todos.filter(t =&gt; !t.value.completed); } @a public setTodos(todos: ITodoItem[]) { this._todos = todos.map(t =&gt; new TodoItemState(t)); } @a public addTodo = (todo: ITodoItem) =&gt; { this._todos.push(new TodoItemState(todo)); }; @a public removeTodo = (id: string): boolean =&gt; { const index = this._todos.findIndex(todo =&gt; todo.value.id === id); if (index === -1) return false; this._todos.splice(index, 1); return true; }; }</span></span></code> </pre> <br><p>  Daftar todo akses terbuka hanya melalui bidang yang dihitung, di mana, tergantung pada mode tampilan, set data yang diperlukan yang disaring dikembalikan (selesai, aktif atau semua todo).  Dependensi todo menentukan bidang completeTodos yang dihitung, activeTodos yang dihitung, dan private _todos yang dapat diamati. </p><br><p>  Pertimbangkan komponen utama Aplikasi.  Itu membuat formulir untuk menambahkan todo baru dan daftar todo.  Sebuah instance dari negara AppSate utama dibuat secara instan. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// App.tsx import React from 'react'; import { observer } from 'mobx-react'; import { TodoList, initialTodos } from 'components/TodoList'; import { AddTodo } from 'components/AddTodo'; import { AppState } from './AppState'; import classes from './App.module.scss'; export interface IAppProps {} @observer export class App extends React.Component&lt;IAppProps&gt; { private appState = new AppState(); constructor(props: IAppProps) { super(props); this.appState.todoList.setTodos(initialTodos); } render() { const { addTodo, todoList } = this.appState; return ( &lt;div className={classes.root}&gt; &lt;div className={classes.container}&gt; &lt;AddTodo onAdd={addTodo} /&gt; &lt;TodoList todoListState={todoList} /&gt; &lt;/div&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Bidang appState berisi turunan dari kelas TodoListState untuk menampilkan komponen TodoList dan metode untuk menambahkan todo baru, yang diteruskan ke komponen AddTodo. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// AppState.ts import { action as a } from 'mobx'; import { TodoListState } from 'components/TodoList'; import { ITodoItem } from 'components/TodoItem'; export class AppState { public todoList = new TodoListState(); @a public addTodo = (value: string) =&gt; { const newTodo: ITodoItem = { id: Date.now().toString(), name: value, completed: false, }; this.todoList.addTodo(newTodo); }; }</span></span></code> </pre> <br><p>  Komponen AddTodo memiliki status terisolasi.  Tidak ada akses ke sana dari keadaan umum.  Satu-satunya koneksi ke appState adalah melalui metode appState.addTodo saat mengirimkan formulir. <br>  Untuk status komponen AddTodo, pustaka formstate digunakan, yang merupakan teman baik dengan ts dan mobx.  Formstate memungkinkan Anda bekerja dengan nyaman dengan formulir, memvalidasi formulir, dan banyak lagi.  Formulir hanya memiliki satu nama bidang yang diperlukan. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// AddTodoState.ts import { FormState, FieldState } from 'formstate'; export class AddTodoState { // Create a field public name = new FieldState('').validators( val =&gt; !val &amp;&amp; 'name is required' ); // Compose fields into a form public form = new FormState({ name: this.name, }); public onSubmit = async () =&gt; { // Validate all fields const res = await this.form.validate(); // If any errors you would know if (res.hasError) { console.error(this.form.error); return; } const name = this.name.$; this.form.reset(); return name; }; }</span></span></code> </pre> <br><p>  Secara umum, tidak masuk akal untuk sepenuhnya menggambarkan perilaku semua komponen.  Kode lengkapnya diberikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Artikel ini menjelaskan upaya penulis untuk menulis kode sederhana, fleksibel, dan terstruktur yang mudah dipelihara.  Bereaksi membagi UI menjadi komponen.  Komponen menggambarkan kelas negara (masing-masing kelas dapat diuji secara terpisah).  Contoh status dibuat baik di komponen itu sendiri atau di tingkat yang lebih tinggi, tergantung pada tugas.  Cukup mudah, Anda bisa menentukan tipe bidang kelas dan tipe properti komponen berkat naskah.  Berkat mobx, kita dapat, hampir tanpa terasa bagi pengembang, membuat komponen bereaksi bereaksi terhadap perubahan data. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462597/">https://habr.com/ru/post/id462597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462585/index.html">Pembuatan CRUD cepat dengan sarang, @ nestjsx / kasar dan TestMace</a></li>
<li><a href="../id462587/index.html">AirTest IDE dan Image Recognition - Otomatisasi pengujian game seluler berdasarkan pengenalan gambar</a></li>
<li><a href="../id462589/index.html">Buat saluran pipa untuk memproses data streaming. Bagian 2</a></li>
<li><a href="../id462593/index.html">Di sisi lain dudukan</a></li>
<li><a href="../id462595/index.html">Audit dan pengujian surat: apa yang harus Anda perhatikan saat tata letak</a></li>
<li><a href="../id462601/index.html">Mencadangkan server windows di AWS</a></li>
<li><a href="../id462605/index.html">Jejak Italia dalam kriptografi</a></li>
<li><a href="../id462607/index.html">Bagaimana saya menulis perpustakaan untuk layanan Yandex.Music</a></li>
<li><a href="../id462615/index.html">Mengapa sangat sulit untuk memilih film mana yang akan ditonton (dan jaringan saraf tidak akan menyelesaikan masalah ini)</a></li>
<li><a href="../id462619/index.html">Anak-anak, Matematika, dan R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>