<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍👩 🏄 👨🏿‍🌾 Hexagon Maps in Unity: Path Finder, Pemain Regu, Animasi 👨🏽‍🔧 🖐🏻 👆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1-3: jala, warna, dan tinggi sel 

 Bagian 4-7: gundukan, sungai, dan jalan 

 Bagian 8-11: air, bentang alam, dan benteng 

 Bagian 12-15: men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hexagon Maps in Unity: Path Finder, Pemain Regu, Animasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426481/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1-3: jala, warna, dan tinggi sel</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4-7: gundukan, sungai, dan jalan</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8-11: air, bentang alam, dan benteng</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 12-15: menyimpan dan memuat, tekstur, jarak</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 16-19: menemukan jalan, regu pemain, animasi</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 20-23: Kabut Perang, Penelitian Peta, Generasi Prosedural</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 24-27: siklus air, erosi, bioma, peta silindris</a> <br><br><h1>  Bagian 16: menemukan jalan </h1><br><ul><li>  Sorot sel </li><li>  Pilih target pencarian </li><li>  Temukan jalur terpendek </li><li>  Buat antrian prioritas </li></ul><br>  Setelah menghitung jarak antar sel, kami melanjutkan untuk menemukan jalur di antara mereka. <br><br>  Dimulai dengan bagian ini, tutorial peta segi enam akan dibuat di Unity 5.6.0.  Perlu dicatat bahwa dalam 5.6 ada bug yang menghancurkan array tekstur dalam rakitan untuk beberapa platform.  Anda dapat menyiasatinya dengan memasukkan <em>Apakah Dapat Dibaca</em> di inspektur array tekstur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>Merencanakan perjalanan</i> <br><a name="habracut"></a><br><h2>  Sel yang disorot </h2><br>  Untuk mencari jalur antara dua sel, pertama-tama kita harus memilih sel-sel ini.  Lebih dari sekadar memilih satu sel dan memantau pencarian di peta.  Sebagai contoh, pertama-tama kita akan memilih sel awal, dan kemudian yang terakhir.  Dalam hal ini, akan lebih mudah bagi mereka untuk disorot.  Karena itu, mari kita tambahkan fungsionalitas tersebut.  Sampai kita menciptakan cara penyorotan yang canggih atau efisien, kita hanya menciptakan sesuatu untuk membantu kita dalam pengembangan. <br><br><h3>  Tekstur garis besar </h3><br>  Salah satu cara sederhana untuk memilih sel adalah dengan menambahkan path ke dalamnya.  Cara termudah untuk melakukan ini adalah dengan tekstur yang mengandung garis heksagonal.  <a href="">Di sini</a> Anda dapat mengunduh tekstur seperti itu.  Ini transparan kecuali untuk garis putih segi enam.  Setelah membuatnya putih, di masa depan kita akan dapat mewarnainya sesuai kebutuhan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>Garis sel pada latar belakang hitam</i> <br><br>  Impor tekstur dan atur <em>Jenis Teksturnya</em> ke <em>Sprite</em> .  <em>Mode Sprite-</em> nya akan diatur ke <em>Tunggal</em> dengan pengaturan default.  Karena ini adalah tekstur yang sangat putih, kita tidak perlu mengonversi ke <em>sRGB</em> .  Saluran alfa menunjukkan transparansi, jadi aktifkan <em>Alpha adalah Transparansi</em> .  Saya juga mengatur tekstur <em>Mode Filter</em> ke <em>Trilinear</em> , karena kalau tidak transisi mip untuk jalur mungkin menjadi terlalu mencolok. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>Opsi Impor Tekstur</i> <br><br><h3>  Satu sprite per sel </h3><br>  Cara tercepat adalah menambahkan kontur yang mungkin ke sel, menambahkan masing-masing sprite sendiri.  Buat objek game baru, tambahkan komponen Gambar ( <em>Komponen / UI / Gambar</em> ) ke dalamnya dan tetapkan sprite garis besar kami.  Lalu masukkan contoh cetakan <em>Hex Cell Label</em> ke dalam adegan, buat objek sprite menjadi anak dari itu, terapkan perubahan pada cetakan, dan kemudian singkirkan cetakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>Elemen Pemilihan Anak Prefab</i> <br><br>  Sekarang setiap sel memiliki sprite, tetapi akan terlalu besar.  Untuk membuat kontur cocok dengan pusat sel, ubah <em>Lebar</em> dan <em>Tinggi</em> komponen transformasi sprite menjadi 17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>Pilihan sprite sebagian disembunyikan oleh lega</i> <br><br><h3>  Menggambar di atas segalanya </h3><br>  Karena kontur ditumpangkan pada area tepi sel, sering muncul di bawah geometri relief.  Karena itu, bagian dari sirkuit menghilang.  Ini dapat dihindari dengan sedikit menaikkan sprite secara vertikal, tetapi tidak dalam kasus istirahat.  Sebagai gantinya, kita dapat melakukan hal berikut: selalu menggambar sprite di atas segalanya.  Untuk melakukan ini, buat spader shader Anda sendiri.  Cukup bagi kita untuk menyalin sprite shader Unity standar dan membuat beberapa perubahan padanya. <br><br><pre><code class="hljs powershell">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Highlight"</span></span> { Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">MaterialToggle</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelSnap</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Pixel snap"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RendererColor</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"RendererColor"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Flip"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableExternalAlpha</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Enable External Alpha"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"PreviewType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Plane"</span></span> <span class="hljs-string"><span class="hljs-string">"CanUseSpriteAtlas"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> } Cull Off ZWrite Off Blend One OneMinusSrcAlpha Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">#pragma vertex SpriteVert #pragma fragment SpriteFrag #pragma target 2.0 #pragma multi_compile_instancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #include "UnitySprites.cginc" ENDCG } } }</span></span></code> </pre> <br>  Perubahan pertama adalah kita mengabaikan buffer kedalaman, membuat uji-Z selalu berhasil. <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br>  Perubahan kedua adalah bahwa kita membuat setelah sisa dari geometri transparan.  Cukup menambahkan 10 ke antrian transparansi. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br>  Buat materi baru yang akan digunakan shader ini.  Kami dapat mengabaikan semua propertinya, mengikuti nilai default.  Kemudian buat prefab sprite menggunakan bahan ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>Kami menggunakan bahan sprite kami sendiri</i> <br><br>  Sekarang kontur seleksi selalu terlihat.  Bahkan jika sel disembunyikan di bawah lega yang lebih tinggi, garis besarnya masih akan digambarkan di atas segalanya.  Itu mungkin tidak terlihat indah, tetapi sel-sel yang dipilih akan selalu terlihat, yang berguna bagi kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>Abaikan buffer kedalaman</i> <br><br><h3>  Kontrol pemilihan </h3><br>  Kami tidak ingin semua sel disorot secara bersamaan.  Bahkan, pada awalnya mereka semua harus tidak dipilih.  Kita dapat menerapkan ini dengan menonaktifkan komponen Gambar dari objek cetakan awal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>Komponen Gambar Dinonaktifkan</i> <br><br>  Untuk mengaktifkan pemilihan sel, tambahkan metode <code>EnableHighlight</code> ke <code>EnableHighlight</code> .  Ini harus mengambil satu-satunya anak dari <code>uiRect</code> dan memasukkan komponen <code>uiRect</code> .  Kami juga akan membuat metode <code>DisableHighlight</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Akhirnya, kita bisa menentukan warna sehingga ketika dihidupkan, beri rona latar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Menemukan jalan </h2><br>  Sekarang kita dapat memilih sel, kita perlu bergerak dan memilih dua sel, dan kemudian menemukan jalur di antara mereka.  Pertama-tama kita harus memilih sel, kemudian membatasi pencarian ke jalur di antara mereka, dan akhirnya menunjukkan jalur ini. <br><br><h3>  Mulai pencarian </h3><br>  Kita perlu memilih dua sel yang berbeda, titik awal dan akhir pencarian.  Misalkan untuk memilih sel pencarian awal, tahan tombol Shift kiri sambil mengklik mouse.  Dalam hal ini, sel disorot dengan warna biru.  Kami perlu menyimpan tautan ke sel ini untuk pencarian lebih lanjut.  Selain itu, ketika memilih sel awal yang baru, pemilihan yang lama harus dinonaktifkan.  Oleh karena itu, kami menambahkan bidang <code>searchFromCell</code> ke <code>searchFromCell</code> . <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br>  Di dalam <code>HandleInput</code> kita bisa menggunakan <code>Input.GetKey(KeyCode.LeftShift)</code> untuk menguji tombol Shift yang ditekan. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>Di mana mencarinya</i> <br><br><h3>  Cari titik akhir </h3><br>  Alih-alih mencari semua jarak ke sel, kami sekarang mencari jalur antara dua sel tertentu.  Oleh karena itu, ganti nama <code>HexGrid.FindDistancesTo</code> menjadi <code>HexGrid.FindPath</code> dan berikan parameter <code>HexCell</code> , ubah metode <code>Search</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); … }</code> </pre> <br>  Sekarang <code>HexMapEditor.HandleInput</code> harus memanggil metode yang dimodifikasi, menggunakan <code>searchFromCell</code> dan <code>currentCell</code> sebagai argumen.  Selain itu, kita dapat mencari hanya ketika kita tahu dari sel mana untuk mencari.  Dan kita tidak perlu repot mencari jika titik awal dan akhir bertepatan. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br>  Beralih ke pencarian, pertama-tama kita harus menyingkirkan semua pilihan sebelumnya.  Karena itu, buat <code>HexGrid.Search</code> matikan pilihan saat mengatur ulang jarak.  Karena ini juga mematikan iluminasi sel awal, kemudian hidupkan kembali.  Pada tahap ini, kita juga bisa menyoroti titik akhir.  Mari kita membuatnya merah. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>Titik akhir dari jalur potensial</i> <br><br><h3>  Batasi pencarian </h3><br>  Pada titik ini, algoritma pencarian kami masih menghitung jarak ke semua sel yang dapat dijangkau dari sel awal.  Tapi kami tidak membutuhkannya lagi.  Kita bisa berhenti begitu menemukan jarak terakhir ke sel terakhir.  Yaitu, ketika sel saat ini terbatas, kita dapat keluar dari loop algoritma. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>Berhenti di titik akhir</i> <br><br><div class="spoiler">  <b class="spoiler_title">Apa yang terjadi jika titik akhir tidak dapat dijangkau?</b> <div class="spoiler_text">  Kemudian algoritma akan terus bekerja sampai menemukan semua sel yang dapat dijangkau.  Tanpa kemungkinan keluar prematur, ini akan berfungsi sebagai metode <code>FindDistancesTo</code> lama. </div></div><br><h3>  Tampilan jalur </h3><br>  Kita dapat menemukan jarak antara awal dan akhir jalan, tetapi belum tahu jalan yang sebenarnya.  Untuk menemukannya, Anda perlu melacak bagaimana setiap sel tercapai.  Tetapi bagaimana cara melakukannya? <br><br>  Saat menambahkan sel ke perbatasan, kami melakukan ini karena itu adalah tetangga sel saat ini.  Satu-satunya pengecualian adalah sel awal.  Semua sel lain telah dijangkau melalui sel saat ini.  Jika kita melacak dari sel mana masing-masing sel itu berasal, kita mendapatkan jaringan sel sebagai hasilnya.  Lebih tepatnya, jaringan seperti pohon, yang root adalah titik awal.  Kita dapat menggunakannya untuk membangun jalur setelah mencapai titik akhir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>Jaringan pohon menggambarkan jalur ke pusat</i> <br><br>  Kami dapat menyimpan informasi ini dengan menambahkan tautan ke sel lain di <code>HexCell</code> .  Kami tidak perlu membuat serialisasi data ini, jadi kami menggunakan properti standar untuk ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Dalam <code>HexGrid.Search</code> atur nilai <code>PathFrom</code> dari tetangga ke sel saat ini ketika menambahkannya ke perbatasan.  Selain itu, kami perlu mengubah tautan ini ketika kami menemukan cara yang lebih pendek ke tetangga. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br>  Setelah mencapai titik akhir, kita dapat memvisualisasikan jalur dengan mengikuti tautan ini kembali ke sel awal dan memilihnya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>Path ditemukan</i> <br><br>  Perlu mempertimbangkan bahwa seringkali ada beberapa jalur terpendek.  Yang ditemukan tergantung pada urutan pemrosesan sel.  Beberapa jalur mungkin terlihat bagus, yang lain mungkin buruk, tetapi tidak pernah ada jalan yang lebih pendek.  Kami akan kembali ke sini nanti. <br><br><h3>  Ubah awal pencarian </h3><br>  Setelah memilih titik awal, mengubah titik akhir akan memicu pencarian baru.  Hal yang sama harus terjadi ketika memilih sel awal yang baru.  Untuk memungkinkan ini, <code>HexMapEditor</code> juga harus mengingat titik akhir. <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br>  Dengan menggunakan bidang ini, kami juga dapat memulai pencarian baru saat memilih awal yang baru. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br>  Selain itu, kita perlu menghindari titik awal dan akhir yang sama. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { … }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Pencarian Lebih Cerdas </h2><br>  Meskipun algoritme kami menemukan jalur terpendek, algoritma ini menghabiskan banyak waktu menjelajahi titik yang jelas tidak akan menjadi bagian dari jalur ini.  Setidaknya sudah jelas bagi kami.  Algoritme tidak dapat melihat ke bawah pada peta, tidak dapat melihat bahwa pencarian di beberapa arah tidak akan berarti.  Dia lebih suka bergerak di jalan, terlepas dari kenyataan bahwa mereka menuju ke arah yang berlawanan dari titik akhir.  Apakah mungkin membuat pencarian lebih pintar? <br><br>  Saat ini, ketika memilih sel untuk diproses berikutnya, kami hanya mempertimbangkan jarak dari sel ke awal.  Jika kita ingin berbuat lebih pintar, maka kita juga harus mempertimbangkan jarak ke titik akhir.  Sayangnya, kita belum mengenalnya.  Tapi kita bisa membuat estimasi jarak yang tersisa.  Menambahkan perkiraan ini pada jarak ke sel memberi kita pemahaman tentang total panjang jalan yang melewati sel ini.  Kemudian kita dapat menggunakannya untuk memprioritaskan pencarian sel. <br><br><h3>  Cari Heuristik </h3><br>  Saat kami menggunakan estimasi atau dugaan alih-alih data yang diketahui secara tepat, ini disebut menggunakan heuristik pencarian.  Heuristik ini merupakan tebakan terbaik dari jarak yang tersisa.  Kita harus menentukan nilai ini untuk setiap sel yang kita cari, jadi kita akan menambahkan properti integer <code>HexCell</code> untuknya.  Kita tidak perlu membuat cerita bersambung, jadi properti standar lain sudah cukup. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Bagaimana kita membuat asumsi tentang jarak yang tersisa?  Dalam kasus paling ideal, kita akan memiliki jalan yang mengarah langsung ke titik akhir.  Jika demikian, maka jaraknya sama dengan jarak yang tidak berubah antara koordinat sel ini dan sel akhir.  Mari kita manfaatkan hal ini dalam heuristik kita. <br><br>  Karena heuristik tidak bergantung pada jalur yang telah dilalui sebelumnya, maka ia konstan dalam proses pencarian.  Oleh karena itu, kita perlu menghitungnya hanya sekali ketika <code>HexGrid.Search</code> menambahkan sel ke perbatasan. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3>  Prioritas Pencarian </h3><br>  Mulai sekarang, kami akan menentukan prioritas pencarian berdasarkan jarak ke sel plus heuristiknya.  Mari menambahkan properti untuk nilai ini di <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br>  Agar ini berfungsi, <code>HexGrid.Search</code> sehingga ia menggunakan properti ini untuk mengurutkan perbatasan. <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>Cari tanpa heuristik dan dengan heuristik</i> <br><br><h3>  Heuristik yang valid </h3><br>  Berkat prioritas pencarian baru, kami sebenarnya akan mengunjungi lebih sedikit sel sebagai hasilnya.  Namun, pada peta yang seragam, algoritme masih memproses sel yang berada di arah yang salah.  Ini karena, secara default, biaya untuk setiap langkah adalah 5, dan heuristik per langkah hanya menambahkan 1. Artinya, pengaruh heuristik tidak terlalu kuat. <br><br>  Jika biaya pemindahan semua kartu sama, maka kita dapat menggunakan biaya yang sama saat menentukan heuristik.  Dalam kasus kami, ini akan menjadi heuristik saat ini dikalikan dengan 5. Ini akan secara signifikan mengurangi jumlah sel yang diproses. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>Menggunakan heuristik × 5</i> <br><br>  Namun, jika ada jalan di peta, maka kita bisa melebih-lebihkan jarak yang tersisa.  Alhasil, algoritma bisa membuat kesalahan dan membuat jalur yang sebenarnya bukan yang terpendek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>Heuristik berlebihan dan valid</i> <br><br>  Untuk memastikan bahwa jalur terpendek ditemukan, kita perlu memastikan bahwa kita tidak pernah melebih-lebihkan jarak yang tersisa.  Pendekatan ini disebut heuristik yang valid.  Karena biaya minimum untuk bergerak adalah 1, kami tidak punya pilihan selain menggunakan biaya yang sama dalam menentukan heuristik. <br><br>  Sebenarnya, sangat normal untuk menggunakan biaya yang lebih rendah, tetapi ini hanya akan membuat heuristik lebih lemah.  Heuristik minimum yang mungkin adalah nol, yang hanya memberi kita algoritma Dijkstra.  Dengan heuristik yang bukan nol, algoritma ini disebut A <sup>*</sup> (dilafalkan "A star"). <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa disebut A *?</b> <div class="spoiler_text">  Gagasan menambahkan heuristik ke algoritma Dijkstra pertama kali diusulkan oleh Niels Nilsson.  Dia menamai versinya A1.  Bertram Rafael kemudian datang dengan versi terbaik yang ia sebut A2.  Kemudian Peter Hart membuktikan bahwa dengan heuristik A2 yang baik adalah optimal, artinya, tidak ada versi yang lebih baik.  Ini memaksanya untuk memanggil algoritma A <sup>*</sup> untuk menunjukkan bahwa itu tidak dapat diperbaiki, yaitu, A3 atau A4 tidak akan muncul.  Jadi ya, algoritma A <sup>*</sup> adalah yang terbaik yang bisa kita dapatkan, tetapi sama bagusnya dengan heuristiknya. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Antrian prioritas </h2><br>  Meskipun A <sup>* adalah</sup> algoritma yang baik, implementasi kami tidak begitu efektif, karena kami menggunakan daftar untuk menyimpan perbatasan, yang perlu disortir di setiap iterasi.  Seperti disebutkan di bagian sebelumnya, kita perlu antrian prioritas, tetapi penerapan standarnya tidak ada.  Karena itu, mari kita buat sendiri. <br><br>  Giliran kita harus mendukung operasi pengaturan dan pengecualian dari antrian berdasarkan prioritas.  Ini juga harus mendukung perubahan prioritas sel yang sudah ada dalam antrian.  Idealnya, kami menerapkannya, meminimalkan pencarian untuk menyortir dan mengalokasikan memori.  Selain itu, harus tetap sederhana. <br><br><h3>  Buat antrian Anda sendiri </h3><br>  Buat kelas <code>HexCellPriorityQueue</code> baru dengan metode umum yang diperlukan.  Kami menggunakan daftar sederhana untuk melacak konten antrian.  Selain itu, kami akan menambahkan metode <code>Clear</code> untuk menghapus antrian sehingga dapat digunakan berulang kali. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br>  Kami menyimpan prioritas sel di dalam sel itu sendiri.  Artinya, sebelum menambahkan sel ke antrian, prioritasnya harus ditetapkan.  Tetapi jika terjadi perubahan prioritas, mungkin akan berguna untuk mengetahui apa prioritas lama itu.  Jadi mari kita tambahkan ini ke <code>Change</code> sebagai parameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Ini juga berguna untuk mengetahui berapa banyak sel dalam antrian, jadi mari kita tambahkan properti <code>Count</code> untuk ini.  Cukup gunakan bidang yang kami akan melakukan kenaikan dan penurunan yang sesuai. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3>  Tambahkan ke Antrean </h3><br>  Ketika sel ditambahkan ke antrian, pertama mari kita gunakan prioritasnya sebagai indeks, memperlakukan daftar sebagai array sederhana. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br>  Namun, ini hanya berfungsi jika daftar tersebut cukup panjang, jika tidak kita akan melampaui batas.  Anda dapat menghindari ini dengan menambahkan item kosong ke daftar hingga mencapai panjang yang diperlukan.  Elemen kosong ini tidak mereferensikan sel, jadi Anda bisa membuatnya dengan menambahkan <code>null</code> ke daftar. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>Daftar dengan lubang</i> <br><br>  Tetapi ini adalah bagaimana kami menyimpan hanya satu sel per prioritas, dan kemungkinan besar akan ada beberapa.  Untuk melacak semua sel dengan prioritas yang sama, kita perlu menggunakan daftar lain.  Meskipun kami dapat menggunakan daftar nyata untuk setiap prioritas, kami juga dapat menambahkan properti ke <code>HexCell</code> untuk mengikat mereka bersama.  Ini memungkinkan kami membuat rantai sel yang disebut daftar tertaut. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Untuk membuat rantai, biarkan <code>HexCellPriorityQueue.Enqueue</code> memaksa sel yang baru ditambahkan untuk merujuk ke nilai saat ini dengan prioritas yang sama, sebelum menghapusnya. <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>Daftar daftar tertaut</i> <br><br><h3>  Hapus dari antrian </h3><br>  Untuk mendapatkan sel dari antrian prioritas, kita perlu mengakses daftar tertaut di indeks non-kosong terendah.  Oleh karena itu, kita akan berkeliling daftar dalam satu lingkaran sampai kita menemukannya.  Jika kami tidak menemukan, maka antriannya kosong dan kami mengembalikan <code>null</code> . <br><br>  Dari rantai yang ditemukan, kita dapat mengembalikan sel apa pun, karena semuanya memiliki prioritas yang sama.  Cara termudah adalah mengembalikan sel dari awal rantai. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Untuk menjaga tautan ke rantai yang tersisa, gunakan sel berikutnya dengan prioritas yang sama dengan awal yang baru.  Jika hanya ada satu sel pada tingkat prioritas ini, maka elemen menjadi <code>null</code> dan akan dilewati di masa depan. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3>  Pelacakan minimum </h3><br>  Pendekatan ini berfungsi, tetapi beralih melalui daftar setiap kali sel diterima.  Kita tidak dapat menghindari menemukan indeks non -tyty terkecil, tetapi kita tidak diharuskan mulai dari awal setiap waktu.  Sebagai gantinya, kami dapat melacak prioritas minimum dan memulai pencarian dengannya.  Awalnya, minimum pada dasarnya sama dengan tak terbatas. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br>  Saat menambahkan sel ke antrian, kami mengubah minimum yang diperlukan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } … }</code> </pre> <br>  Dan ketika menarik diri dari antrian, kami menggunakan setidaknya daftar untuk iterasi, dan jangan mulai dari awal. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Ini secara signifikan mengurangi jumlah waktu yang diperlukan untuk memotong dalam loop daftar prioritas. <br><br><h3>  Ubah Prioritas </h3><br>  Saat mengubah prioritas sel, itu harus dihapus dari daftar tertaut yang merupakan bagiannya.  Untuk melakukan ini, kita perlu mengikuti rantai sampai kita menemukannya. <br><br>  Mari kita mulai dengan menyatakan bahwa kepala daftar prioritas lama akan menjadi sel saat ini, dan kami juga akan melacak sel berikutnya.  Kita dapat segera mengambil sel berikutnya, karena kita tahu bahwa setidaknya ada satu sel dengan indeks ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br>  Jika sel saat ini adalah sel yang diubah, maka ini adalah sel kepala dan kita dapat memotongnya seolah-olah kita telah mengeluarkannya dari antrian. <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br>  Jika ini tidak terjadi, maka kita perlu mengikuti rantai sampai kita berada di sel di depan sel yang berubah.  Ini berisi tautan ke sel yang telah dimodifikasi. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br>  Pada titik ini, kita dapat menghapus sel yang diubah dari daftar tertaut, melompati sel. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br>  Setelah menghapus sel, Anda perlu menambahkannya lagi sehingga muncul dalam daftar prioritas barunya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { … Enqueue(cell); }</code> </pre> <br>  Metode <code>Enqueue</code> menambah penghitung, tetapi dalam kenyataannya kami tidak menambahkan sel baru.  Karena itu, untuk mengkompensasi ini, kita harus mengurangi penghitung. <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3>  Penggunaan antrian </h3><br>  Sekarang kita dapat memanfaatkan antrian prioritas kami di <code>HexGrid</code> .  Ini dapat dilakukan dengan satu instance, dapat digunakan kembali untuk semua operasi pencarian. <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum memulai loop, metode </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terlebih dahulu harus ditambahkan ke antrian </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan setiap iterasi dimulai dengan output sel dari antrian. </font><font style="vertical-align: inherit;">Ini akan menggantikan kode perbatasan yang lama.</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah kode sehingga menambah dan mengubah tetangga. </font><font style="vertical-align: inherit;">Sebelum perubahan kita akan mengingat prioritas lama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu, kita tidak perlu lagi menyortir perbatasan. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian menggunakan antrian prioritas</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang disebutkan sebelumnya, jalur terpendek yang ditemukan tergantung pada urutan pemrosesan sel. </font><font style="vertical-align: inherit;">Giliran kita menciptakan urutan yang berbeda dari urutan daftar yang diurutkan, sehingga kita bisa mendapatkan cara lain. </font><font style="vertical-align: inherit;">Karena kami menambah dan menghapus dari kepala daftar yang ditautkan untuk setiap prioritas, mereka lebih seperti tumpukan daripada antrian. </font><font style="vertical-align: inherit;">Sel yang ditambahkan terakhir diproses terlebih dahulu. </font><font style="vertical-align: inherit;">Efek samping dari pendekatan ini adalah bahwa algoritma tersebut rawan zigzag. </font><font style="vertical-align: inherit;">Oleh karena itu, kemungkinan jalur zigzag juga meningkat. </font><font style="vertical-align: inherit;">Untungnya, jalur seperti itu biasanya terlihat lebih baik, sehingga efek samping ini menguntungkan kita.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar dan antrian </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">diurutkan </font></a><i><font style="vertical-align: inherit;">dengan prioritas </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 17: gerakan terbatas </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menemukan cara untuk gerakan langkah demi langkah. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Segera tampilkan jalurnya. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membuat pencarian yang lebih efektif. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memvisualisasikan hanya jalur. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di bagian ini, kami akan membagi gerakan menjadi gerakan dan mempercepat pencarian sebanyak mungkin. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perjalanan dari beberapa gerakan</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerakan langkah demi langkah </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game strategi yang menggunakan jaring segi enam hampir selalu berbasis giliran. </font><font style="vertical-align: inherit;">Unit yang bergerak di peta memiliki kecepatan terbatas, yang membatasi jarak yang ditempuh dalam satu putaran.</font></font><br><br><h3>  Kecepatan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memberikan dukungan untuk gerakan terbatas, kami menambahkan </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan ke dalam </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter integer </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini menentukan rentang gerakan untuk satu gerakan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbagai jenis unit dalam permainan menggunakan kecepatan yang berbeda. </font><font style="vertical-align: inherit;">Kavaleri cepat, infanteri lambat, dan sebagainya. </font><font style="vertical-align: inherit;">Kami belum memiliki unit, jadi untuk saat ini kami akan menggunakan kecepatan konstan. </font><font style="vertical-align: inherit;">Mari kita ambil nilai 24. Ini adalah nilai yang cukup besar, tidak habis dibagi 5 (biaya default untuk pindah). </font><font style="vertical-align: inherit;">Menambahkan argumen untuk </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecepatan konstan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bergerak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain melacak total biaya bergerak di sepanjang jalan, kita sekarang juga perlu tahu berapa banyak gerakan yang diperlukan untuk bergerak di sepanjang jalan. Tetapi kita tidak perlu menyimpan informasi ini di setiap sel. Itu bisa diperoleh dengan membagi jarak yang ditempuh dengan kecepatan. Karena ini adalah bilangan bulat, kami akan menggunakan divisi bilangan bulat. Artinya, total jarak tidak lebih dari 24 sesuai dengan jalur 0. Ini berarti bahwa keseluruhan jalur dapat diselesaikan dalam jalur saat ini. Jika titik akhir berada pada jarak 30, maka ini harus belok 1. Untuk sampai ke titik akhir, unit harus menghabiskan semua gerakannya di belokan saat ini dan di bagian dari belokan berikutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita tentukan jalannya sel saat ini dan semua tetangganya di dalam</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Perjalanan sel saat ini dapat dihitung hanya sekali, tepat sebelum berkeliling dalam siklus tetangga. </font><font style="vertical-align: inherit;">Langkah tetangga dapat ditentukan segera setelah kami menemukan jarak dengannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerakan yang hilang </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika langkah tetangga lebih besar dari langkah saat ini, maka kami melewati batas langkah tersebut. </font><font style="vertical-align: inherit;">Jika gerakan yang diperlukan untuk mencapai tetangga adalah 1, maka semuanya baik-baik saja. </font><font style="vertical-align: inherit;">Tetapi jika pindah ke sel berikutnya lebih mahal, maka semuanya menjadi lebih rumit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan kita bergerak di sepanjang peta homogen, yaitu, untuk masuk ke setiap sel Anda membutuhkan 5 unit gerakan. </font><font style="vertical-align: inherit;">Kecepatan kami adalah 24. Setelah empat langkah, kami menghabiskan 20 unit dari stok pergerakan kami, dan ada 4 yang tersisa. Pada langkah berikutnya, 5 unit dibutuhkan lagi, yaitu, satu lebih banyak dari yang tersedia. </font><font style="vertical-align: inherit;">Apa yang perlu kita lakukan pada tahap ini?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada dua pendekatan untuk situasi ini. Yang pertama adalah memungkinkan unit untuk memasuki sel kelima pada giliran saat ini, bahkan jika kita tidak memiliki cukup gerakan. Yang kedua adalah untuk melarang gerakan selama gerakan saat ini, yaitu, poin gerakan yang tersisa tidak dapat digunakan dan mereka akan hilang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan opsi tergantung pada gim. Secara umum, pendekatan pertama lebih tepat untuk game di mana unit hanya dapat bergerak beberapa langkah per giliran, misalnya, untuk game dalam seri Civilization. Ini memastikan bahwa unit selalu dapat bergerak setidaknya satu sel per putaran. Jika unit dapat memindahkan banyak sel per giliran, seperti di Age of Wonders atau di Battle for Wesnoth, maka opsi kedua lebih baik.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita menggunakan kecepatan 24, mari kita pilih pendekatan kedua. </font><font style="vertical-align: inherit;">Agar mulai bekerja, kita perlu mengisolasi biaya masuk ke sel berikutnya sebelum menambahkannya ke jarak saat ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika akibatnya kita melewati batas gerakan, maka pertama-tama kita menggunakan semua titik gerakan dari gerakan saat ini. </font><font style="vertical-align: inherit;">Kita bisa melakukan ini hanya dengan mengalikan langkah dengan kecepatan. </font><font style="vertical-align: inherit;">Setelah itu, kami menambahkan biaya pemindahan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasil dari ini, kami akan menyelesaikan langkah pertama di sel keempat dengan 4 titik gerakan yang tidak digunakan. </font><font style="vertical-align: inherit;">Titik-titik yang hilang ini ditambahkan ke biaya sel kelima, sehingga jaraknya menjadi 29, bukan 25. Akibatnya, jaraknya lebih besar dari sebelumnya. </font><font style="vertical-align: inherit;">Sebagai contoh, sel kesepuluh memiliki jarak 50. Tapi sekarang untuk masuk ke dalamnya, kita perlu melintasi batas dua gerakan, kehilangan 8 titik gerakan, yaitu jarak ke sekarang menjadi 58.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih lama dari yang diharapkan</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena titik pergerakan yang tidak digunakan ditambahkan ke jarak ke sel, mereka diperhitungkan saat menentukan jalur terpendek. </font><font style="vertical-align: inherit;">Cara paling efektif adalah membuang poin sesedikit mungkin. </font><font style="vertical-align: inherit;">Karenanya, pada kecepatan yang berbeda, kita bisa mendapatkan jalur yang berbeda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menampilkan gerakan alih-alih jarak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat kami memainkan game, kami tidak terlalu tertarik dengan nilai jarak yang digunakan untuk menemukan jalur terpendek. </font><font style="vertical-align: inherit;">Kami tertarik pada jumlah gerakan yang diperlukan untuk mencapai titik akhir. </font><font style="vertical-align: inherit;">Karena itu, alih-alih jarak, mari kita tampilkan gerakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, singkirkan </font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilannya </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } … // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai gantinya, kami akan menambah </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode umum </font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menerima string arbitrer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan metode baru ini dalam </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membersihkan sel. </font><font style="vertical-align: inherit;">Untuk menyembunyikan sel, cukup tetapkan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lalu kami memberikan nilai tetangganya kepada tetangganya. </font><font style="vertical-align: inherit;">Setelah itu, kita akan dapat melihat berapa banyak gerakan tambahan yang diperlukan untuk melakukan semuanya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah gerakan yang diperlukan untuk bergerak di sepanjang jalur paket </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jalur instan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saat kami bermain game, kami tidak peduli bagaimana algoritma pencarian jalur menemukan jalannya. </font><font style="vertical-align: inherit;">Kami ingin segera melihat jalur yang diminta. </font><font style="vertical-align: inherit;">Saat ini, kami dapat memastikan bahwa algoritme berfungsi, jadi mari kita singkirkan visualisasi pencarian.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tanpa corutin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk bagian yang lambat melalui algoritma, kami menggunakan corutin. </font><font style="vertical-align: inherit;">Kami tidak perlu melakukan ini lagi, jadi kami akan menyingkirkan panggilan </font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebagai gantinya, kami hanya memintanya </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai metode biasa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); … } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita tidak lagi menggunakannya </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai coroutine, maka tidak perlu hasil, jadi kita akan menyingkirkan operator ini. </font><font style="vertical-align: inherit;">Ini berarti bahwa kami juga akan menghapus deklarasi </font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengubah tipe pengembalian metode menjadi </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); … } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil instan</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definisi waktu pencarian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita bisa mendapatkan jalur secara instan, tetapi seberapa cepat mereka dihitung? Jalur pendek muncul hampir dengan segera, tetapi jalur panjang di peta besar mungkin tampak agak lambat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mengukur berapa banyak waktu yang diperlukan untuk menemukan dan menampilkan jalan. Kita dapat menggunakan profiler untuk menentukan waktu pencarian, tetapi ini sedikit terlalu banyak dan menciptakan biaya tambahan. Mari kita gunakan </font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang ada di namespace </font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena kami hanya menggunakannya untuk sementara, saya tidak akan menambahkan konstruk </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke awal skrip. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepat sebelum pencarian, buat stopwatch baru dan mulai saja. Setelah pencarian selesai, hentikan stopwatch dan tampilkan waktu yang berlalu di konsol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita pilih kasus terburuk untuk algoritma kami - pencarian dari kiri bawah ke sudut kanan atas peta besar. Yang terburuk adalah peta yang seragam, karena algoritme harus memproses semua 4.800 sel peta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cari dalam kasus terburuk Waktu yang</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dihabiskan untuk mencari bisa berbeda, karena editor Unity bukan satu-satunya proses yang berjalan pada mesin Anda. Jadi cobalah beberapa kali untuk mendapatkan pemahaman tentang durasi rata-rata. Dalam kasus saya, pencarian membutuhkan waktu sekitar 45 milidetik. Ini tidak terlalu banyak dan sesuai dengan 22,22 jalur per detik; menyatakan ini sebagai 22 pps (jalur per detik). Ini berarti bahwa frame rate dari permainan juga akan berkurang hingga maksimum 22 fps dalam frame itu ketika jalur ini dihitung. Dan ini tanpa memperhitungkan semua pekerjaan lain, misalnya, merender bingkai itu sendiri. Artinya, kami mendapatkan penurunan frame rate yang cukup besar, itu akan turun menjadi 20 fps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat melakukan tes kinerja seperti itu, Anda perlu mempertimbangkan bahwa kinerja editor Unity tidak akan setinggi kinerja aplikasi yang sudah selesai. </font><font style="vertical-align: inherit;">Jika saya melakukan tes yang sama dengan perakitan, maka rata-rata hanya butuh 15 ms. </font><font style="vertical-align: inherit;">Itu adalah 66 pps, yang jauh lebih baik. </font><font style="vertical-align: inherit;">Namun demikian, ini masih merupakan bagian besar dari sumber daya yang dialokasikan per frame, sehingga frame rate akan menjadi lebih rendah dari 60 fps.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di mana saya dapat melihat log debug untuk perakitan?</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cari hanya jika perlu. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat membuat optimasi sederhana - melakukan pencarian hanya saat diperlukan. </font><font style="vertical-align: inherit;">Sementara kami memulai pencarian baru di setiap frame di mana tombol mouse ditekan. </font><font style="vertical-align: inherit;">Oleh karena itu, frame rate akan terus-menerus diremehkan saat diseret dan dijatuhkan. </font><font style="vertical-align: inherit;">Kita dapat menghindari ini dengan memulai pencarian baru </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya ketika kita benar-benar berurusan dengan titik akhir yang baru. </font><font style="vertical-align: inherit;">Jika tidak, maka jalur yang terlihat saat ini masih valid.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilkan label hanya untuk jalur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menampilkan tanda perjalanan adalah operasi yang agak mahal, terutama karena kami menggunakan pendekatan yang tidak dioptimalkan. </font><font style="vertical-align: inherit;">Melakukan operasi ini untuk semua sel pasti akan memperlambat eksekusi. </font><font style="vertical-align: inherit;">Jadi mari kita lewati label </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita perlu melihat informasi ini hanya untuk jalur yang ditemukan. </font><font style="vertical-align: inherit;">Oleh karena itu, setelah mencapai titik akhir, kami akan menghitung kursus dan mengatur label hanya sel-sel yang ada di jalan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menampilkan label untuk sel path saja</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kami hanya menyertakan label sel antara awal dan akhir. </font><font style="vertical-align: inherit;">Tetapi titik akhirnya adalah hal yang paling penting, kita juga harus menetapkan label untuk itu. </font><font style="vertical-align: inherit;">Anda bisa melakukan ini dengan memulai siklus jalur dari sel tujuan, dan bukan dari sel di depannya. </font><font style="vertical-align: inherit;">Dalam kasus ini, iluminasi titik akhir dari merah akan berubah menjadi putih, jadi kami akan menghapus cahaya latar di bawah siklus.</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informasi kemajuan paling penting untuk titik akhir.Setelah</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perubahan ini, waktu kasus terburuk dikurangi menjadi 23 milidetik dalam editor dan 6 milidetik dalam perakitan selesai. </font><font style="vertical-align: inherit;">Ini adalah 43 pps dan 166 pps - jauh lebih baik. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pencarian paling cerdas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian sebelumnya, kami membuat prosedur pencarian lebih pintar dengan menerapkan algoritma A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Namun, pada kenyataannya kami masih belum melakukan pencarian dengan cara yang paling optimal. </font><font style="vertical-align: inherit;">Dalam setiap iterasi, kami menghitung jarak dari sel saat ini ke semua tetangganya. </font><font style="vertical-align: inherit;">Ini berlaku untuk sel yang belum atau saat ini menjadi bagian dari batas pencarian. </font><font style="vertical-align: inherit;">Tetapi sel-sel yang telah dihilangkan dari perbatasan, tidak perlu lagi dipertimbangkan, karena kami telah menemukan jalur terpendek ke sel-sel ini. </font><font style="vertical-align: inherit;">Implementasi yang benar dari A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melewatkan sel-sel ini, sehingga kita dapat melakukan hal yang sama.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fase Pencarian Sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana kita tahu jika sel telah meninggalkan perbatasan? </font><font style="vertical-align: inherit;">Meskipun kita tidak bisa menentukan ini. </font><font style="vertical-align: inherit;">Karena itu, Anda perlu melacak pada fase apa pencarian sel itu. </font><font style="vertical-align: inherit;">Dia belum berada di perbatasan, atau di dalamnya sekarang, atau di luar negeri. </font><font style="vertical-align: inherit;">Kami dapat melacak ini dengan menambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti integer sederhana.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Misalnya, 0 berarti bahwa sel belum mencapai, 1 - bahwa sel berada di perbatasan sekarang, dan 2 - bahwa ia telah dihapus dari perbatasan. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memukul perbatasan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita dapat mengatur ulang semua sel ke 0 dan selalu menggunakan 1 untuk perbatasan. </font><font style="vertical-align: inherit;">Atau kami dapat menambah jumlah perbatasan dengan setiap pencarian baru. </font><font style="vertical-align: inherit;">Berkat ini, kita tidak harus berurusan dengan pembuangan sel jika kita setiap kali menambah jumlah perbatasan dua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu mengatur fase pencarian sel saat menambahkannya ke perbatasan. </font><font style="vertical-align: inherit;">Proses dimulai dengan sel awal, yang ditambahkan ke perbatasan.</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan juga setiap kali kita menambahkan tetangga ke perbatasan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemeriksaan perbatasan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sampai sekarang, untuk memverifikasi bahwa sel belum ditambahkan ke perbatasan, kami menggunakan jarak yang sama dengan </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sekarang kita dapat membandingkan fase pencarian sel dengan perbatasan saat ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini berarti bahwa kita tidak perlu lagi mengatur ulang jarak sel sebelum mencari, artinya, kita harus melakukan lebih sedikit pekerjaan, yang bagus. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meninggalkan perbatasan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika sel dihapus dari batas, kami menyatakan ini dengan peningkatan fase pencariannya. </font><font style="vertical-align: inherit;">Ini menempatkannya di luar perbatasan saat ini dan sebelum yang berikutnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita dapat melewati sel yang dihapus dari perbatasan, menghindari perhitungan yang tidak berguna dan perbandingan jarak. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, algoritma kami masih menghasilkan hasil yang sama, tetapi lebih efisien. </font><font style="vertical-align: inherit;">Di mesin saya, pencarian terburuk membutuhkan 20 ms di editor dan 5 ms di majelis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga dapat menghitung berapa kali sel diproses oleh algoritma, meningkatkan penghitung saat menghitung jarak ke sel. </font><font style="vertical-align: inherit;">Sebelumnya, algoritma kami dalam kasus terburuk menghitung 28.239 jarak. </font><font style="vertical-align: inherit;">Dalam algoritma A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siap pakai, </font><font style="vertical-align: inherit;">kami menghitung 14.120 jaraknya. </font><font style="vertical-align: inherit;">Jumlahnya berkurang 50%. </font><font style="vertical-align: inherit;">Tingkat dampak indikator-indikator ini terhadap produktivitas tergantung pada biaya dalam menghitung biaya pemindahan. </font><font style="vertical-align: inherit;">Dalam kasus kami, tidak ada banyak pekerjaan di sini, jadi peningkatan dalam perakitan tidak terlalu besar, tetapi sangat terlihat di editor. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membersihkan jalan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat memulai pencarian baru, pertama-tama kita perlu menghapus visualisasi dari jalur sebelumnya. </font><font style="vertical-align: inherit;">Saat kami melakukan ini, matikan pilihan dan hapus label dari setiap sel kisi. </font><font style="vertical-align: inherit;">Ini adalah pendekatan yang sangat sulit. </font><font style="vertical-align: inherit;">Idealnya, kita hanya perlu membuang sel-sel yang merupakan bagian dari jalur sebelumnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cari Saja </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan menghapus kode visualisasi sepenuhnya </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dia hanya perlu melakukan pencarian jalur dan tidak harus tahu apa yang akan kita lakukan dengan informasi ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } … } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melaporkan bahwa </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami telah menemukan cara, kami akan mengembalikan boolean.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } … } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ingat jalannya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika jalan ditemukan, kita perlu mengingatnya. </font><font style="vertical-align: inherit;">Berkat ini, kita akan dapat membersihkannya di masa depan. </font><font style="vertical-align: inherit;">Oleh karena itu, kami akan melacak titik akhir dan apakah ada jalur di antara mereka.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilkan jalan lagi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menggunakan data pencarian yang kita rekam untuk memvisualisasikan jalan lagi. </font><font style="vertical-align: inherit;">Mari kita buat metode baru untuk ini </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan melalui siklus dari ujung ke awal jalan, menyorot sel dan menetapkan nilai stroke ke label mereka. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu mengetahui kecepatannya, jadi buatlah parameter. </font><font style="vertical-align: inherit;">Jika kami tidak memiliki jalur, maka metode hanya memilih titik akhir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggil metode ini </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah pencarian.</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sapu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat jalan lagi, tetapi sekarang tidak bergerak menjauh. </font><font style="vertical-align: inherit;">Untuk menghapusnya, buat metode </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bahkan, itu adalah salinan </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kecuali bahwa itu menonaktifkan pemilihan dan label, tetapi tidak termasuk mereka. </font><font style="vertical-align: inherit;">Setelah melakukan ini, ia harus menghapus data jalur yang direkam yang tidak lagi valid.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan menggunakan metode ini, kita dapat menghapus visualisasi jalur lama dengan hanya mengunjungi sel yang diperlukan, ukuran peta tidak lagi penting. </font><font style="vertical-align: inherit;">Kami akan memanggilnya </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum memulai pencarian baru.</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu, kami akan menghapus jalur saat membuat peta baru. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan juga sebelum memuat kartu lain. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisasi jalur dihapus lagi, seperti sebelum perubahan ini. </font><font style="vertical-align: inherit;">Tetapi sekarang kami menggunakan pendekatan yang lebih efisien, dan dalam kasus pencarian terburuk, waktu telah berkurang menjadi 14 milidetik. </font><font style="vertical-align: inherit;">Perbaikan yang cukup serius hanya karena pembersihan yang lebih cerdas. </font><font style="vertical-align: inherit;">Waktu perakitan menurun hingga 3 ms, yaitu 333 pps. </font><font style="vertical-align: inherit;">Berkat ini, pencarian jalur tepat berlaku di waktu nyata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami telah melakukan pencarian cepat untuk jalur, kami dapat menghapus kode debug sementara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 18: unit </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menempatkan regu di peta. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simpan dan muat regu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menemukan cara untuk pasukan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memindahkan unit. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kami telah menemukan cara untuk mencari jalur, mari kita tempatkan pasukan di peta. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bala bantuan tiba</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat regu </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini kita hanya berurusan dengan sel dan objek tetapnya. </font><font style="vertical-align: inherit;">Unit berbeda dari mereka dalam hal mereka mobile. </font><font style="vertical-align: inherit;">Pasukan dapat berarti apa saja dari skala apa pun, dari satu orang atau kendaraan hingga seluruh pasukan. </font><font style="vertical-align: inherit;">Dalam tutorial ini, kami membatasi diri untuk jenis unit sederhana sederhana. </font><font style="vertical-align: inherit;">Setelah itu, kami akan beralih ke kombinasi pendukung beberapa jenis unit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pasukan Prefab </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk bekerja dengan regu, buat tipe komponen baru </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk sekarang, mari kita mulai dengan yang kosong </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian menambahkan fungsionalitasnya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat objek game kosong dengan komponen ini, yang seharusnya menjadi cetakan. </font><font style="vertical-align: inherit;">Ini akan menjadi objek root dari skuad.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasukan Prefab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan model 3D yang melambangkan detasemen sebagai objek anak. </font><font style="vertical-align: inherit;">Saya menggunakan kubus skala sederhana yang saya buat bahan biru. </font><font style="vertical-align: inherit;">Objek root menentukan tingkat dasar detasemen, oleh karena itu, kami memindahkan elemen anak.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemen kubus anak</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan collider ke skuad sehingga lebih mudah untuk memilih di masa depan. </font><font style="vertical-align: inherit;">Penumbuk kubus standar cukup cocok untuk kita, cukup buat penumbuk pas dalam satu sel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat instance regu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami belum memiliki gameplay, pembuatan unit dilakukan dalam mode pengeditan. </font><font style="vertical-align: inherit;">Karena itu, ini harus diatasi </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk melakukan ini, ia memerlukan cetakan, jadi tambahkan bidang </font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan hubungkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghubungkan prefab</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat membuat unit, kami akan menempatkannya di sel di bawah kursor. </font><font style="vertical-align: inherit;">Ada </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode untuk menemukan sel ini saat mengedit medan. </font><font style="vertical-align: inherit;">Sekarang kita juga membutuhkannya untuk regu, jadi kita akan memindahkan kode yang sesuai ke metode yang terpisah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menggunakan metode ini dalam </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyederhanakannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { … } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, tambahkan metode baru </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang juga menggunakan </font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika ada sel, kami akan membuat skuad baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menjaga hierarki tetap bersih, mari gunakan kisi sebagai induk untuk semua objek gim di regu. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara termudah untuk menambahkan </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dukungan untuk membuat unit adalah dengan menekan tombol. </font><font style="vertical-align: inherit;">Ubah metode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga panggilan </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika Anda menekan tombol U. Seperti halnya c </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini harus terjadi jika kursor tidak di atas elemen GUI. </font><font style="vertical-align: inherit;">Pertama, kami akan memeriksa apakah kami harus mengedit peta, dan jika tidak, kami akan memeriksa apakah kami harus menambahkan skuad. </font><font style="vertical-align: inherit;">Jika demikian, teleponlah </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dibuat contoh skuad</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penempatan Pasukan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat membuat unit, tetapi mereka muncul di awal peta. </font><font style="vertical-align: inherit;">Kita harus menempatkan mereka di tempat yang tepat. </font><font style="vertical-align: inherit;">Untuk ini, perlu bahwa pasukan menyadari posisi mereka. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambah </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti yang </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan sel yang mereka tempati. </font><font style="vertical-align: inherit;">Saat mengatur properti, kami akan mengubah posisi skuad sehingga cocok dengan posisi sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang saya </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menetapkan posisi sel skuadron di bawah kursor. </font><font style="vertical-align: inherit;">Maka unit akan berada di tempat yang seharusnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasukan di peta</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Orientasi Unit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, semua unit memiliki orientasi yang sama, yang terlihat agak tidak wajar. </font><font style="vertical-align: inherit;">Untuk menghidupkannya kembali, tambahkan ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah nilai float yang menunjukkan rotasi skuad sepanjang sumbu Y dalam derajat. </font><font style="vertical-align: inherit;">Saat mengaturnya, kami akan mengubah rotasi objek game itu sendiri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menetapkan rotasi acak dari 0 hingga 360 derajat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orientasi unit yang berbeda</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satu regu per sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit terlihat bagus jika tidak dibuat dalam satu sel. </font><font style="vertical-align: inherit;">Dalam hal ini, kami mendapatkan sekelompok kubus yang terlihat aneh.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overlay unit</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa game memungkinkan penempatan beberapa unit di satu tempat, yang lain tidak. </font><font style="vertical-align: inherit;">Karena lebih mudah untuk bekerja dengan satu regu per sel, saya akan memilih opsi ini. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita harus membuat skuad baru hanya ketika sel saat ini tidak ditempati. </font><font style="vertical-align: inherit;">Agar Anda bisa mengetahuinya, tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti standar </font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan properti ini </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memberi tahu sel jika unit ada di dalamnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat memeriksa apakah sel saat ini gratis.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengedit Sel Sibuk </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, unit ditempatkan dengan benar, tetapi semuanya dapat berubah jika selnya diedit nanti. </font><font style="vertical-align: inherit;">Jika ketinggian sel berubah, maka unit yang menempatinya akan menggantung di atasnya atau masuk ke dalamnya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasukan yang tergantung dan tenggelam</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solusinya adalah memeriksa posisi pasukan setelah melakukan perubahan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan metode ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sejauh ini, kami hanya tertarik dengan posisi pasukan, jadi tanyakan saja lagi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita harus mengoordinasikan posisi detasemen ketika memperbarui sel, apa yang terjadi ketika metode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipanggil. </font><font style="vertical-align: inherit;">Tentu saja, ini diperlukan hanya ketika benar-benar ada detasemen dalam sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghapus regu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain membuat unit, akan berguna untuk menghancurkannya. </font><font style="vertical-align: inherit;">Karena itu, tambahkan ke </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dia harus memeriksa apakah ada detasemen dalam sel di bawah kursor, dan jika demikian, hancurkan objek permainan detasemen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap dicatat, untuk sampai ke pasukan, kami melewati sel. </font><font style="vertical-align: inherit;">Untuk berinteraksi dengan skuad, cukup gerakkan mouse di atas selnya. </font><font style="vertical-align: inherit;">Oleh karena itu, agar ini berfungsi, skuad tidak harus memiliki collider. </font><font style="vertical-align: inherit;">Namun, menambahkan collider membuatnya lebih mudah untuk dipilih karena menghalangi sinar yang akan bertabrakan dengan sel di belakang regu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gunakan kombinasi Shift + U kiri </font><font style="vertical-align: inherit;">untuk menghancurkan skuad </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus ketika kita membuat dan menghancurkan beberapa unit, mari kita berhati-hati dan membersihkan properti saat melepas unit. </font><font style="vertical-align: inherit;">Yaitu, kami secara eksplisit menghapus tautan sel ke skuad. </font><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berhubungan dengan ini, serta penghancuran objek game Anda sendiri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memanggil metode ini </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan tidak menghancurkan pasukan secara langsung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyimpan dan memuat regu </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat memiliki unit di peta, kita harus memasukkannya dalam proses penyimpanan dan pemuatan. </font><font style="vertical-align: inherit;">Kami dapat mendekati tugas ini dengan dua cara. </font><font style="vertical-align: inherit;">Yang pertama adalah untuk merekam data regu saat merekam sel sehingga sel dan data regu dicampur. </font><font style="vertical-align: inherit;">Cara kedua adalah menyimpan data sel dan skuad secara terpisah. </font><font style="vertical-align: inherit;">Meskipun tampaknya pendekatan pertama lebih mudah diimplementasikan, yang kedua memberi kita lebih banyak data terstruktur. </font><font style="vertical-align: inherit;">Jika kami berbagi data, maka akan lebih mudah untuk bekerja dengan mereka di masa mendatang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelacakan Unit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyatukan semua unit, kita perlu melacaknya. </font><font style="vertical-align: inherit;">Kami akan melakukan ini dengan menambahkan ke </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar unit. </font><font style="vertical-align: inherit;">Daftar ini harus berisi semua unit di peta.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat membuat atau memuat peta baru, kita harus menyingkirkan semua unit di peta. </font><font style="vertical-align: inherit;">Untuk menyederhanakan proses ini, buat metode </font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang membunuh semua orang dalam daftar dan membersihkannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyebut metode ini masuk </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan masuk </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita lakukan setelah membersihkan jalan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … ClearPath(); ClearUnits(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menambahkan regu ke grid </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, saat membuat unit baru, kita perlu menambahkannya ke daftar. </font><font style="vertical-align: inherit;">Mari kita menetapkan metode untuk ini </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang juga akan berurusan dengan lokasi skuad dan parameter objek induknya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cukup menelepon </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan instance baru detasemen, lokasi, dan orientasi acak.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghapus regu dari grid </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode untuk menghapus regu dan c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hapus saja skuad dari daftar dan suruh mati.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memanggil metode ini </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alih-alih menghancurkan pasukan secara langsung.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyimpan unit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita akan menyatukan semua unit, kita perlu mengingat sel mana yang mereka tempati. </font><font style="vertical-align: inherit;">Cara yang paling dapat diandalkan adalah dengan menyimpan koordinat lokasi mereka. </font><font style="vertical-align: inherit;">Untuk memungkinkan ini, kami menambahkan </font><font style="vertical-align: inherit;">bidang X dan Z </font><font style="vertical-align: inherit;">ke </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menulisnya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang dapat merekam koordinat dan orientasi skuad. </font><font style="vertical-align: inherit;">Ini semua data unit yang kita miliki saat ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena ia </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melacak unit, metodenya </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan merekam data unit. </font><font style="vertical-align: inherit;">Pertama, tulis jumlah total unit, dan kemudian lewati semuanya dalam satu lingkaran.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengubah data yang disimpan, jadi kami akan menambah nomor versi </font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi 2. Kode booting lama akan tetap berfungsi, karena itu hanya tidak akan membaca data skuad. </font><font style="vertical-align: inherit;">Namun, Anda perlu menambah nomor versi untuk menunjukkan bahwa ada informasi unit dalam file.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memuat regu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena ini </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah struktur, tidak masuk akal untuk menambahkan metode yang biasa </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita menjadikannya metode statis yang membaca dan mengembalikan koordinat yang tersimpan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena jumlah unit adalah variabel, kami tidak memiliki unit yang sudah ada sebelumnya di mana data dapat dimuat. </font><font style="vertical-align: inherit;">Kita dapat membuat instance unit baru sebelum memuat datanya, tetapi ini mengharuskan kita </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat instance unit baru pada saat boot. </font><font style="vertical-align: inherit;">Jadi lebih baik meninggalkannya </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami juga menggunakan metode statis </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita mulai dengan hanya membaca regu ini. </font><font style="vertical-align: inherit;">Untuk membaca nilai float orientasi, kami menggunakan metode </font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kenapa lajang?</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah selanjutnya adalah membuat instance dari skuad baru. </font><font style="vertical-align: inherit;">Namun, untuk ini kita perlu tautan ke cetakan unit. </font><font style="vertical-align: inherit;">Agar tidak menyulitkannya, mari kita tambahkan </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode statis </font><font style="vertical-align: inherit;">untuk ini </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatur tautan ini, mari kita gunakan lagi </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti yang kita lakukan dengan tekstur noise. </font><font style="vertical-align: inherit;">Ketika kita perlu mendukung banyak jenis unit, kita akan beralih ke solusi yang lebih baik.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melewati cetakan unit.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah menghubungkan bidang, kami tidak lagi memerlukan tautan langsung ke </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebaliknya, dia bisa menggunakan </font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; … void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat membuat instance dari skuad baru di </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alih-alih mengembalikannya, kita dapat menggunakan koordinat dan orientasi yang dimuat untuk menambahkannya ke kisi. </font><font style="vertical-align: inherit;">Untuk memungkinkan ini, tambahkan parameter </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami menghitung jumlah unit dan menggunakannya untuk memuat semua unit yang tersimpan, menyerahkan diri sebagai argumen tambahan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentu saja, ini hanya akan berfungsi untuk menyimpan file dengan versi tidak lebih rendah dari 2, dalam versi yang lebih muda tidak ada unit untuk memuat. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengunggah file versi 2 dengan benar, sehingga </font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambah jumlah versi yang didukung menjadi 2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerakan Pasukan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regu bersifat mobile, jadi kita harus bisa memindahkannya di sekitar peta. </font><font style="vertical-align: inherit;">Kami sudah memiliki kode pencarian jalur, tetapi sejauh ini kami telah mengujinya hanya untuk tempat yang sewenang-wenang. </font><font style="vertical-align: inherit;">Sekarang kita perlu menghapus UI uji lama dan membuat UI baru untuk manajemen pasukan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembersihan Editor Peta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memindahkan unit di sepanjang jalur adalah bagian dari gameplay, itu tidak berlaku untuk editor peta. </font><font style="vertical-align: inherit;">Oleh karena itu, kami akan menyingkirkan </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua kode yang terkait dengan menemukan jalan.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; … void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menghapus kode ini, tidak lagi masuk akal untuk membiarkan editor aktif ketika kita tidak dalam mode edit. </font><font style="vertical-align: inherit;">Oleh karena itu, alih-alih bidang pelacakan mode, kita cukup mengaktifkan atau menonaktifkan komponen </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selain itu, editor sekarang tidak harus berurusan dengan label UI.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; … public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } … void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena secara default kita tidak dalam mode pengeditan peta, di Sedarlah kita akan menonaktifkan editor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diperlukan raycast untuk mencari sel saat ini di bawah kursor ketika mengedit peta, dan untuk mengelola unit. </font><font style="vertical-align: inherit;">Mungkin di masa depan itu akan berguna bagi kita untuk hal lain. </font><font style="vertical-align: inherit;">Mari kita pindahkan logika raycasting dari </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke metode baru </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan parameter balok.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin hanya memanggil metode ini dengan sinar kursor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game UI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengontrol UI mode game, kami akan menggunakan komponen baru. </font><font style="vertical-align: inherit;">Sementara dia hanya akan berurusan dengan pemilihan dan pergerakan unit. </font><font style="vertical-align: inherit;">Buat tipe komponen baru untuk itu </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk melakukan pekerjaannya, tautan ke jaringan sudah cukup baginya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan komponen ini ke objek game baru di hierarki UI. </font><font style="vertical-align: inherit;">Dia tidak harus memiliki objek sendiri, tetapi akan jelas bagi kita bahwa ada UI terpisah untuk permainan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game UI Object</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menambahkan </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti pada </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Game UI harus dihidupkan ketika kita tidak dalam mode edit. </font><font style="vertical-align: inherit;">Juga, label perlu dimasukkan di sini karena UI game bekerja dengan jalur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode UI game dengan daftar acara sakelar mode edit. </font><font style="vertical-align: inherit;">Ini berarti bahwa ketika pemain mengubah mode, kedua metode dipanggil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa metode acara. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lacak sel saat ini </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bergantung pada situasinya, </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu tahu sel mana yang saat ini di bawah kursor. </font><font style="vertical-align: inherit;">Karena itu, kami menambahkan bidang ke dalamnya </font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat metode </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menggunakan </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinar kursor untuk memperbarui bidang ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat memperbarui sel saat ini, kami mungkin perlu mencari tahu apakah itu telah berubah. </font><font style="vertical-align: inherit;">Paksa untuk </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan informasi ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemilihan Unit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum memindahkan regu, regu harus dipilih dan dilacak. </font><font style="vertical-align: inherit;">Karena itu, tambahkan bidang </font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami mencoba membuat pilihan, kami perlu memulai dengan memperbarui sel saat ini. </font><font style="vertical-align: inherit;">Jika sel saat ini maka unit yang menempati sel ini menjadi unit yang dipilih. </font><font style="vertical-align: inherit;">Jika tidak ada unit dalam sel, maka tidak ada unit yang dipilih. </font><font style="vertical-align: inherit;">Mari kita buat metode untuk ini </font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyadari pilihan unit dengan klik sederhana mouse. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkan metode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang membuat pilihan ketika tombol mouse diaktifkan. Tentu saja, kita perlu menjalankannya hanya ketika kursor tidak di atas elemen GUI.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, kami belajar cara memilih satu unit sekaligus dengan mengklik mouse. </font><font style="vertical-align: inherit;">Ketika Anda mengklik sel kosong, pemilihan unit apa pun dihapus. </font><font style="vertical-align: inherit;">Tetapi sementara kami tidak menerima konfirmasi visual apa pun tentang ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pencarian pasukan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika sebuah unit dipilih, kita dapat menggunakan lokasinya sebagai titik awal untuk menemukan jalur. </font><font style="vertical-align: inherit;">Untuk mengaktifkan ini, kami tidak akan memerlukan klik tombol mouse lagi. </font><font style="vertical-align: inherit;">Sebagai gantinya, kami akan secara otomatis menemukan dan menunjukkan jalur antara posisi regu dan sel saat ini. </font><font style="vertical-align: inherit;">Kami akan selalu melakukan ini </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kecuali ketika pilihan dibuat. </font><font style="vertical-align: inherit;">Untuk melakukan ini, ketika kami memiliki detasemen, kami memanggil metode </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baru saja memperbarui sel saat ini dan menelepon </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika ada titik akhir. </font><font style="vertical-align: inherit;">Kami kembali menggunakan kecepatan konstan 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Harap perhatikan bahwa kami tidak boleh menemukan jalur baru setiap kali kami memperbarui, tetapi hanya ketika sel saat ini berubah. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan jalur untuk sebuah regu</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita melihat jalur yang muncul ketika Anda memindahkan kursor setelah memilih regu. </font><font style="vertical-align: inherit;">Berkat ini, jelas unit mana yang dipilih. </font><font style="vertical-align: inherit;">Namun, jalur tidak selalu dibersihkan dengan benar. </font><font style="vertical-align: inherit;">Pertama, mari kita hapus jalur lama jika kursor berada di luar peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, ini mensyaratkan bahwa itu </font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah </font><font style="vertical-align: inherit;">hal </font><font style="vertical-align: inherit;">biasa, jadi kami membuat perubahan seperti itu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kedua, kita akan membersihkan jalan lama saat memilih detasemen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akhirnya, kami akan menghapus jalur saat mengubah mode pengeditan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cari hanya titik akhir yang valid </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak selalu dapat menemukan jalannya, karena kadang-kadang tidak mungkin mencapai sel terakhir. </font><font style="vertical-align: inherit;">Ini normal. </font><font style="vertical-align: inherit;">Tetapi kadang-kadang sel terakhir itu sendiri tidak dapat diterima. </font><font style="vertical-align: inherit;">Sebagai contoh, kami memutuskan bahwa jalur tidak dapat memasukkan sel bawah air. </font><font style="vertical-align: inherit;">Tetapi mungkin tergantung pada unit. </font><font style="vertical-align: inherit;">Mari kita tambahkan </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode yang memberi tahu kita apakah sebuah sel adalah titik akhir yang valid. </font><font style="vertical-align: inherit;">Sel bawah laut tidak.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, kami hanya mengizinkan satu unit untuk berdiri di dalam sel. </font><font style="vertical-align: inherit;">Karenanya, sel terakhir tidak akan valid jika sedang sibuk.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan metode ini </font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengabaikan titik akhir yang tidak valid.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pindah ke titik akhir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kami memiliki jalur yang valid, maka kami dapat memindahkan skuad ke titik akhir. </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tahu kapan ini bisa dilakukan. </font><font style="vertical-align: inherit;">Kami membuatnya meneruskan informasi ini di properti baca-saja yang baru </font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memindahkan skuad, tambahkan ke </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini akan dipanggil ketika perintah dikeluarkan dan jika unit dipilih. </font><font style="vertical-align: inherit;">Karena itu, ia harus memeriksa apakah ada cara, dan jika demikian, ubah lokasi detasemen. </font><font style="vertical-align: inherit;">Sementara kami segera memindahkan skuad ke titik akhir. </font><font style="vertical-align: inherit;">Dalam salah satu tutorial berikut, kita akan membuat skuad benar-benar berjalan sepanjang jalan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita gunakan tombol mouse 1 (klik kanan) untuk mengirimkan perintah. </font><font style="vertical-align: inherit;">Kami akan memeriksa ini jika detasemen dipilih. </font><font style="vertical-align: inherit;">Jika tombol tidak ditekan, maka kami mencari jalannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita bisa memindahkan unit! </font><font style="vertical-align: inherit;">Tetapi kadang-kadang mereka menolak untuk menemukan jalan ke beberapa sel. </font><font style="vertical-align: inherit;">Secara khusus, untuk sel-sel di mana detasemen dulu. </font><font style="vertical-align: inherit;">Ini terjadi karena </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak memperbarui lokasi lama ketika mengatur yang baru. </font><font style="vertical-align: inherit;">Untuk memperbaikinya, kami akan menghapus tautan ke skuad di lokasi lamanya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari regu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan cara sekarang berfungsi dengan benar, dan unit dapat berteleportasi di peta. </font><font style="vertical-align: inherit;">Meskipun mereka tidak dapat pindah ke sel yang sudah memiliki pasukan, detasemen yang berdiri di jalan diabaikan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit di jalan diabaikan.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit dari faksi yang sama biasanya dapat bergerak melalui satu sama lain, tetapi sejauh ini kami tidak memiliki faksi. </font><font style="vertical-align: inherit;">Oleh karena itu, mari kita pertimbangkan semua unit sebagai terputus satu sama lain dan memblokir jalur. </font><font style="vertical-align: inherit;">Ini dapat diimplementasikan dengan melewatkan sel yang sibuk di </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detasemen Hindari </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 19: Animasi Bergerak </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memindahkan unit di antara sel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisasikan jalan yang dilalui. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memindahkan pasukan di sepanjang kurva. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memaksa pasukan untuk melihat ke arah pergerakan. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di bagian ini, kami akan memaksa unit alih-alih teleportasi untuk bergerak di sepanjang trek. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasukan di jalan</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerakan di sepanjang jalan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian sebelumnya, kami menambahkan unit dan kemampuan untuk memindahkannya. </font><font style="vertical-align: inherit;">Meskipun kami menggunakan pencarian jalan untuk menentukan titik akhir yang valid, setelah memberikan perintah, pasukan hanya berpindah ke sel terakhir. </font><font style="vertical-align: inherit;">Untuk benar-benar mengikuti jalur yang ditemukan, kita perlu melacak jalur ini dan membuat proses animasi yang memaksa skuad untuk bergerak dari sel ke sel. </font><font style="vertical-align: inherit;">Karena melihat animasi, sulit untuk memperhatikan bagaimana pasukan bergerak, kami juga memvisualisasikan jalan yang ditempuh dengan bantuan gizmos. </font><font style="vertical-align: inherit;">Tetapi sebelum kita melanjutkan, kita perlu memperbaiki kesalahan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan saat berbelok </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kelalaian, kami salah menghitung jalan di mana sel akan dijangkau. </font><font style="vertical-align: inherit;">Sekarang kita menentukan arah dengan membagi jarak total dengan kecepatan pasukan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-5"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan membuang sisanya. </font><font style="vertical-align: inherit;">Kesalahan terjadi ketika untuk masuk ke sel Anda harus menghabiskan semua poin gerakan yang tersisa per gerakan. </font><font style="vertical-align: inherit;">Misalnya, ketika setiap langkah berharga 1, dan kecepatannya 3, maka kita dapat memindahkan tiga sel per putaran. </font><font style="vertical-align: inherit;">Namun, dengan perhitungan yang ada, kita hanya bisa mengambil dua langkah di langkah pertama, karena untuk langkah ketiga</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.407ex" height="2.66ex" viewBox="0 -832 3189.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-73" x="2719" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">t = d / s</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s </font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-21"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.254ex" height="2.66ex" viewBox="0 -832 7859.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-73" x="2719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="3466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-33" x="4523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2F" x="5023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-33" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="6302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-31" x="7358" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">t = d / s = 3 / 3 = 1</script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah biaya untuk bergerak dengan gerakan yang salah, kecepatan 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk perhitungan gerakan yang benar, kita perlu memindahkan batas satu langkah dari sel awal. </font><font style="vertical-align: inherit;">Kita bisa melakukan ini dengan mengurangi jarak dengan 1 sebelum menghitung langkah, lalu langkah untuk langkah ketiga adalah</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.686ex" height="2.66ex" viewBox="0 -832 5031.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-32" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2F" x="2196" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-33" x="2696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="3474" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-30" x="4531" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah yang benar</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kita dapat melakukan ini dengan mengubah rumus perhitungan menjadi</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.219ex" height="2.66ex" viewBox="0 -832 5691.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-64" x="2085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2212" x="2830" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-31" x="3831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="4332" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2F" x="4721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-73" x="5222" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">t = (d - 1) / s</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan membuat perubahan ini menjadi </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } … } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami juga mengubah tanda gerakan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; … } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa dengan pendekatan ini, jalur sel awal adalah −1. </font><font style="vertical-align: inherit;">Ini normal, karena kami tidak menampilkannya, dan algoritma pencarian tetap operasional.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mendapatkan jalan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bergerak di sepanjang jalan adalah tugas pasukan. </font><font style="vertical-align: inherit;">Agar dia melakukan ini, dia perlu tahu jalannya. </font><font style="vertical-align: inherit;">Kami memiliki informasi ini </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi mari kita tambahkan metode untuk mendapatkan jalur saat ini dalam bentuk daftar sel. </font><font style="vertical-align: inherit;">Dia bisa mengambilnya dari kumpulan daftar dan kembali jika memang ada jalan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daftar ini diisi dengan mengikuti jalur tautan dari sel terakhir ke sel awal, seperti yang dilakukan saat memvisualisasikan jalur. </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam hal ini, kita membutuhkan keseluruhan path, yang meliputi sel awal. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki jalur dalam urutan terbalik. </font><font style="vertical-align: inherit;">Kita dapat bekerja dengannya, tetapi itu tidak akan sangat intuitif. </font><font style="vertical-align: inherit;">Mari kita balikkan daftarnya sehingga mulai dari awal hingga akhir.</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permintaan gerak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menambahkan </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode, memerintahkannya untuk mengikuti jalan. </font><font style="vertical-align: inherit;">Awalnya, kami membiarkannya melakukan teleportasi ke sel terakhir. </font><font style="vertical-align: inherit;">Kami tidak akan segera mengembalikan daftar ke kolam renang, karena akan berguna bagi kami untuk sementara waktu.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meminta perpindahan, kami mengubahnya </font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga memanggil metode baru dengan jalur saat ini, dan tidak hanya menetapkan lokasi unit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisasi jalur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita mulai menjiwai regu, mari kita periksa apakah jalurnya benar. </font><font style="vertical-align: inherit;">Kami akan melakukan ini dengan memesan untuk </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengingat jalan yang harus dilalui, sehingga dapat divisualisasikan menggunakan gizmos.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menunjukkan jalur terakhir untuk pergi (jika ada). </font><font style="vertical-align: inherit;">Jika unit belum bergerak, jalan harus sama </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tetapi karena serialisasi Unity selama pengeditan setelah kompilasi ulang dalam mode Play, itu juga bisa menjadi daftar kosong.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara termudah untuk menunjukkan jalan adalah dengan menggambar bola alat untuk setiap sel jalan. </font><font style="vertical-align: inherit;">Bola dengan jari-jari 2 unit cocok untuk kita.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena kita akan menunjukkan jalur untuk detasemen, kita akan dapat secara bersamaan melihat semua jalur terakhirnya. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gizmos menampilkan jalur terakhir yang ditempuh.Untuk</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menunjukkan koneksi sel yang lebih baik, kami menggambar beberapa bola dalam satu lingkaran pada garis antara sel sebelumnya dan saat ini. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu memulai proses dari sel kedua. </font><font style="vertical-align: inherit;">Bola dapat diatur menggunakan interpolasi linier dengan kenaikan 0,1 unit, sehingga kami mendapatkan sepuluh bola per segmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara yang lebih jelas</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meluncur di sepanjang jalan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggunakan metode yang sama untuk memindahkan unit. </font><font style="vertical-align: inherit;">Mari kita buat coroutine untuk ini. </font><font style="vertical-align: inherit;">Alih-alih menggambar alat, kami akan mengatur posisi skuad. </font><font style="vertical-align: inherit;">Alih-alih menambah, kami akan menggunakan 0,1 delta waktu, dan kami akan melakukan hasil untuk setiap iterasi. </font><font style="vertical-align: inherit;">Dalam hal ini, skuad akan bergerak dari satu sel ke sel berikutnya dalam satu detik.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai coroutine di akhir metode </font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi pertama-tama, kita akan menghentikan semua coroutine yang ada. </font><font style="vertical-align: inherit;">Jadi kami menjamin bahwa dua coroutine tidak akan mulai pada saat yang sama, jika tidak, ini akan menghasilkan hasil yang sangat aneh.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memindahkan satu sel per detik cukup lambat. </font><font style="vertical-align: inherit;">Pemain selama pertandingan tidak akan mau menunggu lama. </font><font style="vertical-align: inherit;">Anda dapat menjadikan kecepatan gerakan regu sebagai opsi konfigurasi, tetapi untuk sekarang, mari gunakan konstanta. </font><font style="vertical-align: inherit;">Saya memberinya nilai 4 sel per detik; </font><font style="vertical-align: inherit;">itu cukup cepat, tetapi mari kita perhatikan apa yang terjadi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sama seperti kita dapat memvisualisasikan beberapa jalur secara bersamaan, kita dapat membuat beberapa unit bepergian pada saat yang sama. </font><font style="vertical-align: inherit;">Dari sudut pandang keadaan gim, gerakannya masih teleportasi, animasinya hanya visual. </font><font style="vertical-align: inherit;">Unit langsung menempati sel terakhir. </font><font style="vertical-align: inherit;">Anda bahkan dapat menemukan cara dan memulai langkah baru sebelum mereka tiba. </font><font style="vertical-align: inherit;">Dalam hal ini, mereka diteleportasi secara visual ke awal jalur baru. </font><font style="vertical-align: inherit;">Ini dapat dihindari dengan memblokir unit atau bahkan seluruh UI saat mereka bergerak, tetapi reaksi cepat semacam itu cukup nyaman ketika mengembangkan dan menguji gerakan.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit bergerak. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan perbedaan tinggi badan?</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posisi setelah kompilasi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu kelemahan corutin adalah mereka tidak "bertahan" ketika dikompilasi ulang dalam mode Play. </font><font style="vertical-align: inherit;">Meskipun kondisi permainan selalu benar, ini dapat menyebabkan regu terjebak di suatu tempat di jalur terakhir mereka jika kompilasi dimulai saat mereka masih bergerak. </font><font style="vertical-align: inherit;">Untuk mengurangi konsekuensinya, mari kita pastikan bahwa, setelah dikompilasi ulang, unit-unit selalu berada di posisi yang benar. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan memperbarui posisi mereka di </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerakan halus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerakan dari pusat ke pusat sel terlihat terlalu mekanistik dan menciptakan perubahan arah yang tajam. </font><font style="vertical-align: inherit;">Untuk banyak permainan, ini akan normal, tetapi tidak dapat diterima jika Anda membutuhkan setidaknya gerakan yang sedikit realistis. </font><font style="vertical-align: inherit;">Jadi mari kita ubah gerakan agar terlihat sedikit lebih organik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pindah dari tulang rusuk ke tulang rusuk </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasukan memulai perjalanannya dari pusat sel. </font><font style="vertical-align: inherit;">Lewat ke tengah tepi sel, dan kemudian memasuki sel berikutnya. </font><font style="vertical-align: inherit;">Alih-alih bergerak ke tengah, ia bisa langsung menuju tepi berikutnya yang harus disilangkan. </font><font style="vertical-align: inherit;">Bahkan, unit akan memotong jalan ketika perlu mengubah arah. </font><font style="vertical-align: inherit;">Ini dimungkinkan untuk semua sel kecuali titik akhir jalur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga cara untuk bergerak dari ujung ke ujung</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita beradaptasi </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menampilkan jalur yang dihasilkan dengan cara ini. </font><font style="vertical-align: inherit;">Itu harus interpolasi antara tepi sel, yang dapat ditemukan dengan rata-rata posisi sel tetangga. </font><font style="vertical-align: inherit;">Cukup bagi kami untuk menghitung satu sisi per iterasi, menggunakan kembali nilai dari iterasi sebelumnya. </font><font style="vertical-align: inherit;">Dengan demikian, kita dapat membuat metode ini bekerja untuk sel awal, tetapi alih-alih dari tepi kita mengambil posisinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencapai pusat sel akhir, kita perlu menggunakan posisi sel sebagai titik terakhir, bukan tepi. </font><font style="vertical-align: inherit;">Anda dapat menambahkan verifikasi kasus ini ke loop, tetapi ini adalah kode sederhana sehingga akan lebih jelas untuk hanya menduplikasi kode dan sedikit mengubahnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalur </font><i><font style="vertical-align: inherit;">berbasis rusuk</font></i><font style="vertical-align: inherit;"> Jalur yang dihasilkan kurang seperti zig-zag, dan sudut belok maksimum dikurangi dari 120 ° hingga 90 °. </font><font style="vertical-align: inherit;">Ini dapat dianggap sebagai peningkatan, jadi kami menerapkan perubahan yang sama di coroutine </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk melihat tampilannya di animasi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bergerak dengan kecepatan yang berubah</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah memotong sudut, panjang segmen jalur menjadi tergantung pada perubahan arah. </font><font style="vertical-align: inherit;">Tapi kami mengatur kecepatan dalam sel per detik. </font><font style="vertical-align: inherit;">Akibatnya, kecepatan detasemen berubah secara acak.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurva mengikuti </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahan instan dalam arah dan kecepatan ketika melintasi batas sel terlihat jelek. </font><font style="vertical-align: inherit;">Lebih baik gunakan perubahan arah secara bertahap. </font><font style="vertical-align: inherit;">Kita dapat menambahkan dukungan untuk ini dengan memaksa pasukan mengikuti garis lengkung daripada garis lurus. </font><font style="vertical-align: inherit;">Anda dapat menggunakan kurva Bezier untuk ini. </font><font style="vertical-align: inherit;">Secara khusus, kita dapat mengambil kurva Bezier kuadrat di mana pusat sel akan menjadi titik kontrol tengah. </font><font style="vertical-align: inherit;">Dalam hal ini, garis singgung kurva yang berdekatan akan menjadi gambar cermin satu sama lain, yaitu, seluruh jalur akan berubah menjadi kurva halus terus menerus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurva dari ujung ke ujung.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat kelas bantu </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan metode untuk mendapatkan poin pada kurva Bezier kuadratik. </font><font style="vertical-align: inherit;">Seperti dijelaskan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial Curves and Splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , rumus ini digunakan untuk ini</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-49" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A </font></font></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.208ex" height="2.901ex" viewBox="0 -935.7 12575.6 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2212" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="2112" y="0"></use><g transform="translate(2474,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-32" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-41" x="3317" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2B" x="4290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-32" x="5291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-31" x="6181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2212" x="6904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="7904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="8266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="8655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-42" x="9017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2B" x="9998" y="0"></use><g transform="translate(10999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-32" x="511" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-43" x="11815" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.057ex" viewBox="0 -780.1 750.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-41" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> A </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> B </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah titik kontrol, dan t adalah interpolator.</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">C</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidakkah GetPoint dibatasi hingga 0-1?</font></font></b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menunjukkan lintasan kurva </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita perlu melacak bukan dua, tetapi tiga titik. </font><font style="vertical-align: inherit;">Poin tambahan adalah pusat sel tempat kita bekerja pada iterasi saat ini, yang memiliki indeks </font></font><code>i - 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena siklus dimulai dengan 1. Setelah menerima semua poin, kita dapat menggantinya </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>Bezier.GetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sel awal dan akhir, alih-alih titik akhir dan tengah, kita cukup menggunakan pusat sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalur dibuat menggunakan kurva Bezier</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jalur </font><i><font style="vertical-align: inherit;">melengkung</font></i><font style="vertical-align: inherit;"> terlihat jauh lebih baik. </font><font style="vertical-align: inherit;">Kami menerapkan perubahan yang sama untuk </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melihat bagaimana unit dianimasikan dengan pendekatan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami bergerak di sepanjang kurva.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animasi juga menjadi halus, bahkan ketika kecepatan detasemen tidak stabil. </font><font style="vertical-align: inherit;">Karena garis singgung kurva segmen yang berdekatan bertepatan, kecepatannya kontinu. </font><font style="vertical-align: inherit;">Perubahan kecepatan terjadi secara bertahap dan terjadi ketika detasemen melewati sel, melambat saat mengubah arah. </font><font style="vertical-align: inherit;">Jika dia lurus, maka kecepatannya tetap konstan. </font><font style="vertical-align: inherit;">Selain itu, pasukan mulai dan mengakhiri perjalanannya dengan kecepatan nol. </font><font style="vertical-align: inherit;">Ini meniru gerakan alami, jadi biarkan begitu saja.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelacakan waktu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hingga saat ini, kami mulai mengulangi setiap segmen mulai dari 0, berlanjut hingga mencapai 1. Ini berfungsi dengan baik ketika meningkat dengan nilai konstan, tetapi iterasi kami bergantung pada delta waktu. Ketika iterasi lebih dari satu segmen selesai, kami cenderung melebihi 1 dengan jumlah tertentu, tergantung pada delta waktu. Ini tidak terlihat pada frame rate tinggi, tetapi dapat menyebabkan tersentak pada frame rate rendah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghindari kehilangan waktu, kami perlu mentransfer sisa waktu dari satu segmen ke segmen berikutnya. Ini dapat dilakukan dengan melacak </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sepanjang jalur, dan tidak hanya di setiap segmen. Kemudian pada akhir setiap segmen kita akan mengurangi 1 dari itu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita sudah melakukan ini, mari kita pastikan bahwa waktu delta diperhitungkan di awal jalan. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita akan mulai bergerak segera, dan tidak akan diam untuk satu frame.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, kita tidak selesai tepat pada titik waktu ketika jalan seharusnya berakhir, tetapi beberapa saat sebelumnya. </font><font style="vertical-align: inherit;">Di sini, perbedaannya juga tergantung pada frame rate. </font><font style="vertical-align: inherit;">Oleh karena itu, mari kita membuat pasukan menyelesaikan jalur tepat di titik akhir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animasi orientasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit-unit mulai bergerak di sepanjang kurva yang halus, tetapi mereka tidak mengubah orientasi sesuai dengan arah gerakan. </font><font style="vertical-align: inherit;">Akibatnya, mereka tampak meluncur. </font><font style="vertical-align: inherit;">Untuk membuat gerakan terlihat seperti gerakan nyata, kita perlu memutarnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menantikan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial Curves and Splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kita dapat menggunakan turunan kurva untuk menentukan orientasi unit. </font><font style="vertical-align: inherit;">Rumus untuk turunan dari kurva Bezier kuadratik:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mn" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-75"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font></span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-91" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.64ex" height="2.66ex" viewBox="0 -832 12761.8 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-31" x="1279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2212" x="2002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="3002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="3364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="3753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-42" x="4143" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2212" x="5125" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-41" x="6125" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="6876" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2B" x="7488" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-74" x="8488" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-28" x="8850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-43" x="9239" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-2212" x="10222" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-42" x="11223" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="11982" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMAIN-29" x="12372" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9">2 ((1 - t) (B - A) + t (C - B))</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode untuk menghitungnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektor turunan terletak pada satu garis lurus dengan arah gerakan. </font><font style="vertical-align: inherit;">Kita dapat menggunakan metode ini </font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengubahnya menjadi giliran regu. </font><font style="vertical-align: inherit;">Kami akan melaksanakannya di setiap langkah di </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; … transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah tidak ada kesalahan di awal jalan?</font></font></b> <div class="spoiler_text">    ,        .    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">A</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.211ex" viewBox="0 -831.5 750.5 952" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhifk6Vet2j-Wko-xPift_G2nXNGzw#MJMATHI-41" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-10"> A </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">B</span></span></span><script type="math/tex" id="MathJax-Element-11"> B </script>  ,    .   ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">t</span><span class="MJXp-mo" id="MJXp-Span-98" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-99">0</span></span></span><script type="math/tex" id="MathJax-Element-12">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">t</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-103">0</span></span></span><script type="math/tex" id="MathJax-Element-13">t = 0</script>   .     .       ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">t</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-107">0</span></span></span><script type="math/tex" id="MathJax-Element-14">t > 0</script>    . <br>         ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-111">1</span></span></span><script type="math/tex" id="MathJax-Element-15">t < 1</script>  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbeda dengan posisi detasemen, orientasi yang tidak ideal pada ujung jalan tidak penting. </font><font style="vertical-align: inherit;">Namun, kita perlu memastikan bahwa orientasinya sesuai dengan rotasi akhir. </font><font style="vertical-align: inherit;">Untuk melakukan ini, setelah selesai, kami menyamakan orientasinya dengan rotasi di Y.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang unit-unit tersebut melihat dengan tepat ke arah gerakan, baik secara horizontal maupun vertikal. </font><font style="vertical-align: inherit;">Ini berarti bahwa mereka akan bersandar ke depan dan ke belakang, turun dari lereng dan memanjat mereka. </font><font style="vertical-align: inherit;">Untuk memastikan bahwa mereka selalu berdiri tegak, kami memaksa komponen Y dari vektor arah ke nol sebelum menggunakannya untuk menentukan rotasi unit.</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); … Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menantikan saat bergerak</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami melihat intinya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sepanjang jalan, unit melihat ke depan, tetapi sebelum mulai bergerak, mereka dapat melihat ke arah lain. Dalam hal ini, mereka langsung mengubah orientasi mereka. Akan lebih baik jika mereka berbelok ke arah jalan sebelum dimulainya gerakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melihat ke arah yang benar bisa berguna dalam situasi lain, jadi mari kita buat metode </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memaksa skuad untuk mengubah orientasi untuk melihat pada titik tertentu. Rotasi yang diperlukan dapat diatur menggunakan metode ini </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pertama dengan membuat titik pada posisi vertikal yang sama dengan detasemen. Setelah itu, kita dapat mengambil orientasi skuad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar detasemen benar-benar berubah, kita akan mengubah metodenya menjadi corutin lain yang akan memutarnya dengan kecepatan konstan. Kecepatan belok juga dapat disesuaikan, tetapi kita akan menggunakan konstanta lagi. Rotasi harus cepat, sekitar 180 ° per detik.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; … <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak perlu mengutak-atik percepatan belokan karena tidak terlihat. Cukup bagi kita untuk menyisipkan di antara kedua orientasi. Sayangnya, ini tidak sesederhana dalam kasus dua angka, karena sudutnya melingkar. Misalnya, transisi dari 350 ° ke 10 ° akan menghasilkan rotasi 20 ° searah jarum jam, tetapi interpolasi sederhana akan memaksa rotasi 340 ° dalam arah berlawanan arah jarum jam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara termudah untuk membuat rotasi yang benar adalah interpolasi antara dua angka empat menggunakan interpolasi bola. Ini akan mengarah pada belokan terpendek. Untuk melakukan ini, kita mendapatkan angka empat dari awal dan akhir, dan kemudian membuat transisi di antara mereka menggunakan </font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan berhasil, tetapi interpolasi selalu berjalan dari 0 ke 1, terlepas dari sudut rotasi. </font><font style="vertical-align: inherit;">Untuk memastikan kecepatan sudut yang seragam, kita perlu memperlambat interpolasi saat sudut rotasi meningkat.</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengetahui sudutnya, kita dapat sepenuhnya melewati belokan jika ternyata nol. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( … ) { … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menambahkan rotasi unit </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan hanya melakukan hasil sebelum memindahkan </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posisi sel kedua. </font><font style="vertical-align: inherit;">Unity akan secara otomatis meluncurkan coroutine </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menunggu penyelesaiannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memeriksa kode, regu teleportasi ke sel terakhir, berbelok ke sana, lalu teleport kembali ke awal jalur dan mulai bergerak dari sana. </font><font style="vertical-align: inherit;">Ini terjadi karena kami memberikan nilai pada properti </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum awal coroutine </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk menghilangkan teleportasi, kita dapat </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan posisi detasemen ke sel awal.</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Putar sebelum bergerak</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sapu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima gerakan yang kita butuhkan, kita dapat menyingkirkan metode itu </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hapus atau komentari kalau-kalau kita perlu melihat jalur di masa depan.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // … // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita tidak lagi perlu mengingat ke arah mana kita bergerak, pada akhirnya </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat membebaskan daftar sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan animasi pasukan nyata?</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426481/">https://habr.com/ru/post/id426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426471/index.html">Bagaimana data spyware bocor</a></li>
<li><a href="../id426473/index.html">Arsitektur redux. Ya atau tidak</a></li>
<li><a href="../id426475/index.html">Miya - asisten dari smartphone</a></li>
<li><a href="../id426477/index.html">Seluruh kebenaran tentang RTOS. Artikel # 15. Partisi Memori: Layanan dan Struktur Data</a></li>
<li><a href="../id426479/index.html">Bangku tes buatan sendiri untuk motherboard</a></li>
<li><a href="../id426483/index.html">Seseorang yang menyusul Tesla. Agar lebih menguntungkan</a></li>
<li><a href="../id426485/index.html">Tes Qt 5 Ketiga dengan PVS-Studio</a></li>
<li><a href="../id426487/index.html">Tes otomatisasi dari awal. Bagian 1</a></li>
<li><a href="../id426489/index.html">Tentang hubungan bilangan prima dan irasional</a></li>
<li><a href="../id426491/index.html">Minggu Keamanan 39: pada kematian Google+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>