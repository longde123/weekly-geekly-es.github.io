<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèª ü§± üë©üèæ‚Äçü§ù‚Äçüë®üèΩ "Wenn die Uhr zw√∂lf schl√§gt." Oder eine Girlande im Browser üß° üê¶ üë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angenommen, wir haben mehrere Monitore. Und wir wollten diese Monitore als Girlande verwenden. Lassen Sie sie beispielsweise gleichzeitig blinken. Ode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Wenn die Uhr zw√∂lf schl√§gt." Oder eine Girlande im Browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/">  Angenommen, wir haben mehrere Monitore.  Und wir wollten diese Monitore als Girlande verwenden.  Lassen Sie sie beispielsweise gleichzeitig blinken.  Oder √§ndern Sie die Farbe synchron nach einem intelligenten Algorithmus.  Und was ist, wenn Sie es in einem Browser tun - dann k√∂nnen Sie Smartphones und Tablets daran anschlie√üen.  All das ist zur Hand. <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br>  Und da wir einen Browser verwenden, k√∂nnen Sie auch Sounddesign hinzuf√ºgen.  Wenn es genau genug ist, um die Ger√§te rechtzeitig zu synchronisieren, k√∂nnen Sie die Sounds auf jedem so abspielen, als ob ein Mehrkanalsystem klingt. <br><br><hr>  <i>Was kann bei der Synchronisierung von Web-Audio- und Gameplay-Uhren in einer Javascript-Anwendung auftreten?</i>  <i>Wie viele verschiedene "Stunden" gibt es in javasctipt (drei!) und warum werden alle ben√∂tigt, sowie eine <a href="http://habr.snowtime.fun/" rel="nofollow">fertige Anwendung</a> f√ºr node.js unter cat.</i> <a name="habracut"></a><hr><br><h2>  √úberpr√ºfen Sie die Uhr </h2><br>  F√ºr jede bedingte Online-Girlande ist eine genaue Uhrzeitsynchronisation erforderlich.  Schlie√ülich k√∂nnen Sie auch zeitweise auftretende Netzwerkverz√∂gerungen ignorieren.  Es reicht aus, die Steuerbefehle mit einem Zeitstempel zu versehen und diese Befehle ein wenig "in die Zukunft" zu generieren.  Auf Clients werden sie gepuffert und dann synchron und p√ºnktlich ausgef√ºhrt. <br><br>  Oder Sie k√∂nnen sogar noch weiter gehen - nehmen Sie den guten alten deterministischen Zufallsalgorithmus und verwenden Sie einen gemeinsamen Startwert (der vom Server einmal ausgegeben wird, wenn eine Verbindung besteht) auf allen Ger√§ten.  Wenn Sie einen solchen Startwert <i>zusammen</i> mit der genauen Zeit verwenden, k√∂nnen Sie das Verhalten des Algorithmus auf allen Ger√§ten vollst√§ndig vorgeben.  Stellen Sie sich vor, Sie ben√∂tigen kein Netzwerk und keinen Server, um den Status eindeutig und synchron zu √§ndern.  Seed enth√§lt bereits die gesamte (bedingt unendliche) ‚ÄûVideoaufzeichnung‚Äú von Aktionen im Voraus.  Die Hauptsache ist die genaue Zeit. <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>Jede Methode hat ihre Anwendungsgrenzen.</i>  <i>Bei der sofortigen Benutzereingabe ist nat√ºrlich nichts zu tun, es bleibt nur zu √ºbertragen, wie es ist.</i>  <i>Aber alles, was berechnet werden kann, ist zu berechnen.</i>  <i>In meiner Implementierung verwende ich je nach Situation alle drei Ans√§tze.</i> <hr><br><h2>  Subjektiv "zur gleichen Zeit" </h2><br>  Im Idealfall sollte alles ‚Äûzur selben Zeit‚Äú klingen - f√ºr das schlechteste Paar unter den kombinierten Ger√§ten sind nicht mehr als ¬± 10 ms Diskrepanz erforderlich.  Sie k√∂nnen sich nicht auf eine solche Genauigkeit der Systemzeit verlassen, und Standardmethoden zum Synchronisieren der Zeit mithilfe des NTP-Protokolls sind im Browser nicht verf√ºgbar.  Deshalb werden wir unseren Synchronisationsserver ansteuern.  Das Prinzip ist einfach: Helm "pingt" und akzeptiert "Pongs" mit dem Zeitstempel des Servers.  Wenn Sie dies mehrmals hintereinander tun, k√∂nnen Sie den Fehler statistisch ausgleichen und die durchschnittliche Verz√∂gerungszeit ermitteln. <br><br><div class="spoiler">  <b class="spoiler_title">Code: Berechnung der Serverzeit auf dem Client</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Websockets und darauf basierende L√∂sungen sind am besten geeignet, da sie keine Zeit zum Herstellen einer TCP-Verbindung ben√∂tigen und Sie in beide Richtungen mit ihnen "kommunizieren" k√∂nnen.  Nat√ºrlich nicht UDP oder ICMP, aber unvergleichlich schneller als eine normale Kaltverbindung √ºber die HTTP-API.  Daher ist socket.io.  Dort ist alles sehr einfach: <br><br><div class="spoiler">  <b class="spoiler_title">Code: socket.io Implementierung</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>Anstatt den Durchschnitt zu berechnen, w√§re es sch√∂n, den Median zu berechnen - dies verbessert die Genauigkeit bei einer instabilen Verbindung.</i>  <i>Die Wahl der Filtermethode liegt beim Leser.</i>  <i>Ich vereinfache den Code hier bewusst zugunsten von Schaltpl√§nen.</i>  <i>Meine komplette L√∂sung finden Sie im Repository.</i> <br></div></div><br><br><h2>  performance.now () </h2><br>  Ich m√∂chte Sie daran erinnern, dass das <code>performance</code> eine API ist, die den Zugriff auf einen hochaufl√∂senden Zeitgeber erm√∂glicht.  Vergleichen Sie: <br><br><ul><li>  <b><code>Date.now()</code></b> gibt die Anzahl der Millisekunden seit dem 1. Januar 1970 in <b>ganzzahliger</b> Form zur√ºck.  Das hei√üt, der Fehler nur beim Runden betr√§gt durchschnittlich 0,5 ms.  Beispielsweise k√∂nnen Sie bei einer Subtraktionsoperation <code>ab</code> bis zu 2 ms erfolglos ‚Äûverlieren‚Äú.  Dar√ºber hinaus garantiert der Zeitmesser selbst historisch und konzeptionell keine hohe Genauigkeit und ist f√ºr die Arbeit mit einer gr√∂√üeren Zeitskala gesch√§rft. </li><li>  <b><code>performance.now()</code></b> gibt die Anzahl der Millisekunden <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">seit dem √ñffnen der Webseite zur√ºck</a> . <br>  Dies ist eine relativ neue API, die speziell f√ºr die genaue Messung von Zeitintervallen "gesch√§rft" wurde.  Gibt <b>einen Gleitkommawert zur√ºck</b> , der theoretisch einen Genauigkeitsgrad nahe an den F√§higkeiten des Betriebssystems selbst angibt. <br></li></ul><br><br>  Ich denke, diese Information ist fast allen Javascript-Entwicklern bekannt.  Aber nicht jeder wei√ü das ... <br><br><h2>  Specter </h2><br>  Aufgrund des sensationellen Timing-Angriffs von Specter im Jahr 2018 geht alles so weit, dass der hochaufl√∂sende Timer k√ºnstlich aufgeraut wird, wenn es keine andere L√∂sung f√ºr das Schwachstellenproblem gibt.  Firefox, beginnend mit Version 60, rundet den Wert dieses Timers auf eine Millisekunde und Edge noch schlimmer. <br><br>  Hier ist, was <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a> sagt: <br><br><blockquote>  Der Zeitstempel ist nicht wirklich hochaufl√∂send.  Um Sicherheitsbedrohungen wie Spectre abzuschw√§chen, runden Browser die Ergebnisse derzeit in unterschiedlichem Ma√üe ab.  (Firefox hat in Firefox 60 auf 1 Millisekunde gerundet.) Einige Browser k√∂nnen den Zeitstempel auch leicht zuf√§llig einstellen.  Die Genauigkeit wird in zuk√ºnftigen Versionen m√∂glicherweise wieder verbessert.  Browser-Entwickler untersuchen diese Timing-Angriffe noch und wie sie am besten gemindert werden k√∂nnen. </blockquote><br>  Lassen Sie uns den Test durchf√ºhren und die Grafiken betrachten.  Dies ist das Ergebnis des Tests f√ºr das Intervall von 10 ms: <br><br><div class="spoiler">  <b class="spoiler_title">Testcode: Zeitmessung in einem Zyklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  durchschnittliches Intervall: 1.0538336052202284 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,7547819181245603 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.567100970873786 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6748006785171455 ms <br>  Intervallmedian: 1,5015000000003056 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.0168350168350169 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,21645930182417966 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.0134453781512605 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,1734108492762375 ms <br>  Intervallmedian: 1 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.02442996742671 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,49858684744444 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 0.005555847229948915 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,027497846727194235 ms <br>  Intervallmedian: 0.0050000089686363935 ms <br></div></div><br><br>  Ok, Chrome, Zoom auf 1 ms. <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br>  Chrome h√§lt also immer noch an und die Implementierung von <code>performance.now()</code> wurde noch nicht erdrosselt und der Schritt ist wundersch√∂n, 0,005 ms.  Unter Edge ist der Timer von <code>performance.now()</code> rauer als <code>Date.now()</code> !  In Firefox haben beide Timer die gleiche Millisekundengenauigkeit. <br><br>  Zu diesem Zeitpunkt k√∂nnen bereits einige Schlussfolgerungen gezogen werden.  Aber es gibt einen anderen Timer in Javascript (ohne den wir nicht auskommen k√∂nnen). <br><br><h2>  WebAudio API Timer </h2><br>  Dies ist ein etwas anderes Tier.  Es wird f√ºr verz√∂gerte Audio-Warteschlangen verwendet.  Tatsache ist, dass Audio-Events (Noten abspielen, Effekte verwalten) nicht auf standardm√§√üigen asynchronen Javascript-Tools <code>setInterval</code> k√∂nnen: <code>setInterval</code> und <code>setTimeout</code> - wegen ihres zu gro√üen Fehlers.  Und dies ist nicht nur der Fehler <i>der</i> Timer- <i>Werte</i> (mit denen wir uns zuvor befasst haben), sondern es ist der Fehler, mit dem die Ereignismaschine Ereignisse ausf√ºhrt.  Und es ist auch bei Gew√§chshausbedingungen schon etwas um die 5-25 ms. <br><br><div class="spoiler">  <b class="spoiler_title">Grafiken f√ºr den asynchronen Fall unter dem Spoiler</b> <div class="spoiler_text">  Das Ergebnis des Tests √ºber einen Zeitraum von 100 ms: <br><br><div class="spoiler">  <b class="spoiler_title">Testcode: Zeitmessung in einem asynchronen Zyklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  durchschnittliches Intervall: 25.595959595959595 ms <br>  Abweichung vom Mittelwertintervall, RMS: 10.12639235162126 ms <br>  Intervallmedian: 28 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 25.862596938775525 ms <br>  Abweichung vom Mittelwertintervall, RMS: 10.123711255512573 ms <br>  Intervallmedian: 27.027099999999336 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.6914893617021276 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6018870280772611 ms <br>  Intervallmedian: 2 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.7865168539325842 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6442818510935484 ms <br>  Intervallmedian: 2 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 4,7878787878787888, ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,7557553886872682 ms <br>  Intervallmedian: 5 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 4.783989898979516 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6483716900974945 ms <br>  Medianintervall: 4.750000000058208 ms <br></div></div><br></div></div><br><br>  Vielleicht erinnert sich jemand an die ersten experimentellen HTML-Audioanwendungen.  Bevor vollwertiges WebAudio zu den Browsern kam, klangen sie alle wie ein bisschen betrunken und schlampig.  Nur weil sie <code>setTimeout</code> als Sequenzer benutzt haben. <br><br>  Die moderne WebAudio-API bietet dagegen eine garantierte Aufl√∂sung von bis zu 0,02 ms (Spekulation auf Basis der Abtastfrequenz von 44100Hz).  Dies liegt daran, dass f√ºr die verz√∂gerte <code>setTimeout</code> ein anderer Mechanismus verwendet wird als f√ºr <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br>  Tats√§chlich ist die Wiedergabe eines Audio-Samples ‚Äûverz√∂gert‚Äú.  Nur um es zu verlieren "wird nicht verschoben", m√ºssen Sie es "bis jetzt" verschieben. <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">√úber durch Echtzeitsoftware erzeugte Musik</b> <div class="spoiler_text">  Wenn Sie eine programmsynthetisierte Melodie aus Noten spielen, m√ºssen diese Noten vorab zur Wiedergabewarteschlange hinzugef√ºgt werden.  Dann wird die Melodie trotz aller nicht grundlegenden Einschr√§nkungen und Unregelm√§√üigkeiten der Timer perfekt fl√ºssig abgespielt. <br><br>  Mit anderen Worten, die in Echtzeit synthetisierte Melodie sollte nicht in Echtzeit "erfunden" werden, sondern ein wenig im Voraus. <br></div></div><br><br><h2>  Ein Timer, um alle zu regieren </h2><br>  Da <code>audioCtx.currentTime</code> so stabil und genau ist, sollten wir es vielleicht als Hauptquelle f√ºr die relative Zeit verwenden?  Lassen Sie uns den Test noch einmal durchf√ºhren. <br><br><div class="spoiler">  <b class="spoiler_title">Testcode: Messen der synchronen Zeitmessung in einem Zyklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.037037037037037 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6166609846299806 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.5447103117505993 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,4390514285320851 ms <br>  Intervallmedian: 1,5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3>  Durchschnittsintervall: 2.955751134714949 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6193645611529503 ms <br>  Intervallmedian: 2.902507781982422 ms <br><br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.005128205128205 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,12392867665225249 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.00513698630137 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,07148844433269844 ms <br>  Intervallmedian: 1 ms <br><br><h3>  audioCtx.currentTime </h3>  Firefox aktualisiert den Audio-Timer-Wert in der Synchronisierungsschleife nicht <br><br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.0207612456747406 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,49870223457982504 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 0.005414502034674972 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,027441293974958335 ms <br>  Medianintervall: 0.004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3>  Durchschnittsintervall: 3.0877599266656963 ms <br>  Abweichung vom Mittelwert, RMS: 1.1445555956407658 ms <br>  Intervallmedian: 2.9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Grafiken f√ºr den asynchronen Fall unter dem Spoiler</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Testcode: Zeitmessung in einem asynchronen Zyklus</b> <div class="spoiler_text">  Das Ergebnis des Tests √ºber einen Zeitraum von 100 ms: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now (): </h3>  Durchschnittsintervall: 24.505050505050505 ms <br>  Abweichung vom Mittelwertintervall: 11.513166584195204 ms <br>  Intervallmedian: 26 ms <br><br><h3>  performance.now (): </h3>  Durchschnittsintervall: 24.50935757575754 ms <br>  Abweichung vom Mittelwertintervall: 11.679091435527388 ms <br>  Intervallmedian: 25.525499999999738 ms <br><br><h3>  audioCtx.currentTime: </h3>  Durchschnittsintervall: 24.76005164944396 ms <br>  Abweichung vom Mittelwertintervall: 11.311571546205316 ms <br>  Intervallmedian: 26.121139526367187 ms <br><br></div></div><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now (): </h3>  Durchschnittsintervall: 1,6875 ms <br>  Abweichung vom Mittelwertintervall: 0.6663410663216448 ms <br>  Intervallmedian: 2 ms <br><br><h3>  performance.now (): </h3>  Durchschnittsintervall: 1.7234042553191489 ms <br>  Abweichung vom Mittelwertintervall: 0.6588877688171075 ms <br>  Intervallmedian: 2 ms <br><br><h3>  audioCtx.currentTime: </h3>  Durchschnittsintervall: 10.158730158730123 ms <br>  Abweichung vom Mittelwertintervall: 1.4512471655330046 ms <br>  Medianintervall: 8.707482993195299 ms <br><br></div></div><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now (): </h3>  Durchschnittsintervall: 4.585858585858586 ms <br>  Abweichung vom Mittelwertintervall: 0.9102125516015199 ms <br>  Intervallmedian: 5 ms <br><br><h3>  performance.now (): </h3>  durchschnittliches Intervall: 4.592424242424955 ms <br>  Abweichung vom Mittelwertintervall: 0.719936993603155 ms <br>  Intervallmedian: 4.605000001902226 ms <br><br><h3>  audioCtx.currentTime: </h3>  durchschnittliches Intervall: 10.12648022171832 ms <br>  Abweichung vom Mittelwertintervall: 1.4508887886499262 ms <br>  Intervallmedian: 8.707482993197118 ms <br><br></div></div><br></div></div><br>  Nun, es wird nicht klappen.  ‚ÄûDrau√üen‚Äú ist dieser Timer am ungenauesten.  Firefox aktualisiert den Timer-Wert in der Schleife nicht.  Aber im Allgemeinen: Aufl√∂sung ist 3 ms und schlechter und sp√ºrbarer Jitter.  M√∂glicherweise spiegelt der Wert von <code>audioCtx.currentTime</code> die Position im Ringpuffer des <code>audioCtx.currentTime</code> wider.  Mit anderen Worten, es wird die minimale Zeit angezeigt, die es noch m√∂glich ist, die Wiedergabe sicher zu verz√∂gern. <br><br>  Und was machen?  Schlie√ülich ben√∂tigen wir sowohl einen genauen Timer f√ºr die Synchronisierung mit dem Server und das Starten von Javascript-Ereignissen auf dem Bildschirm als auch einen Audio-Timer f√ºr Audio-Ereignisse! <br><br>  Es stellt sich heraus, dass Sie alle Timer miteinander synchronisieren m√ºssen: <br><br><ul><li>  Client <code>audioCtx.currentTime</code> mit client <code>performance.now()</code> auf dem Client. </li><li>  Und client <code>performance.now()</code> mit <code>performance.now()</code> serverseitig. </li></ul><br><h2>  Synchronisiert, synchronisiert </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right">  Im Allgemeinen ist dies ziemlich lustig, wenn Sie dar√ºber nachdenken: Sie k√∂nnen zwei gute Zeitquellen A und B haben, von denen jede am Ausgang sehr grob und verrauscht ist (A '= A + err <sub>A</sub> ; B' = B + err <sub>B</sub> ), so dass es kann selbst unbrauchbar sein.  Der Unterschied d zwischen den urspr√ºnglichen Quellen ohne Rauschen kann jedoch sehr genau wiederhergestellt werden. <br><br>  Da der tats√§chliche Zeitabstand zwischen den idealen Uhren konstant ist und n-mal gemessen wird, wird der Messfehler n-mal verringert.  Es sei denn nat√ºrlich, die Uhr l√§uft mit der gleichen Geschwindigkeit. <br><br><h2>  Ja nicht synchronisiert </h2><br>  Die schlechte Nachricht ist, dass sie nicht mit der gleichen Geschwindigkeit fahren.  Und ich spreche nicht von der Streuung der Stunden auf dem Server und auf dem Client - das ist verst√§ndlich und zu erwarten.  Was noch unerwarteter ist: <code>audioCtx.currentTime</code> allm√§hlich von <code>performance.now()</code> .  Es ist im Client.  Wir werden es vielleicht nicht bemerken, aber manchmal verschluckt das Audiosystem unter Last m√∂glicherweise keine kleinen Daten und (entgegen der Natur des Ringpuffers) verschiebt sich die Audiozeit relativ zur Systemzeit.  Dies kommt nicht so selten vor, es betrifft nur nicht viele Menschen. Wenn Sie beispielsweise zwei YouTube-Videos gleichzeitig auf verschiedenen Computern starten, ist es nicht so, dass die gleichzeitige Wiedergabe unterbrochen wird.  Und der Punkt ist nat√ºrlich nicht in der Werbung. <br><br>  Somit f√ºr einen stabilen und synchronen Betrieb.  Wir m√ºssen <i>regelm√§√üig</i> alle Uhren miteinander √ºberpr√ºfen und dabei die Serverzeit als Referenz verwenden.  Der Kompromiss <code>audioCtx.currentTime</code> sich aus der <code>audioCtx.currentTime</code> Messungen, die f√ºr die Mittelwertbildung verwendet werden sollen: Je genauer, aber je gr√∂√üer die Wahrscheinlichkeit, dass ein starker Sprung in <code>audioCtx.currentTime</code> in das Zeitfenster f√§llt, in dem die Werte gefiltert werden.  Wenn wir dann zum Beispiel das Minutenfenster verwenden, ist die Zeit jede Minute abgelaufen.  Die Auswahl an Filtern ist gro√ü: <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">Exponential-</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">Median-</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">Kalman-Filter</a> usw.  Aber dieser Kompromiss ist auf jeden Fall. <br><br><h2>  Zeitfenster </h2><br>  <code>audioCtx.currentTime</code> mit <code>performance.now()</code> synchronisieren, k√∂nnen Sie in einer asynchronen Schleife eine Messung durchf√ºhren, beispielsweise 100 ms, um die Benutzeroberfl√§che nicht zu beeintr√§chtigen. <br>  Es sei angenommen, dass der Messfehler err = errA + errB = 1 + 3 = 4 ms ist <br>  Dementsprechend k√∂nnen wir es in 1 Sekunde auf 0,4 ms und in 10 Sekunden auf 0,04 ms reduzieren.  Eine weitere Verbesserung des Ergebnisses ist nicht sinnvoll und ein gutes Filterfenster ist: 1 - 10 Sekunden. <br><br>  Bei der Netzwerksynchronisation sind Verz√∂gerungen und Fehler bereits viel bedeutender, aber es gibt keinen scharfen Zeitsprung wie beim <code>audioCtx.currentTime</code> .  Und Sie k√∂nnen sich erlauben, wirklich gute Statistiken zu sammeln.  Immerhin kann err for ping bis zu 500 ms betragen.  Und die Messungen selbst k√∂nnen wir nicht so oft machen. <br><br>  An diesem Punkt schlage ich vor, aufzuh√∂ren.  Wenn jemand interessiert war, erz√§hle ich Ihnen gerne, wie Sie "den Rest der Eule zeichnen" k√∂nnen.  Aber als Teil der Geschichte √ºber Timer denke ich, dass meine Geschichte vorbei ist. <br><br>  Und ich m√∂chte teilen, was ich habe.  Trotzdem das neue Jahr. <br><br><h2>  Was ist passiert? </h2><br>  Haftungsausschluss: Technisch gesehen handelt es sich um eine PR-Site auf Habr√©, aber es handelt sich um ein vollst√§ndig gemeinn√ºtziges Open-Source-Haustierprojekt, f√ºr das ich verspreche, niemals Werbung zu schalten oder anderweitig Geld zu verdienen.  Im Gegenteil, ich habe jetzt mehr Instanzen von meinem Geld gesammelt, um einen m√∂glichen Habraeffekt zu √ºberleben.  Deshalb bitte, gute Leute, brecht mich nicht und erreicht mich nicht.  Das macht alles nur Spa√ü. <br><br>  Frohes Neues Jahr, Habr! <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">snowtime.fun</a> </h3>  Sie k√∂nnen die Regler drehen und Visualisierung, Musik und Audioeffekte steuern.  Wenn Sie eine normale Grafikkarte haben, gehen Sie zu den Einstellungen und stellen Sie die Anzahl der Partikel auf 100% ein. <br><br>  Ben√∂tigt WebAudio und WebGL. <br><br><hr><br><br>  <b>UPD:</b> Funktioniert nicht in Safari unter MacOS Mojave.  Leider ist es nicht m√∂glich, schnell herauszufinden, was passiert, da diese Safari nicht vorhanden ist.  iOS scheint zu funktionieren. <br><br>  <b>UPD2:</b> Wenn <a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a> und <a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a> nicht reagieren, versuchen Sie es mit der neuen <a href="http://habr.snowtime.fun/" rel="nofollow"><b>Unterdom√§ne</b> habr .snowtime.fun</a> .  Er verlegte den Server in ein anderes Rechenzentrum und die alte IP wurde im DNS zwischengespeichert, <code>expire=1w</code> .  :( <br><br>  <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">Aufbewahrungsort</a> : <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">Bitbucket</a> <br>  Beim Schreiben dieses Artikels wurden <a href="http://www.freepik.com/" rel="nofollow">Macrovector / Freepik-</a> Illustrationen verwendet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482168/">https://habr.com/ru/post/de482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482152/index.html">Sicherheitsl√ºcken in Echtzeitbetriebssystemen</a></li>
<li><a href="../de482156/index.html">Interview mit Will Kurt √ºber sein neues Buch Bayesian Statistics - It's Great</a></li>
<li><a href="../de482158/index.html">Lernen Sie Ember Octane kennen</a></li>
<li><a href="../de482162/index.html">Mathematiker haben ein Muster gefunden und verstanden, wie man sein Auftreten vermeidet</a></li>
<li><a href="../de482166/index.html">Hundetraining am Flughafen: Sie sind bereits beschnuppert</a></li>
<li><a href="../de482170/index.html">Prozessorkriege. Die Geschichte vom blauen Hasen und der roten Schildkr√∂te</a></li>
<li><a href="../de482176/index.html">Wie verlief die @Kubernetes-Konferenz am 29. November: Video und Ergebnisse</a></li>
<li><a href="../de482178/index.html">Die Geschichte eines koreanischen Studenten, der vom Ministerium einen Preis f√ºr ein Warteschlangen√ºberwachungssystem erhalten hat</a></li>
<li><a href="../de482182/index.html">Welche Probleme h√§tte ich, wenn ich mich in der IT f√ºr ein ausgewogenes Verh√§ltnis der Geschlechter einsetzen w√ºrde?</a></li>
<li><a href="../de482186/index.html">Leben und IT oder das Jahr, in dem ich meinen letzten Job gek√ºndigt habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>