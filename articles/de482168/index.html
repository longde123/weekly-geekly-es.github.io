<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻 🤱 👩🏾‍🤝‍👨🏽 "Wenn die Uhr zwölf schlägt." Oder eine Girlande im Browser 🧡 🐦 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angenommen, wir haben mehrere Monitore. Und wir wollten diese Monitore als Girlande verwenden. Lassen Sie sie beispielsweise gleichzeitig blinken. Ode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Wenn die Uhr zwölf schlägt." Oder eine Girlande im Browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/">  Angenommen, wir haben mehrere Monitore.  Und wir wollten diese Monitore als Girlande verwenden.  Lassen Sie sie beispielsweise gleichzeitig blinken.  Oder ändern Sie die Farbe synchron nach einem intelligenten Algorithmus.  Und was ist, wenn Sie es in einem Browser tun - dann können Sie Smartphones und Tablets daran anschließen.  All das ist zur Hand. <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br>  Und da wir einen Browser verwenden, können Sie auch Sounddesign hinzufügen.  Wenn es genau genug ist, um die Geräte rechtzeitig zu synchronisieren, können Sie die Sounds auf jedem so abspielen, als ob ein Mehrkanalsystem klingt. <br><br><hr>  <i>Was kann bei der Synchronisierung von Web-Audio- und Gameplay-Uhren in einer Javascript-Anwendung auftreten?</i>  <i>Wie viele verschiedene "Stunden" gibt es in javasctipt (drei!) und warum werden alle benötigt, sowie eine <a href="http://habr.snowtime.fun/" rel="nofollow">fertige Anwendung</a> für node.js unter cat.</i> <a name="habracut"></a><hr><br><h2>  Überprüfen Sie die Uhr </h2><br>  Für jede bedingte Online-Girlande ist eine genaue Uhrzeitsynchronisation erforderlich.  Schließlich können Sie auch zeitweise auftretende Netzwerkverzögerungen ignorieren.  Es reicht aus, die Steuerbefehle mit einem Zeitstempel zu versehen und diese Befehle ein wenig "in die Zukunft" zu generieren.  Auf Clients werden sie gepuffert und dann synchron und pünktlich ausgeführt. <br><br>  Oder Sie können sogar noch weiter gehen - nehmen Sie den guten alten deterministischen Zufallsalgorithmus und verwenden Sie einen gemeinsamen Startwert (der vom Server einmal ausgegeben wird, wenn eine Verbindung besteht) auf allen Geräten.  Wenn Sie einen solchen Startwert <i>zusammen</i> mit der genauen Zeit verwenden, können Sie das Verhalten des Algorithmus auf allen Geräten vollständig vorgeben.  Stellen Sie sich vor, Sie benötigen kein Netzwerk und keinen Server, um den Status eindeutig und synchron zu ändern.  Seed enthält bereits die gesamte (bedingt unendliche) „Videoaufzeichnung“ von Aktionen im Voraus.  Die Hauptsache ist die genaue Zeit. <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>Jede Methode hat ihre Anwendungsgrenzen.</i>  <i>Bei der sofortigen Benutzereingabe ist natürlich nichts zu tun, es bleibt nur zu übertragen, wie es ist.</i>  <i>Aber alles, was berechnet werden kann, ist zu berechnen.</i>  <i>In meiner Implementierung verwende ich je nach Situation alle drei Ansätze.</i> <hr><br><h2>  Subjektiv "zur gleichen Zeit" </h2><br>  Im Idealfall sollte alles „zur selben Zeit“ klingen - für das schlechteste Paar unter den kombinierten Geräten sind nicht mehr als ± 10 ms Diskrepanz erforderlich.  Sie können sich nicht auf eine solche Genauigkeit der Systemzeit verlassen, und Standardmethoden zum Synchronisieren der Zeit mithilfe des NTP-Protokolls sind im Browser nicht verfügbar.  Deshalb werden wir unseren Synchronisationsserver ansteuern.  Das Prinzip ist einfach: Helm "pingt" und akzeptiert "Pongs" mit dem Zeitstempel des Servers.  Wenn Sie dies mehrmals hintereinander tun, können Sie den Fehler statistisch ausgleichen und die durchschnittliche Verzögerungszeit ermitteln. <br><br><div class="spoiler">  <b class="spoiler_title">Code: Berechnung der Serverzeit auf dem Client</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Websockets und darauf basierende Lösungen sind am besten geeignet, da sie keine Zeit zum Herstellen einer TCP-Verbindung benötigen und Sie in beide Richtungen mit ihnen "kommunizieren" können.  Natürlich nicht UDP oder ICMP, aber unvergleichlich schneller als eine normale Kaltverbindung über die HTTP-API.  Daher ist socket.io.  Dort ist alles sehr einfach: <br><br><div class="spoiler">  <b class="spoiler_title">Code: socket.io Implementierung</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>Anstatt den Durchschnitt zu berechnen, wäre es schön, den Median zu berechnen - dies verbessert die Genauigkeit bei einer instabilen Verbindung.</i>  <i>Die Wahl der Filtermethode liegt beim Leser.</i>  <i>Ich vereinfache den Code hier bewusst zugunsten von Schaltplänen.</i>  <i>Meine komplette Lösung finden Sie im Repository.</i> <br></div></div><br><br><h2>  performance.now () </h2><br>  Ich möchte Sie daran erinnern, dass das <code>performance</code> eine API ist, die den Zugriff auf einen hochauflösenden Zeitgeber ermöglicht.  Vergleichen Sie: <br><br><ul><li>  <b><code>Date.now()</code></b> gibt die Anzahl der Millisekunden seit dem 1. Januar 1970 in <b>ganzzahliger</b> Form zurück.  Das heißt, der Fehler nur beim Runden beträgt durchschnittlich 0,5 ms.  Beispielsweise können Sie bei einer Subtraktionsoperation <code>ab</code> bis zu 2 ms erfolglos „verlieren“.  Darüber hinaus garantiert der Zeitmesser selbst historisch und konzeptionell keine hohe Genauigkeit und ist für die Arbeit mit einer größeren Zeitskala geschärft. </li><li>  <b><code>performance.now()</code></b> gibt die Anzahl der Millisekunden <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">seit dem Öffnen der Webseite zurück</a> . <br>  Dies ist eine relativ neue API, die speziell für die genaue Messung von Zeitintervallen "geschärft" wurde.  Gibt <b>einen Gleitkommawert zurück</b> , der theoretisch einen Genauigkeitsgrad nahe an den Fähigkeiten des Betriebssystems selbst angibt. <br></li></ul><br><br>  Ich denke, diese Information ist fast allen Javascript-Entwicklern bekannt.  Aber nicht jeder weiß das ... <br><br><h2>  Specter </h2><br>  Aufgrund des sensationellen Timing-Angriffs von Specter im Jahr 2018 geht alles so weit, dass der hochauflösende Timer künstlich aufgeraut wird, wenn es keine andere Lösung für das Schwachstellenproblem gibt.  Firefox, beginnend mit Version 60, rundet den Wert dieses Timers auf eine Millisekunde und Edge noch schlimmer. <br><br>  Hier ist, was <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a> sagt: <br><br><blockquote>  Der Zeitstempel ist nicht wirklich hochauflösend.  Um Sicherheitsbedrohungen wie Spectre abzuschwächen, runden Browser die Ergebnisse derzeit in unterschiedlichem Maße ab.  (Firefox hat in Firefox 60 auf 1 Millisekunde gerundet.) Einige Browser können den Zeitstempel auch leicht zufällig einstellen.  Die Genauigkeit wird in zukünftigen Versionen möglicherweise wieder verbessert.  Browser-Entwickler untersuchen diese Timing-Angriffe noch und wie sie am besten gemindert werden können. </blockquote><br>  Lassen Sie uns den Test durchführen und die Grafiken betrachten.  Dies ist das Ergebnis des Tests für das Intervall von 10 ms: <br><br><div class="spoiler">  <b class="spoiler_title">Testcode: Zeitmessung in einem Zyklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  durchschnittliches Intervall: 1.0538336052202284 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,7547819181245603 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.567100970873786 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6748006785171455 ms <br>  Intervallmedian: 1,5015000000003056 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.0168350168350169 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,21645930182417966 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.0134453781512605 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,1734108492762375 ms <br>  Intervallmedian: 1 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.02442996742671 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,49858684744444 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 0.005555847229948915 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,027497846727194235 ms <br>  Intervallmedian: 0.0050000089686363935 ms <br></div></div><br><br>  Ok, Chrome, Zoom auf 1 ms. <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br>  Chrome hält also immer noch an und die Implementierung von <code>performance.now()</code> wurde noch nicht erdrosselt und der Schritt ist wunderschön, 0,005 ms.  Unter Edge ist der Timer von <code>performance.now()</code> rauer als <code>Date.now()</code> !  In Firefox haben beide Timer die gleiche Millisekundengenauigkeit. <br><br>  Zu diesem Zeitpunkt können bereits einige Schlussfolgerungen gezogen werden.  Aber es gibt einen anderen Timer in Javascript (ohne den wir nicht auskommen können). <br><br><h2>  WebAudio API Timer </h2><br>  Dies ist ein etwas anderes Tier.  Es wird für verzögerte Audio-Warteschlangen verwendet.  Tatsache ist, dass Audio-Events (Noten abspielen, Effekte verwalten) nicht auf standardmäßigen asynchronen Javascript-Tools <code>setInterval</code> können: <code>setInterval</code> und <code>setTimeout</code> - wegen ihres zu großen Fehlers.  Und dies ist nicht nur der Fehler <i>der</i> Timer- <i>Werte</i> (mit denen wir uns zuvor befasst haben), sondern es ist der Fehler, mit dem die Ereignismaschine Ereignisse ausführt.  Und es ist auch bei Gewächshausbedingungen schon etwas um die 5-25 ms. <br><br><div class="spoiler">  <b class="spoiler_title">Grafiken für den asynchronen Fall unter dem Spoiler</b> <div class="spoiler_text">  Das Ergebnis des Tests über einen Zeitraum von 100 ms: <br><br><div class="spoiler">  <b class="spoiler_title">Testcode: Zeitmessung in einem asynchronen Zyklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  durchschnittliches Intervall: 25.595959595959595 ms <br>  Abweichung vom Mittelwertintervall, RMS: 10.12639235162126 ms <br>  Intervallmedian: 28 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 25.862596938775525 ms <br>  Abweichung vom Mittelwertintervall, RMS: 10.123711255512573 ms <br>  Intervallmedian: 27.027099999999336 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.6914893617021276 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6018870280772611 ms <br>  Intervallmedian: 2 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.7865168539325842 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6442818510935484 ms <br>  Intervallmedian: 2 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 4,7878787878787888, ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,7557553886872682 ms <br>  Intervallmedian: 5 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 4.783989898979516 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6483716900974945 ms <br>  Medianintervall: 4.750000000058208 ms <br></div></div><br></div></div><br><br>  Vielleicht erinnert sich jemand an die ersten experimentellen HTML-Audioanwendungen.  Bevor vollwertiges WebAudio zu den Browsern kam, klangen sie alle wie ein bisschen betrunken und schlampig.  Nur weil sie <code>setTimeout</code> als Sequenzer benutzt haben. <br><br>  Die moderne WebAudio-API bietet dagegen eine garantierte Auflösung von bis zu 0,02 ms (Spekulation auf Basis der Abtastfrequenz von 44100Hz).  Dies liegt daran, dass für die verzögerte <code>setTimeout</code> ein anderer Mechanismus verwendet wird als für <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br>  Tatsächlich ist die Wiedergabe eines Audio-Samples „verzögert“.  Nur um es zu verlieren "wird nicht verschoben", müssen Sie es "bis jetzt" verschieben. <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Über durch Echtzeitsoftware erzeugte Musik</b> <div class="spoiler_text">  Wenn Sie eine programmsynthetisierte Melodie aus Noten spielen, müssen diese Noten vorab zur Wiedergabewarteschlange hinzugefügt werden.  Dann wird die Melodie trotz aller nicht grundlegenden Einschränkungen und Unregelmäßigkeiten der Timer perfekt flüssig abgespielt. <br><br>  Mit anderen Worten, die in Echtzeit synthetisierte Melodie sollte nicht in Echtzeit "erfunden" werden, sondern ein wenig im Voraus. <br></div></div><br><br><h2>  Ein Timer, um alle zu regieren </h2><br>  Da <code>audioCtx.currentTime</code> so stabil und genau ist, sollten wir es vielleicht als Hauptquelle für die relative Zeit verwenden?  Lassen Sie uns den Test noch einmal durchführen. <br><br><div class="spoiler">  <b class="spoiler_title">Testcode: Messen der synchronen Zeitmessung in einem Zyklus</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.037037037037037 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6166609846299806 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.5447103117505993 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,4390514285320851 ms <br>  Intervallmedian: 1,5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3>  Durchschnittsintervall: 2.955751134714949 ms <br>  Abweichung vom Mittelwertintervall, RMS: 0,6193645611529503 ms <br>  Intervallmedian: 2.902507781982422 ms <br><br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.005128205128205 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,12392867665225249 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 1.00513698630137 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,07148844433269844 ms <br>  Intervallmedian: 1 ms <br><br><h3>  audioCtx.currentTime </h3>  Firefox aktualisiert den Audio-Timer-Wert in der Synchronisierungsschleife nicht <br><br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  Durchschnittsintervall: 1.0207612456747406 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,49870223457982504 ms <br>  Intervallmedian: 1 ms <br><br><h3>  performance.now () </h3>  Durchschnittsintervall: 0.005414502034674972 ms <br>  Abweichung vom Durchschnittsintervall, RMS: 0,027441293974958335 ms <br>  Medianintervall: 0.004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3>  Durchschnittsintervall: 3.0877599266656963 ms <br>  Abweichung vom Mittelwert, RMS: 1.1445555956407658 ms <br>  Intervallmedian: 2.9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Grafiken für den asynchronen Fall unter dem Spoiler</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Testcode: Zeitmessung in einem asynchronen Zyklus</b> <div class="spoiler_text">  Das Ergebnis des Tests über einen Zeitraum von 100 ms: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Rand </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 44.17763.771.0 <br><br><h3>  Date.now (): </h3>  Durchschnittsintervall: 24.505050505050505 ms <br>  Abweichung vom Mittelwertintervall: 11.513166584195204 ms <br>  Intervallmedian: 26 ms <br><br><h3>  performance.now (): </h3>  Durchschnittsintervall: 24.50935757575754 ms <br>  Abweichung vom Mittelwertintervall: 11.679091435527388 ms <br>  Intervallmedian: 25.525499999999738 ms <br><br><h3>  audioCtx.currentTime: </h3>  Durchschnittsintervall: 24.76005164944396 ms <br>  Abweichung vom Mittelwertintervall: 11.311571546205316 ms <br>  Intervallmedian: 26.121139526367187 ms <br><br></div></div><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 71.0 <br><br><h3>  Date.now (): </h3>  Durchschnittsintervall: 1,6875 ms <br>  Abweichung vom Mittelwertintervall: 0.6663410663216448 ms <br>  Intervallmedian: 2 ms <br><br><h3>  performance.now (): </h3>  Durchschnittsintervall: 1.7234042553191489 ms <br>  Abweichung vom Mittelwertintervall: 0.6588877688171075 ms <br>  Intervallmedian: 2 ms <br><br><h3>  audioCtx.currentTime: </h3>  Durchschnittsintervall: 10.158730158730123 ms <br>  Abweichung vom Mittelwertintervall: 1.4512471655330046 ms <br>  Medianintervall: 8.707482993195299 ms <br><br></div></div><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">Statistiken</b> <div class="spoiler_text">  Browserversion: 79.0.3945.88 <br><br><h3>  Date.now (): </h3>  Durchschnittsintervall: 4.585858585858586 ms <br>  Abweichung vom Mittelwertintervall: 0.9102125516015199 ms <br>  Intervallmedian: 5 ms <br><br><h3>  performance.now (): </h3>  durchschnittliches Intervall: 4.592424242424955 ms <br>  Abweichung vom Mittelwertintervall: 0.719936993603155 ms <br>  Intervallmedian: 4.605000001902226 ms <br><br><h3>  audioCtx.currentTime: </h3>  durchschnittliches Intervall: 10.12648022171832 ms <br>  Abweichung vom Mittelwertintervall: 1.4508887886499262 ms <br>  Intervallmedian: 8.707482993197118 ms <br><br></div></div><br></div></div><br>  Nun, es wird nicht klappen.  „Draußen“ ist dieser Timer am ungenauesten.  Firefox aktualisiert den Timer-Wert in der Schleife nicht.  Aber im Allgemeinen: Auflösung ist 3 ms und schlechter und spürbarer Jitter.  Möglicherweise spiegelt der Wert von <code>audioCtx.currentTime</code> die Position im Ringpuffer des <code>audioCtx.currentTime</code> wider.  Mit anderen Worten, es wird die minimale Zeit angezeigt, die es noch möglich ist, die Wiedergabe sicher zu verzögern. <br><br>  Und was machen?  Schließlich benötigen wir sowohl einen genauen Timer für die Synchronisierung mit dem Server und das Starten von Javascript-Ereignissen auf dem Bildschirm als auch einen Audio-Timer für Audio-Ereignisse! <br><br>  Es stellt sich heraus, dass Sie alle Timer miteinander synchronisieren müssen: <br><br><ul><li>  Client <code>audioCtx.currentTime</code> mit client <code>performance.now()</code> auf dem Client. </li><li>  Und client <code>performance.now()</code> mit <code>performance.now()</code> serverseitig. </li></ul><br><h2>  Synchronisiert, synchronisiert </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right">  Im Allgemeinen ist dies ziemlich lustig, wenn Sie darüber nachdenken: Sie können zwei gute Zeitquellen A und B haben, von denen jede am Ausgang sehr grob und verrauscht ist (A '= A + err <sub>A</sub> ; B' = B + err <sub>B</sub> ), so dass es kann selbst unbrauchbar sein.  Der Unterschied d zwischen den ursprünglichen Quellen ohne Rauschen kann jedoch sehr genau wiederhergestellt werden. <br><br>  Da der tatsächliche Zeitabstand zwischen den idealen Uhren konstant ist und n-mal gemessen wird, wird der Messfehler n-mal verringert.  Es sei denn natürlich, die Uhr läuft mit der gleichen Geschwindigkeit. <br><br><h2>  Ja nicht synchronisiert </h2><br>  Die schlechte Nachricht ist, dass sie nicht mit der gleichen Geschwindigkeit fahren.  Und ich spreche nicht von der Streuung der Stunden auf dem Server und auf dem Client - das ist verständlich und zu erwarten.  Was noch unerwarteter ist: <code>audioCtx.currentTime</code> allmählich von <code>performance.now()</code> .  Es ist im Client.  Wir werden es vielleicht nicht bemerken, aber manchmal verschluckt das Audiosystem unter Last möglicherweise keine kleinen Daten und (entgegen der Natur des Ringpuffers) verschiebt sich die Audiozeit relativ zur Systemzeit.  Dies kommt nicht so selten vor, es betrifft nur nicht viele Menschen. Wenn Sie beispielsweise zwei YouTube-Videos gleichzeitig auf verschiedenen Computern starten, ist es nicht so, dass die gleichzeitige Wiedergabe unterbrochen wird.  Und der Punkt ist natürlich nicht in der Werbung. <br><br>  Somit für einen stabilen und synchronen Betrieb.  Wir müssen <i>regelmäßig</i> alle Uhren miteinander überprüfen und dabei die Serverzeit als Referenz verwenden.  Der Kompromiss <code>audioCtx.currentTime</code> sich aus der <code>audioCtx.currentTime</code> Messungen, die für die Mittelwertbildung verwendet werden sollen: Je genauer, aber je größer die Wahrscheinlichkeit, dass ein starker Sprung in <code>audioCtx.currentTime</code> in das Zeitfenster fällt, in dem die Werte gefiltert werden.  Wenn wir dann zum Beispiel das Minutenfenster verwenden, ist die Zeit jede Minute abgelaufen.  Die Auswahl an Filtern ist groß: <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">Exponential-</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">Median-</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">Kalman-Filter</a> usw.  Aber dieser Kompromiss ist auf jeden Fall. <br><br><h2>  Zeitfenster </h2><br>  <code>audioCtx.currentTime</code> mit <code>performance.now()</code> synchronisieren, können Sie in einer asynchronen Schleife eine Messung durchführen, beispielsweise 100 ms, um die Benutzeroberfläche nicht zu beeinträchtigen. <br>  Es sei angenommen, dass der Messfehler err = errA + errB = 1 + 3 = 4 ms ist <br>  Dementsprechend können wir es in 1 Sekunde auf 0,4 ms und in 10 Sekunden auf 0,04 ms reduzieren.  Eine weitere Verbesserung des Ergebnisses ist nicht sinnvoll und ein gutes Filterfenster ist: 1 - 10 Sekunden. <br><br>  Bei der Netzwerksynchronisation sind Verzögerungen und Fehler bereits viel bedeutender, aber es gibt keinen scharfen Zeitsprung wie beim <code>audioCtx.currentTime</code> .  Und Sie können sich erlauben, wirklich gute Statistiken zu sammeln.  Immerhin kann err for ping bis zu 500 ms betragen.  Und die Messungen selbst können wir nicht so oft machen. <br><br>  An diesem Punkt schlage ich vor, aufzuhören.  Wenn jemand interessiert war, erzähle ich Ihnen gerne, wie Sie "den Rest der Eule zeichnen" können.  Aber als Teil der Geschichte über Timer denke ich, dass meine Geschichte vorbei ist. <br><br>  Und ich möchte teilen, was ich habe.  Trotzdem das neue Jahr. <br><br><h2>  Was ist passiert? </h2><br>  Haftungsausschluss: Technisch gesehen handelt es sich um eine PR-Site auf Habré, aber es handelt sich um ein vollständig gemeinnütziges Open-Source-Haustierprojekt, für das ich verspreche, niemals Werbung zu schalten oder anderweitig Geld zu verdienen.  Im Gegenteil, ich habe jetzt mehr Instanzen von meinem Geld gesammelt, um einen möglichen Habraeffekt zu überleben.  Deshalb bitte, gute Leute, brecht mich nicht und erreicht mich nicht.  Das macht alles nur Spaß. <br><br>  Frohes Neues Jahr, Habr! <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">snowtime.fun</a> </h3>  Sie können die Regler drehen und Visualisierung, Musik und Audioeffekte steuern.  Wenn Sie eine normale Grafikkarte haben, gehen Sie zu den Einstellungen und stellen Sie die Anzahl der Partikel auf 100% ein. <br><br>  Benötigt WebAudio und WebGL. <br><br><hr><br><br>  <b>UPD:</b> Funktioniert nicht in Safari unter MacOS Mojave.  Leider ist es nicht möglich, schnell herauszufinden, was passiert, da diese Safari nicht vorhanden ist.  iOS scheint zu funktionieren. <br><br>  <b>UPD2:</b> Wenn <a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a> und <a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a> nicht reagieren, versuchen Sie es mit der neuen <a href="http://habr.snowtime.fun/" rel="nofollow"><b>Unterdomäne</b> habr .snowtime.fun</a> .  Er verlegte den Server in ein anderes Rechenzentrum und die alte IP wurde im DNS zwischengespeichert, <code>expire=1w</code> .  :( <br><br>  <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">Aufbewahrungsort</a> : <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">Bitbucket</a> <br>  Beim Schreiben dieses Artikels wurden <a href="http://www.freepik.com/" rel="nofollow">Macrovector / Freepik-</a> Illustrationen verwendet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482168/">https://habr.com/ru/post/de482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482152/index.html">Sicherheitslücken in Echtzeitbetriebssystemen</a></li>
<li><a href="../de482156/index.html">Interview mit Will Kurt über sein neues Buch Bayesian Statistics - It's Great</a></li>
<li><a href="../de482158/index.html">Lernen Sie Ember Octane kennen</a></li>
<li><a href="../de482162/index.html">Mathematiker haben ein Muster gefunden und verstanden, wie man sein Auftreten vermeidet</a></li>
<li><a href="../de482166/index.html">Hundetraining am Flughafen: Sie sind bereits beschnuppert</a></li>
<li><a href="../de482170/index.html">Prozessorkriege. Die Geschichte vom blauen Hasen und der roten Schildkröte</a></li>
<li><a href="../de482176/index.html">Wie verlief die @Kubernetes-Konferenz am 29. November: Video und Ergebnisse</a></li>
<li><a href="../de482178/index.html">Die Geschichte eines koreanischen Studenten, der vom Ministerium einen Preis für ein Warteschlangenüberwachungssystem erhalten hat</a></li>
<li><a href="../de482182/index.html">Welche Probleme hätte ich, wenn ich mich in der IT für ein ausgewogenes Verhältnis der Geschlechter einsetzen würde?</a></li>
<li><a href="../de482186/index.html">Leben und IT oder das Jahr, in dem ich meinen letzten Job gekündigt habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>