<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßÄ üëêüèø üè≥Ô∏è‚Äçüåà ¬øQu√© hay debajo de las optimizaciones del compilador GraalVM? ü•î üíò ‚ú°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos lidiando con el trabajo de GraalVM, y esta vez tenemos una traducci√≥n del art√≠culo de Aleksandar Prokopec "Bajo el cap√≥ de las optimizacio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© hay debajo de las optimizaciones del compilador GraalVM?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/485024/"><p>  Continuamos lidiando con el trabajo de GraalVM, y esta vez tenemos una traducci√≥n del art√≠culo de Aleksandar Prokopec "Bajo el cap√≥ de las optimizaciones de GraalVM JIT", publicado originalmente en el <a href="https://medium.com/graalvm/under-the-hood-of-graalvm-jit-optimizations-d6e931394797">blog en Medium</a> .  El art√≠culo tiene algunos enlaces interesantes, luego trataremos de traducir estos art√≠culos tambi√©n. </p><br><p><img src="https://habrastorage.org/webt/k-/0k/fz/k-0kfzbwnfrk_hswloa6dyyftjc.jpeg"></p><br><hr><br><p>  <a href="https://medium.com/graalvm/stream-api-performance-with-graalvm-be6cfe7fbb52">La √∫ltima vez en Medium,</a> vimos los problemas de rendimiento de la API de Java Streams en GraalVM en comparaci√≥n con Java HotSpot VM.  <a href="https://www.graalvm.org/">GraalVM</a> se caracteriza por un alto rendimiento, y en esos experimentos logramos una aceleraci√≥n de 1.7 a 5 veces.  Por supuesto, los valores espec√≠ficos de la ganancia de rendimiento siempre depender√°n del c√≥digo que ejecute y de los datos de carga, por lo que antes de sacar conclusiones, debe intentar ejecutar su c√≥digo en GraalVM usted mismo. </p><br><p>  En este art√≠culo, profundizaremos en el interior de GraalVM y veremos c√≥mo ocurre la compilaci√≥n JIT. </p><br><a name="habracut"></a><br><h2>  <font color="#D93740">Optimizaciones JIT en GraalVM</font> </h2><br><p>  Echemos un vistazo a una serie de optimizaciones de alto nivel que utiliza el compilador GraalVM.  En este art√≠culo tocaremos solo las optimizaciones m√°s interesantes junto con ejemplos espec√≠ficos de su trabajo.  Si desea profundizar, una buena visi√≥n general de las optimizaciones del compilador GraalVM se encuentra en un trabajo titulado <a href="https://www.researchgate.net/publication/320359502_Making_collection_operations_optimal_with_aggressive_JIT_compilation">"Hacer que las operaciones de recopilaci√≥n sean √≥ptimas con una compilaci√≥n JIT agresiva"</a> . </p><br><h2>  <font color="#D93740">En l√≠nea</font> </h2><br><p>  Si no toca el ensamblaje antes de tiempo, entonces la mayor√≠a de los compiladores JIT en m√°quinas virtuales modernas hacen an√°lisis internos.  Esto significa que en cada momento particular hay un an√°lisis de un m√©todo.  Por esta raz√≥n, el an√°lisis intraprocedural es mucho m√°s r√°pido que el an√°lisis interprocedural de todo el programa, que generalmente no tiene tiempo para completarse en el tiempo asignado para el trabajo del compilador JIT.  En un compilador que utiliza optimizaciones intraprocesales (por ejemplo, optimizando un m√©todo a la vez), una de las optimizaciones fundamentales m√°s importantes es la integraci√≥n.  La alineaci√≥n es importante porque aumenta efectivamente el m√©todo, lo que significa que el compilador puede ver m√°s oportunidades para optimizar simult√°neamente varios fragmentos de c√≥digo utilizados en m√©todos aparentemente no relacionados. </p><br><p> Tomemos, por ejemplo, el m√©todo <code>volleyballStars</code> de un art√≠culo anterior: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volleyballStars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(people) .map(p -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(p.hair, p.age + <span class="hljs-number"><span class="hljs-number">1</span></span>, p.height)) .filter(p -&gt; p.height &gt; <span class="hljs-number"><span class="hljs-number">198</span></span>) .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; p.age &lt;= <span class="hljs-number"><span class="hljs-number">21</span></span>) .mapToInt(p -&gt; p.age) .average().getAsDouble(); }</code> </pre> <br><p>  En este diagrama, vemos partes de la representaci√≥n intermedia (IR) de este m√©todo en GraalVM, en el momento inmediatamente posterior al an√°lisis del correspondiente c√≥digo de bytes de Java. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1cb/b4f/fd1/1cbb4ffd15a4c171de823accd8830071.png"></p><br><p>  Puede pensar en este IR como una especie de <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">√°rbol de sintaxis abstracta</a> con esteroides; gracias a √©l, algunas optimizaciones son m√°s f√°ciles de realizar.  No importa c√≥mo funciona este IR, pero si desea comprender este tema m√°s profundamente, puede consultar un documento llamado <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.726.5496%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">"Graal IR: una representaci√≥n intermedia declarativa extensible"</a> . </p><br><p>  La conclusi√≥n principal aqu√≠ es que el flujo de control del m√©todo indicado por los nodos amarillos del gr√°fico y las l√≠neas rojas ejecuta secuencialmente los m√©todos de la interfaz <code>Stream</code> : <code>Stream.filter</code> , <code>Stream.mapToInt</code> , <code>IntStream.average</code> .  Al no tener un conocimiento exacto de lo que est√° en el c√≥digo de estos m√©todos, el compilador no puede simplificar el m√©todo, ¬°y aqu√≠ la recuperaci√≥n viene al rescate! </p><br><p>  Una transformaci√≥n llamada en l√≠nea es algo muy comprensible: simplemente busca lugares para llamar m√©todos y los reemplaza con el cuerpo del m√©todo en l√≠nea correspondiente, los incrusta dentro.  Echemos un vistazo al IR del m√©todo <code>volleyballStars</code> despu√©s de incluir parte de los m√©todos.  <code>IntStream.average</code> se <code>IntStream.average</code> la parte que sigue a la llamada <code>IntStream.average</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d5a/717/c71/d5a717c711a64a653ae7784f5557a2e5.png"></p><br><p>  El diagrama muestra que la llamada a <code>getAsDouble</code> (n√∫mero de nodo 71) ha desaparecido del IR.  Tenga en cuenta que el m√©todo <code>getAsDouble</code> del objeto <code>getAsDouble</code> devuelto por <code>IntStream.average</code> (la √∫ltima llamada en el m√©todo <code>volleyballStars</code> ) se define en el JDK de la siguiente manera: </p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAsDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPresent) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"No value present"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> <br><p>  Aqu√≠ podemos encontrar la carga del campo <code>isPresent</code> (n√∫mero de nodo 190, <code>LoadField</code> ) y leer el campo de <code>value</code> .  Sin embargo, no queda ning√∫n rastro de la excepci√≥n <code>NoSuchElementException</code> y no hay m√°s c√≥digo que la arroje. </p><br><p>  Esto se debe a que el compilador GraalVM adivina: el m√©todo <code>volleyballStars</code> nunca arrojar√° una excepci√≥n.  Este conocimiento generalmente no est√° disponible durante la compilaci√≥n <code>getAsDouble</code> : se puede llamar desde muchos lugares diferentes en el programa, y ‚Äã‚Äãen alg√∫n otro caso la excepci√≥n seguir√° funcionando.  Sin embargo, en un m√©todo particular de <code>volleyballStars</code> , es poco probable que ocurra una excepci√≥n porque el conjunto de estrellas potenciales de voleibol nunca est√° vac√≠o.  Por esta raz√≥n, GraalVM elimina la rama e inserta <code>FixedGuard</code> , un nodo que no optimiza el c√≥digo en caso de violaci√≥n de nuestra suposici√≥n.  Este es un ejemplo bastante minimalista, y en la vida real hay casos mucho m√°s complicados de c√≥mo la alineaci√≥n ayuda a otras optimizaciones. </p><br><p>  Sabemos que el √°rbol de llamadas del programa suele ser muy profundo o tal vez incluso interminable.  Por lo tanto, es necesario detener la alineaci√≥n en alg√∫n momento: tiene restricciones muy espec√≠ficas sobre el tiempo de funcionamiento y el tama√±o de la memoria.  Sabiendo esto, queda claro: determinar qu√© y cu√°ndo en l√≠nea es muy dif√≠cil. </p><br><h2>  <font color="#D93740">Revestimiento polim√≥rfico</font> </h2><br><p>  La alineaci√≥n solo funciona si el compilador puede determinar el m√©todo espec√≠fico al que se dirige la operaci√≥n de llamada al m√©todo.  Pero en Java, generalmente hay muchas llamadas indirectas para aquellos m√©todos cuyas implementaciones son desconocidas en est√°tica, que se buscan en tiempo de ejecuci√≥n mediante el env√≠o virtual. </p><br><p>  Por ejemplo, tome el m√©todo <code>IntStream.average</code> .  Su implementaci√≥n t√≠pica se ve as√≠: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> OptionalDouble </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] avg = collect( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], (ll, i) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += i; }, (ll, rr) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> avg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? OptionalDouble.of((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) avg[<span class="hljs-number"><span class="hljs-number">1</span></span>] / avg[<span class="hljs-number"><span class="hljs-number">0</span></span>]) : OptionalDouble.empty(); }</code> </pre> <br><p>  ¬°No dejes que la aparente simplicidad del c√≥digo te enga√±e!  Este m√©todo se define en t√©rminos de llamadas por <code>collect</code> , y la magia sucede aqu√≠.  El √°rbol de llamadas de este m√©todo (por ejemplo, la jerarqu√≠a de llamadas) crece r√°pidamente a medida que profundizamos en la <code>collect</code> .  Solo eche un vistazo a este diagrama: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/584/306/ce3/584306ce380584ae1266e1026040389f.png"></p><br><p>  Comenzando desde alg√∫n punto en el proceso de atravesar el √°rbol de llamadas, el inliner descansa contra la llamada <code>opWrapSink</code> del marco de <code>opWrapSink</code> Java, que es un m√©todo abstracto: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/be4/43b/b46/be443bb464f938c962b8649ef26de75d.png"></p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function">&lt;P_IN&gt; Sink&lt;P_IN&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapSink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sink&lt;P_OUT&gt; sink)</span></span></span></span>;</code> </pre> <br><p>  Por lo general, un inliner no ir√° m√°s all√°, porque es una llamada indirecta.  La determinaci√≥n de un m√©todo espec√≠fico ocurrir√° solo durante la ejecuci√≥n del programa, y ‚Äã‚Äãahora el inlayner simplemente no sabe en qu√© continuar√° trabajando. </p><br><p>  En el caso de GraalVM, sucede algo m√°s: guarda un perfil del tipo del m√©todo de destino para cada punto de llamada indirecta.  Este perfil es esencialmente solo una tabla que indica con qu√© frecuencia se <code>wrapSink</code> cada una de las implementaciones de <code>wrapSink</code> .  En nuestro caso, el perfil conoce tres implementaciones diferentes en clases an√≥nimas: <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> , <code>ReferencePipeline$4</code> .  Estas implementaciones se llaman con una probabilidad del 50%, 25% y 25%, respectivamente. </p><br><br><pre> <code class="plaintext hljs">0.500000: Ljava/util/stream/ReferencePipeline$2; 0.250000: Ljava/util/stream/ReferencePipeline$4; 0.250000: Ljava/util/stream/ReferencePipeline$3; notRecorded: 0.000000</code> </pre><br><p>  Esta informaci√≥n proporciona una ayuda invaluable al compilador, permiti√©ndole generar un <code>switch</code> <em>tipo</em> : una breve <code>switch</code> que verifica el tipo del m√©todo en tiempo de ejecuci√≥n, luego llama a un m√©todo espec√≠fico para cada uno de los casos anteriores.  La imagen a continuaci√≥n muestra una parte de la vista intermedia que muestra el interruptor de tipo (tres <code>if</code> nodos) con una verificaci√≥n para ver si el tipo de destinatario es alguien de <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> o <code>ReferencePipeline$4</code> .  Cada llamada directa en la ramificaci√≥n exitosa de cada una de las comprobaciones de <code>InstanceOf</code> ahora puede estar en l√≠nea o conectarle algunas optimizaciones adicionales.  Si ninguno de los tipos pasa la prueba, el c√≥digo se desoptimiza en el nodo <code>Deopt</code> (como alternativa, puede ejecutar el despacho virtual). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/26e/688/ca8/26e688ca89ea6c397b72f9acaba08ff3.png"></p><br><p>  Si desea comprender m√°s profundamente la alineaci√≥n polim√≥rfica, le recomiendo el trabajo cl√°sico sobre este tema, <a href="https://dl.acm.org/citation.cfm%3Fid%3D679839">"Incorporaci√≥n de m√©todos virtuales"</a> . </p><br><h2>  <font color="#D93740">An√°lisis de escape parcial</font> </h2><br><p>  Volvamos a nuestro ejemplo de voleibol.  Observe que ninguno de los objetos <code>Person</code> asignados dentro de la lambda pasada a la funci√≥n de <code>map</code> escapa del alcance del m√©todo <code>volleyballStars</code> .  En otras palabras, en el momento en que finaliza el m√©todo <code>volleyballStars</code> , no existe tal √°rea de memoria que apunte a objetos de tipo <code>Person</code> .  En particular, el registro del valor <code>getHeight</code> se usa adem√°s solo para el filtrado de altura. </p><br><p>  En alg√∫n momento durante la compilaci√≥n del m√©todo <code>volleyballStars</code> , llegamos al IR que se muestra en el diagrama a continuaci√≥n.  El bloque que comienza con el nodo <code>Begin</code> -1621 comienza con la asignaci√≥n del objeto <code>Person</code> (en el nodo <code>Alloc</code> ), que se inicializa tanto con el valor del campo de <code>age</code> con un incremento de 1 como con el valor anterior del campo de <code>height</code> .  El campo de <code>height</code> se lee previamente en el nodo <code>LoadField</code> -1539.  El resultado de la asignaci√≥n se encapsula en <code>AllocatedObject</code> -2137 y se env√≠a a la llamada al m√©todo <code>accept</code> -1625.  El compilador no puede hacer nada m√°s en este momento: desde su punto de vista, el objeto escap√≥ del m√©todo <code>volleyballStars</code> .  ( <em>Nota del traductor: "escapar de un objeto" se llama "escape" en ingl√©s, de ah√≠ que el nombre de la optimizaci√≥n sea "an√°lisis de escape"</em> ). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a02/cca/495/a02cca495ad607770a0111040e0a724a.png"></p><br><p>  Despu√©s de eso, el compilador decide alinear la llamada de <code>accept</code> , esto parece razonable.  Como resultado, llegamos al siguiente IR: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/334/5b9/029/3345b90295b77a64ded506f3042a146a.png"></p><br><p>  Y aqu√≠ el compilador JIT comienza un an√°lisis de escape parcial: se da cuenta de que <code>AllocatedObject</code> usa solo para leer el campo de <code>height</code> (recuperar, la <code>height</code> usa solo en la condici√≥n de filtrado, verifique que la altura sea mayor que 198).  Por lo tanto, el compilador puede reasignar la lectura del campo de <code>height</code> -2167 para trabajar directamente con el nodo previamente escrito en el objeto <code>Person</code> (nodo <code>Alloc</code> -2136), y este es nuestro <code>LoadField</code> -1539.  Adem√°s, el nodo <code>Alloc</code> aqu√≠ en adelante no va a la entrada de ning√∫n otro nodo, por lo que simplemente puede eliminarlo: ¬°este es un c√≥digo muerto! </p><br><p>  Esta optimizaci√≥n es, de hecho, la raz√≥n principal por la cual el ejemplo de <code>volleyballStars</code> experiment√≥ una aceleraci√≥n de cinco veces despu√©s de cambiar a GraalVM.  Aunque todos los objetos <code>Person</code> no son necesarios y se descartan inmediatamente despu√©s de la creaci√≥n, a√∫n deben asignarse en el mont√≥n, su memoria a√∫n debe inicializarse.  El an√°lisis de escape parcial le permite eliminar asignaciones o posponerlas movi√©ndolas a esas ramas de c√≥digo donde los objetos realmente se escapan y que suceden con mucha menos frecuencia. </p><br><p>  Puede obtener una comprensi√≥n m√°s profunda del an√°lisis de escape parcial en un documento llamado <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">An√°lisis de escape parcial y reemplazo escalar para Java</a> . </p><br><h2>  <font color="#D93740">Resumen</font> </h2><br><p>  En este art√≠culo, analizamos tres optimizaciones de GraalVM: alineaci√≥n, alineaci√≥n polim√≥rfica y an√°lisis de escape parcial.  Hay muchas m√°s optimizaciones diferentes: promoci√≥n y divisi√≥n de ciclos, duplicaci√≥n de rutas, numeraci√≥n de valores globales, convoluci√≥n de constantes, eliminaci√≥n de c√≥digo muerto, ejecuci√≥n especulativa, etc. </p><br><p>  Si desea obtener m√°s informaci√≥n sobre c√≥mo funciona GraalVM, no dude en abrir la <a href="http://www.graalvm.org/community/publications/">p√°gina de publicaci√≥n</a> .  Si desea asegurarse de que GraalVM pueda acelerar su c√≥digo, puede <a href="https://www.graalvm.org/downloads/">descargar los archivos binarios</a> y probarlo usted mismo. </p><br><hr><br><h2>  <font color="#D93740">Del traductor: materiales adicionales</font> </h2><br>  En las conferencias, JPoint y Joker a menudo hablan sobre GraalVM.  Por ejemplo, en el √∫ltimo JPoint 2019, Thomas Wuerthinger (Director de Investigaci√≥n de Oracle Labs, responsable de GraalVM) y Oleg Shelaev, uno de los dos evangelistas tecnol√≥gicos oficiales, nos visitaron. <br><br>  Puedes ver estos y otros videos en nuestro canal de YouTube: <br><br><ul><li>  Thomas Wuerthinger: <a href="https://www.youtube.com/watch%3Fv%3DR_SeDk16PLY">"Maximizando el rendimiento con GraalVM"</a> </li><li>  Oleg Shelaev: <a href="https://www.youtube.com/watch%3Fv%3DC5fATKdVxZ0">"Supercompilaci√≥n, evaluaci√≥n parcial, proyecciones de Futamura y c√≥mo GraalVM salvar√° al mundo"</a> </li><li>  Roberto Cortez: <a href="https://www.youtube.com/watch%3Fv%3DoY8sfg7A1kg">‚ÄúGraalVM y MicroProfile: una soluci√≥n de microservicios pol√≠glotas‚Äù</a> </li><li>  Ionut Balosin: <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">‚ÄúUna carrera de dos compiladores: GraalVM JIT versus HotSpot JIT C2.</a>  <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">¬øCu√°l ofrece un mejor rendimiento en tiempo de ejecuci√≥n?</a> </li></ul><br><blockquote>  Le recordamos que el pr√≥ximo JPoint se llevar√° a cabo del 15 al 16 de mayo de 2020 en Mosc√∫, y que los boletos ya se pueden comprar <a href="https://jpoint.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D485024%26utm_campaign%3Djpoint20">en el sitio web oficial</a> . </blockquote><br></div></div><p>Source: <a href="https://habr.com/ru/post/485024/">https://habr.com/ru/post/485024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485012/index.html">C√≥mo usar Control Inversion en JavaScript y Reactjs para simplificar el manejo del c√≥digo</a></li>
<li><a href="../485014/index.html">¬øDeber√≠a quejarme de entrevistas?</a></li>
<li><a href="../485016/index.html">Bases de datos administradas en Selectel: Bienvenido a Beta</a></li>
<li><a href="../485018/index.html">Escribir sombreadores con c√≥digo en Unity LWRP</a></li>
<li><a href="../485022/index.html">Playme Sigma: DVR funcional y asequible</a></li>
<li><a href="../485026/index.html">Oportunidades de Georgia para profesionales de TI</a></li>
<li><a href="../485028/index.html">CRM 2020</a></li>
<li><a href="../485030/index.html">Top 8 tarifas de IEO y su capitalizaci√≥n ahora</a></li>
<li><a href="../485032/index.html">C√≥mo hacer que una aplicaci√≥n React sea m√°s r√°pida con el cohospedaje estatal</a></li>
<li><a href="../485034/index.html">Automatizar la compilaci√≥n de un proyecto Qt en Windows en Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>