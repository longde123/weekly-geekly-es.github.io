<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏼 🏣 👼🏾 100.500 metode caching di Oracle Database 👩🏿‍🤝‍👩🏾 🤚🏻 🐛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk mengetahui apa itu cache, apa itu Hasil Cache, bagaimana itu dibuat di Oracle dan di database lain tidak terlalu menarik dan cukup sederhana. Ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>100.500 metode caching di Oracle Database</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414401/">  Untuk mengetahui apa itu cache, apa itu Hasil Cache, bagaimana itu dibuat di Oracle dan di database lain tidak terlalu menarik dan cukup sederhana.  Tapi semuanya mengambil warna yang sangat berbeda ketika datang ke contoh spesifik.  <strong>Alexander Tokarev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">shtock</a> ) membuat laporannya di Highload ++ 2017 berdasarkan kasus.  Dan justru atas dasar kasus-kasus itu dia mengatakan kapan cache buatan mungkin nyaman, apa rasa sakit dari Cache Hasil sisi server dan bagaimana menggantinya dengan yang sisi klien, dan secara umum dia membawa sejumlah tips yang berguna untuk mengatur Hasil Cache di Oracle. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hTCXaAKIArk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Alexander Tokarev bekerja di DataArt dan menangani masalah yang terkait dengan database, baik dalam hal membangun sistem dari awal dan mengoptimalkan yang sudah ada. <br><br>  Mari kita mulai dengan beberapa pertanyaan retoris.  Sudahkah Anda bekerja dengan Oracle Result Cache?  Apakah Anda percaya bahwa Oracle adalah basis data yang cocok untuk semua kesempatan?  Menurut pengalaman Alexander, kebanyakan orang menjawab pertanyaan terakhir dalam negatif, <strong>seratus pemimpi memiliki satu pemimpi</strong> .  Namun berkat keyakinannya, kemajuan terus bergerak. <br><br>  Omong-omong, Oracle sudah memiliki 14 basis data - sejauh ini 14 - apa yang akan terjadi di masa depan tidak diketahui. <br><br>  Seperti yang telah disebutkan, semua masalah dan solusi akan diilustrasikan dengan kasus-kasus spesifik.  Ini akan menjadi dua kasus dari proyek DataArt, dan satu contoh pihak ketiga. <br><a name="habracut"></a><br><h2>  Tembolok basis data <br></h2><br>  Untuk memulainya, cache mana yang ada di database.  Semuanya jelas di sini: <br><br><ul><li>  Cache penyangga - cache data - cache untuk halaman data / blok data; </li><li>  Cache pernyataan - cache pernyataan dan rencananya - cache rencana kueri; </li><li>  Cache hasil - cache hasil baris - baris dari kueri; </li><li>  OS cache - cache sistem operasi. </li></ul><br>  Selain itu, cache Hasil, pada umumnya, hanya digunakan di Oracle.  Dia pernah di MySQL, tapi kemudian dia dengan heroik dipotong.  Dalam PostgreSQL juga tidak ada, ia hadir dalam satu bentuk atau lainnya hanya dalam produk pgpool pihak ketiga. <br><br><h2>  Kasus 1. Gudang Pengecer <br></h2><br><img src="https://habrastorage.org/webt/qo/cq/t5/qocqt5zzctiqj1hh5n-6hc9skkm.jpeg"><br><br>  Di atas adalah diagram produk yang kami sertai - repositori (pengguna Oracle 11, 20 Tb, 300), dan berisi beberapa jenis laporan suram, di mana terdapat 350 produk unik per 5.000 jalur data.  Diperlukan waktu sekitar 20 menit, dan para pengguna merasa sedih. <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> laporan ini, seperti orang lain, tersedia di situs konferensi Highload ++. </blockquote><br>  Laporan ini memiliki SELECT, JOINs, dan sebuah fungsi.  Suatu fungsi sebagai fungsi, semuanya akan baik-baik saja, hanya saja ia menghitung parameter misterius yang disebut "nilai harga transfer", ia bekerja selama 0,2 detik - sepertinya tidak ada apa-apa, tetapi ia dipanggil berkali-kali karena ada baris dalam tabel.  Fungsi ini memiliki 400 baris SQL + PL / SQL, sejak  produk ini dalam dukungan, itu menakutkan untuk mengubahnya. <br><br>  Untuk alasan yang sama, result_cache tidak dapat digunakan. <br><br><img src="https://habrastorage.org/webt/1o/u5/ct/1ou5ctbufxqrsme66mbz60bieuy.jpeg"><br><br>  Untuk mengatasi masalah tersebut, kami menggunakan <strong>pendekatan</strong> standar <strong>dengan caching buatan tangan</strong> : kami membiarkan 3 blok pertama dari rangkaian, seperti sebelumnya, cukup ganti nama fungsi sku_detail () menjadi sku_full () dan deklarasikan array asosiatif, di mana masing-masing: <br><br><ul><li>  kuncinya adalah SKU kami (barang komoditas), <br></li><li>  Nilai adalah harga konversi transfer yang dihitung. <br></li></ul><br>  Kami membuat fungsi cache (sku) menjadi jelas: jika tidak ada id seperti itu di array asosiatif kami, fungsi kami diluncurkan, hasilnya di-cache, disimpan, dan dikembalikan.  Dengan demikian, jika id seperti itu, maka semua ini tidak terjadi.  Bahkan, kami mendapat <strong>permintaan cache</strong> . <br><br>  Dengan demikian, kami telah mengurangi jumlah pemanggilan fungsi ke jumlah yang sebenarnya dibutuhkan.  <strong>Waktu pemrosesan laporan menurun menjadi 4 menit</strong> , semua pengguna merasa senang. <br><br><h3>  <strong>Memori Cache Buatan Tangan</strong> <br></h3><br>  Kerugian dan keuntungan dari sistem ini jelas dari gambar pintar yang besar ini, yang akan kita bahas banyak - ini adalah arsitektur memori. <br><br><img src="https://habrastorage.org/webt/ku/e4/2o/kue42onfhkjjpxxyk0klg0-at50.jpeg"><br><br>  Penting untuk memahami di mana area memori koleksi berada.  Mereka ditempatkan di area memori yang disebut PGA.  <strong>Program area global</strong> dipakai pada setiap koneksi ke database.  Inilah yang menentukan kelebihan dan kekurangan, karena lebih banyak koneksi - lebih banyak memori, dan <strong>memori mahal, server</strong> , admin lunak. <br><br><img src="https://habrastorage.org/webt/7c/gi/hd/7cgihdigefzcded25cmfondxkcc.jpeg"><br><br><ul><li>  <strong>Pro:</strong> semuanya bekerja sangat cepat, sangat mudah dilakukan, tidak ada konfigurasi yang diperlukan, tidak ada masalah dengan keterlibatan antarproses. <br></li><li>  <strong>Kontra</strong> dapat dimengerti: jika logika yang disimpan dilarang dalam proyek, mereka tidak dapat digunakan, tidak ada mekanisme untuk pembatalan otomatis, dan karena memori pada cache dialokasikan dalam satu sesi basis data, bukan sebuah instance, <strong>konsumsinya terlalu dilebih-lebihkan</strong> .  Selain itu, dalam kasus penggunaan kasus koneksi pool, Anda harus ingat untuk menyiram cache jika harus ada caching yang berbeda untuk setiap sesi. <br></li></ul><br>  Ada opsi lain untuk cache buatan tangan berdasarkan pandangan material, tabel sementara, tetapi dari mereka ada beban besar pada sistem input-output, jadi di sini kita tidak mempertimbangkannya.  Mereka lebih berlaku untuk database lain di mana masalah seperti itu biasanya diselesaikan dengan menyimpan prosedur tersimpan di beberapa tabel perantara dan mengambil data dari itu sebelum mengakses permintaan yang berat.  Dan hanya jika tidak ditemukan apa yang dibutuhkan, maka permintaan awal dipanggil. <br><br><img src="https://habrastorage.org/webt/mh/8u/xg/mh8uxg2hjytjwrp0fbds1gvoc4k.jpeg"><br><br>  Di atas adalah ilustrasi dari pendekatan ini untuk masalah caching untuk mendapatkan daftar produk terkait di MsSQL.  Secara umum, pendekatannya relatif sama, tetapi tidak bekerja dalam memori database baik dalam hal memperoleh data dan pengisian primer, karena ini <strong>bisa lebih lambat</strong> . <br><br>  Secara umum, result_cache buatan sendiri digunakan secara aktif, tetapi in-database result_cache adalah pendekatan yang berbeda untuk pelaksanaan tugas ini.  Itu dan bagaimana itu tidak berhasil, kita akan mempertimbangkan lebih lanjut. <br><br><h2>  Kasus 2. Pemrosesan dokumentasi keuangan <br></h2><br>  Jadi, kasus kedua kami. <br><br><img src="https://habrastorage.org/webt/dd/zn/wy/ddznwymy92vgt32eox6fvwanepq.jpeg"><br><br>  Ini adalah sistem pemrosesan dokumentasi keuangan semi-otomatis - perusahaan suram dengan arsitektur klasik, yang meliputi: <br><br><ul><li>  klien kurus; <br></li><li>  4.000 pengguna yang tinggal di berbagai belahan dunia; <br></li><li>  penyeimbang; <br></li><li>  2 JBoss untuk menghitung logika bisnis; <br></li><li>  in-memory cluster; <br></li><li>  inti Oracle; <br></li><li>  Cadangan Oracle <br></li></ul><br>  Salah satu dari banyak tugas sistem ini adalah <strong>perhitungan rekomendasi</strong> . <br><br><img src="https://habrastorage.org/webt/dm/rt/cf/dmrtcfcgvy2q94g-jl52qnhatbo.jpeg"><br><br>  Ada beberapa dokumen, untuk setiap indikator yang tidak secara otomatis dikenali oleh sistem, serangkaian indikator ditawarkan baik dari dokumen klien sebelumnya, atau dari industri serupa, atau oleh profitabilitas yang serupa, sementara indikator tersebut dibandingkan dengan nilai yang diakui sehingga tidak menawarkan terlalu banyak.  Yang penting, <strong>dokumen-dokumen itu multibahasa</strong> . <br><br>  Pengguna memilih nilai yang diinginkan dan mengulangi operasi untuk setiap baris kosong. <br><br>  Sederhana, tugas ini terdiri dari yang berikut: dokumen tiba dalam bentuk pasangan kunci-nilai dari sistem pengenalan yang berbeda, dan parameter dikenali di suatu tempat, tetapi tidak di suatu tempat.  Penting untuk memastikan bahwa pada akhirnya pengguna memproses dokumen dan semua nilai diakui.  Rekomendasi tersebut tepat ditujukan untuk menyederhanakan tugas ini dan mempertimbangkan: <br><br><ol><li>  Multilingualisme - sekitar 30 bahasa.  Setiap bahasa memiliki stemming, sinonim dan fitur lainnya sendiri. </li><li>  Data sebelumnya dari klien ini, atau, jika tidak ada, data klien dari industri yang sama atau klien yang serupa dalam laba. </li></ol><br>  Sebenarnya, ini adalah sekitar 12 aturan yang sangat kompleks. <br><br>  <strong>Asumsi awal:</strong> <br><br><ul><li>  Tidak lebih dari 100 pengguna sekaligus; </li><li>  2-3 kolom untuk pengakuan; </li><li>  100 baris. </li></ul><br>  <strong>Tidak ada beban</strong> sama sekali - semuanya membosankan. <br><br>  Jadi, saatnya untuk rilis.  Terjadi pembekuan kode, Java takut disentuh, dan dibutuhkan setidaknya 5 menit untuk memproses dokumen. <br><br>  Mereka datang ke tim pengembangan basis data untuk meminta bantuan.  Tentu saja, karena <em>jika sesuatu melambat di JVM, maka dengan sendirinya, Anda perlu mengubah atau memperbaiki database</em> . <br><br><img src="https://habrastorage.org/webt/ae/q_/tm/aeq_tm3cua2tkk3ohgxl7rntova.jpeg"><br><br>  Kami mempelajari dokumen-dokumen dan menyadari bahwa dalam pasangan kunci-nilai, nilai sering diulang - 5-10 kali.  Oleh karena itu, kami memutuskan untuk menggunakan basis data untuk menyimpan cache, karena sudah diuji. <br><br>  Kami memutuskan untuk menggunakan Cache Hasil sisi server Oracle, karena: <br><br><ol><li>  peluang untuk mengoptimalkan SQL telah habis, karena menggunakan mesin pencari teks lengkap Oracle; <br></li><li>  cache akan digunakan untuk parameter duplikat; <br></li><li>  sebagian besar data untuk rekomendasi dihitung ulang sekali per jam, karena mereka menggunakan indeks teks lengkap; <br></li><li>  <strong>PL / SQL dilarang</strong> . <br></li></ol><br><h3>  <strong>Cache Hasil Oracle</strong> <br></h3><br>  Cache hasil - caching hasil Oracle - memiliki properti berikut: <br><br><ul><li>  Ini adalah area memori tempat semua hasil pencarian digeledah; </li><li>  membaca konsisten, dan pembatalan otomatis terjadi; </li><li>  diperlukan perubahan minimal pada aplikasi.  Anda dapat membuat aplikasi tidak perlu diubah sama sekali; </li><li>  bonus - Anda dapat men-cache logika PL / SQL, tetapi dilarang di sini. </li></ul><br>  <strong>Bagaimana cara mengaktifkannya?</strong> <br><br><h4>  Metode nomor 1 <br></h4><br><img src="https://habrastorage.org/webt/qo/im/jv/qoimjvcbfclnfsp_pncn6uf-74g.jpeg"><br><br>  Sangat sederhana untuk <strong>menentukan pernyataan result_cache</strong> .  Slide menunjukkan bahwa pengidentifikasi hasil telah muncul.  Dengan demikian, pertama kali kueri dieksekusi, database akan melakukan beberapa pekerjaan, selama eksekusi berikutnya, dalam hal ini tidak ada pekerjaan yang diperlukan.  Semuanya baik-baik saja. <br><br><h4>  Metode nomor 2 <br></h4><br><img src="https://habrastorage.org/webt/5x/uy/d5/5xuyd5seajh5kshz1xmdvmd6fu0.jpeg"><br><br>  Cara kedua memungkinkan pengembang aplikasi untuk tidak melakukan apa pun - ini adalah apa yang disebut anotasi.  Kami menunjukkan tanda centang untuk tabel yang permintaannya harus ditempatkan di result_cache.  Dengan demikian, tidak ada petunjuk, kami tidak menyentuh aplikasi, dan semuanya sudah ada di result_cache. <br><br><blockquote>  Omong-omong, bagaimana menurut Anda, jika kueri merujuk ke dua tabel, yang satu ditandai sebagai result_cache, dan yang kedua tidak, apakah hasil kueri tersebut di-cache? <br><br>  Jawabannya adalah tidak, tidak sama sekali. <br></blockquote><br>  Agar bisa di-cache, semua tabel yang berpartisipasi dalam kueri harus memiliki anotasi result_cache. <br><br><h3>  <strong>Pelacakan ketergantungan</strong> <br></h3><br>  Ada pandangan yang relevan di mana Anda bisa melihat apa dependensi itu. <br><br><img src="https://habrastorage.org/webt/ni/12/bp/ni12bpiy04zhswxncy1rsq1h29s.jpeg"><br><br>  Dalam contoh di atas, permintaan GABUNG adalah beberapa tabel di mana ada satu ketergantungan.  Mengapa  Karena Oracle menentukan ketergantungan tidak hanya dengan parsing, tetapi mengimplementasikannya <strong>sesuai dengan hasil rencana kerja</strong> . <br><br>  Dalam kasus ini, rencana seperti itu dipilih karena hanya satu tabel yang digunakan, dan pada kenyataannya tabel pekerjaan terkait dengan tabel karyawan melalui batasan kunci asing.  Jika kita menghapus batasan kunci asing yang memungkinkan transformasi eliminasi gabungan ini, maka kita akan melihat dua dependensi, karena rencana akan berubah dengan cara ini. <br><br>  <strong>Oracle tidak melacak apa yang tidak perlu dilacak</strong> . <br><br>  Dalam PL / SQL, dependensi berjalan pada saat run-time sehingga Anda dapat menggunakan SQL dinamis dan melakukan hal-hal lain. <br><br><img src="https://habrastorage.org/webt/3j/nh/fk/3jnhfkrft2dgbs-4nyvnwg6nfkm.jpeg"><br><br>  Harap perhatikan bahwa Anda dapat men-cache tidak hanya seluruh permintaan, tetapi <strong>Anda juga dapat men-cache tampilan inline dengan dan dari</strong> .  Misalkan untuk satu hal kita perlu cache, dan yang lain akan lebih baik untuk membaca dari database agar tidak memaksanya.  Kami mengambil tampilan inline, sekali lagi mendeklarasikannya sebagai result_cache dan melihat bahwa hanya satu bagian yang di-cache, dan untuk yang kedua kami mengakses database setiap kali. <br><br><img src="https://habrastorage.org/webt/zq/ze/7z/zqze7zgbnbljnme7a9j8qfbewdo.jpeg"><br><br>  Dan akhirnya, <strong>database juga memiliki enkapsulasi</strong> , meskipun tidak ada yang percaya.  Kami mengambil pandangan, memasukkan result_cache di dalamnya, dan programmer kami bahkan tidak menyadari bahwa itu di-cache.  Di bawah ini kita melihat bahwa sebenarnya hanya satu bagian yang berfungsi. <br><br><img src="https://habrastorage.org/webt/-x/-a/mt/-x-amt3jzaygadispddtfx_fojy.jpeg"><br><br><h3>  Cacat <br></h3><br>  Jadi, mari kita lihat ketika Oracle membatalkan result_cache. Status yang Diterbitkan menunjukkan status validitas cache saat ini.  Ketika permintaan untuk result_cache, seperti yang saya katakan, tidak ada pekerjaan di database <br><br><img src="https://habrastorage.org/webt/uv/9b/at/uv9batcfvtszo6tudxpovnhzy8s.jpeg"><br><br>  Ketika kami melakukan pembaruan, statusnya masih Diterbitkan, karena pembaruan belum dilakukan dan sesi lain akan melihat result_cache yang lama.  Ini adalah konsistensi membaca yang terkenal buruk. <br><br>  Tetapi dalam sesi saat ini kita akan melihat bahwa beban telah hilang, karena pada sesi ini cache diabaikan.  Ini cukup masuk akal, mari kita komit - hasilnya akan menjadi tidak valid, semuanya bekerja dengan sendirinya. <br><br><img src="https://habrastorage.org/webt/-r/sn/rt/-rsnrtdyj9bk6vthaott4qondaq.jpeg"><br><br>  Tampaknya - mimpi!  Ketergantungan dianggap benar - hanya tergantung pada permintaan.  Namun tidak, sejumlah nuansa terungkap.  <strong>Oracle menghasilkan cacat dan dalam sejumlah kasus yang tidak terlihat</strong> : <br><br><ol><li>  Dengan panggilan SELECT FOR UPDATE, dependensi terbang. </li><li>  Jika tabel memiliki kunci asing yang tidak diindeks, dan pembaruan terjadi pada tabel yang ditandai result_cache, yang tidak memengaruhi apa pun, tetapi sesuatu telah berubah di tabel induk, cache juga akan menjadi tidak valid. </li><li>  Ini adalah hal yang paling menarik yang merusak kehidupan sebanyak mungkin - jika ada beberapa pembaruan yang gagal pada tabel yang ditandai sebagai result_cache, tidak ada yang berhasil, tetapi kemudian dalam transaksi yang sama setiap perubahan lain diterapkan yang entah bagaimana memengaruhi tabel pertama, bagaimanapun juga result_cache akan diatur ulang. </li></ol><br>  Masih ada antipattern tentang result_cache, ketika pengembang, setelah mendengar ada hal yang sangat keren, pikirkan: “Oh, ada penyimpanan!  Sekarang kami akan mengambil beberapa permintaan yang berfungsi pada 2-3 partisi - pada tanggal saat ini dan yang sebelumnya, tandai sebagai result_cache, dan itu akan selalu diambil dari memori! " <br><br>  Tetapi ketika Anda mengubah patricia di belakang, seluruh cache terbang, karena sebenarnya unit pelacakan ketergantungan di result_cache selalu berupa tabel, dan saya tidak tahu apakah akan ada partisi atau tidak. <br><br>  Kami berpikir dan memutuskan bahwa kami akan membuat sistem rekomendasi dengan hal-hal berikut: <br><br><ul><li>  <strong>Kami tidak akan melakukan cache semua tabel kami, kami hanya akan mengambil yang diperlukan.</strong> <br></li><li>  <strong>Setel result_cache untuk kueri yang sudah berjalan lama.</strong> <br></li></ul><br>  Kami memeriksa semuanya, melakukan tes kinerja, <strong>waktu pemrosesan - 30 detik</strong> .  Semuanya bagus, pergi ke produksi! <br><br>  Lari - pergi tidur.  Kami tiba di pagi hari.  Kami melihat surat: "Pengakuan membutuhkan setidaknya 20 menit, sesi membeku."  Mengapa mereka membeku?  Bagaimana <strong>30 detik berubah menjadi 20 menit</strong> ? <br><br>  Mereka mulai mengerti, lihat database: <br><br><ul><li>  sesi aktif - 400; </li><li>  pada garis rata-rata dalam dokumen untuk pengakuan - 500; </li><li>  minimum kolom - 5-8; </li><li>  jumlah sesi dalam basis data selalu sama dengan jumlah aplikasi pengguna dikalikan 3!  Dan result_cache tidak suka sering mengaksesnya. </li></ul><br>  Setelah melakukan penyelidikan internal, kami menemukan bahwa pengembang Java membuat pengakuan dalam 3 utas. <br><br>  Kami kesal - beban 5 kali lipat, jatuh, degradasi, dan bahkan dengan parameter seperti itu seharusnya tidak terjadi penurunan muka tanah. <br><br>  Jelas, Anda harus mengerti. <br><br><h3>  Pemantauan <br></h3><br><img src="https://habrastorage.org/webt/b6/iq/iw/b6iqiwwevjqyua9xr6p8j2aq0bu.jpeg"><br><br>  Untuk pemantauan, kami memiliki dua hal utama: <br><br><ol><li>  V $ RESULT_CACHE_OBJECTS - daftar semua objek; </li><li>  V $ RESULT_CACHE_STATISTICS - statistik agregat dari result_cache secara keseluruhan. </li></ol><br>  MEMORY_REPORT adalah variasi pada suatu tema, kami tidak akan membutuhkannya. <br><br>  Oracle ajaib!  Ada dokumentasi yang bagus, tetapi dirancang untuk mereka yang beralih dari database lain sehingga mereka membaca dan berpikir bahwa Oracle sangat keren!  Tetapi <strong>semua informasi pada result_cache hanya terletak pada dukungan</strong> . <br><br><img src="https://habrastorage.org/webt/vm/u1/bt/vmu1bt35lwpsvebw9o-rnxxasgs.jpeg"><br><br>  Ada nuansa yang terdiri dari kenyataan bahwa begitu kita beralih ke objek-objek ini untuk menyelesaikan masalah, kita memperburuknya dengan akhirnya mengubur diri kita sendiri!  Sampai Oracle12.2, sebelum tambalan yang dirilis pada Oktober tahun lalu, permintaan ini membuat result_cache tidak dapat diakses untuk status dan untuk menulis sampai mereka benar-benar dihitung. <br><br><img src="https://habrastorage.org/webt/8b/nd/4y/8bnd4ygeerwxy7n38lqjrqrfwnw.jpeg"><br><br>  Jadi, dengan menggunakan tampilan v $ result_cache_objects, kami menemukan bahwa ada ribuan entri dalam daftar objek yang di-cache - lebih dari yang kami harapkan.  Selain itu, ini adalah objek dari beberapa kueri kami di tabel aneh - tablet kecil, dan kueri last_modified_date.  Jelas, <strong>seseorang menetapkan ETL di pangkalan kami</strong> . <br><br>  Sebelum bersumpah pada pengembang ETL, kami memeriksa bahwa opsi force result_cache diaktifkan untuk tabel ini, dan ingat bahwa kami menyalakannya sendiri, karena beberapa data ini sering diperlukan oleh aplikasi dan caching sesuai. <br><br><img src="https://habrastorage.org/webt/u1/wq/28/u1wq28jkvtylav6ndpx7qql6koo.jpeg"><br><br>  Tetapi ternyata <strong>semua permintaan ini hanya mengambil dan mencuci cache kami</strong> .  Untungnya, pengembang memiliki kesempatan untuk mempengaruhi ETL dalam produksi, jadi kami dapat mengubah result_cache untuk mengecualikan permintaan menit ini. <br><br>  Apakah Anda pikir ini lebih mudah?  - Jangan merasa lebih baik!  Jumlah objek yang di-cache menurun, dan kemudian naik lagi menjadi 12.000. Kami terus mempelajari apa yang di-cache, karena kecepatannya tidak berubah. <br><br><img src="https://habrastorage.org/webt/iy/1o/di/iy1odismaewdpasdhlh_uidjeay.jpeg"><br><br>  Kami melihat - banyak permintaan, dan sangat pintar, tetapi semua tidak bisa dipahami.  Meskipun siapa pun yang telah bekerja dengan Oracle 12 tahu bahwa DS SVC adalah statistik adaptif.  Itu diperlukan untuk meningkatkan kinerja, tetapi ketika ada result_cache, ternyata itu membunuhnya karena persaingan sedang terjadi.  Ini, tentu saja, <strong>hanya</strong> ditulis <strong>sebagai dukungan</strong> . <br><br>  Kami tahu bagaimana beban kerja diatur dan dipahami bahwa dalam kasus kami, statistik adaptif tidak akan secara radikal memperbaiki rencana kami.  Oleh karena itu, kami mematikannya secara heroik - hasilnya, seperti yang tertulis dalam manual rahasia, adalah 10 menit per dokumen.  Tidak buruk, tetapi tidak cukup. <br><br><h3>  Kait <br></h3><br>  <strong>Persaingan antara result_cache dan DS SVC</strong> disebabkan oleh fakta bahwa Oracle memiliki kait - kunci kecil yang ringan. <br><br><img src="https://habrastorage.org/webt/d5/ts/nd/d5tsndbmieve1hguz6yv-qzq2jk.jpeg"><br><br>  Tanpa merinci bagaimana cara kerjanya, kami mencoba untuk memasang kait bernama beberapa kali - tidak berhasil - Oracle mengambil dan tertidur <br><br>  Siapa pun yang berada dalam subjek dapat mengatakan bahwa dalam result_cache, dua kait ditempatkan pada setiap blok dengan mengambil.  Ini adalah detailnya.  Ada dua jenis kait di result_cache: <br><br>  1. Kait untuk periode sementara kami menulis data di result_cache. <br><br><img src="https://habrastorage.org/webt/pv/db/qe/pvdbqeunmn4qjgcybpkxai3thne.jpeg"><br><br>  Artinya, jika permintaan Anda telah bekerja selama 8 detik, untuk periode 8 detik ini, permintaan lain yang sama (kata kunci "sama") tidak akan dapat melakukan apa pun, karena mereka menunggu sampai data ditulis ke result_cache.  Permintaan lain akan dicatat, tetapi permintaan itu hanya akan menunggu kunci di baris pertama.  Berapa banyak mereka harus menunggu tidak diketahui, ini adalah parameter hasil_cache_timeout tidak berdokumen.  Setelah itu, mereka mulai mengabaikan result_cache, seolah-olah, dan bekerja perlahan.  Namun, begitu kunci dari baris terakhir di pintu telah dirilis, mereka secara otomatis mulai bekerja dengan result_cache lagi. <br><br>  2. Jenis kunci kedua - untuk menerima dari result_cache juga dari baris 1 hingga yang terakhir. <br>  Tetapi karena mengambil berasal dari memori instan, mereka dihapus dengan sangat cepat. <br><br><img src="https://habrastorage.org/webt/pl/es/ds/plesds8v7w0qd8vjfrecofbmwno.jpeg"><br><br>  Pastikan untuk diingat bahwa ketika DBA melihat kait di database, itu mulai berkata: "Kait!  Waktu tunggu - semuanya hilang!  »Dan di sini permainan yang paling menarik dimulai: <strong>meyakinkan DBA bahwa waktu tunggu dari kait sebenarnya jauh lebih pendek daripada waktu coba lagi permintaan</strong> . <br><br><img src="https://habrastorage.org/webt/ii/du/sv/iidusv3bzptakrexkjrco7cubsw.jpeg"><br><br>  Seperti yang ditunjukkan oleh pengalaman kami, pengukuran kami, <strong>terkait dengan result_cache menempati 10% dari permintaan itu sendiri</strong> . <br><br><img src="https://habrastorage.org/webt/7-/o8/8a/7-o88agtahp-edtfts_lb2ss6s4.jpeg"><br><br>  Ini adalah statistik gabungan.  Fakta bahwa semuanya buruk dapat dipahami oleh fakta bahwa cache tersumbat.  Konfirmasi lain adalah hasil yang tepat dihapus.  Yaitu, <strong>cache ditimpa</strong> .  Tampaknya kami cerdas dan selalu mempertimbangkan ukuran memori - kami mengambil ukuran garis hasil cache kami untuk rekomendasi kami, dikalikan dengan jumlah garis, dan ada yang salah. <br><br><img src="https://habrastorage.org/webt/mg/lh/5e/mglh5eorzkulnfqoewvrreqpb_u.jpeg"><br><br>  support   2 ,  ,  <strong>  result_cache   </strong> .         . <br><br>   ,    .   , ,   ,  workload   5 .           ,     ,    . <br><br> <strong>   ?</strong> <br><br>  :     .   ,      . <br><br><img src="https://habrastorage.org/webt/2i/qm/_j/2iqm_jbqws8mw7udadiwhkrngao.jpeg"><br><br>    4 : <br><br><ul><li> RESULT_CACHE_MAX_SIZE; <br></li><li> RESULT_CACHE_MAX_RESULT; <br></li><li> RESULT_CACHE_MODE; <br></li><li> _RESULT_CACHE_MAX_TIMEOUT. <br></li></ul><br><img src="https://habrastorage.org/webt/bt/fr/wp/btfrwpqmjmcs6evdykbcvizgte4.jpeg"><br><br>     —  .  ,    100   512,      6 . <br><br>    ,    - . , Invalidation Count = 10000. <br><br>   ,    .     ,   job  ,      . ,   .   job   ,    ,      . <br><br><img src="https://habrastorage.org/webt/2b/m0/dl/2bm0dl2vlmo6bbv16wyksdoora0.jpeg"><br><br>    , invalid     ,    . <strong>         40 </strong> . <br><br>  ,    .     ,     ,     Oracle.  ! <br><br><img src="https://habrastorage.org/webt/wj/dd/jw/wjddjwnlpkmemk8lglmb7rczgb0.jpeg"><br><br> <strong>SHELFLIVE</strong> — ,    read-consistent  ,       10 ,   .        . ,     ,    . <br><br>      — <strong>SNAPSHOT</strong> .  ,       ,     read-consistent    —       . <br><br> <strong></strong> : <br><br><img src="https://habrastorage.org/webt/bj/ts/pd/bjtspdkmsfo2d2xicp_pmxgtqag.jpeg"><br><br><ol><li>  —       SYS. </li><li>      . ,    ,  Oracle    ,     ,        .  , Oracle ,   ,   12.2     . ,  external  -    support,    . </li><li>    sql  pl/sql : current_date, current_time  .   ,     current_time,          . </li><li>    . </li><li>          ,    CLOB, BLOB  . </li></ol><br><h3> Result cache inside Oracle <br></h3><br> Result_cache —   Oracle Core.        , ,    job  result_cache (,    hint,    )  ,    APEX. <br><br><img src="https://habrastorage.org/webt/6n/u3/wf/6nu3wfqtrqzz3n5r_kyfdfwfv8c.jpeg"><br><br> ,    Dynamic sampling    ,   ,      ,   result_cache. <br><br><img src="https://habrastorage.org/webt/qa/gr/al/qagralka35xxjh68wtrfpprgrii.jpeg"><br><br><h2> Oracle internals for result cache <br></h2><br>         result_cache: <br><br><ol><li>        (storage)   ; <br></li><li>         result_cache; <br></li><li> result_cache   shared pool. <br></li></ol><br><img src="https://habrastorage.org/webt/yx/29/pk/yx29pkuz-o_c4dbgk9dbjwbn0lm.jpeg"><br><br> <strong>:</strong> <br><br><ul><li>     . <br></li><li>           read-consistent. </li><li> Result_cache,   ,  . </li></ul><br> <strong>:</strong> <br><br><ul><li>    . <br></li><li>     ,    . <br></li></ul><br><h2>   ! <br></h2><br>      ,    .    support Oracle, ,  29  2017 .:   Oracle E-Business suite    result_cache,      . <br><br><img src="https://habrastorage.org/webt/zh/h3/eu/zhh3eud6fphqdaiuukx1yoklczu.jpeg"><br><br> ,       ,     .          support        ,    ,      . <br><br><img src="https://habrastorage.org/webt/qp/e8/5i/qpe85iwdofjvbxhgtrrihdjmxb4.jpeg"><br><br>             : <br><br><ol><li>  -    ; <br></li><li> , , , ,  v$result_cache_memory  dbms_result_cache.memory_report,       . <br></li></ol><br> ,     ,      ,   v_result_cache_objects  . <br><br><blockquote>   ,  support note —   support ,   . <br></blockquote><br><img src="https://habrastorage.org/webt/me/ut/5o/meut5o7krxdlelwjxgavdxrq-fe.jpeg"><br><br>    ,       ,   :     - .    ,    ,      : <br><br><ol><li>  hint result_cache; </li><li>  hint no result_cache; </li><li>  black_list,  ,   ,   -. </li></ol><br> <strong>    ?</strong> <br><br><ul><li>   ,  - , ,      ; </li><li>     ,    ,   . ,   - ,  ,   . </li></ul><br>   , <strong>     —     </strong> .  Oracle  ,  . <br><br><h3> Client side result cache <br></h3><br><img src="https://habrastorage.org/webt/mk/6s/5m/mk6s5m24srinff6gkhrmxxei7xu.jpeg"><br><br>  Diagram perangkatnya ditunjukkan di atas, ini adalah komponen utama dari database dan driver. <br><br>  Pertama kali sisi klien diakses, Cache Hasil pergi ke database, yang sudah dikonfigurasi sebelumnya, menerima ukuran cache klien dari database dan menginstal cache ini pada klien satu kali pada koneksi pertama.  Query cache pertama-tama mengakses database dan menulis data ke cache.  Utas yang tersisa meminta cache driver bersama, sehingga menghemat memori server dan sumber daya.  Ngomong-ngomong, kadang-kadang tergantung pada beban, driver mengirim statistik tentang penggunaan cache ke database, yang kemudian dapat dilihat. <br><br>  <strong>Pertanyaan yang menarik adalah, bagaimana kecacatan terjadi?</strong> <br><br>  Ada dua mode invalidation, yang dipertajam oleh parameter Invalidation lag.  Ini adalah seberapa banyak Oracle memungkinkan cache driver menjadi tidak konsisten. <br><br>  Mode pertama digunakan ketika permintaan sering pergi dan jeda pembatalan tidak terjadi.  Dalam hal ini, stream akan menuju ke database, memperbarui cache dan membaca data darinya. <br><br><img src="https://habrastorage.org/webt/ah/wo/u1/ahwou1tplbgyiq4w8lizx0raeto.jpeg"><br><br>  Jika kelambatan validasi gagal, maka setiap permintaan yang tidak di-cache, merujuk ke database, di samping hasil kueri, membawa daftar objek yang tidak valid.  Dengan demikian, mereka ditandai sebagai tidak valid dalam cache, dan semuanya berfungsi seperti pada gambar dari skenario pertama. <br><br>  Dalam kasus kedua, jika lebih banyak waktu telah berlalu daripada jeda validasi, maka client result_cache itu sendiri pergi ke database dan berkata: "Beri aku daftar perubahan!"  Artinya, dia sendiri mempertahankan kondisinya yang memadai. <br><br>  <strong>Mengkonfigurasi Cache Hasil sisi klien sangat sederhana</strong> .  Ada 2 opsi: <br><br><ol><li>  CLIENT_RESULT_CACHE_LAG - nilai lag cache; </li><li>  CLIENT_RESULT_CACHE_SIZE - ukuran (minimum 32 Kb, maksimum - 2 GB). </li></ol><br><img src="https://habrastorage.org/webt/ky/zl/mh/kyzlmhtgmgjkodcgtwkjm6sqoym.jpeg"><br><br>  Dari sudut pandang pengembang aplikasi, cache klien tidak jauh berbeda dari cache server, mereka juga memasukkan petunjuk result_cache.  Jika ya, maka itu hanya akan mulai digunakan oleh klien - baik di .Net dan di Jawa. <br><br><img src="https://habrastorage.org/webt/xo/bv/of/xobvof-_m9gwfhdocpw5dywqshe.jpeg"><br><br>  Setelah melakukan 10 iterasi dari kueri, saya mendapatkan yang berikut ini. <br><br><img src="https://habrastorage.org/webt/vq/zs/di/vqzsdifg9jkvb18jnrgy_bu9je4.jpeg"><br><br>  Daya tarik pertama adalah pembuatan, lalu 9 akses cache.  Tabel menunjukkan bahwa memori juga dialokasikan dalam blok.  Juga perhatikan SELECT - ini tidak terlalu intuitif.  Sejujurnya, sebelum saya mulai berurusan dengan ini, saya bahkan tidak tahu bahwa ada representasi seperti <code>GV$SESSION_CONNECT_INFO</code> .  Mengapa Oracle tidak membawanya langsung ke tabel ini (dan ini adalah tabel, bukan tampilan), saya tidak bisa mengerti.  Tapi itu sebabnya saya percaya bahwa fungsi ini tidak terlalu populer, meskipun, menurut saya, ini sangat berguna. <br><br>  <strong>Keuntungan dari caching klien:</strong> <br><br><ul><li>  memori klien murah; </li><li>  driver apa pun yang tersedia - JDBC, .NET, dll. </li><li>  dampak minimal dalam kode aplikasi. </li><li>  Mengurangi beban pada CPU, I / O dan umumnya database; </li><li>  tidak perlu belajar dan menggunakan segala macam lapisan caching pintar dan API; </li><li>  tidak ada kait. </li></ul><br>  <strong>Kekurangan:</strong> <br><br><ul><li>  konsistensi dalam membaca dengan penundaan - pada prinsipnya, sekarang ini adalah tren; </li><li>  membutuhkan klien Oracle OCI; </li><li>  batasan 2 GB per klien, tetapi secara umum 2 GB banyak; </li><li>  Bagi saya pribadi, batasan utama adalah sedikit informasi tentang produksi. </li></ul><br>  Pada dukungan, yang selalu kami gunakan ketika bekerja dengan result_cache, saya hanya menemukan 5 bug.  Ini menunjukkan bahwa, kemungkinan besar, hanya sedikit orang yang membutuhkannya. <br><br>  Jadi, kami menyatukan semua yang dikatakan di atas. <br><br><h3>  <strong>Tembolok buatan tangan</strong> <br></h3><br>  <strong>Skenario buruk:</strong> <br><br><ul><li>  Perubahan instan - jika setelah mengubah data, cache harus segera menjadi tidak relevan.  Untuk singgahan buatan sendiri, sulit untuk membuat pembatalan yang benar jika terjadi perubahan pada objek di mana mereka dibangun. </li><li>  Jika penggunaan logika yang disimpan dalam database dilarang oleh kebijakan pengembangan. </li></ul><br>  <strong>Skenario yang bagus:</strong> <br><br><ul><li>  Ada tim pengembangan basis data yang kuat. </li><li>  Menerapkan logika PL / SQL. </li><li>  Ada batasan yang mencegah teknik caching lainnya digunakan. </li></ul><br><h3>  <strong>Tembolok hasil sisi server</strong> <br></h3><br>  <strong>Skenario buruk:</strong> <br><br><ul><li>  Banyak hasil berbeda yang hanya mencuci seluruh cache; </li><li>  Permintaan membutuhkan waktu lebih lama dari _RESULT_CACHE_TIMEOUT atau parameter ini tidak dikonfigurasi dengan benar. </li><li>  Hasil dari sesi yang sangat besar dimuat ke dalam cache di thread paralel. </li></ul><br>  <strong>Skenario yang bagus:</strong> <br><br><ul><li>  Jumlah hasil cache yang masuk akal. </li><li>  Kumpulan data yang relatif kecil (200–300 baris). </li><li>  SQL yang cukup mahal, jika tidak, semua waktu akan ke latch. </li><li>  Tabel kurang lebih statis. </li><li>  Ada DBA, yang dalam hal sesuatu akan datang dan menyelamatkan semua orang. </li></ul><br><h3>  <strong>Tembolok hasil sisi klien</strong> <br></h3><br>  <strong>Skenario buruk:</strong> <br><br><ul><li>  Ketika masalah kecacatan instan muncul. </li><li>  Dibutuhkan driver yang tipis. <br></li></ul><br>  <strong>Skenario yang bagus:</strong> <br><br><ul><li>  Ada tim pengembangan lapisan tengah normal. </li><li>  Banyak SQL sudah digunakan tanpa menggunakan lapisan caching eksternal yang dapat dengan mudah dihubungkan. </li><li>  Ada batasan pada kelenjar. </li></ul><br><br><h2>  Kesimpulan <br></h2><br>  Saya percaya bahwa cerita saya adalah tentang nyeri cache hasil sisi server, jadi kesimpulannya adalah sebagai berikut: <br><br><ol><li>  Selalu evaluasi ukuran memori dengan benar dengan mempertimbangkan jumlah kueri, dan bukan jumlah hasil, yaitu: blok, APEX, pekerjaan, statistik adaptif, dll. </li><li>  Jangan takut untuk menggunakan opsi pembilasan cache otomatis (snapshot + shelflife). </li><li>  Jangan membebani cache dengan permintaan saat memuat sejumlah besar data; nonaktifkan result_cache sebelum ini.  Lakukan pemanasan cache. </li><li>  Pastikan _result_cache_timeout memenuhi harapan Anda. </li><li>  JANGAN PERNAH menggunakan FORCE untuk seluruh basis data.  Membutuhkan database dalam memori - gunakan solusi khusus dalam memori. </li><li>  Periksa apakah opsi FORCE digunakan secara tepat untuk setiap tabel sehingga tidak berfungsi seperti yang kami lakukan dengan ETL pihak ketiga. </li><li>  Putuskan apakah statistik adaptif sebaik dijelaskan oleh Oracle (_optimizer_ads_use_result_cache = false). </li></ol><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Highload ++ Siberia</a> Senin depan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jadwal</a> siap dan dipublikasikan di situs.  Ada beberapa laporan dalam topik artikel ini: <br><br><ul><li>  <strong>Alexander Makarov</strong> (CFT GC) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan menunjukkan</a> metode untuk mengidentifikasi kemacetan di sisi server perangkat lunak menggunakan database Oracle sebagai contoh. <br></li><li>  <strong>Ivan Sharov</strong> dan <strong>Konstantin Poluektov</strong> akan memberi tahu Anda masalah apa yang muncul saat memigrasi produk ke versi baru dari basis data Oracle, dan juga berjanji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk memberikan rekomendasi</a> tentang pengorganisasian dan melakukan pekerjaan seperti itu. <br></li><li>  <strong>Nikolay Golov</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan memberi tahu Anda</a> cara memastikan integritas data dalam arsitektur layanan mikro tanpa transaksi terdistribusi dan konektivitas yang ketat. <br></li></ul><br>  <strong>Temui aku di Novosibirsk!</strong> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414401/">https://habr.com/ru/post/id414401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414389/index.html">Menganalisis Log Perangkat Cisco Menggunakan Splunk Cisco Security Suite</a></li>
<li><a href="../id414393/index.html">Robot yang Dioperasikan dengan Suara pada tahun 1961</a></li>
<li><a href="../id414395/index.html">Lebih mudah daripada kedengarannya. Fraktur</a></li>
<li><a href="../id414397/index.html">FCS mengusulkan pengurangan ambang batas bebas bea menjadi nol</a></li>
<li><a href="../id414399/index.html">Penggunaan produksi digital dalam bisnis dan pendidikan nyata</a></li>
<li><a href="../id414403/index.html">Fujitsu telah menciptakan teknologi pemodelan molekul baru</a></li>
<li><a href="../id414405/index.html">Instal sertifikat di server HTTP Apache</a></li>
<li><a href="../id414411/index.html">Wiren Board 6: lagi di Habré dengan versi baru controller untuk otomatisasi</a></li>
<li><a href="../id414413/index.html">Sinopsis dan video cerita tentang jaringan di industri game dengan gamedev festival</a></li>
<li><a href="../id414415/index.html">Tarantool Conference 21 Juni - tidak hanya tentang Tarantool, tetapi secara umum tentang komputasi dalam memori</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>