<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêÔ∏è ‚ò£Ô∏è üë©üèª‚Äçüé§ Principales errores de desarrollo al trabajar con PostgreSQL ‚öìÔ∏è ‚ù£Ô∏è üçñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HighLoad ++ ha existido durante mucho tiempo, y hablamos sobre trabajar con PostgreSQL regularmente. Pero los desarrolladores todav√≠a tienen los mismo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principales errores de desarrollo al trabajar con PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/455248/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> ha existido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">durante</a> mucho tiempo, y hablamos sobre trabajar con PostgreSQL regularmente.  Pero los desarrolladores todav√≠a tienen los mismos problemas de mes a mes, de a√±o a a√±o.  Cuando en peque√±as empresas sin un DBA en el estado hay errores al trabajar con bases de datos, esto no es sorprendente.  Las grandes empresas tambi√©n necesitan bases de datos, e incluso con procesos depurados, a√∫n se producen errores y las bases de datos caen.  No importa el tama√±o de la empresa: a√∫n se producen errores, las bases de datos se bloquean peri√≥dicamente. <br><br><img src="https://habrastorage.org/webt/k7/dz/pb/k7dzpbs_rg2wat7ac4awvar2h-e.png"><br><br>  Por supuesto, esto nunca te suceder√°, pero verificar la lista de verificaci√≥n no es dif√≠cil, y puede ser muy decente para salvar los nervios futuros.  Debajo del gato, enumeraremos los principales errores t√≠picos que cometen los desarrolladores al trabajar con PostgreSQL, veremos por qu√© no necesitamos hacer esto y descubriremos c√≥mo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HjLnY0aPQZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Sobre el orador: Alexey Lesovsky</b> comenz√≥ como administrador del sistema Linux.  De las tareas de virtualizaci√≥n y sistemas de monitoreo, poco a poco lleg√≥ a PostgreSQL.  Ahora PostgreSQL DBA en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Data Egret</a> , una empresa de consultor√≠a que trabaja con muchos proyectos diferentes y ve muchos ejemplos de problemas recurrentes.  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> a la presentaci√≥n del informe en HighLoad ++ 2018. <br><a name="habracut"></a><br><h2>  ¬øDe d√≥nde vienen los problemas? </h2><br>  Para calentar, algunas historias sobre c√≥mo ocurren los errores. <br><br><h3>  Historia 1. Caracter√≠sticas </h3><br>  Uno de los problemas es qu√© caracter√≠sticas usa la compa√±√≠a cuando trabaja con PostgreSQL.  Todo comienza simple: PostgreSQL, conjuntos de datos, consultas simples con JOIN.  Tomamos los datos, hacemos SELECCIONAR: todo es simple. <br><br>  Luego comenzamos a usar la funcionalidad adicional de PostgreSQL, agregamos nuevas funciones, extensiones.  La caracter√≠stica se est√° haciendo m√°s grande.  Conectamos replicaci√≥n de transmisi√≥n, fragmentaci√≥n.  Aparecen varias utilidades y kits de cuerpo: pgbouncer, pgpool, patroni.  Algo asi. <br><br><img src="https://habrastorage.org/webt/_i/kr/an/_ikran7pf4ni9e4hyxiwptuhwy4.png"><br><br><blockquote>  Cada palabra clave es una raz√≥n para que aparezca un error. </blockquote><br><h3>  Historia 2. Almacenamiento de datos </h3><br>  La forma en que almacenamos datos tambi√©n es una fuente de errores. <br><br>  Cuando apareci√≥ el proyecto por primera vez, hab√≠a bastantes datos y tablas en √©l.  Las consultas simples son suficientes para recibir y registrar datos.  Pero luego hay m√°s y m√°s mesas.  Los datos se seleccionan de diferentes lugares, aparecen las UNIONES.  Las consultas son complicadas e incluyen construcciones CTE, SUBQUER√çA, listas IN, LATERAL.  Cometer un error y escribir una consulta de curva se vuelve mucho m√°s f√°cil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/37e/620/ff937e6202947bba4393531475868c74.png"><br><br>  Y esto es solo la punta del iceberg: en alg√∫n lado puede haber otras 400 tablas, particiones, de las que tambi√©n se leen ocasionalmente datos. <br><br><h3>  Historia 3. Ciclo de vida </h3><br>  La historia de c√≥mo se sigue el producto.  Los datos siempre deben almacenarse en alg√∫n lugar, por lo que siempre hay una base de datos.  ¬øC√≥mo se desarrolla una base de datos cuando se desarrolla un producto? <br><br>  Por un lado, hay <b>desarrolladores</b> que est√°n ocupados con lenguajes de programaci√≥n.  Escriben sus aplicaciones y desarrollan habilidades en el campo del desarrollo de software, sin prestar atenci√≥n a los servicios.  A menudo no les interesa c√≥mo funcionan Kafka o PostgreSQL: desarrollan nuevas funciones en su aplicaci√≥n y no les importa el resto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/1c3/00a/0561c300abe5623898768ad7d334a334.png"><br><br>  <b>Administradores, por</b> otro lado.  Plantean nuevas instancias de Amazon en Bare-metal y est√°n ocupados con la automatizaci√≥n: configuran implementaciones para que el dise√±o funcione bien y configuran para que los servicios interact√∫en bien entre s√≠. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/3f5/8fb/9613f58fb950f69b235d5b80cc29e1b4.png"><br><br>  Hay una situaci√≥n en la que no hay tiempo o deseo de ajuste fino de componentes, y la base de datos tambi√©n.  Las bases de datos funcionan con configuraciones predeterminadas, y luego se olvidan por completo de ellas: "funciona, no lo toques". <br><br>  Como resultado, los rastrillos se encuentran dispersos en varios lugares, que de vez en cuando vuelan a la frente de los desarrolladores.  En este art√≠culo, intentaremos recopilar todos estos rastrillos en un cobertizo para que los conozca y no los pise cuando trabaje con PostgreSQL. <br><br><h2>  Planificaci√≥n y seguimiento. </h2><br>  Primero, imagine que tenemos un nuevo proyecto: siempre es un desarrollo activo, prueba de hip√≥tesis e implementaci√≥n de nuevas caracter√≠sticas.  En el momento en que la aplicaci√≥n acaba de aparecer y se est√° desarrollando, tiene poco tr√°fico, usuarios y clientes, y todos generan peque√±as cantidades de datos.  La base de datos tiene consultas simples que se procesan r√°pidamente.  No es necesario arrastrar grandes cantidades de datos, no hay problemas. <br><br>  Pero hay m√°s usuarios, llega el tr√°fico: aparecen nuevos datos, las bases de datos crecen y las consultas antiguas dejan de funcionar.  Es necesario completar √≠ndices, reescribir y optimizar consultas.  Hay problemas de rendimiento.  Todo esto genera alertas a las 4 a.m., estr√©s para los administradores y descontento de la administraci√≥n. <br><br><h3>  Que esta mal </h3><br><blockquote>  En mi experiencia, la mayor√≠a de las veces no hay suficientes discos. </blockquote><br>  <b>El primer ejemplo</b> .  Abrimos el cronograma para monitorear la utilizaci√≥n del disco y vemos que el <b>espacio libre en el disco se est√° agotando</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/245/c83/65b245c834e20a94ed7e698b08cfabaf.png"><br><br>  Observamos cu√°nto espacio y qu√© se come; resulta que hay un directorio pg_xlog: <br><br><pre><code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 15G /pgdb/9.6/main/base 58G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Los administradores de bases de datos generalmente saben qu√© es este directorio y no lo tocan, existe y existe.  Pero el desarrollador, especialmente si observa la puesta en escena, se rasca la cabeza y piensa: <br><br>  <i>- Alg√∫n tipo de registros ... ¬°Eliminemos pg_xlog!</i> <br><br>  <b>Elimina el directorio, la base de datos deja de funcionar</b> .  Inmediatamente debe buscar en Google c√≥mo aumentar la base de datos despu√©s de eliminar los registros de transacciones. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/1af/30c/2b81af30c865d529e6f7ff3fd66339ce.png"><br><br>  <b>Segundo ejemplo</b>  Nuevamente, abrimos el monitoreo y vemos que no hay suficiente espacio.  Esta vez el lugar est√° ocupado por alg√∫n tipo de base. <br><br><pre> <code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 70G /pgdb/9.6/main/base 2G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Estamos buscando qu√© base de datos ocupa m√°s espacio, qu√© tablas e √≠ndices. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/ffc/4e9/d88ffc4e98ca1fd4648ac7aea1c8d019.png"><br><br>  Resulta que esta es una tabla con registros hist√≥ricos.  Nunca necesitamos registros hist√≥ricos.  Est√°n escritos por si acaso, y si no fuera por el problema con el lugar, nadie los mirar√≠a hasta la segunda venida: <br><br>  <i>- Vamos a limpiar todo lo que mm ... m√°s viejo que octubre!</i> <br><br>  Haga una solicitud de actualizaci√≥n, ejec√∫tela, funcionar√° y eliminar√° algunas de las l√≠neas. <br><br><pre> <code class="plaintext hljs">=# DELETE FROM history_log -# WHERE created_at &lt; ¬´2018-10-01¬ª; DELETE 165517399 Time: 585478.451 ms</code> </pre> <br>  La consulta se ejecuta durante 10 minutos, pero la tabla todav√≠a ocupa la misma cantidad de espacio. <br><br>  PostgreSQL elimina filas de la tabla: todo es correcto, pero no devuelve el lugar al sistema operativo.  Este comportamiento de PostgreSQL es desconocido para la mayor√≠a de los desarrolladores y puede ser muy sorprendente. <br><br>  <b>El tercer ejemplo</b> .  Por ejemplo, ORM hizo una solicitud interesante.  Por lo general, todos culpan a ORM por hacer consultas "malas" que leen algunas tablas. <br><br>  Supongamos que hay varias operaciones JOIN que leen tablas en paralelo en varios subprocesos.  PostgreSQL puede paralelizar operaciones de datos y puede leer tablas en m√∫ltiples hilos.  Pero, dado que tenemos varios servidores de aplicaciones, esta consulta lee todas las tablas varios miles de veces por segundo.  Resulta que el servidor de la base de datos est√° sobrecargado, los discos no pueden hacer frente y todo esto conduce a un error <b>502 Bad Gateway</b> desde el backend: la base de datos no est√° disponible. <br><br>  Pero eso no es todo.  Puede recordar otras caracter√≠sticas de PostgerSQL. <br><br><ul><li>  <b>Frenos de los procesos en segundo plano de DBMS</b> : PostgreSQL tiene todo tipo de puntos de control, aspiradoras y replicaci√≥n. <br></li><li>  <b>Gastos generales de virtualizaci√≥n</b> .  Cuando la base de datos se ejecuta en una m√°quina virtual, en la misma pieza de hierro tambi√©n hay m√°quinas virtuales a un lado, y pueden entrar en conflicto por los recursos. <br></li><li>  <b>El almacenamiento es del fabricante chino NoName</b> , cuyo rendimiento depende de la luna en Capricornio o la posici√≥n de Saturno, y no hay forma de averiguar por qu√© funciona de esta manera.  La base est√° sufriendo. <br></li><li>  <b>La configuraci√≥n por defecto</b> .  Este es mi tema favorito: el cliente dice que su base de datos se est√° ralentizando, mira, y tiene una configuraci√≥n predeterminada.  El hecho es que la configuraci√≥n predeterminada de PostgreSQL est√° dise√±ada para <b>ejecutarse en la tetera m√°s d√©bil</b> .  La base se inicia, funciona, pero cuando ya funciona en hardware de nivel medio, entonces esta configuraci√≥n no es suficiente, debe ajustarse. <br></li></ul><br><blockquote>  Muy a menudo, PostgreSQL carece de espacio en disco o de rendimiento de disco.  Afortunadamente, con procesadores, memoria y una red, por regla general, todo est√° m√°s o menos en orden. </blockquote><br>  Como ser  ¬°Necesita monitoreo y planificaci√≥n!  Parece obvio, pero por alguna raz√≥n, en la mayor√≠a de los casos, nadie planifica una base, y el monitoreo no cubre todo lo que se necesita monitorear durante la operaci√≥n de PostgreSQL.  Hay un conjunto de reglas claras, con las cuales todo funcionar√° bien, y no "al azar". <br><br><h3>  Planificacion </h3><br>  <b>Hospede la base de datos en un SSD sin dudarlo</b> .  Los SSD se han vuelto confiables, estables y productivos.  Los modelos de SSD empresariales han existido durante a√±os. <br><br>  <b>Planifique siempre un esquema de datos</b> .  No escriba en la base de datos que duda de lo que se necesita, lo que garantiza que no ser√° necesario.  Un ejemplo simple es una tabla ligeramente modificada de uno de nuestros clientes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/56f/9ec/9e156f9ec534a11c5e80180c1c72a987.png"><br><br>  Esta es una tabla de registro en la que hay una columna de datos de tipo json.  Relativamente hablando, puedes escribir cualquier cosa en esta columna.  Del √∫ltimo registro de esta tabla se puede ver que los registros ocupan 8 MB.  PostgreSQL no tiene problemas para almacenar registros de esta longitud.  PostgreSQL tiene muy buen almacenamiento que mastica dichos registros. <br><br>  Pero el problema es que cuando los servidores de aplicaciones leen datos de esta tabla, obstruir√°n f√°cilmente todo el ancho de banda de la red, y otras solicitudes se ver√°n afectadas.  Este es el problema de planificar un esquema de datos. <br><br>  <b>Utilice la partici√≥n para cualquier pista de una historia que deba almacenarse durante m√°s de dos a√±os</b> .  El particionamiento a veces parece complicado: debe molestarse con los desencadenantes, con funciones que crear√°n particiones.  En las nuevas versiones de PostgreSQL, la situaci√≥n es mejor y ahora configurar la partici√≥n es mucho m√°s simple: una vez hecho, funciona. <br><br>  En el ejemplo considerado de eliminaci√≥n de datos en 10 minutos, <code>DELETE</code> se puede reemplazar con <code>DROP TABLE</code> ; tal operaci√≥n en circunstancias similares tomar√° solo unos pocos milisegundos. <br><br>  Cuando los datos se ordenan por partici√≥n, la partici√≥n se elimina literalmente en unos pocos milisegundos y el sistema operativo se hace cargo de inmediato.  Administrar datos hist√≥ricos es m√°s f√°cil, m√°s f√°cil y m√°s seguro. <br><br><h3>  Monitoreo </h3><br>  El monitoreo es un gran tema separado, pero desde el punto de vista de la base de datos hay recomendaciones que pueden encajar en una secci√≥n del art√≠culo. <br><br>  De manera predeterminada, muchos sistemas de monitoreo proporcionan monitoreo de procesadores, memoria, red, espacio en disco, pero, por regla general, <b>no se eliminan los dispositivos de disco</b> .  La informaci√≥n sobre qu√© tan cargados est√°n los discos, qu√© ancho de banda est√° actualmente en los discos y el valor de latencia siempre debe agregarse a la supervisi√≥n.  Esto lo ayudar√° a evaluar r√°pidamente c√≥mo se cargan las unidades. <br><br>  Hay muchas opciones de monitoreo de PostgreSQL, hay para todos los gustos.  Aqu√≠ hay algunos puntos que deben estar presentes. <br><br><ul><li>  <b>Clientes conectados</b> .  Es necesario controlar con qu√© estados trabajan, encontrar r√°pidamente a los clientes "da√±inos" que da√±an la base de datos y apagarlos. </li><li>  <b>Errores</b>  Es necesario monitorear los errores para monitorear qu√© tan bien funciona la base de datos: sin errores, excelente, han aparecido errores, una raz√≥n para mirar los registros y comenzar a comprender qu√© est√° yendo mal. </li><li>  <b>Solicitudes (declaraciones)</b> .  Monitoreamos las caracter√≠sticas cuantitativas y cualitativas de las solicitudes para evaluar aproximadamente si tenemos solicitudes lentas, largas o que requieren muchos recursos. </li></ul><br>  Para obtener m√°s informaci√≥n, consulte el informe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Conceptos b√°sicos de monitoreo de PostgreSQL"</a> con HighLoad ++ Siberia y la p√°gina de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitoreo</a> en el Wiki de PostgreSQL. <br><br>  Cuando planificamos todo y "nos cubrimos" con el monitoreo, a√∫n podemos encontrar algunos problemas. <br><br><h3>  Escalamiento </h3><br>  Por lo general, el desarrollador ve la l√≠nea de la base de datos en la configuraci√≥n.  No est√° particularmente interesado en c√≥mo est√° organizado internamente: c√≥mo funciona el punto de control, la replicaci√≥n y el planificador.  El desarrollador ya tiene algo que hacer: en todo hay muchas cosas interesantes que quiere probar. <br><br><blockquote>  "Dame la direcci√≥n de la base, luego yo mismo".  ¬© Desarrollador an√≥nimo. </blockquote><br>  La ignorancia del tema conlleva consecuencias bastante interesantes cuando el desarrollador comienza a escribir consultas que funcionan en esta base de datos.  Las fantas√≠as al escribir consultas a veces dan efectos sorprendentes. <br><br>  Hay dos tipos de transacciones.  <b>Las transacciones OLTP</b> son r√°pidas, cortas y livianas que toman fracciones de milisegundos.  Funcionan muy r√°pido, y hay muchos de ellos.  <b>OLAP - consultas anal√≠ticas</b> - lentas, largas, pesadas, leen grandes conjuntos de tablas y leen estad√≠sticas. <br><br>  <b>En los</b> √∫ltimos 2-3 a√±os, la abreviatura <b>HTAP a</b> menudo suena: Transacci√≥n h√≠brida / Procesamiento anal√≠tico o Procesamiento <b>h√≠brido transaccional-anal√≠tico</b> .  Si no tiene tiempo para pensar en el escalado y la diversidad de las solicitudes OLAP y OLTP, puede decir: "¬°Tenemos HTAP!"  Pero la experiencia y el dolor de los errores muestran que, despu√©s de todo, los diferentes tipos de solicitudes deben vivir por separado, ya que las solicitudes OLAP largas bloquean las solicitudes OLTP ligeras. <br><br>  Entonces llegamos a la pregunta de c√≥mo escalar PostgreSQL para distribuir la carga, y todos quedaron satisfechos. <br><br>  <b>Streaming de replicaci√≥n</b> .  La opci√≥n m√°s f√°cil es <b>la replicaci√≥n de transmisi√≥n</b> .  Cuando la aplicaci√≥n funciona con la base de datos, conectamos varias r√©plicas a esta base de datos y distribuimos la carga.  La grabaci√≥n todav√≠a va a la base maestra y la lectura a las r√©plicas.  Este m√©todo le permite escalar muy ampliamente. <br><br>  Adem√°s, puede conectar m√°s r√©plicas a r√©plicas individuales y obtener <b>replicaci√≥n en cascada</b> .  Grupos de usuarios o aplicaciones separados que, por ejemplo, leen an√°lisis, se pueden mover a una r√©plica separada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/5b3/2d7/7f45b32d7eeb8dfcd7e19cfb38210134.png"><br><br>  <b>Publicaciones l√≥gicas, suscripciones</b> : el mecanismo de suscripciones y publicaciones l√≥gicas implica la presencia de varios servidores PostgreSQL independientes con bases de datos y conjuntos de tablas independientes.  Estos conjuntos de tablas se pueden conectar a bases de datos vecinas, ser√°n visibles para las aplicaciones que pueden usarlas normalmente.  Es decir, todos los cambios que se producen en el origen se replican en la base de destino y son visibles all√≠.  Funciona muy bien con PostgreSQL 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/4aa/068/13a4aa06893b4ae9f1a1b7523c407b06.png"><br><br>  <b>Tablas for√°neas, Particionamiento declarativo - Particionamiento declarativo y tablas externas</b> .  Puede tomar varios PostgreSQL y crear varios conjuntos de tablas all√≠ que almacenar√°n los rangos de datos deseados.  Estos pueden ser datos de un a√±o espec√≠fico o datos recopilados en cualquier rango. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/929/cb9/109929cb936d0c040651ad30c130258b.png"><br><br>  Usando el mecanismo de tablas externas, puede combinar todas estas bases de datos en forma de una tabla particionada en un PostgreSQL separado.  Es posible que una aplicaci√≥n ya funcione con esta tabla particionada, pero de hecho leer√° datos de particiones remotas.  Cuando los vol√∫menes de datos son m√°s que las capacidades de un servidor, esto es fragmentaci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/446/d13/a39/446d13a394143b988ec04f60e645ea21.png"><br><br>  Todo esto se puede combinar en configuraciones de expansi√≥n, para obtener diferentes topolog√≠as de replicaci√≥n PostgreSQL, pero c√≥mo funciona todo y c√≥mo administrarlo es el tema de un informe separado. <br><br><h3>  Por donde empezar </h3><br>  La opci√≥n m√°s f√°cil es <b>con la replicaci√≥n</b> .  El primer paso es repartir la carga de lectura y escritura.  Es decir, escriba al maestro y lea las r√©plicas.  Entonces escalamos la carga y llevamos a cabo la lectura del asistente.  Adem√°s, no te olvides de los analistas.  Las consultas anal√≠ticas funcionan durante mucho tiempo, necesitan una r√©plica separada con configuraciones separadas para que las consultas anal√≠ticas largas no puedan interferir con el resto. <br><br>  El siguiente paso es <b>equilibrar</b> .  Todav√≠a tenemos la misma l√≠nea en la configuraci√≥n en la que opera el desarrollador.  Necesita un lugar donde escriba y lea.  Hay varias opciones aqu√≠. <br><br>  Lo ideal es implementar el equilibrio <b>a nivel de la aplicaci√≥n</b> , cuando la aplicaci√≥n en s√≠ misma sabe d√≥nde leer los datos y sabe c√≥mo elegir una r√©plica.  Suponga que el saldo de una cuenta siempre se necesita actualizado y debe leerse desde el maestro, y la imagen del producto o la informaci√≥n al respecto se pueden leer con cierto retraso y desde una r√©plica. <br><br><ul><li>  <b>DNS Round Robin</b> , en mi opini√≥n, no es una implementaci√≥n muy conveniente, porque a veces funciona durante mucho tiempo y no proporciona el tiempo necesario al cambiar las funciones de asistente entre servidores en casos de conmutaci√≥n por error. </li><li>  Una opci√≥n m√°s interesante es usar <b>Keepalived y HAProxy</b> .  Las direcciones virtuales para el maestro y el conjunto de r√©plicas se lanzan entre los servidores HAProxy, y HAProxy ya est√° equilibrando el tr√°fico. </li><li>  <b>Patroni, DCS</b> junto con algo como ZooKeeper, etcd, Consul, la opci√≥n m√°s interesante, en mi opini√≥n.  Es decir, el descubrimiento de servicios es responsable de la informaci√≥n sobre qui√©n es el maestro ahora y qui√©n es la r√©plica.  Patroni administra un cl√∫ster de PostgreSQL, realiza la conmutaci√≥n: si la topolog√≠a ha cambiado, esta informaci√≥n aparecer√° en el descubrimiento de servicios y las aplicaciones pueden encontrar r√°pidamente la topolog√≠a actual. </li></ul><br>  Y hay matices con la replicaci√≥n, el m√°s com√∫n de los cuales es el <b>retraso de</b> la <b>replicaci√≥n</b> .  Puede hacerlo como GitLab, y cuando se acumula el retraso, simplemente suelte la base.  Pero tenemos un monitoreo integral: lo miramos y vemos transacciones largas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/9a0/fae/6199a0fae7ed88fb1646e232cc1f2953.png"><br><br><h3>  Aplicaciones y transacciones DBMS </h3><br>  En general, las transacciones lentas e inactivas resultan en: <br><br><ul><li>  <b>disminuci√≥n de la productividad</b> , no a un espasm√≥dico agudo, sino suave; <br></li><li>  <b>bloqueos y puntos muertos</b> , porque las transacciones largas mantienen bloqueos en las filas y evitan que otras transacciones funcionen; <br></li><li>  <b>50 * errores HTTP en el backend</b> , errores de interfaz o en otro lugar. <br></li></ul><br><br>  Veamos una peque√±a teor√≠a sobre c√≥mo surgen estos problemas y por qu√© el mecanismo de transacciones largas e inactivas es perjudicial. <br><br>  PostgreSQL tiene MVCC, relativamente hablando, un motor de base de datos.  Permite a los clientes trabajar de manera competitiva con los datos sin interferir entre s√≠: los lectores no interfieren con los lectores, y los escritores no interfieren con los escritores.  Por supuesto, hay algunas excepciones, pero en este caso no son importantes. <br><br>  Resulta que en la base de datos para una fila puede haber varias versiones para diferentes transacciones.  Los clientes se conectan, la base de datos les proporciona instant√°neas de datos, y dentro de estas instant√°neas pueden existir diferentes versiones de la misma l√≠nea.  En consecuencia, en el ciclo de vida de la base de datos, las transacciones se cambian, se reemplazan entre s√≠ y aparecen versiones de filas que nadie necesita. <br><br>  Por lo tanto, existe la <b>necesidad de un recolector de basura: aspiradora autom√°tica</b> .  Existen transacciones largas y evitan que la aspiradora autom√°tica limpie versiones innecesarias de filas.  Estos datos basura comienzan a vagar de la memoria al disco, del disco a la memoria.  Para almacenar esta basura, se desperdician recursos de CPU y memoria. <br><br><blockquote>  Cuanto m√°s larga sea la transacci√≥n, m√°s basura y menor rendimiento. </blockquote><br>  Desde el punto de vista de "¬øQui√©n tiene la culpa?", La aplicaci√≥n tiene la culpa de la aparici√≥n de largas transacciones.  Si la base de datos existir√° por s√≠ sola, no se tomar√°n transacciones largas de no hacer nada de ninguna parte.  En la pr√°ctica, existen las siguientes opciones para la aparici√≥n de transacciones inactivas. <br><br>  <b>"Vayamos a una fuente externa"</b> .  La aplicaci√≥n abre una transacci√≥n, hace algo en la base de datos, luego decide recurrir a una fuente externa, por ejemplo, Memcached o Redis, con la esperanza de que luego regrese a la base de datos, contin√∫e trabajando y cierre la transacci√≥n.  Pero si se produce un error en la fuente externa, la aplicaci√≥n se bloquea y la transacci√≥n permanece cerrada hasta que alguien lo note y lo mate. <br><br>  <b>Sin manejo de errores</b> .  Por otro lado, puede haber un problema al manejar los errores.  Cuando, nuevamente, la aplicaci√≥n abri√≥ una transacci√≥n, resolvi√≥ un problema en la base de datos, regres√≥ a la ejecuci√≥n del c√≥digo, realiz√≥ algunas funciones y c√°lculos, para continuar trabajando en la transacci√≥n y cerrarla.  Cuando en estos c√°lculos, la operaci√≥n de la aplicaci√≥n se interrumpi√≥ con un error, el c√≥digo regres√≥ al comienzo del ciclo y la transacci√≥n nuevamente permaneci√≥ sin cerrar. <br><br>  <b>El factor humano</b> .  Por ejemplo, un administrador, desarrollador, analista, trabaja en alg√∫n pgAdmin o en DBeaver: abre una transacci√≥n y hace algo en ella.  Luego la persona se distrajo, cambi√≥ a otra tarea, luego a la tercera, se olvid√≥ de la transacci√≥n, se fue para el fin de semana y la transacci√≥n contin√∫a suspendida.  El rendimiento base sufre. <br><br>  Veamos qu√© hacer en estos casos. <br><br><ul><li>  Tenemos monitoreo; en consecuencia, necesitamos <b>alertas en el monitoreo</b> .  Cualquier transacci√≥n que se cuelgue durante m√°s de una hora y no haga nada es una ocasi√≥n para ver de d√≥nde vino y comprender qu√© est√° mal. </li><li>  El siguiente paso es <b>disparar tales transacciones a trav√©s de la tarea en la corona</b> (pg_terminate_backend (pid)) o configurar en la configuraci√≥n de PostgreSQL.  Se necesitan umbrales de 10-30 minutos, despu√©s de lo cual las transacciones se completan autom√°ticamente. </li><li>  <b>Refactorizaci√≥n de aplicaciones</b> .  Por supuesto, debe averiguar de d√≥nde provienen las transacciones inactivas, por qu√© ocurren y eliminar dichos lugares. </li></ul><br><blockquote>  Evite transacciones largas a toda costa, ya que afectan en gran medida el rendimiento de la base de datos. </blockquote><br>  Todo se vuelve a√∫n m√°s interesante cuando aparecen tareas pendientes, por ejemplo, debe calcular cuidadosamente las unidades.  Y llegamos al tema de la construcci√≥n de bicicletas. <br><br><h3>  Construcci√≥n de bicicletas </h3><br>  Tema dolorido.  Las empresas del lado de la aplicaci√≥n deben realizar un procesamiento en segundo plano de los eventos.  Por ejemplo, para calcular los agregados: m√≠nimo, m√°ximo, valor promedio, enviar notificaciones a los usuarios, emitir facturas a los clientes, configurar una cuenta de usuario despu√©s del registro o registrarse en los servicios vecinos, hacer el procesamiento retrasado. <br><br>  La esencia de tales tareas es la misma: se posponen para m√°s adelante.  Las tablas aparecen en la base de datos que solo ejecutan las colas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/bfa/f20/ef4bfaf20634c6d43941c9c8325a09ff.png"><br><br>  Aqu√≠ est√° el identificador de la tarea, el momento en que se cre√≥ la tarea, cuando se actualiz√≥, el controlador que la tom√≥, el n√∫mero de intentos de completar.  Si tiene una tabla que incluso se parece remotamente a esta, entonces tiene <b>colas autoescritas</b> . <br><br>  Todo esto funciona bien hasta que aparecen transacciones largas.  Despu√©s de eso, las <b>tablas que funcionan con colas aumentan de tama√±o</b> .  Se agregan nuevos trabajos todo el tiempo, se eliminan los antiguos, se realizan actualizaciones: se obtiene una tabla con grabaci√≥n intensiva.  Debe limpiarse regularmente de versiones obsoletas de cadenas para que el rendimiento no se vea afectado. <br><br>  <b>El tiempo de procesamiento est√° aumentando</b> : una transacci√≥n larga mantiene bloqueado las versiones obsoletas de las filas o evita que la aspiradora lo limpie.  Cuando la tabla crece en tama√±o, el tiempo de procesamiento tambi√©n aumenta, ya que debe leer muchas p√°ginas con basura.  El tiempo aumenta y la <b>cola en alg√∫n momento deja de funcionar</b> . <br><br>  A continuaci√≥n se muestra un ejemplo de la parte superior de uno de nuestros clientes, que ten√≠a una cola.  Todas las solicitudes solo est√°n relacionadas con la cola. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/203/7ac/3442037ac837daec02ee89a83bd53dd7.png"><br><br>  Preste atenci√≥n al tiempo de ejecuci√≥n de estas solicitudes, todas menos una funcionan por m√°s de veinte segundos. <br><br>  Para resolver estos problemas, <b>Skytools PgQ</b> , un gestor de colas para PostgreSQL, se invent√≥ hace mucho tiempo.  No reinvente su bicicleta: tome PgQ, config√∫relo una vez y olv√≠dese de las l√≠neas. <br><br>  Es cierto, √©l tambi√©n tiene caracter√≠sticas.  Skytools PgQ tiene <b>poca documentaci√≥n</b> .  Despu√©s de leer la p√°gina oficial, uno tiene la sensaci√≥n de que no entendi√≥ nada.  El sentimiento crece cuando intentas hacer algo.  Todo funciona, pero <b>no est√° claro c√≥mo funciona</b> .  Alg√∫n tipo de magia Jedi.  Pero se puede encontrar mucha informaci√≥n en <b>las listas de correo</b> .  Este no es un formato muy conveniente, pero hay muchas cosas interesantes all√≠, y tendr√° que leer estas hojas. <br><br>  A pesar de las desventajas, Skytools PgQ funciona seg√∫n el principio de "configurar y olvidar".   ,    ,     ,    .   PgQ ,        .  PgQ ,      . <br><br><blockquote>    ,   -     ‚Äî  ,   .     . </blockquote><br>              PgQ. ,    PostgreSQL, ,  ,   PgQ  .    ,   . <br><br><h3>  </h3><br>        ,          .   ,    , ,     - ,   , ,      . ,       ,       ,   alter. <br><br>     <b>auto-failover</b> ‚Äî       PostgreSQL  - ,       ,        .      ,    auto-failover. <br><br> <b>Split-brain</b> .    PostgreSQL     ,     ,  ‚Äî  .   ,   .   PostgreSQL     fencing,     Kubernets    .     -    ,         .   Split-brain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/239/97e/32723997e13e8427e4cddc59ea7c964f.png"><br><br>           .  GitHub   Split-brain,       . <br><br> <b>Cascade failover</b> . ,     .  ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/864/d63/ea9864d63b7cebd46ff8b185ddb5d639.png"><br><br>        ,       .    ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81d/243/fc1/81d243fc1500011f0f3c24576f81786a.png"><br><br>         ‚Äî   failover. <br><br>      auto-failover,    . <br><br> <b>Bash </b> ‚Äî  ,      .   ,     ,   .   - ,   ,   .     . <br><br> <b>Ansible playbooks</b> ‚Äî bash-  .    ,   ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>Patroni</b></a> ‚Äî   ,    ,      auto-failover,   ,       service discovery. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>PAF</b></a> ‚Äî <b>  Pacemaker</b> .     auto-failover  PostgreSQL,        Pacemaker. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>Stolon</b></a>     .  Kubernetes, . Stolon  Patroni,        . <br><br><h3>    </h3><br>    Docker  Kubernetes .    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/aba/8c4/b99aba8c4f9c959cd96840bfcd3359b2.png"><br><br>        ,       . <i> ¬´      Kubernetes...¬ª</i>    . <br><br> <b> ‚Äî   stateful</b> ,   - .  Donde      .   Open Source: CEPH, GlusterFS, LinStor DRBD.    ,       , ,     . <br><br>       ‚Äî <b>    </b> . ,      Kubernetes,     CEPH.         ‚Äî    .           ,       . <br><br><ul><li> <b>  </b> ,           . </li><li> <b>     latency</b> .  latency        ‚Äî    . </li><li> <b>   </b> . Kubernetes ,    - . ,    shared storage  Kubernetes,       .  -         . </li></ul><br>     ,    Kubernetes  Docker    staging  dev-     .    ,   , Kubernetes      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/8dd/fd0/b048ddfd0b6212ef2d1eb49eda02386b.png"><br><br>    ,     <b>local volumes ‚Äî  </b>     , <b>streaming replication ‚Äî   </b> ,       <b>PostgreSQL-</b> ,       ‚Äî ,   .       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zalando</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crunchy</a> . <br><br>    ,     .    issues  pull requests.   ,     ,     . <br><br><h2>  Resumen </h2><br> <b>         SSD</b> ‚Äî          ,    . <br><br> <b>     </b> .   JSON  8  ‚Äî  ,   . <br><br> <b> </b> ,        .  PostgreSQL,   . <br><br> <b>  ‚Äî Postgres is ready</b> .          . PostgreSQL   ,        .    : <b>streaming replication; publications, subscriptions; foreign Tables; declarative partitioning</b> . <br><br> <b>    </b> .      ,    . <br><br>    -,      ,   ‚Äî <b>   </b> .    .    ,  Skytools PgQ! <br><br> <b>     Kubernetes,  local volumes, streaming replication  PostgreSQL </b> .     - ,   ,      . <br><br><blockquote>               .     ,   24  25   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad++ Siberia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  ,    ,           .   38    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ‚Äî     ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455248/">https://habr.com/ru/post/455248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455236/index.html">Comodo revoca certificados sin motivo</a></li>
<li><a href="../455240/index.html">Uso de la tasa de defectos rechazados para mejorar el informe de errores</a></li>
<li><a href="../455242/index.html">Menos o√≠dos o c√≥mo no estropear el sonido en el juego desde el principio</a></li>
<li><a href="../455244/index.html">Comic "Soldar es f√°cil" en la versi√≥n actualizada (2019)</a></li>
<li><a href="../455246/index.html">La inscripci√≥n para el D√≠a de la Experiencia del Cliente en San Petersburgo est√° abierta el 20 de junio.</a></li>
<li><a href="../455250/index.html">El que resucit√≥ a Duke Nukem: entrevista con Randy Pitchford, mago de Gearbox</a></li>
<li><a href="../455252/index.html">.NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a - Parte 1</a></li>
<li><a href="../455258/index.html">Comenz√≥ la votaci√≥n de los informes de la secci√≥n Backend en el aniversario DevConfX, que se realizar√° del 21 al 22 de junio en Mosc√∫</a></li>
<li><a href="../455260/index.html">Merkle Tree: oxidado y r√°pido</a></li>
<li><a href="../455264/index.html">S√© como Munch, o unas palabras sobre el deber t√©cnico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>