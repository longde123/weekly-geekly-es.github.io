<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöâ üßïüèΩ ‚§¥Ô∏è Gera√ß√£o de som em microcontroladores AVR usando o m√©todo de tabela de ondas com suporte a polifonia üë©üèæ‚Äç‚úàÔ∏è üöµ üêøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os microcontroladores AVR s√£o bastante baratos e difundidos. Provavelmente, quase qualquer desenvolvedor incorporado come√ßa com eles. E entre os amado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gera√ß√£o de som em microcontroladores AVR usando o m√©todo de tabela de ondas com suporte a polifonia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466121/">  Os microcontroladores AVR s√£o bastante baratos e difundidos.  Provavelmente, quase qualquer desenvolvedor incorporado come√ßa com eles.  E entre os amadores, a bola do Arduino domina, cujo cora√ß√£o geralmente √© o ATmega328p.  Certamente muitos se perguntaram: como voc√™ pode faz√™-los soar? <br><br>  Se voc√™ olhar para os projetos existentes, eles s√£o de v√°rios tipos: <br><br><ol><li>  Geradores de pulso quadrado.  Gere usando pinos PWM ou arrancados em interrup√ß√µes.  Em qualquer caso, √© obtido um som de chiado muito caracter√≠stico. </li><li>  Usando equipamento externo, como um decodificador de MP3. </li><li>  Usando o PWM para emitir som de 8 bits (√†s vezes 16 bits) no formato PCM ou ADPCM.  Como a mem√≥ria nos microcontroladores claramente n√£o √© suficiente para isso, eles geralmente usam um cart√£o SD. </li><li>  Usando o PWM para gerar som com base em tabelas de ondas como MIDI. </li></ol><br>  O √∫ltimo tipo foi especialmente interessante para mim, porque  quase n√£o requer equipamento adicional.  Apresento minha op√ß√£o √† comunidade.  Primeiro, uma pequena demonstra√ß√£o: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Interessado, pe√ßo gato. <br><a name="habracut"></a><br>  Ent√£o, o equipamento: <br><br><ul><li>  ATmega8 ou ATmega328.  Portar para outro ATmega n√£o √© dif√≠cil.  E mesmo no ATtiny, mas mais sobre isso depois; </li><li>  Resistor; </li><li>  Capacitor; </li><li>  Alto-falante ou fone de ouvido; </li><li>  Nutri√ß√£o; </li></ul><br>  Como tudo. <br><br>  Um circuito RC simples com um alto-falante √© conectado √† sa√≠da do microcontrolador.  A sa√≠da √© um som de 8 bits com uma frequ√™ncia de amostragem de 31250Hz.  A uma frequ√™ncia de cristal de 8 MHz, podem ser gerados at√© 5 canais de som + um canal de ru√≠do para percuss√£o.  Nesse caso, quase todo o tempo do processador √© usado, mas ap√≥s o preenchimento do buffer, o processador pode ser ocupado com algo √∫til al√©m do som: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JwqY7FoxYsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este exemplo se encaixa completamente na mem√≥ria do ATmega8, 5 canais + ru√≠do s√£o processados ‚Äã‚Äãa uma frequ√™ncia de cristal de 8 MHz e h√° pouco tempo para anima√ß√£o no visor. <br><br>  Neste exemplo, eu tamb√©m queria mostrar que a biblioteca pode ser usada n√£o apenas como um cart√£o postal musical comum, mas tamb√©m para conectar som a projetos existentes, por exemplo, para notifica√ß√µes.  E mesmo ao usar apenas um canal de som, as notifica√ß√µes podem ser muito mais interessantes do que um simples tweeter. <br><br>  E agora os detalhes ... <br><br><h2>  Tabelas de ondas ou tabelas de ondas </h2><br>  A matem√°tica √© extremamente simples.  H√° uma fun√ß√£o de tom peri√≥dica, por exemplo, <i>tom (t) = sin (t * freq / (2 * Pi))</i> . <br><br>  H√° tamb√©m uma fun√ß√£o para alterar o volume do som fundamental ao longo do tempo, por exemplo, <i>volume (t) = e ^ (- t)</i> . <br><br>  No caso mais simples, o som de um instrumento √© o produto dessas fun√ß√µes <i>instrumento (t) = tom (t) * volume (t)</i> : <br><br>  No gr√°fico, tudo se parece com isso: <br><br><img src="https://habrastorage.org/webt/pn/dp/pi/pndppihozomu4ep_fxzcho44xx8.png"><br><br>  Em seguida, pegamos todos os instrumentos que tocam em um determinado momento e os resumimos com alguns fatores de volume (pseudo-c√≥digo): <br><br><pre><code class="cmake hljs">for (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; CHANNELS; i++) { value += channels[i].tone(t) * channels[i].volume(t) * channels[i].volume; }</code> </pre> <br>  S√≥ √© necess√°rio selecionar o volume para que n√£o haja transbordamento.  E isso √© quase tudo. <br><br>  O canal de ru√≠do funciona da mesma maneira, mas, em vez de uma fun√ß√£o de tom, um gerador de sequ√™ncia pseudo-aleat√≥ria. <br><br>  A percuss√£o √© uma mistura de canal de ru√≠do e onda de baixa frequ√™ncia, em cerca de 50-70 Hz. <br>  Obviamente, √© dif√≠cil obter um som de alta qualidade.  Mas temos apenas 8 kilobytes para tudo.  Espero que isso possa ser perdoado. <br><br><h2>  O que posso espremer de 8 bits </h2><br>  Inicialmente, concentrei-me no ATmega8.  Sem quartzo externo, ele opera a uma frequ√™ncia de 8 MHz e possui um PWM de 8 bits, que fornece uma frequ√™ncia de amostragem b√°sica de 8000000/256 = 31250 Hz.  Um timer usa o PWM para emitir som e causa uma interrup√ß√£o durante o estouro para transmitir o pr√≥ximo valor ao gerador PWM.  Conseq√ºentemente, temos 256 ciclos para calcular o valor da amostra para tudo, incluindo sobrecarga de interrup√ß√£o, atualiza√ß√£o dos par√¢metros do canal de som, rastreamento do tempo em que voc√™ precisa tocar a pr√≥xima nota etc. <br><br>  Para otimiza√ß√£o, usaremos ativamente os seguintes truques: <br><br><ul><li>  Como temos um processador de oito bits, tentaremos tornar as vari√°veis ‚Äã‚Äãiguais.  √Äs vezes, usaremos 16 bits. </li><li>  Os c√°lculos s√£o condicionalmente divididos em frequentes e n√£o s√£o.  Os primeiros precisam ser calculados para cada amostra, o segundo - com muito menos frequ√™ncia, uma vez a cada dezenas / centenas de amostras. </li><li>  Para distribuir uniformemente a carga ao longo do tempo, usamos um buffer circular.  No loop principal do programa, preenchemos o buffer e subtra√≠mos na interrup√ß√£o.  Se tudo estiver bem, o buffer enche mais r√°pido do que esvazia e temos tempo para outra coisa. </li><li>  O c√≥digo √© escrito em C com muita inline.  A pr√°tica mostra que √© muito mais r√°pido. </li><li>  Tudo o que pode ser calculado pelo pr√©-processador, especialmente com a participa√ß√£o da divis√£o, √© feito pelo pr√©-processador. </li></ul><br>  Primeiro, divida o tempo em intervalos de 4 milissegundos (eu os chamei de carrapatos).  A uma frequ√™ncia de amostragem de 31250Hz, obtemos 125 amostras por tick.  O fato de que cada amostra deve ser lida deve ser contado em todas as amostras e o restante - uma vez por tick ou menos.  Por exemplo, dentro de um tick, o volume do instrumento ser√° constante: <i>instrument (t) = tone (t) * currentVolume</i> ;  e o pr√≥prio currentVolume ser√° recalculado uma vez por tick, levando em considera√ß√£o o volume (t) e o volume selecionado do canal de som. <br><br>  Uma dura√ß√£o de escala de 4ms foi escolhida com base em um limite simples de 8 bits: com um contador de amostra de oito bits, voc√™ pode trabalhar com uma frequ√™ncia de amostragem de at√© 64 kHz, com um contador de escala de oito bits, podemos medir o tempo at√© 1 segundo. <br><br><h2>  Algum c√≥digo </h2><br>  O canal em si √© descrito por esta estrutura: <br><br><pre> <code class="cmake hljs">typedef struct { // Info about wave const int8_t* waveForm; // Wave table array uint16_t waveSample; // High byte is an index in waveForm array uint16_t waveStep; // Frequency, how waveSample is changed in time // Info about volume envelope const uint8_t* volumeForm; // Array of volume change in time uint8_t volumeFormLength; // Length of volumeForm uint8_t volumeTicksPerSample; // How many ticks should pass before index of volumeForm is changed uint8_t volumeTicksCounter; // Counter for volumeTicksPerSample // Info about volume uint8_t currentVolume; // Precalculated volume for current tick uint8_t instrumentVolume; // Volume of channel } waveChannel;</code> </pre> <br>  Condicionalmente, os dados aqui s√£o divididos em 3 partes: <br><br><ol><li>  Informa√ß√µes sobre a forma de onda, fase, frequ√™ncia. <br><br>  waveForm: informa√ß√µes sobre a fun√ß√£o tone (t): uma refer√™ncia a uma matriz de 256 bytes.  Define o som, o som do instrumento. <br><br>  waveSample: byte alto indica o √≠ndice atual da matriz waveForm. <br><br>  waveStep: define a frequ√™ncia com que waveSample ser√° aumentado ao contar a pr√≥xima amostra. <br><br>  Cada amostra √© considerada algo como isto: <br><br><pre> <code class="cmake hljs">int8_t tone = channelData.waveForm[channelData.waveSample &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>]; channelData.waveSample += channelaData.waveStep; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tone * channelData.currentVolume;</code> </pre> <br></li><li>  Informa√ß√µes de volume.  Define a fun√ß√£o de alterar o volume ao longo do tempo.  Como o volume n√£o muda com tanta frequ√™ncia, voc√™ pode recont√°-lo com menos frequ√™ncia, uma vez por tick.  Isso √© feito assim: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((channel-&gt;volumeTicksCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; channel-&gt;volumeFormLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { channel-&gt;volumeTicksCounter = channel-&gt;volumeTicksPerSample; channel-&gt;volumeFormLength--; channel-&gt;volumeForm++; } channel-&gt;currentVolume = channel-&gt;volumeForm * channel-&gt;instrumentVolume &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br></li><li>  Define o volume do canal e o volume atual calculado. <br></li></ol><br>  Observe: a forma de onda √© de oito bits, o volume tamb√©m √© de oito bits e o resultado √© de 16 bits.  Com uma pequena perda de desempenho, voc√™ pode fazer o som (quase) em 16 bits. <br><br>  Na luta pela produtividade, tive que recorrer a alguma magia negra. <br><br>  Exemplo n√∫mero 1. Como recalcular o volume de canais: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tickSampleCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //    tickSampleCounter = SAMPLES_PER_TICK ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; //   - } // volume recalculation should no be done so often for all channels <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickSampleCounter &lt; CHANNELS_SIZE) { recalculateVolume(channels[tickSampleCounter]); }</code> </pre> <br>  Assim, todos os canais recontam o volume uma vez por tick, mas n√£o simultaneamente. <br><br>  Exemplo n√∫mero 2. Manter as informa√ß√µes do canal em uma estrutura est√°tica √© mais barato que em uma matriz.  Sem entrar em detalhes da implementa√ß√£o do wavechannel.h, direi que esse arquivo √© inserido no c√≥digo v√°rias vezes (igual ao n√∫mero de canais) com diretivas diferentes de pr√©-processador.  Cada inser√ß√£o cria novas vari√°veis ‚Äã‚Äãglobais e uma nova fun√ß√£o de c√°lculo de canal, que √© incorporada ao c√≥digo principal: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#if CHANNELS_SIZE &gt;= 1 val += channel0NextSample(); #endif #if CHANNELS_SIZE &gt;= 2 val += channel1NextSample(); #endif ‚Ä¶</span></span></code> </pre><br>  Exemplo n√∫mero 3. Se come√ßarmos a tocar a pr√≥xima nota um pouco mais tarde, ningu√©m notar√°.  Vamos imaginar a situa√ß√£o: pegamos o processador com alguma coisa e, durante esse per√≠odo, o buffer estava quase vazio.  Ent√£o come√ßamos a preench√™-lo e de repente acontece que uma nova medida est√° chegando: precisamos atualizar as notas atuais, ler a partir da matriz o que vem a seguir, etc.  Se n√£o tivermos tempo, haver√° gagueira caracter√≠stica.  √â muito melhor preencher um pouco o buffer com dados antigos e s√≥ ent√£o atualizar o estado dos canais. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((samplesToWrite) &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { //          fillBuffer(SAMPLES_PER_TICK); //     -  updateMusicData(); //    }</code> </pre> <br>  De uma maneira boa, seria necess√°rio reabastecer o buffer ap√≥s o loop, mas como temos quase tudo em linha, o tamanho do c√≥digo √© visivelmente inflado. <br><br><h2>  M√∫sica </h2><br>  Um contador de escala de oito bits √© usado.  Quando zero √© atingido, uma nova medida come√ßa, o contador recebe a dura√ß√£o da medida (em ticks), um pouco mais tarde, a matriz de comandos musicais √© verificada. <br><br>  Os dados da m√∫sica s√£o armazenados em uma matriz de bytes.  Est√° escrito algo como isto: <br><br><pre> <code class="cmake hljs">const uint8_t demoSample[] PROGMEM = { DATA_TEMPO(<span class="hljs-number"><span class="hljs-number">160</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> beats per minute DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_PLAY(<span class="hljs-number"><span class="hljs-number">0</span></span>, NOTE_A4, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A4 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_PLAY(<span class="hljs-number"><span class="hljs-number">1</span></span>, NOTE_A3, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A3 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_WAIT(<span class="hljs-number"><span class="hljs-number">63</span></span>), // Wait <span class="hljs-number"><span class="hljs-number">63</span></span> beats DATA_END() // End of data stream };</code> </pre> <br>  Tudo o que come√ßa com DATA_ s√£o macros de pr√©-processador que expandem os par√¢metros no n√∫mero necess√°rio de bytes de dados. <br><br>  Por exemplo, o comando DATA_PLAY √© expandido em 2 bytes, nos quais est√£o armazenados: o marcador de comando (1 bit), a pausa antes do pr√≥ximo comando (3 bits), o n√∫mero do canal no qual reproduzir a nota (4 bits), informa√ß√µes sobre a nota (8 bits).  A limita√ß√£o mais significativa √© que esse comando n√£o pode ser usado por longas pausas, com no m√°ximo 7 medidas.  Se precisar de mais, use o comando DATA_WAIT (at√© 63 medidas).  Infelizmente, n√£o encontrei se a macro pode ser expandida para um n√∫mero diferente de bytes da matriz, dependendo do par√¢metro da macro.  E mesmo aviso eu n√£o sei como exibir.  Talvez voc√™ me diga. <br><br><h2>  Use </h2><br>  No diret√≥rio demos, existem v√°rios exemplos para diferentes microcontroladores.  Mas, resumindo, aqui est√° um artigo do leia-me, n√£o tenho nada a acrescentar: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "../../microsound/devices/atmega8timer1.h" #include "../../microsound/micromusic.h" // Make some settings #define CHANNELS_SIZE 5 #define SAMPLES_SIZE 16 #define USE_NOISE_CHANNEL initMusic(); // Init music data and sound control sei(); // Enable interrupts, silence sound should be generated setSample(0, instrument1); // Use instrument1 as sample 0 setSample(1, instrument2); // Init all other instruments‚Ä¶ playMusic(mySong); // Start playing music at pointer mySong while (!isMusicStopped) { fillMusicBuffer(); // Fill music buffer in loop // Do some other stuff }</span></span></code> </pre> <br>  Se voc√™ quiser fazer outra coisa al√©m da m√∫sica, poder√° aumentar o tamanho do buffer usando BUFFER_SIZE.  O tamanho do buffer deve ser 2 ^ n, mas, infelizmente, com um tamanho de 256, ocorre uma degrada√ß√£o do desempenho.  At√© eu descobrir. <br><br>  Para aumentar a produtividade, voc√™ pode aumentar a frequ√™ncia com quartzo externo, reduzir o n√∫mero de canais, reduzir a frequ√™ncia de amostragem.  Com o √∫ltimo truque, voc√™ pode usar a interpola√ß√£o linear, que compensa um pouco a queda na qualidade do som. <br><br>  Qualquer atraso n√£o √© recomendado, porque  O tempo da CPU √© desperdi√ßado.  Em vez disso, seu pr√≥prio m√©todo √© implementado no <i>arquivo microsound / delay.h</i> , que, al√©m da pr√≥pria pausa, est√° envolvido no preenchimento do buffer.  Esse m√©todo pode n√£o funcionar com precis√£o em pausas curtas, mas em pausas longas mais ou menos saud√°veis. <br><br><h2>  Fazendo sua pr√≥pria m√∫sica </h2><br>  Se voc√™ escrever comandos manualmente, precisar√° ouvir o que acontece.  Despejar cada mudan√ßa no microcontrolador n√£o √© conveniente, especialmente se houver uma alternativa. <br><br>  Existe um servi√ßo bastante engra√ßado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wavepot.com</a> - um editor de JavaScript on-line no qual voc√™ precisa definir a fun√ß√£o do sinal sonoro de tempos em tempos, e esse sinal √© emitido para a placa de som.  O exemplo mais simples: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dsp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.1</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * t * <span class="hljs-number"><span class="hljs-number">440</span></span>); }</code> </pre> <br>  Portamos o mecanismo para JavaScript, ele est√° localizado em <i>demos / wavepot.js</i> .  O conte√∫do do arquivo deve ser inserido no editor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wavepot.com</a> e voc√™ pode realizar experimentos.  N√≥s escrevemos nossos dados no array soundData, ou√ßa, n√£o esque√ßa de salvar. <br><br>  Tamb√©m devemos mencionar a vari√°vel simulate8bits.  Ela, de acordo com o nome, simula um som de oito bits.  Se de repente parece que a bateria est√° zumbindo e o ru√≠do aparece em instrumentos amortecidos com um som silencioso, ent√£o √© isso, uma distor√ß√£o de um som de oito bits.  Voc√™ pode tentar desativar esta op√ß√£o e ouvir a diferen√ßa.  O problema √© muito menos percept√≠vel se n√£o houver sil√™ncio na m√∫sica. <br><br><h2>  Liga√ß√£o </h2><br>  Em uma vers√£o simples, o circuito fica assim: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VC | R1 | Pin+---/\/\--+-----&gt; OUT | | | +---+GN | === C1 | +-------+ | | | --- Grnd --- Grnd</code> </pre> <br>  O pino de sa√≠da depende do microcontrolador.  O resistor R1 e o capacitor C1 devem ser selecionados com base na carga, no amplificador (se houver), etc.  N√£o sou engenheiro eletr√¥nico e n√£o darei f√≥rmulas; elas s√£o f√°ceis de pesquisar no Google junto com calculadoras on-line. <br><br>  Eu tenho R1 = 130 Ohms, C1 = 0,33 uF.  Na sa√≠da, conecto fones de ouvido chineses comuns. <br><br><h2>  O que havia no som de 16 bits? </h2><br>  Como eu disse acima, quando multiplicamos dois n√∫meros de oito bits (frequ√™ncia e volume), obtemos um n√∫mero de 16 bits.  Voc√™ n√£o pode arredondar para oito bits, mas gerar os dois bytes em 2 canais PWM.  Se voc√™ misturar esses 2 canais na propor√ß√£o 1/256, obteremos um som de 16 bits.  A diferen√ßa com o de oito bits √© especialmente f√°cil de ouvir em sons e baterias suavemente desbotados nos momentos em que apenas um instrumento soa. <br><br>  Conex√£o de sa√≠da de 16 bits: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VCC | R1 | PinH+---/\/\--+-----&gt; OUT | | | | | R2 | | PinL+---/\/\--+ +---+GND | | | +-------+ === C1 | | --- Grnd --- Grnd</code> </pre> <br>  √â importante misturar as 2 sa√≠das corretamente: a resist√™ncia R2 deve ser 256 vezes maior que a resist√™ncia R1.  Quanto mais preciso, melhor.  Infelizmente, mesmo resistores com um erro de 1% n√£o fornecem a precis√£o necess√°ria.  No entanto, mesmo com uma sele√ß√£o n√£o muito precisa de resistores, a distor√ß√£o pode ser visivelmente atenuada. <br><br>  Infelizmente, ao usar som de 16 bits, o desempenho diminui e 5 canais + ru√≠do n√£o t√™m mais tempo para processar nos 256 ciclos de clock alocados. <br><br><h2>  √â poss√≠vel no Arduino? </h2><br>  Sim voc√™ pode.  Eu s√≥ tenho um nano clone chin√™s no ATmega328p, ele funciona nele.  Provavelmente, outros arduinos no ATmega328p tamb√©m devem funcionar.  O ATmega168 parece ter os mesmos registros de controle do timer.  Muito provavelmente eles funcionar√£o inalterados.  Em outros microcontroladores que voc√™ precisa verificar, pode ser necess√°rio adicionar um driver. <br><br>  H√° um esbo√ßo em <i>demos / arduino328p</i> , mas para que ele seja aberto normalmente no Arduino IDE, voc√™ precisa copi√°-lo para a raiz do projeto. <br><br>  No exemplo, um som de 16 bits √© gerado e as sa√≠das D9 e D10 s√£o usadas.  Para simplificar, voc√™ pode limitar-se ao som de 8 bits e usar apenas uma sa√≠da D9. <br><br>  Como quase todos os arduins operam em 16 MHz, se desejado, voc√™ pode aumentar o n√∫mero de canais para 8. <br><br><h2>  E o ATtiny? </h2><br>  ATtiny n√£o tem multiplica√ß√£o de hardware.  A multiplica√ß√£o de software que o compilador usa √© muito lenta e √© melhor evitar.  Ao usar pastilhas de montagem otimizadas, o desempenho cai 2 vezes em compara√ß√£o com o ATmega.  Parece que n√£o faz sentido usar ATtiny, mas ... <br><br>  Alguns ATtiny t√™m um multiplicador de frequ√™ncia, PLL.  E isso significa que nesses microcontroladores existem 2 recursos interessantes: <br><br><ol><li>  A frequ√™ncia do gerador PWM √© de 64 MHz, o que fornece um per√≠odo PWM de 250 kHz, que √© muito melhor que 31 250 Hz a 8 MHz ou 62500 Hz com quartzo a 16 MHz em qualquer ATmega. </li><li>  O mesmo multiplicador de frequ√™ncia permite que o cristal fa√ßa clock de 16 MHz sem quartzo. </li></ol><br>  Da√≠ a conclus√£o: algum ATtiny pode ser usado para gerar som.  Eles conseguem processar os mesmos 5 instrumentos + canal de ru√≠do, mas a 16 MHz e n√£o precisam de quartzo externo. <br><br>  A desvantagem √© que a frequ√™ncia n√£o pode mais ser aumentada e os c√°lculos demoram quase o tempo todo.  Para liberar recursos, voc√™ pode reduzir o n√∫mero de canais ou a taxa de amostragem. <br><br>  Outro ponto negativo √© a necessidade de usar dois temporizadores ao mesmo tempo: um para PWM, o segundo para interrup√ß√£o.  √â aqui que os temporizadores geralmente terminam. <br><br>  Dos microcontroladores PLL que conhe√ßo, posso mencionar ATtiny85 / 45/25 (8 pernas), ATtiny861 / 461/261 (20 pernas), ATtiny26 (20 pernas). <br><br>  Quanto √† mem√≥ria, a diferen√ßa com o ATmega n√£o √© grande.  Em 8kb, v√°rios instrumentos e melodias se encaixam perfeitamente.  Em 4kb, voc√™ pode colocar 1-2 instrumentos e 1-2 m√∫sicas.  √â dif√≠cil colocar algo em 2 kilobytes, mas se voc√™ realmente quiser, pode.  √â necess√°rio separar os m√©todos, desativar algumas fun√ß√µes, como controle de volume sobre os canais, reduzir a frequ√™ncia de amostragem e o n√∫mero de canais.  Em geral, para um amador, mas h√° um exemplo de trabalho no ATtiny26. <br><br><h2>  Os problemas </h2><br>  H√° problemas  E o maior problema √© a velocidade da computa√ß√£o.  O c√≥digo √© completamente escrito em C com pequenas inser√ß√µes de multiplica√ß√£o de assembler para ATtiny.  A otimiza√ß√£o √© dada ao compilador e √†s vezes se comporta de maneira estranha.  Com pequenas altera√ß√µes que parecem n√£o influenciar nada, voc√™ pode obter uma diminui√ß√£o percept√≠vel no desempenho.  Al√©m disso, mudar de -Os para -O3 nem sempre ajuda.  Um exemplo √© o uso de um buffer de 256 bytes.  Particularmente desagrad√°vel √© que n√£o h√° garantia de que em novas vers√µes do compilador n√£o obteremos uma queda no desempenho no mesmo c√≥digo. <br><br>  Outro problema √© que o mecanismo de atenua√ß√£o antes da pr√≥xima nota n√£o √© implementado.  I.e.  quando em um canal uma nota √© substitu√≠da por outra, o som antigo √© interrompido abruptamente, √†s vezes um pequeno clique √© ouvido.  Eu gostaria de encontrar uma maneira de me livrar disso sem perder o desempenho, mas at√© agora. <br><br>  N√£o h√° comandos para aumentar / diminuir suavemente o volume.  √â especialmente cr√≠tico para toques curtos de notifica√ß√£o, onde, no final, voc√™ precisa fazer uma atenua√ß√£o r√°pida do volume, para que n√£o haja interrup√ß√£o acentuada no som.  Parte do problema √© escrever uma s√©rie de comandos com a configura√ß√£o manual do volume e uma breve pausa. <br><br>  A abordagem escolhida, em princ√≠pio, n√£o √© capaz de fornecer um som naturalista para os instrumentos.  Para um som mais natural, voc√™ precisa dividir os sons dos instrumentos em libera√ß√£o de ataque-sustenta√ß√£o, usar pelo menos as 2 primeiras partes e com uma dura√ß√£o muito mais longa que um per√≠odo de oscila√ß√£o.  Mas os dados da ferramenta precisar√£o de muito mais.  Havia uma id√©ia de usar tabelas de ondas mais curtas, por exemplo, em 32 bytes em vez de 256, mas sem interpola√ß√£o, a qualidade do som diminui drasticamente e, com a interpola√ß√£o, o desempenho diminui.  E outros 8 bits de amostragem claramente n√£o s√£o suficientes para m√∫sica, mas isso pode ser contornado. <br><br>  O tamanho do buffer √© limitado a 256 amostras.  Isso corresponde a aproximadamente 8 milissegundos e √© o per√≠odo m√°ximo de tempo integral que pode ser concedido a outras tarefas.  Ao mesmo tempo, a execu√ß√£o das tarefas ainda √© suspensa periodicamente por interrup√ß√µes. <br><br>  A substitui√ß√£o do atraso padr√£o n√£o funciona com muita precis√£o em pequenas pausas. <br><br>  Estou certo de que esta n√£o √© uma lista completa. <br><br><h2>  Refer√™ncias </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√°lculo do filtro PWM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algumas id√©ias e uma m√∫sica demo foram tiradas daqui</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466121/">https://habr.com/ru/post/pt466121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466105/index.html">API de Magento Rest com Overclocking com RoadRunner</a></li>
<li><a href="../pt466107/index.html">Sistema Smart Home fa√ßa voc√™ mesmo</a></li>
<li><a href="../pt466109/index.html">Solu√ß√£o de problemas com pwnable.kr 22 - brainfuck. Ataque Ret2libc</a></li>
<li><a href="../pt466111/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 32. Recupera√ß√£o de senha, XMODEM / TFTPDNLD e ativa√ß√£o de licen√ßa da Cisco</a></li>
<li><a href="../pt466113/index.html">Definindo codifica√ß√£o de texto no PHP em vez de mb_detect_encoding</a></li>
<li><a href="../pt466123/index.html">Crescimento. Peso. Tr√™s vizinhos</a></li>
<li><a href="../pt466127/index.html">Kola NPP ou em p√© no reator</a></li>
<li><a href="../pt466129/index.html">Efici√™ncia do transporte em gasolina, baterias e hidrog√™nio</a></li>
<li><a href="../pt466135/index.html">Megapack: como os desenvolvedores do Factorio conseguiram resolver o problema com o multiplayer de 200 jogadores</a></li>
<li><a href="../pt466137/index.html">System.IO. Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>