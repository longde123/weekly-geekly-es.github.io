<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏻 👩🏿‍💻 👌🏾 Balada de transferência de dados 🖲️ 🏌️ 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nas primeiras linhas da minha hemorragia de texto, quero dizer o seguinte: Já foi escrito muito sobre isso, também vou escrever minha visão. As interf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Balada de transferência de dados</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/398791/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nas primeiras linhas da minha hemorragia de texto, quero dizer o seguinte: Já foi escrito muito sobre isso, também vou escrever minha visão. </font><font style="vertical-align: inherit;">As interfaces padrão para transmissão de informações são ótimas, mas, para minhas necessidades, elas não fornecem transferência de dados satisfatória (boa ou quase) suficiente. </font><font style="vertical-align: inherit;">Vou tentar fazer algumas adições para levar isso ao estado que me convém.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem 2 ou mais dispositivos a uma distância suficientemente grande (1-100 metros) entre os quais os dados devem ser transmitidos. Tendo examinado algumas interfaces (rs232 / 422/485, I2C, Ethernet), cheguei à conclusão de que elas não garantem uma transferência inequívoca de dados, também não gostei de muitos fios, e não respondem que a informação é aceita. Decidi tomar a interface RS485 como base - ela pode ir muito longe de suas vantagens, 2 fios, você pode conectar vários dispositivos ao mesmo tempo, é simples, (UART) está em quase qualquer controlador.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 No meu caso, o esquema clássico 1 que lidera o resto dos escravos é adequado para mim. O algoritmo do sistema de mensagens é o seguinte: os dados são transmitidos em ciclos de troca, um ciclo de troca consiste em uma mensagem que é transmitida do mestre para o escravo, em resposta o mestre recebe a mensagem do escravo, todos os outros ficam em silêncio. Na mesma base, implemente uma solicitação de dados de um dispositivo escravo. </font></font><br>
<br>
<img src="https://habrastorage.org/files/e4e/48e/048/e4e48e048a5e4cd08723865418a0e25a.png" alt="imagem"><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ciclo de troca.</font></font></em><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Para atender às minhas necessidades de transferência de dados, preciso resolver apenas duas perguntas. Pergunta 1: a verificação do byte transmitido é baseada na própria interface RS-485, mas não garante um byte transmitido de forma confiável - se um byte for encontrado na própria interface, ele será jogado fora dos dados recebidos, mas ainda é possível transferir o byte errado - se ele mudou (ficou ruim) ) um número par de bits em um byte. isto é é necessária uma verificação do número de bytes transmitidos e da validade dos bytes nos dados transmitidos. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Pergunta dois: recebendo uma mensagem de resposta para a transmitida. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Na primeira pergunta: esse esquema é proposto: o byte inicial, o byte do número de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 caracteres transmitidos em toda a mensagem, outra coisa, o byte de soma de verificação (BCS), o byte final.</font></font><br>
 <br>
<img src="https://habrastorage.org/files/a00/e71/e60/a00e71e60f3a40d1affd859b411afe89.png" alt="imagem"><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: o byte da soma de verificação deve ser considerado o módulo 2.</font></font></em><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Com base no esquema proposto, pode-se julgar que, se a resposta não retornar, o seguidor não estará disponível. Nesse caso, são possíveis opções quando uma mensagem danificada chega ao seguidor e ele não responde, ou a mensagem chega até ele e ele envia a resposta, mas a resposta fica ruim e o líder a ignora.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para corrigir isso, foi aceito: se a resposta não vier (ou vier, mas não for confiável), repita (o número de vezes sem insanidade) repita o atual ciclo de troca. O seguinte erro pode ocorrer aqui. Suponha que enviemos um comando informando ao dispositivo que você precisa aumentar o volume em +1 unidade. Quando a mensagem chega ao escravo, ele executa o comando para aumentar o volume e envia a resposta "ok, eu fiz como você queria", mas pode acontecer que a resposta fique ruim e o apresentador não entenda que o comando já foi executado e envie a mensagem novamente. Como resultado, ao receber um comando no lado escravo, o volume já será adicionado por +2 unidades. Para evitar esse fenômeno, é habitual introduzir um identificador (NS - número da mensagem) da diferença de mensagem. Se o número da mensagem for repetido, será uma mensagem repetida e o comando especificado não precisará ser executado,mas basta enviar a mensagem de resposta anterior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também digito aqui mais 2 parâmetros - este é o número (código) do dispositivo para o qual os dados são transmitidos e o número (subcódigo) indicando qual comando deve ser executado (ou quais dados estão dentro da mensagem). </font></font><br>
 <br>
<img src="https://habrastorage.org/files/2ca/3d8/226/2ca3d82263eb48e6a0b566ba824c917a.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, reunirei tudo e analisarei o algoritmo, usando o exemplo de aumento do limiar do relé por temperatura em 5 graus Celsius e obtendo a leitura de temperatura atual do escravo por 1 ciclo de troca: eu </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
giro os dados transmitidos do mestre: </font></font><br>
<br>
<img src="https://habrastorage.org/files/c7a/172/c23/c7a172c23c3d4a9886481ce1c052304a.PNG" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
quando a mensagem é recebida, o escravo olha para 2 bytes, onde é o número de bytes enviados, se o número de bytes enviados for igual ao número de recebidos, a mensagem não perdeu bytes; então, veremos o byte inicial (caractere) se for = '$' e também o byte final (caractere) se for = ' # '- esta é uma mensagem de viajar para o escravo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imediatamente considerarei as possíveis opções de mensagem do mestre para o escravo com erros nos bytes inicial e final, bem como a opção com um erro no número de bytes na mensagem. </font><font style="vertical-align: inherit;">Farei uma reserva imediatamente a partir de 3 valores de parâmetros que considerarei corretos 2 e 3, ou seja, </font><font style="vertical-align: inherit;">se 2 parâmetros de 3 possíveis coincidem, considero a mensagem válida.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. start byte = '$', número de bytes recebidos = 7 (número de bytes enviados = 7), o byte final não é igual a '#'; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 2. o byte inicial não é igual a '$', o número de bytes recebidos = 7 (o número de bytes enviados = 7), o byte final = '#'; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 3. start byte = '$', número de bytes recebidos = 7 (número de bytes enviados = 7, número de bytes não é 7), byte final = '#'.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, calculamos a soma de verificação dos 3 bytes restantes (bytes 3, 4, 5); se coincide com o BCS, continuamos analisando os dados, analisamos esses dados para este dispositivo e o que deve ser feito nele; no nosso caso, o código escravo é 55 e o subcódigo 2 diz sobre a necessidade de adicionar mais 5 graus ao limite do relé e na mensagem de resposta para enviar os dados de temperatura atuais. Verifico o NS se não é igual ao número da mensagem anterior e, em seguida, executo o comando e adiciono 5 graus ao valor atual do limite do relé. Se eles são iguais (NS), então eu não executo as ações indicadas, então prossigo para a formação de uma mensagem de resposta.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aplicação do esquema ['$'] [número de bytes enviados / recebidos] [...] ['#'] - com alta probabilidade garante que essa combinação não poderá ser encontrada nos dados transmitidos e provoca uma mensagem falsa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formo os dados transmitidos do escravo com base na mensagem recebida:</font></font><br>
<br>
<img src="https://habrastorage.org/files/f0e/f6a/e05/f0ef6ae05be5437daf087ce6681ea795.PNG" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O princípio do processamento é o seguinte: observe 2 bytes em que o número de bytes enviados é, se o número de bytes enviados for igual ao número de bytes recebidos e também o byte inicial = '@' e o byte final = '&amp;' - esta é uma mensagem do escravo para o mestre. Se necessário, eu uso o mecanismo 2 de 3, semelhante ao descrito acima apenas para a mensagem de resposta (para os caracteres '@' e '&amp;'). Ao receber esta mensagem, o host analisa a soma de verificação 9 (do 3º ao 11º) bytes, se a soma de verificação corresponder, os dados na mensagem serão considerados confiáveis ​​e uma análise de dados adicional continuará. Se o código, o subcódigo e o NS das mensagens enviadas e recebidas coincidirem, continuaremos analisando a resposta à mensagem enviada pelo host. A seguir, é apresentada a análise dos dados recebidos,no meu caso, no sexto byte, um valor de 1 significa que o comando para aumentar 5 graus até o limiar do relé foi bem-sucedido, os 5 bytes restantes indicam as leituras de temperatura atuais; o 7 byte é um sinalizador que indica a confiabilidade da temperatura transmitida (ou seja, Estou considerando a opção em que o escravo está ligado e respondendo, mas o sensor pode não funcionar) e 4 bytes do tipo valores de temperatura de flutuação.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O uso de 2 caracteres de teste no início e no final de uma mensagem com alta probabilidade garante que, em caso de erro, não confunda mensagens do escravo e do mestre. Também dados aleatórios (não aleatórios) no canal não estragam a troca. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Um pouco sobre a transmissão de dados do escravo para o escravo e uma mensagem centralizada para todos os escravos do mestre.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Primeiro, o último - a transmissão do mestre pelo escravo é realizada atribuindo o código do dispositivo 255, que informa ao escravo que esta é uma mensagem centralizada, resta apenas resolver o problema dos subcódigos comuns, podendo também ser agrupados por códigos de dispositivo atribuir código de dispositivo 254 e 3 ou 4 dispositivos receberão uma mensagem usando esse código; o restante ignorará, naturalmente, a parte do envio de respostas de escravos não deve funcionar aqui, ou seja, não é garantido que os seguidores aceitem sem ambiguidade essas mensagens!</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Na transmissão de dados do escravo para o escravo, implementada pelo mestre envia uma mensagem ao escravo (escravo1) a partir da qual as informações devem ser enviadas para o outro escravo (escravo2), o escravo1 envia uma resposta ao mestre enquanto o escravo2 ouve essa resposta, levando os dados para si. Novamente, não há garantia de uma entrega inequívoca de mensagem do slave1 para o slave2; isso deve ser levado em consideração! </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Número de recursos de interface de dispositivos conectados teoricamente cerca de 250, tipos de comandos / dados até 248 para cada dispositivo, o comprimento da informação útil na mensagem é de até 250 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fale sobre as armadilhas:</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Toda a transferência de dados foi projetada para funcionar a tempo, ou seja, certos atrasos entre as mensagens devem ser observados. Eu também recomendo que você faça um atraso fixo entre a mensagem enviada pelo mestre e a resposta do escravo, para que o escravo possa gerar dados e transmiti-los completamente ao canal. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 O momento de organizar as respostas do escravo também é importante; pode acontecer que o escravo esteja ocupado e tenha várias mensagens de dados em seu canal ao mesmo tempo; evite respostas a mensagens desatualizadas (porque o líder não espera mais por elas) ignorando-as, executando comandos apenas das últimas mensagens e dê uma resposta.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Separadamente, eu gostaria de destacar a questão da sincronização de dispositivos por tempo - deve-se ter em mente que a sincronização de tempo do escravo ao receber uma mensagem exige levar em consideração o atraso no envio de dados ao canal (a uma velocidade de 9600, uma mensagem de 10 bytes será transmitida por cerca de 11 ms) e o momento em que a interrupção é acionada no final recebendo dados no lado escravo, se não houver interrupção, vale a pena considerar o tempo de verificar a chegada de dados no buffer do dispositivo, etc. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Também é importante notar que o reenvio de um loop de mensagens também adiciona nuances, eu recomendo o envio de mensagens sem repetições para sincronização de tempo e a composição de mensagens com um novo NS. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenho dúvidas de que descobri algo novo aqui, tudo isso até certo ponto é usado em algum lugar em diferentes interfaces! </font><font style="vertical-align: inherit;">Com a mão leve do autor deste rabisco e a aplicação deste protocolo em meus desenvolvimentos, quero dar o nome a esse protocolo de transferência de dados “SRDB2”.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt398791/">https://habr.com/ru/post/pt398791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt398781/index.html">Depuração sem fio STM32</a></li>
<li><a href="../pt398783/index.html">Pacote de serviços de segurança de rede e utilitário oidcalc</a></li>
<li><a href="../pt398785/index.html">No fundo do Golfo do México encontrou um lago venenoso</a></li>
<li><a href="../pt398787/index.html">Em um subúrbio de Moscou, usando uma impressora 3D em 20 horas para construir uma casa</a></li>
<li><a href="../pt398789/index.html">A rede neural prevê a primeira impressão de uma pessoa pelo seu rosto</a></li>
<li><a href="../pt398793/index.html">Uma caneta para um computador ou um computador para uma caneta?</a></li>
<li><a href="../pt398795/index.html">Soluções educacionais LEGO Education. O que seus filhos podem crescer</a></li>
<li><a href="../pt398797/index.html">A EA Games and Origin proibiu um país inteiro devido a sanções dos EUA</a></li>
<li><a href="../pt398801/index.html">Mundo dos traços eternos</a></li>
<li><a href="../pt398803/index.html">11.11: berço para vendas instantâneas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>