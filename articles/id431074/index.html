<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦊 😦 👩🏾‍🚒 Panduan JavaScript Bagian 8: Tinjauan Umum Fitur ES6 👩‍❤️‍👩 ✂️ 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, di bagian kedelapan dari terjemahan manual JavaScript, kami akan meninjau fitur bahasa yang muncul di dalamnya setelah rilis standar ES6. De...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan JavaScript Bagian 8: Tinjauan Umum Fitur ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Hari ini, di bagian kedelapan dari terjemahan manual JavaScript, kami akan meninjau fitur bahasa yang muncul di dalamnya setelah rilis standar ES6.  Dengan satu atau lain cara, kita telah menemukan banyak peluang ini sebelumnya, di suatu tempat memikirkannya secara lebih rinci, suatu tempat menerima begitu saja.  Bagian panduan ini dimaksudkan, bersama dengan pengungkapan beberapa topik yang belum pernah kami sentuh sebelumnya, untuk merampingkan pengetahuan pengembang pemula di bidang JavaScript modern. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: program pertama, fitur bahasa, standar</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: gaya kode dan struktur program</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: variabel, tipe data, ekspresi, objek</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: fungsi</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5: array dan loop</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 6: pengecualian, titik koma, literal wildcard</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 7: mode ketat, kata kunci ini, acara, modul, perhitungan matematis</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8: Gambaran Umum Fitur ES6</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 9: Gambaran Umum Standar ES7, ES8, dan ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tentang ES6</font> </h2><br>  Standar ES6, yang akan lebih tepat untuk memanggil ES2015 atau ECMAScript 2015 (ini adalah nama resminya, meskipun semua orang menyebutnya ES6), muncul 4 tahun setelah rilis standar sebelumnya - ES5.1.  Butuh sekitar sepuluh tahun untuk mengembangkan semua yang masuk ke standar ES5.1.  Saat ini, segala sesuatu yang muncul dalam standar ini telah menjadi alat biasa dari pengembang JS.  Perlu dicatat bahwa ES6 membuat perubahan besar pada bahasa (dengan tetap mempertahankan kompatibilitas dengan versi sebelumnya).  Untuk menghargai besarnya perubahan ini, dapat dicatat bahwa ukuran dokumen yang menggambarkan standar ES5 adalah sekitar 250 halaman, dan standar ES6 dijelaskan dalam dokumen yang sudah memiliki sekitar 600 halaman. <br><br>  Daftar inovasi paling penting dari standar ES2015 dapat mencakup yang berikut: <br><br><ul><li>  Fungsi panah </li><li>  Janji </li><li>  Generator </li><li> Kata kunci <code>let</code> dan <code>const</code> </li><li>  Kelas </li><li>  Modul </li><li>  Template Literal Support </li><li>  Dukungan untuk parameter fungsi default </li><li>  Operator yang tersebar </li><li>  Tugas Merusak </li><li>  Meningkatkan Literal Obyek </li><li>  <code>for...of</code> loop </li><li>  Dukungan untuk <code>Map</code> dan <code>Set</code> struktur data </li></ul><br>  Pertimbangkan kemungkinan ini. <br><br><h2>  <font color="#3AC1EF">Fungsi panah</font> </h2><br>  Fungsi panah telah mengubah tampilan dan nuansa kode JavaScript.  Dalam hal tampilan, penggunaannya membuat deklarasi fungsi lebih pendek dan lebih mudah.  Berikut adalah deklarasi fungsi reguler. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Tetapi fungsi panah yang hampir sama (walaupun tidak sepenuhnya mirip dengan yang di atas). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Jika tubuh fungsi panah hanya terdiri dari satu baris, yang hasilnya harus dikembalikan dari fungsi ini, maka itu ditulis lebih pendek. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Jika fungsi panah hanya mengambil satu parameter, Anda dapat menuliskannya sebagai berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Perlu dicatat bahwa dengan munculnya fungsi panah, fungsi biasa belum hilang, mereka masih dapat digunakan dalam kode, mereka bekerja dengan cara yang sama seperti sebelumnya. <br><br><h2>  <font color="#3AC1EF">Fitur Kata Kunci Ini dalam Fungsi Panah</font> </h2><br>  Fungsi panah tidak memiliki nilai <code>this</code> sendiri, mereka mewarisinya dari konteks eksekusi. <br><br>  Ini memperbaiki masalah, yang, ketika menggunakan fungsi biasa, perlu menggunakan konstruksi seperti <code>var that = this</code> untuk mempertahankan konteks.  Namun, seperti yang ditunjukkan pada bagian sebelumnya dari panduan ini, perubahan ini sangat memengaruhi fitur bekerja dengan fungsi panah dan cakupan aplikasi mereka. <br><br><h2>  <font color="#3AC1EF">Janji</font> </h2><br>  Janji memungkinkan Anda untuk menyingkirkan masalah terkenal yang disebut "panggilan balik neraka", meskipun penggunaannya menyiratkan penggunaan struktur yang agak rumit.  Masalah ini diselesaikan dalam standar ES2017 dengan munculnya <code>async/await</code> konstruksi, yang didasarkan pada janji. <br><br>  Pengembang JavaScript menggunakan janji sebelum standar ES2015, menggunakan berbagai pustaka untuk ini (misalnya - jQuery, q, deferred.js, sumpah).  Ini menunjukkan pentingnya dan relevansi mekanisme ini.  Perpustakaan yang berbeda menerapkannya dengan cara yang berbeda, munculnya standar di bidang ini dapat dianggap sebagai fakta yang sangat positif. <br>  Berikut adalah kode yang ditulis menggunakan fungsi callback (panggilan balik). <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Menggunakan janji, ini dapat ditulis ulang sebagai berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Generator</font> </h2><br>  Generator adalah fungsi khusus yang dapat menjeda eksekusi mereka sendiri dan melanjutkannya.  Ini memungkinkan kode lain dijalankan ketika generator dalam keadaan idle. <br><br>  Generator memutuskan sendiri bahwa ia perlu menjeda dan mengizinkan kode lain, "menunggu" untuk gilirannya, untuk dieksekusi.  Pada saat yang sama, generator memiliki kesempatan untuk melanjutkan eksekusi setelah operasi, yang hasilnya menunggu, selesai. <br><br>  Semua ini dilakukan berkat satu <code>yield</code> kata kunci sederhana.  Ketika kata kunci ini ditemukan di generator, eksekusinya dijeda. <br>  Generator dapat berisi banyak baris dengan kata kunci ini, menjeda eksekusi sendiri beberapa kali.  Generator dideklarasikan dengan menggunakan <code>*function</code> .  Tanda bintang ini sebelum <code>function</code> kata tidak boleh diambil untuk sesuatu seperti operator penunjuk titik yang digunakan dalam bahasa seperti C, C ++ atau Go. <br><br>  Generator menandai munculnya paradigma pemrograman JavaScript baru.  Secara khusus, mereka memungkinkan pertukaran data dua arah antara generator dan kode lainnya, dan memungkinkan pembuatan loop <code>while</code> yang tidak akan "menggantung" program. <br><br>  Pertimbangkan contoh yang menggambarkan fitur-fitur pengoperasian generator.  Ini generatornya sendiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Dengan perintah ini kita menginisialisasi itu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Kemudian kita beralih ke iteratornya. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Perintah ini memulai iterator, mengembalikan objek seperti itu. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Di sini hal berikut terjadi.  Kode menjalankan fungsi menggunakan nilai <code>input</code> diteruskan ke konstruktor generator.  Kode generator dijalankan hingga kata kunci <code>yield</code> ditemukan di dalamnya.  Pada titik ini, ia mengembalikan hasil dari membagi <code>input</code> dengan <code>2</code> , yang, karena <code>input</code> adalah <code>10</code> , memberikan angka <code>5</code> .  Kami mendapatkan nomor ini berkat iterator, dan, bersamaan dengan itu, indikasi bahwa generator belum selesai (properti yang <code>done</code> pada objek yang dikembalikan oleh iterator disetel ke <code>false</code> ), yaitu, fungsinya hanya ditangguhkan. <br>  Kali berikutnya iterator dipanggil, kita meneruskan angka <code>7</code> ke generator. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  Menanggapi hal ini, iterator mengembalikan objek berikutnya kepada kami. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Di sini, angka <code>7</code> digunakan untuk menghitung nilai <code>doubleThat</code> . <br><br>  Sekilas, mungkin tampak bahwa <code>input / 2</code> kode adalah sesuatu seperti argumen untuk suatu fungsi, tetapi ini hanya nilai yang dikembalikan pada iterasi pertama.  Di sini kita melewatkan nilai ini dan menggunakan nilai input baru <code>7</code> , mengalikannya dengan <code>2</code> .  Setelah itu, kita sampai pada kata kunci <code>yield</code> kedua, sebagai hasilnya, nilai yang diperoleh pada iterasi kedua adalah <code>14</code> . <br><br>  Pada iterasi berikutnya, yang merupakan yang terakhir, kami memberikan angka <code>100</code> ke generator. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Sebagai tanggapan, kami mendapatkan objek berikut. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  Iterasi selesai (kata kunci <code>yield</code> tidak lagi ditemukan dalam generator), hasil evaluasi ekspresi <code>(input * doubleThat * another)</code> dikembalikan dalam objek, yaitu - <code>10 * 14 * 100</code> dan indikasi penyelesaian iterator ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Kata kunci let dan const</font> </h2><br>  JavaScript selalu menggunakan kata kunci <code>var</code> untuk mendeklarasikan variabel.  Variabel semacam itu memiliki cakupan fungsional.  Kata kunci <code>let</code> dan <code>const</code> , masing-masing, memungkinkan Anda untuk mendeklarasikan variabel dan konstanta yang memiliki cakupan blok. <br><br>  Ini berarti bahwa, misalnya, variabel yang dideklarasikan menggunakan kata kunci <code>let</code> dalam satu loop, di dalam blok <code>if</code> , atau di dalam blok kode reguler yang dibatasi oleh kurung kurawal, tidak akan melampaui blok ini.  Variabel yang dideklarasikan dengan <code>var</code> tidak disimpan dalam blok-blok seperti itu, menjadi tersedia dalam fungsi di tingkat yang dideklarasikan. <br><br>  Kata kunci <code>const</code> berfungsi seperti <code>let</code> , tetapi dengan itu, konstanta yang tidak dapat diubah dinyatakan. <br><br>  Dalam kode JS modern, kata kunci <code>var</code> jarang digunakan.  Ini memberi jalan pada kata kunci <code>let</code> dan <code>const</code> .  Pada saat yang sama, yang mungkin tampak tidak biasa, kata kunci <code>const</code> digunakan sangat luas hari ini, yang menunjukkan popularitas ide-ide kekebalan entitas dalam pemrograman modern. <br><br><h2>  <font color="#3AC1EF">Kelas</font> </h2><br>  Ternyata JavaScript adalah satu-satunya bahasa yang sangat luas yang menggunakan model pewarisan prototipe.  Pemrogram beralih ke JS dari bahasa yang menerapkan mekanisme pewarisan berbasis kelas merasa tidak nyaman dalam lingkungan seperti itu.  Standar ES2015 memperkenalkan dukungan kelas dalam JavaScript.  Ini pada dasarnya adalah "gula sintaksis" di sekitar mekanisme internal JS menggunakan prototipe.  Namun, ini mempengaruhi bagaimana tepatnya aplikasi JS menulis. <br><br>  Mekanisme pewarisan JavaScript sekarang terlihat seperti mekanisme serupa dalam bahasa berorientasi objek lainnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Program ini menampilkan teks <code>Hello, I am Tom Cruise. I am an actor</code> ke konsol <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> . <br>  Di kelas JS, variabel instan tidak dapat dideklarasikan, mereka harus diinisialisasi dalam konstruktor. <br><br><h3>  <font color="#3AC1EF"> Konstruktor kelas</font> </h3><br>  Kelas memiliki metode khusus, <code>constructor</code> , yang dipanggil ketika turunan kelas dibuat menggunakan kata kunci <code>new</code> . <br><br><h3>  <font color="#3AC1EF">▍ Kata kunci super</font> </h3><br>  Kata kunci <code>super</code> memungkinkan Anda untuk mengakses kelas induk dari kelas turunan. <br><br><h3>  <font color="#3AC1EF">▍ Getters and setters</font> </h3><br>  Pembuat untuk properti dapat diatur sebagai berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  Setter dapat digambarkan seperti yang ditunjukkan di bawah ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Mereka bekerja dengan getter dan setter seolah-olah mereka bukan fungsi, tetapi properti benda biasa. <br><br><h2>  <font color="#3AC1EF">Modul</font> </h2><br>  Sebelum standar ES2015, ada beberapa pendekatan yang bersaing untuk bekerja dengan modul.  Secara khusus, kita berbicara tentang teknologi RequireJS dan CommonJS.  Situasi ini menyebabkan ketidaksepakatan di komunitas pengembang JS. <br><br>  Saat ini, berkat standarisasi modul di ES2015, situasinya secara bertahap menjadi normal. <br><br><h3>  <font color="#3AC1EF">▍ Impor modul</font> </h3><br>  Modul diimpor menggunakan konstruk dari formulir <code>import...from...</code>  Berikut ini beberapa contohnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Ekspor modul</font> </h3><br>  Mekanisme internal modul ditutup dari dunia luar, tetapi dari modul Anda dapat mengekspor semua yang dapat ditawarkan modul lain.  Ini dilakukan dengan menggunakan kata kunci <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Templat literal</font> </h3><br>  Templat literal adalah cara baru untuk menggambarkan string dalam JavaScript.  Ini tampilannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  Selain itu, menggunakan sintaks literal templat memungkinkan Anda untuk menanamkan ekspresi dalam string dan menyisipkannya.  Ini dilakukan dengan menggunakan konstruksi formulir <code>${a_variable}</code> .  Berikut adalah contoh sederhana penggunaannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Berikut adalah contoh yang lebih rumit, yang menggambarkan kemampuan untuk mengevaluasi ekspresi apa pun dan mengganti hasilnya dalam string. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Berkat penggunaan templat literal, menjadi lebih mudah untuk mendeklarasikan string multi-line. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Bandingkan ini dengan apa yang harus Anda lakukan untuk menggambarkan string multi-line saat menggunakan fitur yang tersedia dalam bahasa sebelum ES2015. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Parameter Fungsi Default</font> </h2><br>  Sekarang fungsi mendukung parameter yang digunakan secara default - jika argumen yang sesuai tidak diteruskan kepada mereka saat memanggil fungsi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Operator yang tersebar</font> </h2><br>  Operator spread (operator ekstensi) memungkinkan Anda untuk "memperluas" array, objek, atau string.  Operator ini terlihat seperti tiga titik ( <code>...</code> ).  Pertama, pertimbangkan dengan contoh array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  Berikut cara membuat array baru berdasarkan array ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  Berikut cara membuat salinan array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Operator ini juga bekerja dengan objek.  Misalnya, inilah cara menggunakannya untuk mengkloning suatu objek. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  Menerapkan operator spread ke string, Anda bisa mengonversinya menjadi array, yang masing-masing elemennya mengandung satu karakter dari string ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Operator ini, selain varian aplikasi di atas, mudah digunakan ketika memanggil fungsi yang mengharapkan daftar argumen normal, memberikan mereka array dengan argumen ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Sebelumnya, ini dilakukan dengan menggunakan konstruksi dari bentuk <code>f.apply(null, a)</code> , tetapi kode seperti itu lebih sulit untuk ditulis dan kurang dapat dibaca. <br><br><h2>  <font color="#3AC1EF">Tugas Merusak</font> </h2><br>  Teknik penugasan destruksi memungkinkan, misalnya, untuk mengambil objek, mengekstraksi beberapa nilai darinya dan menempatkannya dalam variabel atau konstanta bernama. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Di sini, properti <code>firstName</code> dan <code>age</code> diambil dari objek.  Properti <code>age</code> ditulis ke konstanta yang dideklarasikan dengan nama yang sama, dan properti <code>firstName</code> , setelah ekstraksi, jatuh ke <code>name</code> konstan. <br><br>  Tugas yang merusak juga cocok untuk bekerja dengan array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  Konstanta <code>first</code> , <code>second</code> dan <code>fifth</code> mendapatkan elemen pertama, kedua, dan kelima dari array. <br><br><h2>  <font color="#3AC1EF">Meningkatkan Literal Obyek</font> </h2><br>  ES2015 telah sangat memperluas kemampuan untuk menggambarkan objek menggunakan literal objek. <br><br><h3>  <font color="#3AC1EF">▍ Penyederhanaan penyertaan variabel dalam objek</font> </h3><br>  Sebelumnya, untuk menetapkan variabel ke properti objek, perlu menggunakan konstruksi berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Sekarang hal yang sama dapat dilakukan seperti ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Prototipe</font> </h3><br>  Prototipe objek sekarang dapat diatur menggunakan konstruksi berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Kata kunci super</font> </h3><br>  Menggunakan kata kunci <code>super</code> , objek dapat mengakses objek prototipe.  Misalnya, untuk memanggil metode mereka yang memiliki nama yang sama dengan metode objek ini sendiri. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Nama properti yang dihitung</font> </h3><br>  Nama properti yang dihitung terbentuk pada tahap pembuatan objek. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Untuk ... dari loop</font> </h2><br>  Pada 2009, dalam standar ES5, <code>forEach()</code> loop muncul.  Ini adalah desain yang bermanfaat, kelemahannya adalah kenyataan bahwa siklus seperti itu sangat tidak nyaman untuk disela.  Klasik <code>for</code> loop dalam situasi di mana Anda perlu menghentikan eksekusi loop sebelum selesai normal adalah pilihan yang jauh lebih tepat. <br><br>  An <code>for...of</code> cycle telah muncul di ES2015, yang, di satu sisi, dibedakan oleh sintaksisnya yang ringkas dan kenyamanan <code>forEach</code> , dan di sisi lain, ia mendukung kemungkinan keluar awal dari siklus. <br><br>  Berikut adalah beberapa contoh <code>for...of</code> loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Memetakan dan Mengatur Struktur Data</font> </h2><br>  ES2015 memperkenalkan <code>Map</code> dan <code>Set</code> struktur data (serta versi "lemah" <code>WeakMap</code> dan <code>WeakSet</code> , yang penggunaannya meningkatkan kinerja "pengumpul sampah" - mekanisme yang bertanggung jawab untuk mengelola memori di mesin JS).  Ini adalah struktur data yang sangat populer, yang, sebelum tampilan implementasi resmi mereka, harus ditiru menggunakan alat bahasa yang tersedia. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kami meninjau fitur dari standar ES2015, yang telah sangat memengaruhi kondisi bahasa saat ini.  Topik kita berikutnya adalah fitur standar ES2016, ES2017 dan ES2018. <br><br>  <b>Pembaca yang budiman!</b>  Inovasi apa dari standar ES6 yang menurut Anda paling berguna? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431074/">https://habr.com/ru/post/id431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431064/index.html">Manifesto Programmer yang Kaku</a></li>
<li><a href="../id431066/index.html">DEFCON 16. Bagaimana saya bisa menghubungi Anda? Biarkan saya daftar caranya. Bagian 2</a></li>
<li><a href="../id431068/index.html">Seni pendidikan: ideologi mesin slot</a></li>
<li><a href="../id431070/index.html">Hara makan? Kita berbicara tentang kebiasaan makan seorang spesialis IT modern</a></li>
<li><a href="../id431072/index.html">Panduan JavaScript bagian 7: mode ketat, kata kunci ini, acara, modul, matematika</a></li>
<li><a href="../id431076/index.html">Kerangka Node.js paling populer tahun 2018</a></li>
<li><a href="../id431078/index.html">Panduan penanganan kesalahan JavaScript</a></li>
<li><a href="../id431080/index.html">Bagaimana mengatur kantor jarak jauh dan tidak kehilangan tim di ruang angkasa</a></li>
<li><a href="../id431082/index.html">Kotlin: mencari Kepala Pemasaran</a></li>
<li><a href="../id431084/index.html">Dalam situasi yang tidak dapat dipahami - tulis skrip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>