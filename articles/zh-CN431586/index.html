<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍵 👨🏾‍🏫 🖖🏿 如何更快地在JVM上处理错误 👨🏼‍🎨 🤨 🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有多种方法可以处理编程语言中的错误： 


- 许多语言（Java，Scala和其他JVM，Python和许多其他语言）的标准异常 
- 状态码或标志（Go，bash） 
- 各种代数数据结构，其值既可以是成功的结果，也可以是错误描述（Scala，haskell和其他功能语言） 


 异常的使用非...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何更快地在JVM上处理错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p> 有多种方法可以处理编程语言中的错误： </p><br><ul><li> 许多语言（Java，Scala和其他JVM，Python和许多其他语言）的标准异常 </li><li> 状态码或标志（Go，bash） </li><li> 各种代数数据结构，其值既可以是成功的结果，也可以是错误描述（Scala，haskell和其他功能语言） </li></ul><br><p> 异常的使用非常广泛，另一方面，异常通常被称为缓慢的。 但是，功能性方法的反对者通常会对性能产生吸引力。 </p><br><p> 最近，我一直在与Scala一起工作，在这里我可以同时使用异常和各种数据类型进行错误处理，因此我想知道哪种方法会更方便，更快捷。 </p><br><p>我们将立即放弃使用代码和标志，因为JVM语言不接受这种方法，而且我认为这种方法太容易出错（对双关语很抱歉）。 因此，我们将比较异常和不同类型的ADT。 此外，ADT可被视为功能性样式中错误代码的使用。 </p><br><p>  <strong>更新</strong> ：没有堆栈跟踪的异常被添加到比较中 </p><a name="habracut"></a><br><h3 id="konkursanty"> 参赛者 </h3><br><div class="spoiler">  <b class="spoiler_title">有关代数数据类型的更多信息</b> <div class="spoiler_text"><p> 对于不太熟悉ADT（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ADT</a> ）的人-代数类型由几个可能的值组成，每个值都可以是复合值（结构，记录）。 </p><br><p>一个示例是类型<code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> ，它代替空值：使用此类型的值可以是<code>Some(t)</code>如果有值<code>Some(t)</code> ，也可以是<code>None</code> （无）。 </p><br><p> 另一个示例为“ <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> ，它描述可以成功完成或出现错误的计算结果。 </p><br><p> 所以我们的参赛者： </p></div></div><br><ul><li>  <em>好</em>老的例外 </li><li> 没有堆栈跟踪的异常，因为填充堆栈跟踪是非常缓慢的操作 </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> -相同的异常，但在功能包装中 </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> -包含结果或错误说明的类型 </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cats库中的</a>一种类型，如果发生错误，它可能包含有关不同错误的多条消息（此处并没有使用<code>List</code> ，但这没关系） </li></ul><br><p>  <strong>注意</strong>本质上，将异常与堆栈跟踪（不带和ADT）进行比较，但选择了几种类型，因为Scala没有单一的方法，比较几种有趣。 </p><br><p> 除异常外，字符串还用于描述错误，但在实际情况下成功使用相同的字符串时，将使用不同的类（ <code>Either[Failure, T]</code> ）。 </p><br><h3 id="problema"> 问题 </h3><br><p> 为了测试错误处理，我们考虑了解析和数据验证的问题： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p> 即 具有原始数据<code>Map[String, String]</code>您需要获取<code>Person</code>或一个错误（如果数据无效）。 </p><br><h4 id="throw"> 投掷 </h4><br><p> 使用异常解决<em>额头的</em>方法（以下我将仅提供<code>person</code>函数，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上查看完整的代码）： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p> 在这里， <code>string</code> ， <code>integer</code>和<code>boolean</code>验证简单类型​​的存在和格式并执行转换。 <br> 总的来说，它非常简单明了。 </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST（无堆栈跟踪） </h4><br><p> 代码与前面的情况相同，但是在可能的情况下使用了没有堆栈跟踪的异常： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try"> 试一下 </h4><br><p> 该解决方案可以更早地捕获异常，并允许通过<code>for</code>合并结果（不要与其他语言的循环混淆）： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p> 对于脆弱的眼睛来说有点不寻常，但是由于使用了<code>for</code> ，它与版本非常相似，但有例外，另外，对字段是否存在的验证和所需类型的解析是分别进行的（ <code>flatMap</code>可以在此处<code>and then</code>阅读） </p><br><h4 id="either"> 要么 </h4><br><p> 由于错误类型是固定的，因此， <code>Either</code>类型都隐藏在<code>Result</code>别名后面： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解析器</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p> 由于标准的<code>Either</code>如<code>Try</code>在Scala中形成了monad，因此代码完全相同，因此此处的区别在于，字符串在此处显示为错误，并且最少使用了异常（仅用于解析数字时处理错误） </p><br><h4 id="validated"> 已验证 </h4><br><p> 在这里，使用Cats库的目的是为了尽可能多地获取未发生的第一件事（例如，如果几个字段无效，则结果将包含所有这些字段的解析错误） <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p> 这段代码已经与原始版本稍有相似，但是有例外，但是对附加限制的验证并未脱离解析字段，我们仍然会遇到一些错误而不是一个错误，这是值得的！ </p><br><h3 id="testirovanie"> 测试中 </h3><br><p> 为了进行测试，生成了具有不同百分比错误的数据集，并以每种方式对其进行了解析。 </p><br><p> 所有错误百分比的结果： <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p> 更详细地讲，错误率低（由于使用<em>了</em>更大的样本，因此时间有所不同）： <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p> 如果错误的某些部分仍然是堆栈跟踪的异常（在我们的情况下，解析数字的错误将是我们无法控制的异常），那么“快速”错误处理方法的性能当然会大大降低。  <code>Validated</code>尤其受到影响，因为它收集了所有错误，因此比其他错误接收到的异常缓慢： <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody"> 结论 </h3><br><p> 如实验所示，具有堆栈跟踪的异常确实非常慢（100％的错误是<code>Throw</code>和<code>Either</code>之间的差异超过50倍！），并且在几乎没有异常的情况下，使用ADT付出了代价。 但是，使用没有堆栈跟踪的异常的速度与ADT一样快（并且错误率较低），但是，如果此类异常超出了相同的验证范围，则跟踪其来源将不容易。 </p><br><p> 总体而言，如果发生异常的可能性大于1％，则没有堆栈跟踪的异常的工作速度最快， <code>Validated</code>或常规的<code>Either</code>几乎一样快。 出现大量错误时，仅由于快速失败的语义， <code>Either</code>都可能比<code>Validated</code>更快。 </p><br><p> 使用ADT进行错误处理比异常提供了另一个优点：错误的可能性被连接到类型本身中，并且更容易错过，例如使用<code>Option</code>而不是null时。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431586/">https://habr.com/ru/post/zh-CN431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431572/index.html">如何编写功能要求</a></li>
<li><a href="../zh-CN431574/index.html">今天的神经接口</a></li>
<li><a href="../zh-CN431576/index.html">背景：开普勒太空天文台-铁，与地球的交流，软件和结果</a></li>
<li><a href="../zh-CN431582/index.html">个人数据保护的历史：GDPR如何</a></li>
<li><a href="../zh-CN431584/index.html">空间和测试：混合，但不要晃动</a></li>
<li><a href="../zh-CN431588/index.html">自雇法。 需要考虑的信息</a></li>
<li><a href="../zh-CN431590/index.html">英国过时风电场的现代化改造将使能源发电增加171％</a></li>
<li><a href="../zh-CN431596/index.html">Veeam备份和复制负载测试</a></li>
<li><a href="../zh-CN431598/index.html">我们将没有网卡的公共QEMU虚拟机带入Internet，并尝试挖掘</a></li>
<li><a href="../zh-CN431600/index.html">通过网络界面提高IDS / NMS：Mikrotik和Suricata</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>