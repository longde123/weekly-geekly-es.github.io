<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏞️ 🛒 😔 Structuration des applications React 👨🏽‍🌾 👨🏼‍🌾 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le matériel, dont nous publions la traduction aujourd'hui, révèle les approches utilisées par son auteur lors de la structuration des applications Rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structuration des applications React</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/460793/">  Le matériel, dont nous publions la traduction aujourd'hui, révèle les approches utilisées par son auteur lors de la structuration des applications React.  En particulier, nous discuterons ici de la structure de dossiers utilisée, de la dénomination des entités, des endroits où se trouvent les fichiers de test et d'autres choses similaires. <br><br>  L'une des caractéristiques les plus agréables de React est que cette bibliothèque n'oblige pas le développeur à respecter strictement certaines conventions concernant la structure du projet.  Une grande partie de cela reste à la discrétion du programmeur.  Cette approche est différente de celle, disons, adoptée dans les cadres Ember.js ou Angular.  Ils offrent aux développeurs plus de fonctionnalités standard.  Ces cadres prévoient des conventions concernant la structure des projets et des règles pour nommer les fichiers et les composants. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/k6/9y/ug/k69yugvbt27p3wtccvzeqrf_v4w.jpeg"></a> <br><br>  Personnellement, j'aime l'approche adoptée par React.  Le fait est que je préfère contrôler quelque chose moi-même, sans compter sur certains «accords».  Cependant, l'approche de structuration des projets qu'Angular offre de nombreux avantages.  Le choix entre la liberté et des règles plus ou moins rigides se résume à ce qui est le plus proche de vous et de votre équipe. <br><br>  Au fil des années de travail avec React, j'ai essayé de nombreuses façons de structurer les applications.  Certaines des idées que j'ai appliquées se sont avérées plus efficaces que d'autres.  Par conséquent, ici, je vais parler de tout ce qui s'est bien montré dans la pratique.  J'espère que vous trouverez ici quelque chose qui vous sera utile. <br><a name="habracut"></a><br>  Je n’essaie pas de montrer ici une façon «juste» de structurer les applications.  Vous pouvez reprendre certaines de mes idées et les modifier pour répondre à vos besoins.  Vous pourriez bien être en désaccord avec moi en continuant à travailler comme vous le faisiez auparavant.  Différentes équipes créent différentes applications et utilisent différents moyens pour atteindre leurs objectifs. <br><br>  Il est important de noter que si vous regardez le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thread</a> , dont je participe au développement, et regardez le dispositif de son interface, vous trouverez des endroits où ces règles dont je parlerai ne sont pas respectées.  Le fait est que toute «règle» de programmation ne doit être considérée que comme des recommandations et non comme des normes complètes valables dans toutes les situations.  Et si vous pensez qu'une sorte de "règles" ne vous convient pas - vous, pour améliorer la qualité de ce sur quoi vous travaillez, devriez trouver la force de s'écarter de ces "règles". <br><br>  En fait, maintenant, sans plus tarder, je vous propose mon histoire sur la structuration des applications React. <br><br><h2>  <font color="#3AC1EF">Ne vous inquiétez pas trop des règles.</font> </h2><br>  Peut-être décidez-vous que la recommandation de ne pas trop vous soucier des règles semble étrange au début de notre conversation.  Mais c'est exactement ce que je veux dire quand je dis que la principale erreur que les programmeurs ont en termes d'observation des règles est que les programmeurs attachent trop d'importance aux règles.  Cela est particulièrement vrai au début des travaux sur un nouveau projet.  Au moment de la création du premier <code>index.jsx</code> tout simplement impossible de savoir ce qui est le mieux pour ce projet.  Au fur et à mesure que le projet se développe, vous arriverez naturellement à une sorte de structure de fichiers et de dossiers, ce qui est probablement très bon pour ce projet.  Si, au cours de la poursuite des travaux, il s'avère que la structure existante est quelque peu infructueuse, elle peut être améliorée. <br><br>  Si vous lisez ceci et vous surprenez à penser qu'il n'y a rien dans votre application qui est en cours de discussion, alors ce n'est pas un problème.  Chaque application est unique, il n'y a pas deux équipes de développement absolument identiques.  Par conséquent, chaque équipe, travaillant sur un projet, parvient à des accords concernant sa structure et ses méthodes de travail.  Cela aide les membres de l'équipe à travailler de manière productive.  Ne vous efforcez pas de, après avoir appris comment quelqu'un fait quelque chose, présentez-vous immédiatement cela.  N'essayez pas d'introduire dans votre travail ce que l'on appelle dans certains matériaux, et même dans ce cas, le "moyen le plus efficace" de résoudre un problème.  J'ai toujours adhéré et adhéré à la stratégie suivante concernant ces recommandations.  J'ai mon propre ensemble de règles, mais en lisant comment les autres agissent dans certaines situations, je choisis ce qui me semble réussi et qui me convient.  Cela conduit au fait qu'au fil du temps, mes méthodes de travail s'améliorent.  En même temps, je n'ai pas de chocs et il n'y a aucune envie de tout réécrire à partir de zéro. <br><br><h2>  <font color="#3AC1EF">Les composants importants se trouvent dans des dossiers séparés</font> </h2><br>  L'approche pour placer des fichiers de composants dans des dossiers auxquels je suis arrivé est que les composants qui peuvent être considérés comme «importants», «de base», «de base» dans le contexte de l'application sont placés dans des dossiers séparés.  Ces dossiers se trouvent à leur tour dans le dossier des <code>components</code> .  Par exemple, si nous parlons d'une application pour une boutique électronique, le composant <code>&lt;Product&gt;</code> utilisé pour décrire le produit peut être reconnu comme un composant similaire.  Voici ce que je veux dire: <br><br><pre> <code class="plaintext hljs">- src/  - components/    - product/      - product.jsx      - product-price.jsx    - navigation/      - navigation.jsx    - checkout-flow/      - checkout-flow.jsx</code> </pre> <br>  Dans ce cas, les composants "secondaires" qui ne sont utilisés que par certains composants "principaux" se trouvent dans le même dossier que ces composants "principaux".  Cette approche a fait ses preuves dans la pratique.  Le fait est qu'en raison de son application, une certaine structure apparaît dans le projet, mais le niveau d'imbrication des dossiers n'est pas trop important.  Son application n'entraîne pas l'apparition de quelque chose comme <code>../../../</code> dans les commandes d'importation de composants, elle ne rend pas difficile le déplacement dans le projet.  Cette approche vous permet de créer une hiérarchie claire de composants.  Ce composant, dont le nom correspond au nom du dossier, est considéré comme "de base".  D'autres composants situés dans le même dossier servent à diviser le composant "de base" en parties, ce qui simplifie le travail avec le code de ce composant et son support. <br><br>  Bien que je soutienne la présence d'une certaine structure de dossiers dans le projet, je crois que la chose la plus importante est la sélection de bons noms de fichiers.  Les dossiers eux-mêmes sont moins importants. <br><br><h2>  <font color="#3AC1EF">Utilisation de sous-dossiers pour les sous-composants</font> </h2><br>  L'un des inconvénients de l'approche ci-dessus est que son utilisation peut conduire à l'apparition de dossiers de composants «basiques» contenant de nombreux fichiers.  Prenons, par exemple, le composant <code>&lt;Product&gt;</code> .  Des fichiers CSS y seront attachés (nous en parlerons plus tard), des fichiers de test, de nombreux sous-composants et, éventuellement, d'autres ressources - telles que des images et des icônes SVG.  Cette liste "d'ajouts" n'est pas limitée.  Tout cela se retrouvera dans le même dossier que le composant "base". <br><br>  Je m'en fiche vraiment.  Cela me convient si les fichiers ont des noms bien pensés et s'ils peuvent être facilement trouvés (en utilisant les outils de recherche de fichiers dans l'éditeur).  Si tel est le cas, la structure des dossiers s'estompe en arrière-plan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un</a> tweet sur ce sujet. <br><br>  Cependant, si vous préférez que votre projet ait une structure plus étendue, il n'y a rien de difficile à déplacer des sous-composants vers leurs propres dossiers: <br><br><pre> <code class="javascript hljs">- src/  - components/    - product/      - product.jsx      - ...      - product-price/        - product-price.jsx</code> </pre> <br><h2>  <font color="#3AC1EF">Les fichiers de test se trouvent au même endroit que les fichiers des composants testés.</font> </h2><br>  Nous commençons cette section par une simple recommandation, à savoir que les fichiers de test doivent être placés au même endroit que les fichiers avec le code qu'ils sont vérifiés avec leur aide.  Je parlerai également de la façon dont je préfère structurer les composants, en essayant de veiller à ce qu'ils soient proches les uns des autres.  Mais maintenant, je peux dire que je trouve pratique de placer les fichiers de test dans les mêmes dossiers que les fichiers de composants.  Dans ce cas, les noms des fichiers avec les tests sont identiques aux noms des fichiers avec le code.  Aux noms de test, avant l'extension du nom de fichier, le suffixe <code>.test</code> ajouté que: <br><br><ul><li>  Nom du fichier du composant: <code>auth.js</code> </li><li>  Nom du fichier de test: <code>auth.test.js</code> </li></ul><br>  Cette approche a plusieurs atouts: <br><br><ul><li>  Il facilite la recherche de fichiers de test.  En un coup d'œil, vous pouvez comprendre s'il existe un test pour le composant avec lequel je travaille. </li><li>  Toutes les commandes d'importation nécessaires sont très simples.  Dans le test, pour importer le code testé, vous n'avez pas besoin de créer des structures qui décrivent, par exemple, la sortie du dossier <code>__tests__</code> .  Ces équipes semblent extrêmement simples.  Par exemple, comme ceci: <code>import Auth from './auth'</code> . </li></ul><br>  Si nous avons des données utilisées pendant le test, par exemple quelque chose comme des simulations de demande d'API, nous les mettons dans le même dossier où se trouvent déjà le composant et son test.  Lorsque tout ce qui peut être nécessaire se trouve dans un seul dossier, cela contribue à la croissance de la productivité.  Par exemple, si vous utilisez une structure de dossiers ramifiés et que le programmeur est sûr qu'un certain fichier existe, mais ne se souvient pas de son nom, le programmeur devra rechercher ce fichier dans de nombreux sous-répertoires.  Avec l'approche proposée, il suffit de regarder le contenu d'un dossier et tout deviendra clair. <br><br><h2>  <font color="#3AC1EF">Modules CSS</font> </h2><br>  Je suis un grand fan des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modules CSS</a> .  Nous avons constaté qu'ils sont parfaits pour créer des règles CSS modulaires pour les composants. <br><br>  De plus, j'aime beaucoup la technologie des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants de style</a> .  Cependant, au cours de travaux sur des projets auxquels de nombreux développeurs ont participé, il s'est avéré que la présence de vrais fichiers CSS dans le projet augmentait l'utilisabilité. <br><br>  Comme vous l'avez probablement déjà deviné, nos fichiers CSS sont situés, comme les autres fichiers, à côté des fichiers de composants, dans les mêmes dossiers.  Cela simplifie considérablement le mouvement entre les fichiers lorsque vous avez besoin de comprendre rapidement la signification d'une classe. <br><br>  Une recommandation plus générale, dont l'essence imprègne tout ce matériel, est que tout le code lié à un certain composant doit être conservé dans le même dossier dans lequel se trouve ce composant.  Il est révolu le temps où des dossiers distincts étaient utilisés pour stocker le code CSS et JS, le code de test et d'autres ressources.  L'utilisation de structures de dossiers complexes complique le mouvement entre les fichiers et n'a aucun avantage évident, sauf qu'il aide à "organiser le code".  Conservez les fichiers interconnectés dans le même dossier - cela signifie passer moins de temps à vous déplacer entre les dossiers pendant le travail. <br><br>  Nous avons même créé un chargeur Webpack pour CSS, dont les capacités correspondent aux fonctionnalités de notre travail.  Il vérifie les noms de classe déclarés et renvoie une erreur dans la console si nous nous référons à une classe qui n'existe pas. <br><br><h2>  <font color="#3AC1EF">Presque toujours, un seul code de composant est placé dans un fichier</font> </h2><br>  Mon expérience montre que les programmeurs adhèrent généralement trop strictement à la règle selon laquelle le code d'un et d'un seul composant React doit être dans un seul fichier.  En même temps, je soutiens pleinement l'idée qu'il ne vaut pas la peine de placer trop de composants dans un seul fichier (imaginez les difficultés de nommer de tels fichiers!).  Mais je crois qu'il n'y a rien de mal à mettre dans le même fichier dans lequel se trouve le code d'un certain "gros" composant, et le code du "petit" composant qui lui est associé.  Si un tel mouvement aide à préserver la pureté du code, si le "petit" composant n'est pas trop grand pour le mettre dans un fichier séparé, cela ne nuira à personne. <br><br>  Par exemple, si je crée un composant <code>&lt;Product&gt;</code> , et j'ai besoin d'un petit morceau de code pour afficher le prix, alors je peux le faire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Price = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ price, currency }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    {currency}    {formatPrice(price)}  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Product = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ,      !  return (    &lt;div&gt;      &lt;Price price={props.price} currency={props.currency} /&gt;      &lt;div&gt;loads more stuff...&lt;/div&gt;    &lt;/div&gt;  ) }</span></span></code> </pre> <br>  La bonne chose à propos de cette approche est que je n'ai pas eu à créer de fichier séparé pour le composant <code>&lt;Price&gt;</code> et que ce composant est disponible exclusivement pour le composant <code>&lt;Product&gt;</code> .  Nous n'exportons pas ce composant, il ne peut donc pas être importé ailleurs dans l'application.  Cela signifie que lorsqu'on vous demande de mettre <code>&lt;Price&gt;</code> dans un fichier séparé, vous pouvez donner une réponse claire et positive si vous devez l'importer ailleurs.  Sinon, vous pouvez vous passer de mettre le code <code>&lt;Price&gt;</code> dans un fichier séparé. <br><br><h2>  <font color="#3AC1EF">Dossiers séparés pour les composants universels</font> </h2><br>  Nous utilisons récemment des composants universels.  En fait, ils forment notre système de conception (que nous prévoyons de publier un jour), mais jusqu'à présent, nous avons commencé petit - avec des composants comme <code>&lt;Button&gt;</code> et <code>&lt;Logo&gt;</code> .  Un composant est considéré comme «universel» s'il n'est pas lié à une partie spécifique du site, mais est l'un des éléments constitutifs de l'interface utilisateur. <br><br>  Des composants similaires se trouvent dans votre propre dossier ( <code>src/components/generic</code> ).  Cela simplifie considérablement le travail avec tous les composants universels.  Ils sont au même endroit - c'est très pratique.  Au fil du temps, au fur et à mesure que le projet se développe, nous prévoyons de développer un guide de style (nous sommes de grands fans de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">react-styleguidist</a> ) afin de simplifier davantage le travail avec des composants universels. <br><br><h2>  <font color="#3AC1EF">Utilisation d'alias pour importer des entités</font> </h2><br>  La structure de dossiers relativement plate dans nos projets garantit que les commandes d'importation n'ont pas de structures trop longues comme <code>../../</code> .  Mais c'est difficile de s'en passer.  Par conséquent, nous avons utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">babel-plugin-module-resolver</a> pour configurer des alias qui simplifient les commandes d'importation. <br><br>  Vous pouvez faire de même avec Webpack, mais grâce au plugin Babel, les mêmes commandes d'importation peuvent fonctionner dans les tests. <br><br>  Nous l'avons configuré avec une paire d'alias: <br><br><pre> <code class="javascript hljs">{  <span class="hljs-attr"><span class="hljs-attr">components</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components'</span></span>,  <span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>, }</code> </pre> <br>  Le premier est extrêmement simple.  Il vous permet d'importer n'importe quel composant, en démarrant la commande avec le mot <code>components</code> .  Dans l'approche normale, les commandes d'importation ressemblent à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../components/product/product'</span></span></code> </pre> <br>  Au lieu de cela, nous pouvons les écrire comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'components/product/product'</span></span></code> </pre> <br>  Les deux commandes importent le même fichier.  C'est très pratique, car cela vous permet de ne pas penser à la structure des dossiers. <br><br>  Le deuxième alias est un peu plus compliqué: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>,</code> </pre> <br>  Nous utilisons ici l'expression régulière.  Il trouve les commandes d'importation qui commencent par <code>generic</code> (le signe <code>^</code> au début de l'expression vous permet de sélectionner uniquement les commandes qui commencent par <code>generic</code> ) et capture ce qui est après <code>generic/</code> dans le groupe.  Après cela, nous utilisons le fragment capturé ( <code>\\1</code> ) dans la construction <code>./src/components/generic/\\1/\\1</code> . <br><br>  Par conséquent, nous pouvons utiliser les commandes d'importation pour les composants universels de ce type: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'generic/button'</span></span></code> </pre> <br>  Ils sont convertis en commandes suivantes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/components/generic/button/button'</span></span></code> </pre> <br>  Cette commande, par exemple, sert à importer un fichier JSX décrivant un bouton universel.  Nous avons fait tout cela parce que cette approche simplifie considérablement l'importation de composants universels.  De plus, cela nous sera très utile si nous décidons de changer la structure des fichiers du projet (cela, comme notre système de conception se développe, est tout à fait possible). <br><br>  Ici, je voudrais noter que vous devez être prudent lorsque vous travaillez avec des pseudonymes.  Si vous n'en avez que quelques-uns et qu'ils sont conçus pour résoudre des problèmes d'importation standard, tout va bien.  Mais si vous en avez beaucoup, ils peuvent apporter plus de confusion que de bien. <br><br><h2>  <font color="#3AC1EF">Dossier lib universel pour les utilitaires</font> </h2><br>  Je voudrais retrouver tout le temps que j'ai passé à essayer de trouver l'endroit parfait pour du code qui n'est pas du code composant.  J'ai partagé tout cela selon différents principes, en mettant en évidence le code des utilitaires, des services, des fonctions auxiliaires.  Tout cela a tellement de noms que je ne les mentionnerai pas tous.  Maintenant, je n'essaie pas de comprendre la différence entre "l'utilitaire" et la "fonction auxiliaire" afin de trouver la bonne place pour un certain fichier.  Maintenant, j'utilise une approche beaucoup plus simple et plus compréhensible: tout cela tombe dans un seul dossier <code>lib</code> . <br><br>  À long terme, la taille de ce dossier peut s'avérer si grande que vous devez le structurer d'une manière ou d'une autre, mais c'est tout à fait normal.  Il est toujours plus facile d'équiper quelque chose d'une certaine structure que de se débarrasser des erreurs de structuration excessive. <br><br>  Dans notre projet Thread, le dossier <code>lib</code> contient environ 100 fichiers.  Ils sont divisés à peu près également en fichiers contenant l'implémentation de certaines fonctionnalités et en fichiers de test.  Cela n'a pas posé de difficultés pour trouver les fichiers nécessaires.  Grâce aux <code>lib/name_of_thing</code> recherche intelligents intégrés à la plupart des éditeurs, je dois presque toujours saisir quelque chose comme <code>lib/name_of_thing</code> , et ce dont j'ai besoin se trouve. <br><br>  De plus, nous avons un alias qui simplifie l'importation à partir du dossier <code>lib</code> , vous permettant d'utiliser des commandes de ce type: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> formatPrice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lib/format_price'</span></span></code> </pre> <br>  Ne soyez pas alarmé par les structures de dossiers plats qui peuvent entraîner le stockage de plusieurs fichiers dans un dossier.  Habituellement, une telle structure est tout ce qui est nécessaire pour un certain projet. <br><br><h2>  <font color="#3AC1EF">Masquage de bibliothèques tierces derrière des API natives</font> </h2><br>  J'aime vraiment le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système de</a> surveillance des bogues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sentry</a> .  Je l'ai souvent utilisé lors du développement de parties serveur et client d'applications.  Avec son aide, vous pouvez intercepter des exceptions et recevoir des notifications sur leur occurrence.  Il s'agit d'un excellent outil qui nous permet de nous tenir au courant des problèmes rencontrés sur le site. <br><br>  Chaque fois que j'utilise une bibliothèque tierce dans mon projet, je réfléchis à la manière de la faire pour que, si nécessaire, elle puisse être remplacée le plus facilement possible par autre chose.  Souvent, comme avec le même système Sentry que nous aimons vraiment, ce n'est pas nécessaire.  Mais, juste au cas où, cela ne fait jamais de mal de penser à un moyen d'éviter d'utiliser un certain service ou un moyen de le changer pour autre chose. <br><br>  La meilleure solution à ce problème est de développer votre propre API qui cache les outils des autres.  Cela ressemble à la création d'un module <code>lib/error-reporting.js</code> qui exporte la fonction <code>reportError()</code> .  Le cœur de ce module utilise Sentry.  Mais Sentry n'est directement importé que dans ce module et nulle part ailleurs.  Cela signifie que remplacer Sentry par un autre outil sera très simple.  Pour ce faire, il suffira de changer un fichier en un seul endroit.  Tant que l'API publique de ce fichier reste inchangée, le reste du projet ne saura même pas qu'en appelant <code>reportError()</code> , ce n'est pas Sentry qui est utilisé, mais autre chose. <br><br>  Veuillez noter que l'API publique du module s'appelle les fonctions qu'elle exporte et leurs arguments.  Ils sont également appelés l'interface publique du module. <br><br><h2>  <font color="#3AC1EF">Utilisation de PropTypes (ou d'outils tels que TypeScript ou Flow)</font> </h2><br>  Quand je fais de la programmation, je pense à trois versions de moi-même: <br><br><ul><li>  Jack du passé et le code qu'il a écrit (code parfois douteux). </li><li>  Aujourd'hui, Jack et le code qu'il écrit maintenant. </li><li>  Jack du futur.  Quand je pense à cet avenir moi-même, je me pose la question de savoir comment écrire du code qui me facilitera la vie à l'avenir. </li></ul><br>  Cela peut sembler bizarre, mais je l'ai trouvé utile, en réfléchissant à la façon d'écrire du code, posez la question suivante: "Comment sera-t-il perçu dans six mois?". <br><br>  Un moyen simple de vous rendre présent et de vous rendre plus productif consiste à spécifier les types de propriétés ( <code>PropTypes</code> ) utilisées par les composants.  Cela vous fera gagner du temps dans la recherche de fautes de frappe possibles.  Cela vous protégera des situations où, en utilisant le composant, des propriétés de mauvais types sont appliquées, ou ils oublient complètement le transfert de propriétés.  Dans notre cas, la <a href="">règle eslint-react / prop-types</a> est un bon rappel de la nécessité d'utiliser <code>PropTypes</code> . <br><br>  Si vous allez encore plus loin, il est recommandé de décrire les propriétés aussi précisément que possible.  Par exemple, vous pouvez faire ceci: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.object.isRequired</code> </pre> <br>  Mais ce serait bien mieux de faire ça: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.shape({  <span class="hljs-attr"><span class="hljs-attr">id</span></span>: PropTypes.number.isRequired,  <span class="hljs-attr"><span class="hljs-attr">title</span></span>: PropTypes.string.isRequired,  <span class="hljs-comment"><span class="hljs-comment">//    }).isRequired</span></span></code> </pre> <br>  Dans le premier exemple, la vérification minimale nécessaire est effectuée.  Dans le second, le développeur reçoit des informations beaucoup plus utiles.  Ils seront très utiles, par exemple, si quelqu'un oublie un certain champ utilisé dans l'objet. <br><br><h2>  <font color="#3AC1EF">Les bibliothèques tierces ne sont utilisées que lorsqu'elles sont vraiment nécessaires.</font> </h2><br>  Cette astuce est plus pertinente que jamais avec l'avènement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hameçons React</a> .  Par exemple, j'ai participé à une importante modification d'une des parties du site Thread et j'ai décidé d'accorder une attention particulière à l'utilisation de bibliothèques tierces.  ,       ,          .   (   ),  .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,      React-.      —  ,    ,   React  API Context,        . <br><br> ,  ,  Redux,    .       ,      (            ,     ). ,           ,   ,           . <br><br><h2> <font color="#3AC1EF">   </font> </h2><br>   —   ,       ,   .      . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     emitter.send('user_add_to_cart') //     emitter.on('user_add_to_cart', () =&gt; {  //  -  })</span></span></code> </pre> <br>      ,            .     ,             .      ,   «   ».   ,      ,   ,    .         . «»      - ,       .  ,    ,        . <br><br>      Redux.       .     ,  .  ,     ,  <code>user_add_to_cart</code> ,   .       .  , ,       Redux,      .     ,    Redux    ,     . <br><br>  ,       ,   ,  ,     : <br><br><ul><li>  ,   , .         . </li><li>  ,  ,   .       ,    . </li><li>  ,  -  , . ,     ,    . </li></ul><br>    - ,    .    ,        ,   .      ,        ,   ,           «» . <br><br>       ,       ,  API Context  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-</a> . <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>         ,    (, ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ).     :    ,      . <br><br> ,    ,          ,     .        : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mount(  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ComponentUnderTest</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br>      : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mountWithAuth(ComponentUnderTest, {  <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>,  <span class="hljs-attr"><span class="hljs-attr">userId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, })</code> </pre> <br>       : <br><br><ul><li>     .       —     ,     ,   ,      . </li><li>      —    <code>mountWithAuth</code>       .    ,          . </li></ul><br>   ,           <code>test-utils.js</code> . ,       —   .       . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>       .     ,     , ,  ,      .         ,  ,              .        ,   :       .               .           -     ,   . <br><br>  <b>Chers lecteurs!</b>     React-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460793/">https://habr.com/ru/post/fr460793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460777/index.html">C'est le tour: pourquoi Apple a changé les exigences pour les développeurs d'applications</a></li>
<li><a href="../fr460779/index.html">Débogage avancé</a></li>
<li><a href="../fr460783/index.html">Consensus sur la réputation du nœud. Est-ce nécessaire?</a></li>
<li><a href="../fr460785/index.html">Applications pour les livres électroniques sur le système d'exploitation Android. Partie 1. Introduction et applications bureautiques</a></li>
<li><a href="../fr460789/index.html">Enfin, le rajeunissement est une chose</a></li>
<li><a href="../fr460795/index.html">12 conseils pour améliorer les performances des applications JavaScript</a></li>
<li><a href="../fr460797/index.html">Développement JavaScript responsable Partie 2</a></li>
<li><a href="../fr460799/index.html">Demande de paiement API de navigateur standard</a></li>
<li><a href="../fr460801/index.html">27 outils VS Code géniaux pour les développeurs JavaScript modernes</a></li>
<li><a href="../fr460803/index.html">Lire pour l'été: des livres pour les techniciens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>