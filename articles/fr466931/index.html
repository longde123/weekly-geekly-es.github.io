<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ ğŸ¥ª ğŸ¦€ Optimisation des performances pour les applications .NET (C #) ğŸšµğŸ¾ ğŸ”‹ ğŸ‘¨ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a beaucoup d'articles avec un titre similaire, donc j'essaierai d'Ã©viter les sujets courants. J'espÃ¨re que mÃªme un dÃ©veloppeur trÃ¨s expÃ©rimentÃ© t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation des performances pour les applications .NET (C #)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466931/"><img src="https://habrastorage.org/webt/gs/yu/jc/gsyujcvzccxootdcxkywpaida0k.jpeg" alt="image"><br><br>  Il y a beaucoup d'articles avec un titre similaire, donc j'essaierai d'Ã©viter les sujets courants.  J'espÃ¨re que mÃªme un dÃ©veloppeur trÃ¨s expÃ©rimentÃ© trouvera quelque chose d'utile ici.  Cet article ne considÃ©rera que des mÃ©canismes et des approches d'optimisation simples qui leur permettront d'Ãªtre appliquÃ©s avec un minimum d'effort.  Et ces changements n'augmenteront pas l'entropie de votre code.  L'article ne fera pas attention Ã  quoi et quand optimiser, cet article concerne plus l'approche de l'Ã©criture de code en gÃ©nÃ©ral. <br><a name="habracut"></a><br><h4>  1. ToArray vs ToList </h4><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItems</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _storage.Items.Where(...).ToList(); }</code> </pre> <br>  D'accord, un code trÃ¨s typique pour les projets industriels.  Mais qu'est-ce qui ne va pas avec lui?  L'interface IEnumerable renvoie une collection que vous pouvez Â«parcourirÂ», cette interface n'implique pas que nous puissions ajouter / supprimer des Ã©lÃ©ments.  Par consÃ©quent, il n'est pas nÃ©cessaire de mettre fin Ã  l'expression LINQ en effectuant un transtypage en liste (ToList).  Dans ce cas, la conversion en tableau (ToArray) est prÃ©fÃ©rable.  Puisque List est un wrapper sur Array, et toutes les fonctionnalitÃ©s supplÃ©mentaires fournies par ce wrapper, nous avons coupÃ© l'interface.  Un tableau consomme moins de mÃ©moire et l'accÃ¨s Ã  ses valeurs est plus rapide.  Par consÃ©quent, pourquoi payer plus.  D'une part, cette optimisation n'est pas significative, comme on dit Â«optimisation sur les matchsÂ», mais ce n'est pas tout Ã  fait vrai.  Le fait est que dans une application typique dans laquelle les services renvoient des modÃ¨les pour la couche de prÃ©sentation, il peut y avoir une myriade d'appels ToList.  Dans l'exemple dÃ©crit ci-dessus, l'interface IEnumerable est introduite Ã  des fins d'illustration uniquement.  Cette approche est pertinente pour tous les cas oÃ¹ vous devez renvoyer une collection que vous n'allez pas modifier plus tard. <br><br>  Je prÃ©vois un commentaire selon lequel Array et List ne fonctionneront pas de maniÃ¨re Ã©quivalente dans le cas d'un accÃ¨s multi-thread Ã  la collection.  Ã‡a l'est vraiment.  Mais si vous, en tant que dÃ©veloppeur, envisagez la possibilitÃ© d'un accÃ¨s multithread Ã  une telle collection avec la possibilitÃ© de la modifier, alors avec un haut degrÃ© de probabilitÃ©, ni Array ni List ne vous conviendront. <br><br><h4>  2. Le paramÃ¨tre Â«chemin d'accÃ¨s au fichierÂ» n'est pas toujours le meilleur choix pour votre mÃ©thode </h4><br>  Lors du dÃ©veloppement d'une API, Ã©vitez les signatures de mÃ©thode qui reÃ§oivent un chemin de fichier en entrÃ©e (pour un traitement ultÃ©rieur par votre mÃ©thode).  Au lieu de cela, donnez la possibilitÃ© de passer un tableau d'octets Ã  l'entrÃ©e, ou <b>en dernier recours</b> Stream.  Le fait est qu'au fil du temps, votre mÃ©thode peut Ãªtre appliquÃ©e non seulement Ã  un fichier du disque, mais aussi Ã  un fichier transfÃ©rÃ© sur le rÃ©seau, Ã  un fichier d'une archive, Ã  un fichier d'une base de donnÃ©es, Ã  un fichier dont le contenu est gÃ©nÃ©rÃ© dynamiquement en mÃ©moire, etc. e. En fournissant une mÃ©thode avec le paramÃ¨tre d'entrÃ©e "chemin de fichier", vous obligez l'utilisateur de votre API Ã  sauvegarder les donnÃ©es sur le disque avant de les relire.  Cette opÃ©ration sans signification affecte de maniÃ¨re critique les performances.  Un lecteur est une chose extrÃªmement lente.  Pour plus de commoditÃ©, vous pouvez fournir une mÃ©thode avec un paramÃ¨tre d'entrÃ©e "chemin vers un fichier", mais Ã  l'intÃ©rieur, utilisez toujours une mÃ©thode publique surchargÃ©e avec un tableau d'octets ou un flux Ã  l'entrÃ©e.  Il existe un Â«marqueurÂ» qui peut aider Ã  trouver des opÃ©rations d'Ã©criture / lecture de disque supplÃ©mentaires, essayez de trouver dans votre projet en utilisant des mÃ©thodes standard: <code>Path.GetTempPath()</code> et <code>Path.GetRandomFileName()</code> (de System.IO).  Avec un degrÃ© de probabilitÃ© Ã©levÃ©, vous rencontrerez une solution de contournement du problÃ¨me ci-dessus ou similaire. <br><br>  Un lecteur attentif et expÃ©rimentÃ© remarquera que dans certains cas, l'Ã©criture sur disque peut, au contraire, amÃ©liorer les performances, par exemple si nous avons affaire Ã  des fichiers trÃ¨s volumineux.  C'est vrai, il faut en tenir compte, mais je suppose que c'est une situation trÃ¨s rare avec une implÃ©mentation spÃ©cifique. <br><br><h4>  3. Ã‰vitez d'utiliser des threads comme paramÃ¨tres et le rÃ©sultat de retour de vos mÃ©thodes </h4><br>  Quel est le problÃ¨me ici ... lorsque nous obtenons un flux d'une certaine "boÃ®te noire", nous devons garder Ã  l'esprit son Ã©tat.  C'est-Ã -dire  Le flux est-il ouvert?  OÃ¹ est le marqueur de lecture / Ã©criture?  Son Ã©tat peut-il changer quel que soit notre code?  Si un flux est dÃ©clarÃ© en tant que classe de base de Stream, nous ne disposons mÃªme pas d'informations sur les opÃ©rations disponibles.  Tout cela est rÃ©solu par des vÃ©rifications supplÃ©mentaires, et c'est du code et des coÃ»ts supplÃ©mentaires.  De plus, je suis tombÃ© Ã  plusieurs reprises sur une situation oÃ¹, lors de la rÃ©ception de Stream d'une mÃ©thode Â«obscureÂ», le dÃ©veloppeur prÃ©fÃ©rait jouer en toute sÃ©curitÃ© et Â«transfÃ©rerÂ» les donnÃ©es de celui-ci vers un nouveau MemoryStream local complÃ¨tement contrÃ´lÃ©.  Bien que le flux source puisse Ãªtre assez sÃ»r.  Peut-Ãªtre mÃªme que c'Ã©tait dÃ©jÃ  gentiment prÃ©parÃ© pour lire MemoryStream.  Parfois, il peut atteindre le point d'absurditÃ© - Ã  l'intÃ©rieur d'une mÃ©thode, un tableau d'octets est placÃ© dans un MemoryStream, puis ce MemoryStream est renvoyÃ© comme rÃ©sultat d'une mÃ©thode dÃ©clarÃ©e comme un flux de base.  Ã€ l'extÃ©rieur, ce flux se transforme en un nouveau MemoryStream, puis ToArray () renvoie un tableau d'octets, que nous avions Ã  l'origine.  Plus prÃ©cisÃ©ment, ce sera sa prochaine copie.  L'ironie est qu'Ã  l'intÃ©rieur et Ã  l'extÃ©rieur de notre mÃ©thode, le code est complÃ¨tement correct.  Ã€ mon avis, cet exemple n'est pas sorti de ma tÃªte, mais a Ã©tÃ© trouvÃ© quelque part dans le code commercial. <br><br>  Par consÃ©quent, si vous avez la possibilitÃ© d'envoyer / recevoir des donnÃ©es "propres", n'utilisez pas de flux pour cela - ne crÃ©ez pas de piÃ¨ges pour ceux qui les utiliseront.  Si votre application dispose dÃ©jÃ  d'un flux de transfert / retour, analysez leur utilisation en fonction de ce qui prÃ©cÃ¨de. <br><br><h4>  4. HÃ©ritage des Ã©numÃ©rations </h4><br>  Cette optimisation est courante, tout le monde le sait, mÃªme les Ã©tudiants.  Mais d'aprÃ¨s mon expÃ©rience, il est extrÃªmement rarement utilisÃ©.  Donc, par dÃ©faut, enum hÃ©rite de int.  Cependant, il peut Ãªtre hÃ©ritÃ© de l'octet, qui contient 256 valeurs (ou 8 valeurs Â«flaggablesÂ»).  Ce qui couvre presque toujours la fonctionnalitÃ© de l'Ã©numÃ©ration Â«intermÃ©diaireÂ».  Un changement minimal dans le code et toutes les valeurs de votre Ã©numÃ©ration prennent moins de mÃ©moire pour toujours.  Vous trouverez ci-dessous une illustration d'une rÃ©fÃ©rence pour remplir une collection avec des valeurs d'Ã©numÃ©ration hÃ©ritÃ©es de int et byte. <br><br><img src="https://habrastorage.org/webt/e-/ir/q2/e-irq2g_r9iorxjbadfqyxuc9ei.png"><br><br><div class="spoiler">  <b class="spoiler_title">Code de rÃ©fÃ©rence</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectEnums</span></span> { [Params(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromInt[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromInt[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromInt[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromInt.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromByte[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromByte[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromByte[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromByte.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromInt { Value1, Value2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromByte: <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> { Value1, Value2 }</code> </pre> <br></div></div><br><h4>  5. Encore quelques mots sur les classes Array et List </h4><br>  Suivant la logique, l'itÃ©ration sur un tableau est toujours plus efficace que l'itÃ©ration sur une Â«feuilleÂ», car une Â«feuilleÂ» est un wrapper sur un tableau.  En outre, selon la logique, Â«forÂ» est toujours plus rapide que Â«foreachÂ», car Â«foreachÂ» effectue un grand nombre des actions requises par la mise en Å“uvre de l'interface IEnumerable.  Tout est logique ici, mais faux!  Jetons un coup d'Å“il aux rÃ©sultats de rÃ©fÃ©rence: <br><br><img src="https://habrastorage.org/webt/p7/7z/ih/p77zihj1drhzs84wcik9vtyq4qg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Code de rÃ©fÃ©rence</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IterationBenchmark</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _list; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] _array; [Params(<span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">10000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [GlobalSetup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MIN = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX = <span class="hljs-number"><span class="hljs-number">10</span></span>; Random rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); _list = Enumerable.Repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, N).Select(i =&gt; rnd.Next(MIN, MAX)).ToList(); _array = _list.ToArray(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list.Count; i++) { total += _list[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _list) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _array) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _array.Length; i++) { total += _array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } }</code> </pre> <br></div></div><br>  Le fait est que pour itÃ©rer sur un tableau, Â«foreachÂ» n'utilise pas une implÃ©mentation IEnumerable.  Dans ce cas particulier, l'itÃ©ration la plus optimisÃ©e par index est effectuÃ©e, sans vÃ©rifier les limites du tableau, car la construction Â«foreachÂ» ne fonctionne pas avec les index, donc le dÃ©veloppeur n'a pas la possibilitÃ© de Â«foirerÂ» le code.  Telle est l'exception Ã  la rÃ¨gle.  Par consÃ©quent, si dans une section critique du code vous avez remplacÃ© l'utilisation de Â«foreachÂ» par Â«forÂ» dans un souci d'optimisation, vous vous Ãªtes tirÃ© une balle dans le pied.  Veuillez noter que cela n'est pertinent <b>que pour les tableaux</b> .  Il y a plusieurs branches sur StackOverflow oÃ¹ cette fonctionnalitÃ© est discutÃ©e. <br><br><h4>  6. La recherche dans une table de hachage est-elle toujours justifiÃ©e? </h4><br>  Tout le monde sait que les tables de hachage sont trÃ¨s efficaces pour la recherche.  Mais ils oublient souvent que le prix d'une recherche rapide est un ajout lent Ã  la table de hachage.  Qu'est-ce qui en dÃ©coule?  Pour que l'utilisation de la table de hachage soit justifiÃ©e, il est nÃ©cessaire que le nombre d'Ã©lÃ©ments de table de hachage soit d'au moins 8 (environ).  Et pour que le nombre d'opÃ©rations de recherche soit au moins d'un ordre de grandeur supÃ©rieur au nombre d'opÃ©rations d'ajout.  Sinon, utilisez une collection plus simple.  La qualitÃ© de la fonction de hachage fera ses propres ajustements Ã  l'efficacitÃ©, mais la signification de cela ne changera pas.  Dans ma pratique, il y avait un cas oÃ¹ le plus de goulot d'Ã©tranglement dans le code chargÃ© appelait la mÃ©thode Dictionary.Add ().  La clÃ© Ã©tait une chaÃ®ne rÃ©guliÃ¨re, de courte longueur.  Se souvenir de cela et est devenu un dÃ©clencheur pour Ã©crire ce paragraphe.  Pour illustrer, un exemple de trÃ¨s mauvais code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberStr</span></span></span><span class="hljs-function">)</span></span> { Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"One"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} }; dictionary.TryGetValue(numberStr, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Peut-Ãªtre que quelque chose de similaire se produit dans votre projet? <br><br><h4>  7. MÃ©thodes d'intÃ©gration </h4><br>  Le code est divisÃ© en mÃ©thodes le plus souvent pour 2 raisons.  Assurez la rÃ©utilisation et la dÃ©composition du code lorsqu'une tÃ¢che est divisÃ©e en plusieurs sous-tÃ¢ches.  Câ€™est plus facile pour une personne.  L'intÃ©gration est le processus inverse de dÃ©composition, c'est-Ã -dire  le code de la mÃ©thode est incorporÃ© Ã  l'endroit oÃ¹ la mÃ©thode doit Ãªtre appelÃ©e; en consÃ©quence, nous Ã©conomisons sur la pile d'appels et en passant les paramÃ¨tres.  Je ne recommande en aucun cas de tout mettre dans une seule mÃ©thode.  Mais ces mÃ©thodes que nous pourrions thÃ©oriquement Â«inlineÂ» peuvent Ãªtre marquÃ©es avec l'attribut correspondant: <br><br><pre> <code class="plaintext hljs">[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> </pre> <br>  Cet attribut indiquera au systÃ¨me que cette mÃ©thode peut Ãªtre intÃ©grÃ©e.  Cela ne signifie pas que la mÃ©thode marquÃ©e avec cet attribut sera nÃ©cessairement intÃ©grÃ©e.  Par exemple, il n'est pas possible d'incorporer des mÃ©thodes rÃ©cursives ou virtuelles.  Il convient Ã©galement de noter que le mÃ©canisme d'ancrage est extrÃªmement Â«dÃ©licatÂ».  Il existe de nombreuses autres raisons pour lesquelles le systÃ¨me refusera d'intÃ©grer votre mÃ©thode.  Cependant, l'Ã©quipe Microsoft travaillant sur .NET Core utilise activement cet attribut.  Le code source de .NET Core contient de nombreux exemples de son utilisation. <br><br><h4>  8. CapacitÃ© estimÃ©e </h4><br>  J'ai (et j'espÃ¨re que la plupart des dÃ©veloppeurs aussi) ai dÃ©veloppÃ© un rÃ©flexe: j'ai initialisÃ© la collection - je me suis demandÃ© s'il Ã©tait possible de dÃ©finir Capacity pour cela.  Cependant, le nombre exact d'Ã©lÃ©ments de collection n'est pas toujours connu Ã  l'avance.  Mais ce n'est pas une raison pour ignorer ce paramÃ¨tre.  Par exemple, si, en parlant du nombre d'articles qui seront dans votre collection, vous supposez un Â«couple de milliersÂ» flou, c'est l'occasion de dÃ©finir la capacitÃ© Ã  1000. Une petite thÃ©orie, par exemple, pour Liste par dÃ©faut, CapacitÃ© = 16, de sorte que seulement atteindre 1000, le systÃ¨me fera 1008 (16 + 32 + 64 + 128 + 256 + 512) copies supplÃ©mentaires des Ã©lÃ©ments et crÃ©era 7 tableaux temporaires Ã  la merci du prochain appel GC.  C'est-Ã -dire  tout ce travail sera gaspillÃ©.  De plus, en tant que CapacitÃ©, personne n'interdit d'utiliser la formule.  Si la taille de votre collection est estimÃ©e Ã  un tiers de l'autre collection, vous pouvez dÃ©finir une capacitÃ© Ã©gale Ã  otherCollection.Count / 3. Lorsque vous dÃ©finissez la capacitÃ©, il est bon de comprendre la plage de la taille possible de la collection et le degrÃ© de distribution de sa valeur.  Il y a toujours un risque de dommage, mais s'il est utilisÃ© correctement, une capacitÃ© estimÃ©e vous donnera une bonne victoire. <br><br><h4>  9. SpÃ©cifiez toujours votre code. </h4><br>  Utilisez activement (Ã  premiÃ¨re vue, facultatif) des mots clÃ©s C #, tels que: statique, const, en lecture seule, scellÃ©, abstrait, etc.  Naturellement, lÃ  oÃ¹ ils ont du sens.  Et voici la performance?  Le fait est que plus vous dÃ©crivez votre systÃ¨me au compilateur, plus le code qu'il peut gÃ©nÃ©rer est optimal.  Un lecteur attentif et expÃ©rimentÃ© peut remarquer que, par exemple, le mot clÃ© scellÃ© n'a aucun effet sur les performances.  Maintenant, c'est vrai, mais dans les versions futures, tout peut changer.  Donnez une chance au compilateur et Ã  la machine virtuelle!  Obtenez un bonus, identifiant de nombreuses erreurs d'utilisation incorrecte de votre code au stade de la compilation.  RÃ¨gle gÃ©nÃ©rale: plus le systÃ¨me est dÃ©crit clairement, plus le rÃ©sultat est optimal.  Apparemment, avec des gens aussi. <br><br><div class="spoiler">  <b class="spoiler_title">La vraie histoire confirme cette rÃ¨gle, mais si vous lisez la paresse, vous pouvez sauter</b> <div class="spoiler_text">  Une nuit, alors qu'il Ã©tait engagÃ© dans son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">projet de passe-temps</a> , il s'est donnÃ© pour tÃ¢che d'augmenter les performances d'une section de code au-dessus d'un certain niveau.  Mais ce site Ã©tait court et il y avait peu d'options pour en faire quoi.  J'ai trouvÃ© dans la documentation qu'Ã  partir de la version C # 7.2, le mot-clÃ© "readonly" peut Ãªtre utilisÃ© pour les structures.  Et dans mon cas, des structures immuables ont Ã©tÃ© utilisÃ©es, en ajoutant un seul mot Â«en lecture seuleÂ», j'ai obtenu ce que je voulais, mÃªme avec une marge!  Le systÃ¨me, sachant que mes structures ne sont pas destinÃ©es Ã  Ãªtre modifiÃ©es, a pu gÃ©nÃ©rer un meilleur code pour mon cas. <br></div></div><br><h4>  10. Si possible, utilisez une version de .NET pour tous les projets de solution </h4><br>  Vous devez vous assurer que tous les assemblys de votre application appartiennent Ã  la mÃªme version de .NET.  Cela s'applique aux packages NuGet (modifiÃ©s dans packages.config / json) et Ã  vos propres assemblys (modifiÃ©s dans les propriÃ©tÃ©s du projet).  Cela permettra d'Ã©conomiser de la RAM et d'accÃ©lÃ©rer le dÃ©marrage "Ã  froid", car dans la mÃ©moire de votre application, il n'y aura pas de copies des mÃªmes bibliothÃ¨ques pour diffÃ©rentes versions de .NET.  Il convient de noter que dans tous les cas, diffÃ©rentes versions de .NET gÃ©nÃ¨rent des copies en mÃ©moire.  Mais supposons qu'une application construite sur la mÃªme version de .NET soit toujours meilleure.  En outre, cela Ã©limine un certain nombre de problÃ¨mes potentiels qui n'entrent pas dans le cadre de cet article.  La consolidation des versions de tous les packages NuGet que vous utilisez contribuera Ã©galement Ã  amÃ©liorer les performances de votre application. <br><br><h4>  Quelques outils utiles </h4><br>  <b>ILSpy</b> est un outil gratuit qui vous permet de visualiser le code source de l'assembly restaurÃ©.  Si j'ai une question sur le mÃ©canisme .NET le plus efficace, j'ouvre d'abord ILSpy (et non Google ou StackOverflow), et dÃ©jÃ  lÃ , je vois comment il est mis en Å“uvre.  Par exemple, pour savoir ce qui est le mieux utilisÃ© en termes de performances pour recevoir des donnÃ©es sur HTTP, la classe HttpWebRequest ou WebClient, il suffit de regarder leur implÃ©mentation via ILSpy.  Dans ce cas particulier, WebClient est un wrapper sur HttpWebRequest, respectivement, la rÃ©ponse est Ã©vidente.  Les codes source .NET ne valent pas la peine, ils sont Ã©crits par les mÃªmes programmeurs ordinaires. <br><br>  <b>BenchmarkDotNet</b> est une bibliothÃ¨que gratuite de benchmarks.  Il existe un chronomÃ¨tre simple et intuitif (de System.Diagnostics).  Mais parfois, cela ne suffit pas.  Comme dans le bon sens il faut prendre en compte non pas un seul rÃ©sultat, mais la moyenne de plusieurs comparaisons, il vaut mieux comparer leur mÃ©diane afin de minimiser l'influence de l'OS.  En outre, vous devez prendre en compte le "dÃ©marrage Ã  froid" et la quantitÃ© de mÃ©moire allouÃ©e.  Pour ces tests complexes, BenchmarkDotNet a Ã©tÃ© crÃ©Ã©.  C'est cette bibliothÃ¨que que les dÃ©veloppeurs .NET Core utilisent dans les tests officiels.  La bibliothÃ¨que est facile Ã  utiliser, mais si ses auteurs lisent soudainement cet article, donnez-leur une opportunitÃ© plus pratique d'influencer la structure du tableau des rÃ©sultats. <br><br>  <b>U2U Consult Performance Analyzers</b> est un plug-in gratuit pour Visual Studio qui fournit des conseils sur l'amÃ©lioration du code en termes de performances.  100% se fier aux conseils de cet analyseur n'en vaut pas la peine.  Depuis que je suis tombÃ© sur une situation oÃ¹ un conseil m'a un peu surpris et aprÃ¨s une analyse dÃ©taillÃ©e, il s'est avÃ©rÃ© vraiment erronÃ©.  Malheureusement, cet exemple est perdu, alors prenez un mot.  Cependant, si vous l'utilisez judicieusement, c'est un outil trÃ¨s utile.  Par exemple, il suggÃ©rera qu'au lieu de <code>myStr.Replace("*", "-")</code> plus efficace d'utiliser <code>myStr.Replace('*', '-')</code> .  Et les deux expressions Where dans LINQ sont mieux combinÃ©es en une seule.  Ce sont tous des Â«optimisations sur les correspondancesÂ», mais elles sont faciles Ã  appliquer et n'entraÃ®nent pas une augmentation du code / de la complexitÃ©. <br><br><h4>  En conclusion </h4><br>  Si chaque 10e personne qui lit l'article applique les approches ci-dessus Ã  son projet actuel (ou une partie critique de celui-ci), et adhÃ¨re Ã©galement Ã  ces approches Ã  l'avenir, alors ensemble, nous pouvons sauver toute la forÃªt!  ForÃªt ???  C'est-Ã -dire  les ressources Ã©conomisÃ©es des systÃ¨mes informatiques, sous forme d'Ã©lectricitÃ© obtenue Ã  partir de la combustion du bois, resteront inutilisÃ©es.  Dans ce cas, la Â«forÃªtÂ» n'est qu'une sorte d'Ã©quivalent.  Une conclusion Ã©trange est probablement sortie, mais j'espÃ¨re que cette pensÃ©e vous a inspirÃ©. <br><br><h4>  Mise Ã  jour PS basÃ©e sur les commentaires de publication </h4><br>  L'avantage de ToArray sur ToList est pertinent pour .NET Core.  Mais si vous utilisez l'ancien .NET Framework, ToList sera probablement prÃ©fÃ©rable pour vous.  Le problÃ¨me est que dans le .NET Framework, l'appel ToArray lui-mÃªme est beaucoup plus lent que l'appel ToList.  Et ces pertes peuvent ne pas Ãªtre compensÃ©es par des accÃ¨s plus rapides aux Ã©lÃ©ments et moins de stockage en baie.  En gÃ©nÃ©ral, ce problÃ¨me s'est avÃ©rÃ© plus compliquÃ©, car diffÃ©rentes classes implÃ©mentant IEnumerable peuvent avoir diffÃ©rentes implÃ©mentations de ToArray et ToList, avec diffÃ©rents niveaux d'efficacitÃ©. <br><br>  Si l'Ã©numÃ©ration hÃ©ritÃ©e de l'octet est utilisÃ©e en tant que membre d'une classe (structure), et non sÃ©parÃ©ment, il peut ne pas y avoir d'Ã©conomie de mÃ©moire.  En raison de l'alignement de la mÃ©moire occupÃ©e de tous les membres de la classe (structure).  Ce point manque dans l'article.  NÃ©anmoins, le gain potentiel est meilleur que son absence, car en plus de la mÃ©moire occupÃ©e, des Ã©numÃ©rations sont Ã©galement utilisÃ©es.  Par consÃ©quent, le paragraphe 4 est toujours pertinent, mais avec cette importante rÃ©serve. <br><br>  Merci Ã  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">KvanTTT</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">epetrukhin</a> pour leurs commentaires constructifs sur ces questions. <br><br>  En outre, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Taritsyn l'a</a> notÃ©, l'optimisation au stade de la compilation JIT pour le mot clÃ© "scellÃ©" existe toujours.  Mais cela ne fait que confirmer toutes les thÃ¨ses du 9Ã¨me paragraphe. <br><br>  Il semble que tous les commentaires constructifs aient Ã©tÃ© pris en compte.  Je suis trÃ¨s satisfait de ces commentaires.  Depuis que moi-mÃªme, en tant qu'auteur, j'ai reÃ§u un retour et j'ai aussi appris quelque chose de nouveau pour moi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466931/">https://habr.com/ru/post/fr466931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466917/index.html">Lorsque la norme HTTP ne suffit pas. Micronaut s'engage</a></li>
<li><a href="../fr466921/index.html">5 problÃ¨mes de toute entreprise de services et leur solution en utilisant la plate-forme d'automatisation</a></li>
<li><a href="../fr466923/index.html">Comment les professionnels de l'informatique dans une banque Ã©trangÃ¨re pour prouver l'origine des fonds</a></li>
<li><a href="../fr466925/index.html">Comment exÃ©cuter Hi-CPU VDS pour Bitrix, disperser les perroquets et ne pas faire faillite</a></li>
<li><a href="../fr466929/index.html">Ajouter un jeton d'actualisation</a></li>
<li><a href="../fr466933/index.html">Comment se faire des amis dans l'industrie et le Big Data</a></li>
<li><a href="../fr466937/index.html">Comment nous organisons l'Olympiade en ligne panrusse en anglais, en mathÃ©matiques et en informatique</a></li>
<li><a href="../fr466941/index.html">Pourquoi Windows lit-il un fichier cent mille fois pour ouvrir un menu?</a></li>
<li><a href="../fr466949/index.html">Perspectives pour les rÃ©seaux quantiques: qui s'y engage et pourquoi</a></li>
<li><a href="../fr466955/index.html">Ã‰nigmes du CV. Partie 3. Le voile des secrets enlevÃ©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>