<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëö üë©üèº‚Äç‚öïÔ∏è „Ä∞Ô∏è Einfache Methoden zur Optimierung von Go-Programmen üßñüèø üòµ ‚ò¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Leistung ist mir immer wichtig. Ich wei√ü nicht genau warum. Aber ich bin nur sauer auf langsame Dienste und Programme. Sieht so aus, als w√§re ich nich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfache Methoden zur Optimierung von Go-Programmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457004/">  Leistung ist mir immer wichtig.  Ich wei√ü nicht genau warum.  Aber ich bin nur sauer auf langsame Dienste und Programme.  Sieht so aus, als w√§re <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich nicht allein</a> . <br><br><blockquote>  <i>In den A / B-Tests haben wir versucht, die Ausgabe von Seiten in Schritten von 100 Millisekunden zu verlangsamen, und festgestellt, dass selbst sehr kleine Verz√∂gerungen zu einem erheblichen Umsatzr√ºckgang f√ºhren.</i>  - Greg Linden, Amazon.com </blockquote><br>  Erfahrungsgem√§√ü zeigt sich eine geringe Produktivit√§t auf zwei Arten: <br><br><ul><li>  Vorg√§nge, die im kleinen Ma√üstab gut funktionieren, werden mit zunehmender Anzahl von Benutzern unrentabel.  Normalerweise sind dies O (N) - oder O (N¬≤) -Operationen.  Wenn die Benutzerbasis klein ist, funktioniert alles einwandfrei.  Das Produkt hat es eilig, auf den Markt zu bringen.  Wenn die Basis w√§chst, treten immer mehr unerwartete pathologische Situationen auf - und der Dienst stoppt. <br></li><li> Viele einzelne Quellen suboptimaler Arbeit, "Tod durch tausend Schnitte". </li></ul><a name="habracut"></a><br>  W√§hrend des gr√∂√üten Teils meiner Karriere habe ich entweder Data Science bei Python studiert oder Services on Go erstellt.  Im zweiten Fall habe ich viel mehr Erfahrung in der Optimierung.  Go ist normalerweise kein Engpass bei den von mir geschriebenen Diensten - Datenbankprogramme werden h√§ufig durch E / A eingeschr√§nkt.  In den von mir entwickelten Batch-Pipelines f√ºr maschinelles Lernen ist das Programm jedoch h√§ufig durch die CPU begrenzt.  Wenn Go den Prozessor zu oft verwendet, gibt es verschiedene Strategien. <br><br>  In diesem Artikel werden einige Methoden erl√§utert, mit denen die Produktivit√§t ohne gro√üen Aufwand erheblich gesteigert werden kann.  Ich ignoriere bewusst Methoden, die erheblichen Aufwand oder gro√üe √Ñnderungen in der Struktur des Programms erfordern. <br><br><h1>  Bevor Sie anfangen </h1><br>  Nehmen Sie sich Zeit, um eine geeignete Basislinie f√ºr den Vergleich zu erstellen, bevor Sie √Ñnderungen am Programm vornehmen.  Wenn Sie dies nicht tun, wandern Sie im Dunkeln und fragen sich, ob die vorgenommenen √Ñnderungen von Nutzen sind.  Schreiben Sie zun√§chst Benchmarks und nehmen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Profile</a> zur Verwendung in pprof.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schreiben Sie den Benchmark am</a> besten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch auf Go</a> : Dies erleichtert die Verwendung von pprof und des Profilspeichers.  Verwenden Sie auch Benchcmp: ein n√ºtzliches Tool zum Vergleichen von Leistungsunterschieden zwischen Tests. <br><br>  Wenn der Code nicht sehr gut mit Benchmarks kompatibel ist, beginnen Sie einfach mit etwas, das gemessen werden kann.  Sie k√∂nnen den Code manuell mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">runtime / pprof profilieren</a> . <br><br>  Also fangen wir an! <br><br><h3>  Verwenden Sie sync.Pool, um zuvor ausgew√§hlte Objekte wiederzuverwenden </h3><br>  sync.Pool implementiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Versionsliste.  Auf diese Weise k√∂nnen Sie zuvor zugewiesene Strukturen wiederverwenden und die Verteilung des Objekts √ºber viele Verwendungszwecke amortisieren, wodurch die Arbeit des Garbage Collectors reduziert wird.  Die API ist sehr einfach.  Implementieren Sie eine Funktion, die eine neue Instanz eines Objekts zuweist.  Die API gibt den Zeigertyp zur√ºck. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bufpool = sync.Pool{ New: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;buf }}</code> </pre> <br>  Danach k√∂nnen Sie <code>Get()</code> -Objekte aus dem Pool <code>Put()</code> und sie zur√ºcksetzen, wenn Sie fertig sind. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sync.Pool returns a interface{}: you must cast it to the underlying type // before you use it. b := *bufpool.Get().(*[]byte) defer bufpool.Put(&amp;b) // Now, go do interesting things with your byte buffer. buf := bytes.NewBuffer(b)</span></span></code> </pre> <br>  Es gibt Nuancen.  Vor Go 1.13 wurde der Pool bei jeder Speicherbereinigung gel√∂scht.  Dies kann die Leistung von Programmen beeintr√§chtigen, die viel Speicher zuweisen.  Ab 1.13 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scheinen nach dem GC mehr Objekte zu √ºberleben</a> . <br><br>  <b>!!!</b>  <b>Stellen Sie vor dem Zur√ºckgeben eines Objekts an den Pool sicher, dass Sie die Strukturfelder zur√ºcksetzen.</b> <br><br>  Wenn Sie dies nicht tun, k√∂nnen Sie ein schmutziges Objekt aus dem Pool abrufen, das Daten aus der vorherigen Verwendung enth√§lt.  Dies ist ein ernstes Sicherheitsrisiko! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AuthenticationResponse { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } rsp := authPool.Get().(*AuthenticationResponse) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> authPool.Put(rsp) <span class="hljs-comment"><span class="hljs-comment">// If we don't hit this if statement, we might return data from other users! if blah { rsp.UserID = "user-1" rsp.Token = "super-secret" } return rsp</span></span></code> </pre> <br>  Ein sicherer Weg, um immer null Speicher zu garantieren, besteht darin, dies explizit zu tun: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// reset resets all fields of the AuthenticationResponse before pooling it. func (a* AuthenticationResponse) reset() { a.Token = "" a.UserID = "" } rsp := authPool.Get().(*AuthenticationResponse) defer func() { rsp.reset() authPool.Put(rsp) }()</span></span></code> </pre> <br>  Der einzige Fall, in dem dies kein Problem darstellt, besteht darin, dass Sie genau den Speicher verwenden, in den Sie geschrieben haben.  Zum Beispiel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( r io.Reader w io.Writer ) <span class="hljs-comment"><span class="hljs-comment">// Obtain a buffer from the pool. buf := *bufPool.Get().(*[]byte) defer bufPool.Put(&amp;buf) // We only write to w exactly what we read from r, and no more. nr, er := r.Read(buf) if nr &gt; 0 { nw, ew := w.Write(buf[0:nr]) }</span></span></code> </pre> <br><h3>  Vermeiden Sie die Verwendung von Strukturen mit Zeigern als Schl√ºssel f√ºr eine gro√üe Karte </h3><br>  Fuh, ich war zu wortreich.  Ich bitte um Entschuldigung.  Sie sprachen oft (einschlie√ülich meines ehemaligen Kollegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phil Pearl</a> ) √ºber die Go-Leistung mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üen Heap-Gr√∂√üe</a> .  W√§hrend der Speicherbereinigung durchsucht die Laufzeit Objekte mit Zeigern und verfolgt sie.  Wenn Sie eine sehr gro√üe Map <code>map[string]int</code> , sollte GC jede Zeile √ºberpr√ºfen.  Dies geschieht bei jeder Speicherbereinigung, da die Zeilen Zeiger enthalten. <br><br>  In diesem Beispiel schreiben wir 10 Millionen Elemente, <code>map[string]int</code> und die Dauer der Speicherbereinigung zu messen.  Wir ordnen unsere Karte im Paketbereich zu, um die Speicherzuordnung vom Heap zu gew√§hrleisten. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[strconv.Itoa(i)] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Wenn Sie das Programm ausf√ºhren, sehen Sie Folgendes: <br><br><pre>  inthash ‚Üí gehe installieren &amp;&amp; inthash
 gc dauerte: 98,726321 ms
 gc dauerte: 105,524633 ms
 gc dauerte: 102,829451ms
 gc dauerte: 102,71908 ms
 gc dauerte: 103.084104ms
 gc dauerte: 104,821989 ms </pre><br>  Dies ist eine ziemlich lange Zeit in einem Computerland! <br><br>  Was kann zur Optimierung getan werden?  Das Entfernen von Zeigern √ºberall ist eine gute Idee, um den Garbage Collector nicht zu laden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es gibt Zeiger in den Zeilen</a> ;  Implementieren wir dies also als <code>map[int]int</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[i] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Wenn Sie das Programm erneut ausf√ºhren, sehen Sie: <br><br><pre>  inthash ‚Üí gehe installieren &amp;&amp; inthash
 gc dauerte: 3.608993ms
 gc dauerte: 3,926913ms
 gc dauerte: 3,955706ms
 gc dauerte: 4.063795ms
 gc dauerte: 3.91519ms
 gc dauerte: 3,75226ms </pre><br>  Viel besser.  Wir haben die Speicherbereinigung um das 35-fache beschleunigt.  Bei der Verwendung in der Produktion m√ºssen die Zeichenfolgen vor dem Einsetzen in die Karte in Ganzzahlen gehasht werden. <br><br>  √úbrigens gibt es noch viele weitere M√∂glichkeiten, GC zu vermeiden.  Wenn Sie gigantische Arrays bedeutungsloser Strukturen, Ints oder Bytes zuweisen, scannt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GC dies nicht. Das</a> hei√üt, Sie sparen GC-Zeit.  Solche Methoden erfordern normalerweise eine umfassende √úberarbeitung des Programms, daher werden wir uns heute nicht mit diesem Thema befassen. <br><br>  Wie bei jeder Optimierung kann der Effekt variieren.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tweets-Thread von Damian Gryski finden Sie</a> ein interessantes Beispiel daf√ºr, wie das L√∂schen von Zeilen aus einer gro√üen Karte zugunsten einer intelligenteren Datenstruktur <i>den</i> Speicherverbrauch tats√§chlich <i>erh√∂ht</i> .  Lesen Sie im Allgemeinen alles, was er ver√∂ffentlicht. <br><br><h3>  Marshaling-Codegenerierung zur Vermeidung von Laufzeitreflexionen </h3><br>  Das Marshalling und Unmarshaling Ihrer Struktur in verschiedene Serialisierungsformate wie JSON ist ein typischer Vorgang, insbesondere beim Erstellen von Microservices.  F√ºr viele Microservices ist dies im Allgemeinen die einzige Aufgabe.  Funktionen wie <code>json.Marshal</code> und <code>json.Unmarshal</code> auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflexion in der Laufzeit,</a> um Strukturfelder in Bytes zu serialisieren und umgekehrt.  Dies kann langsam funktionieren: Reflexion ist nicht so effizient wie expliziter Code. <br><br>  Es gibt jedoch Optimierungsoptionen.  Die JSON-Marshalling-Mechanik sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="json hljs">package json // Marshal take an object and returns its representation in JSON. func Marshal(obj interface{}) ([]byte, error) { // Check if this object knows how to marshal itself to JSON // by satisfying the Marshaller interface. if m, is := obj.(json.Marshaller); is { return m.MarshalJSON() } // It doesn't know how to marshal itself. Do default reflection based marshallling. return marshal(obj) }</code> </pre> <br>  Wenn wir den Marshalling-Prozess in JSON kennen, haben wir einen Hinweis, um eine Reflexion in der Laufzeit zu vermeiden.  Wir m√∂chten jedoch nicht den gesamten Marshalling-Code manuell schreiben. Was sollen wir also tun?  Lassen Sie den Computer diesen Code generieren!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codegeneratoren</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">easyjson</a> betrachten die Struktur und generieren hochoptimierten Code, der vollst√§ndig mit vorhandenen Marshalling-Schnittstellen wie <code>json.Marshaller</code> . <br><br>  Laden Sie das Paket herunter und schreiben Sie den folgenden Befehl in <code>$file.go</code> , der die Strukturen enth√§lt, f√ºr die Sie Code generieren m√∂chten. <br><br><pre>  easyjson -all $ file.go </pre><br>  Die Datei <code>$file_easyjson.go</code> sollte generiert werden.  Da <code>easyjson</code> die <code>json.Marshaller</code> Schnittstelle f√ºr Sie <code>easyjson</code> , werden diese Funktionen standardm√§√üig anstelle von Reflection aufgerufen.  Herzlichen Gl√ºckwunsch: Sie haben Ihren JSON-Code gerade dreimal beschleunigt.  Es gibt viele Tricks, um die Produktivit√§t weiter zu steigern. <br><br>  Ich empfehle dieses Paket, weil ich es zuvor selbst und erfolgreich verwendet habe.  Aber sei vorsichtig.  Bitte nehmen Sie dies nicht als Einladung, mit mir aggressive Debatten √ºber die schnellsten JSON-Pakete zu beginnen. <br><br>  Stellen Sie sicher, dass Sie den Marshalling-Code neu generieren, wenn sich die Struktur √§ndert.  Wenn Sie dies vergessen, werden die neu hinzugef√ºgten Felder nicht serialisiert, was zu Verwirrung f√ºhren kann!  Sie k√∂nnen <code>go generate</code> f√ºr diese Aufgaben verwenden.  Um die Synchronisation mit den Strukturen aufrechtzuerhalten, platziere ich <code>generate.go</code> lieber im Stammverzeichnis des Pakets, wodurch alle Paketdateien <code>go generate</code> werden. Dies kann hilfreich sein, wenn Sie viele Dateien haben, die solchen Code generieren m√ºssen.  Der Haupttipp: Um sicherzustellen, dass die Strukturen aktualisiert werden, rufen Sie <code>go generate</code> in CI auf und pr√ºfen Sie, ob es keinen Unterschied zum registrierten Code gibt. <br><br><h3>  Verwenden Sie strings.Builder, um Zeichenfolgen zu erstellen </h3><br>  In Go sind Zeichenfolgen unver√§nderlich: Stellen Sie sie sich als schreibgesch√ºtzte Bytes vor.  Dies bedeutet, dass Sie jedes Mal, wenn Sie eine Zeichenfolge erstellen, Speicher zuweisen und m√∂glicherweise mehr Arbeit f√ºr den Garbage Collector erstellen. <br><br>  Go 1.10 implementierte Strings. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Builder</a> als effiziente Methode zum Erstellen von Strings.  Intern schreibt es in einen Bytepuffer.  Nur beim Aufrufen von <code>String()</code> im Builder wird tats√§chlich ein String erstellt.  Er st√ºtzt sich auf einige unsichere Tricks, um die zugrunde liegenden Bytes als Zeichenfolge mit einer Nullzuweisung zur√ºckzugeben: Weitere Studien dazu finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Blog</a> . <br><br>  Vergleichen Sie die Leistung der beiden Ans√§tze: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import "strings" var strs = []string{ "here's", "a", "some", "long", "list", "of", "strings", "for", "you", } func buildStrNaive() string { var s string for _, v := range strs { s += v } return s } func buildStrBuilder() string { b := strings.Builder{} // Grow the buffer to a decent length, so we don't have to continually // re-allocate. b.Grow(60) for _, v := range strs { b.WriteString(v) } return b.String() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var str string func BenchmarkStringBuildNaive(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrNaive() } } func BenchmarkStringBuildBuilder(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrBuilder() }</span></span></code> </pre> <br>  Hier sind die Ergebnisse auf meinem Macbook Pro: <br><br><pre>  strbuild -&gt; go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strbuild
 BenchmarkStringBuildNaive-8 5.000.000 255 ns / op 216 B / op 8 Allokationen / op
 BenchmarkStringBuildBuilder-8 20.000.000 54,9 ns / op 64 B / op 1 Allokationen / op </pre><br>  Wie Sie sehen k√∂nnen, ist <code>strings.Builder</code> 4,7-mal schneller, verursacht achtmal weniger Zuweisungen und ben√∂tigt viermal weniger Speicher. <br><br>  Wenn Leistung wichtig ist, verwenden Sie <code>strings.Builder</code> .  Im Allgemeinen empfehle ich, es √ºberall zu verwenden, au√üer in den trivialsten F√§llen, in denen Zeichenfolgen erstellt werden. <br><br><h3>  Verwenden Sie strconv anstelle von fmt </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fmt</a> ist eines der bekanntesten Pakete in Go.  Sie haben es wahrscheinlich in Ihrem ersten Programm verwendet, um "Hallo Welt" anzuzeigen.  Aber wenn es darum geht, ganze Zahlen und Floats in Strings umzuwandeln, ist es nicht so effizient wie sein j√ºngerer Bruder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strconv</a> .  Dieses Paket zeigt eine anst√§ndige Leistung mit sehr wenigen √Ñnderungen an der API. <br><br>  <code>fmt</code> grunds√§tzlich die <code>interface{}</code> als Funktionsargumente.  Es gibt zwei Nachteile: <br><br><ul><li>  Sie verlieren die Typensicherheit.  F√ºr mich ist es sehr wichtig. <br></li><li>  Dies kann die Menge der ben√∂tigten Sekrete erh√∂hen.  Das √úbergeben eines Typs ohne Zeiger als <code>interface{}</code> normalerweise zu einer Heap-Zuordnung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Blog-Beitrag</a> erkl√§rt, warum dies so ist. </li><li>  Das folgende Programm zeigt den Leistungsunterschied: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import ( "fmt" "strconv" ) func strconvFmt(a string, b int) string { return a + ":" + strconv.Itoa(b) } func fmtFmt(a string, b int) string { return fmt.Sprintf("%s:%d", a, b) } func main() {}</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var ( a = "boo" blah = 42 box = "" ) func BenchmarkStrconv(b *testing.B) { for i := 0; i &lt; bN; i++ { box = strconvFmt(a, blah) } a = box } func BenchmarkFmt(b *testing.B) { for i := 0; i &lt; bN; i++ { box = fmtFmt(a, blah) } a = box }</span></span></code> </pre> <br>  Benchmarks auf Macbook Pro: <br><br><pre>  strfmt ‚Üí go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strfmt
 BenchmarkStrconv-8 30.000.000 39,5 ns / op 32 B / op 1 Allokationen / op
 BenchmarkFmt-8 10.000.000 143 ns / op 72 B / op 3 Allokationen / op </pre><br>  Wie Sie sehen k√∂nnen, ist die Option strconv 3,5-mal schneller, verursacht dreimal weniger Zuweisungen und belegt halb so viel Speicher. <br><br><h3>  Ordnen Sie den Scheibentank mit make zu, um eine Umverteilung zu vermeiden </h3><br>  Bevor wir mit der Verbesserung der Leistung fortfahren, aktualisieren wir schnell die geschnittenen Informationen im Speicher.  Ein Slice ist ein sehr n√ºtzliches Konstrukt in Go.  Es bietet ein skalierbares Array mit der M√∂glichkeit, verschiedene Ansichten im selben Basisspeicher ohne Neuzuweisung zu akzeptieren.  Wenn Sie unter die Haube schauen, besteht die Scheibe aus drei Elementen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pointer to underlying data in the slice. data uintptr // the number of elements in the slice. len int // the number of elements that the slice can // grow to before a new underlying array // is allocated. cap int }</span></span></code> </pre> <br>  Was sind diese Felder? <br><br><ul><li>  <code>data</code> : Zeiger auf die zugrunde liegenden Daten im Slice <br></li><li>  <code>len</code> : Aktuelle Anzahl der Elemente im Slice <br></li><li>  <code>cap</code> : Anzahl der Elemente, auf die ein Slice vor der Neuverteilung anwachsen kann </li></ul><br>  Abschnitte unter der Haube sind Arrays fester L√§nge.  Wenn der Maximalwert ( <code>cap</code> ) erreicht ist, wird ein neues Array mit einem doppelten Wert zugewiesen, der Speicher wird vom alten Slice in den neuen kopiert und das alte Array wird verworfen. <br><br>  Ich sehe oft so etwas wie diesen Code, bei dem ein Slice mit einer Grenzkapazit√§t von Null zugewiesen wird, wenn die Slice-Kapazit√§t im Voraus bekannt ist: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userIDs []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  In diesem Fall beginnt die Schicht mit der Nullgr√∂√üe <code>len</code> und der <code>cap</code> .  Nachdem wir die Antwort erhalten haben, f√ºgen wir die Elemente dem Slice hinzu und erreichen gleichzeitig die Grenzkapazit√§t: Ein neues Basisarray wird ausgew√§hlt, bei dem die <code>cap</code> verdoppelt und die Daten darauf kopiert werden.  Wenn die Antwort 8 Elemente enth√§lt, f√ºhrt dies zu 5 Umverteilungen. <br><br>  Die folgende Methode ist viel effizienter: <br><br><pre> <code class="go hljs">userIDs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rsp.Users)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Hier haben wir die Kapazit√§t f√ºr das Slice explizit mit make zugewiesen.  Jetzt k√∂nnen wir dort sicher Daten hinzuf√ºgen, ohne sie weiter zu verteilen und zu kopieren. <br><br>  Wenn Sie nicht wissen, wie viel Speicher zugewiesen werden soll, weil die Kapazit√§t dynamisch ist oder sp√§ter im Programm berechnet wird, messen Sie die endg√ºltige Verteilung der Slice-Gr√∂√üe, nachdem das Programm ausgef√ºhrt wurde.  Normalerweise nehme ich das 90. oder 99. Perzentil und codiere den Wert im Programm fest.  In F√§llen, in denen die CPU f√ºr Sie teurer als RAM ist, stellen Sie diesen Wert h√∂her ein, als Sie f√ºr erforderlich halten. <br><br>  Der Tipp gilt auch f√ºr Maps: <code>make(map[string]string, len(foo))</code> gen√ºgend Speicher zu, um eine Umverteilung zu vermeiden. <br><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> erfahren Sie, wie Slices tats√§chlich funktionieren. <br><br><h3>  Verwenden Sie Methoden, um Byte-Slices zu √ºbertragen </h3><br>  Verwenden Sie bei der Verwendung von Paketen Methoden, die die √úbertragung eines Byte-Slice erm√∂glichen: Diese Methoden bieten normalerweise mehr Kontrolle √ºber die Verteilung. <br><br>  Ein gutes Beispiel ist der Vergleich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">time.Format</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">time.AppendFormat</a> .  Der erste gibt eine Zeichenfolge zur√ºck.  Unter der Haube w√§hlt dies ein neues Byte-Slice aus und ruft <code>time.AppendFormat</code> auf.  Der zweite nimmt einen Bytepuffer, schreibt eine formatierte Zeitdarstellung und gibt einen erweiterten Byte-Slice zur√ºck.  Dies ist h√§ufig in anderen Paketen in der Standardbibliothek zu finden: siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">strconv.AppendFloat</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.NewBuffer</a> . <br><br>  Warum erh√∂ht dies die Produktivit√§t?  Nun k√∂nnen Sie die von <code>sync.Pool</code> empfangenen Byte-Slices <code>sync.Pool</code> , anstatt jedes Mal einen neuen Puffer <code>sync.Pool</code> .  Oder Sie k√∂nnen die anf√§ngliche Puffergr√∂√üe auf einen Wert erh√∂hen, der f√ºr Ihr Programm besser geeignet ist, um die Anzahl der wiederholten Kopien des Slice zu verringern. <br><br><h1>  Zusammenfassung </h1><br>  Sie k√∂nnen alle diese Methoden auf Ihre Codebasis anwenden.  Im Laufe der Zeit werden Sie ein mentales Modell erstellen, um √ºber die Leistung in Go-Programmen nachzudenken.  Dies wird bei ihrer Gestaltung sehr hilfreich sein. <br><br>  Verwenden Sie sie jedoch je nach Situation.  Dies sind Ratschl√§ge, nicht das Evangelium.  Messen und √ºberpr√ºfen Sie alles mit Benchmarks. <br><br>  Und wissen, wann Sie aufh√∂ren m√ºssen.  Die Steigerung der Produktivit√§t ist eine gute √úbung: Die Aufgabe ist interessant und die Ergebnisse sind sofort sichtbar.  Der Nutzen einer Produktivit√§tssteigerung h√§ngt jedoch stark von der jeweiligen Situation ab.  Wenn Ihr Dienst innerhalb von 10 ms eine Antwort gibt und die Netzwerkverz√∂gerung 90 ms betr√§gt, sollten Sie wahrscheinlich nicht versuchen, diese 10 ms auf 5 ms zu reduzieren: Sie haben noch 95 ms.  Selbst wenn Sie den Dienst auf maximal 1 ms optimieren, betr√§gt die Gesamtverz√∂gerung immer noch 91 ms.  Essen Sie wahrscheinlich gr√∂√üere Fische. <br><br>  Mit Bedacht optimieren! <br><br><h3>  Referenzen </h3><br>  Wenn Sie weitere Informationen w√ºnschen, finden Sie hier gro√üartige Inspirationsquellen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Gefahren von Big Piles in Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verteilungseffizienz bei Hochleistungs-Go-Diensten</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ich aufh√∂rte mir Sorgen zu machen und mich in einen Haufen verliebte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Buffer, ich dachte du w√§rst mein Freund</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gc ist schlecht, aber du solltest dich nicht schlecht f√ºhlen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Profilerstellung und Optimierung in Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichernutzung in CockroachDB</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eliminieren von GC-Verz√∂gerungen in gro√üen Haufen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sieben Schritte, um hundertfach zu beschleunigen</a> </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457004/">https://habr.com/ru/post/de457004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456986/index.html">Durov hat nichts mit TON zu tun</a></li>
<li><a href="../de456988/index.html">Geschichten eines IT-Anwalts. Life-Outsourcing-Gesch√§ft. Teil 3</a></li>
<li><a href="../de456992/index.html">Einige n√ºtzliche Tipps f√ºr diejenigen, die selbst Englisch lernen m√∂chten</a></li>
<li><a href="../de456996/index.html">Drei wei√üe Pferde</a></li>
<li><a href="../de456998/index.html">Die komplette Geschichte von Harold und dem Bob Herbert Tree in Fallout</a></li>
<li><a href="../de457008/index.html">Antiquit√§ten: Drei Palmengeschichten</a></li>
<li><a href="../de457010/index.html">Warum ich keine Webkomponenten verwende</a></li>
<li><a href="../de457016/index.html">BEM-Methodik als Beispiel f√ºr Aufkleber in OpenCart</a></li>
<li><a href="../de457018/index.html">√úber Komplexit√§t</a></li>
<li><a href="../de457020/index.html">Eine Auswahl von akademischen und Science-Pop-Quellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>