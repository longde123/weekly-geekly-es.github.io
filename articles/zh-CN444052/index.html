<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👪 🍵 🏴󠁧󠁢󠁥󠁮󠁧󠁿 我们IntelliJ IDEA如何寻找lambda表达式 🍦 🏴‍☠️ 🚵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="任何IDE的重要功能都是在代码中进行搜索和导航。 常用的Java搜索选项之一是搜索此接口的所有实现。 通常，这种功能称为“类型层次”，其外观如右图所示。 


 调用此函数时，在项目的所有类中进行迭代效率很低。 您可以在编译时将完整的类层次结构保存到索引，因为无论如何编译器都会构建它。 如果编译是由...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们IntelliJ IDEA如何寻找lambda表达式</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/444052/"><p><img alt="IntelliJ IDEA中的类型的层次结构" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300"> 任何IDE的重要功能都是在代码中进行搜索和导航。 常用的Java搜索选项之一是搜索此接口的所有实现。 通常，这种功能称为“类型层次”，其外观如右图所示。 </p><br><p> 调用此函数时，在项目的所有类中进行迭代效率很低。 您可以在编译时将完整的类层次结构保存到索引，因为无论如何编译器都会构建它。 如果编译是由IDE本身启动且未委托（例如在Gradle中），则我们将执行此操作。 但这仅在编译后模块中没有任何更改的情况下有效。 但是在一般情况下，源代码是最相关的信息源，索引建立在源代码上。 </p><br><p>如果我们不处理功能接口，那么寻找直系继承人是一项简单的任务。 在寻找<code>Foo</code>接口的实现时，您需要找到所有带有<code>implements Foo</code> ，以及所有具有<code>extends Foo</code>接口，以及形式为<code>new Foo(...) {...}</code>匿名类。 为此，预先构建每个项目文件的语法树，找到相应的结构并将其添加到索引就足够了。 </p><a name="habracut"></a><br><p> 当然，这里有一些微妙之处：也许您在寻找<code>com.example.goodcompany.Foo</code>接口，但是实际上使用了<code>org.example.evilcompany.Foo</code> 。 是否可以在索引中预先放置父接口的全名？ 这有困难。 例如，使用该接口的文件可能如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p> 仅查看文件，我们无法理解真正的全名是<code>Foo</code> 。 您必须查看几个软件包的内容。 每个包都可以在多个位置定义（例如，在几个jar文件中）。 如果在分析此文件时必须对字符进行完全解析，则索引编制将花费很长时间。 但是主要的问题还不止于此，而是建立在<code>MyFoo.java</code>文件上的索引不仅取决于它，还取决于其他文件。 毕竟，我们可以将<code>Foo</code>接口的描述从<code>org.example.foo</code>包转移到<code>org.example.bar</code>包，并且不要更改<code>MyFoo.java</code>文件中的任何内容，并且<code>Foo</code>的全名将更改。 </p><br><p>  IntelliJ IDEA中的索引仅取决于单个文件的内容。 一方面，这非常方便：与特定文件相关的索引在此文件更改时变为无效。 另一方面，这对可以放置在索引中的内容施加了很大的限制。 例如，它不能可靠地将父类的全名存储在索引中。 但是，从原则上讲，这并不那么可怕。 在查询类型层次结构时，我们可以找到所有适合短名称的内容，然后对这些文件执行诚实的字符解析并确定其是否真正适合我们。 在大多数情况下，不会有太多多余的字符，这样的检查很快。 </p><br><p><img alt="IntelliJ IDEA中的功能接口的层次结构" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300"> 当我们要寻找其后代的类是一个功能接口时，情况将发生巨大变化。 然后，除了显式和匿名继承人之外，我们还获得lambda表达式和方法链接。 现在要输入什么索引，以及在搜索时直接计算什么？ </p><br><p> 假设我们有一个功能接口： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p> 代码中有不同的lambda表达式。 例如： </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">//   :   (a, b) -&gt; a + b //   :   s -&gt; { return list.add(s); //   :   } s -&gt; list.add(s); //   </span></span></code> </pre> <br><p> 也就是说，我们可以快速仅过滤那些参数数量错误或返回类型明显错误的lambda，例如void vs non-void。 通常不可能更精确地确定返回类型。 例如，在lambda <code>s -&gt; list.add(s)</code> ，您需要解析字符<code>list</code>并<code>add</code> ，并且有可能启动完整的类型推断过程。 所有这些都是漫长的，并且需要固定其他文件的内容。 </p><br><p> 如果我们的功能接口接受五个参数，我们很幸运。 但是，如果只接受一个参数，则此类过滤器将留下大量额外的lambda。 方法引用更糟。 原则上，无论是否合适，都不能以任何方式表示对方法的引用。 </p><br><p> 也许您应该环顾lambda以了解某些内容？ 是的，有时候可以。 例如： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        Predicate&lt;String&gt; p = s -&gt; list.add(s); //      IntPredicate getPredicate() { return s -&gt; list.add(s); } //      SomeType fn; fn = s -&gt; list.add(s); //     foo((SomeFunctionalType)(s -&gt; list.add(s))); //     Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p> 在所有这些情况下，可以从当前文件中找到相应功能接口的简称，并将其放在功能表达式旁边的索引中，无论是lambda还是方法引用。 不幸的是，在实际项目中，这些情况仅占所有lambda的很小一部分。 在绝大多数情况下，lambda用作方法的参数： </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p> 这三个lambda中的哪一个可以为<code>StringConsumer</code>类型？ 程序员显然没有。 因为很明显，我们这里有Stream API链，而且标准库中只有功能接口，所以我们的类型不能在那里。 </p><br><p> 但是，IDE不应欺骗自己，而必须给出准确的答案。 如果<code>list</code>根本不是<code>java.util.List</code> ，而<code>list.stream()</code>根本不返回<code>java.util.stream.Stream</code>怎么办？ 为此，您必须解析<code>list</code>符号，众所周知，仅根据当前文件的内容才能可靠地完成此操作。 即使我们安装了它，搜索也不应该依赖于标准库的实现。 也许我们专门在这个项目中用我们自己的<code>java.util.List</code>类替换了？ 搜索必须对此做出响应。 好吧，当然，lambda不仅用于标准流中，而且还有许多其他传输方法。 </p><br><p> 结果，事实证明我们可以在索引中查询所有使用lambda的Java文件的列表，这些文件具有所需的参数数量和有效的返回类型（实际上，我们仅跟踪四个选项：void，non-void，boolean和any）。 然后呢？ 对于这些文件中的每一个，构建一个完整的PSI树（它像一个解析树，但是具有字符解析，类型推断和其他巧妙的东西），并诚实地为lambda执行类型推断吗？ 然后，在大型项目中，即使只有两个接口实现，也不会等待所有接口实现的列表。 </p><br><p> 事实证明，我们需要执行以下步骤： </p><br><ul><li> 询问指数（便宜） </li><li> 建立PSI（昂贵） </li><li> 打印lambda类型（非常昂贵） </li></ul><br><p> 在Java版本8和更高版本中，类型推断是一项非常昂贵的操作。 在一个复杂的调用链中，您可以具有许多通用通配符参数，这些值需要使用规范<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第18章中</a>描述的激烈过程来确定。 对于正在编辑的当前文件，可以在后台完成此操作，但是对于成千上万个未打开的文件则很难做到这一点。 </p><br><p> 但是，您可以在这里进行一些操作：在大多数情况下，我们不需要最终类型。 如果没有将lambda传递给使用通用参数的方法，那么我们可以摆脱参数替换的最后一步。 假设，如果推导了lambda类型<code>java.util.function.Function&lt;T, R&gt;</code> ，则无法计算替换参数<code>T</code>和<code>R</code> ：的值，因此很明显是否将其返回到搜索结果。 尽管在调用这样的方法时这不起作用： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p> 可以这样调用该方法： <code>doSmth(Runnable.class, () -&gt; {})</code> 。 然后，lambda类型将显示为<code>T</code> ，无论如何您都必须替换。 但这是一种罕见的情况。 因此，事实证明可以节省，但不超过10％。 问题没有得到根本解决。 </p><br><p> 另一个想法：如果确切的类型推断很复杂，那么让我们得出一个近似的结论。 让它仅对擦除的类类型起作用，并且不减少规范中所写的限制集，而只是遵循调用链。 只要擦除的类型不包含通用参数，一切都很好。 例如，从上面的示例中获取流，并确定最后一个lambda是否实现了我们的<code>StringConsumer</code> ： </p><br><ul><li>  <code>list</code>变量-&gt;类型<code>java.util.List</code> </li><li>  <code>List.stream()</code>方法- <code>List.stream()</code> <code>java.util.stream.Stream</code>类型 </li><li>  <code>Stream.filter(...)</code>方法→输入<code>java.util.stream.Stream</code> ，我们什至不看过<code>filter</code>参数，有什么区别 </li><li>  <code>Stream.map(...)</code>方法- <code>Stream.map(...)</code> <code>java.util.stream.Stream</code>类型，类似 </li><li>  <code>Stream.forEach(...)</code>方法→有一个这样的方法，它的参数是<code>Consumer</code>类型，显然不是<code>StringConsumer</code> 。 </li></ul><br><p> 好吧，他们没有进行完全类型推断。 但是，使用这种简单的方法，很容易遇到重载方法。 如果我们没有完全开始类型推断，那么您将无法选择正确的重载版本。 虽然不是，但有时方法参数的数量可能不同。 例如： </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p> 在这里我们可以很容易地理解 </p><br><ul><li> 有两个<code>CompletableFuture.supplyAsync</code>方法，但是一个方法带有一个参数，第二个带有两个参数，因此请选择一个带有两个参数的方法。 它返回一个<code>CompletableFuture</code> 。 </li><li>  <code>thenRunAsync</code>方法也是两个，您可以从中类似地选择一个采用一个参数的方法。 相应的参数类型为<code>Runnable</code> ，这意味着它不是<code>StringConsumer</code> 。 </li></ul><br><p> 如果几种方法接受相同数量的参数，或者某些方法具有可变数量的参数并且看起来也很合适，那么您将必须跟踪所有选项。 但是通常这也并不可怕。 例如： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code>显然会创建<code>java.lang.StringBuilder</code> 。 对于设计人员，我们仍然允许该链接，但是这里不需要复杂的类型推断。 即使有<code>new Foo&lt;&gt;(x, y, z)</code> ，我们也不显示典型参数的值，我们只对<code>Foo</code>感兴趣。 </li><li> 有<code>StringBuilder.append</code>采用一个参数<code>StringBuilder.append</code>方法，但是它们都返回类型<code>java.lang.StringBuilder</code> ，所以<code>foo</code>和<code>bar</code>什么类型都没有关系。 </li><li>  <code>StringBuilder.chars</code>方法<code>StringBuilder.chars</code>一种，它返回<code>java.util.stream.IntStream</code> 。 </li><li>  <code>IntStream.forEach</code>方法<code>IntStream.forEach</code>一个，并且接受<code>IntConsumer</code>类型。 </li></ul><br><p> 即使某些选项保留在某处，您也可以全部跟踪它们。 例如，传递给<code>ForkJoinPool.getInstance().submit(...)</code>的lambda的类型可以是<code>Runnable</code>或<code>Callable</code> ，但是如果我们正在寻找第三者，我们仍然可以丢弃该lambda。 </p><br><p> 当方法返回通用参数时，会发生不愉快的情况。 然后，该过程中断，您必须运行全类型推断。 但是，我们支持一种情况。 它在我的StreamEx库中显示得很好，该库具有一个抽象类<code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code>其中包含<code>S filter(Predicate&lt;? super T&gt; predicate)</code> 。 通常，人们使用特定的类<code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> 。 在这种情况下，可以执行type参数的替换，并找出<code>S = StreamEx</code> 。 </p><br><p> 好吧，在许多情况下，我们摆脱了非常昂贵的类型推断。 但是我们对PSI的构建一无所获。 只是将文件解析为五百行只是为了发现第480行中的lambda不适合我们的查询，这有点可耻。 让我们回到我们的流： </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p> 如果<code>list</code>是当前类中的局部变量，方法参数或字段，则已经在索引阶段，我们可以找到其声明并确定类型的简称为 <br>  <code>List</code> 因此，在最后一个lambda的索引中，我们可以输入以下信息： </p><br><blockquote> 这个lambda的类型是一个参数的<code>forEach</code>方法的参数类型，一个参数调用<code>map</code>方法的结果，一个参数调用<code>filter</code>方法的结果，零参数调用<code>stream</code>方法的结果，并调用<code>List</code>类型的对象。 </blockquote><p> 所有这些信息在当前文件上都可用，这意味着可以将其放置在索引中。 在搜索过程中，我们要求索引提供有关所有lambda的此类信息，并尝试在不构建PSI的情况下还原lambda类型。 首先，您必须对名为<code>List</code>班级进行全局搜索。 当然，我们不仅会发现<code>java.util.List</code> ，而且还会发现<code>java.awt.List</code>或用户项目代码中的某些内容。 此外，我们将所有这些类提交给我们之前使用的不准确的类型解析相同的过程。 通常，多余的类本身会很快被过滤掉。 例如，在<code>java.awt.List</code>中没有<code>stream</code>方法，因此将其进一步排除在外。 但是，即使最后有多余的东西，并且我们找到了几种lambda类型的候选者，也很有可能它们都不适合搜索查询，并且我们仍将避免构建完整的PSI。 </p><br><p> 全局搜索可能会太昂贵（项目中有很多<code>List</code>类），或者在一个文件的上下文中不允许链的开头（假设这是父类的字段），或者链会在某处中断，因为该方法返回一个通用参数。 然后，我们不会立即放弃，而是再次尝试从下一个链接方法的全局搜索开始。 例如，对于<code>map.get(key).updateAndGet(a -&gt; a * 2)</code>链，以下语句进入了索引： </p><br><blockquote>  lambda的类型是<code>updateAndGet</code>方法的唯一参数的类型，该方法在具有一个参数的<code>get</code>方法的结果上调用，该方法在<code>Map</code>类型的对象上调用。 </blockquote><p> 让我们幸运的是，在项目中只有一种<code>java.util.Map</code> 。 它确实具有<code>get(Object)</code>方法，但不幸的是它返回通用参数<code>V</code> 然后，我们删除该链，并在全局范围内查找具有一个参数的<code>updateAndGet</code>方法（当然使用索引）。  <code>AtomicInteger</code> ，项目中只有三种这样的方法，分别在<code>AtomicInteger</code> ， <code>AtomicLong</code>和<code>AtomicReference</code> ，它们的参数类型分别为<code>IntUnaryOperator</code> ， <code>LongUnaryOperator</code>和<code>UnaryOperator</code> 。 如果我们正在寻找其他任何类型，那么我们发现该lambda不适合并且无法构建PSI。 </p><br><p> 令人惊讶的是，这是该功能的生动示例，随着时间的流逝，其功能开始变得越来越慢。 例如，您正在寻找功能接口的实现，项目中只有三个，而IntelliJ IDEA会搜索它们十秒钟。 您会非常清楚地记得，三年前也有三个，您也在寻找它们，但是随后环境在同一台计算机上在两秒钟内给出了答案。 您的项目尽管庞大，却在三年内增长了，也许增长了5％。 当然，您会开始不满意这些开发人员所犯的错误，以至于IDE开始变得如此缓慢。 扯掉这些不幸的程序员的手。 </p><br><p> 也许我们什么都没做。 也许搜索工作与三年前相同。 就在三年前，您刚刚切换到Java 8，例如，您的项目中有一百个lambda。 现在，您的同事将匿名类转换为lambda，开始积极使用流或连接某种反应式库，结果lambda不再是一百，而是一万。 现在，为了找出三个必需的lambda，必须对IDE进行一百倍以上的搜索。 </p><br><p> 我说“也许”是因为，当然，我们会不时返回此搜索并尝试加快搜索速度。 但是在这里，您甚至不必划着小溪划船，而是划上瀑布。 我们尝试过，但是项目中的lambda数量正在迅速增长。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444052/">https://habr.com/ru/post/zh-CN444052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444038/index.html">在真实的“ iOS”项目中使用“协调器”的经验</a></li>
<li><a href="../zh-CN444040/index.html">自动中心排名。 Yandex报告关于寻找禅宗作者的相关受众</a></li>
<li><a href="../zh-CN444044/index.html">欧洲将回收数据中心的铁</a></li>
<li><a href="../zh-CN444048/index.html">数字取证技巧和窍门：如何检测入侵者驱动的组策略更改</a></li>
<li><a href="../zh-CN444050/index.html">讨论：DNA储存会变得庞大</a></li>
<li><a href="../zh-CN444056/index.html">克里米亚的互联网提供商大幅提高了服务价格</a></li>
<li><a href="../zh-CN444058/index.html">当孩子们知道他们的一生已经在线时</a></li>
<li><a href="../zh-CN444060/index.html">从Nagios迁移到澳大利亚的Icinga2</a></li>
<li><a href="../zh-CN444062/index.html">点亮！ 拉赫塔中心的夜间改造</a></li>
<li><a href="../zh-CN444064/index.html">崭新的未来的新思路</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>