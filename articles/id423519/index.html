<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏾 💵 🙍🏽 Wandering Monster: cara menyingkirkan masalah di peta 🥕 🍠 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sudah dalam proses menciptakan The Witness telah menjadi salah satu game favorit saya. Saya mulai memainkannya sejak saat Jonathan Blow mulai mengemba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wandering Monster: cara menyingkirkan masalah di peta</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423519/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png" alt="gambar"></div><br>  Sudah dalam proses menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Witness</a> telah menjadi salah satu game favorit saya.  Saya mulai memainkannya sejak saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jonathan Blow</a> mulai mengembangkannya, dan tidak bisa menunggu rilisnya. <br><br>  Tidak seperti game John <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Braid</a> sebelumnya, skala sumber daya dan pemrograman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Witness</a> jauh lebih dekat dengan proyek AAA daripada game indie.  Setiap orang yang bekerja pada proyek seperti itu tahu bahwa jumlah pekerjaan ketika memilih jalur ini meningkat secara signifikan.  Ada lebih banyak orang yang bekerja pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saksi</a> daripada pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Braid</a> , tetapi seperti halnya proyek pada tingkat ini, ada banyak aspek yang membutuhkan lebih banyak perhatian daripada yang bisa diberikan manajemen proyek. <br><br>  Karena itu, saya selalu ingin mencari waktu luang untuk membantu menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Witness</a> ketika akan merilis game.  Jadi suatu hari, Thanksgiving, John dan saya duduk dan melihat daftar hal-hal dalam basis kode yang akan mendapat manfaat dari upaya tambahan dari programmer lain.  Setelah memutuskan kepentingan relatif dari item dalam daftar, kami memutuskan bahwa permainan akan mendapat manfaat paling besar jika kami melakukan perbaikan pada kode gerakan pemain. <br><a name="habracut"></a><br><h2>  Walkmonster di dinding </h2><br>  Dalam konteks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saksi</a> , tujuan kode gerakan pemain adalah untuk tidak mengganggu mungkin.  Pemain harus sepenuhnya membenamkan dirinya dalam realitas alternatif, dan dalam pengalaman permainan ini setiap detail adalah penting.  Hal terakhir yang kami inginkan adalah agar pemain memperhatikan bahwa ia sedang duduk di depan komputer dan menggerakkan kamera virtual. <br><br>  Karenanya, kode gerakan pemain harus benar-benar andal.  Jika seorang pemain menempel di sudut-sudut, terjebak di dinding, jatuh melalui lantai, turun dari bukit tanpa kemampuan untuk kembali, dll., Ini akan langsung menghancurkan ilusi perendaman dan mengingatkan pemain bahwa ia berada di dalam proses permainan buatan yang diganggu oleh sistem yang tidak dapat diandalkan perpindahan.  Dalam beberapa keadaan, ini bahkan dapat menyebabkan konsekuensi bencana bagi pemain jika ia tidak memiliki kesempatan untuk menyelesaikan masalah dengan memulai kembali permainan atau memuat ulang "mungkin" yang lama.  Jika Anda sering bermain game, Anda pasti mengalami masalah jenis ini, dan Anda tahu apa yang saya maksud. <br><br>  Setelah diskusi kami, saya mulai mengerjakan tugas ini.  Pertama-tama, saya memutuskan untuk menulis alat terintegrasi untuk bekerja dengan kode gerakan pemain, sehingga kami dapat menganalisisnya dan mengamati perilakunya saat ini.  Setelah membuka proyek, saya mengalami masalah serius yang sudah diketahui oleh saya: apa yang harus saya beri nama file kode sumber pertama?  Ini selalu menjadi bagian terpenting dari proyek apa pun ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti yang pernah dikatakan Bob Pollard tentang nama grup musik dan album</a> ).  Jika Anda memberikan file sumber nama yang sesuai, maka pekerjaan lebih lanjut akan jelas dan lancar.  Pilih yang salah - Anda dapat menghancurkan seluruh proyek. <br><br>  Tapi apa nama sistem untuk memastikan kualitas kode gerakan pemain?  Saya belum pernah menulis kode seperti ini sebelumnya.  Ketika saya memikirkan hal ini, saya menyadari bahwa saya pribadi melihat contoh kode semacam itu hanya sekali: ketika memainkan beta awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quake</a> .  Isinya bug dengan lokasi monster, dan di jendela konsol Anda bisa melihat pesan kesalahan yang menyatakan bahwa monster, bukannya menciptakan di permukaan bumi, dibuat, sebagian berpotongan dengan geometri level.  Setiap pesan debug dimulai dengan frasa "walkmonster di dinding di ..." <br><br>  Bingo!  Sulit menemukan nama yang lebih baik untuk file kode daripada "walk_monster.cpp".  Dan saya hampir yakin bahwa mulai sekarang kode akan dibuat tanpa masalah. <br><br><h2>  Gerakan ke titik </h2><br>  Ketika Anda ingin menguji sistem, yang paling penting adalah <i>benar-benar menguji sistem</i> .  Meskipun aturan ini tampak sederhana, orang yang menulis tes sering gagal untuk mematuhinya. <br><br>  Dalam kasus khusus kami, sangat mudah untuk <i>membayangkan</i> bahwa kami menguji kode gerakan pemain tanpa benar-benar mengujinya.  Berikut ini salah satu contohnya: Anda dapat menganalisis volume tabrakan dan permukaan tempat Anda dapat bergerak dalam permainan, mencari permukaan kecil, celah, dll.  Setelah menghilangkan semua masalah ini, kita dapat mengatakan bahwa sekarang pemain dapat bergerak dan berjalan dengan aman di seluruh dunia. <br><br>  Namun pada kenyataannya, kami menguji data, bukan kode.  Sangat mungkin bahwa akan ada bug dalam kode gerak yang menyebabkan perilaku buruk bahkan dengan data berkualitas tinggi. <br><br>  Untuk menghindari jebakan seperti itu, saya ingin sistem pengujian sedekat mungkin dengan perilaku orang yang benar-benar mengendalikan pergerakan karakter dalam permainan.  Saya mulai dengan menulis dua prosedur yang akan menjadi dasar pengujian tersebut. <br><br>  Prosedur pertama paling dekat dengan tindakan nyata manusia.  Ini adalah panggilan pembaruan yang menghubungkan ke sistem pemrosesan input <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Witness</a> dan meneruskan kejadian keyboard dan mouse yang disintesis kepadanya.  Ia mampu melakukan hal-hal sederhana yang dapat dilakukan seseorang: melihat-lihat, pergi ke suatu titik, melihat suatu titik, dan seterusnya.  Prosedur melakukan tindakan-tindakan ini dengan hanya meniru interaksi pengguna dengan keyboard dan mouse, jadi saya yakin bahwa ketika memproses input dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Witness</a> semuanya akan dilakukan persis seperti saat pengujian.  Dalam artikel berikut saya akan berbicara lebih banyak tentang sistem ini dan penggunaannya. <br><br>  Prosedur kedua adalah satu langkah yang tidak digunakan pada level ini.  Ini adalah fungsi yang disebut <i>DriveTowardPoint</i> , yang menerima dua poin di dunia dan, menyebabkan sistem tabrakan pemain yang ada, mencoba untuk berpindah dari satu titik ke titik lainnya.  Melaksanakan kembalinya, dia mentransmisikan informasi tentang upaya: apa hambatan yang dia temui di jalan dan apakah dia berhasil mencapai titik akhir. <br><br>  Fungsi ini tidak dapat diandalkan seperti metode pengujian dengan input yang disintesis, karena menghilangkan bagian dari sistem pergerakan pemain dari pengujian.  Misalnya, kondisi salah apa pun yang terkait dengan lokasi pemain jika terjadi masalah dengan sistem tumbukan tidak akan mempengaruhi pengujian menggunakan fungsi ini.  Namun demikian, saya menganggap tingkat pengujian ini berharga karena dapat menguji area yang luas lebih cepat, karena tidak memerlukan pelaksanaan seluruh siklus permainan, yaitu, dapat digunakan lebih sering di seluruh dunia, dan tidak hanya dalam uji coba terpisah . <br><br>  Perlu juga dicatat bahwa fungsi ini tidak mengirimkan data input fisik;  misalnya, kecepatan tidak ditunjukkan untuk titik awal.  Ini karena <i>The Witness</i> bukan permainan aksi, jadi pemain memiliki beberapa sifat fisik yang signifikan.  Pemain tidak bisa melompat, berlari di dinding, menyalakan waktu peluru.  Anda dapat mendukung perilaku tersebut menggunakan sistem yang akan saya uraikan nanti, tetapi mereka menambahkan tingkat kompleksitas yang tidak diperlukan dalam proyek kami. <br><br>  Namun, setelah menerapkan <i>DriveTowardPoint</i> saya bisa mulai menyelesaikan tugas pertama sistem: menentukan di mana pemain dapat pindah ke Pulau <i>Witness</i> . <br><br><h2>  Menjelajahi Pohon Acak Dengan Cepat </h2><br>  Ke mana pemain bisa pergi?  Ini sepertinya pertanyaan sederhana, tetapi Anda akan terkejut mengetahui berapa banyak game yang dirilis ketika tim pengembang tidak tahu jawaban yang sebenarnya.  Jika ini mungkin, maka saya ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saksi</a> menjadi salah satu dari beberapa game di mana pengembang sebelum rilis tahu persis di mana pemain bisa dan tidak bisa mendapatkan - tidak ada kejutan. <br><br>  Ini membuat pernyataan masalah (tapi mungkin bukan solusinya) sangat sederhana: jika ada fungsi <i>DriveTowardPoint</i> yang dapat menentukan apakah pemain dapat bergerak dalam garis lurus antara dua titik, buat peta cakupan yang menunjukkan di mana pemain berada. <br><br>  Untuk beberapa alasan, tanpa menulis satu baris kode, untuk beberapa alasan saya pikir akan lebih baik menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rapidly Exploring Random Tree</a> .  Bagi mereka yang tidak terbiasa dengan algoritma ini, saya akan menjelaskan: ini adalah proses yang sangat sederhana di mana kami merekam semua poin yang kami kunjungi dengan referensi ke titik dari mana kami berasal.  Untuk menambahkan titik ke pohon, kami mengambil titik target acak di mana saja di dunia, pilih titik terdekat, sudah di pohon, dan mencoba untuk mendapatkan dari titik ini ke target.  Tempat di mana kami akhirnya menjadi titik pengambilan sampel berikutnya. <br><br>  Biasanya algoritma ini digunakan untuk mencari jalur: secara bergantian untuk titik-titik acak, kami selalu memilih titik yang sama dengan target.  Ini cenderung mengeksplorasi ruang menuju titik target, dan inilah yang diperlukan ketika satu-satunya tugas kita adalah mencapai tujuan.  Tetapi dalam kasus ini, saya ingin membuat peta lengkap tempat pemain bisa jatuh, jadi saya hanya menggunakan sampel acak. <br><br>  Setelah menerapkan algoritma ini (untungnya, ini sangat sederhana dan tidak memerlukan banyak waktu), saya melihat bahwa ia melakukan pekerjaan yang cukup baik dalam menjelajahi ruang (jalur yang ditunjukkan ditunjukkan oleh jalur putih dan garis merah vertikal menunjukkan tempat-tempat di mana algoritma bertabrakan dengan penghalang) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed2/ca3/fe3/ed2ca3fe3dbfe02cb7c9779af50f9ca6.png"></div><br>  Namun, setelah mengamati perilakunya, saya menyadari bahwa sebenarnya saya tidak perlu algoritma seperti itu.  Sebagai contoh, bahkan setelah banyak iterasi, ia hampir tidak dapat menjelajahi kamar yang mirip dengan yang ditunjukkan di bawah ini, meskipun cakupan area luarnya padat.  Ini karena dia tidak bisa memilih titik acak yang cukup di dalam kamar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/2d4/5a5/9832d45a5c14dc13df9a03cf5216697f.png" width="1280" height="720"></div><br>  Jika saya memikirkan hal ini sebelum mulai bekerja, saya akan mengerti bahwa keuntungan dari algoritma seperti Rapidly Exploring Random Tree adalah bahwa mereka secara efektif menjelajahi ruang dimensi tinggi.  Bahkan, ini biasanya menjadi alasan utama penggunaannya.  Tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saksi</a> tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki</a> ruang dimensi tinggi.  Kami memiliki ruang dua dimensi (ya, didistribusikan pada varietas yang kompleks, tetapi ini masih merupakan ruang dua dimensi). <br><br>  Dalam ruang berdimensi rendah ini, keuntungan dari Rapidly Exploring Random Tree lemah, dan kelemahannya sangat penting untuk tugas saya: algoritme ini dirancang untuk pencarian jalur yang paling efisien untuk pasangan titik yang terhubung di ruang, dan bukan untuk pencarian yang efisien untuk semua titik yang dapat dijangkau dari ruang ini.  Jika Anda memiliki tugas seperti itu, maka sebenarnya Rapidly Exploring Random Tree akan membutuhkan banyak waktu untuk menyelesaikannya. <br><br>  Jadi saya segera menyadari bahwa saya perlu mencari sebuah algoritma yang secara efektif sepenuhnya menutupi ruang dimensi rendah. <br><br><h2>  Mengisi Banjir 3D </h2><br>  Ketika saya benar-benar berpikir tentang memilih algoritma, menjadi jelas bahwa sebenarnya saya membutuhkan sesuatu seperti isian dua dimensi yang bagus, yang digunakan untuk mengisi area bitmap.  Untuk setiap titik awal, saya hanya perlu mengisi seluruh ruang, memeriksa setiap cara yang mungkin.  Sayangnya, karena berbagai alasan, solusi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Witness</a> akan jauh lebih rumit daripada untuk bitmap dua dimensi. <br><br>  Pertama, kita tidak memiliki konsep yang jelas tentang keterhubungan terbatas suatu titik.  Semua ruang kontinu.  Ini untuk piksel, kami dapat dengan mudah mendaftar 4 tempat yang mungkin dapat dijangkau dari titik tertentu, dan memeriksa masing-masing secara bergantian. <br><br>  Kedua, tidak ada ukuran posisi yang tetap di ruang angkasa, seperti piksel pada bitmap.  Permukaan tempat pemain bergerak, dan rintangan dapat berada di mana saja, mereka tidak memiliki ukuran topologi maksimum atau minimum, serta tidak mengikat ke grid eksternal. <br><br>  Ketiga, meskipun pergerakan melalui ruang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saksi</a> dapat secara lokal dianggap bergerak di sepanjang pesawat, ruang itu sendiri sebenarnya sangat saling berhubungan dan berganti-ganti, di mana area walkable pemain berada tepat di atas area lain (kadang-kadang mungkin ada beberapa level yang terletak satu di atas yang lain) .  Selain itu, ada koneksi yang bervariasi tergantung pada kondisi dunia (pintu terbuka / tertutup, elevator yang naik / turun, dll.). <br><br>  Mengingat kesulitan yang diuraikan, sangat mudah untuk membuat versi Anda sendiri dari implementasi pengisian, yang sebagai hasilnya akan diisi dengan daerah yang bersinggungan, kehilangan rute-rute penting, informasi yang salah tentang koneksi di tempat-tempat kompleks manifold.  Pada akhirnya, algoritme akan terlalu rumit untuk digunakan, karena untuk memperhitungkan perubahan akun di negara dunia itu harus dijalankan kembali. <br><br>  Saya tidak segera memikirkan solusi yang baik, jadi saya memutuskan untuk memulai dengan eksperimen sederhana.  Dengan menggunakan kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Random Tree yang</a> Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksplorasi Secara Cepat</a> , saya mengubah pemilihan titik target dari acak menjadi sangat terkontrol.  Setiap kali sebuah titik baru ditambahkan ke pohon, saya menunjukkan bahwa titik-titik tersebut berada pada satuan jarak sepanjang arah utama dari titik yang akan dianggap sebagai titik target masa depan, seperti yang terjadi pada pengisian dua dimensi yang sederhana. <br><br>  Tetapi tentu saja, jika tidak hati-hati, ini akan menciptakan siklus pengambilan sampel yang tidak berguna.  Poin tersebut akan bercabang ke 8 poin di sekitarnya, tetapi 8 poin ini kemudian akan mencoba lagi untuk kembali ke titik awal, dan ini akan berlanjut selamanya.  Oleh karena itu, selain pemilihan titik target yang terkontrol, saya memerlukan batasan sederhana: titik target mana pun yang tidak berada dalam jarak minimum tertentu yang bermanfaat dari titik target yang ada tidak akan diperhitungkan.  Yang mengejutkan saya, dua aturan sederhana ini membuat isian yang cukup sukses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/591/cf6/446/591cf6446fdcc8281f7ebd9449c48703.png"></div><br>  Tidak buruk untuk percobaan yang cukup sederhana.  Tetapi algoritma menderita dari apa yang saya sebut "echo batas".  Efek ini dapat dilihat pada tangkapan layar berikut yang diambil selama studi peta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/fd0/25f/58efd025f80d2b96274ed849d3e4c568.png"></div><br>  Di daerah tanpa hambatan, algoritma bekerja dengan baik dengan mengambil sampel pada jarak yang relatif sama.  Tetapi ketika persimpangan mencapai perbatasan, mereka menciptakan titik yang "di luar kotak", yaitu, mereka tidak selaras sesuai dengan pola sampel, yang menurutnya algoritma mengisi area terbuka yang berdekatan.  Alasan bahwa poin-poin "di dalam grid" tidak menciptakan tessellation yang terlalu padat adalah karena setiap titik baru yang mencoba untuk kembali ke salah satu yang sebelumnya menemukan titik sebelumnya di sana dan menolak untuk menceritakannya lagi.  Tetapi ketika membuat titik baru di perbatasan, mereka sepenuhnya tidak sejajar, sehingga tidak ada yang bisa menghentikan mereka untuk kembali ke ruang yang sudah dieksplorasi.  Ini mengarah pada penciptaan gelombang sampel yang bias, yang berlanjut sampai mencapai garis acak titik di tempat lain, yang cukup dekat sehingga algoritma dapat menemukannya bertepatan dengan bagian depan yang bergerak dari titik. <br><br>  Meskipun ini tampaknya bukan masalah serius, ini sebenarnya penting.  Inti dari algoritma tersebut adalah untuk memusatkan sampel di area di mana mereka paling mungkin menghasilkan hasil yang produktif.  Semakin banyak waktu yang kita habiskan untuk pengambilan sampel dan pengambilan sampel kembali area terbuka yang luas, semakin sedikit waktu yang akan kita habiskan untuk menandai wajah-wajah area ini, yang merupakan informasi yang kita butuhkan.  Karena kita berhadapan dengan ruang kontinu, dan hanya jumlah sampel tak terbatas yang dapat menggambarkan bentuk aslinya, rasio sampel signifikan dan tidak signifikan secara literal adalah ukuran efektivitas algoritma dalam menciptakan permukaan yang bisa dilewati pemain. <br><br>  Namun, ada solusi sederhana untuk masalah khusus ini: Anda perlu memperluas jarak di mana dua titik dianggap "cukup dekat."  Dengan melakukan itu, kami akan mengurangi kepadatan pengambilan sampel di tempat-tempat yang <i>tidak penting bagi</i> kami, tetapi juga kehilangan kepadatan pengambilan sampel di tempat-tempat yang <i>penting bagi</i> kami, misalnya, area di sekitar perbatasan yang kami ingin hati-hati memeriksa keberadaan "lubang". <br><br><h2>  Pengambilan Sampel Directional Lokal </h2><br>  Mungkin karena saya mulai dengan Pohon Acak yang Menjelajah Cepat, otak saya menggantikan semua gagasan lain kecuali gagasan kedekatan.  Semua algoritma sebelumnya menggunakan kedekatan untuk tugas mereka, misalnya, untuk menentukan titik baru yang perlu dipertimbangkan berikutnya, atau untuk memilih titik dari mana untuk mulai sampai ke titik target baru. <br><br>  Tetapi setelah memikirkan tugas itu selama beberapa waktu, saya menyadari bahwa semuanya menjadi lebih logis, jika kita berpikir tidak hanya tentang kedekatan, tetapi juga tentang <i>arah</i> .  Maka menjadi jelas, tetapi jika Anda mengerjakan tugas-tugas serupa, maka Anda tahu bahwa mudah untuk jatuh ke dalam perangkap pemikiran picik dan tidak melihat gambaran besarnya, bahkan jika itu lebih mudah.  Itulah yang terjadi pada saya. <br><br>  Ketika saya mengubah pandangan saya tentang berbagai hal, pendekatan yang benar untuk pengambilan sampel tampak jelas.  Setiap kali saya ingin memperluas eksplorasi ruang saya dari suatu titik, saya mengajukan permintaan untuk keberadaan titik-titik terdekat di lingkungan lokal.  Namun, alih-alih menggunakan jarak ke titik-titik ini untuk penelitian, saya akan mengklasifikasikan mereka sesuai dengan arahan mereka (sebelumnya saya hanya menggunakan delapan arah utama, tetapi saya ingin bereksperimen dengan kernel lain). <br><br>  Ke arah mana pun saya tidak “melihat” titik, saya pergi jarak yang ditentukan dan menambahkan titik di tempat di mana saya berhenti (terlepas dari apakah saya menemukan sesuatu atau tidak).  Jika saya melihat titik di salah satu arah, saya pindah ke sana dan memeriksa apakah saya bisa sampai di sana.  Jika saya bisa, maka saya hanya menambahkan tepi yang terlihat sehingga pengguna dapat dengan mudah melihat bahwa titik-titik tersebut terhubung.  Jika saya tidak bisa, maka saya menambahkan titik baru di titik tabrakan, mendefinisikan batas hambatan. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode pengambilan sampel ini bekerja dengan baik. </font><font style="vertical-align: inherit;">Hal ini memungkinkan kita untuk mengontrol pengambilan sampel secara tepat menggunakan parameter nyaman yang mudah disesuaikan, menyimpan semua poin yang diperlukan dan menghindari tessellation yang tidak perlu, yang mengarah pada pengisian ruang yang sangat cepat:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/e45/60e/699e4560ef50242ff48ba0682554248a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena algoritme melakukan pencarian sepanjang arah, dan tidak hanya menggunakan kedekatan, ia dilindungi dari gema batas dan membatasi pengambilan sampel berlebihan hanya pada batas-batas yang kami butuhkan: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/673/618/6f3673618d182bb1810e2577c18ab1ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, algoritma ini sama sekali tidak terpengaruh oleh transisi negara atau masalah dengan manifold yang kompleks. Ini hanya berurusan dengan poin, dan poin ini bisa di mana saja, dan yang baru dapat ditambahkan kapan saja. Jika Anda sudah menyusun peta area dengan pintu tertutup, maka setelah membuka pintu, Anda hanya perlu menempatkan satu-satunya titik penelitian di sisi lain pintu dan memesan algoritma untuk terus memperluas peta ini, setelah itu akan terhubung dengan benar dan dengan benar memeriksa seluruh area di luar pintu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, kapan saja, Anda dapat mengubah parameter dasar, dan sistem akan terus bekerja. </font><font style="vertical-align: inherit;">Ingin pengambilan sampel area dilakukan dengan kepadatan yang lebih tinggi? </font><font style="vertical-align: inherit;">Turunkan jarak standarnya. </font><font style="vertical-align: inherit;">Ini dapat dilakukan sudah dalam proses membangun peta, dan algoritma akan mulai pengambilan sampel dengan kepadatan yang lebih tinggi tanpa perlu mengatur ulang hasil sebelumnya (yang mungkin memakan waktu lama).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifikasi dasar belum sempurna </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritme default sudah membatasi sampel dengan sangat hati-hati, karena persimpangan membuat titik tambahan yang tidak termasuk dalam pola pengambilan sampel, tetapi tidak perlu memeriksanya dengan perawatan yang diperlukan, karena tidak melakukan tindakan khusus saat menghadapi hambatan. Saya menyadari bahwa karena saya tahu titik mana yang dibuat selama tabrakan, dua titik tabrakan yang terdeteksi terhubung oleh tepi dan kita dapat memanggil sampel tambahan untuk mencoba menemukan lebih banyak titik batas di lingkungan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak secara aktif meneliti pendekatan ini, tetapi menciptakan metode yang belum sempurna untuk menguji teori ini, dan itu tampak menjanjikan bagi saya. </font><font style="vertical-align: inherit;">Setelah mengambil dua titik tabrakan yang dihubungkan oleh sebuah tepi, saya bergeser ke titik tengah dari tepi dan mencoba untuk menarik keluar yang tegak lurus ke tepi. </font><font style="vertical-align: inherit;">Jika tidak memotong perbatasan pada jarak yang sangat pendek, maka saya berasumsi bahwa perbatasan lebih kompleks, dan menambahkan titik target baru untuk melanjutkan pencarian di area ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan skema sederhana ini menciptakan sampling padat berkualitas tinggi di sepanjang perbatasan tanpa perlu mengambil sampel area terbuka yang berdekatan. </font><font style="vertical-align: inherit;">Berikut adalah area dengan beberapa batas, tetapi tanpa memeriksa tepinya:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/c9f/f6d/6dcc9ff6d78ddb981413ed4b795dcd5b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan di sini adalah area yang sama dengan memeriksa tepi: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak peduli betapa senangnya saya dengan hasil ini, saya terkejut dengan kurangnya algoritma yang secara signifikan lebih baik untuk pengambilan sampel perbatasan, dan saya akan mencoba untuk mengambil beberapa metode lagi di masa depan. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemenangan cepat </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun hanya menginvestasikan sedikit waktu dalam pengembangan dan membuat kode yang cukup sederhana, saya memastikan bahwa Walk Monster sudah menciptakan output yang cukup cocok yang dapat mendeteksi masalah nyata dalam game. </font><font style="vertical-align: inherit;">Berikut adalah contoh masalah yang saya temukan selama pengembangan algoritma:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ed/6f6/823/4ed6f6823ba2de2886a0fd83f702aa97.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lereng di sisi platform ini tidak boleh dilewati, tetapi pemain bisa berjalan di atasnya. </font><font style="vertical-align: inherit;">Ini terjadi karena dalam kode gerakan pemain ada cara patologis yang buruk dalam memproses geometri miring. </font><font style="vertical-align: inherit;">Sekarang saya tahu bahwa dia ada di sana, dan saya akan memperbaikinya untuk memastikan keandalannya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c38/b83/530c38b83fd5762238c3210d45e72d86.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saksi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seharusnya menjadi permainan kontemplatif, tetapi bertanya-tanya mengapa tampaknya ada batu, meskipun bukan, bukan salah satu dari koansnya. </font><font style="vertical-align: inherit;">Seperti yang Anda tebak, masalah ini muncul karena seseorang meninggalkan jumlah tabrakan dalam permainan setelah menghapus geometri yang menunjukkannya. </font><font style="vertical-align: inherit;">Ini dapat dengan mudah terjadi, dan sangat baik bahwa kami memiliki alat yang dapat dengan cepat mengenali kesalahan tersebut sehingga orang tidak perlu melakukannya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/233/c86/122233c86cd7f7cf4f08e69cbb76404a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/616/377/012616377b5515b2ee23d71da78bdeeb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benda-benda ini seharusnya adalah batu yang tidak bisa dilewati, tetapi Walk Monster menemukan bahwa ini tidak terjadi. </font><font style="vertical-align: inherit;">Lebih buruk lagi, Walk Monster menemukan bahwa karena alasan tertentu jalannya hanya satu arah (dari tangkapan layar dari kiri ke kanan), tetapi ini tidak boleh terjadi. </font><font style="vertical-align: inherit;">Saya memastikan bahwa pemain benar-benar dapat melakukan ini (saya berhasil). </font><font style="vertical-align: inherit;">Sangat menarik untuk mengamati terjadinya kesalahan seperti itu!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertanyaan terbuka </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika Anda melihat hasil yang baik yang dapat dikembangkan lebih lanjut, itu menginspirasi. </font><font style="vertical-align: inherit;">Seperti yang saya katakan, jika Anda memilih nama yang cocok untuk file sumber, maka semuanya akan berjalan seperti jam! </font><font style="vertical-align: inherit;">Tetapi semua pekerjaan ini selesai hanya dalam beberapa hari, jadi itu jauh dari lengkap, dan banyak yang telah dilakukan sepenuhnya diimprovisasi. </font><font style="vertical-align: inherit;">Jika saya punya cukup waktu untuk pengembangan lebih lanjut dari sistem ini, maka ada baiknya menjawab beberapa pertanyaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, apa yang perlu dilakukan pasca pengolahan dengan data sehingga lebih mudah untuk divisualisasikan? </font><font style="vertical-align: inherit;">Akan sulit bagi orang untuk mengetahui jaringan titik dan tepi yang tidak diproses, tetapi jika Anda meningkatkan deskripsi data, ini mungkin akan membuat sulit untuk mengevaluasi area yang sulit dilewati pada pandangan pertama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, bagaimana pola pengambilan sampel di sekitar perbatasan dapat ditingkatkan untuk memastikan bahwa jumlah "lubang" maksimum ditemukan? Adakah cara yang baik untuk mengkarakterisasi pengurangan angka menjadi kisi, dan adakah skema tesselasi berkualitas tinggi yang memaksimalkan kemungkinan melintasi dan melewati angka-angka ini? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketiga, pola pengambilan sampel mana yang paling baik untuk mengisi ruang - teratur atau acak? Saya dapat dengan mudah mengubah kriteria untuk memilih poin target untuk membuat lebih banyak pola acak, tetapi tidak begitu jelas apakah ini layak dilakukan, dan jika demikian, jenis pola acak apa yang akan lebih baik.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keempat, informasi lain apa yang ingin kita dapatkan dari peta area yang bisa dilewati jika kita sudah belajar bagaimana membangunnya? Misalnya, sangat mudah untuk memperluas sistem yang ada dengan fungsi seperti mencari jalur atau peta jarak, sehingga pengguna dapat memilih titik dan meminta jalur terpendek di antara itu dan beberapa titik lain, atau melihat peta panas jarak antara titik dan titik lain dari peta. Apakah pertanyaan seperti itu akan membantu? Pertanyaan apa lagi yang bisa saya gunakan?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, visualisasi Walk Monster dari area yang dapat dilewati lebih dari cukup untuk menunjukkan bahwa kode gerakan pemain sangat buruk. </font><font style="vertical-align: inherit;">Saya berencana untuk beralih ke menciptakan sistem untuk pengujian kartu malam menggunakan metode simulasi input pengguna, tetapi jelas bahwa kita sudah memiliki cukup banyak masalah untuk dipecahkan tanpa langkah ini. </font><font style="vertical-align: inherit;">Oleh karena itu, langkah selanjutnya adalah meningkatkan keandalan kode gerakan pemain. </font><font style="vertical-align: inherit;">Dan ketika saya sedang mengerjakan ini, saya ingin memeriksa apakah mungkin untuk meningkatkan kecepatan eksekusi sebesar satu atau dua urutan, karena sementara pekerjaan Walk Monster sangat diperlambat oleh sistem rem tabrakan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423519/">https://habr.com/ru/post/id423519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423505/index.html">Zuckerberg menjual saham Facebook seharga $ 13 miliar sehingga "anak-anak kita tidak perlu sakit"</a></li>
<li><a href="../id423507/index.html">Bagaimana cara menyimpan memori pada tab browser, tetapi tidak kehilangan isinya. Pengalaman tim Yandex.Browser</a></li>
<li><a href="../id423511/index.html">Mencegah instalasi Firefox dan Chrome di Windows 10</a></li>
<li><a href="../id423513/index.html">Kami menghemat pengontrol RAID, atau cara memberi makan Varia dengan Iops</a></li>
<li><a href="../id423515/index.html">Apakah KERING baik atau dapat merusak O dari SOLID</a></li>
<li><a href="../id423521/index.html">Tujuh aturan praktis untuk bereksperimen dengan situs web</a></li>
<li><a href="../id423523/index.html">Sensor gabungan, dengan preferensi dan penyair</a></li>
<li><a href="../id423527/index.html">Aplikasi anak-anak secara besar-besaran mengumpulkan data pribadi dan meneruskannya kepada pihak ketiga</a></li>
<li><a href="../id423529/index.html">Apa yang dibutuhkan seluruh tim untuk bekerja? Bagaimana cara menyeret semua orang ke dalam sistem manajemen proyek?</a></li>
<li><a href="../id423531/index.html">Reddit Evolusi Arsitektur Bergerak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>