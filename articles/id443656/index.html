<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèæ üèΩ ‚úåüèº Mengikuti Jejak Kalkulator: Hitung Ulang üöÉ ‚èèÔ∏è ‚§¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelumnya kami melakukan review kode dari paket matematika besar, misalnya, Scilab dan Oktaf, di mana kalkulator tetap menyendiri sebagai utilitas ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengikuti Jejak Kalkulator: Hitung Ulang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/443656/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8-/gy/xn/8-gyxngfcuknt6ufomhpg4kpjry.png"></div><br>  Sebelumnya kami melakukan review kode dari paket matematika besar, misalnya, Scilab dan Oktaf, di mana kalkulator tetap menyendiri sebagai utilitas kecil, di mana sulit untuk membuat kesalahan karena basis kode kecil mereka.  Kami salah bahwa kami tidak memperhatikan mereka.  Kasus dengan memposting kode sumber kalkulator Windows menunjukkan bahwa sebenarnya semua orang tertarik untuk mendiskusikan jenis kesalahan yang bersembunyi di dalamnya.  Apalagi jumlah kesalahan di sana lebih dari cukup untuk menulis artikel tentang itu.  Kolega saya dan saya, kami memutuskan untuk menjelajahi kode sejumlah kalkulator populer, dan ternyata kode kalkulator Windows tidak terlalu buruk (spoiler). <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hitung Ulang!</a>  adalah kalkulator desktop lintas platform multi guna.  Mudah digunakan tetapi memberikan daya dan keserbagunaan yang biasanya dicadangkan untuk paket matematika yang rumit, serta alat yang berguna untuk kebutuhan sehari-hari (seperti konversi mata uang dan perhitungan persen).  Proyek ini terdiri dari dua komponen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libqalculate</a> (library dan CLI) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qalculate-gtk</a> (GTK + UI).  Studi ini hanya melibatkan kode libqalculate. <br><br>  Untuk membandingkan proyek dengan Windows Calculator dengan mudah, yang baru-baru ini kami periksa, saya mengutip keluaran dari utilitas Cloc untuk libqalculate: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/214/1f7/e35/2141f7e35bc5af14579e61f9bf4d907a.png"></div><br>  Mempertimbangkannya secara subjektif, ada lebih banyak kesalahan di dalamnya dan mereka lebih kritis daripada dalam kode kalkulator Windows.  Namun demikian, saya akan merekomendasikan membuat kesimpulan sendiri, setelah membaca ikhtisar kode ini. <br><br>  Ngomong-ngomong, inilah tautan ke artikel tentang pemeriksaan kalkulator dari Microsoft: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghitung Bug di Kalkulator Windows</a> ". <br><br>  Alat analisis adalah penganalisa kode statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> .  Ini adalah serangkaian solusi untuk kontrol kualitas kode, mencari bug dan kerentanan potensial.  Bahasa yang didukung meliputi: C, C ++, C # dan Java.  Anda dapat menjalankan penganalisis pada Windows, Linux dan macOS. <br><br><h2>  Salin dan tempel lagi dan lagi! </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V523</a> Pernyataan 'lalu' sama dengan pernyataan 'lain'.  Number.cc 4018 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::square() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpfr_cmpabs(i_value-&gt;internalLowerFloat(), i_value-&gt;internalUpperFloat()) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } .... }</code> </pre> <br>  Kode ini benar-benar sama di blok <i>if</i> and <i>else</i> <i>.</i>  Fragmen kode yang berdekatan sangat mirip dengan yang ini, tetapi fungsi yang berbeda digunakan di dalamnya: <i>internalLowerFloat ()</i> dan <i>internalUpperFloat ()</i> .  Aman untuk mengasumsikan bahwa pengembang menyalin kode dan lupa untuk memperbaiki nama fungsi di sini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> Ada sub-ekspresi identik '! Mtr2.number (). IsReal ()' di kiri dan di kanan '||'  operator.  BuiltinFunctions.cc 6274 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegrateFunction::calculate(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mtr2.isNumber() || !mtr2.number().isReal() || !mtr.isNumber() || !mtr2.number().isReal()) b_unknown_precision = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  Dalam hal ini, ekspresi duplikat muncul karena fakta bahwa di satu tempat <i>mtr2</i> ditulis, bukan <i>mtr.</i>  Dengan demikian, panggilan fungsi <i>mtr.number (). IsReal ()</i> tidak ada dalam kondisi tersebut. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> Ada sub-ekspresi identik 'muatan [1] .representsNonPositive ()' ke kiri dan ke kanan '||'  operator.  BuiltinFunctions.cc 5785 <br><br><br><br>  Kami tidak akan pernah menemukan cacat dalam kode ini secara manual!  Tapi di sini ada.  Selain itu, dalam file asli fragmen ini ditulis dalam satu baris.  Penganalisis telah mendeteksi duplikasi ekspresi <i>muatan [1] .representsNonPositive ()</i> , yang dapat menunjukkan kesalahan ketik atau, akibatnya, kesalahan potensial. <br><br>  Inilah seluruh daftar tempat mencurigakan, yang sulit ditemukan. <br><br><ul><li>  V501 Ada sub-ekspresi identik 'muatan [1] .representsNonPositive ()' ke kiri dan ke kanan '||'  operator.  BuiltinFunctions.cc 5788 </li><li>  V501 Ada sub-ekspresi identik 'tambahkan' ke kiri dan ke kanan operator '&amp;&amp;'.  MathStructure.cc 1780 </li><li>  V501 Ada sub-ekspresi identik 'tambahkan' ke kiri dan ke kanan operator '&amp;&amp;'.  MathStructure.cc 2043 </li><li>  V501 Ada sub-ekspresi yang identik '(* v_subs [v_order [1]]). Merupakan Representatif (benar)' di sebelah kiri dan di sebelah kanan operator '&amp;&amp;'.  MathStructure.cc 5569 </li></ul><br><h2>  Loop Dengan Kondisi Yang Tidak Benar </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V534</a> Kemungkinan variabel yang salah sedang dibandingkan di dalam operator 'untuk'.  Pertimbangkan untuk meninjau 'i'.  MathStructure.cc 28741 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MathStructure::isolate_x_sub(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar-&gt;size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar)[i].contains(x_var)) { mvar2 = &amp;(*mvar)[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mvar-&gt;isMultiplication()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar2-&gt;size(); i2++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar2)[i2].contains(x_var)) {mvar2 = &amp;(*mvar2)[i2]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Di loop dalam, variabel <i>i2</i> mewakili penghitung, tetapi karena kesalahan ketik kesalahan dibuat - variabel <i>i</i> dari loop luar digunakan dalam kondisi loop keluar. <br><br><h2>  Redundansi atau kesalahan? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V590</a> Pertimbangkan untuk memeriksa ungkapan ini.  Ekspresi berlebihan atau mengandung kesalahan cetak.  Number.cc 6564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Number &amp;o, MathOperation op) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i1 &gt;= COMPARISON_RESULT_UNKNOWN &amp;&amp; (i2 == COMPARISON_RESULT_UNKNOWN || i2 != COMPARISON_RESULT_LESS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  3 tahun yang lalu setelah saya melihat kode semacam itu, saya menulis lembar contekan untuk saya dan pengembang lain: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekspresi logis dalam C / C ++. Kesalahan yang Dibuat oleh Profesional</a> ". Ketika saya menemukan kode seperti itu, saya memastikan bahwa catatan itu belum menjadi kurang relevan.  Anda dapat melihat ke dalam artikel, menemukan pola kesalahan yang sesuai dengan kode, dan mencari tahu semua nuansanya. <br><br>  Dalam kasus contoh ini, kita akan pergi ke bagian ‚ÄúEkspresi == ||  ! = "Dan cari tahu bahwa ekspresi <i>i2 == COMPARISON_RESULT_UNKNOWN</i> tidak mempengaruhi apa pun. <br><br><h2>  Dereferencing Pointer Tidak Dicentang </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595 Pointer</a> 'o_data' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 1108, 1112. DataSet.cc 1108 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DataObjectArgument::subprintlong() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = _(<span class="hljs-string"><span class="hljs-string">"an object from"</span></span>); str += <span class="hljs-string"><span class="hljs-string">" \""</span></span>; str += o_data-&gt;title(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= str += "\""; DataPropertyIter it; DataProperty *o = NULL; if(o_data) { // &lt;= o = o_data-&gt;getFirstProperty(&amp;it); } .... }</span></span></code> </pre> <br>  Dalam satu fungsi pointer <i>o_data</i> dereferenced baik tanpa maupun dengan cek.  Ini bisa berupa kode yang berlebihan, atau kesalahan potensial.  Saya condong ke arah yang terakhir. <br><br>  Ada dua tempat serupa: <br><br><ul><li>  V595 Pointer 'o_assumption' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 229, 230. Variable.cc 229 </li><li>  V595 Pointer 'i_value' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 3412, 3427. Number.cc 3412 </li></ul><br><h2>  gratis () atau hapus []? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'baru' tetapi dirilis menggunakan fungsi 'bebas'.  Pertimbangkan untuk memeriksa logika operasi di belakang variabel 'remcopy'.  Number.cc 8123 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Number::print(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!exact &amp;&amp; precision2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(try_infinite_series) { remcopy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mpz_t</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= mpz_init_set(*remcopy, remainder); } mpz_mul_si(remainder, remainder, base); mpz_tdiv_qr(remainder, remainder2, remainder, d); exact = (mpz_sgn(remainder2) == 0); if(!started) { started = (mpz_sgn(remainder) != 0); } if(started) { mpz_mul_si(num, num, base); mpz_add(num, num, remainder); } if(try_infinite_series) { if(started &amp;&amp; first_rem_check == 0) { remainders.push_back(remcopy); } else { if(started) first_rem_check--; mpz_clear(*remcopy); free(remcopy); // &lt;= } } .... } .... }</span></span></code> </pre> <br>  Memori untuk array <i>salinan</i> dialokasikan dan dirilis dengan cara yang berbeda, yang merupakan kesalahan serius. <br><br><h2>  Perubahan yang hilang </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand_partial_fractions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MathStructure &amp;m, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b_poly &amp;&amp; !mquo.isZero()) { MathStructure m = mquo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mrem.isZero()) { m += mrem; m.last() *= mtest[i]; m.childrenUpdated(); } expand_partial_fractions(m, eo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  Variabel <i>m</i> dalam fungsi dilewatkan oleh referensi, yang berarti modifikasi.  Namun, penganalisa telah mendeteksi bahwa kode tersebut berisi variabel dengan nama yang sama, yang tumpang tindih dengan cakupan parameter fungsi, yang memungkinkan hilangnya perubahan. <br><br><h2>  Pointer aneh </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V774 Penunjuk</a> 'cu' digunakan setelah memori dilepaskan.  Calculator.cc 3595 <br><br><pre> <code class="cpp hljs">MathStructure Calculator::convertToBestUnit(....) { .... CompositeUnit *cu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeUnit(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"...."</span></span>); cu-&gt;add(....); Unit *u = getBestUnit(cu, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, eo.local_currency_conversion); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(u == cu) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cu; <span class="hljs-comment"><span class="hljs-comment">// &lt;= return mstruct_new; } delete cu; // &lt;= if(eo.approximation == APPROXIMATION_EXACT &amp;&amp; cu-&gt;hasApproximateRelationTo(u, true)) { // &lt;= if(!u-&gt;isRegistered()) delete u; return mstruct_new; } .... }</span></span></code> </pre> <br>  Penganalisa memperingatkan bahwa kode memanggil metode objek <i>cu</i> setelah deallocating memori.  Tetapi ketika mencoba untuk bergulat dengannya, kode tersebut ternyata menjadi lebih aneh.  Pertama, panggilan <i>delete cu</i> selalu terjadi - baik dalam kondisi dan setelah itu.  Kedua, kode setelah kondisi menyiratkan bahwa pointer <i>u</i> dan <i>cu</i> tidak sama, yang berarti bahwa setelah menghapus objek <i>cu</i> , cukup logis untuk menggunakan objek <i>u</i> .  Kemungkinan besar, kesalahan ketik dibuat dalam kode dan pembuat kode hanya ingin menggunakan variabel <i>u</i> . <br><br><h2>  Penggunaan fungsi find </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V797</a> Fungsi 'find' digunakan seolah-olah mengembalikan tipe bool.  Nilai pengembalian fungsi mungkin harus dibandingkan dengan std :: string :: npos.  Unit.cc 404 <br><br><pre> <code class="cpp hljs">MathStructure &amp;AliasUnit::convertFromFirstBaseUnit(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i_exp != <span class="hljs-number"><span class="hljs-number">1</span></span>) mexp /= i_exp; ParseOptions po; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isApproximate() &amp;&amp; suncertainty.empty() &amp;&amp; precision() == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sinverse.find(DOT) || svalue.find(DOT)) po.read_precision = READ_PRECISION_WHEN_DECIMALS; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> po.read_precision = ALWAYS_READ_PRECISION; } .... }</code> </pre> <br>  Meskipun kode berhasil dikompilasi, kode tersebut terlihat mencurigakan, karena fungsi <i>find</i> mengembalikan jumlah tipe <i>std :: string :: size_type</i> .  Kondisi ini akan benar jika titik ditemukan di bagian mana pun dari string kecuali jika titiknya ada di awal.  Ini cek aneh.  Saya tidak yakin tetapi, mungkin, kode ini harus ditulis ulang sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sinverse.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos || svalue.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { po.read_precision = READ_PRECISION_WHEN_DECIMALS; }</code> </pre> <br><h2>  Potensi kebocoran memori </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V701</a> realloc () kemungkinan kebocoran: ketika realloc () gagal mengalokasikan memori, 'buffer' pointer asli hilang.  Pertimbangkan untuk menetapkan realloc () ke pointer sementara.  util.cc 703 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">utf8_strdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_ICU .... outlength = length + 4; buffer = (char*) realloc(buffer, outlength * sizeof(char)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= .... #else return NULL; #endif }</span></span></span></span></code> </pre> <br>  Ketika bekerja dengan fungsi <i>realloc ()</i> disarankan untuk menggunakan buffer perantara, seperti dalam kasus jika tidak mungkin mengalokasikan memori, penunjuk ke area memori lama akan hilang. <br><br><h2>  Kesimpulan </h2><br>  The Qalculate!  proyek menduduki puncak daftar kalkulator gratis terbaik, sedangkan itu berisi banyak kesalahan serius.  Di sisi lain, kami belum memeriksa pesaingnya.  Kami akan mencoba memeriksa semua kalkulator populer. <br><br>  Sedangkan untuk membandingkan dengan kualitas kalkulator dari dunia Windows, utilitas dari Microsoft terlihat lebih andal dan berfungsi dengan baik sejauh ini. <br><br>  Periksa "Kalkulator" Anda sendiri - unduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> dan coba untuk proyek Anda.  :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443656/">https://habr.com/ru/post/id443656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443644/index.html">Gulung telur dengan Unity</a></li>
<li><a href="../id443648/index.html">Dokumentasi pengguna: apa yang membuatnya buruk dan bagaimana cara memperbaikinya</a></li>
<li><a href="../id443650/index.html">Begitu-begitu-begitu dan tidak ada tic. Apa perbedaan antara prosesor Intel Core dari generasi yang berbeda berdasarkan satu arsitektur</a></li>
<li><a href="../id443652/index.html">Setiap hari di Outlook saya baru saja ...</a></li>
<li><a href="../id443654/index.html">Mengikuti jejak kalkulator: Hitung Ulang</a></li>
<li><a href="../id443658/index.html">Mengkonfigurasi kluster HA Kubernetes pada logam telanjang, pemantauan, log, dan contoh penggunaan. Bagian 3/3</a></li>
<li><a href="../id443660/index.html">Para ahli: "Pemindai 3D biayanya 10 kali lebih murah daripada kesalahan dengan kontrol kualitas tradisional"</a></li>
<li><a href="../id443662/index.html">Memahami Kode Bersih di Android</a></li>
<li><a href="../id443664/index.html">Stasiun Cuaca Arduino</a></li>
<li><a href="../id443666/index.html">Pendekatan kami untuk mewarnai benang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>