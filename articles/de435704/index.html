<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öõÔ∏è üë∏üèº ‚ùáÔ∏è Architekturl√∂sungen f√ºr ein Handyspiel. Teil 2: Befehl und ihre Warteschlangen ü§õüèº üìï ü§π</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil des Artikels haben wir untersucht, wie das Modell so angeordnet werden sollte, dass es einfach zu verwenden ist, aber das Debuggen und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architekturl√∂sungen f√ºr ein Handyspiel. Teil 2: Befehl und ihre Warteschlangen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435704/"><img src="https://habrastorage.org/webt/1n/ji/xq/1njixqpyay22mmuyckufhgouye8.jpeg"><br><br>  Im ersten Teil des Artikels haben wir untersucht, wie das Modell so angeordnet werden sollte, dass es einfach zu verwenden ist, aber das Debuggen und Verschrauben von Schnittstellen ist einfach.  In diesem Teil werden wir die R√ºckgabe von Befehlen f√ºr √Ñnderungen im Modell in all seiner Sch√∂nheit und Vielfalt betrachten.  Nach wie vor liegt die Priorit√§t f√ºr uns in der Bequemlichkeit des Debuggens, der Minimierung der Gesten, die ein Programmierer zum Erstellen einer neuen Funktion ausf√ºhren muss, sowie der Lesbarkeit des Codes f√ºr eine Person. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturl√∂sungen f√ºr ein Handyspiel.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Modell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturl√∂sungen f√ºr ein Handyspiel.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Blick auf den Strahlschub</a> <br><a name="habracut"></a><br><h2>  Warum befehlen </h2><br>  Das Befehlsmuster klingt laut, aber tats√§chlich ist es nur ein Objekt, in dem alles, was f√ºr die angeforderte Operation erforderlich ist, hinzugef√ºgt und dort gespeichert wird.  Wir w√§hlen diesen Ansatz, zumindest weil unsere Teams √ºber das Netzwerk gesendet werden und sogar wir einige Kopien des Spielstatus zur offiziellen Verwendung erhalten.  Wenn der Benutzer auf die Schaltfl√§che klickt, wird eine Instanz der Befehlsklasse erstellt und an den Empf√§nger gesendet.  Die Bedeutung des Buchstabens C in der Abk√ºrzung MVC ist etwas anders. <br><br><h2>  Vorhersage des Ergebnisses und √úberpr√ºfung der Befehle √ºber das Netzwerk </h2><br>  In diesem Fall ist der spezifische Code weniger wichtig als die Idee.  Und hier ist die Idee: <br><br>  Ein Spiel mit Selbstachtung kann nicht auf eine Antwort vom Server warten, bevor es auf die Schaltfl√§che reagiert.  Nat√ºrlich wird das Internet immer besser und Sie k√∂nnen eine Reihe von Servern auf der ganzen Welt haben, und ich kenne sogar ein paar erfolgreiche Spiele, die auf eine Antwort vom Server warten. Eines davon ist sogar Summoning Wars, aber das m√ºssen Sie trotzdem nicht tun.  Da f√ºr das mobile Internet Verz√∂gerungen von 5 bis 15 Sekunden eher die Norm als eine Ausnahme sind, sollte zumindest in Moskau das Spiel wirklich gro√üartig sein, damit die Spieler nicht darauf achten. <br><br>  Dementsprechend haben wir einen Spielstatus, der alle f√ºr die Schnittstelle erforderlichen Informationen darstellt, und die Befehle werden sofort darauf angewendet und erst danach an den Server gesendet.  Normalerweise sitzen flei√üige Java-Programmierer auf dem Server und duplizieren alle neuen Funktionen einzeln in einer anderen Sprache.  Bei unserem ‚ÄûHirsch‚Äú -Projekt erreichte ihre Anzahl 3 Personen, und Fehler beim Portieren waren eine st√§ndige Quelle schwer fassbarer Freude.  Stattdessen k√∂nnen wir es anders machen.  Wir f√ºhren auf dem .NET-Server und auf der Serverseite denselben Befehlscode wie auf dem Client aus. <br><br>  Das im letzten Artikel beschriebene Modell bietet uns eine neue interessante M√∂glichkeit zum Selbsttest.  Nachdem Sie den Befehl auf dem Client ausgef√ºhrt haben, berechnen wir den Hash der √Ñnderung, die im GameState-Baum aufgetreten ist, und wenden ihn auf das Team an.  Wenn der Server denselben Befehlscode ausf√ºhrt und der Hash der √Ñnderungen nicht √ºbereinstimmt, ist ein Fehler aufgetreten. <br><br>  Erste Vorteile: <br><br><ul><li>  Diese L√∂sung beschleunigt die Entwicklung erheblich und minimiert die Anzahl der Serverprogrammierer. </li><li>  Wenn der Programmierer beispielsweise Fehler gemacht hat, die zu nicht deterministischem Verhalten gef√ºhrt haben, hat er den ersten Wert aus dem W√∂rterbuch abgerufen oder DateTime.now verwendet und im Allgemeinen einige Werte verwendet, die nicht explizit in die Befehlsfelder geschrieben wurden. Wenn sie auf dem Server ausgef√ºhrt werden, stimmt der Hash nicht √ºberein wir werden es herausfinden. </li><li>  Die Client-Entwicklung kann vorerst √ºberhaupt ohne Server durchgef√ºhrt werden.  Sie k√∂nnen sogar in ein benutzerfreundliches Alpha wechseln, ohne einen Server zu haben.  Dies ist nicht nur f√ºr Indie-Entwickler n√ºtzlich, die nachts ihr Traumspiel verpassen.  Als ich in Piksonik war, gab es einen Fall, in dem der Serverprogrammierer alle Polymere verlor und unser Spiel einer Moderation unterzogen werden musste, da anstelle des Servers hin und wieder ein Dummy dumm den gesamten Spielstatus verteidigte. </li></ul><br>  Ein Nachteil, der aus irgendeinem Grund systematisch untersch√§tzt wird: <br><br><ul><li>  Wenn der Client-Programmierer etwas falsch gemacht hat und es beim Testen unsichtbar ist, zum Beispiel die Wahrscheinlichkeit von Waren in den mysteri√∂sen Kisten, gibt es niemanden, der dasselbe ein zweites Mal schreibt und einen Fehler findet.  Autoportable Code erfordert eine viel verantwortungsvollere Haltung gegen√ºber Tests. </li></ul><br><h2>  Detaillierte Debugging-Informationen </h2><br>  Eine unserer erkl√§rten Priorit√§ten ist das bequeme Debuggen.  Wenn wir w√§hrend der Ausf√ºhrung des Teams die Ausf√ºhrung abgefangen haben - alles ist klar, wir setzen den Spielstatus zur√ºck, senden den vollst√§ndigen Status an die Protokolle und serialisieren den Befehl, der ihn abgelegt hat, alles ist bequem und sch√∂n.  Die Situation ist komplizierter, wenn wir eine Desynchronisierung mit dem Server haben.  Weil der Client seitdem bereits mehrere andere Befehle ausgef√ºhrt hat und nicht nur herausgefunden werden muss, in welchem ‚Äã‚ÄãZustand sich das Modell befand, bevor der Befehl ausgef√ºhrt wurde, der zur Katastrophe gef√ºhrt hat, sondern ich m√∂chte es wirklich.  Das Klonen eines Gamestate vor jedem Team ist zu kompliziert und zu teuer.  Um das Problem zu l√∂sen, erschweren wir das unter der Motorhaube des Motors eingen√§hte Schema. <br><br>  Im Client haben wir nicht einen Spielstatus, sondern zwei.  Die erste dient als Hauptschnittstelle f√ºr das Rendern, die Befehle werden sofort darauf angewendet.  Danach werden die angewendeten Befehle zum Senden an den Server in die Warteschlange gestellt.  Der Server f√ºhrt dieselbe Aktion auf seiner Seite aus und best√§tigt, dass alles in Ordnung und korrekt ist.  Nachdem der Client eine Best√§tigung erhalten hat, nimmt er denselben Befehl entgegen und wendet ihn auf den zweiten Spielstatus an, wodurch er in den Zustand versetzt wird, der vom Server bereits als korrekt best√§tigt wurde.  Gleichzeitig haben wir auch die M√∂glichkeit, den Hash der aus Sicherheitsgr√ºnden vorgenommenen √Ñnderungen zu vergleichen, und wir k√∂nnen auch den vollst√§ndigen Hash des gesamten Baums auf dem Client vergleichen, den wir berechnen k√∂nnen, nachdem der Befehl ausgef√ºhrt wurde. Er wiegt ein wenig und wird als schnell genug angesehen.  Wenn der Server nicht sagt, dass alles in Ordnung ist, fragt er den Client nach Einzelheiten zu dem, was passiert ist, und der Client kann ihm einen serialisierten zweiten Gamestate genau so senden, wie er aussah, bevor der Befehl erfolgreich auf dem Client ausgef√ºhrt wurde. <br>  Die L√∂sung sieht sehr attraktiv aus, schafft jedoch zwei Probleme, die auf Codeebene gel√∂st werden m√ºssen: <br><br><ul><li>  Unter den Befehlsparametern k√∂nnen nicht nur einfache Typen, sondern auch Links zu Modellen vorhanden sein.  In einem anderen Spielzustand befinden sich genau an derselben Stelle andere Objekte des Modells.  Wir l√∂sen dieses Problem folgenderma√üen: Bevor der Befehl auf dem Client ausgef√ºhrt wird, serialisieren wir alle seine Daten.  Darunter befinden sich m√∂glicherweise Links zu Modellen, die wir in Form eines Pfads zum Modell aus der Wurzel des Spielstatus schreiben werden.  Wir tun dies vor dem Team, da sich die Pfade nach der Ausf√ºhrung √§ndern k√∂nnen.  Dann senden wir diesen Pfad an den Server, und der Server-Gamestate kann unterwegs einen Link zu seinem Modell erhalten.  In √§hnlicher Weise kann das Modell aus dem zweiten Spielzustand erhalten werden, wenn ein Team auf den zweiten Spielzustand angewendet wird. </li><li>  Zus√§tzlich zu elementaren Typen und Modellen kann ein Team Links zu Sammlungen haben.  W√∂rterbuch &lt;Schl√ºssel, Modell&gt;, W√∂rterbuch &lt;Modell, Schl√ºssel&gt;, Liste &lt;Modell&gt;, Liste &lt;Wert&gt;.  F√ºr alle m√ºssen sie Serialisierer schreiben.  Zwar kann man sich nicht darauf st√ºrzen, in einem realen Projekt entstehen solche Felder √ºberraschend selten. </li><li>  Das Senden von Befehlen nacheinander an den Server ist keine gute Idee, da der Benutzer sie schneller erstellen kann als das Internet sie hin und her ziehen kann. In einem schlechten Internet w√§chst der Pool von Befehlen, die vom Server nicht ausgearbeitet wurden.  Anstatt Befehle einzeln zu senden, senden wir sie in Stapeln von mehreren Teilen.  In diesem Fall m√ºssen Sie, nachdem Sie vom Server eine Antwort erhalten haben, dass ein Fehler aufgetreten ist, zun√§chst alle vorherigen Befehle aus demselben Paket, die vom Server best√§tigt wurden, auf den zweiten Status anwenden und erst dann den zweiten Status des Steuerelements l√∂schen und an den Server senden. </li></ul><br><h2>  Komfort und einfache Schreibbefehle </h2><br>  Der Befehlsausf√ºhrungscode ist der zweitgr√∂√üte und der am meisten verantwortliche Code im Spiel.  Je einfacher und klarer es sein wird und je weniger der Programmierer das Extra mit seinen H√§nden tun muss, um es zu schreiben, desto schneller wird der Code geschrieben, desto weniger Fehler werden gemacht und, ganz unerwartet, desto gl√ºcklicher wird der Programmierer sein.  Ich platziere den Ausf√ºhrungscode direkt im Befehl selbst, zus√§tzlich zu den allgemeinen Teilen und Funktionen, die sich in separaten statischen Regelklassen befinden, meist in Form von Erweiterungen der Modellklassen, mit denen sie arbeiten.  Ich zeige Ihnen einige Beispiele f√ºr Befehle aus meinem Lieblingsprojekt, eines sehr einfach und das andere etwas komplizierter: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetSideCostCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//              protected override bool DetaliedLog { get { return true; } } public FCMatchModel match; public int newCost; protected override void HexApply(HexKingdomsRoot root) { match.sideCost = newCost; match.CalculateAssignments(); match.CalculateNextUnassignedPlayer(); } } }</span></span></code> </pre> <br>  Und hier ist das Protokoll, das dieser Befehl hinter sich l√§sst, wenn dieses Protokoll daf√ºr nicht deaktiviert ist. <br><br><pre> <code class="json hljs">[FCSetSideCostCommand id=<span class="hljs-number"><span class="hljs-number">1</span></span> match=FCMatchModel[<span class="hljs-number"><span class="hljs-number">0</span></span>] newCost=<span class="hljs-number"><span class="hljs-number">260</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0027546</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0008689</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"0"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"SIDE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"1"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"POSSIBLE_COST"</span></span>:<span class="hljs-number"><span class="hljs-number">260</span></span>}}}}</code> </pre> <br>  Das erste im Protokoll angegebene Mal ist die Zeit, in der alle erforderlichen √Ñnderungen am Modell vorgenommen wurden, und das zweite Mal ist die Zeit, in der alle √Ñnderungen von den Schnittstellencontrollern ausgearbeitet wurden.  Dies sollte im Protokoll angezeigt werden, um nicht versehentlich etwas schrecklich Langsames zu tun oder um rechtzeitig zu bemerken, wenn die Vorg√§nge aufgrund der Gr√∂√üe des Modells selbst zu lange dauern. <br><br>  Abgesehen von Aufrufen von persistenten Objekten auf Id-shniks, die die Lesbarkeit des Protokolls erheblich beeintr√§chtigen, was hier √ºbrigens h√§tte vermieden werden k√∂nnen, sind der Befehlscode selbst und das Protokoll, das er mit dem Spielstatus erstellt hat, erstaunlich klar.  Bitte beachten Sie, dass der Programmierer im Befehlstext keine einzige zus√§tzliche Bewegung ausf√ºhrt.  Alles, was Sie brauchen, erledigt der Motor unter der Motorhaube. <br><br>  Schauen wir uns nun ein Beispiel eines gr√∂√üeren Teams an <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> HexKingdoms { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCSetUnitForPlayerCommand</span></span></span><span class="hljs-class"> :</span></span> HexKingdomsCommand { <span class="hljs-comment"><span class="hljs-comment">//            protected override bool DetaliedLog { get { return true; } } public FCSelectArmyScreenModel screen; public string unit; public int count; protected override void HexApply(HexKingdomsRoot root) { if (count == 0 &amp;&amp; screen.player.units.ContainsKey(unit)) { screen.player.units.Remove(unit); screen.selectedUnits.Remove(unit); } else if (count != 0) { if (screen.player.units.ContainsKey(unit)) { screen.player.units[unit] = count; screen.selectedUnits[unit].count = count; } else { screen.player.units.Add(unit, count); screen.selectedUnits[unit] = new ReferenceUnitModel() { type = unit, count = count }; } } screen.SetSelectedReferenceUnits(); screen.player.CalculateUnitsCost(); var side = screen.match.sides[screen.side]; screen.match.CalculatePlayerAssignmentsAcceptablity(side); screen.match.CalculateNextUnassignedPlayer(screen.player); } } }</span></span></code> </pre> <br>  Und hier ist das Protokoll, das das Team hinterlassen hat: <br><br><pre> <code class="json hljs">[FCSetUnitForPlayerCommand id=<span class="hljs-number"><span class="hljs-number">3</span></span> screen=/UI_SCREENS[main] unit=militia count=<span class="hljs-number"><span class="hljs-number">1</span></span>] Execute:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0065625</span></span> Apply:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.0004573</span></span> { <span class="hljs-attr"><span class="hljs-attr">"LOCAL_PERSISTENTS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}}, <span class="hljs-attr"><span class="hljs-attr">"ASSIGNED"</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>}}}, <span class="hljs-attr"><span class="hljs-attr">"UI_SCREENS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@changed"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"SELECTED_UNITS"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"@set"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"militia"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"@new"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"TYPE"</span></span>:<span class="hljs-string"><span class="hljs-string">"militia"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"REMARK"</span></span>:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"COUNT"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"SELECTED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"DISABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_GREEN"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"HIGHLIGHT_RED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"BUTTON_ENABLED"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}}}}}}}</code> </pre> <br>  Wie sie sagen, ist es viel klarer.  Nehmen Sie sich Zeit, um das Team mit einem praktischen, kompakten und informativen Protokoll auszustatten.  Dies ist der Schl√ºssel zu Ihrem Gl√ºck.  Das Modell muss sehr schnell funktionieren, daher haben wir dort verschiedene Tricks mit Methoden zur Speicherung und zum Zugriff auf die Felder angewendet.  Befehle werden im schlimmsten Fall einmal pro Frame ausgef√ºhrt, und zwar mehrmals seltener, sodass wir die Serialisierung und Deserialisierung der Befehlsfelder ohne Phantasie durchf√ºhren, nur durch Reflexion.  Wir sortieren die Felder nur nach Namen, damit die Reihenfolge festgelegt ist. Nun, wir werden die Liste der Felder einmal w√§hrend der Laufzeit des Befehls zusammenstellen und mit den nativen Methoden C # lesen und schreiben. <br><br><h2>  Informationsmodell f√ºr die Schnittstelle. </h2><br>  Machen wir den n√§chsten Schritt, um unsere Engine zu komplizieren. Dieser Schritt sieht be√§ngstigend aus, vereinfacht jedoch das Schreiben und Debuggen von Schnittstellen erheblich.  Insbesondere im zugeh√∂rigen MVP-Muster enth√§lt das Modell h√§ufig nur eine servergesteuerte Gesch√§ftslogik, und Informationen zum Status der Schnittstelle werden im Pr√§sentator gespeichert.  Zum Beispiel m√∂chten Sie f√ºnf Tickets bestellen.  Sie haben ihre Nummer bereits ausgew√§hlt, aber noch nicht auf die Schaltfl√§che "Bestellen" geklickt.  Informationen dar√ºber, wie viele Tickets Sie genau im Formular ausgew√§hlt haben, k√∂nnen irgendwo in den geheimen Ecken der Klasse gespeichert werden, die als Dichtung zwischen dem Modell und seiner Anzeige dienen.  Zum Beispiel wechselt ein Spieler von einem Bildschirm zum anderen, aber nichts √§ndert sich am Modell, und wo er sich befand, als die Trag√∂die passierte, wei√ü der am Debuggen beteiligte Programmierer nur aus den Worten eines √§u√üerst disziplinierten Testers.  Der Ansatz ist einfach, verst√§ndlich, fast immer verwendet und meiner Meinung nach ein wenig b√∂sartig.  Denn wenn etwas schief gelaufen ist, ist der Zustand dieses Pr√§sentators, der zu einem Fehler gef√ºhrt hat, absolut unm√∂glich herauszufinden.  Vor allem, wenn der Fehler auf dem Battle Server w√§hrend des Vorgangs f√ºr 1000 US-Dollar aufgetreten ist und nicht beim Tester in einer kontrollierten und reproduzierbaren Umgebung. <br><br>  Anstelle dieses √ºblichen Ansatzes verbieten wir jedem au√üer dem Modell, Informationen √ºber den Status der Schnittstelle zu enthalten.  Dies hat wie √ºblich Vor- und Nachteile, die bek√§mpft werden m√ºssen. <br><br><ul><li>  <b>(+1)</b> Der wichtigste Vorteil, der monatelange Programmierarbeit spart - wenn etwas schief geht, l√§dt der Programmierer einfach den Spielstatus vor dem Unfall und erh√§lt nicht nur den gleichen Status des Gesch√§ftsmodells, sondern der gesamten Benutzeroberfl√§che bis zur letzten Schaltfl√§che auf dem Bildschirm. </li><li>  <b>(+2)</b> Wenn ein Team etwas an der Benutzeroberfl√§che ge√§ndert hat, kann der Programmierer einfach in das Protokoll gehen und sehen, was sich genau in einer praktischen json-Form ge√§ndert hat, wie im vorherigen Abschnitt. </li><li>  <b>(-1)</b> Im Modell werden viele redundante Informationen angezeigt, die zum Verst√§ndnis der Gesch√§ftslogik des Spiels nicht ben√∂tigt werden und vom Server nicht zweimal ben√∂tigt werden. </li></ul><br>  Um dieses Problem zu l√∂sen, markieren wir einige Felder als notServerVerified. Es sieht beispielsweise so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EDictionary&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; uiScreens { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UI_SCREENS.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt; UI_SCREENS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDictionaryModel&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, UIStateModel&gt;() { notServerVerified = <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre> <br>  Dieser Teil des Modells und alles darunter bezieht sich ausschlie√ülich auf den Kunden. <br><br>  Wenn Sie sich noch erinnern, die Flaggen dessen, was Sie exportieren m√ºssen und was nicht so aussieht: <br><br><pre> <code class="cpp hljs">[Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ExportMode { all = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, changes = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, serverVerified = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }</code> </pre> <br>  Dementsprechend k√∂nnen Sie beim Exportieren oder Berechnen eines Hashs angeben, ob der gesamte Baum oder nur der Teil davon exportiert werden soll, der vom Server √ºberpr√ºft wird. <br><br>  Die erste offensichtliche Komplikation, die sich hier ergibt, ist die Notwendigkeit, separate Befehle zu erstellen, die vom Server √ºberpr√ºft werden m√ºssen, und solche, die nicht ben√∂tigt werden, aber es gibt auch solche, die nicht vollst√§ndig √ºberpr√ºft werden m√ºssen.  Um den Programmierer nicht mit unn√∂tigen Operationen zum Einrichten des Befehls zu beladen, werden wir erneut versuchen, alles Notwendige mit der Motorhaube zu tun. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;    ,      &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">/** &lt;summary&gt;         &lt;/summary&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyClientSide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br>  Der Programmierer, der den Befehl erstellt, kann eine oder beide dieser Funktionen √ºberschreiben.  Das alles ist nat√ºrlich wunderbar, aber wie kann ich sicherstellen, dass der Programmierer nichts durcheinander gebracht hat, und wenn er etwas durcheinander gebracht hat - wie kann er ihm helfen, es schnell und einfach zu beheben?  Es gibt zwei M√∂glichkeiten.  Ich habe das erste angewendet, aber das zweite gef√§llt Ihnen vielleicht besser. <br><br><h3>  Erster Weg </h3><br>  Wir nutzen die coolen Funktionen unseres Modells: <br><br><ol><li>  Die Engine ruft die erste Funktion auf, nach der sie einen Hash von √Ñnderungen im vom Server √ºberpr√ºften Teil des Spielstatus erh√§lt.  Wenn sich nichts √§ndert, haben wir es ausschlie√ülich mit dem Kundenteam zu tun. </li><li>  Wir erhalten den Modell-Hash der √Ñnderungen im gesamten Modell, nicht nur im vom Server verifizierten.  Wenn es sich vom vorherigen Hash unterscheidet, hat der Programmierer etwas in dem Teil des Modells durcheinander gebracht und ge√§ndert, der nicht vom Server √ºberpr√ºft wurde.  Wir gehen um den Statusbaum herum und geben dem Programmierer als Ausf√ºhrung eine vollst√§ndige Liste der Felder notServerVerified = true und der Felder unter dem Baum aus, die er ge√§ndert hat. </li><li>  Wir nennen die zweite Funktion.  Wir erhalten vom Modell einen Hash der √Ñnderungen, die im gepr√ºften Teil aufgetreten sind.  Wenn es nach dem ersten Aufruf nicht mit dem Hash √ºbereinstimmt, hat der Programmierer in der zweiten Funktion etwas getan.  Wenn wir in diesem Fall ein sehr informatives Protokoll erhalten m√∂chten, setzen wir das gesamte Modell auf den urspr√ºnglichen Zustand zur√ºck, serialisieren es in eine Datei, dann ist der Programmierer zum Debuggen n√ºtzlich, klonen es dann vollst√§ndig (zwei Zeilen - Serialisierung-Deserialisierung) und wenden jetzt zuerst das erste an Funktion, dann √ºbernehmen wir die √Ñnderungen, so dass das Modell unver√§ndert aussieht, wonach wir die zweite Funktion anwenden.  Und dann exportieren wir alle √Ñnderungen im servergepr√ºften Teil in Form von JSON und beziehen sie in die missbr√§uchliche Ausf√ºhrung ein, damit der besch√§mte Programmierer sofort sehen kann, was und wo er ge√§ndert hat, was nicht ge√§ndert werden sollte. </li></ol><br>  Es sieht nat√ºrlich be√§ngstigend aus, aber tats√§chlich sind es 7 Zeilen, denn die Funktionen, die dies tun, sind alle (au√üer das Durchqueren des Baums aus dem zweiten Absatz), wir sind bereit.  Und da dies Rezeption ist, k√∂nnen wir uns erlauben, nicht optimal zu handeln. <br><br><h3>  Zweiter Weg </h3><br>  Etwas brutaler, jetzt haben wir in ModelRoot ein Sperrfeld, aber wir k√∂nnen es in zwei Teile teilen. Eines sperrt nur die markierten Felder f√ºr den Server, das andere nur die markierten Felder.  In diesem Fall erh√§lt der Programmierer, der etwas falsch gemacht hat, sofort eine Erkl√§rung mit einer Bindung an den Ort, an dem er es getan hat.  Der einzige Nachteil dieses Ansatzes besteht darin, dass, wenn in unserem Baum eine Modelleigenschaft als nicht √ºberpr√ºfbar markiert ist, alles im Baum darunter in Bezug auf die Berechnung von Hashes und die √Ñnderungskontrolle nicht √ºberpr√ºft wird, selbst wenn nicht jedes Feld markiert wurde.  Eine Sperre untersucht nat√ºrlich nicht die Hierarchie, was bedeutet, dass alle Felder des nicht aktivierten Teils des Baums markiert werden m√ºssen, und es funktioniert an einigen Stellen nicht, dieselben Klassen in der Benutzeroberfl√§che und im √ºblichen Teil des Baums zu verwenden.  Optional ist eine solche Konstruktion m√∂glich (ich werde sie vereinfacht schreiben): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameState</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelData data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RootModelLocal local; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> locked { get; } }</code> </pre> <br>  Dann stellt sich heraus, dass jeder Teilbaum eine eigene Sperre hat.  GameState erbt Modelle, da es einfacher ist, eine separate Implementierung mit derselben Funktionalit√§t zu erstellen. <br><br><h3>  Notwendige Verbesserungen </h3><br>  Nat√ºrlich muss der Manager, der f√ºr die Verarbeitung der Teams verantwortlich ist, neue Funktionen hinzuf√ºgen.  Das Wesentliche an den √Ñnderungen ist, dass nicht alle Befehle an den Server gesendet werden, sondern nur diejenigen, die die √ºberpr√ºften √Ñnderungen erstellen.  Der Server auf seiner Seite erh√∂ht nicht den gesamten Spielstatusbaum, sondern nur den Teil, der gepr√ºft wird, und dementsprechend stimmt der Hash nur f√ºr den Teil √ºberein, der gepr√ºft wird.  Wenn ein Befehl auf dem Server ausgef√ºhrt wird, wird nur die erste der beiden Funktionen des Befehls gestartet. Wenn beim Aufl√∂sen von Verweisen auf Modelle im Gamestate der Pfad zu einem nicht √ºberpr√ºfbaren Teil des Baums f√ºhrt, wird anstelle des Modells null in die Befehlsvariable eingef√ºgt.  Alle nicht sendenden Teams werden ehrlich mit den √ºblichen √ºbereinstimmen, gelten jedoch als bereits best√§tigt.  Sobald sie die Linie erreichen und keine unbest√§tigten vor ihnen liegen, werden sie sofort auf den zweiten Zustand angewendet. <br><br>  Die Implementierung ist nicht grundlegend kompliziert.  Es ist nur so, dass die Eigenschaft jedes Felds des Modells eine weitere Bedingung hat, eine Baumdurchquerung. <br><br>  Eine weitere notwendige Verfeinerung: Sie ben√∂tigen eine separate Factory f√ºr ParsistentModel in den gepr√ºften und nicht gepr√ºften Teilen des Baums, und NextFreeId f√ºr diese Teile ist unterschiedlich. <br><br><h2>  Vom Server initiierte Befehle </h2><br>  Es gibt ein Problem, wenn der Server seinen Befehl an den Client senden m√∂chte, da der Client-Status relativ zum Server bereits einige Schritte vorw√§rts springen k√∂nnte.  Die Hauptidee ist, dass der Server, wenn er seinen Befehl senden musste, die Serverbenachrichtigung mit der n√§chsten Antwort an den Client sendet und diese in das Feld f√ºr Benachrichtigungen schreibt, die an diesen Client gesendet werden.  Der Client erh√§lt eine Benachrichtigung, bildet auf seiner Basis einen Befehl und stellt ihn an das Ende seiner Warteschlange, nachdem diejenigen, die auf dem Client abgeschlossen wurden, aber den Server noch nicht erreicht haben.  Nach einiger Zeit wird der Befehl im Rahmen der normalen Arbeit mit dem Modell an den Server gesendet.  Nachdem der Server diesen Befehl zur Verarbeitung erhalten hat, wirft er die Benachrichtigung aus der ausgehenden Warteschlange.  Wenn der Client nicht innerhalb der festgelegten Zeit mit dem n√§chsten Paket auf die Benachrichtigung geantwortet hat, wird ein Neustartbefehl an ihn gesendet.  Wenn der Client, der die Benachrichtigung erhalten hat, abgefallen ist, sp√§ter eine Verbindung herstellt oder aus irgendeinem Grund das Spiel l√§dt, wandelt der Server alle Benachrichtigungen in Befehle um, bevor er den Status erh√§lt, f√ºhrt sie auf seiner Seite aus und gibt dem beitretenden Client erst danach seinen neuen Status.  Bitte beachten Sie, dass ein Spieler m√∂glicherweise einen Konflikt mit negativen Ressourcen hat, wenn es dem Spieler gelungen ist, das Geld genau zu dem Zeitpunkt auszugeben, als der Server sie ihm weggenommen hat.  Ein Zufall ist unwahrscheinlich, aber bei einer gro√üen DAU fast unvermeidlich.  Daher sollten die Benutzeroberfl√§che und die Spielregeln in einer solchen Situation nicht zu Tode fallen. <br><br><h2>  Auszuf√ºhrende Befehle, die Sie ben√∂tigen, um die Serverantwort zu kennen </h2><br>  Ein typischer Fehler ist zu glauben, dass eine Zufallszahl nur vom Server abgerufen werden kann.  Nichts hindert Sie daran, dass derselbe Pseudozufallszahlengenerator gleichzeitig vom Client und vom Server ausgehend von einer gemeinsamen Seite ausgef√ºhrt wird.  Dar√ºber hinaus kann der aktuelle Startwert direkt im Gamestate gespeichert werden.  Einige finden es m√∂glicherweise schwierig, die Reaktion dieses Generators zu synchronisieren.  In der Tat reicht es aus, eine weitere Nummer im selben Artikel zu haben - genau wie viele Nummern vom Generator bis zu diesem Moment empfangen wurden.  Wenn Ihr Generator aus irgendeinem Grund nicht konvergiert, liegt irgendwo ein Fehler vor und der Code funktioniert nicht deterministisch.  Und diese Tatsache sollte nicht unter dem Teppich versteckt werden, sondern aussortiert und nach einem Fehler gesucht werden.  F√ºr die √ºberwiegende Mehrheit der F√§lle, einschlie√ülich der mysteri√∂sen Kisten, reicht dieser Ansatz aus. <br><br>  Es gibt jedoch Zeiten, in denen diese Option nicht geeignet ist.  Zum Beispiel spielen Sie einen sehr teuren Preis und m√∂chten nicht, dass der listige Kamerad das Spiel dekompiliert. Schreiben Sie einen Bot, der Ihnen im Voraus sagt, was aus der Diamantbox f√§llt, wenn Sie sie gerade √∂ffnen, und was, wenn Sie die Trommel vorher an einer anderen Stelle drehen.  Sie k√∂nnen Samen f√ºr jede Zufallsvariable separat speichern. Dies sch√ºtzt vor frontalem Hacking, hilft jedoch in keiner Weise vor einem Bot, der Ihnen sagt, wie viele Kisten das ben√∂tigte Produkt derzeit enth√§lt.  Nun, der offensichtlichste Fall ist, dass Sie in der Client-Konfiguration m√∂glicherweise nicht mit Informationen √ºber die Wahrscheinlichkeit eines seltenen Ereignisses gl√§nzen m√∂chten.  Kurz gesagt, manchmal muss auf eine Serverantwort gewartet werden. <br>  Solche Situationen sollten nicht durch die zus√§tzlichen Funktionen der Engine gel√∂st werden, sondern indem das Team in zwei Teile geteilt wird - der erste bereitet die Situation vor und versetzt die Schnittstelle in einen Wartezustand f√ºr Benachrichtigungen, der zweite tats√§chlich f√ºr Benachrichtigungen mit der Antwort, die Sie ben√∂tigen.  Selbst wenn Sie die Schnittstelle zwischen ihnen auf dem Client fest blockieren, kann ein anderer Befehl durchgehen - beispielsweise wird eine Energieeinheit rechtzeitig wiederhergestellt. <br><br>  Es ist wichtig zu verstehen, dass solche Situationen nicht die Regel, sondern die Ausnahme sind.  Tats√§chlich muss in den meisten Spielen nur ein Team auf eine Antwort warten - GetInitialGameState.  Ein weiteres Paket solcher Befehle ist die Interaktion zwischen Spielern in einem Metaspiel, beispielsweise GetLeaderboard.  Alle anderen zweihundert St√ºcke sind deterministisch. <br><br><h2>  Serverdatenspeicherung und das schlammige Thema der Serveroptimierung </h2><br>  Ich gebe sofort zu, dass ich ein Kunde bin, und manchmal habe ich solche Ideen und Algorithmen von bekannten Server-Servanten geh√∂rt, dass sie sich nicht einmal in meinen Kopf eingeschlichen haben.  Durch die Kommunikation mit meinen Kollegen entwickelte ich irgendwie ein Bild davon, wie meine Architektur im Idealfall auf der Serverseite funktionieren sollte.  Allerdings: Es gibt Kontraindikationen, es ist notwendig, einen spezialisierten Server zu konsultieren. <br><br>  Zun√§chst zur Datenspeicherung.  Auf Ihrer Serverseite gelten m√∂glicherweise zus√§tzliche Einschr√§nkungen.  Beispielsweise kann Ihnen die Verwendung statischer Felder untersagt werden.  Au√üerdem ist der Code von Befehlen und Modellen automatisch portierbar, aber der Eigenschaftscode auf dem Client und auf dem Server muss √ºberhaupt nicht √ºbereinstimmen.  Dort kann alles versteckt werden, bis hin zur verz√∂gerten Initialisierung von Feldwerten aus dem Memcache.  Eigenschaftsfelder k√∂nnen auch zus√§tzliche Parameter empfangen, die vom Server verwendet werden, die Arbeit des Clients jedoch nicht beeintr√§chtigen. <br><br>  Der erste Hauptunterschied des Servers: Hier werden die Felder serialisiert und deserialisiert.  Eine vern√ºnftige L√∂sung besteht darin, dass der gr√∂√üte Teil des Statusbaums in ein gro√ües Bin√§r- oder JSON-Feld serialisiert wird.  Gleichzeitig werden einige Felder aus Tabellen entnommen.  Dies ist erforderlich, da die Werte einiger Felder st√§ndig erforderlich sind, damit die Interaktionsdienste zwischen den Spielern funktionieren.  Zum Beispiel zucken das Symbol und die Ebene st√§ndig von einer Vielzahl von Personen.  Sie werden am besten in einer regul√§ren Datenbank gespeichert.  Ein vollst√§ndiger oder teilweiser, aber detaillierter Zustand einer Person wird von einer anderen Person als ihr sehr selten ben√∂tigt, wenn sich jemand entscheidet, in sein Gebiet zu schauen. <br><br>  Dar√ºber hinaus ist es unpraktisch, Felder einzeln von der Basis zu ziehen, und es kann sich als langer Widerstand herausstellen.  Eine sehr ungew√∂hnliche L√∂sung, die nur f√ºr unsere Architektur verf√ºgbar ist, kann darin bestehen, dass der Client beim Ausf√ºhren eines Befehls Informationen zu allen Feldern sammelt, die separat in Tabellen gespeichert sind, deren Getter es geschafft haben, diese zu ber√ºhren, und diese Informationen dem Befehl hinzuf√ºgt, damit der Server diese Gruppe von Feldern ausl√∂sen kann eine Anfrage an die Datenbank.  Nat√ºrlich mit vern√ºnftigen Einschr√§nkungen, um nicht um DDOS zu betteln, das von Programmierern mit gebogenen H√§nden verursacht wurde, die alles unaufmerksam ber√ºhrten. <br><br>  Bei einem solchen separaten Speicher sollten die Transaktionsmechanismen ber√ºcksichtigt werden, wenn ein Spieler in die Daten eines anderen kriecht und ihm beispielsweise Geld stiehlt.  Im Allgemeinen tun wir dies jedoch durch Benachrichtigung.  Das hei√üt, der Dieb erh√§lt sein Geld sofort und die ausgeraubte Person erh√§lt eine Benachrichtigung mit Anweisungen, um Geld abzuschreiben, wenn es darum geht. <br><br><h2>  Wie Teams zwischen Servern aufgeteilt werden </h2><br>  Nun der zweite wichtige Moment f√ºr den Server.  Es gibt zwei Ans√§tze.  Zum Verarbeiten einer Anforderung (oder eines Pakets von Anforderungen) wird zun√§chst der gesamte Status von der Datenbank oder dem Cache in den Speicher verschoben, verarbeitet und dann an die Datenbank zur√ºckgegeben.  Operationen werden atomar auf einer Reihe von verschiedenen ausf√ºhrenden Servern ausgef√ºhrt, und sie haben nur eine gemeinsame Basis, und selbst dann nicht immer.  Als Kunde ist es schockierend, den gesamten Status f√ºr jedes Team zu erh√∂hen, aber ich habe gesehen, wie es funktioniert, und es funktioniert sehr zuverl√§ssig und skalierbar.  Die zweite M√∂glichkeit besteht darin, dass der Status einmal im Speicher ansteigt und dort lebt, bis der Client nur gelegentlich abf√§llt und seinen aktuellen Status zur Datenbank hinzuf√ºgt.            .    -           .        ,       .     ,     ,   .          10 .       ,     ,       ‚Äî          .         ,                .     ‚Äî    . <br><br><h2>    </h2><br>   ,        :       ,      .      .              .   ,          .     ,          .            ‚Äî          ‚Äî            . <br><br>         ,   ,       -                     .     ,    .          ,     VR   CS,  -           . ,  ,         ,          30%. <br><br>   ,      ‚Äî    ,     .          ,      .     ,  , ,     ,    ,       . <br><br> , , -      ,     :       .     ,       .      ,   35                 .     ,       ,    . ,   ,                 ,    ‚Äî         . <br>     :       ‚Äî 30 .          ?  ‚Ññ1:   .  ‚Ññ2:       ,        3000      . <br><br>  ,                   ‚Äî  .  Irgendwie so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface Command { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; }</code> </pre> <br>    , ,     Unity     ‚Äî .    UnixTime   ,         ,         PTime,   PValue&lt;long&gt;  ,     JSON         :   - .    .   . <br><br>  :     ,       ,  , ,  .   ,   .   ,   .  PTimeOut,                .     ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PTimeOut RESTORE_ENERGY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PTimeOut() {command = (model, property) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestoreEnergyCommand() { model = model}} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> restoreEnergy { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RESTORE_ENERGY.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { RESTORE_ENERGY.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); }} }</code> </pre> <br>                ,      .     ,       ,       .            ,       ,      ,      ,      .          ,         ,              . <br><br>     -   ,        .   ,      ,       ,     ,      ,    .            ,               currentTime,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span></span>; } vs <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> event Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; setCurrentTime; }</code> </pre> <br>   ,    ,  ,                ,      .    ,      ,          ,  -       GC. <br><br><h3>  1,  ,     </h3><br>      .             ,    - .       ,    ,           .        ,      ,   ,  ,      callback,       . , .      ,           ,               ,  ,    ¬´  ¬ª , ,    .    ,   ,             . <br><br>  ,    .       ,        inventory,      .     ,   ,      -,  ,     .          ,       ¬´ ¬ª      ,      ,      ,    .     ¬´    ¬ª.         ,        .        ,       ,                 .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenMisterBox</span></span></span><span class="hljs-class"> :</span></span> Command { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BoxItemModel item; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slot; <span class="hljs-comment"><span class="hljs-comment">//        ,  . public override void Apply(GameState state) { state.inventory[item.revardKey] += item.revardCount; } //       . public override void Apply(GameState state) { var cause = state.NewPersistent&lt;WaitForCommand&gt;(); cause.key = item.key; cause.value = item.value; state.ui.delayedInventoryVisualization.Add(cause); state.ui.mysteryBoxScreen.animations.Add(new Animation() {cause = item, slot = slot})); } } public class MysteryBoxView : View { /* ... */ public override void ConnectModel(MysteryBoxScreenModel model, List&lt;Control&gt; c) { model.Get(c, MysteryBoxScreenModel.ANIMATIONS) .Control(c, onAdd = item =&gt; animationFactory(item, OnComleteOrAbort =&gt; { AsincQueue(new RemoveAnimation() {cause = item.cause, animation = item}) }), onRemove = item =&gt; {} ) } } public class InventoryView : View&lt;InventoryItem&gt; { public Text text; public override void ConnectModel(InventoryItem model, List&lt;Control&gt; c) { model.GameState.ui.Get(c, UIModel.DELAYED_INVENTORY_VISUALIZATION). .Where(c, item =&gt; item.key == model.key) .Expression(c, onChange = (IList&lt;InventoryItem&gt; list) =&gt; { int sum = 0; for (int i = 0; i &lt; list.Count; i++) sum += list[i].value; return sum; }, onAdd = null, onRemove = null ) //      .Join (c, model.GameState.Get(GameState.INVENTORY).ItemByKey(model.key)) .Expression(c, (delay, count) =&gt; count - delay) .SetText(c, text); //     ,      ,   ,  ,   ,       ,     : model.inventory.CreateVisibleInventoryItemCount(c, model.key).SetText(c, text); } } public class RemoveDelayedInventoryVisualization : Command { public DelayCauseModel cause; public override void Apply(GameState state) { state.ui.delayedInventoryVisualization.Remove(cause); } } public class RemoveAnimation : RemoveDelayedInventoryVisualization { public Animation animation public override void Apply(GameState state) { base.Apply(state); state.ui.mysteryBoxScreen.animations.Remove(animation); } }</span></span></code> </pre> <br>  Was haben wir am Ende?   View,       ,         ,           .  .          GameState        ,    ,      .    ,       ,    ,    . <br><br><h2>  Insgesamt </h2><br>  -   ,      ,                  ,     , ,   ,      .              .    , ,                        .              ,         ,       . <br>          .      ,     ,       ‚Äî    .            . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435704/">https://habr.com/ru/post/de435704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435694/index.html">Wie und warum haben wir den Algorithmus zum Bereinigen von SLAB-Caches im Linux-Kernel optimiert?</a></li>
<li><a href="../de435696/index.html">Antiquit√§ten: 1997 Computerwerbung</a></li>
<li><a href="../de435698/index.html">Schreiben Sie Ihren eigenen guten Speichermanager</a></li>
<li><a href="../de435700/index.html">8 Worst Vue.js Interview Fragen</a></li>
<li><a href="../de435702/index.html">Patenttrolle starten und gewinnen: wie ich ohne Spiel blieb</a></li>
<li><a href="../de435706/index.html">Wir verwenden rcm, um die Konfiguration in einem beliebigen Ordner bereitzustellen</a></li>
<li><a href="../de435708/index.html">Fayal: ein Treffpunkt im Atlantik</a></li>
<li><a href="../de435712/index.html">Procter & Gamble bringt Anti-Aging-Hautdrucker auf den Markt</a></li>
<li><a href="../de435714/index.html">Ukrainische Entwickler erhielten Zugriff auf Dateien von allen Ringkameras der Welt</a></li>
<li><a href="../de435718/index.html">Wir pumpen Angular NGSW mit benutzerdefinierter Logik in Service Worker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>