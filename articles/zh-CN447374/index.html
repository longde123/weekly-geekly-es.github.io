<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏼 👩‍🔬 🐅 使用PureLayout以编程方式创建界面元素（第2部分） 🕖 🧐 🤳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍Aly Yaka 撰写的文章《 使用PureLayout以编程方式创建UI元素》的翻译。 



 欢迎使用有关使用PureLayout以编程方式创建接口的文章的第二部分。 在第一部分中，我们完全用代码创建了一个简单的移动应用程序的用户界面，而无需使用Storyboards或NI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PureLayout以编程方式创建界面元素（第2部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447374/"> 哈Ha！ 我向您介绍Aly Yaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">撰写</a>的文章《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用PureLayout</a>以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编程方式创建UI元素》</a>的翻译。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/631/88d/e30/63188de305b02c7f0e14a4bd2a6350f6.jpg" alt="图片"><br><br> 欢迎使用有关使用PureLayout以编程方式创建接口的文章的第二部分。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在第一部分中，</a>我们完全用代码创建了一个简单的移动应用程序的用户界面，而无需使用Storyboards或NIB。 在本指南中，我们将介绍所有应用程序中一些最常用的用户界面元素： <br><br><ul><li>  UINavigationController /栏 </li><li>  UITableView </li><li> 自定义UITableViewCell </li></ul><br><a name="habracut"></a><br><h2>  UINavigationController </h2><br> 在我们的应用程序中，您可能需要一个导航栏，以便用户可以从联系人列表转到有关特定联系人的详细信息，然后返回列表。  <code>UINavigationController</code>可以使用导航栏轻松解决此问题。 <br><br>  <code>UINavigationController</code>只是一个堆栈，您可以在其中移动许多视图。 用户现在可以看到最上面的视图（上次移动的视图）（除非您在此视图的上方有另一个视图，比如说收藏夹）。 并且，当您按下导航控制器的顶视图控制器时，导航控制器会自动创建一个“后退”按钮（取决于设备当前的语言首选项，位于左上方或右侧），然后按此按钮将返回上一个视图。 <br><br> 所有这些都由导航控制器开箱即用地处理。 如果再添加一行，则只需要增加一行代码（如果您不想自定义导航栏）。 <br> 转到AppDelegate.swift并在下面添加以下代码行，让<code>viewController = ViewController ():</code> <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigationController = <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>(rootViewController: viewController)</code> </pre> <br> 现在更改<code>self.window? .RootViewController = viewController  self.window? .RootViewController = navigationController</code> <code>self.window? .RootViewController = viewController  self.window? .RootViewController = navigationController</code>  <code>self.window? .RootViewController = viewController  self.window? .RootViewController = navigationController</code> 。 在第一行中，我们创建了<code>UINavigationController</code>的实例，并将其<code>viewController</code>作为<code>rootViewController</code>传递给了它，它是堆栈最底部的视图控制器，这意味着该视图的导航栏上永远不会有后退按钮。 然后，给我们的窗口一个导航控制器，称为<code>rootViewController</code> ，因为现在它将包含应用程序中的所有视图。 <br><br> 现在运行您的应用程序。 结果应如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/1e6/e3a/2fb1e6e3a449bd990d30785ef9557646.jpg" alt="图片" width="500"></div><br> 不幸的是，出了点问题。 导航栏似乎与我们的upperView重叠，并且我们有几种方法可以解决此问题： <br><br><ul><li> 增大<code>upperView</code>的大小以适合导航栏的高度。 </li><li> 将导航栏的<code>isTranslucent</code>属性设置为<code>false</code> 。 这将使导航栏不透明（如果您没有注意到它有点透明），那么超级视图的顶部边缘将变为导航栏的底部。 </li></ul><br> 我个人将选择第二个选项，但是，您将学习第一个。 我还建议检查并仔细阅读有关<code>UINavigationController</code>和<code>UINavigationBar</code> Apple文档： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UINavigationController-UIKit |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple开发人员文档</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UINavigationBar-UIKit |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple开发人员文档</a> </li></ul><br> 现在转到viewDidLoad方法并添加以下行<code>self.navigationController? .NavigationBar.isTranslucent = false  super.viewDidLoad ()</code>  <code>self.navigationController? .NavigationBar.isTranslucent = false  super.viewDidLoad ()</code> ，因此看起来像这样： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController?.navigationBar.isTranslucent = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.backgroundColor = .white <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addSubviews() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.setupConstraints() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.bringSubview(toFront: avatar) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.setNeedsUpdateConstraints() }</code> </pre> <br> 您还可以将这一行<code>self.title = "John Doe"  viewDidLoad</code>添加<code>self.title = "John Doe"  viewDidLoad</code> ，这将在导航栏中添加“个人资料”，以便用户知道他当前所在的位置。 运行应用程序，结果应如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/327/147/88032714733a4e3b6030ce51e93a63d3.jpg" alt="图片" width="500"></div><br><h2> 重构我们的View Controller </h2><br> 在继续之前，我们需要减少<code>ViewController.swift</code>文件， <code>ViewController.swift</code>我们只能使用真实的逻辑，而不仅仅是用户界面元素的代码。 为此，我们可以创建<code>UIView</code>的子类，然后将所有用户界面元素移到那里。 我们这样做的原因是遵循Model-View-Controller或MVC架构模式。 了解有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">iOS上的</a> MVC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模型视图控制器（MVC）的</a>更多信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">：一种现代方法</a> 。 <br><br> 现在，右键单击Project Navigator中的<code>ContactCard</code>文件夹，然后选择“ New File”： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd3/bc3/51d/bd3bc351d325b664cb1eec2424404216.jpg" alt="图片"><br><br> 单击可可接触类，然后单击下一步。 现在，写“ ProfileView”作为类名，并在“ Subclass of：”旁边确保输入“ UIView”。 它只是告诉Xcode自动使我们的类继承自<code>UIView</code> ，并将添加一些样板代码。 现在单击下一步，然后单击创建并删除注释掉的代码： <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">/* // Only override draw() if you perform custom drawing. // An empty implementation adversely affects performance during animation. override func draw(_ rect: CGRect) { // Drawing code } */</span></span></code> </pre> <br> 现在我们可以进行重构了。 <br><br> 将视图控制器中的所有惰性变量剪切并粘贴到我们的新视图中。 <br> 在最后一个挂起的变量下面，通过键入<code>init</code>并从Xcode中选择第一个自动完成结果来覆盖<code>init(frame :)</code> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d30/f88/a04/d30f88a040c0b48c67eadc91e33dd7a9.jpg" alt="图片"><br><br> 将出现一条错误消息，指出“必需的”初始化程序“ init（coder :)”应由“ UIView”的子类提供： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a6b/056/2e4/a6b0562e48fa340a63f41e370ebb8cd6.jpg" alt="图片"><br><br> 您可以通过单击红色圆圈，然后单击“修复”来解决此问题。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de8/c0f/faf/de8c0ffafd81bd2703d1f1a9400fa45a.jpg" alt="图片"><br><br> 在任何重写的初始化程序中，几乎应该始终调用超类初始化程序，因此应在方法顶部添加以下代码行： <code>super.init (frame: frame)</code> 。 <br> 在初始化程序下剪切并粘贴<code>addSubviews()</code>方法，并在每次<code>addSubview</code>调用之前删除<code>self.view</code> 。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSubviews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { addSubview(avatar) addSubview(upperView) addSubview(segmentedControl) addSubview(editButton) }</code> </pre> <br> 然后从初始化程序调用此方法： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) addSubviews() bringSubview(toFront: avatar) }</code> </pre> <br> 对于限制，请覆盖<code>updateConstraints()</code>并在此函数的末尾添加一个调用（它将始终保留在其中）： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateConstraints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Insert code here super.updateConstraints() // Always at the bottom of the function }</span></span></code> </pre> <br> 覆盖任何方法时，通过访问Apple文档或更简单地按住Option（或Alt）键并单击函数名称来检查其文档总是有用的： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2c/30c/5e7/a2c30c5e775e0e806ee2c1a00e14c128.jpg" alt="图片"><br><br> 将约束代码从视图控制器中剪切并粘贴到我们的新方法中： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateConstraints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { avatar.autoAlignAxis(toSuperviewAxis: .vertical) avatar.autoPinEdge(toSuperviewEdge: .top, withInset: <span class="hljs-number"><span class="hljs-number">64.0</span></span>) upperView.autoPinEdgesToSuperviewEdges(with: .zero, excludingEdge: .bottom) segmentedControl.autoPinEdge(toSuperviewEdge: .<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, withInset: <span class="hljs-number"><span class="hljs-number">8.0</span></span>) segmentedControl.autoPinEdge(toSuperviewEdge: .<span class="hljs-keyword"><span class="hljs-keyword">right</span></span>, withInset: <span class="hljs-number"><span class="hljs-number">8.0</span></span>) segmentedControl.autoPinEdge(.top, to: .bottom, of: avatar, withOffset: <span class="hljs-number"><span class="hljs-number">16.0</span></span>) editButton.autoPinEdge(.top, to: .bottom, of: upperView, withOffset: <span class="hljs-number"><span class="hljs-number">16.0</span></span>) editButton.autoPinEdge(toSuperviewEdge: .<span class="hljs-keyword"><span class="hljs-keyword">right</span></span>, withInset: <span class="hljs-number"><span class="hljs-number">8.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.updateConstraints() }</code> </pre> <br> 现在回到视图控制器，并通过<code>viewDidLoad</code>方法初始化<code>ProfileView</code>实例， <code>let profileView = ProfileView(frame: .zero)</code> ，将其作为子视图添加到<code>ViewController</code> 。 <br><br> 现在，我们的视图控制器已减少为几行代码！ <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PureLayout class ViewController: UIViewController { let profileView = ProfileView(frame: .zero) override func viewDidLoad() { super.viewDidLoad() self.navigationController?.navigationBar.isTranslucent = false self.title = "Profile" self.view.backgroundColor = .white self.view.addSubview(self.profileView) self.profileView.autoPinEdgesToSuperviewEdges() self.view.layoutIfNeeded() } }</code> </pre> <br> 为确保一切正常，请启动应用程序并检查其外观。 <br><br> 目标是拥有一个瘦弱，整洁的审查控制者。 这可能会花费很多时间，但是它将使您免于维护期间的不必要麻烦。 <br><br><h2>  UITableView </h2><br> 接下来，我们将添加一个UITableView来显示联系信息，例如电话号码，地址等。 <br><br> 如果您尚未这样做，请访问Apple文档以查看UITableView，UITableViewDataSource和UITableViewDelegate。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UITableView-UIKit |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple开发人员文档</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UITableViewDataSource-UIKit |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple开发人员文档</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UITableViewDelegate-UIKit |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple开发人员文档</a> </li></ul><br> 转到<code>ViewController.swift</code>并在<code>viewDidLoad()</code>上方为<code>tableView</code>添加<code>lazy var</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableView: <span class="hljs-type"><span class="hljs-type">UITableView</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tableView = <span class="hljs-type"><span class="hljs-type">UITableView</span></span>() tableView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> tableView.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> tableView.dataSource = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableView }()</code> </pre> <br> 如果尝试运行该应用程序，则Xcode会抱怨该类既不是<code>UITableViewController</code>的委托也不是数据源，因此我们将这两个协议添加到该类中： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewDataSource</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewDelegate</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br> 再一次，Xcode将抱怨一个不符合<code>UITableViewDataSource</code>协议的类，这意味着该协议中有一些未在该类中定义的强制性方法。 要找出在按住Cmd + Control的同时应实现的方法，请单击类定义中的<code>UITableViewDataSource</code>协议，然后继续进行协议定义。 对于任何不包含“ <code>optional</code> ”一词的方法，必须实现与该协议相对应的类。 <br><br> 这里我们有两种方法需要实现： <br><br><ol><li>  <code>public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int</code>此方法告诉表视图我们要显示多少行。 </li><li>  <code>public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell</code>此方法查询每行中的单元格。 在这里，我们初始化（或重用）单元格，然后插入要显示给用户的信息。 例如，第一个单元格将显示电话号码，第二个单元格将显示地址，依此类推。 </li></ol><br> 现在回到<code>ViewController.swift</code> ，开始输入<code>numberOfRowsInSection</code> ，当自动完成出现时，选择第一个选项。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, numberOfRowsInSection section: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { &lt;#code#&gt; }</code> </pre> <br> 删除密码并立即返回1。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, numberOfRowsInSection section: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br> 在此功能下，开始键入<code>cellForRowAt</code>并再次从自动完成中选择第一个方法。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { &lt;#code#&gt; }</code> </pre> <br> 再次，现在返回<code>UITableViewCell</code> 。 <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span>() }</code> </pre> <br> 现在，要将表视图连接到<code>ProfileView</code> ，我们将定义一个新的初始化程序，该初始化程序将表视图作为参数，以便可以将其添加为子视图并为其设置适当的限制。 <br><br> 转到<code>ProfileView.swift</code>并在初始化程序上方添加表视图的属性： <br><br> <code>var tableView: UITableView!</code> 因此，我们不确定它是否会保持不变。 <br><br> 现在，将旧的<code>init (frame :)</code>实现替换为： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(tableView: <span class="hljs-type"><span class="hljs-type">UITableView</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: .zero) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView = tableView addSubviews() bringSubview(toFront: avatar) }</code> </pre> <br>  Xcode现在将抱怨缺少<code>ProfileView</code> <code>init (frame :)</code> ，因此请返回<code>ViewController.swift</code>并将<code>let profileView = ProfileView (frame: .zero)</code>替换为 <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> profileView: <span class="hljs-type"><span class="hljs-type">UIView</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ProfileView</span></span>(tableView: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView) }()</code> </pre> <br> 现在，我们的<code>ProfileView</code>有一个指向表视图的链接，我们可以将其添加为子视图并为其设置正确的限制。 <br> 返回<code>ProfileView.swift</code> ，在<code>addSubview(tableView)</code>的末尾添加<code>addSubview(tableView)</code> ，并将这些限制设置为相对于<code>super.updateConstraints</code> <code>updateConstraints()</code> ： <br><br><pre> <code class="swift hljs">tableView.autoPinEdgesToSuperviewEdges(with: .zero, excludingEdge: .top) tableView.autoPinEdge(.top, to: .bottom, of: segmentedControl, withOffset: <span class="hljs-number"><span class="hljs-number">8</span></span>)</code> </pre> <br> 第一行在表格视图及其父视图之间添加了三个限制：表格视图的右侧，左侧和底部分别连接到纵断面图的右侧，左侧和底部。 <br><br> 第二行将表格视图的顶部附加到分段控件的底部，它们之间有八个点的间隔。 启动应用程序，结果应如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/f31/c6f/8a5f31c6f6925e6466e4bfbb94df1c03.jpg" alt="图片" width="500"></div><br> 太好了，现在一切就绪，我们可以开始介绍细胞了。 <br><br><h2>  UITableViewCell </h2><br> 要实现<code>UITableViewCell</code> ，我们几乎总是需要将该类作为子类，因此在Project Navigator中右键单击<code>ContactCard</code>文件夹，然后在“ New file ...”，“ Cocoa Touch Class”和“ Next”上单击鼠标右键。 <br><br> 在“子类：”字段中输入“ UITableViewCell”，Xcode将自动填充类名“ TableViewCell”。 在自动完成之前输入“ ProfileView”，以使最终名称为“ ProfileInfoTableViewCell”，然后单击“下一步”和“创建”。 继续并删除创建的方法，因为我们将不需要它们。 如果需要，您可以先阅读它们的描述，以了解为什么我们现在不需要它们。 <br><br> 如前所述，我们的单元格将包含基本信息，这是字段名称及其描述，因此我们需要为其添加标签。 <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">UILabel</span></span>() label.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> label.text = <span class="hljs-string"><span class="hljs-string">"Title"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> label }() <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> descriptionLabel: <span class="hljs-type"><span class="hljs-type">UILabel</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">UILabel</span></span>() label.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> label.text = <span class="hljs-string"><span class="hljs-string">"Description"</span></span> label.textColor = .gray <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> label }()</code> </pre> <br> 现在，我们将重新定义初始化程序，以便可以配置单元： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(style: <span class="hljs-type"><span class="hljs-type">UITableViewCellStyle</span></span>, reuseIdentifier: <span class="hljs-type"><span class="hljs-type">String?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(style: style, reuseIdentifier: reuseIdentifier) contentView.addSubview(titleLabel) contentView.addSubview(descriptionLabel) } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) }</code> </pre> <br> 关于限制，我们将做一些不同的操作，但是仍然非常有用： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateConstraints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> titleInsets = <span class="hljs-type"><span class="hljs-type">UIEdgeInsetsMake</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) titleLabel.autoPinEdgesToSuperviewEdges(with: titleInsets, excludingEdge: .bottom) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> descInsets = <span class="hljs-type"><span class="hljs-type">UIEdgeInsetsMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) descriptionLabel.autoPinEdgesToSuperviewEdges(with: descInsets, excludingEdge: .top) descriptionLabel.autoPinEdge(.top, to: .bottom, of: titleLabel, withOffset: <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.updateConstraints() }</code> </pre> <br> 在这里，我们开始使用<code>UIEdgeInsets</code>设置每个标签周围的间距。 可以使用<code>UIEdgeInsetsMake(top:, left:, bottom:, right:)</code>方法创建<code>UIEdgeInsets</code>对象。 例如，对于<code>titleLabel</code>我们说我们希望上限为4点，左右为8。 我们不在乎底部，因为我们将其排除在描述标记的顶部，因此将其排除在外。 花一点时间阅读并可视化您脑海中的所有约束。 <br><br> 好的，现在我们可以开始在表格视图中绘制单元格了。 让我们继续执行<code>ViewController.swift</code>并更改表格视图的延迟初始化，以在表格视图中注册此类单元格并设置每个单元格的高度。 <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> profileInfoCellReuseIdentifier = <span class="hljs-string"><span class="hljs-string">"profileInfoCellReuseIdentifier"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableView: <span class="hljs-type"><span class="hljs-type">UITableView</span></span> = { ... tableView.register(<span class="hljs-type"><span class="hljs-type">ProfileInfoTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forCellReuseIdentifier: profileInfoCellReuseIdentifier) tableView.rowHeight = <span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableView }()</code> </pre> <br> 我们还为单元重用标识符添加了一个常量。 此标识符用于在显示单元格时从表格视图中删除它们。 此优化可以（并且应该）用于帮助<code>UITableView</code>重用以前显示的用于显示新内容的单元格，而不是从头开始重新绘制新单元格。 <br> 现在让我向您展示如何在<code>cellForRowAt</code>方法的一行代码中重用单元格： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: profileInfoCellReuseIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ProfileInfoTableViewCell</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }</code> </pre> <br> 在这里，我们使用标识符将通知可重用单元格从队列中退出的表格视图，在该标识符下我们注册了用户将要出现的单元格路径。 然后，我们将单元格强制给<code>ProfileInfoTableViewCell</code>以便能够访问其属性，以便例如可以设置标题和描述。 可以使用以下方法完成此操作： <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> indexPath.row { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: cell.titleLabel.text = <span class="hljs-string"><span class="hljs-string">"Phone Number"</span></span> cell.descriptionLabel.text = <span class="hljs-string"><span class="hljs-string">"+234567890"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: cell.titleLabel.text = <span class="hljs-string"><span class="hljs-string">"Email"</span></span> cell.descriptionLabel.text = <span class="hljs-string"><span class="hljs-string">"john@doe.co"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: cell.titleLabel.text = <span class="hljs-string"><span class="hljs-string">"LinkedIn"</span></span> cell.descriptionLabel.text = <span class="hljs-string"><span class="hljs-string">"www.linkedin.com/john-doe"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }</code> </pre> <br> 现在将<code>numberOfRowsInSection</code>设置为返回“ 3”并启动您的应用程序。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/b15/586/505b15586c806763ec3c52d41a2236d5.jpg" alt="图片" width="500"></div><br> 对不对？ <br><br><h2> 自定格单元 </h2><br> 可能并且很可能会出现一种情况，您希望不同的单元格根据其内部信息具有高度，这是事先未知的。 为此，您需要一个具有自动计算尺寸的表格视图，实际上，有一种非常简单的方法来执行此操作。 <br><br> 首先，在<code>ProfileInfoTableViewCell</code>将此行添加到惰性初始化程序<code>descriptionLabel</code> ： <br><br><pre> <code class="swift hljs">label.numberOfLines = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 返回到<code>ViewController</code>并将这两行添加到表视图初始化程序中： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableView: <span class="hljs-type"><span class="hljs-type">UITableView</span></span> = { ... tableView.estimatedRowHeight = <span class="hljs-number"><span class="hljs-number">64</span></span> tableView.rowHeight = <span class="hljs-type"><span class="hljs-type">UITableViewAutomaticDimension</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableView }()</code> </pre> <br> 在这里，我们告知表格视图，行高应基于其内容具有自动计算的值。 <br><br> 关于估计的行高： <br><blockquote>  “提供行高度的非负估计可以提高加载表视图的性能。”  -Apple文件 </blockquote><br> 在<code>ViewDidLoad</code>我们需要重新加载表视图以使这些更改生效： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() ... <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView.reloadData() } }</code> </pre> <br> 现在继续添加另一个单元格，将行数增加到四，并向<code>cellForRow</code>添加另一个<code>switch</code> ： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: cell.titleLabel.text = <span class="hljs-string"><span class="hljs-string">"Address"</span></span> cell.descriptionLabel.text = <span class="hljs-string"><span class="hljs-string">"45, Walt Disney St.\n37485, Mickey Mouse State"</span></span></code> </pre> <br> 现在运行该应用程序，它看起来应该像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/f04/90c/9a8f0490c9411ff4507941dfab818d1f.jpg" alt="图片" width="500"></div><br><h2> 结论 </h2><br> 对不对？ 为了提醒我们为什么实际编写用户界面，这是我们的移动团队撰写的完整博客文章，内容涉及为什么我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不在Instabug中使用情节提要</a> 。 <br><br> 您在本课的两部分中做了什么： <br><br><ul><li> 从您的项目中删除了<code>main.storyboard</code>文件。 </li><li> 我们以编程方式创建了<code>UIWindow</code>并<code>rootViewController</code>分配了<code>rootViewController</code> 。 </li><li> 在代码中创建了各种用户界面元素，例如标签，图像视图，分段控件以及带有其单元格的表格视图。 </li><li> 在您的应用程序中嵌套了<code>UINavigationBar</code> 。 </li><li> 创建了一个动态大小的<code>UITableViewCell</code> 。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447374/">https://habr.com/ru/post/zh-CN447374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447364/index.html">Chromium上的Microsoft Edge正式开放测试</a></li>
<li><a href="../zh-CN447366/index.html">什么是启动项目的最佳方法，或者如何使其不致于造成极大痛苦的项目</a></li>
<li><a href="../zh-CN447368/index.html">不只是抓跳蚤。 为什么速度对任何商店都如此重要</a></li>
<li><a href="../zh-CN447370/index.html">为什么，由于专利制度破裂，Theranos的阴影仍然笼罩着我们</a></li>
<li><a href="../zh-CN447372/index.html">IT转型是不可避免的：从哪里开始</a></li>
<li><a href="../zh-CN447376/index.html">SNA Hackathon 2019</a></li>
<li><a href="../zh-CN447380/index.html">Kotlin例外及其功能</a></li>
<li><a href="../zh-CN447382/index.html">《统一与C＃》一书。 Gamedev从构思到实施。 第二版</a></li>
<li><a href="../zh-CN447384/index.html">功率半导体保护生态</a></li>
<li><a href="../zh-CN447388/index.html">TL； ITMO大学的摘要：非经典的大学入学，即将发生的事件和最有趣的资料</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>