<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏪ 👆🏿 🥋 Bagaimana kami memilih dan memutar kerangka kerja untuk pengujian kinerja 🐈 🧑🏾‍🤝‍🧑🏻 🎣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak cara untuk menguji API dan antarmuka. Sehubungan dengan pembukaan akses luas ke Acronis Cyber ​​Platform, kami terpaksa mencari cara untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami memilih dan memutar kerangka kerja untuk pengujian kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/474694/">  Ada banyak cara untuk menguji API dan antarmuka.  Sehubungan dengan pembukaan akses luas ke Acronis Cyber ​​Platform, kami terpaksa mencari cara untuk menguji layanan “untuk daya tahan” dari berbagai posisi.  Dalam posting ini, arsitek perangkat lunak utama Acronis Dmitry Salomatin berbicara tentang bagaimana kami memilih kerangka kerja untuk pengujian, kesulitan apa yang kami temui, dan perbaikan apa yang harus kami lakukan sendiri. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/2dd/239/11d/2dd23911d3affd694c4cfcbf01a89adc.jpg" alt="gambar"></a> <br><a name="habracut"></a><br>  Saya harus segera mengatakan bahwa kami di Acronis sangat berhati-hati dalam menguji API.  Faktanya adalah produk kami sendiri mengakses layanan melalui API yang sama yang digunakan untuk menghubungkan sistem eksternal.  Oleh karena itu, pengujian kinerja setiap antarmuka diperlukan.  Kami menguji operasi API dan secara terpisah memverifikasi operasi UI.  Hasil pengujian akan memungkinkan Anda untuk mengevaluasi apakah API itu sendiri berfungsi dengan baik, serta antarmuka pengguna.  Konfirmasikan pengembangan yang berhasil atau rumuskan tugas untuk pengembangan lebih lanjut. <br><br>  Tetapi tes berbeda.  Terkadang suatu layanan tidak langsung menunjukkan degradasi.  Bahkan jika kami menjalankan layanan yang mirip dengan produk yang sudah dirilis dalam rilis, untuk verifikasi Anda dapat memuatnya dengan data yang sama yang digunakan "dalam prod".  Dalam hal ini, Anda dapat melihat regresi, tetapi sama sekali tidak mungkin untuk menilai perspektif.  Anda tidak tahu apa yang akan terjadi jika jumlah data meningkat tajam atau frekuensi permintaan meningkat. <br><br>  Di bawah ini adalah grafik yang menunjukkan bagaimana jumlah API yang diproses oleh backend per detik berubah dengan pertumbuhan data dalam sistem <br><br><img src="https://habrastorage.org/webt/iz/ak/pk/izakpktadqsa2nm6xfr18bim07o.jpeg"><br><br>  Misalkan layanan yang kami uji adalah dalam keadaan khas dari awal jadwal ini.  Dalam hal ini, bahkan dengan pertumbuhan sistem yang kecil, kecepatan API ini akan menurun tajam. <br><br>  Untuk mengecualikan situasi seperti itu, kami meningkatkan jumlah data beberapa kali, menambah jumlah utas paralel untuk memahami bagaimana layanan akan berperilaku jika beban meningkat secara dramatis. <br><br>  Namun ada satu lagi nuansa.  Jika pekerjaan layanan "akrab" berubah sesuai dengan pertumbuhan jumlah data, perkembangannya, munculnya fungsi baru, dengan layanan baru situasinya bahkan lebih rumit.  Ketika suatu layanan baru secara konseptual muncul dalam suatu produk, ia perlu dipertimbangkan dari berbagai sudut pandang.  Untuk situasi ini, Anda perlu menyiapkan set data khusus, melakukan pengujian beban, menyarankan kemungkinan kasus penggunaan. <br><br><h3>  Fitur pengujian kinerja di Acronis </h3><br>  Biasanya, proses pengujian kami berlangsung dalam "pola spiral."  Salah satu fase pengujian melibatkan penggunaan API untuk meningkatkan jumlah entitas (ukuran), dan yang kedua melakukan operasi baru pada set data yang ada (penggunaan).  Semua tes dijalankan dalam jumlah utas berbeda.  Misalnya, kami memiliki layanan Hewan, dan memiliki API berikut: <br><br><pre><code class="plaintext hljs">POST /animals PUT /animals/&lt;id&gt; GET /animals?filter=criteria</code> </pre> <br>  1 dan 2 adalah API yang disebut dalam tes ukuran - mereka meningkatkan jumlah entitas baru dalam sistem. <br>  3 adalah API yang disebut dalam fase penggunaan.  API ini memiliki banyak opsi penyaringan.  Dengan demikian, akan ada lebih dari satu tes <br><br>  Dengan demikian, dengan menjalankan tes ukuran dan penggunaan berulang, kami mendapatkan gambaran tentang perubahan kinerja sistem dengan pertumbuhannya <br><br><img src="https://habrastorage.org/webt/kt/gu/mr/ktgumrhgb9rylzdzychmfia98a8.jpeg"><br><img src="https://habrastorage.org/webt/qq/c3/1a/qqc31asxcnfdj2zxiomspfjepdq.jpeg"><br><img src="https://habrastorage.org/webt/id/nv/ud/idnvudwxbh7k2vbi6sttga0eprw.jpeg"><br><img src="https://habrastorage.org/webt/07/eq/ba/07eqbad2yzyut-rupjjiebmdab8.jpeg"><br><br><h3>  Kerangka kerja yang dibutuhkan ... </h3><br>  Untuk melakukan pengujian skala besar terhadap sejumlah besar layanan baru dan yang diperbarui, kami membutuhkan kerangka kerja fleksibel yang memungkinkan kami menjalankan skrip yang berbeda.  Dan hal utama adalah untuk benar-benar menguji API, dan tidak hanya membuat beban pada layanan dengan operasi berulang. <br><br>  Pengujian kinerja dapat dilakukan baik pada beban sintetis maupun menggunakan pola beban yang dicatat dari produksi.  Kedua pendekatan memiliki pro dan kontra mereka.  Metode dengan beban nyata dapat lebih dikarakteristikkan sebagai pengujian tegangan - kami mendapatkan gambaran nyata tentang kinerja sistem dalam beban seperti itu, tetapi kami tidak memiliki kemampuan untuk dengan mudah mengidentifikasi area masalah, mengukur throughput komponen secara individual, kami tidak mendapatkan angka pasti yang memuat komponen individual yang dapat bertahan.  Dalam hal pendekatan sintetis, kami mendapatkan angka pastinya, kami memiliki fleksibilitas besar, dan kami dapat dengan mudah memperbaiki area yang bermasalah, dan dengan menjalankan beberapa skrip uji secara paralel, kami dapat mereproduksi beban stres.  Kerugian utama dari pendekatan kedua adalah biaya tenaga kerja yang tinggi untuk menulis skrip tes, serta meningkatnya risiko kehilangan beberapa skrip penting.  Karena itu, kami memutuskan untuk menempuh jalan yang lebih sulit. <br><br>  Jadi, pilihan kerangka kerja ditentukan oleh tugas.  Dan tugas kita adalah: <br><br><ul><li>  Menemukan kemacetan API </li><li>  Periksa ketahanan terhadap beban tinggi </li><li>  Untuk mengevaluasi efektivitas layanan dengan pertumbuhan volume data </li><li>  Identifikasi kesalahan kumulatif yang terjadi seiring waktu </li></ul><br>  Ada begitu banyak kerangka kerja Kinerja di pasar yang dapat memecat sejumlah besar permintaan yang identik.  Banyak dari mereka tidak mengizinkan perubahan apa pun secara internal (misalnya, Apache Benchmark) atau dengan kemampuan terbatas untuk menggambarkan skrip (misalnya, JMeter). <br><br>  Kami biasanya menggunakan skrip yang lebih kompleks dalam pengujian.  Seringkali, panggilan API harus dilakukan secara berurutan - satu demi satu, atau untuk mengubah parameter permintaan sesuai dengan beberapa jenis logika.  Contoh paling sederhana ketika kami ingin menguji API REST dari formulir <br><br><pre> <code class="plaintext hljs">PUT /endpoint/resource/&lt;id&gt;</code> </pre> <br>  Dalam hal ini, Anda perlu mengetahui terlebih dahulu &lt;id&gt; sumber daya yang ingin kami ubah untuk mengukur waktu eksekusi kueri net. <br><br>  Oleh karena itu, kita memerlukan kemampuan untuk membuat skrip untuk menjalankan kueri pengujian yang kompleks. <br><br><h3>  Lebih cepat </h3><br>  Karena produk Acronis dirancang untuk memuat tinggi, kami menguji API dalam puluhan ribu permintaan per detik.  Ternyata tidak semua kerangka kerja dapat memungkinkan ini dilakukan.  Sebagai contoh, Python tidak selalu dan tidak selalu mungkin digunakan untuk pengujian, karena karena kekhasan bahasa kemampuan untuk membuat beban multi-threaded besar terbatas <br><br>  Masalah lain adalah penggunaan sumber daya.  Sebagai contoh, kami pertama kali melihat kerangka kerja Locust, yang dapat dijalankan dari beberapa perangkat keras sekaligus dan mendapatkan kinerja yang baik.  Tetapi pada saat yang sama, banyak sumber daya dihabiskan untuk pekerjaan sistem pengujian, dan ternyata mahal untuk dioperasikan. <br><br>  Sebagai hasilnya, kami memilih kerangka kerja K6, yang memungkinkan kami untuk menggambarkan skrip dalam Javascript lengkap, dan memberikan kinerja di atas rata-rata.  Kerangka kerja ini ditulis dalam Go, dan dengan cepat mendapatkan popularitas.  Misalnya, di Github, proyek ini telah menerima hampir 5,5 ribu bintang!  K6 secara aktif berkembang, dan masyarakat telah mengusulkan hampir 3 ribu komitmen, dan proyek ini memiliki 50 kontributor yang telah membuat 36 cabang kode.  Tentu saja, K6 masih jauh dari ideal, tetapi secara bertahap kerangka kerja menjadi lebih baik, dan Anda dapat membaca tentang perbandingannya dengan Jmeter di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Kesulitan dan solusinya </h3><br>  Mengingat "kemudaan" K6, bahkan setelah pilihan kerangka yang seimbang, kami menghadapi sejumlah masalah.  Sebagai contoh, sebelum menguji API seperti / titik akhir /, Anda harus terlebih dahulu menemukan titik akhir ini entah bagaimana.  Kami tidak dapat menggunakan nilai yang sama, karena karena caching hasilnya akan salah. <br><br>  Anda bisa mendapatkan data yang Anda butuhkan dengan berbagai cara: <br><br><ul><li>  Anda dapat meminta mereka melalui API </li><li>  Anda dapat menggunakan akses langsung ke database </li></ul><br>  Metode kedua bekerja lebih cepat, dan ketika menggunakan DB relasional sering ternyata jauh lebih nyaman, karena memungkinkan Anda untuk menghemat waktu yang signifikan selama tes yang panjang.  Satu-satunya "tetapi" adalah bahwa Anda dapat menggunakannya hanya jika kode layanan dan tes ditulis oleh orang yang sama.  Karena untuk bekerja melalui database, tes harus selalu mutakhir.  Namun, dalam kasus K6, kerangka kerja tidak memiliki mekanisme akses ke database.  Karena itu, saya harus menulis modul yang sesuai sendiri. <br><br>  Masalah lain muncul ketika menguji API non-idempoten.  Dalam hal ini, penting bahwa mereka dipanggil hanya sekali dengan parameter yang sama (misalnya, DELETE API).  Dalam pengujian kami, kami menyiapkan data pengujian terlebih dahulu, pada tahap pengaturan, saat sistem disiapkan dan disiapkan.  Dan selama pengujian, pengukuran dilakukan dari panggilan API murni, karena waktu dan sumber daya untuk menyiapkan data tidak lagi diperlukan.  Namun, ini menimbulkan masalah pendistribusian data yang telah disiapkan sebelumnya melalui aliran utama yang tidak disinkronkan.  Masalah ini berhasil diselesaikan dengan menulis antrian data internal.  Tapi ini adalah topik besar, yang akan kita bahas di posting selanjutnya. <br><br><h3>  Kerangka Siap </h3><br>  Singkatnya, saya ingin mencatat bahwa tidak mudah untuk menemukan kerangka kerja yang sepenuhnya siap pakai, dan saya masih harus menyelesaikan beberapa hal dengan tangan saya.  Namun demikian, hari ini kami memiliki alat yang cocok untuk kami, yang, dengan mempertimbangkan peningkatan, memungkinkan kami untuk melakukan tes yang kompleks, membuat simulasi beban tinggi untuk menjamin fungsionalitas API dan GUI dalam kondisi yang berbeda. <br><br>  Dalam posting berikutnya, saya akan berbicara tentang bagaimana kami memecahkan masalah pengujian layanan yang mendukung koneksi simultan dari ratusan ribu koneksi menggunakan sumber daya minimal. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474694/">https://habr.com/ru/post/id474694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474680/index.html">AI dan 2048. Bagian 2: Minimax + alpha beta clipping</a></li>
<li><a href="../id474686/index.html">Kisah fantastis "Keselamatan" (10 mnt)</a></li>
<li><a href="../id474688/index.html">Kereta retro dengan lokomotif uap</a></li>
<li><a href="../id474690/index.html">Membuat konsol dengan tinggi variabel untuk pekerjaan yang lebih nyaman di komputer</a></li>
<li><a href="../id474692/index.html">Ulasan Skaffold untuk Pengembangan Kubernetes</a></li>
<li><a href="../id474696/index.html">Tiket ke industri minyak atau Rosneft menyerukan Tantangan Seismik</a></li>
<li><a href="../id474698/index.html">Menggunakan modal windows di antarmuka pengguna</a></li>
<li><a href="../id474700/index.html">Cloud Smart Home. Bagian 2: Layanan Cloud</a></li>
<li><a href="../id474702/index.html">Pemrograman fungsional dari sudut pandang EcmaScript. Fungsi murni, lambda, kekebalan</a></li>
<li><a href="../id474704/index.html">Wawancara Playboy: Steve Jobs, Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>