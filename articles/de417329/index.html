<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚳 ⚙️ 👨🏻‍🚀 Sie und Brad Pitt sind 99% 👃🏾 😀 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir in der Analytics-Abteilung des Online-Kinos Okko lieben es, die Berechnung der Filmgebühren von Alexander Nevsky so weit wie möglich zu automatisi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sie und Brad Pitt sind 99%</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/417329/"><p><img src="https://habrastorage.org/webt/bg/8z/-p/bg8z-pmvxneor2kulnu9tmg3qoy.jpeg" alt="Morgen im urlaub"></p><br><p>  Wir in der Analytics-Abteilung des Online-Kinos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Okko</a> lieben es, die Berechnung der Filmgebühren von Alexander Nevsky so weit wie möglich zu automatisieren und in der Freizeit neue Dinge zu lernen und coole Dinge zu implementieren, die sich aus irgendeinem Grund normalerweise in Bots für Telegram umsetzen.  Zum Beispiel haben wir vor dem Start der FIFA Fussball-Weltmeisterschaft 2018 einen Bot für den Arbeitschat ausgerollt, der Wetten auf die Verteilung der endgültigen Plätze sammelte, und nach dem Finale haben wir die Ergebnisse anhand einer vorab erfundenen Metrik berechnet und die Gewinner ermittelt.  Kroatien hat nicht vier unter die ersten vier gesetzt. </p><br><p>  In der letzten Freizeit, in der wir die russischen TOP-10-Komödien zusammengestellt haben, haben wir uns der Erstellung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bots gewidmet</a> , der eine Berühmtheit findet, nach der der Benutzer am meisten aussieht.  Im Arbeitschat schätzten alle die Idee so sehr, dass wir beschlossen, den Bot öffentlich zugänglich zu machen.  In diesem Artikel erinnern wir uns kurz an die Theorie, sprechen über die Erstellung unseres Bots und wie man es selbst macht. </p><a name="habracut"></a><br><h1 id="nemnogo-teorii-v-osnovnom-v-kartinkah">  Ein bisschen Theorie (meistens in Bildern) </h1><br><p> In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem meiner vorherigen Artikel habe</a> ich ausführlich darüber gesprochen, wie Gesichtserkennungssysteme angeordnet sind.  Ein interessierter Leser kann dem Link folgen, und ich werde im Folgenden nur die Hauptpunkte skizzieren. </p><br><p>  Sie haben also ein Foto, auf dem vielleicht sogar ein Gesicht gezeigt wird, und Sie möchten verstehen, wer es ist.  Dazu müssen Sie 4 einfache Schritte ausführen: </p><br><ol><li>  Wählen Sie das Rechteck aus, das an das Gesicht grenzt. </li><li>  Markieren Sie wichtige Punkte des Gesichts. </li><li>  Richten Sie Ihr Gesicht aus und beschneiden Sie es. </li><li>  Konvertieren Sie ein Gesichtsbild in eine maschinell interpretierte Darstellung. </li><li>  Vergleichen Sie diese Ansicht mit anderen, die Sie zur Verfügung haben. </li></ol><br><h3 id="vydelenie-lica">  Gesichtsauswahl </h3><br><p>  Obwohl Faltungs-Neuronale Netze in letzter Zeit gelernt haben, Gesichter in Bildern nicht schlechter als klassische Methoden zu finden, sind sie dem klassischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HOG</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezug</a> auf Geschwindigkeit und Benutzerfreundlichkeit immer noch unterlegen. </p><br><p>  HOG - Histogramme orientierter Gradienten.  Dieser Typ ordnet jedes Pixel des Quellbildes seinem Gradienten zu - einem Vektor, in dessen Richtung sich die Helligkeit der Pixel am meisten ändert.  Der Vorteil dieses Ansatzes besteht darin, dass die absoluten Werte der Helligkeit der Pixel nicht berücksichtigt werden, sondern nur deren Verhältnis ausreicht.  Daher wird ein normales, abgedunkeltes, schlecht beleuchtetes und verrauschtes Gesicht in ungefähr demselben Verlaufshistogramm angezeigt. </p><br><p><img src="https://habrastorage.org/webt/ke/_h/b_/ke_hb_cyd3odkvkwmqb0soancka.png" alt="Histogramm der gerichteten Gesichtsverläufe"></p><br><p> Es ist nicht notwendig, den Gradienten für jedes Pixel zu berechnen, es reicht aus, den durchschnittlichen Gradienten für jedes kleine Quadrat <code>n</code> mal <code>n</code> zu berechnen.  Mithilfe des empfangenen Vektorfelds können Sie dann durch einen Detektor mit einem Fenster gehen und für jedes Fenster bestimmen, wie wahrscheinlich das Gesicht darin ist.  Der Detektor kann SVM, eine zufällige Gesamtstruktur oder etwas anderes sein. </p><br><p><img src="https://habrastorage.org/webt/mz/hk/2y/mzhk2ycaurneywpy32a0linnm3o.png" alt="Gesichtserkennung"></p><br><h3 id="vydelenie-klyuchevyh-tochek">  Markieren Sie wichtige Punkte </h3><br><p><img src="https://habrastorage.org/webt/wd/bi/dc/wdbidcix45fpf74iglc7f0f1rpg.png" alt="Wichtige punkte des gesichts gesicht"></p><br><p>  Schlüsselpunkte sind Punkte, die helfen, eine Person im Raum zu identifizieren.  Schwache und unsichere Wissenschaftler benötigen in der Regel 68 Schlüsselpunkte und in besonders vernachlässigten Fällen sogar noch mehr.  Normale und selbstbewusste Jungen, die 300.000 pro Sekunde verdienten, hatten immer genug von fünf: die inneren und äußeren Augen- und Nasenwinkel. </p><br><p><img src="https://habrastorage.org/webt/6t/tb/-8/6ttb-8bq0ugffanbs0qcrihy2a4.jpeg" alt="Altes mem"></p><br><p>  Solche Punkte können beispielsweise durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaskade von Regressoren</a> extrahiert werden. </p><br><h3 id="vyravnivanie-lica">  Gesichtsausrichtung </h3><br><p>  Geklebte Anwendungen in der Kindheit?  Hier ist alles genau gleich: Sie erstellen eine affine Transformation, die drei beliebige Punkte in ihre Standardpositionen übersetzt.  Die Nase kann so gelassen werden, wie sie ist, aber damit die Augen ihre Zentren zählen können - das sind die drei Punkte, die bereit sind. </p><br><p><img src="https://habrastorage.org/webt/ms/3q/s7/ms3qs7hagupsaooas-eqrjjmqpy.png" alt="Gesicht gesicht drehen"></p><br><h3 id="preobrazovanie-izobrazheniya-lica-v-vektor">  Konvertieren Sie Gesichtsbilder in Vektoren </h3><br><p><img src="https://habrastorage.org/webt/ab/8w/jo/ab8wjody73ybfs_opnftpipbcz0.png" alt="Weniger altes mem"></p><br><p>  Drei Jahre sind seit der Veröffentlichung des Artikels über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FaceNet vergangen</a> . In dieser Zeit erschienen viele interessante Trainingsschemata und Verlustfunktionen, aber sie ist es, die unter den verfügbaren OpenSource-Lösungen dominiert.  Anscheinend ist das Ganze eine Kombination aus leichtem Verständnis, Implementierung und anständigen Ergebnissen.  Vielen Dank zumindest für die Tatsache, dass die Architektur in den letzten drei Jahren auf ResNet geändert wurde. </p><br><p><img src="https://habrastorage.org/webt/af/pt/cx/afptcx5ixcu2r0_mjkckckpt2zo.jpeg" alt="Neues mem"></p><br><p>  FaceNet lernt aus dreifachen Beispielen: (Anker, positiv, negativ).  Anker- und Positivbeispiele gehören einer Person, während Negativ als Gesicht einer anderen Person gewählt wird, was aus irgendeinem Grund dem Netzwerk zu nahe an der ersten liegt.  Die Verlustfunktion ist so konzipiert, dass dieses Missverständnis korrigiert, die notwendigen Beispiele zusammengeführt und das Unnötige daraus entfernt werden. </p><br><p><img src="https://habrastorage.org/webt/tp/yf/sw/tpyfswhgnyco4w_0ap3zy8i5zhs.png" alt="Guccinet"></p><br><p><img src="https://habrastorage.org/webt/gj/fi/zq/gjfizqzcwjybnypbv-ugovr5hl0.png" alt="Gesichtsgesichter und Dmitry Malikov"></p><br><p>  Die Ausgabe der letzten Schicht des Netzwerks wird als Einbettung bezeichnet - eine repräsentative Darstellung einer Person in einem bestimmten Raum kleiner Dimension (normalerweise 128-dimensional). </p><br><h3 id="sravnenie-lic">  Gesichtsvergleich </h3><br><p>  Das Schöne an gut ausgebildeten Einbettungen ist, dass die Gesichter einer Person in einem kleinen Raumviertel angezeigt werden, das von den Einbettungen der Gesichter anderer Personen entfernt ist.  Für diesen Raum können Sie also ein Ähnlichkeitsmaß eingeben, den Kehrwert der Entfernung: Euklidisch oder Kosinus, je nachdem, über welche Entfernung das Netzwerk trainiert wurde. </p><br><p><img src="https://habrastorage.org/webt/pn/u8/ba/pnu8barwdzvdryma24yezil7kvo.jpeg" alt="Ein anderes künstliches Beispiel für Einbettungen"></p><br><p>  Daher müssen wir im Voraus Einbettungen für alle Personen erstellen, unter denen die Suche durchgeführt wird, und dann für jede Anforderung den nächsten Vektor unter ihnen finden.  Oder lösen Sie auf andere Weise das Problem, <code>k</code> nächste Nachbarn zu finden, wobei <code>k</code> gleich eins sein kann oder nicht, wenn wir eine fortgeschrittenere Geschäftslogik verwenden möchten.  Die Person, die den Ergebnisvektor besitzt, ist der anfordernden Person am ähnlichsten. </p><br><p><img src="https://habrastorage.org/webt/6f/uz/nx/6fuznxdig3uiw1mjuv1eezx5h3u.jpeg" alt="Unterschiedliche von Angesicht zu Angesicht nicht von Angesicht zu Angesicht"></p><br><h3 id="kakuyu-biblioteku-ispolzovat">  Welche Bibliothek soll ich benutzen? </h3><br><p>  Die Auswahl an offenen Bibliotheken, die verschiedene Teile der Pipeline implementieren, ist großartig.  <code>dlib</code> und <code>OpenCV</code> können Gesichter und wichtige Punkte finden, und vorab trainierte Versionen von Netzwerken können für jedes große neuronale Netzwerk-Framework gefunden werden.  Es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenFace-</a> Projekt, in dem Sie die Architektur für Ihre Anforderungen an Geschwindigkeit und Qualität auswählen können.  Mit nur einer Bibliothek können Sie jedoch alle 5 Punkte der Gesichtserkennung in Aufrufen von drei Funktionen auf hoher Ebene <code>dlib</code> : <code>dlib</code> .  Gleichzeitig ist es in modernem C ++ geschrieben, verwendet BLAS, hat einen Wrapper für Python, benötigt keine GPU und arbeitet recht schnell auf einer CPU.  Unsere Wahl fiel auf sie. </p><br><h1 id="delaem-sobstvennogo-bota">  Mach deinen eigenen Bot </h1><br><p>  Dieser Abschnitt wurde bereits in buchstäblich jeder Anleitung zum Erstellen von Bots beschrieben, aber sobald wir dasselbe schreiben, müssen wir es wiederholen.  Wir schreiben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@BotFather</a> und bitten ihn um ein Token für unseren neuen Bot. </p><br><p><img src="https://habrastorage.org/webt/um/qe/ew/umqeewdk64wtealh1ldudqsv0m8.png" alt="Verwischen Sie den Token xs warum"></p><br><p>  Das Token sieht <code>643075690:AAFC8ola8WRdhGbJtzjmkOhne1FGfu1BFg</code> so aus: <code>643075690:AAFC8ola8WRdhGbJtzjmkOhne1FGfu1BFg</code> .  Bei jeder Anforderung an die Telegramm-Bot-API ist eine Autorisierung erforderlich. </p><br><p>  Ich hoffe, dass derzeit niemand Zweifel an der Auswahl einer Programmiersprache hat.  Natürlich muss man in Haskell schreiben.  Beginnen wir mit dem Hauptmodul. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Process main :: IO () main = do (<span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">handle</span></span>) &lt;- createProcess (<span class="hljs-title"><span class="hljs-title">shell</span></span> "<span class="hljs-title"><span class="hljs-title">python</span></span> <span class="hljs-title"><span class="hljs-title">bot</span></span>.<span class="hljs-title"><span class="hljs-title">py</span></span>") _ &lt;- waitForProcess handle putStrLn "Done!"</code> </pre> <br><p>  Wie Sie dem Code entnehmen können, werden wir in Zukunft ein spezielles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DSL verwenden</a> , um Telegramm-Bots zu schreiben.  Der Code in diesem DSL wird in separaten Dateien geschrieben.  Installieren Sie die Domain-Sprache und alles Notwendige. </p><br><pre> <code class="bash hljs">python -m venv .env <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> .env/bin/activate pip install python-telegram-bot</code> </pre> <br><p>  <code>python-telegram-bot</code> ist derzeit das bequemste Framework zum Erstellen von Bots.  Es ist leicht zu erlernen, flexibel, skalierbar und unterstützt Multithreading.  Leider gibt es im Moment kein einziges normales asynchrones Framework und es müssen alte Threads anstelle der göttlichen Coroutinen verwendet werden. </p><br><p><img src="https://habrastorage.org/webt/t2/8b/qv/t28bqvhxxznqmzsobr4hjmuxlta.jpeg" alt="Asyncio ist mein Regierungs gott"></p><br><p>  Das Starten eines Bots mit <code>python-telegram-bot</code> ist einfach.  Fügen Sie den folgenden Code zu <code>bot.py</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def echo(bot, update): bot.send_message(chat_id=update.message.chat_id, text=update.message.text) updater = Updater(token=TOKEN) dispatcher = updater.dispatcher echo_handler = MessageHandler(Filters.text, echo) dispatcher.add_handler(echo_handler)</span></span></code> </pre> <br><p>  Führen Sie den Bot aus.  Zu Debugging-Zwecken kann dies mit dem <code>python bot.py</code> ohne dass Haskell-Code ausgeführt wird. </p><br><p>  Solch ein einfacher Bot ist in der Lage, ein Minimum an Konversation aufrechtzuerhalten, und kann daher leicht so arrangiert werden, dass er als Front-End-Entwickler arbeitet. </p><br><p><img src="https://habrastorage.org/webt/xs/pk/sm/xspksm1d8ehnslmqjsj33dzyekm.png" alt="Typischer Dialog mit Front-End-Entwickler"></p><br><p>  Das Frontend der Entwickler ist jedoch bereits zu umfangreich. Daher werden wir es so schnell wie möglich beenden und die Hauptfunktionalität implementieren.  Der Einfachheit halber antwortet unser Bot nur auf Nachrichten mit Fotos und ignoriert alle anderen.  Ändern Sie den Code wie folgt. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def handle_photo(bot, update): bot.send_message(chat_id=update.message.chat_id, text='nice') updater = Updater(token=TOKEN) dispatcher = updater.dispatcher photo_handler = MessageHandler(Filters.photo, handle_photo) dispatcher.add_handler(photo_handler) updater.start_polling() updater.idle()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/-8/1k/hq/-81khq5z9redcz29_ut7sunfrpg.png" alt="Schön kein Frontend-Entwickler"></p><br><p>  Wenn das Bild in den Telegrammserver eingeht, wird es automatisch auf mehrere vorgegebene Größen angepasst.  Der Bot kann seinerseits ein Bild beliebiger Größe von den in der <code>message.photo</code> Liste enthaltenen <code>message.photo</code> die in aufsteigender Reihenfolge sortiert sind.  Die einfachste Option: Nehmen Sie das größte Bild auf.  In einer Lebensmittelumgebung müssen Sie natürlich über die Netzwerklast und die Ladezeit nachdenken und ein Bild mit der minimal geeigneten Größe auswählen.  Fügen Sie den Bild-Download-Code oben in der Funktion <code>handle_photo</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io</code> </pre> <br><pre> <code class="python hljs">message = update.message photo = message.photo[~<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> io.BytesIO() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fd: file_id = bot.get_file(photo.file_id) file_id.download(out=fd) fd.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Das Bild wurde heruntergeladen und befindet sich im Speicher.  Um es zu interpretieren und in Form einer Matrix mit <code>numpy</code> , verwenden wir die Bibliotheken <code>Pillow</code> und <code>numpy</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre> <br><p>  Der folgende Code muss dem <code>with</code> Block hinzugefügt werden. </p><br><pre> <code class="python hljs">image = Image.open(fd) image.load() image = np.asarray(image)</code> </pre> <br><p>  Die Zeit ist gekommen, dlib.  Erstellen Sie außerhalb der Funktion einen Gesichtsdetektor. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib</code> </pre> <br><pre> <code class="python hljs">face_detector = dlib.get_frontal_face_detector()</code> </pre> <br><p>  Und innerhalb der Funktion verwenden wir es. </p><br><pre> <code class="python hljs">face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Der zweite Parameter der Funktion bezeichnet die Vergrößerung, die angewendet werden muss, bevor versucht wird, Gesichter zu erkennen.  Je größer es ist, desto kleiner und komplexer kann der Detektor erkennen, aber desto länger arbeitet er.  <code>face_detects</code> - Eine Liste von Gesichtern, sortiert in absteigender Reihenfolge des Vertrauens des Detektors, dass sich das Gesicht davor befindet.  In einer realen Anwendung möchten Sie höchstwahrscheinlich eine Logik für die Auswahl der Hauptperson anwenden, und in der Fallstudie beschränken wir uns auf die Auswahl der ersten Person. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> face_detects: bot.send_message(chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">'no faces'</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  Wir fahren mit der nächsten Stufe fort - der Suche nach Schlüsselpunkten.  Laden Sie das <a href="">trainierte Modell</a> herunter und bewegen Sie seine Last außerhalb der Funktion. </p><br><pre> <code class="python hljs">shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'path/to/shape_predictor_5_face_landmarks.dat'</span></span>)</code> </pre> <br><p>  Finden Sie die wichtigsten Punkte. </p><br><pre> <code class="python hljs">landmarks = shape_predictor(image, face)</code> </pre> <br><p>  Das einzige, was noch übrig ist, ist klein: Um das Gesicht zu begradigen, fahren Sie es durch ResNet und erhalten Sie eine 128-dimensionale Einbettung.  Glücklicherweise können Sie mit dlib all dies mit einem Anruf erledigen.  Sie müssen nur das <a href="">vorgefertigte Modell</a> herunterladen. </p><br><pre> <code class="python hljs">face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'path/to/dlib_face_recognition_resnet_model_v1.dat'</span></span>)</code> </pre> <br><pre> <code class="python hljs">embedding = face_recognition_model.compute_face_descriptor(image, landmarks) embedding = np.asarray(embedding)</code> </pre> <br><p>  Schau dir nur an, in was für einer wundervollen Zeit wir leben.  Die gesamte Komplexität von Faltungs-Neuronalen Netzen, die Unterstützungsvektormethode und affine Transformationen, die auf die Gesichtserkennung angewendet werden, sind in drei Bibliotheksaufrufen zusammengefasst. </p><br><p>  Da wir noch nicht wissen, wie man etwas Sinnvolles macht, geben wir dem Benutzer den Durchschnittswert seiner Einbettung multipliziert mit tausend zurück. </p><br><pre> <code class="python hljs">bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'yours embedding mean: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{embedding.mean() * </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1e3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">:</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">.2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">f}</span></span></span><span class="hljs-string">'</span></span> )</code> </pre> <br><p><img src="https://habrastorage.org/webt/ud/av/o6/udavo6i5srwrl93jbopenn84tae.png" alt="Ich weiß nicht war ich tue"></p><br><p>  Damit unser Bot bestimmen kann, wie die Prominenten der Benutzer sind, müssen wir jetzt mindestens ein Foto von jedem Prominenten finden, eine Einbettung darauf erstellen und es irgendwo speichern.  Wir werden unserem Trainingsbot nur 10 Prominente hinzufügen, deren Fotos von Hand finden und in das <code>photos</code> .  So sollte es aussehen: </p><br><p><img src="https://habrastorage.org/webt/yz/rd/1o/yzrd1ockvqezvybwzo-yulsivqq.png" alt="Ich hatte nicht genug Geld für ein MacBook."></p><br><p>  Wenn Sie eine Million Prominente in der Datenbank haben möchten, sieht alles genau gleich aus, nur gibt es mehr Dateien und es ist unwahrscheinlich, dass Sie sie mit Ihren Händen suchen können.  Erstellen <code>build_embeddings.py</code> Dienstprogramm <code>build_embeddings.py</code> mit den bereits bekannten <code>dlib</code> Aufrufen und speichern die Einbettungen von Prominenten zusammen mit ihren Namen im Binärformat. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image face_detector = dlib.get_frontal_face_detector() shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'assets/shape_predictor_5_face_landmarks.dat'</span></span>) face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'assets/dlib_face_recognition_resnet_model_v1.dat'</span></span>) fs = os.listdir(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>) es = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs: print(f) image = np.asarray(Image.open(os.path.join(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>, f))) face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>] landmarks = shape_predictor(image, face) embedding = face_recognition_model.compute_face_descriptor(image, landmarks, num_jitters=<span class="hljs-number"><span class="hljs-number">10</span></span>) embedding = np.asarray(embedding) name, _ = os.path.splitext(f) es.append((name, embedding)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: pickle.dump(es, f)</code> </pre> <br><p>  Fügen Sie unserem Bot-Code das Einbetten hinzu. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: star_embeddings = pickle.load(f)</code> </pre> <br><p>  Und durch umfassende Suche werden wir herausfinden, wie unser Benutzer alle gleich ist. </p><br><pre> <code class="python hljs">ds = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> star_embeddings: distance = np.linalg.norm(embedding - emb) ds.append((name, distance)) best_match, best_distance = min(ds, key=itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>)) bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'your look exactly like *</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{best_match}</span></span></span><span class="hljs-string">*'</span></span>, parse_mode=<span class="hljs-string"><span class="hljs-string">'Markdown'</span></span> )</code> </pre> <br><p>  Bitte beachten Sie, dass wir den euklidischen Abstand als Abstand verwenden, weil  Das Netzwerk in dlib wurde genau mit dessen Hilfe trainiert. </p><br><p><img src="https://habrastorage.org/webt/yd/fl/wi/ydflwigundswx6_qbctjir_itge.png" alt="Ich war von dem Artikel gehört"></p><br><p>  Das ist alles, Glückwunsch!  Wir haben einen einfachen Bot erstellt, der bestimmen kann, wie berühmt der Benutzer ist.  Es bleibt noch mehr Fotos zu finden, Branding, Skalierbarkeit, eine Prise Protokollierung hinzuzufügen und alles kann in der Produktion freigegeben werden.  All diese Themen sind zu umfangreich, um mit umfangreichen Codelisten ausführlich besprochen zu werden. Daher werde ich im nächsten Abschnitt nur die wichtigsten Punkte im Frage-Antwort-Format skizzieren. </p><br><p>  Der vollständige Trainings-Bot-Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar. </p><br><h1 id="rasskazyvaem-pro-nashego-bota">  Wir reden über unseren Bot </h1><br><h3 id="skolko-u-vas-v-baze-znamenitostey-gde-vy-ih-nashli">  Wie viele Prominente haben Sie in Ihrer Datenbank?  Wo hast du sie gefunden? </h3><br><p>  Die logischste Entscheidung bei der Erstellung des Bots schien darin zu bestehen, Promi-Daten aus unserer internen Inhaltsbasis zu übernehmen.  Sie speichert im Format der Grafik Filme und alle Entitäten, die mit Filmen verbunden sind, einschließlich Schauspieler und Regisseure.  Für jede Person kennen wir ihren Namen, ihr Login und ihr Passwort aus iCloud, verwandten Filmen und Alias, mit denen Links zur Site generiert werden können.  Nach dem Bereinigen und Extrahieren nur der erforderlichen Informationen bleibt die <code>json</code> Datei wie folgt: </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"tilda-swinton"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"michael-shannon"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">22</span></span> }, ... ]</code> </pre> <br><p>  Es gab <strong>22.000</strong> solcher Einträge im Katalog.  Übrigens kein Katalog, sondern ein Katalog. </p><br><h3 id="gde-nayti-fotografii-dlya-vseh-etih-lyudey">  Wo finde ich Fotos für all diese Leute? </h3><br><p><img src="https://habrastorage.org/webt/_n/5i/pl/_n5iplsi4yqnrm2lpvzyjwhjigm.jpeg" alt="In bestimmten Zeiten Zeiten leben wir"></p><br><p>  Weißt du, <em>hier und da</em> .  Es gibt zum Beispiel eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wunderbare Bibliothek</a> , mit der Sie Bilder-Abfrageergebnisse von Google hochladen können.  22.000 Menschen - nicht so viele, mit 56 Streams konnten wir in weniger als einer Stunde Fotos für sie herunterladen. </p><br><p>  Unter den heruntergeladenen Fotos müssen Sie defekte, verrauschte Fotos im falschen Format verwerfen.  Lassen Sie dann nur diejenigen, bei denen es Gesichter gibt und bei denen diese Gesichter bestimmte Bedingungen erfüllen: den Mindestabstand zwischen den Augen, die Neigung des Kopfes.  All dies lässt uns <strong>12.000</strong> Fotos. </p><br><p>  Von den 12.000 Prominenten haben Benutzer derzeit nur 2 gefunden. Das heißt, es gibt ungefähr 8.000 Prominente, die immer noch nicht wie alle anderen sind.  Lass es nicht einfach so!  Öffne Telegramme und finde sie alle. </p><br><h3 id="kak-opredelit-procent-shozhesti-dlya-evklidovoy-distancii">  Wie kann der Prozentsatz der Ähnlichkeit für die euklidische Distanz bestimmt werden? </h3><br><p>  Gute Frage!  In der Tat ist der euklidische Abstand im Gegensatz zum Kosinus oben nicht begrenzt.  Daher stellt sich die vernünftige Frage, wie Sie dem Benutzer etwas Bedeutenderes zeigen können als "Herzlichen Glückwunsch, der Abstand zwischen Ihrer Einbettung und der Einbettung von Angelina Jolie beträgt 0,27635462738".  Eines unserer Teammitglieder schlug die folgende einfache und geniale Lösung vor.  Wenn Sie die Verteilung der Abstände zwischen den Einbettungen erstellen, ist dies normal.  Für ihn können Sie also den Durchschnitt und die Standardabweichung berechnen und dann für jeden Benutzer anhand dieser Parameter berücksichtigen, <em>wie viele Prozent der Menschen ihren Prominenten weniger ähnlich sind als er</em> .  Dies entspricht der Integration einer Wahrscheinlichkeitsdichtefunktion von <code>d</code> bis plus unendlich, wobei <code>d</code> die Entfernung zwischen Benutzer- und Promi-Rallyes ist. </p><br><p><img src="https://habrastorage.org/webt/fh/yc/4r/fhyc4r87otryweg9v-xznackhfq.png" alt="Dies ist nicht seelgeboren"></p><br><p>  Hier ist die genaue Funktion, die wir verwenden: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_transform_dist_to_sim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dist)</span></span></span><span class="hljs-function">:</span></span> p = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> + erf((dist - self._dist_mean) / (self._dist_std * <span class="hljs-number"><span class="hljs-number">1.4142135623730951</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(min(<span class="hljs-number"><span class="hljs-number">1</span></span> - p, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), self._min_similarity)</code> </pre> <br><h3 id="neuzheli-nuzhno-perebirat-spisok-vseh-embedingov-chtoby-nayti-sovpadenie">  Ist es wirklich notwendig, die Liste aller Gewerkschaften zu durchlaufen, um eine Übereinstimmung zu finden? </h3><br><p>  Natürlich nicht, das ist nicht optimal und nimmt viel Zeit in Anspruch.  Der einfachste Weg, Berechnungen zu optimieren, ist die Verwendung von Matrixoperationen.  Anstatt Vektoren voneinander zu subtrahieren, können Sie eine Matrix daraus erstellen, einen Vektor von der Matrix subtrahieren und dann die L2-Norm in Zeilen berechnen. </p><br><pre> <code class="python hljs">scores = np.linalg.norm(emb - embeddings, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_idx = scores.argmax()</code> </pre> <br><p>  Dies führt bereits zu einer enormen Steigerung der Produktivität, aber es stellt sich heraus, dass Sie noch schneller arbeiten können.  Die Suche kann erheblich beschleunigt werden, indem die Genauigkeit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nmslib-</a> Bibliothek ein wenig an Genauigkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verliert</a> .  Es verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HNSW-</a> Methode, um die Suche nach <code>k</code> nächsten Nachbarn zu approximieren.  Für alle verfügbaren Vektoren sollte ein sogenannter Index erstellt werden, in dem dann eine Suche durchgeführt wird.  Sie können den Index für die euklidische Entfernung wie folgt erstellen und speichern: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nmslib index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(embeddings): index.addDataPoint(idx, emb) index_time_params = { <span class="hljs-string"><span class="hljs-string">'indexThreadQty'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'skip_optimized_index'</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'delaunay_type'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'efConstruction'</span></span>: <span class="hljs-number"><span class="hljs-number">2000</span></span> } index.createIndex(index_time_params, print_progress=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) index.saveIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>)</code> </pre> <br><p>  Die Parameter <code>M</code> und <code>efConstruction</code> werden in der <a href="">Dokumentation</a> ausführlich beschrieben und experimentell anhand der erforderlichen Genauigkeit, Indexkonstruktionszeit und <code>efConstruction</code> ausgewählt.  Bevor Sie den Index verwenden können, müssen Sie Folgendes herunterladen: </p><br><pre> <code class="python hljs">index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) index.loadIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>) query_time_params = {<span class="hljs-string"><span class="hljs-string">'efSearch'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>} index.setQueryTimeParams(query_time_params)</code> </pre> <br><p>  Der Parameter <code>efSearch</code> wirkt sich auf die Genauigkeit und Geschwindigkeit von Abfragen aus und <code>efConstruction</code> möglicherweise nicht mit der <code>efConstruction</code> .  Jetzt können Sie Anfragen stellen. </p><br><pre> <code class="python hljs">ids, dists = index.knnQuery(embedding, k=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_dx = ids[<span class="hljs-number"><span class="hljs-number">0</span></span>] best_dist = dists[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  In unserem Fall ist <code>nmslib</code> 20-mal schneller als die vektorisierte lineare Version, und eine Anforderung wird durchschnittlich <code>0.005</code> Sekunden verarbeitet. </p><br><h3 id="kak-sdelat-moego-bota-gotovym-k-prodakshenu">  Wie mache ich meinen Bot produktionsbereit? </h3><br><h5 id="1-asinhronnost">  1. Asynchronität </h5><br><p>  Zunächst müssen Sie die Funktion <code>handle_photo</code> asynchron machen.  Wie ich bereits sagte, bietet <code>python-telegram-bot</code> Multithreading an und implementiert einen praktischen Dekorator. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.dispatcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> run_async @run_async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_photo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bot, update)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br><p>  Jetzt startet das Framework selbst Ihren Handler in einem separaten Thread in seinem Pool.  Die Poolgröße wird beim Erstellen des <code>Updater</code> .  "Aber in Python gibt es kein Multithreading!"  der ungeduldigste von euch hat bereits ausgerufen.  Und das ist nicht ganz richtig.  Aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIL kann</a> regulärer Python-Code nicht parallel ausgeführt werden, aber die GIL wird freigegeben, um auf alle E / A-Vorgänge zu warten, und sie kann auch von Bibliotheken freigegeben werden, die C-Erweiterungen verwenden. </p><br><p>  Analysieren Sie nun unsere Funktion <code>handle_photo</code> : Sie besteht lediglich aus dem Warten auf E / A-Vorgänge (Hochladen eines Fotos, Senden einer Antwort, Lesen eines Fotos von der Festplatte usw.) und Aufrufen von Funktionen aus den Bibliotheken <code>numpy</code> , <code>nmslib</code> und <code>Pillow</code> . </p><br><p>  Ich habe <code>dlib</code> nicht <code>dlib</code> Grund erwähnt.  Die Bibliothek, die den nativen Code aufruft, ist nicht erforderlich, um die GIL <code>dlib</code> und <code>dlib</code> dieses Recht.  Sie braucht dieses Schloss nicht, sie lässt sie einfach nicht los.  Der Autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagt,</a> dass er die entsprechende Pull-Anfrage gerne annehmen wird, aber ich bin zu faul. </p><br><h5 id="2-mnogoprocessnost">  2. Mehrfachverarbeitung </h5><br><p>  Der einfachste Weg, mit <code>dlib</code> besteht darin, das Modell in einer separaten Entität zu kapseln und in einem separaten Prozess auszuführen.  Und besser im Prozesspool. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> model model = Model(config) model.load_state() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.process_image(image) pool = multiprocessing.Pool(<span class="hljs-number"><span class="hljs-number">8</span></span>, initializer=_worker_initialize, initargs=(config,))</code> </pre> <br><pre> <code class="python hljs">result = pool.apply(_worker_do, (image,))</code> </pre> <br><h5 id="3-zhelezo">  3. Eisen </h5><br><p>  Wenn Ihr Bot ständig Fotos von einer Festplatte lesen muss, stellen Sie sicher, dass es sich bei der Festplatte um eine SSD handelt.  Oder mounten Sie sie sogar in RAM.  Ping an Telegrammserver und Kanalqualität ist ebenfalls wichtig. </p><br><h5 id="4-flood-control">  4. Hochwasserschutz </h5><br><p>  Durch Telegramme können Bots nicht mehr als 30 Nachrichten pro Sekunde senden.  Wenn Ihr Bot beliebt ist und viele Leute ihn gleichzeitig verwenden, ist es sehr einfach, ein Verbot für einige Sekunden zu erwischen, was sich für viele Benutzer als Enttäuschung gegenüber den Erwartungen herausstellen wird.  Um dieses Problem zu lösen, bietet uns der <code>python-telegram-bot</code> eine Warteschlange, die nicht mehr als das angegebene Nachrichtenlimit pro Sekunde senden kann, wobei gleiche Intervalle zwischen den Sendungen eingehalten werden. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.messagequeue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageQueue</code> </pre> <br><p>  Um es zu verwenden, müssen Sie Ihren eigenen Bot definieren und ihn beim Erstellen des <code>Updater</code> ersetzen. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.utils.promise <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Promise <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MQBot</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bot)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._message_queue = MessageQueue( all_burst_limit=<span class="hljs-number"><span class="hljs-number">30</span></span>, all_time_limit_ms=<span class="hljs-number"><span class="hljs-number">1000</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._message_queue.stop() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: super().__del__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> is_group = kwargs.get(<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._message_queue(Promise(super().send_message, args, kwargs), is_group)</code> </pre> <br><pre> <code class="python hljs">bot = MQBot(token=TOKEN) updater = Updater(bot=bot)</code> </pre> <br><h5 id="5-web-hooks">  5. Web-Hooks </h5><br><p>  In einer Produktumgebung sollten Web Hooks immer anstelle von Long Polling verwendet werden, um Updates von Telegrammservern zu erhalten.  Worum es geht und wie man es benutzt, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h5 id="6-melochi">  6. Wissenswertes </h5><br><p>              <code>json</code> .    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ultrajson</a> . </p><br><p>          IO-:    ,  ,  .      ,         . </p><br><h5 id="6-analitika"> 6.  </h5><br><p>   ,   .        ,   ,  ,       .        ,        . </p><br><p> , ,      BI-tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Splunk</a>     . </p><br><p><img src="https://habrastorage.org/webt/oh/8e/ve/oh8eve_hczr4pahrzum56fonxxg.jpeg" alt="Werbeplanke (bitte verlängern Sie uns eine Lizenz)"></p><br><p>   ,         .     ,                       . </p><br><p>    ,         .      ,    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@OkkoFaceBot</a> . </p><br><p><del>        </del> ,     . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417329/">https://habr.com/ru/post/de417329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417319/index.html">Systeme im Gehäuse oder Was befindet sich eigentlich unter der Abdeckung des Mikroprozessors</a></li>
<li><a href="../de417321/index.html">Wie suchen wir Lehrer für Online-Kurse unter Entwicklern?</a></li>
<li><a href="../de417323/index.html">Probleme bei der Gewährleistung einer 100% igen Projektzugänglichkeit</a></li>
<li><a href="../de417325/index.html">Tag der offenen Tür in der Netrologie, Thema Data Science</a></li>
<li><a href="../de417327/index.html">Budgetüberwachung der Temperatur im Serverraum (MP707 + Nettop mit Linux + PRTG)</a></li>
<li><a href="../de417331/index.html">Sicherheitswoche 26: Aktualisiertes Spectre, jetzt geschmackvolle Aufnahme</a></li>
<li><a href="../de417333/index.html">Soziale Bewertung</a></li>
<li><a href="../de417337/index.html">Funktionsprinzipien und Anwendungsmerkmale des Atomtauschs</a></li>
<li><a href="../de417339/index.html">3DTouch - Skalen auf dem iPhone: Fertigstellung</a></li>
<li><a href="../de417345/index.html">Bedrohungssuche mit Cisco-Sichtbarkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>