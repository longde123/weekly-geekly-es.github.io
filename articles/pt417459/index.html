<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìö üëãüèº üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ Conhe√ßa o seu JIT: mais perto do carro üë®üèø‚Äçüíº üîè üíø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antes que o c√≥digo escrito por n√≥s seja executado, ele percorre um longo caminho. Andrey Melikhov em seu relat√≥rio sobre o RIT ++ 2018 examinou todas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conhe√ßa o seu JIT: mais perto do carro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417459/"> Antes que o c√≥digo escrito por n√≥s seja executado, ele percorre um longo caminho.  <strong>Andrey Melikhov</strong> em seu relat√≥rio sobre o RIT ++ 2018 examinou todas as etapas desse caminho usando o exemplo do mecanismo V8.  Entre em contato com o gato para descobrir o que nos d√° uma compreens√£o profunda dos princ√≠pios do compilador e como tornar o c√≥digo JavaScript mais produtivo. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Descobriremos se o WASM √© um item importante para melhorar o desempenho do c√≥digo e se as otimiza√ß√µes s√£o sempre justificadas. <br><br>  <strong><em>Spoiler:</em></strong> "A otimiza√ß√£o prematura √© a raiz de todos os males", Donald Knuth. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>Sobre o palestrante:</em></strong> Andrei Melikhov trabalha no Yandex.Money, escreve ativamente no Node.js e menos no navegador, para que o JavaScript do servidor esteja mais pr√≥ximo dele.  Andrew apoia e desenvolve a comunidade devShacht, ent√£o confira o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Medium</a> . <br><a name="habracut"></a><br><h2>  <strong>Motiva√ß√£o e Gloss√°rio</strong> </h2><br>  Hoje vamos falar sobre a compila√ß√£o JIT.  Eu acho que isso √© interessante para voc√™, pois voc√™ est√° lendo isso.  No entanto, vamos esclarecer por que voc√™ precisa saber o que √© o JIT e como a V8 funciona e por que escrever React em um navegador n√£o √© suficiente. <br><br><ul><li>  Permite que voc√™ <strong>escreva um c√≥digo mais eficiente</strong> , porque nosso idioma √© espec√≠fico. </li><li>  <strong>Ele revela quebra-cabe√ßas</strong> porque nas bibliotecas de outras pessoas o c√≥digo √© escrito dessa maneira, e n√£o de outra forma.  √Äs vezes, encontramos bibliotecas antigas e vemos o que est√° escrito l√° de alguma forma estranho, mas se isso √© necess√°rio, n√£o √© necess√°rio - n√£o est√° claro.  Quando voc√™ sabe como isso funciona, voc√™ entende por que isso foi feito. <br></li><li>  <strong>Isto √© apenas interessante</strong> .  Al√©m disso, permite entender o que Axel Rauschmeier, Benedict Moyrer e Dan Abramov se comunicam no Twitter. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  A Wikipedia diz que o JavaScript √© uma linguagem de programa√ß√£o interpretada de alto n√≠vel com digita√ß√£o din√¢mica.  Lidaremos com esses termos. <br><br>  <strong>Compila√ß√£o e interpreta√ß√£o</strong> <br><br>  Compila√ß√£o - quando o programa √© entregue em c√≥digo bin√°rio e √© inicialmente otimizado para o ambiente em que ir√° funcionar. <br><br>  Interpreta√ß√£o - quando entregamos o c√≥digo como est√°. <br><br>  O JavaScript √© entregue como est√° - √© uma linguagem interpretada, conforme escrito na Wikipedia. <br><br>  <strong>Digita√ß√£o din√¢mica e est√°tica</strong> <br><br>  A digita√ß√£o est√°tica e din√¢mica √© frequentemente confundida com a digita√ß√£o fraca e forte.  Por exemplo, C √© um idioma com digita√ß√£o fraca est√°tica.  JavaScript tem digita√ß√£o din√¢mica fraca. <br><br>  Qual √© o melhor?  Se o programa compilar, ele ser√° voltado para o ambiente em que ser√° executado, o que significa que funcionar√° melhor.  A digita√ß√£o est√°tica torna esse c√≥digo mais eficiente.  Em JavaScript, o oposto √© verdadeiro. <br><br>  Mas, ao mesmo tempo, nosso aplicativo est√° se tornando mais complexo: no cliente e no servidor, grandes clusters aparecem no Node.js, que funcionam bem e substituem aplicativos Java. <br><br>  Mas como tudo funciona se inicialmente parece ser um perdedor. <br><br><blockquote>  O JIT reconciliar√° todos!  Ou pelo menos tente. </blockquote><br>  Temos um JIT (compila√ß√£o Just In Time) que acontece em tempo de execu√ß√£o.  Vamos conversar sobre ela. <br><br><h3>  <strong>Js engines</strong> </h3><br><ul><li>  Chakra n√£o amado, localizado no Internet Explorer.  Nem funciona com JavaScript, mas com Jscript - existe esse subconjunto. <br></li><li>  Chakra moderno e ChakraCore que funcionam no Edge; <br></li><li>  SpiderMonkey no FireFox; </li><li>  JavaScriptCore no WebKit.  Tamb√©m √© usado no React Native.  Se voc√™ possui um aplicativo RN para Android, ele tamb√©m √© executado no JavaScriptCore - o mecanismo √© fornecido com o aplicativo. <br></li><li>  V8 √© o meu favorito.  N√£o √© o melhor, apenas trabalho com o Node.js, no qual √© o mecanismo principal, como em todos os navegadores baseados no Chrome. <br></li><li>  Rhino e Nashorn s√£o os mecanismos usados ‚Äã‚Äãem Java.  Com a ajuda deles, voc√™ tamb√©m pode executar o JavaScript l√°. <br></li><li>  JerryScript - para dispositivos incorporados; <br></li><li>  e outros ... </li></ul><br>  Voc√™ pode escrever seu pr√≥prio mecanismo, mas se voc√™ avan√ßar para uma execu√ß√£o efetiva, chegar√° aproximadamente ao mesmo esquema, que mostrarei mais adiante. <br><br>  Hoje vamos falar sobre o V8, e sim, √© nomeado ap√≥s o motor de 8 cilindros. <br><br><h2>  <strong>Subimos sob o cap√¥</strong> </h2><br>  Como o javascript √© executado? <br><br><ul><li>  H√° c√≥digo escrito em JavaScript, que √© fornecido. <br></li><li>  ele est√° analisando; </li><li>  est√° sendo executado; </li><li>  o resultado √© obtido. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  A an√°lise transforma o c√≥digo em uma <strong>√°rvore de sintaxe abstrata</strong> .  AST √© uma exibi√ß√£o da estrutura sint√°tica do c√≥digo na forma de uma √°rvore.  Isso √© realmente conveniente para o programa, embora seja dif√≠cil de ler. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Obter um elemento da matriz com o √≠ndice 1 na forma de uma √°rvore √© representado como um operador e dois operandos: carregue a propriedade pela chave e essas chaves. <br><br><h3>  <strong>Onde o AST √© usado?</strong> </h3><br>  AST n√£o √© apenas em motores.  Usando o AST, muitos utilit√°rios escrevem extens√µes, incluindo: <br><br><ul><li>  ESLint; </li><li>  Babel; </li><li>  Mais bonito </li><li>  Jscodeshift. </li></ul><br>  Por exemplo, a coisa legal Jscodeshift, sobre a qual nem todo mundo sabe ainda, permite escrever transforma√ß√µes.  Se voc√™ alterar a API de uma fun√ß√£o, poder√° definir essas transforma√ß√µes nela e fazer altera√ß√µes em todo o projeto. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  N√≥s seguimos em frente.  O processador n√£o entende a √°rvore de sintaxe abstrata; ele precisa de <strong>c√≥digo de m√°quina</strong> .  Portanto, outras transforma√ß√µes ocorrem atrav√©s do int√©rprete, porque a linguagem √© interpretada. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  Assim, enquanto os navegadores tinham um pouco de JavaScript - destaque a linha, abra algo, feche.  Mas agora temos aplicativos - SPA, Node.js e o <strong>int√©rprete est√° se tornando um gargalo</strong> . <br><br><h2>  <strong>Otimizando o Compilador JIT</strong> </h2><br>  Em vez de um int√©rprete, um compilador JIT otimizado aparece, ou seja, um compilador Just-in-time.  Compiladores antecipados funcionam antes da execu√ß√£o do aplicativo e JIT - durante.  Na quest√£o da otimiza√ß√£o, o compilador JIT tenta adivinhar como o c√≥digo ser√° executado, quais tipos ser√£o usados ‚Äã‚Äãe otimizar o c√≥digo para que funcione melhor. <br><br>  Essa otimiza√ß√£o √© chamada <strong>especulativa</strong> , porque especula sobre o conhecimento do que aconteceu com o c√≥digo antes.  Ou seja, se algo com o tipo de n√∫mero foi chamado 10 vezes, o compilador acha que isso acontecer√° o tempo todo e otimiza para esse tipo. <br><br>  Naturalmente, se Booleano entrar na entrada, a desoptimiza√ß√£o ocorre.  Considere uma fun√ß√£o que adiciona n√∫meros. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Dobrado uma vez, pela segunda vez.  O compilador cria a previs√£o: "Estes s√£o n√∫meros, eu tenho uma solu√ß√£o legal para adicionar n√∫meros!"  E voc√™ escreve <code>foo('WTF', 'JS')</code> e passa as linhas para a fun√ß√£o - temos JavaScript, podemos adicionar uma linha com um n√∫mero. <br><br>  Nesse ponto, a desoptimiza√ß√£o ocorre. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  Portanto, o int√©rprete foi substitu√≠do pelo compilador.  O diagrama acima parece ter um pipeline muito simples.  Na realidade, tudo √© um pouco diferente. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  Isso foi at√© o ano passado.  No ano passado, voc√™ ouviu muitos relat√≥rios do Google de que eles lan√ßaram um novo pipeline com o TurboFan e agora o esquema parece mais simples. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Curiosamente, um int√©rprete apareceu aqui. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  √â necess√°rio um int√©rprete para transformar uma √°rvore de sintaxe abstrata em um bytecode e passar o bytecode para um compilador.  No caso de desoptimiza√ß√£o, ele volta ao int√©rprete. <br><br><h2>  <strong>Igni√ß√£o de int√©rpretes</strong> </h2><br>  Anteriormente, n√£o havia esquema do interpretador de igni√ß√£o.  O Google disse inicialmente que n√£o √© necess√°rio um int√©rprete - o JavaScript j√° √© compacto e interpret√°vel - n√£o ganharemos nada. <br><br>  Mas a equipe que trabalhou com aplicativos m√≥veis encontrou o seguinte problema. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  Em 2013-2014, as pessoas come√ßaram a usar dispositivos m√≥veis para acessar a Internet com mais frequ√™ncia do que o desktop.  Basicamente, este n√£o √© um iPhone, mas de dispositivos mais simples - eles t√™m pouca mem√≥ria e um processador fraco. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Acima est√° um gr√°fico da an√°lise inicial de 1 MB de c√≥digo antes de iniciar o int√©rprete.  Pode-se ver que a √°rea de trabalho ganha muito.  O iPhone tamb√©m n√£o √© ruim, mas tem um mecanismo diferente, e estamos falando do V8, que funciona no Chrome. <br><br><blockquote>  Voc√™ sabia que se voc√™ instalar o Chrome no iPhone, ele ainda funcionar√° no JavaScriptCore? </blockquote><br>  Assim, o tempo √© desperdi√ßado - e isso √© apenas an√°lise, n√£o execu√ß√£o - seu arquivo foi carregado e est√° tentando entender o que est√° escrito nele. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  Quando a desoptimiza√ß√£o ocorre, voc√™ precisa pegar o c√≥digo fonte novamente, ou seja,  ele precisa ser armazenado em algum lugar.  Foi preciso muita mem√≥ria. <br><br>  Assim, o int√©rprete teve duas tarefas: <br><br><ol><li>  reduzir a sobrecarga de an√°lise; <br></li><li>  reduza o consumo de mem√≥ria. <br></li></ol><br>  As tarefas foram resolvidas mudando para um int√©rprete de bytecode. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>O bytecode no Chrome √© uma m√°quina de registro com bateria</strong> .  O SpiderMonkey possui uma m√°quina empilhada, todos os dados est√£o na pilha, mas n√£o h√° registros.  Aqui est√£o eles. <br><br>  N√£o analisaremos completamente como isso funciona, basta olhar para o fragmento de c√≥digo. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  Diz aqui: pegue o valor que est√° na bateria e adicione-o ao valor que est√° no registro <strong>a0</strong> , ou seja, na vari√°vel <strong>a</strong> .  Ainda n√£o se sabe nada sobre os tipos aqui.  Se fosse um c√≥digo assembler real, seria escrito com um entendimento de que tipo de turnos existem na mem√≥ria, o que h√° nele.  Aqui est√° apenas uma instru√ß√£o - pegue o que est√° no registro <strong>a0</strong> e adicione-o ao valor que est√° na bateria. <br><br>  Obviamente, o int√©rprete n√£o pega apenas a √°rvore de sintaxe abstrata e a traduz em c√≥digo de bytes. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  Tamb√©m h√° otimiza√ß√µes, por exemplo, elimina√ß√£o de c√≥digo morto. <br>  Se uma se√ß√£o do c√≥digo n√£o for chamada, ela ser√° descartada e n√£o ser√° mais armazenada.  Se Ignition v√™ a adi√ß√£o de dois n√∫meros, ele os adiciona e os deixa de forma a n√£o armazenar informa√ß√µes desnecess√°rias.  Somente depois disso √© obtido o bytecode. <br><br><h2>  <strong>Otimiza√ß√£o e desoptimiza√ß√£o</strong> </h2><br><h3>  Recursos frios e quentes </h3><br>  Este √© o t√≥pico mais f√°cil. <br><br>  Fun√ß√µes frias s√£o aquelas que foram chamadas uma vez ou n√£o foram chamadas, fun√ß√µes quentes s√£o aquelas que foram chamadas v√°rias vezes.  √â imposs√≠vel dizer exatamente quantas vezes - a qualquer momento isso pode ser refeito.  Mas, em algum momento, a fun√ß√£o fica quente e o mecanismo entende que precisa ser otimizado. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  O esquema do trabalho. <br><br><ul><li>  A igni√ß√£o (int√©rprete) coleta informa√ß√µes.  Ele n√£o apenas converte o JavaScript em c√≥digo de bytes, mas tamb√©m entende quais tipos entraram, quais fun√ß√µes ficaram quentes e informa o compilador sobre tudo isso. </li><li>  Existe uma otimiza√ß√£o. </li><li>  O compilador executa o c√≥digo.  Tudo funciona bem, mas aqui chega um tipo que ele n√£o esperava, ele n√£o tem c√≥digo para trabalhar com esse tipo. </li><li>  Desoptimiza√ß√£o ocorre.  O compilador acessa o int√©rprete do Ignition para esse c√≥digo. </li></ul><br>  Este √© um ciclo normal que ocorre o tempo todo, mas n√£o √© infinito.  Em algum momento, o mecanismo diz: "N√£o, √© imposs√≠vel otimizar" e come√ßa a executar sem otimiza√ß√£o.  √â importante entender que o monomorfismo deve ser observado. <br><br>  <strong>Monomorfismo</strong> √© quando os mesmos tipos sempre chegam √† entrada da sua fun√ß√£o.  Ou seja, se voc√™ recebe string o tempo todo, n√£o precisa passar booleano para l√°. <br><br>  Mas o que fazer com objetos?  Objetos s√£o todos objetos.  Temos aulas, mas elas n√£o s√£o reais - √© apenas a√ß√∫car sobre o modelo de prot√≥tipo.  Mas dentro do mecanismo existem as chamadas classes ocultas. <br><br><h3>  Classes ocultas </h3><br>  Existem classes ocultas em todos os mecanismos, n√£o apenas no V8.  Em todos os lugares em que s√£o chamados de maneira diferente, em termos de V8, √© o Mapa. <br><br>  Todos os objetos que voc√™ criou t√™m classes ocultas.  Se voc√™ <br>  olhe para o criador de perfil de mem√≥ria, voc√™ ver√° que existem elementos onde a lista de elementos est√° armazenada, propriedades onde a propriedade est√° armazenada e mapa (geralmente o primeiro par√¢metro), onde um link para ele √© indicado em sua classe oculta. <br><br>  Mapa descreve a estrutura dos objetos, porque, em princ√≠pio, em JavaScript, a digita√ß√£o √© poss√≠vel apenas estrutural, n√£o nominal.  Podemos descrever como nosso objeto se parece, para que serve. <br><br>  Ao excluir / adicionar propriedades de objetos de classes ocultas, o objeto √© alterado, um novo √© atribu√≠do.  Vamos dar uma olhada no c√≥digo. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  Temos um construtor que cria um novo objeto do tipo Point. <br><br><ul><li>  Crie um objeto. </li><li>  Vincule uma classe oculta a ela, que diz que √© um objeto do tipo Point. </li><li>  Adicionamos o campo x - uma nova classe oculta que diz que √© um objeto do tipo Point, no qual o valor x vem primeiro. </li><li>  Adicionado y - as novas classes ocultas, nas quais x e, em seguida, y. </li><li>  Criou outro objeto - a mesma coisa acontece.  Ou seja, ele tamb√©m liga o que j√° foi criado.  Neste momento, esses dois objetos s√£o do mesmo tipo (via classes ocultas). </li><li>  Quando um novo campo √© adicionado ao segundo objeto, uma nova classe Oculta √© exibida no objeto.  Agora, para o mecanismo p1 e p2, esses s√£o objetos de classes diferentes, porque possuem estruturas diferentes </li><li>  Se voc√™ transferir o primeiro objeto para algum lugar, quando voc√™ transferir o segundo para l√°, a desoptimiza√ß√£o ocorrer√°.  A primeira se refere a uma classe oculta, a segunda a outra. </li></ul><br>  <strong>Como posso verificar as classes ocultas?</strong> <br><br>  No Node.js, voc√™ pode executar o n√≥ ‚Äîallow-natives-syntax.  Ent√£o voc√™ ter√° a oportunidade de escrever comandos em uma sintaxe especial que, √© claro, n√£o pode ser usada na produ√ß√£o.  √â assim: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  Ningu√©m garante que amanh√£ esses comandos funcionem, eles n√£o est√£o na especifica√ß√£o ECMAScript, isso √© tudo para depura√ß√£o. <br><br>  O que voc√™ acha que ser√° o resultado da chamada da fun√ß√£o% HaveSameMap para dois objetos.  A resposta correta √© falsa, porque uma tem um campo e a outra tem <strong>b</strong> .  Estes s√£o objetos diferentes.  Esse conhecimento pode ser usado para a t√©cnica de caches em linha. <br><br><h3>  Caches em linha </h3><br>  Chamamos uma fun√ß√£o muito simples que retorna um campo de um objeto.  Devolver a unidade parece ser muito simples.  Mas se voc√™ olhar para a especifica√ß√£o ECMAScript, ver√° que h√° uma lista enorme do que voc√™ precisa fazer para obter o campo do objeto.  Porque, se o campo n√£o estiver no objeto, √© poss√≠vel que esteja em seu prot√≥tipo.  Talvez seja setter, getter e assim por diante.  Tudo isso precisa ser verificado. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  Nesse caso, o objeto possui um link para o mapa, que diz: para obter o campo <strong>x</strong> , voc√™ precisa fazer um deslocamento de um e obtemos <strong>x</strong> .  Voc√™ n√£o precisa subir em lugar algum, em nenhum prot√≥tipo, tudo est√° pr√≥ximo.  Caches embutidos usam isso. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  Se chamarmos a fun√ß√£o pela primeira vez, est√° tudo bem, o int√©rprete fez a otimiza√ß√£o </li><li>  Para a segunda chamada, um estado monom√≥rfico √© salvo. </li><li>  Chamo a fun√ß√£o pela terceira vez, passo um objeto ligeiramente diferente {x: 3, y: 1}.  A desoptimiza√ß√£o ocorre, se aparecer, entramos em um estado polim√≥rfico.  Agora, o c√≥digo que executa essa fun√ß√£o sabe que dois tipos diferentes de objetos podem voar nele. </li><li>  Se passarmos objetos diferentes v√°rias vezes, ele permanecer√° em um estado polim√≥rfico, adicionando novos ifs.  Mas em algum momento se rende e entra em um estado megam√≥rfico, ou seja,  quando: "Muitos tipos diferentes chegam √† entrada - n√£o sei como otimiz√°-lo!" </li></ul><br>  Parece que agora quatro estados polim√≥rficos s√£o permitidos, mas amanh√£ pode haver 8. Isso √© decidido pelos desenvolvedores do mecanismo.  √â melhor ficarmos em um estado monom√≥rfico, em casos extremos, polim√≥rficos.  A transi√ß√£o entre estados monom√≥rficos e polim√≥rficos √© cara, porque voc√™ precisar√° ir ao int√©rprete, obter o c√≥digo novamente e otimizar novamente. <br><br><h3>  Matrizes </h3><br>  No JavaScript, al√©m das matrizes digitadas espec√≠ficas, h√° um tipo <br>  array.  Existem 6 deles no mecanismo V8: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS - apenas uma matriz compactada de n√∫mero inteiro pequeno.  Existem otimiza√ß√µes para ele. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS - uma matriz compactada de elementos duplos, tamb√©m h√° otimiza√ß√µes para ele, mas s√£o mais lentas. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS - um array empacotado no qual existem objetos, strings e tudo mais.  Para ele tamb√©m h√° otimiza√ß√µes. <br><br>  Os tr√™s tipos a seguir s√£o matrizes do mesmo tipo que os tr√™s primeiros, mas com orif√≠cios: <br><br>  4. [1, / * orif√≠cio * /, 2, / * orif√≠cio * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * orif√≠cio * /, 2, / * orif√≠cio * /, 3,4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * buraco * /, 'X'] // HOLEY_ELEMENTS <br><br>  Quando os furos aparecem em suas matrizes, as otimiza√ß√µes se tornam menos eficientes.  Eles come√ßam a funcionar mal, porque √© imposs√≠vel passar por essa matriz seguidamente, classificando as itera√ß√µes.  Cada tipo subseq√ºente √© menos otimizado <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  No diagrama, tudo acima √© otimizado mais rapidamente.  Ou seja, todos os seus m√©todos nativos - mapear, reduzir, classificar - por dentro s√£o bem otimizados.  Mas com cada tipo, a otimiza√ß√£o fica pior. <br><br>  Por exemplo, uma matriz simples [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] chegou √† entrada (n√∫mero inteiro pequeno compactado).  Alteramos levemente esse array adicionando um duplo a ele - entramos no estado PACKED_DOUBLE_ELEMENTS.  Adicione um objeto a ele - v√° para o pr√≥ximo estado, o ret√¢ngulo verde PACKED_ELEMENTS.  Adicione furos a ele - v√° para o estado HOLEY_ELEMENTS.  Queremos restaur√°-lo ao seu estado anterior para que se torne "bom" novamente - exclu√≠mos tudo o que escrevemos e permanecemos no mesmo estado ... com buracos!  Ou seja, HOLEY_ELEMENTS no canto inferior direito do diagrama.  Voltar isso n√£o funciona.  Suas matrizes s√≥ podem piorar, mas n√£o vice-versa. <br><br><h2>  <strong>Objeto parecido com uma matriz</strong> </h2><br>  Muitas vezes encontramos objetos semelhantes a matrizes - esses s√£o objetos que parecem matrizes porque t√™m um sinal de comprimento.  De fato, eles s√£o como um gato pirata, ou seja, parecem semelhantes, mas na efici√™ncia do consumo de rum, um gato ser√° pior que um pirata.  Da mesma forma, um objeto semelhante a uma matriz √© como uma matriz, mas n√£o √© eficiente. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Nossos dois objetos favoritos do tipo matriz s√£o argumentos e document.querySelectorAII.  Existem coisas funcionais t√£o bonitas. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  Temos um mapa - n√≥s o arrancamos do prot√≥tipo e aparentemente podemos us√°-lo.  Mas se n√£o houver um array para sua entrada, n√£o haver√° otimiza√ß√£o.  Nosso mecanismo n√£o √© capaz de otimizar objetos. <br><br>  O que precisa ser feito? <br><br><ul><li>  A op√ß√£o da velha escola - atrav√©s de slice.call () se transforma em uma matriz real. </li><li>  A op√ß√£o moderna √© ainda melhor: escreva (... descanse), obtenha uma matriz limpa - n√£o argumentos - est√° tudo bem! </li></ul><br>  Com querySelectorAll a mesma coisa - devido √† propaga√ß√£o, podemos transform√°-lo em uma matriz completa e trabalhar com todas as otimiza√ß√µes. <br><br><h2>  <strong>Matrizes grandes</strong> </h2><br><blockquote>  <strong>Charada:</strong> nova matriz (1000) vs matriz = [] <br>  Qual op√ß√£o √© melhor: crie imediatamente uma matriz grande e preencha-a com 1000 objetos em um loop ou crie uma vazia e preencha-a gradualmente? <br></blockquote><br>  <strong>Resposta correta:</strong> depende. <br><br>  Qual a diferen√ßa? <br><br><ul><li>  Quando criamos uma matriz da primeira maneira e preenchemos 1000 elementos, criamos 1000 furos.  Essa matriz n√£o ser√° otimizada.  Mas ele escrever√° rapidamente. <br></li><li>  Criando uma matriz de acordo com a segunda variante, um pouco de mem√≥ria √© alocado, escrevemos, por exemplo, 60 elementos, um pouco mais de mem√≥ria √© alocado etc. </li></ul><br>  Ou seja, no primeiro caso, escrevemos rapidamente - trabalhamos devagar;  no segundo, escrevemos devagar - trabalhamos rapidamente. <br><br><h2>  <strong>Coletor de lixo</strong> </h2><br>  O coletor de lixo tamb√©m consome um pouco de tempo e recursos.  Sem mergulhar profundamente, darei a base mais comum. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  Nosso modelo generativo possui um <strong>espa√ßo de objetos jovens e velhos</strong> .  O objeto criado cai no espa√ßo de objetos jovens.  Ap√≥s algum tempo, a limpeza come√ßa.  Se o objeto n√£o puder ser alcan√ßado pelos links da raiz, ele poder√° ser coletado no lixo.  Se o objeto ainda estiver em uso, ele se mover√° para o espa√ßo de objetos antigos, que s√£o limpos com menos frequ√™ncia.  No entanto, em algum momento, os objetos antigos s√£o exclu√≠dos. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  √â assim que um coletor de lixo autom√°tico funciona - ele limpa os objetos com base no fato de que n√£o h√° links para eles.  Estes s√£o dois algoritmos diferentes. <br><br><ol><li>  <strong>A limpeza</strong> √© r√°pida, mas n√£o eficaz. <br></li><li>  <strong>Mark-Sweep</strong> √© lento, mas eficiente. <br></li></ol><br>  Se voc√™ come√ßar a criar um perfil do consumo de mem√≥ria no Node.js, obter√° algo assim. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  A princ√≠pio, cresce abruptamente - este √© o trabalho do algoritmo Scavenge.  Ent√£o ocorre uma queda acentuada - esse algoritmo Mark-Sweep coletou lixo no espa√ßo de objetos antigos.  Neste momento, tudo come√ßa a desacelerar um pouco.  <strong>Voc√™ n√£o pode control√°-lo</strong> , porque voc√™ n√£o sabe quando isso acontecer√°.  Voc√™ s√≥ pode ajustar os tamanhos. <br><br>  Portanto, o pipeline possui um est√°gio de coleta de lixo que consome tempo. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>Ainda mais r√°pido?</strong> </h2><br>  Vamos olhar para o futuro.  O que fazer a seguir, como ser mais r√°pido? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  Nesta linha, os tamanhos dos blocos est√£o aproximadamente relacionados no tempo que leva. <br><br>  A primeira coisa que vem √† mente das pessoas que ouviram falar sobre bytecode - envie imediatamente um bytecode √† entrada e decodifique-a, em vez de analis√°-la - ser√° mais r√°pida! <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  O problema √© que o bytecode √© diferente agora.  Como eu disse: no Safari um, no FireFox outro, no Chrome terceiro.  No entanto, desenvolvedores da Mozilla, Bloomberg e Facebook apresentaram essa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">proposta</a> , mas este √© o futuro. <br><br>  H√° outro problema - compila√ß√£o, otimiza√ß√£o e re-otimiza√ß√£o, se o compilador n√£o adivinhar.  Imagine que haja uma linguagem de tipo estaticamente na entrada que produza c√≥digo efetivo, o que significa que a re-otimiza√ß√£o n√£o √© mais necess√°ria, porque o que obtivemos j√° √© eficiente.  Essa entrada s√≥ pode ser compilada e otimizada uma vez.  O c√≥digo resultante ser√° mais eficiente e ser√° executado mais rapidamente. <br><br>  O que mais pode ser feito?  Imagine que esse idioma tenha gerenciamento manual de mem√≥ria.  Ent√£o n√£o precisa de um coletor de lixo.  A linha ficou mais curta e mais r√°pida. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  Adivinha o que parece?  <strong>WebAssembly</strong> aproximadamente <br>  √© assim que funciona: gerenciamento manual de mem√≥ria, tipicamente estaticamente <br>  idiomas e execu√ß√£o r√°pida. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  O WebAssembly √© uma bala de prata? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  N√£o, porque significa JavaScript.  O WASM ainda n√£o pode fazer nada.  Ele n√£o tem acesso √† API DOM.  Est√° dentro do mecanismo JavaScript - dentro do mesmo mecanismo!  Ele faz tudo atrav√©s do JavaScript, portanto o <strong>WASM n√£o acelerar√° o seu c√≥digo</strong> .  Isso pode acelerar c√°lculos individuais, mas sua troca entre JavaScript e WASM ser√° um gargalo. <br><br>  Portanto, enquanto a nossa linguagem √© JavaScript e apenas ela, e alguma ajuda da caixa preta. <br><br><h2>  <strong>Total</strong> </h2><br>  Tr√™s tipos de otimiza√ß√£o podem ser distinguidos. <br><br>  ‚óè <strong>Otimiza√ß√µes algor√≠tmicas</strong> <br><br>  H√° um artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Talvez voc√™ n√£o precise do Rust para acelerar o seu JS</a> " de Vyacheslav Egorov, que desenvolveu o V8 e agora est√° desenvolvendo o Dart.  Recontar brevemente sua hist√≥ria. <br><br>  Havia uma biblioteca JavaScript que n√£o funcionava muito r√°pido.  Alguns caras o reescreveram no Rust, compilaram e obtiveram o WebAssembly, e o aplicativo come√ßou a funcionar mais rapidamente.  Vyacheslav Egorov, como um desenvolvedor JS experiente, decidiu respond√™-los.  Ele aplicou otimiza√ß√µes algor√≠tmicas e a solu√ß√£o JavaScript ficou muito mais r√°pida que a solu√ß√£o Rust.  Por sua vez, esses caras viram isso, fizeram as mesmas otimiza√ß√µes e venceram novamente, mas n√£o muito - depende do mecanismo: no Mozilla eles venceram, no Chrome n√£o. <br><br>  Hoje, n√£o falamos sobre otimiza√ß√µes algor√≠tmicas, e as renderiza√ß√µes de front-end geralmente n√£o falam sobre elas.  Isso √© muito ruim, porque os <strong>algoritmos tamb√©m permitem que o c√≥digo seja executado mais rapidamente</strong> .  Voc√™ simplesmente remove os ciclos que n√£o precisa. <br><br>  ‚óè <strong>Otimiza√ß√µes espec√≠ficas do idioma</strong> <br><br>  √â disso que falamos hoje: nossa linguagem √© interpretada de forma din√¢mica.  Compreender como matrizes, objetos e monomorfismo funcionam <strong>permite escrever c√≥digo eficiente</strong> .  Isso deve ser conhecido e escrito corretamente. <br><br>  ‚óè <strong>Otimiza√ß√µes espec√≠ficas do mecanismo</strong> <br><br>  Essas s√£o as otimiza√ß√µes mais perigosas.  Se o seu desenvolvedor muito inteligente, mas n√£o muito soci√°vel, que aplicou muitas dessas otimiza√ß√µes e n√£o contou a ningu√©m sobre elas, n√£o escreveu a documenta√ß√£o, se voc√™ abrir o c√≥digo, n√£o ver√° JavaScript, mas, por exemplo, o Crankshaft Script.  Ou seja, o JavaScript foi escrito com uma profunda compreens√£o de como o motor do virabrequim funcionava h√° dois anos.  Tudo funciona, mas agora n√£o √© mais necess√°rio. <br><br>  Portanto, essas otimiza√ß√µes devem necessariamente ser documentadas, cobertas com testes que comprovem sua efic√°cia no momento.  Eles devem ser monitorados.  Voc√™ precisa procur√°-los apenas no momento em que realmente desacelerou em algum lugar - voc√™ n√£o pode ficar sem conhecer dispositivos t√£o profundos.  Portanto, a famosa frase de Donald Knuth parece l√≥gica. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  N√£o h√° necessidade de tentar implementar qualquer tipo de otimiza√ß√µes r√≠gidas apenas porque voc√™ l√™ cr√≠ticas positivas sobre elas. <br><br>  √â preciso ter medo dessas otimiza√ß√µes, documentar e deixar m√©tricas.  Geralmente sempre colete m√©tricas.  <strong>M√©tricas s√£o importantes!</strong> <br><br>  <strong>Links √∫teis:</strong> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resumos e apresenta√ß√£o do relat√≥rio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que h√° com o monomorfismo?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que torna o WebAssembly r√°pido?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O caminho para entender o bytecode V8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Devshacht: Hardcore</a> </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417459/">https://habr.com/ru/post/pt417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417447/index.html">Expedi√ß√£o aos misteriosos c√≠rculos de fadas no deserto do Namibe</a></li>
<li><a href="../pt417449/index.html">Mundo Jur√°ssico: Podemos Realmente Ressuscitar Dinossauros?</a></li>
<li><a href="../pt417451/index.html">Cinco erros comuns para iniciantes</a></li>
<li><a href="../pt417453/index.html">Organiza√ß√£o de est√°gios para estudantes: truques e truques</a></li>
<li><a href="../pt417457/index.html">Frontend Conf Moscow - entrada e sa√≠da do cliente</a></li>
<li><a href="../pt417461/index.html">Ivan Tulup: ass√≠ncrono em JS sob o cap√¥</a></li>
<li><a href="../pt417463/index.html">Uma reuni√£o inesperada. Cap√≠tulo 17</a></li>
<li><a href="../pt417465/index.html">Uma vis√£o geral dos m√©todos de vincula√ß√£o de texto</a></li>
<li><a href="../pt417469/index.html">Cinco raz√µes ego√≠stas para trabalhar de forma reproduz√≠vel</a></li>
<li><a href="../pt417471/index.html">Solda simples MK936 SMD. Esta√ß√£o de solda DIY para componentes SMD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>