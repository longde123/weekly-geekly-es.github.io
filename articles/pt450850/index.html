<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëö üëáüèΩ üêè Rumo a um futuro melhor para compiladores inteligentes üïõ üèÇüèª ü¶É</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Agora, o t√≥pico de aprendizado de m√°quina e intelig√™ncia artificial √© extremamente popular no momento, gra√ßas ao poder computacional dos computadores,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rumo a um futuro melhor para compiladores inteligentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450850/">  Agora, o t√≥pico de aprendizado de m√°quina e intelig√™ncia artificial √© extremamente popular no momento, gra√ßas ao poder computacional dos computadores, id√©ias e algoritmos que surgiram h√° muito tempo podem ser implementados e melhorados significativamente.  Quase todos os dias voc√™ pode ler not√≠cias sobre novas conquistas nesta √°rea.  Al√©m disso, o aprendizado de m√°quina √© usado em quase todas as √°reas ... e o desenvolvimento de compiladores n√£o √© exce√ß√£o.  No entanto, a √°rea √© bastante espec√≠fica e possui caracter√≠sticas e dificuldades pr√≥prias na cria√ß√£o de compiladores inteligentes.  Ao mesmo tempo, existem muitos estudos sobre esse assunto e eles s√£o realizados h√° muito tempo, tanto no ambiente acad√™mico quanto em v√°rias empresas. <br><br>  Onde exatamente est√° tentando aplicar m√©todos de aprendizado de m√°quina ao criar compiladores?  E por que at√© agora os compiladores "inteligentes" n√£o se tornaram parte da vida di√°ria do desenvolvedor? <br><a name="habracut"></a><br><h2>  Op√ß√µes para usar o aprendizado de m√°quina no desenvolvimento do compilador </h2><br>  Vamos come√ßar com a primeira pergunta sobre usos espec√≠ficos do aprendizado de m√°quina.  O fato √© que os compiladores modernos s√£o sistemas complexos com um grande n√∫mero de otimiza√ß√µes que permitem obter c√≥digo de m√°quina mais eficiente.  No entanto, algumas das otimiza√ß√µes e outras tarefas, como aloca√ß√£o de registros, s√£o NP-completas, o que for√ßa os desenvolvedores de compiladores a usar algoritmos heur√≠sticos.  Como resultado, a maioria dos compiladores possui um grande n√∫mero de sinalizadores de otimiza√ß√£o que permitem configurar as heur√≠sticas usadas.  No LLVM, quase todas as passagens possuem v√°rias op√ß√µes ocultas que podem afetar sua opera√ß√£o; elas podem ser usadas usando o sinalizador ‚Äìmllvm ao chamar clang ou no utilit√°rio opt.  No entanto, essa variedade de sinalizadores est√° oculta por tr√°s das op√ß√µes usadas com mais frequ√™ncia, que cont√™m muitas configura√ß√µes ao mesmo tempo e s√£o geralmente chamadas de n√≠veis de otimiza√ß√£o.  Para compiladores C / C ++, estes s√£o conhecidos pela maioria dos tipos -O1, -O2, -O3 por otimizar o tempo de execu√ß√£o e -Os por otimizar o tamanho do c√≥digo.  Mas, infelizmente, o c√≥digo ideal nem sempre √© o resultado (especialistas em montadores podem reescrever o c√≥digo gerado da melhor maneira), depende muito do c√≥digo-fonte em uma linguagem de alto n√≠vel, arquitetura de processador, recursos de linguagem etc. <br><br>  Apesar de hoje os processadores modernos terem RAM suficiente e desempenho bastante alto, ainda existem √°reas em que o desempenho do aplicativo, a efici√™ncia energ√©tica e o tamanho do c√≥digo da m√°quina desempenham um papel fundamental.  Exemplos dessas √°reas incluem desenvolvimento de software para sistemas embarcados com uma quantidade limitada de RAM, processamento de sinal digital, sistemas em tempo real, etc.  Portanto, nos casos em que voc√™ precisa obter c√≥digo de m√°quina de alto desempenho para sistemas grandes o suficiente, a sele√ß√£o das op√ß√µes de compila√ß√£o corretas que fornecem o melhor resultado √© uma tarefa importante.  Al√©m disso, o problema de pior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caso</a> de tempo de execu√ß√£o ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WCET</a> ) n√£o desapareceu quando os sistemas em tempo real precisam calcular e minimizar, se poss√≠vel, o tempo de execu√ß√£o de uma tarefa espec√≠fica na plataforma.  At√© agora, os programadores que trabalham com sistemas com uma quantidade limitada de RAM n√£o podem confiar totalmente nos compiladores e, geralmente, otimizam independentemente o c√≥digo de m√°quina gerado. <br><br>  √â dif√≠cil para uma pessoa prever quais otimiza√ß√µes dar√£o um bom resultado e quais podem levar a regress√µes, pois para isso voc√™ precisa ter um bom entendimento das complexidades dos algoritmos heur√≠sticos usados, um bom conhecimento da estrutura e passagens do compilador usado e tamb√©m conhecer completamente o c√≥digo do programa compilado, que O atual processo de desenvolvimento de aplicativos √© imposs√≠vel.  Como resultado, identificar as melhores op√ß√µes de compila√ß√£o de um programa para uma pessoa torna-se uma tarefa de pesquisa exaustiva de v√°rias combina√ß√µes de op√ß√µes e medidas de desempenho e tamanhos de c√≥digo. <br><br>  Al√©m disso, h√° uma limita√ß√£o na forma de uma unidade de compila√ß√£o com a qual voc√™ pode trabalhar e para a qual pode escolher op√ß√µes.  Portanto, para C / C ++, esse ainda √© um arquivo que pode conter muito c√≥digo, o que talvez seja √∫til otimizar de maneiras diferentes, mas no momento isso n√£o √© poss√≠vel.  Portanto, um compilador ‚Äúinteligente‚Äù que possa treinar e obter c√≥digo otimizado para v√°rios casos √© um sonho para alguns desenvolvedores. <br><br><h2>  Pesquisa e solu√ß√µes existentes </h2><br>  Naturalmente, o problema da sele√ß√£o automatizada de op√ß√µes de compila√ß√£o √© de interesse dos pesquisadores h√° muitos anos.  Um dos projetos mais famosos √© o desenvolvimento de G. Fursin e pesquisadores de sua equipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MILEPOST GCC</a> , que √© uma vers√£o do compilador gcc, capaz de selecionar passes de otimiza√ß√£o com base em treinamento anterior na amostra de dados obtida.  Neste trabalho, usamos um conjunto de 55 caracter√≠sticas para resolver o problema e um modelo bastante simples, baseado na id√©ia de distribuir boas solu√ß√µes com base no algoritmo K dos vizinhos mais pr√≥ximos.  Foi esse desenvolvimento que mostrou que as passagens de otimiza√ß√£o de ajuste podem levar a um c√≥digo duas vezes mais r√°pido que o c√≥digo obtido usando a op√ß√£o de otimiza√ß√£o m√°xima padr√£o -O3. <br><br>  Existem tamb√©m estudos de G. Pekhimenko e A.D.  Marrom para o TPO da IBM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toronto Portable Optimizer</a> ).  Sua principal tarefa era selecionar valores heuristicamente selecion√°veis ‚Äã‚Äãpara otimiza√ß√µes e o pr√≥prio conjunto de transforma√ß√µes de c√≥digo.  Para a implementa√ß√£o, foi utilizada a regress√£o log√≠stica, que possibilitou a defini√ß√£o de multas eficazes para um treinamento mais r√°pido.  O classificador foi constru√≠do no Matlab.  A probabilidade de uso foi calculada para cada passe e foi utilizada se fosse superior a 50%.  Como resultado da caracter√≠stica que eles tentaram reduzir neste estudo, foi o tempo de compila√ß√£o est√°tica. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">R. A Askhari</a> participou da sele√ß√£o direta de op√ß√µes de compila√ß√£o para todo o programa, a fim de minimizar o tempo de execu√ß√£o, o tempo de compila√ß√£o, o tamanho do c√≥digo e o consumo de energia.  Para isso, foram utilizados o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Framework cTuning</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Collective Mind Framework,</a> desenvolvidos por G. Fursin e A. Lokhmotov (tamb√©m desenvolvido no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ). <br><br>  Tamb√©m existem estudos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M. Stephenson e S. Amarasinge sobre</a> sele√ß√£o de otimiza√ß√µes para certos algoritmos especialmente importantes (aloca√ß√£o de registros, PREFETCHING DE DADOS, FORMA√á√ÉO DE HIPERBLOCO).  Para cada fun√ß√£o, suas pr√≥prias caracter√≠sticas foram usadas de acordo.  Para a solu√ß√£o, foi utilizado um algoritmo gen√©tico.  O teste do produto desenvolvido foi realizado no Open Research Compiler (ORC). <br><br>  H√° tamb√©m um projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MAGEEC</a> (Compilador Eficiente em Energia Guiada por M√°quina), cujos objetivos s√£o um pouco diferentes.  A infraestrutura desenvolvida usa o aprendizado de m√°quina para selecionar as otimiza√ß√µes necess√°rias para gerar o c√≥digo com a m√°xima efici√™ncia energ√©tica para sistemas de computa√ß√£o de alto desempenho.  O MAGEEC foi projetado para funcionar com o gcc e o LLVM.  Esse compilador faz parte do projeto maior TSERO (Total Software Energy Reporting and Optimization). <br><br>  Uma pesquisa diretamente relacionada ao LLVM √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LLVMTuner</a> , um produto de software desenvolvido na Universidade de Illinois por I. Chen e W. Adwe.  Em 2017, foi apresentado um relat√≥rio descrevendo os resultados dispon√≠veis naquele momento.  Neste trabalho, otimizamos os ciclos "quentes" individuais.  Essa estrutura foi projetada para configura√ß√£o automatizada de programas grandes.  O LLVMTuner √© executado no middleware LLVM IR, usa cria√ß√£o de perfil para identificar loops quentes e, em seguida, ajusta automaticamente a heur√≠stica para eles.  O foco est√° nos ciclos de n√≠vel superior.  Os ciclos selecionados e quaisquer fun√ß√µes de chamada s√£o transferidos para um m√≥dulo separado, que √© posteriormente submetido √†s otimiza√ß√µes necess√°rias.  Esta solu√ß√£o permite obter um desempenho aprimorado em programas grandes. <br><br><h2>  Problemas existentes </h2><br>  No entanto, n√£o existe um compilador amplamente utilizado que ajusta independentemente as heur√≠sticas da otimiza√ß√£o de passes.  Qual √© o problema?  Como voc√™ sabe, a efic√°cia dos m√©todos de aprendizado de m√°quina e a qualidade dos modelos obtidos dependem da escolha correta dos recursos e da qualidade dos dados para o treinamento (apesar da exist√™ncia de algoritmos menos sens√≠veis a dados "ruidosos").  Sem conhecer a estrutura e os algoritmos usados ‚Äã‚Äãno compilador, n√£o √© f√°cil selecionar um conjunto completo e suficiente de caracter√≠sticas para o treinamento, embora existam bastante claras e l√≥gicas, por exemplo, o tamanho do ciclo, o n√∫mero de sa√≠das do ciclo, etc.  Portanto, √© dif√≠cil desenvolver uma solu√ß√£o universal adequada para muitos compiladores de uma s√≥ vez e n√£o √© fato que geralmente seja poss√≠vel.  Al√©m disso, √© prov√°vel que isso n√£o seja necess√°rio. <br><br>  Como o desenvolvimento de compiladores deve ser eficiente e vi√°vel em um tempo bastante curto, √© natural que mesmo grandes empresas desenvolvam seus compiladores industriais com base em solu√ß√µes prontas.  As solu√ß√µes mais modernas podem ser divididas em duas categorias: execu√ß√£o em m√°quinas virtuais, por exemplo, compiladores JVM - JIT e compiladores baseados no LLVM, um sistema que implementa uma m√°quina virtual com instru√ß√µes do tipo RISC - compiladores est√°ticos e din√¢micos.  Obviamente, ainda existem solu√ß√µes pr√≥prias das empresas, mas elas est√£o se tornando menos competitivas devido √† falta de uma grande comunidade envolvida no desenvolvimento das tecnologias usadas nelas.  Como resultado, hoje muitas empresas grandes como Google, Apple, Adobe e ARM usam o LLVM para desenvolver suas pr√≥prias solu√ß√µes.  Obviamente, o gcc continua sendo o principal compilador para C / C ++, existem outras solu√ß√µes para outros idiomas, mas de qualquer maneira, se, por exemplo, for encontrada uma solu√ß√£o para LLVM, isso j√° cobrir√° uma parte decente dos compiladores atualmente existentes. <br><br>  A cole√ß√£o de caracter√≠sticas para treinamento tamb√©m se torna um grande problema, uma vez que os compiladores de m√∫ltiplas passagens transformam fortemente a representa√ß√£o intermedi√°ria, e as caracter√≠sticas coletadas no est√°gio inicial n√£o s√£o muito relevantes para otimiza√ß√µes posteriores do compilador; essas caracter√≠sticas podem mudar com alta probabilidade.  Al√©m disso, faz sentido coletar separadamente para diferentes tipos de elementos: m√≥dulos, ciclos, blocos de base, j√° que as otimiza√ß√µes geralmente s√£o projetadas para alterar um tipo espec√≠fico de elemento, no LLVM, mesmo de acordo com esse crit√©rio, as passagens s√£o divididas. <br><br>  Mas, em primeiro lugar, surge a quest√£o de identificar os elementos para os quais √© necess√°rio coletar caracter√≠sticas.  Existem v√°rias maneiras de calcular identificadores exclusivos que podem ser salvos durante todas as otimiza√ß√µes, por exemplo: <br><br><ul><li>  Hash de front-end baseado em AST </li><li>  n√∫meros exclusivos atribu√≠dos na an√°lise de front-end </li><li>  N√∫mero de 64 bits gerado com base em arcos no CFG (gr√°fico de fluxo de controle) usando uma soma de verifica√ß√£o (semelhante ao PGO (otimiza√ß√£o guiada por perfil) no LLVM) </li></ul><br>  No entanto, √© necess√°rio salvar adequadamente esses identificadores durante as transforma√ß√µes, quando os elementos puderem se mesclar em um, dividir, criar novos e excluir os originais, o que n√£o √© uma tarefa f√°cil. <br><br>  Em segundo lugar, √© dif√≠cil, em princ√≠pio, avaliar os limites dos ciclos de origem, blocos de base etc. escritos no c√≥digo-fonte, no IR j√° convertido.  Por exemplo, devido √† gera√ß√£o de c√≥digo de m√°quina em v√°rios est√°gios adotada pelo LLVM, as informa√ß√µes sobre as unidades base da m√°quina s√£o perdidas ap√≥s a gera√ß√£o do c√≥digo com base nas instru√ß√µes da m√°quina no AsmPrinter.  E, consequentemente, as informa√ß√µes sobre os identificadores dos blocos de base e ciclos tamb√©m s√£o perdidas, para as quais, por exemplo, o deslocamento desde o in√≠cio da fun√ß√£o √© medido, portanto, com este m√©todo, somente no est√°gio de gera√ß√£o do c√≥digo da m√°quina o deslocamento pode ser obtido na forma do n√∫mero de bytes.  No entanto, nos est√°gios subseq√ºentes da gera√ß√£o de c√≥digo de m√°quina ao trabalhar com fragmentos de m√°quina, v√°rios alinhamentos podem ser adicionados a ele, o que altera o tamanho das instru√ß√µes consideradas anteriormente, e tamb√©m as instru√ß√µes nop.  Por esse motivo, para os blocos de base no final de grandes fun√ß√µes, o erro de c√°lculo pode ser muito grande, at√© uma mudan√ßa completa para outro bloco / ciclo.  E embora algumas das transforma√ß√µes nos est√°gios posteriores possam ser rastreadas e levadas em considera√ß√£o, isso n√£o dar√° garantias para a precis√£o das medi√ß√µes, pois o tamanho das instru√ß√µes pode variar at√© o vinculador. <br><br><img src="https://habrastorage.org/webt/af/xw/2-/afxw2-jziob0rhikr1nqaw_wmai.png"><br><br>  Como voc√™ pode ver, mesmo a cole√ß√£o de atributos com base nos quais o treinamento √© necess√°rio √© bastante complicada e demorada, e que no futuro provavelmente se tornar√° o conjunto de informa√ß√µes para o modelo treinado para a tomada de decis√µes.  E n√£o h√° solu√ß√µes √≥bvias para esses problemas, o que complica o trabalho imediato associado ao aprendizado de m√°quina e atrai um grande n√∫mero de pessoas devido √† falta de conjuntos de dados suficientes.  Bem, as dificuldades t√≠picas de encontrar solu√ß√µes para problemas de aprendizado de m√°quina, escolher modelos, m√©todos, determinar o subconjunto correto de atributos com um grande n√∫mero deles, etc.  existe neste caso.  Quase todo mundo que se deparou com o aprendizado de m√°quina sabe sobre eles e, talvez, algo √∫nico e espec√≠fico para os compiladores n√£o esteja aqui. <br><br>  √â dif√≠cil prever quando os compiladores inteligentes se espalhar√£o.  Os compiladores modernos tamb√©m t√™m outros problemas que dificilmente ser√£o resolvidos por esse m√©todo e que, no momento, provavelmente s√£o mais priorit√°rios.  No entanto, os compiladores j√° se tornaram muito mais inteligentes do que eram no in√≠cio de sua apar√™ncia, e esse processo continuar√°, embora possa ser um pouco mais lento do que a maioria dos desenvolvedores gostaria. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450850/">https://habr.com/ru/post/pt450850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450838/index.html">Por que a unidade n√£o √© atribu√≠da a n√∫meros primos e quando geralmente era considerada um n√∫mero</a></li>
<li><a href="../pt450840/index.html">A √∫ltima lanterna est√° cansada ou o piscar salvar√° a Bielorr√∫ssia (atual. Spinner?)</a></li>
<li><a href="../pt450844/index.html">Introdu√ß√£o ao mapeamento de exemplo</a></li>
<li><a href="../pt450846/index.html">As maravilhas do empacotamento da Microsoft: o kernel Linux no Windows 10 e o mecanismo IE dentro do Chromium Edge</a></li>
<li><a href="../pt450848/index.html">Sobre o f√≥sforo amarelo e a natureza em p√¢nico do homem</a></li>
<li><a href="../pt450854/index.html">Experi√™ncia no desenvolvimento de um ativo Unity para encontrar um caminho no espa√ßo 3D</a></li>
<li><a href="../pt450858/index.html">Encontro de rede de c√≥digo aberto - agora em Yandex.Cloud # 3.2019</a></li>
<li><a href="../pt450860/index.html">Tomada inteligente REDMOND SkyPort 100S</a></li>
<li><a href="../pt450862/index.html">@Pythonetc Abril de 2019</a></li>
<li><a href="../pt450864/index.html">Dicas e truques do meu canal de telegrama @pythonetc, abril de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>