<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 👨🏾‍🍳 👼🏻 如何使用Yandex.Direct API示例（第1部分），通过并行计算加快使用R语言API的工作 👨‍👨‍👧 🙌🏻 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如今，R语言是处理数据的最强大，多功能的工具之一，但众所周知，几乎每桶蜂蜜中都有美中不足。 事实是R默认情况下是单线程的。 


 这很可能不会使您困扰足够长的时间，并且您不太可能会问这个问题。 但是，例如，如果您面临从API（例如Yandex.Direct）从大量广告帐户收集数据的任务，那么您可以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何使用Yandex.Direct API示例（第1部分），通过并行计算加快使用R语言API的工作</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437078/"><p> 如今，R语言是处理数据的最强大，多功能的工具之一，但众所周知，几乎每桶蜂蜜中都有美中不足。 事实是R默认情况下是单线程的。 </p><br><p> 这很可能不会使您困扰足够长的时间，并且您不太可能会问这个问题。 但是，例如，如果您面临从API（例如Yandex.Direct）从大量广告帐户收集数据的任务，那么您可以显着减少至少两到三倍的时间来减少使用多线程收集数据的时间。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/86f/042/b60/86f042b609e10a79893f2dfbc24fd6f8.jpg" alt="图片"></p><a name="habracut"></a><br><p> R中的多线程主题不是新话题，在Habré的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>已多次提出，但是上一版出版物的历史可追溯至2013年，正如他们所说的，所有新内容都被遗忘了。 此外，之前讨论了用于计算模型和训练神经网络的多线程，我们将讨论使用异步与API配合使用。 不过，我想借此机会感谢这些文章的作者，因为 他们用他们的出版物为我写这篇文章提供了很大帮助。 </p><br><h2 id="soderzhanie"> 目录内容 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是多线程</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们将使用哪些软件包</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">挑战赛</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Yandex.Direct，ryandexdirect软件包中的授权</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用for循环的单线程顺序解决方案</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">R中的多线程解决方案</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DoSNOW软件包和多线程功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DoParallel套餐</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三种方法之间的速度测试，rbenchmark程序包</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><p> 本文的第二部分提供了有关在R中实现多线程的更现代选项的信息。 </p><br><h2 id="chto-takoe-mnogopotochnost"> 什么是多线程 </h2><br><p>  <u><strong>单线程（顺序计算）</strong></u> -一种按顺序执行所有动作（任务）的计算模式，在这种情况下，所有给定操作的总持续时间将等于所有操作的持续时间之和。 </p><br><p>  <u><strong>多线程（并行计算）</strong></u> -一种计算模式，其中并行执行指定的操作（任务），即 同时，所有操作的总执行时间将不等于所有操作的持续时间之和。 </p><br><p> 为了简化理解，让我们看一下下表： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f01/295/d5d/f01295d5dcf31db7d8ea8826c724f271.png" alt="图片"></p><br><p> 给定表的第一行是有条件的时间单位，在这种情况下，对我们来说，秒，分钟或任何其他时间段都无关紧要。 </p><br><p> 在此示例中，我们需要执行4个操作，在这种情况下每个操作具有不同的计算持续时间，在单线程模式下，所有4个操作将依次依次执行，因此执行它们的总时间为t1 + t2 + t3 + t4，3 + 1 + 5 + 4 = 13。 </p><br><p> 在多线程模式下，所有4个任务将并行执行，即 要开始下一个任务，无需等待上一个任务完成，因此，如果我们在4个线程中启动我们的任务，则总计算时间将等于最大任务的计算时间，在本例中是任务t3，在我们的示例中，计算持续时间为5临时单元，在这种情况下所有4个操作的执行时间将等于5个临时单元。 </p><br><h2 id="kakie-pakety-my-budem-ispolzovat"> 我们将使用哪些软件包 </h2><br><p>对于多线程模式下的计算，我们将使用<code>foreach</code> ， <code>doSNOW</code>和<code>doParallel</code> 。 </p><br><p>  <code>foreach</code>包允许您使用<code>foreach</code>构造，它实质上是for循环的增强功能。 </p><br><p>  <code>doSNOW</code>和<code>doParallel</code>本质上是孪生兄弟，允许您创建虚拟集群并使用它们执行并行计算。 </p><br><p> 在本文的<code>rbenchmark</code>我们将使用<code>rbenchmark</code>包<code>rbenchmark</code>使用以下描述的所有方法来测量和比较Yandex.Direct API中数据收集操作的持续时间。 </p><br><p> 要使用Yandex.Direct API，我们将使用ryandexdirect包，在本文中，我们将以它为例，有关其功能的更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a> 。 </p><br><p> 用于安装所有必需软件包的代码： </p><br><pre> <code class="plaintext hljs">install.packages("foreach") install.packages("doSNOW") install.packages("doParallel") install.packages("rbenchmark") install.packages("ryandexdirect")</code> </pre> <br><h2 id="zadacha"> 挑战赛 </h2><br><p> 您必须编写代码，要求从任意数量的Yandex.Direct广告帐户中获取关键字列表。 结果必须在一个日期范围内收集，在该日期范围内，关键字所属的广告帐户的登录将有一个附加字段。 </p><br><p> 此外，我们的任务是编写一个代码，该代码将在任意数量的广告帐户上尽快执行此操作。 </p><br><h2 id="avtorizaciya-v-yandeksdirekt">  Yandex.Direct中的授权 </h2><br><p> 要使用Yandex.Direct广告平台的API，最初需要在我们计划从中请求关键字列表的每个帐户下进行授权。 </p><br><p> 本文提供的所有代码均反映了使用常规Yandex.Direct广告帐户的示例，如果您使用代理帐户，则需要使用<em>AgencyAccount</em>参数并将代理帐户登录名传递给它。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>使用ryandexdirect包找到有关使用Yandex.Direct代理帐户的更多信息。 </p><br><p> 为了进行授权，您需要从<code>yadirAuth</code>包中执行<code>yadirAuth</code>函数，对于需要从中请求关键字及其参数列表的每个帐户，都需要重复以下代码。 </p><br><pre> <code class="plaintext hljs">ryandexdirect::yadirAuth(Login = "    ")</code> </pre> <br><p> 尽管<code>ryandexdirect</code>通过第三方站点进行的，但通过<code>ryandexdirect</code>软件包进行的授权过程<code>ryandexdirect</code>完全安全的。 我已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“使用R包与广告系统API一起使用有多安全”</a>一文中详细讨论了其使用的安全性。 </p><br><p> 授权后，将在工作目录中的每个帐户下创建一个<em>login.yadirAuth.RData</em>文件，该文件将存储每个帐户的凭据。 文件名将从<em>Login</em>参数中指定的<em>登录</em>名开始。 如果需要将文件保存在当前工作目录中，而不是当前目录中，请使用<em>TokenPath</em>参数，但是在这种情况下，使用<code>yadirGetKeyWords</code>函数请求关键字时<code>yadirGetKeyWords</code>还需要使用<em>TokenPath</em>参数并指定保存文件的文件夹的路径与凭据。 </p><br><h2 id="reshenie-v-odnopotochnom-posledovatelnom-rezhime-s-ispolzovaniem-cikla-for"> 使用for循环的单线程顺序解决方案 </h2><br><p> 一次从多个帐户收集数据的最简单方法是使用<code>for</code>循环。 简单但不是最有效的，因为  R语言开发的原则之一是避免在代码中使用循环。 </p><br><p> 以下是使用for循环从4个帐户收集数据的示例代码，实际上，您可以使用此示例从任意数量的广告帐户收集数据。 </p><br><div class="spoiler">  <b class="spoiler_title">代码1：我们使用通常的for循环处理4个帐户</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(ryandexdirect) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") #    res1 &lt;- data.frame() #    for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) temp$login &lt;- login res1 &lt;- rbind(res1, temp) }</code> </pre> </div></div><br><p> 使用system.time函数测量运行时显示以下结果： </p><br><p>  <strong>工作时间：</strong> <br>  <u>用户：</u> 178.83 <br>  <u>系统：</u> 0.63 <br>  <u>通过：</u> 320.39 </p><br><p> 收集4个帐户的关键字花费了320秒，从<code>yadirGetKeyWords</code>函数在操作过程中显示的信息消息中，可以看到最大的帐户，其中接收了5970个关键字，并处理了142秒。 </p><br><h2 id="reshenie-s-pomoschyu-mnogopotochnosti-v-r">  R中的多线程解决方案 </h2><br><p> 在上面我已经写过，对于多线程，我们将使用<code>doSNOW</code>和<code>doParallel</code> 。 </p><br><p> 我想提请注意以下事实：几乎所有API都有其自身的局限性，Yandex.Direct API也不例外。 实际上，使用Yandex.Direct API的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帮助</a>说： </p><br><blockquote> 代表一个用户最多同时允许五个API请求。 </blockquote><p> 因此，尽管在这种情况下我们将考虑创建4个流的示例，但在使用Yandex.Direct的情况下，即使您在同一用户下发送所有请求，也可以创建5个流。 但是最合理的做法是每1个处理器内核使用1个线程，您可以使用<code>parallel::detectCores(logical = FALSE)</code>命令确定物理处理器内核的数量，可以使用<code>parallel::detectCores(logical = TRUE)</code>查找逻辑内核的数量。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia</a>上可以更详细地了解这种物理和逻辑核心是什么。 </p><br><p> 除了请求数量的限制外，访问Yandex.Direct API的点数每天都有限制，对于所有帐户而言，它可能都不同，根据所执行的操作，每个请求所消耗的点数也不同。 例如，要查询关键字列表，对于完整的查询，您将被扣除15分，而每2000个字词将被扣除3分，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方证书中</a>找到如何注销这些积分。 您还可以在由<code>yadirGetKeyWords</code>函数返回到控制台的信息消息中查看有关得分和可用分数的信息，以及它们的每日限额。 </p><br><pre> <code class="plaintext hljs">Number of API points spent when executing the request: 60 Available balance of daily limit API points: 993530 Daily limit of API points:996000</code> </pre> <br><p> 让我们按顺序处理<code>doSNOW</code>和<code>doParallel</code> 。 </p><br><h3 id="paket-dosnow-i-osobennosti-raboty-v-mnogopotochnom-rezhime">  DoSNOW软件包和多线程功能 </h3><br><p> 我们为多线程计算模式重写相同的操作，在这种情况下创建4个线程，并且使用<code>foreach</code>构造代替<code>for</code>循环。 </p><br><div class="spoiler">  <b class="spoiler_title">代码2：使用doSNOW进行并行计算</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doSNOW) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- foreach(login = logins, #  -  .combine = 'rbind', #        .packages = "ryandexdirect", #   .inorder=F ) %dopar% {cbind(yadirGetKeyWords(Login = login), login) } stopCluster(cl)</code> </pre> </div></div><br><p> 在这种情况下，使用system.time函数测量运行时将显示以下结果： </p><br><p>  <strong>工作时间：</strong> <br>  <u>使用者：</u> 0.17 <br>  <u>系统：</u> 0.08 <br>  <u>通过：</u> 151.47 </p><br><p> 相同的结果 我们在151秒内，即从4个Yandex.Direct帐户收到了关键字集合。 快2倍。 另外，我在上一个示例中写道，从最大的帐户加载关键字列表需要多长时间（142秒），即 在此示例中，总时间几乎与最大帐户的处理时间相同。 事实是，借助<code>foreach</code>函数，我们同时启动了以4个流（即 同时从所有4个帐户中收集数据，总时间等于最大帐户的处理时间。 </p><br><p> 我<code>makeCluster</code> <em>代码2</em>进行一些说明， <code>makeCluster</code>函数负责线程的数量，在这种情况下，我们创建了一个由4个处理器核心组成的集群，但是正如我先前在使用Yandex.Direct API时所写的那样，无论有多少个帐户，您都可以创建5个线程您需要处理5-15-100或更多，您可以同时向API发送5个请求。 </p><br><p> 接下来， <code>registerDoSNOW</code>函数启动创建的集群。 </p><br><p> 之后，我们使用了<code>foreach</code>构造，如我之前所说，该构造是for循环的改进。 您将计数器指定为第一个参数，在我命名为示例的示例中，它将在每次迭代时遍历<em>logins</em>向量的元素，如果我们<code>for ( login in logins)</code>编写<code>for ( login in logins)</code> ，则会在<code>for</code>循环中获得相同的结果。 </p><br><p> 接下来，您需要在<em>.combine</em>参数中指定将合并每次迭代获得的结果的函数，最常见的选项是： </p><br><ul><li>  <code>rbind</code>将结果表彼此逐行连接； </li><li>  <code>cbind</code>将结果表连接到列中； </li><li>  <code>"+"</code> -总结每次迭代获得的结果。 </li></ul><br><p> 您还可以使用任何其他功能，甚至可以自己编写。 </p><br><p> 如果您不关心合并结果的顺序，则参数<em>.inorder = F</em>可以使您加快功能的速度，在这种情况下，顺序对我们而言并不重要。 </p><br><p> 接下来是<code>%dopar%</code>运算符，它将在并行计算模式下启动循环，如果使用<code>%do%</code>运算符，则将依次执行迭代，以及使用常规的<code>for</code>循环时。 </p><br><p>  <code>stopCluster</code>函数停止集群。 </p><br><p> 多线程，或者说多线程模式下的<code>foreach</code>构造，具有一些功能，实际上，在这种情况下，我们在一个全新的干净R会话中启动每个并行进程。 因此，为了使用其中在<code>foreach</code>构造外部定义的通用函数和内部对象，您需要使用<em>.export</em>参数导出它们。 此参数采用文本向量，其中包含要在<code>foreach</code>使用的对象的名称。 </p><br><p> 另外，在并行模式下， <code>foreach</code>在默认情况下不会看到以前连接的软件包，因此，还需要使用<em>.packages</em>参数将它们传递到foreach内部。 还需要通过在文本向量中列出软件包的名称来传输软件包，例如<code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> 。 在上面的<em>代码</em>示例<em>2中</em> ，我们只是以这种方式在<code>foreach</code>每次迭代中加载<strong>ryandexdirect</strong>包。 </p><br><h3 id="paket-doparallel">  DoParallel套餐 </h3><br><p> 正如我在上面所写， <code>doSNOW</code>和<code>doParallel</code>是双胞胎，因此它们具有相同的语法。 </p><br><div class="spoiler">  <b class="spoiler_title">代码5：使用doParallel进行并行计算</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doParallel) logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoParallel(cl) res3 &lt;- data.frame() res3 &lt;- foreach(login=logins, .combine= 'rbind', .inorder=F) %dopar% {cbind(ryandexdirect::yadirGetKeyWords(Login = login), login) stopCluster(cl)</code> </pre> </div></div><br><p>  <strong>工作时间：</strong> <br>  <u>使用者：</u> 0.25 <br>  <u>系统：</u> 0.01 <br>  <u>通过：</u> 173.28 </p><br><p> 如您所见，在这种情况下，执行时间与使用<code>doSNOW</code>包的并行计算代码的上一个示例稍有不同。 </p><br><h2 id="test-skorosti-mezhdu-tremya-rassmotrennymi-podhodami"> 三种方法之间的速度测试 </h2><br><p> 现在，使用<code>rbenchmark</code>软件包运行速度测试。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a63/b9d/2d4/a63b9d2d476203e701c1c789f013793b.png" alt="图片"></p><br><p> 如您所见，即使在4个帐户的测试中， <code>doSNOW</code>和<code>doParallel</code>通过关键字接收数据的速度也比顺序for循环快2倍，如果您创建5个内核的集群并处理50或100个帐户，则差异将更加明显。 </p><br><div class="spoiler">  <b class="spoiler_title">代码6：用于比较多线程和顺序计算速度的脚本</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   library(ryandexdirect) library(foreach) library(doParallel) library(doSNOW) library(rbenchmark) #         for for_fun &lt;- function(logins) { res1 &lt;- data.frame() for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) res1 &lt;- rbind(res1, temp) } return(res1) } #         foreach   doSNOW dosnow_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login } }) stopCluster(cl) return(res2) } #         foreach   doParallel dopar_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoParallel(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login) } }) stopCluster(cl) return(res2) } #          within(benchmark(for_cycle = for_fun(logins = logins), dosnow = dosnow_fun(logins = logins), doparallel = dopar_fun(logins = logins), replications = c(20), columns=c('test', 'replications', 'elapsed'), order=c('elapsed', 'test')), { average = elapsed/replications })</code> </pre></div></div><br><p> 总而言之，我将对上面的<em>代码5</em>进行解释，以此来测试工作速度。 </p><br><p> 最初，我们创建了三个函数： </p><br><p>  <code>for_fun</code>从多个帐户请求关键字的功能， <code>for_fun</code>周期对它们进行顺序排序。 </p><br><p>  <code>dosnow_fun</code>使用<code>doSNOW</code>包以多线程模式请求关键字列表的函数。 </p><br><p>  <code>dopar_fun</code>使用<code>doParallel</code>包以多线程模式请求关键字列表的函数。 </p><br><p> 接下来，在内部构造中，我们从<code>rbenchmark</code>包运行<code>benchmark</code>函数，指定测试的名称（for_cycle，dosnow，doparallel），每个函数分别指定函数： <code>for_fun(logins = logins)</code> ；  <code>dosnow_fun(logins = logins)</code> ;  <code>dopar_fun(logins = logins)</code> 。 </p><br><p>  <em>复制</em>参数负责测试的数量，即 每个函数将运行多少次。 </p><br><p>  <em>columns</em>参数允许您指定要接收的列，在我们的例子中，'test'，'replications'，'elapsed'意味着要返回这些列：测试名称，测试数量，所有测试的总执行时间。 </p><br><p> 您还可以添加计算出的列（（ <code>{ average = elapsed/replications }</code> ），即 输出将是一个平均列，它将用总时间除以测试次数，因此我们计算每个函数的平均执行时间。 </p><br><p>  <em>订单</em>负责对测试结果进行排序。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 在本文中，原则上描述了一种相当通用的方法来加速API的工作，但是每个API都有其局限性，因此，特别是在这种形式下，具有如此多的线程，以上示例适用于Yandex.Direct API，可以与API一起使用对于其他服务，最初需要阅读有关API中同时发送的请求数限制的文档，否则可能会收到“ <code>Too Many Requests</code>错误。 </p><br><p> 本文的续篇在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里提供</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437078/">https://habr.com/ru/post/zh-CN437078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437068/index.html">ILV解锁270万个IP地址</a></li>
<li><a href="../zh-CN437070/index.html">调查数据科学工具2019</a></li>
<li><a href="../zh-CN437072/index.html">哈伯规则中的弱点</a></li>
<li><a href="../zh-CN437074/index.html">Google可能会封锁其在欧洲的新闻服务</a></li>
<li><a href="../zh-CN437076/index.html">霉菌的脱落和恢复</a></li>
<li><a href="../zh-CN437084/index.html">从Uncharted到Obra Dinn：Lucas Pope谈论他在游戏开发中的职业</a></li>
<li><a href="../zh-CN437086/index.html">媒体：黑客入侵了美国证券委员会的数据库，并从内幕交易中获利数百万美元</a></li>
<li><a href="../zh-CN437088/index.html">在国外推广初创企业：如何通过中级受众吸引成千上万的英语读者</a></li>
<li><a href="../zh-CN437092/index.html">机器学习算法的安全性。 Python攻击</a></li>
<li><a href="../zh-CN437094/index.html">我们抽了Atlassian服务台-mitap的公告和现场直播</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>