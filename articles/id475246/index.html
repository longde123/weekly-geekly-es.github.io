<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—ï¸ ğŸ» ğŸŒ´ Pemrograman Asinkron Python: Tinjauan Singkat ğŸ ğŸ¤ ğŸ“¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika berbicara tentang eksekusi program, maka â€œeksekusi asinkronâ€ berarti situasi di mana program tidak menunggu selesainya proses tertentu, tetapi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Asinkron Python: Tinjauan Singkat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/475246/">  Ketika berbicara tentang eksekusi program, maka â€œeksekusi asinkronâ€ berarti situasi di mana program tidak menunggu selesainya proses tertentu, tetapi terus bekerja secara independen.  Contoh pemrograman asinkron adalah utilitas yang, bekerja secara asinkron, menulis ke file log.  Meskipun utilitas seperti itu mungkin gagal (misalnya, karena kurangnya ruang disk kosong), dalam banyak kasus ini akan berfungsi dengan benar dan dapat digunakan dalam berbagai program.  Mereka akan dapat memanggilnya, memberikan data untuk direkam, dan setelah itu mereka dapat terus melakukan hal mereka sendiri. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ep/bw/pt/epbwpti391hcs-adu7jr0hcpqrm.jpeg"></a> <br><br>  Penggunaan mekanisme asinkron saat menulis program tertentu berarti bahwa program ini akan berjalan lebih cepat daripada tanpa menggunakan mekanisme tersebut.  Pada saat yang sama, apa yang direncanakan akan diluncurkan secara tidak serempak, seperti utilitas untuk logging, harus ditulis dengan mempertimbangkan keadaan darurat akun.  Sebagai contoh, sebuah utilitas untuk logging, jika ruang disk habis, cukup berhenti logging, dan tidak "crash" program utama dengan kesalahan. <br><br>  Eksekusi kode asinkron biasanya melibatkan operasi kode tersebut di utas terpisah.  Ini - jika kita berbicara tentang sistem dengan prosesor single-core.  Pada sistem dengan prosesor multi-core, kode tersebut dapat dieksekusi dengan proses menggunakan core terpisah.  Prosesor single-core pada waktu tertentu dapat membaca dan menjalankan hanya satu instruksi.  Ini seperti membaca buku.  Anda tidak dapat membaca dua buku sekaligus. <br><br>  Jika Anda membaca buku dan orang lain memberi Anda buku lain, Anda dapat mengambil buku kedua ini dan mulai membacanya.  Tetapi yang pertama harus ditunda.  Eksekusi kode multi-threaded diatur pada prinsip yang sama.  Dan jika beberapa salinan Anda akan membaca beberapa buku sekaligus, maka itu akan mirip dengan cara kerja sistem multiprosesor. <br><a name="habracut"></a><br>  Jika pada prosesor single-core sangat cepat untuk beralih di antara tugas-tugas yang membutuhkan daya komputasi yang berbeda (misalnya, antara perhitungan tertentu dan membaca data dari disk), maka Anda mungkin merasa bahwa inti prosesor tunggal melakukan beberapa hal pada saat yang sama.  Atau, katakanlah, ini terjadi jika Anda mencoba membuka beberapa situs di browser sekaligus.  Jika browser menggunakan aliran terpisah untuk memuat setiap halaman, maka semuanya akan dilakukan jauh lebih cepat daripada jika halaman-halaman ini memuat satu per satu.  Memuat halaman bukanlah tugas yang sulit, itu tidak menggunakan sumber daya sistem secara maksimal, sebagai akibatnya, peluncuran simultan dari beberapa tugas semacam itu merupakan langkah yang sangat efektif. <br><br><h2>  <font color="#3AC1EF">Pemrograman Asinkron Python</font> </h2><br>  Awalnya, Python menggunakan coroutine berbasis generator untuk menyelesaikan tugas pemrograman asinkron.  Kemudian, dalam Python 3.4, modul <code>asyncio</code> (kadang-kadang namanya ditulis sebagai <code>async IO</code> ), yang mengimplementasikan mekanisme pemrograman asinkron.  Python 3.5 memperkenalkan konstruksi async / wait. <br><br>  Untuk melakukan pengembangan asinkron dalam Python, Anda perlu berurusan dengan beberapa konsep.  Ini adalah coroutine dan tugas. <br><br><h2>  <font color="#3AC1EF">Coroutine</font> </h2><br>  Biasanya, coroutine adalah fungsi async.  Coroutine juga bisa menjadi objek yang dikembalikan dari fungsi coroutine. <br><br>  Jika, ketika mendeklarasikan suatu fungsi, ini mengindikasikan bahwa itu asinkron, maka Anda dapat memanggilnya menggunakan kata kunci <code>await</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>)</code> </pre> <br>  Konstruksi seperti itu berarti bahwa program akan dieksekusi sampai menemukan ekspresi tunggu, setelah itu akan memanggil fungsi dan menghentikan eksekusi sampai pekerjaan fungsi yang disebut selesai.  Setelah itu, coroutine lain juga akan dapat memulai. <br><br>  Menjeda program berarti kontrol kembali ke loop acara.  Saat menggunakan modul <code>asyncio</code> , loop acara melakukan semua tugas asinkron, melakukan I / O, dan melakukan subproses.  Dalam kebanyakan kasus, tugas digunakan untuk menjalankan corutin. <br><br><h2>  <font color="#3AC1EF">Tugasnya</font> </h2><br>  Tugas memungkinkan Anda untuk menjalankan coroutine dalam satu event loop.  Ini menyederhanakan kontrol eksekusi dari beberapa coroutine.  Berikut adalah contoh yang menggunakan coroutine dan tugas.  Perhatikan bahwa entitas yang dideklarasikan menggunakan <code>async def</code> construct adalah coroutine.  Contoh ini diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resmi</a> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">say_after</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delay, what)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(delay)    print(what) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    task1 = asyncio.create_task(        say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>))    task2 = asyncio.create_task(        say_after(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>))    print(<span class="hljs-string"><span class="hljs-string">f"started at </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{time.strftime(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'%X'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">"</span></span>)    <span class="hljs-comment"><span class="hljs-comment">#     (      #  2 .)    await task1    await task2    print(f"finished at {time.strftime('%X')}") asyncio.run(main())</span></span></code> </pre> <br>  Fungsi <code>say_after()</code> memiliki awalan <code>async</code> ; sebagai hasilnya, kami memiliki coroutine.  Jika kita menyimpang sedikit dari contoh ini, kita dapat mengatakan bahwa fungsi ini dapat disebut seperti ini: <br><br><pre> <code class="python hljs">    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>)</code> </pre> <br>  Dengan pendekatan ini, bagaimanapun, coroutine dipanggil secara berurutan dan membutuhkan waktu sekitar 3 detik untuk menyelesaikannya.  Dalam contoh kami, mereka diluncurkan secara kompetitif.  Untuk masing-masing dari mereka tugas digunakan.  Akibatnya, waktu eksekusi seluruh program adalah sekitar 2 detik.  Harap perhatikan bahwa agar program seperti itu berfungsi, tidak cukup hanya mendeklarasikan fungsi <code>main()</code> dengan <code>async</code> .  Dalam situasi seperti itu, Anda perlu menggunakan modul <code>asyncio</code> . <br><br>  Jika Anda menjalankan kode contoh, teks yang mirip dengan yang berikut ini akan ditampilkan di layar: <br><br><pre> <code class="python hljs">started at <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">39</span></span> hello world finished at <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span></code> </pre> <br>  Perhatikan bahwa cap waktu pada baris pertama dan terakhir berbeda 2 detik.  Jika Anda menjalankan contoh ini dengan panggilan berurutan corutin, maka perbedaan antara cap waktu sudah 3 detik. <br><br><h2>  <font color="#3AC1EF">Contoh</font> </h2><br>  Dalam contoh ini, jumlah operasi yang diperlukan untuk menghitung jumlah sepuluh elemen dari urutan angka ditentukan.  Perhitungan dilakukan mulai dari akhir urutan.  Fungsi rekursif dimulai dengan mendapatkan angka 10, lalu menyebut dirinya dengan angka 9 dan 8, menjumlahkan apa yang akan dikembalikan.  Ini berlanjut sampai perhitungan selesai.  Sebagai hasilnya, ternyata, misalnya, bahwa jumlah urutan angka dari 1 hingga 10 adalah 55. Pada saat yang sama, fungsi kami sangat tidak efisien, konstruksi <code>time.sleep(0.1)</code> digunakan di sini. <br><br>  Berikut adalah kode fungsinya: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count    count=count+<span class="hljs-number"><span class="hljs-number">1</span></span>    time.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) + fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n start=time.time() <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count count = <span class="hljs-number"><span class="hljs-number">0</span></span> result = fib(<span class="hljs-number"><span class="hljs-number">10</span></span>) print(result,count) print(time.time()-start)</code> </pre> <br>  Apa yang terjadi jika Anda menulis ulang kode ini menggunakan mekanisme asinkron dan menerapkan konstruk <code>asyncio.gather</code> , yang bertanggung jawab untuk melakukan dua tugas dan menunggu untuk menyelesaikannya? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio,time <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count    count=count+<span class="hljs-number"><span class="hljs-number">1</span></span>    time.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)    event_loop = asyncio.get_event_loop()    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>:        task1 = asyncio.create_task(fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>))        task2 = asyncio.create_task(fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.gather(task1,task2)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task1.result()+task2.result()    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n</code> </pre> <br>  Bahkan, contoh ini bekerja bahkan sedikit lebih lambat daripada yang sebelumnya, karena semuanya dieksekusi dalam satu utas, dan panggilan ke <code>create_task</code> , <code>gather</code> dan yang lainnya seperti itu membuat beban tambahan pada sistem.  Namun, tujuan dari contoh ini adalah untuk menunjukkan kemampuan untuk bersaing dalam banyak tugas dan untuk menunggu mereka selesai. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Ada situasi di mana penggunaan tugas dan corutin sangat berguna, misalnya, jika suatu program berisi campuran input-output dan perhitungan, atau jika perhitungan yang berbeda dilakukan dalam program yang sama, Anda dapat memecahkan masalah ini dengan menjalankan kode dalam kompetitif daripada dalam mode berurutan.  Ini membantu mengurangi waktu yang diperlukan bagi program untuk melakukan tindakan tertentu.  Namun, ini tidak memungkinkan, misalnya, untuk melakukan perhitungan secara bersamaan.  Multiprocessing digunakan untuk mengatur perhitungan seperti itu.  Ini adalah topik besar yang terpisah. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda menulis kode Python asinkron? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475246/">https://habr.com/ru/post/id475246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475236/index.html">Jangan pernah mengabaikan pelatihan penguatan lagi.</a></li>
<li><a href="../id475238/index.html">Timeline Blade Runner - November 2019. Apakah ramalan itu menjadi kenyataan?</a></li>
<li><a href="../id475240/index.html">Menggunakan modul ketat dalam proyek Python skala besar: pengalaman Instagram. Bagian 1</a></li>
<li><a href="../id475242/index.html">Menggunakan modul ketat dalam proyek Python skala besar: pengalaman Instagram. Bagian 2</a></li>
<li><a href="../id475244/index.html">Fitur JavaScript Baru yang Diharapkan Harus Anda Ketahui</a></li>
<li><a href="../id475248/index.html">Penggunaan polyfill saat menulis aplikasi lintas-browser</a></li>
<li><a href="../id475250/index.html">Sebagai Redash memperhatikan dan memperbaiki masalah yang menyebabkan penurunan kinerja kode Python</a></li>
<li><a href="../id475252/index.html">Cara mengkritik Microsoft</a></li>
<li><a href="../id475254/index.html">AERODISK vAIR arsitektur atau fitur bangunan cluster nasional</a></li>
<li><a href="../id475258/index.html">Representasi visual dari pemilihan di St. Petersburg - keajaiban pembungkus suara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>