<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•¶ï¸ ğŸ’½ ğŸ˜¤ Secara singkat tentang bekerja dengan RabbitMQ dari Python ğŸ¤® ğŸ¡ ğŸ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kebetulan bahwa dalam proses bekerja di MegaFon, seseorang harus menghadapi tugas yang sama ketika bekerja dengan RabbitMQ. Pertanyaan yang wajar munc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Secara singkat tentang bekerja dengan RabbitMQ dari Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434510/"><p><img src="https://habrastorage.org/webt/wj/xp/kf/wjxpkfeg45pxv_pbpaiyykpj9jg.png" alt="KDPV"></p><br><p>  Kebetulan bahwa dalam proses bekerja di MegaFon, seseorang harus menghadapi tugas yang sama ketika bekerja dengan RabbitMQ.  Pertanyaan yang wajar muncul: "Bagaimana menyederhanakan dan mengotomatiskan pelaksanaan tugas-tugas seperti itu?" </p><br><p>  Solusi pertama yang muncul dalam pikiran adalah dengan menggunakan antarmuka HTTP, dan, tentu saja, di luar kotak, RabbitMQ memiliki antarmuka web yang baik dan HTTP API.  Namun demikian, penggunaan HTTP API tidak selalu nyaman, dan kadang-kadang bahkan tidak mungkin (katakanlah Anda tidak memiliki hak akses yang cukup, tetapi saya benar-benar ingin menerbitkan pesan) pada saat-saat seperti itu, menjadi perlu untuk bekerja menggunakan protokol AMQP </p><br><p>  Tidak menemukan solusi siap pakai yang cocok untuk saya di ruang terbuka jaringan, diputuskan untuk menulis aplikasi kecil untuk bekerja dengan RabbitMQ menggunakan protokol AMQP <a name="habracut"></a>  dengan kemampuan untuk mentransfer parameter startup melalui baris perintah dan menyediakan set fitur minimum yang diperlukan, yaitu: </p><br><ul><li>  Posting </li><li>  Mengoreksi Pesan </li><li>  Membuat dan mengedit elemen rute dasar </li></ul><br><p>  Python dipilih sebagai alat paling sederhana (dan menurut saya indah) untuk mengimplementasikan tugas semacam itu.  (Orang dapat berdebat di sini, tetapi apa yang akan berubah?) </p><br><p>  Terjemahan panduan resmi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> ) oleh RabbitMQ disajikan di hub, namun, kadang-kadang contoh sederhana dari praktik berguna.  Dalam artikel tersebut, saya akan mencoba mengilustrasikan masalah utama yang muncul ketika bekerja dengan kelinci menggunakan saluran AMQP dari Python menggunakan contoh aplikasi kecil.  Aplikasi itu sendiri tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </p><br><h4 id="korotko-o-protokole-amqp-i-brokere-soobscheniy-rabbitmq">  Secara singkat tentang protokol AMQP dan broker pesan RabbitMQ </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>AMQP</strong></a> adalah salah satu protokol perpesanan yang paling umum di antara komponen-komponen sistem terdistribusi.  Fitur pembeda utama dari protokol ini adalah konsep membangun rute pesan, yang mengandung dua elemen struktural utama: <strong>antrian</strong> dan <strong>titik pertukaran</strong> .  Antrian mengakumulasikan pesan sampai diterima.  Titik pertukaran adalah distributor pesan yang mengarahkan mereka ke antrian yang diinginkan atau ke titik pertukaran lain.  <strong>Aturan distribusi (binding)</strong> , dimana titik pertukaran menentukan tempat untuk mengarahkan pesan, didasarkan pada memeriksa <strong>kunci perutean pesan</strong> untuk kepatuhan dengan mask yang ditentukan.  Anda dapat membaca lebih lanjut tentang cara kerja AMQP di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>RabbitMQ</strong></a> adalah aplikasi open source yang sepenuhnya mendukung AMQP dan menawarkan sejumlah fitur tambahan.  Untuk bekerja dengan RabbitMQ, sejumlah besar perpustakaan telah ditulis dalam berbagai bahasa pemrograman, termasuk Python. </p><br><h2 id="realizaciya-na-python">  Implementasi python </h2><br><p>  Anda selalu dapat melempar beberapa skrip untuk penggunaan pribadi dan tidak tahu masalahnya.  Ketika harus menyebar mereka di antara rekan kerja, semuanya menjadi lebih rumit.  Semua orang perlu menunjukkan dan memberi tahu bagaimana dan apa yang harus diluncurkan, apa dan di mana harus berubah, di mana untuk mendapatkan versi terbaru, dan apa yang telah berubah di dalamnya ... Secara tidak sadar Anda sampai pada kesimpulan bahwa lebih mudah untuk membuat antarmuka yang sederhana sekali, sehingga Anda tidak membuang waktu di masa depan.  Untuk kemudahan penggunaan, diputuskan untuk membagi aplikasi menjadi 4 modul: </p><br><ol><li>  Modul yang bertanggung jawab untuk posting </li><li>  Modul yang bertanggung jawab untuk mengurangi pesan dari antrian </li><li>  Modul yang dirancang untuk membuat perubahan pada konfigurasi broker RabbitMQ </li><li>  Modul yang berisi parameter dan metode yang umum untuk modul sebelumnya </li></ol><br><p>  Pendekatan ini menyederhanakan set parameter startup.  Kami memilih modul yang diperlukan, memilih salah satu mode operasinya dan melewati parameter yang diperlukan (untuk informasi lebih lanjut tentang mode operasi dan parameter dalam bantuan â€“bantu). </p><br><p>  Karena struktur "kelinci" di MegaFon terdiri dari sejumlah besar node, untuk kenyamanan penggunaan, data untuk menghubungkan ke node ditransfer ke modul dengan parameter umum dan metode <strong>rmq_common_tools.py</strong> </p><br><p>  Untuk bekerja di AMQP dengan Python, kita akan menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pika</a> . </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pika</code> </pre> <br><p>  Menggunakan perpustakaan ini, bekerja dengan RabbitMQ akan terdiri dari tiga tahap utama: </p><br><ol><li>  Buat koneksi </li><li>  Melakukan Operasi yang Diperlukan </li><li>  Tutup koneksi </li></ol><br><p>  Tahap pertama dan terakhir adalah sama untuk semua modul dan diimplementasikan di <strong>rmq_common_tools.py</strong> </p><br><p>  Untuk membuat koneksi: </p><br><pre> <code class="python hljs">rmq_parameters = pika.URLParameters(rmq_url_connection_str) rmq_connection = pika.BlockingConnection(rmq_parameters) rmq_channel = rmq_connection.channel()</code> </pre> <br><p>  Perpustakaan Pika memungkinkan Anda untuk menggunakan berbagai opsi desain untuk menghubungkan ke RabbitMQ.  Dalam hal ini, opsi paling mudah adalah dengan melewatkan parameter dalam bentuk string URL dalam format berikut: </p><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">'amqp://rabbit_user:rabbit_password@host:port/vhost'</span></span></code> </pre> <br><p>  Untuk menutup koneksi: </p><br><pre> <code class="python hljs">rmq_connection.close()</code> </pre> <br><h4 id="publikaciya-soobscheniy">  Posting </h4><br><p>  Menerbitkan pesan mungkin adalah yang termudah, tetapi pada saat yang sama operasi yang paling populer saat bekerja dengan kelinci. </p><br><p>  Alat penerbitan pos dikompilasi di <strong>rmq_publish.py</strong> </p><br><p>  Untuk mengirim pesan, gunakan metode ini </p><br><pre> <code class="python hljs">rmq_channel.basic_publish(exchange = params.exch, routing_key = params.r_key, body = text)</code> </pre> <br><p>  dimana: <br>  <strong>exchange</strong> - nama dari titik pertukaran dimana pesan akan dipublikasikan <br>  <strong>routing_key</strong> - kunci perutean dengan mana pesan akan dipublikasikan <br>  <strong>isi</strong> - isi pesan </p><br><p>  <strong>rmq_publish.py</strong> mendukung dua mode input pesan untuk penerbitan: </p><br><ol><li>  Pesan dimasukkan sebagai parameter melalui baris perintah (from_console) </li><li>  Pesan dibaca dari file (from_file) </li></ol><br><p>  Mode kedua, menurut saya, lebih nyaman ketika bekerja dengan pesan besar atau array pesan.  Yang pertama, pada gilirannya, memungkinkan Anda untuk mengirim pesan tanpa file tambahan, yang nyaman saat mengintegrasikan modul ke dalam skenario lain. </p><br><h4 id="poluchenie-soobscheniy">  Menerima Pesan </h4><br><p>  Masalah menerima pesan tidak lagi sepele seperti penerbitan.  Ketika berbicara tentang membaca pesan, Anda perlu memahami: </p><br><ul><li>  Setelah mengkonfirmasi penerimaan pesan, pesan akan dihapus dari antrian.  Jadi, membaca pesan dari baris "pertempuran", kami "memilih" mereka dari konsumen utama.  Jika kita tidak ingin kehilangan aliran pesan, tetapi hanya ingin memahami pesan apa yang bergerak di "kelinci", maka opsi yang paling logis adalah membuat antrian "logging" yang terpisah, atau seperti juga disebut, "trap queue". </li><li>  Membaca pesan, sebagai suatu peraturan, memerlukan pemrosesan atau analisis lebih lanjut, yang berarti mereka perlu disimpan di suatu tempat jika pemrosesan waktu nyata tidak mungkin atau tidak diperlukan. </li></ul><br><p>  Pembaca pesan diimplementasikan dalam file <strong>rmq_consume.py</strong> </p><br><p>  Dua mode operasi disediakan: </p><br><ol><li>  Baca pesan dari antrian yang ada </li><li>  Membuat antrian waktu dan rute untuk membaca pesan dari antrian ini </li></ol><br><p>  Pertanyaan membuat antrian dan rute akan dipertimbangkan di bawah ini. </p><br><p>  Proofreading langsung diimplementasikan sebagai berikut: </p><br><pre> <code class="python hljs">channel.basic_consume(on_message, queue=params.queue) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: channel.start_consuming() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: channel.stop_consuming() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception: channel.stop_consuming() rmq_tools.console_log(<span class="hljs-string"><span class="hljs-string">":\n"</span></span>, traceback.format_exc())</code> </pre> <br><p>  dimana <br>  <strong>on_message</strong> - prosedur penanganan pesan <br>  <strong>params.queue</strong> - nama antrian dari mana <strong>pengurangan</strong> akan dilakukan </p><br><p>  Penangan pesan harus melakukan beberapa operasi pada pesan yang sudah dibaca dan mengkonfirmasi (atau tidak mengkonfirmasi, jika perlu) pengiriman pesan. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel, method_frame, header_frame, body)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> all_cnt, lim <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> all_cnt &gt;= lim: rmq_tools.console_log(<span class="hljs-string"><span class="hljs-string">'   .'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyboardInterrupt body_str = body.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)[:<span class="hljs-number"><span class="hljs-number">4000</span></span>] rk = method_frame.routing_key rmq_params.file.write(rk + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) rmq_params.file.write(body_str + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>) all_cnt = all_cnt + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lim != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (rmq_params.file == sys.stdout): sys.stdout.write(<span class="hljs-string"><span class="hljs-string">f'[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rmq_tools.time_now()}</span></span></span><span class="hljs-string">] - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{all_cnt}</span></span></span><span class="hljs-string"> of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{lim}</span></span></span><span class="hljs-string"> messages consumed.\r'</span></span>) channel.basic_ack(delivery_tag=method_frame.delivery_tag)</code> </pre> <br><p>  dimana <br>  <strong>all_cnt</strong> - penghitung global <br>  <strong>lim</strong> - jumlah pesan yang akan dibaca </p><br><p>  Dalam implementasi handler seperti itu, sejumlah pesan dikurangkan dan informasi tentang perkembangan pengurangan tersebut dikeluarkan ke konsol jika perekaman terjadi dalam file. </p><br><p>  Dimungkinkan juga untuk menulis pesan yang sudah dibaca ke dalam basis data.  Dalam implementasi saat ini, peluang seperti itu tidak disajikan, tetapi tidak sulit untuk ditambahkan. </p><br><div class="spoiler">  <b class="spoiler_title">Rekam dalam DB</b> <div class="spoiler_text"><p>  Kami akan mempertimbangkan contoh penulisan pesan ke database untuk database Oracle dan pustaka <strong>cx_oracle</strong> . </p><br><p>  Hubungkan ke database </p><br><pre> <code class="python hljs">ora_adress = <span class="hljs-string"><span class="hljs-string">'host:port/dbSID'</span></span> ora_creds = <span class="hljs-string"><span class="hljs-string">'user/pass'</span></span> connection_ora = cx_Oracle.connect(ora_creds + <span class="hljs-string"><span class="hljs-string">'@'</span></span> + ora_address) ora_cursor = connection_ora.cursor()</code> </pre> <br><p>  Di <strong>add</strong> handler <strong>on_message</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">global</span></span> cnt, commit_int insert_rec = <span class="hljs-string"><span class="hljs-string">'insert into '</span></span> + tab_name + <span class="hljs-string"><span class="hljs-string">'(routing_key, text) values (:rkey, :text)'</span></span> ora_cursor.execute(insert_rec, text = body_str, rkey = rk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cnt &gt; commit_int : ora_cursor.execute(<span class="hljs-string"><span class="hljs-string">'commit'</span></span>) cnt = <span class="hljs-number"><span class="hljs-number">1</span></span> cnt = cnt + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  dimana <br>  <strong>cnt</strong> adalah penghitung lain <br>  <strong>commit_int</strong> - jumlah penyisipan ke dalam basis data, setelah itu perlu untuk melakukan "komit".  Kehadiran parameter seperti itu disebabkan oleh keinginan untuk mengurangi beban pada basis data.  Namun, menginstalnya tidak terlalu besar, karena  jika terjadi kegagalan, ada kemungkinan kehilangan pesan yang dibaca setelah komit berhasil terakhir. </p><br><p>  Dan, seperti yang diharapkan, pada akhir pekerjaan kami membuat komitmen akhir dan menutup koneksi </p><br><pre> <code class="python hljs">ora_cursor.execute(<span class="hljs-string"><span class="hljs-string">'commit'</span></span>) connection_ora.close()</code> </pre> <br><p>  Sesuatu seperti ini sedang membaca pesan.  Jika Anda menghapus batasan pada jumlah pesan yang dibaca, Anda dapat membuat proses latar belakang untuk membaca pesan yang terus-menerus dari "kelinci". </p></div></div><br><h4 id="konfigurirovanie">  Konfigurasi </h4><br><p>  Terlepas dari kenyataan bahwa protokol AMQP terutama ditujukan untuk menerbitkan dan membaca pesan, protokol ini juga memungkinkan Anda untuk melakukan manipulasi sederhana dengan konfigurasi rute (kami tidak berbicara tentang mengonfigurasi koneksi jaringan dan pengaturan RabbitMQ lainnya sebagai aplikasi). </p><br><p>  Operasi konfigurasi utama adalah: </p><br><ol><li>  Membuat antrian atau titik pertukaran </li><li>  Membuat Aturan Penerusan (mengikat) </li><li>  Menghapus antrian atau titik pertukaran </li><li>  Menghapus Aturan Penerusan (mengikat) </li><li>  Kliring antrian </li></ol><br><p>  Karena untuk masing-masing dari mereka ada prosedur yang sudah jadi di perpustakaan pika, untuk kemudahan peluncuran, mereka hanya dikompilasi dalam file <strong>rmq_setup.py</strong> .  Selanjutnya, kami membuat daftar prosedur dari pika library dengan beberapa komentar tentang parameter. </p><br><p>  <strong>Membuat antrian</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_declare(queue=params.queue, durable = params.durable)</code> </pre> <br><p>  semuanya sederhana di sini <br>  <strong>antrian</strong> - nama antrian yang akan dibuat <br>  <strong>tahan lama</strong> - parameter logis, nilai True akan berarti bahwa ketika kelinci reboot, antrian akan terus ada.  Jika Salah, antrian akan dihapus setelah reboot.  Opsi kedua biasanya digunakan untuk antrian sementara yang dijamin tidak diperlukan di masa depan. </p><br><p>  <strong>Membuat titik pertukaran (exchange)</strong> </p><br><pre> <code class="python hljs">rmq_channel.exchange_declare(exchange=params.exch, exchange_type = params.type, durable = params.durable)</code> </pre> <br><p>  di sini muncul parameter baru <strong>exchange_type</strong> - jenis titik pertukaran.  Tentang jenis titik pertukaran apa yang dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  <strong>exchange</strong> - nama dari titik pertukaran yang dibuat </p><br><p>  <strong>Menghapus antrian atau titik pertukaran</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_delete(queue=params.queue) rmq_channel.exchange_delete(exchange=params.exch)</code> </pre> <br><p>  <strong>Membuat Aturan Penerusan (mengikat)</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_bind(exchange=params.exch, queue=params.queue, routing_key=params.r_key)</code> </pre> <br><p>  <strong>exchange</strong> - nama titik pertukaran dari mana transfer akan dilakukan <br>  <strong>queue</strong> - nama antrian yang akan diteruskan <br>  <strong>routing_key</strong> - mask dari kunci routing, yang akan digunakan untuk penerusan. </p><br><p>  Entri berikut ini valid: </p><br><ul><li>  <strong>rk.my_key. *</strong> - dalam topeng ini, tanda bintang berarti set karakter yang tidak kosong.  Dengan kata lain, topeng seperti itu akan melewatkan kunci apa pun dari jenis <strong>rk.my_key.</strong>  + sesuatu yang lain, tetapi tidak akan melewatkan kunci <strong>rk.my_key</strong> </li><li>  <strong>rk.my_key. #</strong> - topeng ini akan melewati segalanya seperti + kunci <strong>rk.my_key</strong> sebelumnya </li></ul><br><p>  <strong>Menghapus Aturan Penerusan (mengikat)</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_unbind(exchange=params.exch, queue=params.queue, routing_key=params.r_key)</code> </pre> <br><p>  semuanya mirip dengan membuat aturan penerusan. </p><br><p>  <strong>Kliring antrian</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_purge(queue=params.queue)</code> </pre> <br><p>  <strong>queue</strong> - nama antrian yang akan dihapus </p><br><div class="spoiler">  <b class="spoiler_title">Tentang menggunakan antarmuka baris perintah di aplikasi Python</b> <div class="spoiler_text"><p>  Opsi startup membuat hidup jauh lebih mudah.  Agar tidak mengedit kode sebelum setiap peluncuran, adalah logis untuk menyediakan mekanisme untuk melewatkan parameter saat startup.  Perpustakaan <strong>argparse</strong> dipilih untuk <strong>tujuan</strong> ini.  Saya tidak akan merinci seluk-beluk penggunaannya, ada cukup panduan tentang hal ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga</a> ).  Saya hanya mencatat bahwa alat ini sangat membantu saya menyederhanakan proses menggunakan aplikasi (jika Anda bisa menyebutnya begitu).  Bahkan setelah melemparkan urutan perintah sederhana dan membungkusnya dalam antarmuka yang sama, Anda bisa mendapatkan alat yang lengkap dan mudah digunakan. </p></div></div><br><h2 id="primenenie-v-povsednevnoy-zhizni-chto-prigodilos-bolshe-vsego">  Aplikasi dalam kehidupan sehari-hari.  Apa yang paling berguna. </h2><br><p>  Nah, sekarang sedikit kesan tentang penggunaan AMQP dalam kehidupan sehari-hari. </p><br><p>  Fitur yang paling banyak diminta adalah publikasi pesan.  Hak akses pengguna tertentu tidak selalu memungkinkan penggunaan antarmuka web, meskipun terkadang hanya perlu untuk menguji layanan tertentu.  Di sini AMQP dan otorisasi atas nama layanan menggunakan saluran ini untuk bantuan. </p><br><p>  Yang paling populer kedua adalah kemampuan membaca pesan dari antrian waktu.  Fitur ini berguna untuk mengonfigurasi rute baru dan aliran pesan, serta mencegah kecelakaan. </p><br><p>  Kemungkinan lain juga ditemukan aplikasi dalam berbagai tugas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434510/">https://habr.com/ru/post/id434510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434500/index.html">Penipu bernama Jeanne atau Watch Your Ears</a></li>
<li><a href="../id434502/index.html">Bagaimana "Arkeolog Digital" Menemukan Versi Hilang dari SimCity untuk NES dan Memulihkannya</a></li>
<li><a href="../id434504/index.html">20 tahun Fast Reports â€œProduk ini dibuat dalam satu nafas, cukup tinggi ...â€</a></li>
<li><a href="../id434506/index.html">Pengalaman menerbitkan aplikasi pengeditan video di Microsoft Store</a></li>
<li><a href="../id434508/index.html">Sisi Gelap Pemasaran Mesin Pencari: Bagaimana dan Mengapa Google Mengumpulkan Informasi Pribadi Kami</a></li>
<li><a href="../id434512/index.html">Corporate perusahaan</a></li>
<li><a href="../id434514/index.html">"Rahasia" DPAPI atau DPAPI untuk Pentester</a></li>
<li><a href="../id434516/index.html">Cara mudah untuk menangani aspirasi karier Anda.</a></li>
<li><a href="../id434518/index.html">Tepuk tangan dan tepuk tangan: drama yang dikendalikan dengan cermat di toko-toko Apple</a></li>
<li><a href="../id434522/index.html">Pola justifikasi tugas dan antipatterns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>