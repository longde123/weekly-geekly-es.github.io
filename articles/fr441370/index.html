<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàöÔ∏è üë®üèº‚Äçüéì üë®‚Äçüè≠ Protection sans peur. S√©curit√© du fil dans la rouille üìπ üö∂ üåù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxi√®me partie de la s√©rie d'articles Fearless Protection. Dans le premier, nous avons parl√© de la s√©curit√© de la m√©moire 

 Les appl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protection sans peur. S√©curit√© du fil dans la rouille</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441370/">  <font color="gray"><i>Il s'agit de la deuxi√®me partie de la s√©rie d'articles Fearless Protection.</i></font>  <font color="gray"><i>Dans le premier, nous avons parl√© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la s√©curit√© de la m√©moire</a></i></font> <br><br>  Les applications modernes sont multithreads: au lieu d'ex√©cuter des t√¢ches s√©quentiellement, le programme utilise des threads pour effectuer simultan√©ment plusieurs t√¢ches.  Nous observons tous <i>un travail simultan√©</i> et <i>simultan√©</i> tous les jours: <br><br><ul><li>  Les sites Web sont servis par plusieurs utilisateurs en m√™me temps. <br></li><li> L'interface utilisateur effectue un travail d'arri√®re-plan qui ne d√©range pas l'utilisateur (imaginez que chaque fois que vous tapez un caract√®re, l'application se fige pour v√©rifier l'orthographe). <br></li><li>  Un ordinateur peut ex√©cuter plusieurs applications en m√™me temps. </li></ul><br>  Les flux parall√®les acc√©l√®rent le travail, mais introduisent un ensemble de probl√®mes de synchronisation, √† savoir les blocages et les conditions de concurrence.  Du point de vue de la s√©curit√©, pourquoi nous soucions-nous de la s√©curit√© des threads?  Parce que la s√©curit√© de la m√©moire et des threads a un seul et m√™me probl√®me principal: une utilisation inappropri√©e des ressources.  Les attaques ici ont les m√™mes effets que les attaques de m√©moire, y compris l'escalade de privil√®ges, l'ex√©cution de code arbitraire (ACE) et le contournement des contr√¥les de s√©curit√©. <br><a name="habracut"></a><br>  Les erreurs de concurrence, comme les erreurs d'impl√©mentation, sont √©troitement li√©es √† l'exactitude du programme.  Bien que les vuln√©rabilit√©s de m√©moire soient presque toujours dangereuses, les erreurs d'impl√©mentation / logique n'indiquent pas toujours un probl√®me de s√©curit√© si elles ne se produisent pas dans la partie du code li√©e √† la conformit√© aux contrats de s√©curit√© (par exemple, autorisation de contourner un contr√¥le de s√©curit√©).  Mais les bugs de concurrence ont une particularit√©.  Si des probl√®mes de s√©curit√© dus √† des erreurs logiques apparaissent souvent √† c√¥t√© du code correspondant, des erreurs de concurrence se produisent souvent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans d'autres fonctions, et non dans celle o√π l'erreur a √©t√© directement caus√©e</a> , ce qui rend difficile leur suivi et leur √©limination.  Une autre difficult√© est un certain chevauchement entre un traitement de m√©moire incorrect et des erreurs de concurrence, que nous constatons dans les courses de donn√©es. <br><br>  Les langages de programmation ont d√©velopp√© diverses strat√©gies de concurrence pour aider les d√©veloppeurs √† g√©rer les probl√®mes de performances et de s√©curit√© des applications multi-thread. <br><br><h1>  Probl√®mes de concurrence </h1><br>  Il est g√©n√©ralement admis que la programmation parall√®le est plus difficile que d'habitude: notre cerveau est mieux adapt√© au raisonnement s√©quentiel.  Le code parall√®le peut avoir des interactions inattendues et ind√©sirables entre les threads, y compris les blocages, les conflits et les courses de donn√©es. <br><br>  <i>Un blocage</i> se produit lorsque plusieurs threads s'attendent √† ce que l'autre ex√©cute certaines actions pour continuer √† fonctionner.  Bien que ce comportement ind√©sirable puisse provoquer une attaque par d√©ni de service, il ne provoquera pas de vuln√©rabilit√©s telles que ACE. <br><br>  <i>Une condition de concurrence</i> est une situation dans laquelle le temps ou l'ordre des t√¢ches peut affecter l'exactitude d'un programme.  La course aux donn√©es se produit lorsque plusieurs flux essaient d'acc√©der simultan√©ment au m√™me emplacement m√©moire avec au moins une tentative d'√©criture.  Il arrive qu'une condition de concurrence critique et une course de donn√©es se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">produisent ind√©pendamment l'une de</a> l'autre.  Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les courses de donn√©es sont toujours dangereuses</a> . <br><br><h3>  Cons√©quences potentielles des erreurs de concurrence </h3><br><ol><li>  Impasse <br></li><li>  Perte d'informations: un autre thread √©crase les informations <br></li><li>  Perte d'int√©grit√©: les informations de plusieurs flux sont entrelac√©es <br></li><li>  Perte de viabilit√©: probl√®mes de performances dus √† un acc√®s in√©gal aux ressources partag√©es </li></ol><br>  Le type d'attaque simultan√©e le plus connu est appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TOCTOU</a> (heure de v√©rification √† l'heure d'utilisation): en substance, l'√©tat d'une course se situe entre la v√©rification des conditions (par exemple, les informations d'identification de s√©curit√©) et l'utilisation des r√©sultats.  Une attaque TOCTOU entra√Æne une perte d'int√©grit√©. <br><br>  Les verrous mutuels et la perte de survie sont consid√©r√©s comme des probl√®mes de performances, et non comme des probl√®mes de s√©curit√©, tandis que la perte d'informations et la perte d'int√©grit√© sont probablement li√©es √† la s√©curit√©.  Un article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Red Balloon Security</a> examine certains des exploits possibles.  Un exemple est une corruption de pointeur suivie d'une escalade de privil√®ges ou d'une ex√©cution de code √† distance.  Dans l'exploit, une fonction qui charge la biblioth√®que partag√©e ELF (Executable and Linkable Format) n'initie correctement un s√©maphore que lors du premier appel, puis limite incorrectement le nombre de threads, ce qui provoque une corruption de la m√©moire du noyau.  Cette attaque est un exemple de perte d'informations. <br><br>  La partie la plus difficile de la programmation simultan√©e est le test et le d√©bogage, car les erreurs de concurrence sont difficiles √† reproduire.  Timing des √©v√©nements, d√©cisions du syst√®me d'exploitation, trafic r√©seau et autres facteurs ... tout cela change le comportement du programme √† chaque d√©marrage. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa1/702/1b2/aa17021b2f9cb3eb726ea37995ed4e2e.png"></a> </div><br>  <i><font color="gray">Parfois, il est vraiment plus facile de supprimer tout le programme que de rechercher un bogue.</font></i>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heisenbugs</a></font></i> <br><br>  Non seulement le comportement change √† chaque d√©marrage, mais m√™me l'insertion d'op√©rateurs de sortie ou de d√©bogage peut changer le comportement, ce qui entra√Æne des ¬´bugs Heisenberg¬ª (erreurs non d√©terministes, difficiles √† reproduire, typiques de la programmation parall√®le) qui surviennent et disparaissent myst√©rieusement. <br><br>  La programmation parall√®le est difficile.  Il est difficile de pr√©dire comment le code parall√®le va interagir avec un autre code parall√®le.  Lorsque des erreurs apparaissent, elles sont difficiles √† trouver et √† corriger.  Au lieu de compter sur des testeurs, examinons les moyens de d√©velopper des programmes et l'utilisation de langages qui facilitent l'√©criture de code parall√®le. <br><br>  Tout d'abord, nous formulons le concept de ¬´s√©curit√© des threads¬ª: <br><br><blockquote>  "Un type de donn√©es ou une m√©thode statique est consid√©r√© comme s√ªr pour les threads s'il se comporte correctement lorsqu'il est appel√© √† partir de plusieurs threads, quelle que soit la fa√ßon dont ces threads sont ex√©cut√©s, et ne n√©cessite pas de coordination suppl√©mentaire √† partir du code appelant."  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MIT</a> </blockquote><br><h1>  Comment les langages de programmation fonctionnent avec le parall√©lisme </h1><br>  Dans les langues sans s√©curit√© de thread statique, les programmeurs doivent surveiller en permanence la m√©moire partag√©e avec un autre thread et pouvant changer √† tout moment.  En programmation s√©quentielle, on nous apprend √† √©viter les variables globales si une autre partie du code les modifie discr√®tement.  Il est impossible d'exiger des programmeurs qu'ils garantissent une modification s√ªre des donn√©es partag√©es, ainsi qu'une gestion manuelle de la m√©moire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/3e3/5d2/e3e3e35d2775715a1f337d7c58aad7f7.gif"></div><br>  <i><font color="gray">"Vigilance constante!"</font></i> <br><br>  En r√®gle g√©n√©rale, les langages de programmation sont limit√©s √† deux approches: <br><br><ol><li>  Limitation de la mutabilit√© ou restriction de l'acc√®s partag√© <br></li><li>  S√©curit√© du filetage manuel (p. Ex. Verrous, s√©maphores) </li></ol><br>  Les langues avec restriction de threads imposent une limite de 1 thread pour les variables mutables ou n√©cessitent que toutes les variables communes soient immuables.  Les deux approches abordent le probl√®me fondamental de la course aux donn√©es - modification incorrecte des donn√©es partag√©es - mais les restrictions sont trop s√©v√®res.  Pour r√©soudre le probl√®me, les langages ont cr√©√© des primitives de synchronisation de bas niveau, telles que les mutex.  Ils peuvent √™tre utilis√©s pour cr√©er des structures de donn√©es thread-safe. <br><br><h3>  Python et verrouillage global par interpr√®te </h3><br>  L'impl√©mentation de r√©f√©rence en Python et Cpython a une sorte de mutex appel√© Global Interpreter Lock (GIL), qui bloque tous les autres threads lorsqu'un thread acc√®de √† un objet.  Python multithread est connu pour son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inefficacit√© en</a> raison de la latence GIL.  Par cons√©quent, la plupart des programmes Python simultan√©s fonctionnent dans plusieurs processus afin que chacun ait son propre GIL. <br><br><h3>  Java et exceptions d'ex√©cution </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java</a> prend en charge la programmation simultan√©e via un mod√®le de m√©moire partag√©e.  Chaque thread a son propre chemin d'ex√©cution, mais il peut acc√©der √† n'importe quel objet du programme: le programmeur doit synchroniser l'acc√®s entre les threads √† l'aide des primitives Java int√©gr√©es. <br><br>  Bien que Java ait des blocs de construction pour cr√©er des programmes thread-safe, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©curit√© des threads n'est</a> <b>pas garantie par le</b> compilateur (par opposition √† la s√©curit√© de la m√©moire).  Si l'acc√®s √† la m√©moire non synchronis√© se produit (c'est-√†-dire la course aux donn√©es), Java l√®vera une exception d'ex√©cution, mais les programmeurs doivent utiliser correctement les primitives de concurrence. <br><br><h3>  C ++ et le cerveau du programmeur </h3><br>  Alors que Python √©vite les conditions de concurrence avec le GIL et que Java l√®ve des exceptions au moment de l'ex√©cution, C ++ attend du programmeur qu'il synchronise manuellement l'acc√®s √† la m√©moire.  Avant C ++ 11, la biblioth√®que standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'incluait pas de primitives de concurrence</a> . <br><br>  La plupart des langues fournissent des outils pour √©crire du code thread-safe, et il existe des m√©thodes sp√©ciales pour d√©tecter la race des donn√©es et le statut de la race;  mais il ne donne aucune garantie de s√©curit√© des threads et ne prot√®ge pas contre la course aux donn√©es. <br><br><h1>  Comment r√©soudre le probl√®me de la rouille? </h1><br>  Rust adopte une approche √† multiples facettes pour √©liminer les conditions de course en utilisant des r√®gles de tenure et des types s√ªrs pour se prot√©ger compl√®tement contre les conditions de course au moment de la compilation. <br><br>  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article,</a> nous avons introduit le concept de propri√©t√©, c'est l'un des concepts de base de Rust.  Chaque variable a un propri√©taire unique et la propri√©t√© peut √™tre transf√©r√©e ou emprunt√©e.  Si un autre thread souhaite modifier la ressource, nous transf√©rons la propri√©t√© en d√©pla√ßant la variable vers un nouveau thread. <br><br>  Le d√©placement l√®ve une exception: plusieurs threads peuvent √©crire dans la m√™me m√©moire, mais jamais en m√™me temps.  Puisque le propri√©taire est toujours seul, que se passe-t-il si un autre thread emprunte une variable? <br><br>  Dans Rust, vous avez soit un emprunt mutable, soit plusieurs emprunts immuables.  Il n'est pas possible d'introduire simultan√©ment des emprunts mutables et immuables (ou plusieurs emprunts mutables).  Dans la s√©curit√© de la m√©moire, il est important que les ressources soient correctement lib√©r√©es, et dans la s√©curit√© des threads, il est important qu'un seul thread ait le droit de modifier une variable √† un moment donn√©.  De plus, dans une telle situation, aucun autre flux ne fera r√©f√©rence √† un emprunt obsol√®te: soit l'enregistrement, soit le partage lui est possible, mais pas les deux. <br><br>  Le concept de propri√©t√© est con√ßu pour corriger les vuln√©rabilit√©s de la m√©moire.  Il s'est av√©r√© que cela emp√™che √©galement la course aux donn√©es. <br><br>  Bien que de nombreuses langues disposent de m√©thodes de s√©curit√© de la m√©moire (telles que le comptage de liens et la r√©cup√©ration de place), elles reposent g√©n√©ralement sur une synchronisation manuelle ou des interdictions de partage simultan√© pour emp√™cher la course aux donn√©es.  L'approche Rust aborde les deux types de s√©curit√©, essayant de r√©soudre le probl√®me principal de d√©terminer l'utilisation acceptable des ressources et d'assurer cette validit√© au moment de la compilation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/88b/4d9/97288b4d9796a35d8cce9400c2dbfd73.png"></div><br><br><h3>  Mais attends!  Ce n'est pas tout! </h3><br>  Les r√®gles de propri√©t√© emp√™chent plusieurs threads d'√©crire des donn√©es dans le m√™me emplacement de m√©moire et interdisent l'√©change simultan√© de donn√©es entre les threads et la mutabilit√©, mais cela ne fournit pas n√©cessairement des structures de donn√©es thread-safe.  Chaque structure de donn√©es dans Rust est thread-safe ou non.  Ceci est transmis au compilateur √† l'aide d'un syst√®me de type. <br><br><blockquote>  "Un programme bien tap√© ne peut pas faire d'erreur."  - Robin Milner, 1978 </blockquote><br>  Dans les langages de programmation, les syst√®mes de types d√©crivent un comportement acceptable.  En d'autres termes, un programme bien typ√© est bien d√©fini.  Tant que nos types sont suffisamment expressifs pour capturer le sens voulu, un programme bien typ√© se comportera comme pr√©vu. <br><br>  Rust est un langage de type s√©curis√©, ici le compilateur v√©rifie la coh√©rence de tous les types.  Par exemple, le code suivant ne compile pas: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-string"><span class="hljs-string">"I am a string"</span></span>; x = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br><pre> <code class="rust hljs"> error[E0308]: mismatched types --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | x = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">// | ^ expected &amp;str, found integral variable | = note: expected type `&amp;str` found type `{integer}`</span></span></code> </pre> <br>  Toutes les variables de Rust sont de type souvent implicite.  Nous pouvons √©galement d√©finir de nouveaux types et d√©crire les capacit√©s de chaque type √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> aide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du syst√®me de traits</a> .  Les traits fournissent une abstraction de l'interface.  Deux caract√©ristiques int√©gr√©es importantes sont <code>Send</code> et <code>Sync</code> , qui sont fournies par d√©faut par le compilateur pour chaque type: <br><br><ul><li>  <code>Send</code> indique que la structure peut √™tre transf√©r√©e en toute s√©curit√© entre les threads (requis pour transf√©rer la propri√©t√©) <br></li><li>  <code>Sync</code> indique que les threads peuvent utiliser la structure en toute s√©curit√©. </li></ul><br>  L'exemple ci-dessous est une version simplifi√©e du <a href="">code de la biblioth√®que standard</a> qui g√©n√®re des threads: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;Closure: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(closure: Closure){ ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = std::rc::Rc::new(<span class="hljs-number"><span class="hljs-number">6</span></span>); spawn(|| { x; });</code> </pre> <br>  La fonction d' <code>spawn</code> prend un seul argument, la <code>closure</code> et n√©cessite un type pour ce dernier qui impl√©mente les traits <code>Send</code> et <code>Fn</code> .  Lorsque vous essayez de cr√©er un flux et de transmettre la valeur de <code>closure</code> avec la variable <code>x</code> compilateur renvoie une erreur: <br><br><pre>  erreur [E0277]: `std :: rc :: Rc &lt;i32&gt;` ne peut pas √™tre envoy√© entre les threads en toute s√©curit√©
      -&gt; src / main.rs: 8: 1
       |
     8 |  spawn (move || {x;});
       |  ^^^^^ `std :: rc :: Rc &lt;i32&gt;` ne peut pas √™tre envoy√© entre les threads en toute s√©curit√©
       |
       = aide: dans `[fermeture@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`, le trait `std :: marker :: Send` n'est pas impl√©ment√© pour `std :: rc :: Rc &lt;i32&gt;`
       = note: obligatoire car il appara√Æt dans le type `[fermeture@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`
     note: requis par `spawn` </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les traits d'</a> <code>Send</code> et de <code>Sync</code> permettent au syst√®me de type Rust de comprendre quelles donn√©es peuvent √™tre partag√©es.  En incluant ces informations dans le syst√®me de types, la s√©curit√© des threads fait partie de la s√©curit√© des types.  Au lieu de la documentation, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©curit√© des threads est impl√©ment√©e par la loi du compilateur</a> . <br><br>  Les programmeurs voient clairement les objets communs entre les threads, et le compilateur garantit la fiabilit√© de cette installation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/af5/27e/35caf527e18989b41893e6fd37239dab.gif"></div><br><br>  Bien que des outils de programmation parall√®les soient disponibles dans de nombreux langages, la pr√©vention des conditions de concurrence n'est pas facile.  Si vous avez besoin que les programmeurs alternent de mani√®re complexe les instructions et interagissent entre les threads, les erreurs sont in√©vitables.  Bien que les violations de s√©curit√© des threads et de la m√©moire entra√Ænent des cons√©quences similaires, les protections de m√©moire traditionnelles, telles que le comptage de liens et la r√©cup√©ration de place, n'emp√™chent pas les conditions de concurrence.  En plus de la garantie statique de la s√©curit√© de la m√©moire, le mod√®le de propri√©t√© Rust emp√™che √©galement les modifications de donn√©es non s√©curis√©es et le partage incorrect des objets entre les threads, tandis que le syst√®me de type assure la s√©curit√© des threads au moment de la compilation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/429/fb9/92d429fb9c3812ddfdf115d71a3695ed.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441370/">https://habr.com/ru/post/fr441370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441360/index.html">Openshift - artisanat chapeau rouge</a></li>
<li><a href="../fr441362/index.html">Guide de l'utilisateur Kibana. Visualisation. 3e partie</a></li>
<li><a href="../fr441364/index.html">Programme de la conf√©rence Lua √† Moscou 2019</a></li>
<li><a href="../fr441366/index.html">Le magasin a-t-il besoin de Stylish Crossell: l'exp√©rience de Retail Rocket en analyse d'image pour formuler des recommandations</a></li>
<li><a href="../fr441368/index.html">√Ä quoi ressemble la lune auparavant invisible de Neptune</a></li>
<li><a href="../fr441372/index.html">[Vendredi] Comment faire frire le poulet en termes de physique</a></li>
<li><a href="../fr441376/index.html">Au-del√† de la puret√©: ce qui peut et ce qui ne peut pas inverser la membrane d'osmose</a></li>
<li><a href="../fr441378/index.html">Chercheurs de Google: pour se prot√©ger contre Spectre, il faut changer l'architecture du processeur, les correctifs logiciels n'aideront pas</a></li>
<li><a href="../fr441380/index.html">7 points de croissance de conversion ou comment augmenter la cliquabilit√© des boutons</a></li>
<li><a href="../fr441382/index.html">Des scientifiques chinois ont d√©velopp√© un g√©n√©rateur pi√©zo√©lectrique pour stimulateur cardiaque</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>