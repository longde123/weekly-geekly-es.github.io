<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏽 👦 🖤 Menggunakan data terenkripsi untuk pembelajaran mesin tanpa mendekripsi ↖️ 🥐 👩🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menggunakan data terenkripsi untuk pembelajaran mesin tanpa mendekripsi 
 Artikel ini membahas teknik kriptografi canggih. Ini hanya gambaran umum dar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan data terenkripsi untuk pembelajaran mesin tanpa mendekripsi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/478514/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/ns/yf/_pnsyfz49v6t61j8whitl-q4qw0.jpeg"></div><br>  Menggunakan data terenkripsi untuk pembelajaran mesin tanpa mendekripsi <br>  Artikel ini membahas teknik kriptografi canggih.  Ini hanya gambaran umum dari penelitian yang dilakukan oleh Julia Computing.  Jangan gunakan contoh yang diberikan di sini dalam aplikasi komersial.  Selalu berkonsultasi dengan kriptografi sebelum menerapkan kriptografi. <br><br>  <a href="">Di sini</a> Anda dapat mengunduh paket yang mengimplementasikan semua keajaiban, dan di <a href="">sini</a> adalah kode yang dibahas dalam artikel. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Katakanlah Anda baru saja mengembangkan model pembelajaran mesin baru yang keren (tentu saja, menggunakan <a href="">Flux.jl</a> ).  Dan sekarang Anda ingin mulai menyebarkannya untuk pengguna Anda.  Bagaimana Anda akan melakukan ini?  Mungkin cara termudah adalah memberikan model kepada pengguna dan membiarkannya berjalan secara lokal pada data mereka.  Tetapi pendekatan ini memiliki kelemahan: <br><br><ol><li>  Model pembelajaran mesin berukuran besar, dan komputer pengguna mungkin tidak memiliki cukup sumber daya komputasi atau disk. </li><li>  Model pembelajaran mesin sering diperbarui, dan mungkin tidak nyaman bagi Anda untuk secara teratur mengirim data dalam jumlah besar melalui jaringan. <br></li><li>  Pengembangan model memakan waktu dan membutuhkan banyak sumber daya komputasi.  Dan Anda mungkin ingin kompensasi untuk ini dalam bentuk biaya untuk menggunakan model Anda. </li></ol><br>  Kemudian mereka biasanya ingat bahwa model dapat disediakan di cloud melalui API.  Selama beberapa tahun terakhir, banyak layanan seperti itu telah muncul, masing-masing platform cloud besar menawarkan layanan serupa dengan pengembang perusahaan.  Tetapi pengguna potensial dihadapkan pada dilema yang jelas: sekarang data mereka diproses pada server jauh, yang mungkin tidak dapat dipercaya.  Ini memiliki implikasi etis dan hukum yang jelas yang membatasi penggunaan layanan tersebut.  Dalam industri yang diatur, terutama layanan kesehatan dan keuangan, seringkali tidak mungkin untuk mengirim data pasien dan klien ke pihak ketiga untuk diproses. <br><br>  Ada opsi lain? <br><br>  Ternyata ada!  Penemuan terbaru dalam kriptografi memungkinkan komputasi dengan data <i>tanpa mendekodekannya</i> .  Misalnya, pengguna mengirim data terenkripsi (katakanlah, gambar) ke cloud API yang meluncurkan model pembelajaran mesin, dan kemudian mengirim respons terenkripsi.  Tanpa tahap data didekripsi, penyedia cloud tidak mendapatkan akses ke gambar sumber dan tidak dapat mendekripsi perkiraan ramalan.  Bagaimana ini mungkin?  Mari kita cari tahu contoh membuat layanan untuk pengenalan tulisan tangan pada gambar yang dienkripsi dari dataset MNIST. <br><br><h2>  Tentang enkripsi homomorfik </h2><br>  Kemampuan untuk melakukan perhitungan dengan data terenkripsi biasanya disebut sebagai "komputasi aman".  Ini adalah area yang luas untuk penelitian, dengan banyak pendekatan untuk kriptografi tergantung pada semua jenis skenario aplikasi.  Kami akan fokus pada teknik yang disebut "enkripsi homomorfik".  Dalam sistem seperti itu, operasi berikut biasanya tersedia untuk kami: <br><br><ul><li><code>pub_key, eval_key, priv_key = keygen()</code> <br> </li><li> <code>encrypted = encrypt(pub_key, plaintext)</code> <br> </li><li> <code>decrypted = decrypt(priv_key, encrypted)</code> <br> </li><li> <code>encrypted′ = eval(eval_key, f, encrypted)</code> <br> </li></ul><br>  Tiga operasi pertama sederhana dan akrab bagi semua orang yang telah menggunakan algoritma enkripsi asimetris apa pun (misalnya, jika Anda terhubung melalui TLS).  Semua keajaiban terjadi dalam operasi terakhir.  Selama enkripsi, ia mengevaluasi fungsi <code>f</code> dan mengembalikan nilai terenkripsi lain yang dihitung sesuai dengan hasil evaluasi <code>f</code> pada nilai terenkripsi.  Fitur ini memberi pendekatannya namanya.  Penilaian terkait dengan operasi enkripsi: <br><br><pre> <code class="julia hljs">f(decrypt(priv_key, encrypted)) == decrypt(priv_key, eval(eval_key, f, encrypted))</code> </pre> <br>  Demikian pula, menggunakan nilai terenkripsi, kita dapat mengevaluasi homomorfisme sewenang-wenang <code>f</code> . <br><br>  Fungsi mana <code>f</code> didukung tergantung pada skema kriptografi dan operasi yang didukung.  Jika hanya satu <code>f</code> didukung (misalnya, <code>f = +</code> ), maka rangkaian disebut "sebagian homomorfik".  Jika <code>f</code> dapat berupa serangkaian gateway yang lengkap, berdasarkan skema yang dapat dibuat sewenang-wenang, maka untuk skema ukuran terbatas ini disebut jenis lain dari perhitungan homomorfik sebagian - "agak homomorfik", dan untuk ukuran tak terbatas - perhitungan "sepenuhnya homomorfik".  Anda dapat mengubah "dalam beberapa cara" menjadi enkripsi yang sepenuhnya homomorfik menggunakan teknik bootstrap, tetapi ini di luar ruang lingkup artikel kami.  Enkripsi sepenuhnya homomorfik adalah penemuan yang relatif baru, skema kerja pertama (meskipun tidak praktis) diterbitkan oleh <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">Craig Gentry pada tahun 2009</a> .  Ada beberapa skema yang kemudian (dan praktis) sepenuhnya homomorfis.  Ada juga paket perangkat lunak yang secara kualitatif mengimplementasikan skema ini.  Paling sering mereka menggunakan <a href="https://github.com/microsoft/SEAL">Microsoft SEAL</a> dan <a href="https://palisade-crypto.org/">PALISADE</a> .  Selain itu, saya baru-baru ini membuka kode implementasi untuk algoritma <a href="">Pure Julia ini</a> .  Untuk artikel ini, kami akan menggunakan enkripsi CKKS yang diterapkan di dalamnya. <br><br><h2>  Ikhtisar CKS </h2><br>  CKKS (dengan nama penulis <a href="https://eprint.iacr.org/2016/421.pdf">karya ilmiah</a> Cheon-Kim-Kim-Song, yang mengusulkan algoritma pada 2016) adalah skema enkripsi homomorfik yang memungkinkan evaluasi homomorfik dari operasi primitif berikut: <br><br><ul><li>  Penambahan elemen dari panjang <code>n</code> vektor bilangan kompleks. <br></li><li>  Penggandaan elemen-bijaksana dari panjang <code>n</code> vektor kompleks. <br></li><li>  Putar elemen (dalam konteks <code>circshift</code> ) dalam vektor. <br></li><li>  Pasangan terintegrasi elemen vektor. <br></li></ul><br>  Parameter <code>n</code> tergantung pada tingkat keamanan dan akurasi yang diinginkan, dan biasanya cukup tinggi.  Dalam contoh kita, itu akan sama dengan 4096 (nilai yang lebih tinggi meningkatkan keamanan, tetapi juga lebih sulit dalam perhitungan, skalanya kira-kira seperti <code>n log n</code> ). <br><br>  Selain itu, perhitungan menggunakan CKKS <i>berisik</i> .  Oleh karena itu, hasilnya adalah perkiraan, dan harus diperhatikan bahwa hasilnya dievaluasi dengan akurasi yang cukup agar tidak mempengaruhi kebenaran hasil. <br><br>  Di sisi lain, pembatasan seperti itu tidak biasa bagi pengembang paket pembelajaran mesin.  Akselerator khusus seperti GPU juga biasanya beroperasi dengan vektor angka.  Selain itu, bagi banyak pengembang, angka floating point kadang-kadang terlihat berisik karena pengaruh algoritma pemilihan, multithreading, dan sebagainya.  Saya ingin menekankan bahwa perbedaan utama di sini adalah bahwa perhitungan aritmatika dengan angka floating point pada awalnya bersifat deterministik, bahkan jika ini tidak jelas karena kompleksitas implementasinya, meskipun primitif CKKS benar-benar berisik.  Tapi mungkin ini memungkinkan pengguna untuk memahami bahwa suara itu tidak seseram kelihatannya. <br><br>  Sekarang mari kita lihat bagaimana Anda dapat melakukan operasi ini di Julia (catatan: parameter yang sangat tidak aman dipilih, dengan operasi ini kami hanya menggambarkan penggunaan perpustakaan di REPL). <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ToyFHE <span class="hljs-comment"><span class="hljs-comment"># Let's play with 8 element vectors julia&gt; N = 8; # Choose some parameters - we'll talk about it later julia&gt; ℛ = NegacyclicRing(2N, (40, 40, 40)) ℤ₁₃₂₉₂₂₇₉₉₇₅₆₈₀₈₁₄₅₇₄₀₂₇₀₁₂₀₇₁₀₄₂₄₈₂₅₇/(x¹⁶ + 1) # We'll use CKKS julia&gt; params = CKKSParams(ℛ) CKKS parameters # We need to pick a scaling factor for a numbers - again we'll talk about that later julia&gt; Tscale = FixedRational{2^40} FixedRational{1099511627776,T} where T # Let's start with a plain Vector of zeros julia&gt; plain = CKKSEncoding{Tscale}(zero(ℛ)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im # Ok, we're ready to get started, but first we'll need some keys julia&gt; kp = keygen(params) CKKS key pair julia&gt; kp.priv CKKS private key julia&gt; kp.pub CKKS public key # Alright, let's encrypt some things: julia&gt; foreach(i-&gt;plain[i] = i+1, 0:7); plain 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im 7.0 + 0.0im 8.0 + 0.0im julia&gt; c = encrypt(kp.pub, plain) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1099511627776,T} where T}) # And decrypt it again julia&gt; decrypt(kp.priv, c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.9999999999995506 - 2.7335193113350057e-16im 1.9999999999989408 - 3.885780586188048e-16im 3.000000000000205 + 1.6772825551165524e-16im 4.000000000000538 - 3.885780586188048e-16im 4.999999999998865 + 8.382500573679615e-17im 6.000000000000185 + 4.996003610813204e-16im 7.000000000001043 - 2.0024593503998215e-16im 8.000000000000673 + 4.996003610813204e-16im # Note that we had some noise. Let's go through all the primitive operations we'll need: julia&gt; decrypt(kp.priv, c+c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.9999999999991012 - 5.467038622670011e-16im 3.9999999999978817 - 7.771561172376096e-16im 6.00000000000041 + 3.354565110233105e-16im 8.000000000001076 - 7.771561172376096e-16im 9.99999999999773 + 1.676500114735923e-16im 12.00000000000037 + 9.992007221626409e-16im 14.000000000002085 - 4.004918700799643e-16im 16.000000000001346 + 9.992007221626409e-16im julia&gt; csq = c*c CKKS ciphertext (length 3, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) julia&gt; decrypt(kp.priv, csq) 8-element CKKSEncoding{FixedRational{1208925819614629174706176,T} where T} with indices 0:7: 0.9999999999991012 - 2.350516767363621e-15im 3.9999999999957616 - 5.773159728050814e-15im 9.000000000001226 - 2.534464540987068e-15im 16.000000000004306 - 2.220446049250313e-15im 24.99999999998865 + 2.0903753311370056e-15im 36.00000000000222 + 4.884981308350689e-15im 49.000000000014595 + 1.0182491378134327e-15im 64.00000000001077 + 4.884981308350689e-15im</span></span></code> </pre> <br>  Sangat sederhana!  Pembaca yang penuh perhatian mungkin memperhatikan bahwa CSQ sedikit berbeda dari ciphertext sebelumnya.  Secara khusus, ciphertext memiliki "panjang 3" dan skalanya jauh lebih besar.  Penjelasan tentang apa ini dan apa yang dibutuhkan berada di luar cakupan artikel ini.  Cukuplah untuk mengatakan bahwa kita perlu menurunkan nilai sebelum melanjutkan dengan perhitungan, jika tidak, "tempat" akan berakhir pada ciphertext.  Untungnya, kita dapat mengurangi masing-masing dari dua nilai yang meningkat: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># To get back down to length 2, we need to `keyswitch` (aka # relinerarize), which requires an evaluation key. Generating # this requires the private key. In a real application we would # have generated this up front and sent it along with the encrypted # data, but since we have the private key, we can just do it now. julia&gt; ek = keygen(EvalMultKey, kp.priv) CKKS multiplication key julia&gt; csq_length2 = keyswitch(ek, csq) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) # Getting the scale back down is done using modswitching. julia&gt; csq_smaller = modswitch(csq_length2) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1.099511626783e12,T} where T}) # And it still decrypts correctly (though note we've lost some precision) julia&gt; decrypt(kp.priv, csq_smaller) 8-element CKKSEncoding{FixedRational{1.099511626783e12,T} where T} with indices 0:7: 0.9999999999802469 - 5.005163520332181e-11im 3.9999999999957723 - 1.0468514951188039e-11im 8.999999999998249 - 4.7588542623100616e-12im 16.000000000023014 - 1.0413447889166631e-11im 24.999999999955193 - 6.187833723406491e-12im 36.000000000002345 + 1.860733715346631e-13im 49.00000000001647 - 1.442396043149794e-12im 63.999999999988695 - 1.0722489563648028e-10im</span></span></code> </pre> <br>  Selain itu, modswitching (kependekan dari modulus switching, switching modul) mengurangi ukuran modul ciphertext, sehingga kami tidak dapat terus melakukan ini tanpa batas waktu (kami menggunakan skema enkripsi yang agak homomorfik): <br><br><pre> <code class="julia hljs">julia&gt; ℛ <span class="hljs-comment"><span class="hljs-comment"># Remember the ring we initially created ℤ₁₃₂₉₂₂₇₉₉₇₅₆₈₀₈₁₄₅₇₄₀₂₇₀₁₂₀₇₁₀₄₂₄₈₂₅₇/(x¹⁶ + 1) julia&gt; ToyFHE.ring(csq_smaller) # It shrunk! ℤ₁₂₀₈₉₂₅₈₂₀₁₄₄₅₉₃₇₇₉₃₃₁₅₅₃/(x¹⁶ + 1)&lt;/code&gt;     —  (rotations).      keyswitch,       (evaluation key,     ): &lt;source lang="julia"&gt;julia&gt; gk = keygen(GaloisKey, kp.priv; steps=2) CKKS galois key (element 25) julia&gt; decrypt(circshift(c, gk)) decrypt(kp, circshift(c, gk)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 7.000000000001042 + 5.68459112632516e-16im 8.000000000000673 + 5.551115123125783e-17im 0.999999999999551 - 2.308655353580721e-16im 1.9999999999989408 + 2.7755575615628914e-16im 3.000000000000205 - 6.009767921608429e-16im 4.000000000000538 + 5.551115123125783e-17im 4.999999999998865 + 4.133860996136768e-17im 6.000000000000185 - 1.6653345369377348e-16im # And let's compare to doing the same on the plaintext julia&gt; circshift(plain, 2) 8-element OffsetArray(::Array{Complex{Float64},1}, 0:7) with eltype Complex{Float64} with indices 0:7: 7.0 + 0.0im 8.0 + 0.0im 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im</span></span></code> </pre> <br>  Kami membahas dasar-dasar penggunaan perpustakaan HE.  Tetapi sebelum beralih menggunakan primitif ini untuk menghitung perkiraan jaringan saraf, mari kita lihat proses mempelajarinya. <br><br><h2>  Model pembelajaran mesin </h2><br>  Jika Anda tidak terbiasa dengan pembelajaran mesin atau pustaka Flux.jl, maka saya sarankan menjalankan singkat melalui <a href="https://fluxml.ai/Flux.jl/stable/">dokumentasi Flux.jl</a> atau melihat <a href="https://juliaacademy.com/p/introduction-to-machine-learning">pengantar</a> gratis <a href="https://juliaacademy.com/p/introduction-to-machine-learning">untuk pembelajaran mesin</a> , karena kami hanya akan membahas perubahan dalam menerapkan model untuk data terenkripsi. <br><br>  Mari kita mulai dengan menggunakan jaringan saraf convolutional <a href="">dari kebun binatang Flux</a> .  Kami akan melakukan siklus pelatihan yang sama, dengan persiapan data dan sebagainya, hanya menyiapkan model sedikit.  Ini dia: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reshape_and_vcat(x) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y=reshape(x, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, size(x, <span class="hljs-number"><span class="hljs-number">4</span></span>)) vcat((y[:,i,:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=axes(y,<span class="hljs-number"><span class="hljs-number">2</span></span>))...) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> model = Chain( <span class="hljs-comment"><span class="hljs-comment"># First convolution, operating upon a 28x28 image Conv((7, 7), 1=&gt;4, stride=(3,3), x-&gt;x.^2), reshape_and_vcat, Dense(256, 64, x-&gt;x.^2), Dense(64, 10), )</span></span></code> </pre><br>  Ini adalah model yang sama seperti dalam karya <a href="https://eprint.iacr.org/2018/1041.pdf">"Secure Outsourced Matrix Computation and Application to Neural Networks"</a> , yang menggunakan skema kriptografi yang sama dengan dua perbedaan: 1) demi kesederhanaan, kami tidak mengenkripsi model itu sendiri, dan 2) setelah setiap lapisan yang kami miliki Vektor Bayesian digunakan (dalam Flux ini dilakukan secara default), saya tidak yakin apa itu dalam karya yang disebutkan.  Mungkin, karena poin kedua, akurasi pada set uji model kami ternyata sedikit lebih tinggi (98,6% berbanding 98,1%), tetapi perbedaan hiperparametrik juga bisa menjadi alasannya. <br><br>  Unusual (bagi mereka yang memiliki pengalaman dalam pembelajaran mesin) adalah aktivasi fungsi.  Paling sering dalam kasus seperti itu mereka menggunakan <code>tanh</code> , <code>relu</code> atau sesuatu yang lebih fantastis.  Tetapi meskipun fungsi-fungsi ini (terutama <code>relu</code> ) mudah dihitung untuk nilai teks biasa, namun, mereka mungkin membutuhkan banyak sumber daya komputasi untuk mengevaluasi mereka dalam bentuk terenkripsi (kami biasanya memperkirakan perkiraan polinomial).  Untungnya, dalam hal ini <code>x.^2</code> berfungsi dengan baik. <br><br>  Sisa siklus belajar tetap sama.  Kami menghapus <code>softmax</code> dari model untuk kehilangan-fungsi <code>logitcrossentropy</code> (Anda dapat meninggalkannya dan mengevaluasi softmax setelah dekripsi pada klien).  Kode lengkap untuk melatih model terletak <a href="">pada GitHub</a> , kode ini berjalan dalam beberapa menit pada kartu video baru. <br><br><h2>  Operasi yang efektif </h2><br>  Sekarang kita tahu operasi apa yang perlu kita lakukan: <br><br><ul><li>  Koagulasi. <br></li><li>  Elemen kuadrat. <br></li><li>  Perkalian matriks. <br></li></ul><br>  Dengan mengkuadratkan semuanya sederhana, kami telah memeriksanya di atas, jadi kami akan mempertimbangkan dua operasi lainnya.  Kami berasumsi bahwa panjang paket data adalah 64 (Anda mungkin memperhatikan bahwa parameter model dan ukuran paket dipilih untuk memanfaatkan vektor elemen-4096 yang kami peroleh sebagai hasil dari pilihan parameter yang realistis). <br><br><h3>  Koagulasi </h3><br>  Ingat bagaimana koagulasi bekerja.  Ambil jendela (dalam kasus kami 7x7) dari array input asli, dan setiap elemen jendela dikalikan dengan elemen masker konvolusi.  Kemudian kami memindahkan jendela ke beberapa langkah (dalam kasus kami, langkahnya adalah 3, yaitu, kami memindahkan 3 elemen) dan mengulangi prosesnya (dengan topeng konvolusi yang sama).  Animasi proses ( <a href="https://github.com/vdumoulin/conv_arithmetic">sumber</a> ) untuk konvolusi 3x3 dengan langkah <code>(2, 2)</code> ditunjukkan di bawah ini (array-input biru, output-hijau): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h5/a3/q3/h5a3q3ea0pljgdagz1wd-k2igdy.gif"></div><br>  Selain itu, kami melakukan konvolusi dalam empat "saluran" yang berbeda (yaitu, kami mengulangi konvolusi 3 kali lebih banyak dengan masker yang berbeda). <br><br>  Sekarang kita tahu apa yang harus dilakukan, masih harus mengerti caranya.  Kami beruntung konvolusi adalah operasi pertama dalam model kami.  Akibatnya, untuk menghemat sumber daya, kami dapat melakukan pra-proses data pada klien, dan kemudian mengenkripsi mereka (tanpa menggunakan bobot).  Mari kita lakukan ini: <br><br><ul><li>  Pertama, kami menghitung setiap jendela konvolusi (yaitu, sampel 7x7 dari gambar sumber), yang memberi kami 64 matriks 7x7 untuk setiap gambar input.  Perhatikan bahwa untuk jendela 7x7 dengan kelipatan 2, akan ada jendela konvolusi 8x8 untuk mengevaluasi gambar input 28x28. <br></li><li>  Mari kita kumpulkan dalam satu vektor posisi yang sama di setiap jendela.  Yaitu, untuk setiap gambar kita akan memiliki vektor 64-elemen, atau vektor 64x64 elemen untuk paket ukuran 64 (total 49 matriks 64 64 x 64). <br></li><li>  Kami akan mengenkripsi. <br></li></ul><br>  Kemudian koagulasi berubah menjadi perkalian skalar dari seluruh matriks dengan elemen topeng yang sesuai.  Dan menyimpulkan semua 49 elemen, kita mendapatkan hasil lipat.  Beginilah implementasi dari strategi ini (dalam teks biasa): <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> public_preprocess(batch) ka = OffsetArray(<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create feature extracted matrix I = [[batch[i′*3 .+ (1:7), j′*3 .+ (1:7), 1, k] for i′=ka, j′=ka] for k = 1:64] # Reshape into the ciphertext Iᵢⱼ = [[I[k][l...][i,j] for k=1:64, l=product(ka, ka)] for i=1:7, j=1:7] end Iᵢⱼ = public_preprocess(batch) # Evaluate the convolution weights = model.layers[1].weight conv_weights = reverse(reverse(weights, dims=1), dims=2) conved = [sum(Iᵢⱼ[i,j]*conv_weights[i,j,1,channel] for i=1:7, j=1:7) for channel = 1:4] conved = map(((x,b),)-&gt;x .+ b, zip(conved, model.layers[1].bias))</span></span></code> </pre> <br>  Ini (modul untuk mengubah dimensi) (modulo - mengubah urutan ukuran) memberikan jawaban yang sama dengan model operasi. <code>model.layers[1](batch)</code> . <br><br>  Tambahkan operasi enkripsi: <br><br><pre> <code class="julia hljs">Iᵢⱼ = public_preprocess(batch) C_Iᵢⱼ = map(Iᵢⱼ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N÷<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2)</code> </pre> <br>  Harap dicatat bahwa keyswitch tidak diperlukan di sini karena bobot bersifat publik.  Jadi kami tidak menambah panjang ciphertext. <br><br><h3>  Perkalian matriks </h3><br>  Beralih ke perkalian matriks, kita dapat menggunakan rotasi elemen dalam vektor untuk mengubah urutan indeks perkalian.  Pertimbangkan penempatan elemen matriks dalam vektor.  Jika kita menggeser vektor dengan kelipatan ukuran baris, kita mendapatkan efek rotasi kolom, yang merupakan primitif yang cukup untuk menerapkan perkalian matriks (setidaknya matriks kuadrat).  Mari kita coba: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> matmul_square_reordered(weights, x) sum(<span class="hljs-number"><span class="hljs-number">1</span></span>:size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k <span class="hljs-comment"><span class="hljs-comment"># We rotate the columns of the LHS and take the diagonal weight_diag = diag(circshift(weights, (0,(k-1)))) # We rotate the rows of the RHS x_rotated = circshift(x, (k-1,0)) # We do an elementwise, broadcast multiply weight_diag .* x_rotated end end function matmul_reorderd(weights, x) sum(partition(1:256, 64)) do range matmul_square_reordered(weights[:, range], x[range, :]) end end fc1_weights = model.layers[3].W x = rand(Float64, 256, 64) @assert (fc1_weights*x) ≈ matmul_reorderd(fc1_weights, x)</span></span></code> </pre> <br>  Tentu saja, untuk perkalian matriks umum, sesuatu yang lebih rumit diperlukan, tetapi untuk sekarang ini sudah cukup. <br><br><h2>  Memperbaiki teknik </h2><br>  Sekarang semua komponen pekerjaan teknik kami.  Ini adalah keseluruhan kode (kecuali untuk pengaturan opsi pemilihan dan hal-hal serupa): <br><br><pre> <code class="julia hljs">ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) Iᵢⱼ = public_preprocess(batch) C_Iᵢⱼ = map(Iᵢⱼ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N÷<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2) Csqed1 = map(x-&gt;x*x, conved1) Csqed1 = map(x-&gt;keyswitch(ek, x), Csqed1) Csqed1 = map(ToyFHE.modswitch, Csqed1) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encrypted_matmul(gk, weights, x::ToyFHE.CipherText) result = repeat(diag(weights), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>).*x rotated = x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k = <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">64</span></span> rotated = ToyFHE.rotate(gk, rotated) result += repeat(diag(circshift(weights, (<span class="hljs-number"><span class="hljs-number">0</span></span>,(k-<span class="hljs-number"><span class="hljs-number">1</span></span>)))), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>) .* rotated <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq1_weights = model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].W Cfq1 = sum(enumerate(partition(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (i,range) encrypted_matmul(gk, fq1_weights[:, range], Csqed1[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Cfq1 = Cfq1 .+ OffsetArray(repeat(model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].b, inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>) Cfq1 = modswitch(Cfq1) Csqed2 = Cfq1*Cfq1 Csqed2 = keyswitch(ek, Csqed2) Csqed2 = modswitch(Csqed2) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> naive_rectangular_matmul(gk, weights, x) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>) weights = vcat(weights, zeros(eltype(weights), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>)-size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>))) encrypted_matmul(gk, weights, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq2_weights = model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].W Cresult = naive_rectangular_matmul(gk, fq2_weights, Csqed2) Cresult = Cresult .+ OffsetArray(repeat(vcat(model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].b, zeros(<span class="hljs-number"><span class="hljs-number">54</span></span>)), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>)</code> </pre> <br>  Itu tidak terlihat terlalu rapi, tetapi jika Anda melakukan semua ini, Anda harus memahami setiap langkah. <br>  Sekarang mari kita pikirkan abstraksi apa yang dapat menyederhanakan hidup kita.  Kami meninggalkan bidang kartografi dan pembelajaran mesin dan beralih ke arsitektur bahasa pemrograman, jadi mari manfaatkan fakta bahwa Julia memungkinkan Anda untuk menggunakan dan membuat abstraksi yang kuat.  Misalnya, Anda dapat merangkum seluruh proses ekstraksi konvolusi ke dalam tipe array Anda: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BlockArrays <span class="hljs-string"><span class="hljs-string">""" ExplodedConvArray{T, Dims, Storage} &lt;: AbstractArray{T, 4} Represents a an `nxmx1xb` array of images, but rearranged into a series of convolution windows. Evaluating a convolution compatible with `Dims` on this array is achievable through a sequence of scalar multiplications and sums on the underling storage. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ExplodedConvArray{T, <span class="hljs-built_in"><span class="hljs-built_in">Dims</span></span>, Storage} &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractArray</span></span>{T, <span class="hljs-number"><span class="hljs-number">4</span></span>} <span class="hljs-comment"><span class="hljs-comment"># sx*sy matrix of b*(dx*dy) matrices of extracted elements # where (sx, sy) = kernel_size(Dims) # (dx, dy) = output_size(DenseConvDims(...)) cdims::Dims x::Matrix{Storage} function ExplodedConvArray{T, Dims, Storage}(cdims::Dims, storage::Matrix{Storage}) where {T, Dims, Storage} @assert all(==(size(storage[1])), size.(storage)) new{T, Dims, Storage}(cdims, storage) end end Base.size(ex::ExplodedConvArray) = (NNlib.input_size(ex.cdims)..., 1, size(ex.x[1], 1)) function ExplodedConvArray{T}(cdims, batch::AbstractArray{T, 4}) where {T} x, y = NNlib.output_size(cdims) kx, ky = NNlib.kernel_size(cdims) stridex, stridey = NNlib.stride(cdims) kax = OffsetArray(0:x-1, 0:x-1) kay = OffsetArray(0:x-1, 0:x-1) I = [[batch[i′*stridex .+ (1:kx), j′*stridey .+ (1:ky), 1, k] for i′=kax, j′=kay] for k = 1:size(batch, 4)] Iᵢⱼ = [[I[k][l...][i,j] for k=1:size(batch, 4), l=product(kax, kay)] for (i,j) in product(1:kx, 1:ky)] ExplodedConvArray{T, typeof(cdims), eltype(Iᵢⱼ)}(cdims, Iᵢⱼ) end function NNlib.conv(x::ExplodedConvArray{&lt;:Any, Dims}, weights::AbstractArray{&lt;:Any, 4}, cdims::Dims) where {Dims&lt;:ConvDims} blocks = reshape([ Base.ReshapedArray(sum(xx[i,j]*weights[i,j,1,channel] for i=1:7, j=1:7), (NNlib.output_size(cdims)...,1,size(x, 4)), ()) for channel = 1:4 ],(1,1,4,1)) BlockArrays._BlockArray(blocks, BlockArrays.BlockSizes([8], [8], [1,1,1,1], [64])) end</span></span></code> </pre><br>  Di sini kita kembali menggunakan <code>BlockArrays</code> untuk mewakili array <code>8x8x4x64</code> sebagai empat array <code>8x8x1x64</code> seperti dalam kode sumber.  Sekarang presentasi tahap pertama telah menjadi jauh lebih indah, paling tidak dengan array yang tidak terenkripsi: <br><br><pre> <code class="julia hljs">julia&gt; cdims = DenseConvDims(batch, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight; stride=(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), padding=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), dilation=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) DenseConvDims: (<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) -&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), stride: (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) pad: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), dil: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), flip: <span class="hljs-literal"><span class="hljs-literal">false</span></span> julia&gt; a = ExplodedConvArray{eltype(batch)}(cdims, batch); julia&gt; model(a) <span class="hljs-number"><span class="hljs-number">10</span></span>×<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: [snip]</code> </pre><br>  Sekarang bagaimana kita menghubungkan ini dengan enkripsi?  Untuk melakukan ini, Anda perlu: <br><br><ol><li>  Enkripsi strukturnya ( <code>ExplodedConvArray</code> ) sehingga kita mendapatkan ciphertext untuk setiap bidang.  Operasi dengan struktur terenkripsi akan memverifikasi apa fungsi akan lakukan dengan struktur asli, dan melakukan hal yang sama secara homomorfis. <br></li><li>  Mencegat operasi tertentu untuk melakukannya secara berbeda dalam konteks terenkripsi. </li></ol><br>  Untungnya, Julia memberi kita abstraksi untuk ini: sebuah plugin kompiler yang menggunakan mekanisme <a href="">Cassette.jl</a> .  Saya tidak akan memberi tahu Anda apa itu dan bagaimana cara kerjanya, saya akan singkat mengatakan bahwa itu dapat menentukan konteks, misalnya, <code>Encrypted</code> , dan kemudian mendefinisikan aturan bagaimana operasi harus bekerja dalam konteks ini.  Misalnya, Anda dapat menulis ini untuk persyaratan kedua: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># Define Matrix multiplication between an array and an encrypted block array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{&lt;:BlockArray{T, 2}}) where {T} sum(a*b for (i,range) in enumerate(partition(1:size(a, 2), size(b.blocks[1], 1)))) end # Define Matrix multiplication between an array and an encrypted array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{Array{T, 2}}) where {T} result = repeat(diag(a), inner=size(a, 1)).*x rotated = b for k = 2:size(a, 2) rotated = ToyFHE.rotate(GaloisKey(*), rotated) result += repeat(diag(circshift(a, (0,(k-1)))), inner=size(a, 1)) .* rotated end result end</span></span></code> </pre><br>  Akibatnya, pengguna akan dapat menulis semua hal di atas dengan jumlah minimum pekerjaan manual: <br><br><pre> <code class="julia hljs">kp = keygen(ckks_params) ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create evaluation context ctx = Encrypted(ek, gk) # Do public preprocessing batch = ExplodedConvArray{eltype(batch)}(cdims, batch); # Run on encrypted data under the encryption context Cresult = ctx(model)(encrypt(kp.pub, batch)) # Decrypt the answer decrypt(kp, Cresult)</span></span></code> </pre> <br> ,     .   (   ℛ,   modswitch, keyswitch  ..)       ,      .  ,    ,    ,         ,        . <br><br><h2>  Kesimpulan </h2><br>          —      .     Julia          .  RAMPARTS ( <a href="https://eprint.iacr.org/2019/988.pdf">paper</a> , <a href="https://www.youtube.com/watch%3Fv%3D_KLlMg6jKQg">JuliaCon talk</a> )       :  Julia-   -  PALISADE. Julia Computing    RAMPARTS    Verona, <a href="https://galois.com/news/15m-iarpa-hector-contract-privacy-preserving-technology/"> </a>     .             ,     .  .     ,   ,          . <br><br>        ,   <a href=""> ToyFHE</a> .   <a href="https://juliacomputing.github.io/ToyFHE.jl/dev/man/background/"></a> , ,   ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478514/">https://habr.com/ru/post/id478514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478498/index.html">1. Fortinet Getting Started v 6.0. Pendahuluan</a></li>
<li><a href="../id478500/index.html">Mengapa ada begitu sedikit konferensi di musim panas?</a></li>
<li><a href="../id478502/index.html">Teknologi pintar untuk semua orang</a></li>
<li><a href="../id478504/index.html">Bagaimana tempat kerja berubah dengan evolusi laptop</a></li>
<li><a href="../id478510/index.html">Kami mengundang Anda ke DINS QA EVENING 12/12/19: kami membuat Jenkins Pipeline dan belajar cara memparalelkan peluncuran tes dengan bantuan mereka</a></li>
<li><a href="../id478516/index.html">Jalan prosedural di Houdini dan Unity</a></li>
<li><a href="../id478518/index.html">Pengalaman menggunakan infrastruktur kantor di Zextras / Zimbra OSE</a></li>
<li><a href="../id478522/index.html">Akui saja, Watson, apakah Anda benar-benar bingung?</a></li>
<li><a href="../id478526/index.html">Banyak OpenVPN di Windows Server dan Mikrotik dengan migrasi barang ini ke Linux</a></li>
<li><a href="../id478528/index.html">Kesayangan (kisah fantastis)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>