<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏽 👨‍🎓 👨‍🎤 Compreendendo o protocolo de paginação POCSAG 🚡 😭 👦🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há muito tempo, quando um telefone celular custava cerca de US $ 2.000 e um minuto de chamada de voz era de 50 centavos, os pagers eram realmente popu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compreendendo o protocolo de paginação POCSAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Há muito tempo, quando um telefone celular custava cerca de US $ 2.000 e um minuto de chamada de voz era de 50 centavos, os pagers eram realmente populares.  Mais tarde, os telefones celulares ficaram mais baratos, os preços de chamadas e SMS ficaram mais baixos e, finalmente, os pagers desapareceram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Para pessoas que já possuíam um pager e desejam saber como ele funciona, este artigo será útil. <br><a name="habracut"></a><br><h2>  Informações principais </h2><br>  Para as pessoas que esqueceram os princípios ou nasceram depois de 2000x, lembrarei as principais idéias em breve. <br><br>  A rede de comunicações de paginação possui algumas vantagens, às vezes importantes até agora: <br><br>  - É uma comunicação unidirecional, sem qualquer tipo de confirmação, para que a rede não possa ser sobrecarregada - simplesmente não depende de vários usuários.  As mensagens estão transmitindo continuamente "como estão", uma após a outra, e o pager está recebendo a mensagem se seu número (chamado Capcode) for igual ao número interno do dispositivo. <br><br>  - O receptor é muito leve (literal e eletronicamente) e pode funcionar até um mês com 2 pilhas AA. <br><br>  Existem dois padrões básicos de transmissão de mensagens - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">POCSAG</a> (Grupo Consultivo para Padronização de Código Postal) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FLEX</a> .  Ambos os padrões são bastante antigos, o POCSAG foi fabricado em 1982, pode suportar velocidades de 512, 1200 e 2400 bit / s.  Para transmitir o método FSK (chaveamento com mudança de frequência) é usado com uma separação de frequência de 4,5KHz.  O FLEX é um pouco mais recente (foi fabricado pela Motorola na década de 90), pode funcionar com velocidade de até 6400 bits / s e pode usar o FSK2 e o FSK4. <br><br>  Ambos os protocolos são geralmente muito fáceis, e há cerca de 20 anos foram criados decodificadores de PC que podem decodificar mensagens de uma porta serial da placa de som (não há criptografia suportada, para que todas as mensagens possam ser lidas por qualquer pessoa). <br><br>  Vamos dar uma olhada, como funciona. <br><br><h2>  Recebendo um sinal </h2><br>  Primeiro, precisamos de um sinal para decodificar.  Vamos pegar um laptop, receptor rtl-sdr, e pegá-lo. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  A tecla de mudança de frequência é usada, então definiremos FM.  Com o HDSDR, salvaremos um sinal no formato WAV. <br><br>  Vamos verificar o que temos.  Carregando o arquivo wav como uma matriz de dados Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Saída (bits adicionados manualmente): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Como podemos ver, é fácil e até "a olho nu" podemos desenhar bits no Paint, é fácil distinguir onde é "0" e onde é "1".  Mas será muito tempo para fazê-lo manualmente, é hora de automatizar o processo. <br><br>  Depois de ampliar o gráfico, podemos ver que cada bit tem uma largura de 20 amostras.  Temos um arquivo wav de taxa de bits de 24.000 amostras por segundo, portanto a velocidade de chaveamento é de 1200 bits / s.  Vamos encontrar uma posição de cruzamento zero - é o início da sequência de bits.  Permite também adicionar marcadores para verificar se todos os bits estão em locais adequados. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Como podemos ver, não é perfeitamente compatível (transmissor e receptor têm ligeiras frequências diferentes), mas é definitivamente o suficiente para decodificar. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Para sinais longos, provavelmente precisaremos do algoritmo de correção automática de frequência, mas para esse tipo de sinal não é crítico. <br><br>  O último passo - precisamos traduzir o arquivo wav para a sequência de bits.  Também é fácil, sabemos o tamanho de cada bit; se a soma dos dados for positiva, adicionaremos “1”, caso contrário, “0” (finalmente foi encontrado que um sinal precisa ser revertido, portanto, 0 e 1 foram substituídos) . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Saída - sequência de bits adequada (em formato de string), que contém nossa mensagem. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Decodificando mensagens somente numéricas </h2><br>  Uma sequência de bits é muito mais conveniente que um arquivo wav, podemos extrair dados dele.  Primeiro, vamos dividir os dados em blocos de 4 bytes. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Definitivamente, podemos ver um padrão.  Agora precisamos descobrir o que cada parte significa.  O manual do POCSAG está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em formato PDF</a> , permite verificar a descrição da estrutura de dados. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Agora é muito mais claro.  O cabeçalho contém um bloco longo "10101010101", é usado para "acordar" o pager no modo de suspensão.  A própria mensagem contém os blocos Lote-1 ... Lote-N, cada bloco está iniciando na sequência exclusiva FSC.  Então, como podemos ver no manual, se a string começar em "0", ela conterá o endereço do destinatário.  O endereço em si (capcode) é armazenado é o pager e, se não corresponder, o pager ignorará a mensagem.  Se uma sequência começar em "1", ela conterá o corpo da mensagem.  No nosso exemplo, temos 2 strings desse tipo. <br><br>  Não vamos verificar cada bloco.  Também podemos ver códigos inativos - blocos vazios 01111 ... 0111, eles não possuem nenhuma informação útil.  Depois de removê-los, obtemos apenas isso: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Precisamos descobrir o que há dentro. <br><br>  Depois de verificar o manual, fica claro que existem dois tipos de mensagens - <b>somente</b> <b>numérico e alfanumérico</b> .  As mensagens apenas numéricas são salvas como códigos BCD de 4 bits, então 20 bits podem conter 5 símbolos (também existem bits CRC, não os estamos usando no momento).  Se a mensagem for alfanumérica, será usada a codificação ASCII de 7 bits.  Esta mensagem é muito curta e, portanto, pode ser apenas uma mensagem numérica. <br><br>  A partir das seqüências 10000011010000010101010011010100 e 11110101010001000001000000111000, podemos obter essas sequências de 4 bits: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Ah Ah 8h 8h 2h <br><br>  O próximo passo é obter a tabela de decodificação no manual: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  É óbvio que uma mensagem apenas numérica pode conter dígitos de 0 a 9, letra U ("ugrent"), espaço e dois parênteses.  Vamos escrever um pequeno método para decodificá-lo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Finalmente, recebemos a mensagem "0682 *) * 882". <br><br>  É difícil dizer o que significa, mas se as mensagens apenas numéricas forem usadas, alguém provavelmente precisará dela. <br><br><h2>  Decodificando mensagens alfanuméricas </h2><br>  O próximo passo, e mais interessante, é decodificar mensagens alfanuméricas.  É mais interessante, porque, como saída, devemos obter o texto legível por humanos. <br><br>  Primeiro, precisamos gravar uma mensagem novamente, usaremos o HDSDR.  Como não conhecemos um tipo de mensagem antes da decodificação, gravamos apenas uma mensagem mais longa, podemos recebê-la e esperamos que ela contenha algum texto. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Depois de converter de wav para uma sequência de bits (veja um código Python acima), estamos obtendo o seguinte: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Algumas coisas interessantes que podemos ver imediatamente, a olho nu - como por exemplo, a sequência inicial 01010101010101 está repetindo duas vezes.  Assim, essa mensagem não é apenas mais longa, ela literalmente contém duas mensagens, mescladas (um padrão não está negando isso, btw). <br><br>  Como descobrimos antes, cada bloco de dados inicia a partir de uma sequência, chamada Frame Sync Code (01111100 ...), após o envio dos blocos de 32 bits.  Cada bloco pode armazenar o endereço ou o corpo da mensagem. <br><br>  Antes recebíamos as mensagens apenas numéricas, agora queremos ler as mensagens ASCII.  Primeiro, precisamos distingui-los.  Esses dados são salvos no campo "Bits de funções" (bits 20 a 21) - se os dois bits forem 00, será uma mensagem apenas numérica, se os bits forem 11, será uma mensagem de texto. <br><br>  É interessante mencionar que esse campo de mensagem tem 20 bits, então é ideal colocar cinco blocos de 4 bits no caso de uma mensagem apenas numérica.  Mas se tivermos uma mensagem ASCII de 7 bits, não podemos dividir de 20 a 7. É possível prever que a primeira versão do protocolo suporta apenas mensagens apenas numéricas (não esqueça que foi feita em 1982 <s>e provavelmente os primeiros pagers de tubo nixie) não foram capazes de exibir mais</s> ), e somente posteriormente foi adicionado suporte a mensagens ASCII.  Por causa das razões herdadas, o padrão de enquadramento não foi alterado e os desenvolvedores usaram a abordagem fácil - eles apenas combinaram os bits "como estão", um após o outro.  De cada mensagem, precisamos pegar 20 bits e mesclar para a próxima, finalmente podemos decodificar o corpo da mensagem. <br><br>  Vamos ver um bloco da nossa mensagem (os espaços foram acrescentados para facilitar a leitura): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  Bit “0” Na primeira string nos mostra que é o campo de endereço e “11” em 20-21 bits nos mostra que a mensagem é realmente alfanumérica.  Depois, pegamos 20 bits de cada string e os fundimos. <br><br>  Esta é a nossa sequência de bits: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  No POCSAG, o código ASCII de 7 bits é usado, portanto, dividimos uma string em 7 blocos de caracteres: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Depois de tentar decodificá-lo (a tabela ASCII pode ser facilmente encontrada na Internet), obtemos ... apenas nada.  Verificando o manual novamente, e aqui está a pequena frase "Os caracteres ASCII são colocados da esquerda para a direita (MSB para LSB).  O LSB está transmitindo primeiro. "  Portanto, o bit baixo está transmitindo primeiro - para a decodificação correta, precisamos reverter todas as strings. <br><br>  É muito chato fazê-lo manualmente, então vamos escrever um código Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Finalmente, estamos obtendo esta sequência (bits, códigos de símbolos e símbolos ASCII): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Após a fusão, obtemos a sequência: "(03-feb-2019 13:31:45 * 476) AWZ".  Como foi prometido, é bastante legível por humanos. <br><br>  A propósito, é interessante mencionar que códigos ASCII de 7 bits são usados.  Os símbolos de alguns alfabetos (alemão, cirílico, etc.) não podem ser codificados corretamente em 7 bits.  Por que 7 bits?  Provavelmente os engenheiros decidiram que "7 bits serão suficientes para todos", quem sabe ... <br><br><h2>  Conclusão </h2><br>  Foi realmente interessante investigar como o POCSAG funciona.  É um dos protocolos raros em uso até agora que pode literalmente ser decodificado na folha de papel (e eu definitivamente não tentarei isso com TETRA ou GSM). <br><br>  Com certeza, o protocolo POCSAG não está totalmente descrito aqui.  A parte mais importante e interessante é feita, outras coisas não são tão emocionantes.  Pelo menos, não há decodificação de códigos de captação e não há código de correção de erros (BCH Check Bits) - ele pode permitir corrigir até 2 bits errados na mensagem.  Mas não havia objetivo de escrever outro decodificador POCSAG aqui, já existem o suficiente. <br><br>  Para aqueles que desejam testar a decodificação real com o rtl-sdr, o aplicativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDW</a> freeware pode ser usado.  Não requer instalação, basta apenas encaminhar o som do HDSDR para o PDW por meio do aplicativo Virtual Audio Cable. <br><br>  Os resultados são assim: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (lembre-se de que a decodificação de mensagens de serviço público pode ser ilegal em alguns países e respeitar a privacidade dos destinatários) <br><br>  Se alguém quiser obter mais informações sobre este tópico, estão disponíveis fontes do decodificador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multimon-ng</a> , que pode decodificar muitos protocolos, também POCSAG e FLEX. <br><br>  Obrigado pela leitura. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438906/">https://habr.com/ru/post/pt438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438894/index.html">Por que o desenvolvimento web no Go é melhor do que no PHP</a></li>
<li><a href="../pt438896/index.html">Não chore negócios</a></li>
<li><a href="../pt438898/index.html">Instalação reversa e extensão do Chrome</a></li>
<li><a href="../pt438900/index.html">No caminho para os princípios físicos da evolução biológica. Fim + texto completo da tradução</a></li>
<li><a href="../pt438902/index.html">Usando DBREPLICATION ao recolher bancos de dados no Microsoft SQL Server</a></li>
<li><a href="../pt438908/index.html">Treinamento Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Dia 1. Noções básicas de rede</a></li>
<li><a href="../pt438910/index.html">Samba como ADDC no Solaris 11.4</a></li>
<li><a href="../pt438916/index.html">Notas de um fitoquímico. A batata. Parte três. "Bullet Fugu" ou SOLANIN</a></li>
<li><a href="../pt438920/index.html">Avalonia: primeiro encontro</a></li>
<li><a href="../pt438922/index.html">Criptografia de tráfego no Direct Connect, Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>