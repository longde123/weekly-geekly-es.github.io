<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèΩ üë®‚Äçüéì üë®‚Äçüé§ Compreendendo o protocolo de pagina√ß√£o POCSAG üö° üò≠ üë¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° muito tempo, quando um telefone celular custava cerca de US $ 2.000 e um minuto de chamada de voz era de 50 centavos, os pagers eram realmente popu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compreendendo o protocolo de pagina√ß√£o POCSAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  H√° muito tempo, quando um telefone celular custava cerca de US $ 2.000 e um minuto de chamada de voz era de 50 centavos, os pagers eram realmente populares.  Mais tarde, os telefones celulares ficaram mais baratos, os pre√ßos de chamadas e SMS ficaram mais baixos e, finalmente, os pagers desapareceram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Para pessoas que j√° possu√≠am um pager e desejam saber como ele funciona, este artigo ser√° √∫til. <br><a name="habracut"></a><br><h2>  Informa√ß√µes principais </h2><br>  Para as pessoas que esqueceram os princ√≠pios ou nasceram depois de 2000x, lembrarei as principais id√©ias em breve. <br><br>  A rede de comunica√ß√µes de pagina√ß√£o possui algumas vantagens, √†s vezes importantes at√© agora: <br><br>  - √â uma comunica√ß√£o unidirecional, sem qualquer tipo de confirma√ß√£o, para que a rede n√£o possa ser sobrecarregada - simplesmente n√£o depende de v√°rios usu√°rios.  As mensagens est√£o transmitindo continuamente "como est√£o", uma ap√≥s a outra, e o pager est√° recebendo a mensagem se seu n√∫mero (chamado Capcode) for igual ao n√∫mero interno do dispositivo. <br><br>  - O receptor √© muito leve (literal e eletronicamente) e pode funcionar at√© um m√™s com 2 pilhas AA. <br><br>  Existem dois padr√µes b√°sicos de transmiss√£o de mensagens - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">POCSAG</a> (Grupo Consultivo para Padroniza√ß√£o de C√≥digo Postal) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FLEX</a> .  Ambos os padr√µes s√£o bastante antigos, o POCSAG foi fabricado em 1982, pode suportar velocidades de 512, 1200 e 2400 bit / s.  Para transmitir o m√©todo FSK (chaveamento com mudan√ßa de frequ√™ncia) √© usado com uma separa√ß√£o de frequ√™ncia de 4,5KHz.  O FLEX √© um pouco mais recente (foi fabricado pela Motorola na d√©cada de 90), pode funcionar com velocidade de at√© 6400 bits / s e pode usar o FSK2 e o FSK4. <br><br>  Ambos os protocolos s√£o geralmente muito f√°ceis, e h√° cerca de 20 anos foram criados decodificadores de PC que podem decodificar mensagens de uma porta serial da placa de som (n√£o h√° criptografia suportada, para que todas as mensagens possam ser lidas por qualquer pessoa). <br><br>  Vamos dar uma olhada, como funciona. <br><br><h2>  Recebendo um sinal </h2><br>  Primeiro, precisamos de um sinal para decodificar.  Vamos pegar um laptop, receptor rtl-sdr, e peg√°-lo. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  A tecla de mudan√ßa de frequ√™ncia √© usada, ent√£o definiremos FM.  Com o HDSDR, salvaremos um sinal no formato WAV. <br><br>  Vamos verificar o que temos.  Carregando o arquivo wav como uma matriz de dados Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Sa√≠da (bits adicionados manualmente): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Como podemos ver, √© f√°cil e at√© "a olho nu" podemos desenhar bits no Paint, √© f√°cil distinguir onde √© "0" e onde √© "1".  Mas ser√° muito tempo para faz√™-lo manualmente, √© hora de automatizar o processo. <br><br>  Depois de ampliar o gr√°fico, podemos ver que cada bit tem uma largura de 20 amostras.  Temos um arquivo wav de taxa de bits de 24.000 amostras por segundo, portanto a velocidade de chaveamento √© de 1200 bits / s.  Vamos encontrar uma posi√ß√£o de cruzamento zero - √© o in√≠cio da sequ√™ncia de bits.  Permite tamb√©m adicionar marcadores para verificar se todos os bits est√£o em locais adequados. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Como podemos ver, n√£o √© perfeitamente compat√≠vel (transmissor e receptor t√™m ligeiras frequ√™ncias diferentes), mas √© definitivamente o suficiente para decodificar. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Para sinais longos, provavelmente precisaremos do algoritmo de corre√ß√£o autom√°tica de frequ√™ncia, mas para esse tipo de sinal n√£o √© cr√≠tico. <br><br>  O √∫ltimo passo - precisamos traduzir o arquivo wav para a sequ√™ncia de bits.  Tamb√©m √© f√°cil, sabemos o tamanho de cada bit; se a soma dos dados for positiva, adicionaremos ‚Äú1‚Äù, caso contr√°rio, ‚Äú0‚Äù (finalmente foi encontrado que um sinal precisa ser revertido, portanto, 0 e 1 foram substitu√≠dos) . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Sa√≠da - sequ√™ncia de bits adequada (em formato de string), que cont√©m nossa mensagem. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Decodificando mensagens somente num√©ricas </h2><br>  Uma sequ√™ncia de bits √© muito mais conveniente que um arquivo wav, podemos extrair dados dele.  Primeiro, vamos dividir os dados em blocos de 4 bytes. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Definitivamente, podemos ver um padr√£o.  Agora precisamos descobrir o que cada parte significa.  O manual do POCSAG est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em formato PDF</a> , permite verificar a descri√ß√£o da estrutura de dados. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Agora √© muito mais claro.  O cabe√ßalho cont√©m um bloco longo "10101010101", √© usado para "acordar" o pager no modo de suspens√£o.  A pr√≥pria mensagem cont√©m os blocos Lote-1 ... Lote-N, cada bloco est√° iniciando na sequ√™ncia exclusiva FSC.  Ent√£o, como podemos ver no manual, se a string come√ßar em "0", ela conter√° o endere√ßo do destinat√°rio.  O endere√ßo em si (capcode) √© armazenado √© o pager e, se n√£o corresponder, o pager ignorar√° a mensagem.  Se uma sequ√™ncia come√ßar em "1", ela conter√° o corpo da mensagem.  No nosso exemplo, temos 2 strings desse tipo. <br><br>  N√£o vamos verificar cada bloco.  Tamb√©m podemos ver c√≥digos inativos - blocos vazios 01111 ... 0111, eles n√£o possuem nenhuma informa√ß√£o √∫til.  Depois de remov√™-los, obtemos apenas isso: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Precisamos descobrir o que h√° dentro. <br><br>  Depois de verificar o manual, fica claro que existem dois tipos de mensagens - <b>somente</b> <b>num√©rico e alfanum√©rico</b> .  As mensagens apenas num√©ricas s√£o salvas como c√≥digos BCD de 4 bits, ent√£o 20 bits podem conter 5 s√≠mbolos (tamb√©m existem bits CRC, n√£o os estamos usando no momento).  Se a mensagem for alfanum√©rica, ser√° usada a codifica√ß√£o ASCII de 7 bits.  Esta mensagem √© muito curta e, portanto, pode ser apenas uma mensagem num√©rica. <br><br>  A partir das seq√º√™ncias 10000011010000010101010011010100 e 11110101010001000001000000111000, podemos obter essas sequ√™ncias de 4 bits: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Ah Ah 8h 8h 2h <br><br>  O pr√≥ximo passo √© obter a tabela de decodifica√ß√£o no manual: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  √â √≥bvio que uma mensagem apenas num√©rica pode conter d√≠gitos de 0 a 9, letra U ("ugrent"), espa√ßo e dois par√™nteses.  Vamos escrever um pequeno m√©todo para decodific√°-lo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Finalmente, recebemos a mensagem "0682 *) * 882". <br><br>  √â dif√≠cil dizer o que significa, mas se as mensagens apenas num√©ricas forem usadas, algu√©m provavelmente precisar√° dela. <br><br><h2>  Decodificando mensagens alfanum√©ricas </h2><br>  O pr√≥ximo passo, e mais interessante, √© decodificar mensagens alfanum√©ricas.  √â mais interessante, porque, como sa√≠da, devemos obter o texto leg√≠vel por humanos. <br><br>  Primeiro, precisamos gravar uma mensagem novamente, usaremos o HDSDR.  Como n√£o conhecemos um tipo de mensagem antes da decodifica√ß√£o, gravamos apenas uma mensagem mais longa, podemos receb√™-la e esperamos que ela contenha algum texto. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Depois de converter de wav para uma sequ√™ncia de bits (veja um c√≥digo Python acima), estamos obtendo o seguinte: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Algumas coisas interessantes que podemos ver imediatamente, a olho nu - como por exemplo, a sequ√™ncia inicial 01010101010101 est√° repetindo duas vezes.  Assim, essa mensagem n√£o √© apenas mais longa, ela literalmente cont√©m duas mensagens, mescladas (um padr√£o n√£o est√° negando isso, btw). <br><br>  Como descobrimos antes, cada bloco de dados inicia a partir de uma sequ√™ncia, chamada Frame Sync Code (01111100 ...), ap√≥s o envio dos blocos de 32 bits.  Cada bloco pode armazenar o endere√ßo ou o corpo da mensagem. <br><br>  Antes receb√≠amos as mensagens apenas num√©ricas, agora queremos ler as mensagens ASCII.  Primeiro, precisamos distingui-los.  Esses dados s√£o salvos no campo "Bits de fun√ß√µes" (bits 20 a 21) - se os dois bits forem 00, ser√° uma mensagem apenas num√©rica, se os bits forem 11, ser√° uma mensagem de texto. <br><br>  √â interessante mencionar que esse campo de mensagem tem 20 bits, ent√£o √© ideal colocar cinco blocos de 4 bits no caso de uma mensagem apenas num√©rica.  Mas se tivermos uma mensagem ASCII de 7 bits, n√£o podemos dividir de 20 a 7. √â poss√≠vel prever que a primeira vers√£o do protocolo suporta apenas mensagens apenas num√©ricas (n√£o esque√ßa que foi feita em 1982 <s>e provavelmente os primeiros pagers de tubo nixie) n√£o foram capazes de exibir mais</s> ), e somente posteriormente foi adicionado suporte a mensagens ASCII.  Por causa das raz√µes herdadas, o padr√£o de enquadramento n√£o foi alterado e os desenvolvedores usaram a abordagem f√°cil - eles apenas combinaram os bits "como est√£o", um ap√≥s o outro.  De cada mensagem, precisamos pegar 20 bits e mesclar para a pr√≥xima, finalmente podemos decodificar o corpo da mensagem. <br><br>  Vamos ver um bloco da nossa mensagem (os espa√ßos foram acrescentados para facilitar a leitura): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  Bit ‚Äú0‚Äù Na primeira string nos mostra que √© o campo de endere√ßo e ‚Äú11‚Äù em 20-21 bits nos mostra que a mensagem √© realmente alfanum√©rica.  Depois, pegamos 20 bits de cada string e os fundimos. <br><br>  Esta √© a nossa sequ√™ncia de bits: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  No POCSAG, o c√≥digo ASCII de 7 bits √© usado, portanto, dividimos uma string em 7 blocos de caracteres: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Depois de tentar decodific√°-lo (a tabela ASCII pode ser facilmente encontrada na Internet), obtemos ... apenas nada.  Verificando o manual novamente, e aqui est√° a pequena frase "Os caracteres ASCII s√£o colocados da esquerda para a direita (MSB para LSB).  O LSB est√° transmitindo primeiro. "  Portanto, o bit baixo est√° transmitindo primeiro - para a decodifica√ß√£o correta, precisamos reverter todas as strings. <br><br>  √â muito chato faz√™-lo manualmente, ent√£o vamos escrever um c√≥digo Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Finalmente, estamos obtendo esta sequ√™ncia (bits, c√≥digos de s√≠mbolos e s√≠mbolos ASCII): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Ap√≥s a fus√£o, obtemos a sequ√™ncia: "(03-feb-2019 13:31:45 * 476) AWZ".  Como foi prometido, √© bastante leg√≠vel por humanos. <br><br>  A prop√≥sito, √© interessante mencionar que c√≥digos ASCII de 7 bits s√£o usados.  Os s√≠mbolos de alguns alfabetos (alem√£o, cir√≠lico, etc.) n√£o podem ser codificados corretamente em 7 bits.  Por que 7 bits?  Provavelmente os engenheiros decidiram que "7 bits ser√£o suficientes para todos", quem sabe ... <br><br><h2>  Conclus√£o </h2><br>  Foi realmente interessante investigar como o POCSAG funciona.  √â um dos protocolos raros em uso at√© agora que pode literalmente ser decodificado na folha de papel (e eu definitivamente n√£o tentarei isso com TETRA ou GSM). <br><br>  Com certeza, o protocolo POCSAG n√£o est√° totalmente descrito aqui.  A parte mais importante e interessante √© feita, outras coisas n√£o s√£o t√£o emocionantes.  Pelo menos, n√£o h√° decodifica√ß√£o de c√≥digos de capta√ß√£o e n√£o h√° c√≥digo de corre√ß√£o de erros (BCH Check Bits) - ele pode permitir corrigir at√© 2 bits errados na mensagem.  Mas n√£o havia objetivo de escrever outro decodificador POCSAG aqui, j√° existem o suficiente. <br><br>  Para aqueles que desejam testar a decodifica√ß√£o real com o rtl-sdr, o aplicativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDW</a> freeware pode ser usado.  N√£o requer instala√ß√£o, basta apenas encaminhar o som do HDSDR para o PDW por meio do aplicativo Virtual Audio Cable. <br><br>  Os resultados s√£o assim: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (lembre-se de que a decodifica√ß√£o de mensagens de servi√ßo p√∫blico pode ser ilegal em alguns pa√≠ses e respeitar a privacidade dos destinat√°rios) <br><br>  Se algu√©m quiser obter mais informa√ß√µes sobre este t√≥pico, est√£o dispon√≠veis fontes do decodificador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multimon-ng</a> , que pode decodificar muitos protocolos, tamb√©m POCSAG e FLEX. <br><br>  Obrigado pela leitura. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438906/">https://habr.com/ru/post/pt438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438894/index.html">Por que o desenvolvimento web no Go √© melhor do que no PHP</a></li>
<li><a href="../pt438896/index.html">N√£o chore neg√≥cios</a></li>
<li><a href="../pt438898/index.html">Instala√ß√£o reversa e extens√£o do Chrome</a></li>
<li><a href="../pt438900/index.html">No caminho para os princ√≠pios f√≠sicos da evolu√ß√£o biol√≥gica. Fim + texto completo da tradu√ß√£o</a></li>
<li><a href="../pt438902/index.html">Usando DBREPLICATION ao recolher bancos de dados no Microsoft SQL Server</a></li>
<li><a href="../pt438908/index.html">Treinamento Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Dia 1. No√ß√µes b√°sicas de rede</a></li>
<li><a href="../pt438910/index.html">Samba como ADDC no Solaris 11.4</a></li>
<li><a href="../pt438916/index.html">Notas de um fitoqu√≠mico. A batata. Parte tr√™s. "Bullet Fugu" ou SOLANIN</a></li>
<li><a href="../pt438920/index.html">Avalonia: primeiro encontro</a></li>
<li><a href="../pt438922/index.html">Criptografia de tr√°fego no Direct Connect, Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>