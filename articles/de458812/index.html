<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø üë©‚ÄçüöÄ üë©‚Äçüëß JVM TI: Wie erstelle ich ein Plugin f√ºr eine virtuelle Maschine? üçï üï∑Ô∏è üëâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√∂chten Sie der JVM einige n√ºtzliche Funktionen hinzuf√ºgen? Theoretisch kann jeder Entwickler zu OpenJDK beitragen. In der Praxis sind jedoch nicht tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI: Wie erstelle ich ein Plugin f√ºr eine virtuelle Maschine?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  M√∂chten Sie der JVM einige n√ºtzliche Funktionen hinzuf√ºgen?  Theoretisch kann jeder Entwickler zu OpenJDK beitragen. In der Praxis sind jedoch nicht triviale √Ñnderungen an HotSpot von der Seite nicht sehr willkommen. Selbst bei dem derzeit verk√ºrzten Ver√∂ffentlichungszyklus kann es Jahre dauern, bis JDK-Benutzer Ihre Funktion sehen. <br><br>  In einigen F√§llen ist es jedoch m√∂glich, die Funktionalit√§t einer virtuellen Maschine zu erweitern, ohne ihren Code zu ber√ºhren.  Die JVM-Tool-Schnittstelle, die Standard-API f√ºr die Interaktion mit der JVM, hilft. <br><br>  In dem Artikel werde ich anhand konkreter Beispiele zeigen, was damit gemacht werden kann, was sich in Java 9 und 11 ge√§ndert hat, und ehrlich vor den Schwierigkeiten warnen (Spoiler: Ich muss mich mit C ++ befassen). <br><br>  Ich habe auch √ºber dieses Material auf JPoint gesprochen.  Wenn Sie das Video bevorzugen, k√∂nnen Sie den Videobericht ansehen. <br><a name="habracut"></a><br><h2>  Eintrag </h2><br>  Das soziale Netzwerk Odnoklassniki, in dem ich als f√ºhrender Ingenieur arbeite, ist fast ausschlie√ülich in Java geschrieben.  Aber heute erz√§hle ich Ihnen nur einen anderen Teil, der nicht vollst√§ndig in Java ist. <br><br>  Wie Sie wissen, ist NullPointerException das beliebteste Problem bei Java-Entwicklern.  Einmal bin ich im Dienst auf dem Portal auf NPE in der Produktion gesto√üen.  Der Fehler wurde von so etwas wie dieser Stapelverfolgung begleitet: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Nat√ºrlich k√∂nnen Sie in der Stapelverfolgung den Ort, an dem die Ausnahme aufgetreten ist, bis zu einer bestimmten Zeile im Code verfolgen.  Nur in diesem Fall habe ich mich nicht besser gef√ºhlt, denn hier kann NPE viel treffen, wo: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  Es w√§re gro√üartig, wenn die JVM genau vorschlagen w√ºrde, wo dieser Fehler beispielsweise so ist: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  Leider enth√§lt NPE jetzt nichts dergleichen.  Obwohl sie schon lange danach gefragt haben, zumindest mit Java 1.4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Fehler</a> ist 16 Jahre alt.  In regelm√§√üigen Abst√§nden wurden immer mehr Fehler zu diesem Thema ge√∂ffnet, die jedoch ausnahmslos als "Won't Fix" geschlossen wurden: <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  Das passiert nicht √ºberall.  Volker Simonis von SAP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erz√§hlte,</a> wie sie diese Funktion schon lange in SAP JVM implementiert hatten, und half ihr mehr als einmal.  Ein anderer SAP-Mitarbeiter hat erneut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen</a> Fehler in OpenJDK gemeldet und sich freiwillig bereit erkl√§rt, einen Mechanismus zu implementieren, der dem in der SAP JVM √§hnelt.  Und siehe da, diesmal wurde der Fehler nicht geschlossen - es besteht die M√∂glichkeit, dass diese Funktion in JDK 14 eingeht. <br><br>  Aber wann wird JDK 14 ver√∂ffentlicht und wann werden wir darauf umsteigen?  Was tun, wenn Sie das Problem hier und jetzt untersuchen m√∂chten? <br><br>  Sie k√∂nnen nat√ºrlich Ihre OpenJDK-Gabel beibehalten.  Die NPE-Berichtsfunktion selbst ist nicht so kompliziert, wir h√§tten sie sehr gut implementieren k√∂nnen.  Gleichzeitig gibt es jedoch alle Probleme, Ihre eigene Baugruppe zu unterst√ºtzen.  Es w√§re gro√üartig, die Funktion einmal zu implementieren und sie dann einfach als Plugin mit einer beliebigen Version der JVM zu verbinden.  Und das ist wirklich m√∂glich!  Die JVM verf√ºgt √ºber eine spezielle API (urspr√ºnglich f√ºr alle Arten von Debuggern und Profilern entwickelt): JVM Tool Interface. <br><br>  Am wichtigsten ist, dass diese API Standard ist.  Er hat eine strenge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> , und wenn Sie eine entsprechende Funktion implementieren, k√∂nnen Sie sicher sein, dass sie in neuen Versionen der JVM funktioniert. <br><br>  Um diese Schnittstelle verwenden zu k√∂nnen, m√ºssen Sie ein kleines (oder gro√ües, je nach Ihren Aufgaben) Programm schreiben.  Native: Normalerweise ist es in C oder C ++ geschrieben.  Die Standard-JDK- <code>jdk/include/jvmti.h</code> verf√ºgt √ºber eine Header-Datei <code>jdk/include/jvmti.h</code> , die Sie einschlie√üen m√∂chten. <br><br>  Das Programm wird in eine dynamische Bibliothek kompiliert und beim Start der JVM √ºber den Parameter <code>-agentpath</code> verbunden.  Es ist wichtig, es nicht mit einem anderen √§hnlichen Parameter zu verwechseln: <code>-javaagent</code> .  Tats√§chlich sind Java-Agenten ein Sonderfall von JVM-TI-Agenten.  Weiter im Text unter dem Wort "Agent" ist genau der native Agent gemeint. <br><br><h2>  Wo soll ich anfangen? </h2><br>  Lassen Sie uns in der Praxis sehen, wie man den einfachsten JVM-TI-Agenten schreibt, eine Art "Hallo Welt". <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  In der ersten Zeile f√ºge ich die gleiche Header-Datei hinzu.  Als n√§chstes kommt die Hauptfunktion, die im Agenten implementiert werden muss: <code>Agent_OnLoad()</code> .  Die virtuelle Maschine selbst ruft es beim <code>JavaVM*</code> des Agenten auf und √ºbergibt einen Zeiger auf das <code>JavaVM*</code> -Objekt. <br><br>  Mit ihm k√∂nnen Sie einen Zeiger auf die JVM TI-Umgebung erhalten: <code>jvmtiEnv*</code> .  Und rufen Sie dadurch wiederum bereits JVM TI-Funktionen auf.  Lesen Sie beispielsweise mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GetSystemProperty</a> den Wert einer Systemeigenschaft. <br><br>  Wenn ich jetzt diese "Hallo Welt" <code>-agentpath</code> und die kompilierte DLL-Datei an <code>-agentpath</code> , wird die von unserem Agenten gedruckte Zeile in der Konsole <code>-agentpath</code> , bevor das Java-Programm ausgef√ºhrt wird: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  Anreicherung NPE </h2><br>  Da die Hallo Welt nicht das interessanteste Beispiel ist, kehren wir zu unseren Ausnahmen zur√ºck.  Der vollst√§ndige Agentencode, der NPE-Berichte erg√§nzt, befindet sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> . <br><br>  So sieht <code>Agent_OnLoad()</code> aus, wenn ich die virtuelle Maschine bitten m√∂chte, uns √ºber alle Ausnahmen zu informieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Zuerst frage ich die JVM TI nach der entsprechenden Funktion (can_generate_exception_events).  Wir werden die F√§higkeit separat besprechen. <br><br>  Der n√§chste Schritt ist das Abonnieren der Ausnahmeereignisse.  Immer wenn die JVM Ausnahmen ausl√∂st (egal ob sie abgefangen werden oder nicht), wird unsere <code>ExceptionCallback()</code> -Funktion aufgerufen. <br><br>  Der letzte Schritt besteht darin, <code>SetEventNotificationMode()</code> , um die Zustellung von Benachrichtigungen zu erm√∂glichen. <br><br><div class="spoiler">  <b class="spoiler_title">In ExceptionCallback √ºbergibt die JVM alles, was wir zur Behandlung von Ausnahmen ben√∂tigen.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Hier gibt es sowohl das Objekt des Threads, der die Ausnahme ausgel√∂st hat (Thread), als auch den Ort, an dem dies passiert ist (Methode, Speicherort), und das Objekt der Ausnahme (Ausnahme) und sogar den Ort im Code, der diese Ausnahme abf√§ngt (catch_method, catch_location). <br><br>  Was wichtig ist: In diesem R√ºckruf wird neben dem Zeiger auf die JVM-TI-Umgebung auch die JNI-Umgebung (env) √ºbergeben.  Dies bedeutet, dass wir alle darin enthaltenen JNI-Funktionen verwenden k√∂nnen.  Das hei√üt, JVM TI und JNI koexistieren perfekt und erg√§nzen sich. <br><br>  In meinem Agenten verwende ich beide.  Insbesondere √ºberpr√ºfe ich √ºber JNI, ob meine Ausnahme vom Typ <code>NullPointerException</code> , und ersetze dann das Feld <code>detailMessage</code> eine Fehlermeldung. <br><br>  Da die JVM selbst uns den Speicherort √ºbergibt - den Bytecode-Index, f√ºr den die Ausnahme aufgetreten ist, habe ich diesen Speicherort hier in die Nachricht eingef√ºgt: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  Die Nummer 66 gibt den Index im Bytecode an, bei dem diese Ausnahme aufgetreten ist.  Die manuelle Analyse des Bytecodes ist jedoch trostlos: Sie m√ºssen die Klassendatei dekompilieren, nach der 66. Anweisung suchen und versuchen zu verstehen, was sie tat ... Es w√§re gro√üartig, wenn unser Agent selbst etwas besser lesbares zeigen k√∂nnte. <br><br>  In diesem Fall bietet die JVM TI jedoch alles, was Sie ben√∂tigen.  Richtig, Sie m√ºssen zus√§tzliche Funktionen der JVM TI anfordern: Bytecode abrufen und Konstantenpoolmethode. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Jetzt werde ich ExceptionCallback erweitern: √úber die JVM-TI-Funktion <code>GetBytecodes()</code> ich den Hauptteil der Methode, um anhand des Standortindex zu √ºberpr√ºfen, was darin enthalten ist.  Als n√§chstes folgt eine gro√üe Anweisung f√ºr den Switch-Bytecode: Wenn dies ein Zugriff auf das Array ist, wird eine Fehlermeldung angezeigt, wenn der Zugriff auf das Feld eine andere Meldung ist, wenn der Methodenaufruf der dritte ist und so weiter. <br><br><div class="spoiler">  <b class="spoiler_title">ExceptionCallback-Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  Es bleibt nur der Name des Feldes oder der Methode zu ersetzen.  Sie k√∂nnen es aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">konstanten Pool beziehen</a> , der dank der JVM TI wieder verf√ºgbar ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  Als n√§chstes kommt ein bisschen Magie, aber in Wirklichkeit nichts Schwieriges. Nur gem√§√ü <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Spezifikation des</a> Klassendateiformats analysieren wir den konstanten Pool und isolieren von dort aus die Zeile - den Namen der Methode. <br><br><div class="spoiler">  <b class="spoiler_title">Konstante Poolanalyse</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Ein weiterer wichtiger Punkt: Einige JVM-TI-Funktionen, z. B. <code>GetConstantPool()</code> oder <code>GetBytecodes()</code> , weisen eine bestimmte Struktur im nativen Speicher zu, die freigegeben werden muss, wenn Sie mit der Arbeit fertig sind. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  F√ºhren Sie das Quellprogramm mit unserem erweiterten Agenten aus, und hier ist eine v√∂llig andere Beschreibung der Ausnahme: Es wird berichtet, dass wir die longValue () -Methode f√ºr das Null-Objekt aufgerufen haben. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Andere Anwendungen </h2><br>  Im Allgemeinen m√∂chten Entwickler Ausnahmen h√§ufig auf ihre eigene Weise behandeln.  <code>StackOverflowError</code> Sie beispielsweise die JVM automatisch neu, wenn ein <code>StackOverflowError</code> . <br><br>  Dieser Wunsch kann verstanden werden, da <code>StackOverflowError</code> derselbe schwerwiegende Fehler wie <code>OutOfMemoryError</code> und es nach seinem Auftreten nicht mehr m√∂glich ist, den korrekten Betrieb des Programms zu gew√§hrleisten.  Um das Problem zu analysieren, m√∂chte ich beispielsweise manchmal einen Thread-Dump oder Heap-Dump erhalten, wenn eine Ausnahme auftritt. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  Fairerweise hat das IBM JDK eine solche Chance sofort.  Jetzt wissen wir jedoch bereits, dass Sie mit dem JVM TI-Agenten dasselbe in HotSpot implementieren k√∂nnen.  Es reicht aus, einen Ausnahmer√ºckruf zu abonnieren und die Ausnahme zu analysieren.  Aber wie entferne ich Thread-Dump oder Heap-Dump von unserem Agenten?  Die JVM TI bietet alles, was Sie f√ºr diesen Fall ben√∂tigen: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  Es ist nicht sehr praktisch, den gesamten Mechanismus zum Umgehen des Heaps und zum Erstellen eines Speicherauszugs zu implementieren.  Aber ich werde das Geheimnis teilen, wie man es einfacher und schneller macht.  Dies ist zwar nicht mehr in der Standard-JVM-TI enthalten, sondern eine private Erweiterung von Hotspot. <br><br>  Sie m√ºssen die Header-Datei <a href="">jmm.h</a> von den HotSpot-Quellen verbinden und die Funktion <code>JVM_GetManagement()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  Es wird ein Zeiger auf die HotSpot-Verwaltungsschnittstelle zur√ºckgegeben, die in einem einzelnen Aufruf einen Heap-Dump oder Thread-Dump generiert.  Den vollst√§ndigen Code f√ºr das Beispiel finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Antwort</a> auf Stack Overflow. <br><br>  Nat√ºrlich k√∂nnen Sie nicht nur Ausnahmen behandeln, sondern auch eine Reihe anderer verschiedener Ereignisse im Zusammenhang mit der JVM-Operation: Starten / Stoppen von Threads, Laden von Klassen, Garbage Collection, Kompilieren von Methoden, Eingeben / Beenden von Methoden, sogar Zugreifen auf oder √Ñndern bestimmter Felder von Java-Objekten. <br><br>  Ich habe ein Beispiel f√ºr einen anderen <a href="">vmtrace-</a> Agenten, der viele Standard-JVM-TI-Ereignisse abonniert und protokolliert.  Wenn ich mit diesem Agenten ein einfaches Programm ausf√ºhre, erhalte ich ein detailliertes Protokoll, das anschlie√üend mit Zeitstempeln versehen ist: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  Wie Sie sehen k√∂nnen, werden zum einfachen Drucken der Hallo-Welt Hunderte von Klassen geladen, Dutzende und Hunderte von Methoden generiert und kompiliert.  Es wird klar, warum die Ausf√ºhrung von Java so lange dauert.  Alles an allem dauerte mehr als zweihundert Millisekunden. <br><br><h2>  Was JVM TI kann </h2><br>  Neben der Ereignisbehandlung verf√ºgt die JVM TI √ºber eine Reihe weiterer Funktionen.  Sie k√∂nnen in zwei Gruppen unterteilt werden. <br><br>  Eine ist obligatorisch, die jede JVM, die die JVM-TI unterst√ºtzt, implementieren muss.  Dazu geh√∂ren das Analysieren von Methoden, Feldern, Flows, das Hinzuf√ºgen neuer Klassen zum Klassenpfad usw. <br><br>  Es gibt optionale Funktionen, f√ºr die eine vorl√§ufige Funktionsanforderung erforderlich ist.  JVM muss nicht alle unterst√ºtzen, HotSpot implementiert jedoch die gesamte Spezifikation vollst√§ndig.  Optionale Funktionen sind in zwei Untergruppen unterteilt: diejenigen, die nur zu Beginn der JVM verbunden werden k√∂nnen (z. B. die M√∂glichkeit, einen Haltepunkt festzulegen oder lokale Variablen zu analysieren), und diejenigen, die jederzeit verbunden werden k√∂nnen (insbesondere Bytecode oder konstanter Pool, den ich oben verwendet). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  M√∂glicherweise stellen Sie fest, dass die Liste der Funktionen den Funktionen des Debuggers sehr √§hnlich ist.  Tats√§chlich ist ein Java-Debugger nichts anderes als ein Sonderfall des JVM-TI-Agenten, der alle diese Funktionen nutzt und alle Funktionen anfordert. <br><br>  Die Aufteilung der Funktionen in Funktionen, die jederzeit aktiviert werden k√∂nnen, und Funktionen, die nur zum Startzeitpunkt erfolgen, erfolgt absichtlich.  Nicht alle Funktionen sind kostenlos, einige tragen Overhead. <br><br>  Wenn mit den direkten Gemeinkosten, die mit der Verwendung der Funktion einhergehen, alles klar ist, gibt es noch weniger offensichtliche indirekte Gemeinkosten, die auftreten, selbst wenn Sie die Funktion nicht verwenden, sondern einfach durch Funktionen erkl√§ren, dass sie irgendwann in der Zukunft ben√∂tigt werden.  Dies liegt daran, dass die virtuelle Maschine den Code anders kompilieren oder der Laufzeit zus√§tzliche √úberpr√ºfungen hinzuf√ºgen kann. <br><br>  Beispielsweise f√ºhrt die bereits ber√ºcksichtigte F√§higkeit zum Abonnieren von Ausnahmen (can_generate_exception_events) dazu, dass alle ausl√∂senden Ausnahmen nur langsam ausgef√ºhrt werden.  Im Prinzip ist dies nicht so be√§ngstigend, da Ausnahmen in einem guten Java-Programm selten sind. <br><br>  Die Situation mit lokalen Variablen ist etwas schlimmer.  F√ºr can_access_local_variables, mit dem Sie jederzeit die Werte lokaler Variablen abrufen k√∂nnen, m√ºssen Sie einige wichtige Optimierungen deaktivieren.  Insbesondere die Escape-Analyse funktioniert nicht mehr, was zu einem sp√ºrbaren Overhead f√ºhren kann: Je nach Anwendung 5-10%. <br><br>  Daher die Schlussfolgerung: Wenn Sie Java mit aktiviertem Debug-Agenten ausf√ºhren, ohne es √ºberhaupt zu verwenden, werden Anwendungen langsamer ausgef√ºhrt.  Auf jeden Fall ist es keine gute Idee, einen Debugging-Agenten in die Produktion aufzunehmen. <br><br>  Eine Reihe von Funktionen, z. B. das Festlegen eines Haltepunkts oder das Verfolgen aller Ein- / Ausg√§nge einer Methode, sind mit einem viel gr√∂√üeren Aufwand verbunden.  Insbesondere funktionieren einige JVM-TI-Ereignisse (FieldAccess, MethodEntry / Exit) nur im Interpreter. <br><br><h2>  Ein Agent ist gut und zwei sind besser </h2><br>  Sie k√∂nnen mehrere Agenten mit einem einzigen Prozess verbinden, indem Sie einfach mehrere <code>-agentpath</code> Parameter <code>-agentpath</code> .  Jeder hat seine eigene JVM TI-Umgebung.  Dies bedeutet, dass jeder seine F√§higkeiten abonnieren und seine Ereignisse unabh√§ngig abfangen kann. <br><br>  Und wenn zwei Agenten das Haltepunktereignis abonniert haben und in einem der Haltepunkt in einer Methode festgelegt ist, erh√§lt der zweite Agent das Ereignis, wenn diese Methode ausgef√ºhrt wird? <br><br>  In der Realit√§t kann eine solche Situation nicht auftreten (zumindest in HotSpot JVM).  Weil es einige Funktionen gibt, die jeweils nur einer der Agenten besitzen kann.  Dazu geh√∂ren insbesondere breakpoint_events.  Wenn der zweite Agent dieselbe Funktion anfordert, erh√§lt er daher einen Fehler als Antwort. <br><br>  Dies ist eine wichtige Schlussfolgerung: Der Agent sollte immer das Ergebnis der Funktionsanforderung √ºberpr√ºfen, auch wenn Sie auf HotSpot ausgef√ºhrt werden und wissen, dass alle verf√ºgbar sind.  Die JVM TI-Spezifikation sagt nichts √ºber exklusive Funktionen aus, aber HotSpot verf√ºgt √ºber eine solche Implementierungsfunktion. <br><br>  Zwar funktioniert die Agentenisolation nicht immer perfekt.  W√§hrend der Entwicklung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async-Profilers</a> bin ich auf dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesto√üen</a> : Wenn zwei Agenten vorhanden sind und einer die Generierung von Methoden zur Methodenkompilierung anfordert, erhalten alle Agenten diese Ereignisse.  Nat√ºrlich habe ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler gemeldet</a> , aber Sie sollten bedenken, dass Ereignisse, die Sie nicht erwarten, in Ihrem Agenten auftreten k√∂nnen. <br><br><h2>  Verwendung in einem regul√§ren Programm </h2><br>  JVM TI scheint f√ºr Debugger und Profiler eine sehr spezifische Sache zu sein, kann aber auch in einem regul√§ren Java-Programm verwendet werden.  Betrachten Sie ein Beispiel. <br><br>  Das reaktive Programmierparadigma ist mittlerweile weit verbreitet, wenn alles asynchron ist, aber es gibt ein Problem mit diesem Paradigma. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  Ich f√ºhre zwei asynchrone Aufgaben aus, die sich nur in den Parametern unterscheiden.  Und wenn etwas schief geht, wird eine Ausnahme ausgel√∂st: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  Aus der Stapelverfolgung ist v√∂llig unklar, welche dieser Aufgaben das Problem verursacht haben.  Weil die Ausnahme in einem v√∂llig anderen Thread auftritt, in dem wir keinen Kontext haben.  Wie in welcher Aufgabe zu verstehen? <br><br>  Als eine der L√∂sungen k√∂nnen Sie dem Konstruktor unserer asynchronen Aufgabe Informationen dar√ºber hinzuf√ºgen, wo wir sie erstellt haben: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  Denken Sie also an den Speicherort - einen bestimmten Ort im Code bis zu der Zeile, von der aus der Konstruktor aufgerufen wurde.  Und im Falle einer Ausnahme, um es zu verpf√§nden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Wenn nun eine Ausnahme auftritt, sehen wir, dass dies in Zeile 14 im TaskRunner passiert ist (wo die Aufgabe mit dem Parameter BAD erstellt wird): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  Aber wie bekommt man die Stelle im Code, von der aus der Konstruktor aufgerufen wird?  Vor Java 9 gab es die einzig legale M√∂glichkeit, dies zu tun: Holen Sie sich einen Stack-Trace, √ºberspringen Sie einige irrelevante Frames, und etwas tiefer auf dem Stack befindet sich die Stelle, die unser Code aufgerufen hat. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  Aber es gibt ein Problem.  Das vollst√§ndige StackTrace zu erhalten ist ziemlich langsam.  Ich habe einen ganzen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> dar√ºber. <br><br>  Dies w√§re kein so gro√ües Problem, wenn es selten passieren w√ºrde.  Zum Beispiel haben wir einen Webdienst - ein Frontend, das HTTP-Anfragen akzeptiert.  Dies ist eine gro√üartige Anwendung, Millionen von Codezeilen.  Und um Renderfehler abzufangen, verwenden wir einen √§hnlichen Mechanismus: In den Komponenten f√ºr das Rendern erinnern wir uns an den Ort, an dem sie erstellt wurden.  Wir haben Millionen solcher Komponenten, sodass das Abrufen aller Stapelspuren eine konkrete Zeit in Anspruch nimmt, um die Anwendung zu starten, und nicht nur eine Minute.  Daher war diese Funktion zuvor in der Produktion deaktiviert, obwohl sie zur Analyse von Problemen in der Produktion ben√∂tigt wird. <br><br>  Java 9 hat eine neue Methode zur Umgehung von Stream-Stacks eingef√ºhrt: StackWalker, der √ºber die Stream-API all dies bei Bedarf tr√§ge ausf√ºhren kann.  Das hei√üt, wir k√∂nnen die richtige Anzahl von Frames √ºberspringen und nur einen erhalten, der uns interessiert. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  Es funktioniert ein wenig besser als das Abrufen des vollst√§ndigen Stack-Trace, jedoch nicht um eine Gr√∂√üenordnung oder sogar um ein Vielfaches.  In unserem Fall stellte sich heraus, dass es ungef√§hr eineinhalb Mal schneller war: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  Es ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> mit der suboptimalen Implementierung von StackWalker bekannt, das h√∂chstwahrscheinlich sogar in JDK 13 behoben wird. Aber was sollten wir jetzt in Java 8 tun, wo StackWalker nicht einmal langsam ist? <br><br>  Die JVM TI kommt wieder zur Rettung.  Es gibt eine <code>GetStackTrace()</code> -Funktion, die alles kann, was Sie brauchen: ein Fragment eines Stack-Trace einer bestimmten L√§nge ab dem angegebenen Frame <code>GetStackTrace()</code> und nichts weiter tun. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  Es bleibt nur noch eine Frage: Wie rufe ich die JVM TI-Funktion von unserem Java-Programm aus auf?  Wie bei jeder anderen nativen Methode: Laden Sie die native Bibliothek mit <code>System.loadLibrary()</code> , wo sich die JNI-Implementierung unserer Methode befindet. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  Ein Zeiger auf die JVM-TI-Umgebung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> nicht nur von Agent_OnLoad () <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abgerufen werden</a> , sondern auch, w√§hrend das Programm ausgef√ºhrt wird, und um es weiterhin mit normalen nativen JNI-Methoden zu verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Ansatz ist bereits um ein Vielfaches schneller und erm√∂glichte es uns, einige Minuten beim Starten der Anwendung zu sparen: </font></font><br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig, beim n√§chsten JDK-Update waren wir √ºberrascht, dass die Anwendung pl√∂tzlich sehr, sehr langsam gestartet wurde. Die Untersuchung f√ºhrte zu der sehr nativen Bibliothek f√ºr den Empfang von Stapelspuren. Als wir verstanden, kamen wir zu dem Schluss, dass der Fehler nicht an unserer Stelle, sondern im JDK auftrat. Ab dem JDK 8u112 sind alle JVM-TI-Funktionen, die mit Methoden arbeiten (GetMethodName, GetMethodDeclaringClass usw.), sehr langsam geworden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gestartet </font><font style="vertical-align: inherit;">, ein wenig recherchiert und eine lustige Geschichte entdeckt: Einige JVM TI-Funktionen haben Debugging-Pr√ºfungen hinzugef√ºgt, aber nicht bemerkt, dass sie auch aus dem Produktionscode aufgerufen wurden. Dieses Verwendungsszenario wurde nicht gefunden, da es nicht im Quellcode in C ++, sondern in der Datei enthalten war</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jvmtiEnter.xsl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor: W√§hrend der Kompilierung von HotSpot wird ein Teil des Quellcodes im laufenden Betrieb durch die XSLT-Transformation generiert. </font><font style="vertical-align: inherit;">Auf diese Weise schlug Enterprise HotSpot zur√ºck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was k√∂nnte die L√∂sung sein? </font><font style="vertical-align: inherit;">Rufen Sie diese Funktionen nur nicht zu oft auf, sondern versuchen Sie, die Ergebnisse zwischenzuspeichern. </font><font style="vertical-align: inherit;">Das hei√üt, wenn f√ºr einige jmethodID-Informationen Informationen empfangen wurden, merken Sie sich diese lokal in Ihrem Agenten. </font><font style="vertical-align: inherit;">Durch Anwenden eines solchen Cachings auf Agentenebene haben wir die Leistung auf die vorherige Ebene zur√ºckgesetzt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamische Verbindung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als vorheriges Beispiel habe ich gezeigt, dass JVM TI direkt aus Java-Code mit gew√∂hnlichen nativen Methoden verwendet werden kann </font></font><code>System.loadLibrary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus haben wir bereits gesehen, wie JVM-TI-Agenten </font></font><code>-agentpath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Starten der JVM verbunden werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es gibt noch einen weiteren dritten Weg: das dynamische Anh√§ngen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist die Idee? Wenn Sie die Anwendung gestartet haben und nicht dachten, dass Sie in Zukunft eine Funktion ben√∂tigen w√ºrden, oder wenn Sie pl√∂tzlich einen Fehler in der Produktion untersuchen m√ºssen, k√∂nnen Sie den JVM TI-Agenten direkt zur Laufzeit herunterladen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ab JDK 9 wird dies direkt √ºber die Befehlszeile mit dem Dienstprogramm jcmd erm√∂glicht:</font></font><br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und f√ºr √§ltere Versionen von JDK k√∂nnen Sie mein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jattach-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienstprogramm verwenden </font><font style="vertical-align: inherit;">. Zum Beispiel kann der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async-Profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Verbindung zu Anwendungen herstellen, die ohne zus√§tzliche JVM-Argumente ausgef√ºhrt werden, auch dank jattach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die M√∂glichkeit einer dynamischen Verbindung in Ihrem JVM TI-Agenten nutzen zu k√∂nnen, m√ºssen Sie zus√§tzlich </font></font><code>Agent_OnLoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine √§hnliche Funktion implementieren </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der einzige Unterschied: </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die Funktionen nicht verwenden, die nur zum Startzeitpunkt des Agenten verf√ºgbar sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig zu beachten, dass Sie dieselbe Bibliothek mehrmals dynamisch verbinden k√∂nnen, damit sie </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiederholt aufgerufen werden kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde anhand eines Beispiels demonstrieren. </font><font style="vertical-align: inherit;">IntelliJ IDEA wird die Rolle der Produktion √ºbernehmen: Dies ist auch eine Java-Anwendung, dh wir k√∂nnen uns auch im laufenden Betrieb mit ihr verbinden und etwas unternehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Prozess-ID unserer IDEA finden und dann mit dem Dienstprogramm jattach die JI-Bibliothek der patcher.dll-TI-Bibliothek mit diesem Prozess verbinden: </font></font><br> <code>jattach 8648 load patcher.dll true</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und </font><font style="vertical-align: inherit;">sofort hat sie die Men√ºfarbe </font><font style="vertical-align: inherit;">in rot ge√§ndert: </font></font><br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht dieser Agent? </font><font style="vertical-align: inherit;">Findet alle Java-Objekte der angegebenen Klasse ( </font></font><code>javax.swing.AbstractButton</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und ruft die JNI-Methode auf </font></font><code>setBackground()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Den vollst√§ndigen Code finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist neu in Java 9? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM TI existiert seit langer Zeit und trotz der vorhandenen Fehler gibt es bereits eine etablierte Debug-API, die sich seit langem nicht ge√§ndert hat. Die ersten bedeutenden Neuerungen wurden in Java 9 ver√∂ffentlicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie wissen, brachte Java 9 Entwicklern die mit Modulen verbundenen Schmerzen und Leiden. Erstens ist es schwierig geworden, die "Geheimnisse" von JDK zu nutzen, ohne die manchmal im Prinzip nicht auskommt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im JDK gibt es beispielsweise keine legale M√∂glichkeit, Direct ByteBuffer zu l√∂schen. Nur √ºber eine private API: </font></font><br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, in Cassandra gibt es keinen Ort ohne diese Funktion, da die gesamte DBMS-Arbeit auf der Arbeit mit MappedByteBuffer basiert. Wenn Sie sie nicht manuell l√∂schen, st√ºrzt die JVM schnell ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie versuchen, denselben Code unter JDK 9 auszuf√ºhren, erhalten Sie IllegalAccessError:</font></font><br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Situation bei Reflection ist ungef√§hr dieselbe: Es ist schwierig geworden, private Felder zu erreichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise sind nicht alle Dateivorg√§nge unter Linux in Java verf√ºgbar. </font><font style="vertical-align: inherit;">Daher haben Programmierer f√ºr Linux-spezifische Funktionen den </font></font><code>java.io.FileDescriptor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemdateideskriptor </font><font style="vertical-align: inherit;">durch Reflektion </font><font style="vertical-align: inherit;">und Verwendung von JNI </font><font style="vertical-align: inherit;">aus dem Objekt abgerufen, </font><font style="vertical-align: inherit;">wobei einige Systemfunktionen darauf aufgerufen wurden. </font><font style="vertical-align: inherit;">Und jetzt, wenn Sie dies unter JDK 9 ausf√ºhren, werden Sie Fl√ºche in den Protokollen sehen: </font></font><br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich gibt es JVM-Flags, die die erforderlichen privaten Module √∂ffnen und es Ihnen erm√∂glichen, private Klassen und Reflektionen zu verwenden. </font><font style="vertical-align: inherit;">Sie m√ºssen jedoch alle Pakete, die Sie verwenden m√∂chten, manuell registrieren. </font><font style="vertical-align: inherit;">Um beispielsweise Cassandra nur auf Java 11 auszuf√ºhren, m√ºssen Sie ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Banner </font><font style="vertical-align: inherit;">registrieren </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammen mit den Modulen wurden jedoch </font><font style="vertical-align: inherit;">JVM TI- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr die Arbeit mit ihnen angezeigt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetAllModules </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddModuleExports </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddModuleOpens </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich diese Liste ansehen, bietet sich die L√∂sung an: Sie k√∂nnen warten, bis die JVM geladen ist, eine Liste aller Module abrufen, alle Pakete durchgehen, alles f√ºr alle √∂ffnen und genie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist das gleiche Beispiel mit Direct ByteBuffer:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir es ohne Agenten ausf√ºhren, erwarten wir einen IllegalAccessError. </font><font style="vertical-align: inherit;">Und wenn Sie dem Agentenpfad einen von mir geschriebenen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antimodul-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agenten </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hinzuf√ºgen</font></a><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">funktioniert</font></a><font style="vertical-align: inherit;"> das Beispiel fehlerfrei. </font><font style="vertical-align: inherit;">Gleiches gilt f√ºr Reflexion.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist neu in Java 11? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Neuerung erschien in Java 11. Es ist nur eine, aber was f√ºr eine! Es besteht die M√∂glichkeit einer einfachen Profilerstellung f√ºr Zuordnungen: Es wurde ein neues Ereignis hinzugef√ºgt </font></font><code>SampledObjectAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Sie abonnieren k√∂nnen, damit selektive Benachrichtigungen √ºber Zuordnungen erfolgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles, was f√ºr die weitere Analyse ben√∂tigt wird, wird an den R√ºckruf √ºbertragen: der zuzuweisende Thread, das ausgew√§hlte Objekt selbst, seine Klasse, Gr√∂√üe. Eine andere Methode </font></font><code>SetHeapSampingInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, die H√§ufigkeit zu √§ndern, mit der diese Benachrichtigungen eingehen.</font></font><br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br>  Warum wird das ben√∂tigt?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocation Profiling war fr√ºher in allen g√§ngigen Profilern, arbeitete jedoch mit Instrumenten, die mit hohem Overhead behaftet sind. Das einzige Profiling-Tool mit geringem Overhead war der Java Flight Recorder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee der neuen Methode besteht darin, nicht alle Zuordnungen zu instrumentieren, sondern nur einige davon, mit anderen Worten, zu testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im schnellsten und h√§ufigsten Fall erfolgt die Zuweisung innerhalb des lokalen Thread-Zuordnungspuffers durch einfaches Erh√∂hen des Zeigers. Und mit der Aufnahme der Abtastung in TLAB wird eine virtuelle Grenze hinzugef√ºgt, die der Abtastfrequenz entspricht. Sobald die n√§chste Zuordnung diese Grenze √ºberschreitet, wird ein Ereignis √ºber die Zuordnung des Objekts gesendet.</font></font><br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einigen F√§llen werden gro√üe Objekte, die nicht in TLAB passen, direkt im Heap zugewiesen. Solche Objekte gehen auch den langsamen Zuordnungspfad durch die JVM-Laufzeit und werden ebenfalls abgetastet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund der Tatsache, dass die Probenahme jetzt nur f√ºr einige Objekte durchgef√ºhrt wird, ist der Overhead f√ºr die Produktion bereits akzeptabel - in den meisten F√§llen weniger als 5%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessanterweise ist diese Funktion seit der Zeit von JDK 7 vor langer Zeit speziell f√ºr Flight Recorder entwickelt worden. √úber die private Hotspot-API hat dies jedoch auch der Async-Profiler verwendet. Und jetzt, beginnend mit JDK 11, ist diese API √∂ffentlich geworden, hat die JVM-TI eingegeben und andere Profiler k√∂nnen sie verwenden. Insbesondere wei√ü YourKit bereits wie. Informationen zur Verwendung dieser API finden Sie in dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in unserem Repository.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Profiler k√∂nnen Sie sch√∂ne Zuordnungsdiagramme erstellen. </font><font style="vertical-align: inherit;">Beobachten Sie, welche Objekte hervorstechen, wie viele von ihnen hervorstechen und vor allem wo.</font></font><br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM TI ist eine gro√üartige M√∂glichkeit, mit einer virtuellen Maschine zu interagieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C oder C ++ geschriebene Plugins k√∂nnen beim Start der JVM gestartet oder direkt w√§hrend der Ausf√ºhrung der Anwendung dynamisch verbunden werden. </font><font style="vertical-align: inherit;">Dar√ºber hinaus kann die Anwendung selbst die JVM-TI-Funktionen √ºber native Methoden verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle gezeigten Beispiele werden in unserem Repository </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf GitHub ver√∂ffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verwenden, studieren und Fragen stellen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458812/">https://habr.com/ru/post/de458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458798/index.html">N√§hrstoff-Bot oder wie ich Brot von Fitnesstrainern nehmen m√∂chte</a></li>
<li><a href="../de458800/index.html">Tiefes Lernen. F√∂deriertes Lernen</a></li>
<li><a href="../de458804/index.html">Zusammenfassung der Artikel √ºber maschinelles Lernen und k√ºnstliche Intelligenz</a></li>
<li><a href="../de458808/index.html">Habr Postmortem-Bericht: Zeitung fiel</a></li>
<li><a href="../de458810/index.html">Corel und Parallels wurden aus den USA an die KKR Investment Group verkauft</a></li>
<li><a href="../de458814/index.html">Starten einer Website f√ºr ein Produkt mit ungekl√§rter Nachfrage</a></li>
<li><a href="../de458818/index.html">Prominente Zeitgenossen</a></li>
<li><a href="../de458820/index.html">√úber die Implementierung des ber√ºhmten Genres auf der Minecraft-Plattform</a></li>
<li><a href="../de458826/index.html">Wie man alte Artikel aussortiert, damit sie im Bio-Bereich stark wachsen: + 104% des Verkehrs f√ºr sechs Monate</a></li>
<li><a href="../de458828/index.html">Warum, warum und wann ValueTask verwendet werden soll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>