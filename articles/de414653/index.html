<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèæ üí™ ‚òéÔ∏è Sorte austauschen üëêüèª üë®‚Äçüé§ üéÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie in einigen S√§tzen beschreiben, wie das Prinzip des Sortieraustauschs funktioniert, dann: 



1. Array-Elemente werden paarweise verglichen 
2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sorte austauschen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414653/"><div style="text-align:center;"><img width="700" height="312" src="https://habrastorage.org/webt/cf/xj/x_/cfxjx_qzr1qqhjmwvqz8eyygnxm.png"></div><br><br>  Wenn Sie in einigen S√§tzen beschreiben, wie das Prinzip des Sortieraustauschs funktioniert, dann: <br><br><ol><li>  Array-Elemente werden paarweise verglichen </li><li>  Wenn das Element links <sup>*</sup> gr√∂√üer als das Element rechts ist, werden die Elemente vertauscht </li><li>  Wiederholen Sie die Schritte 1-2, bis das Array sortiert ist </li></ol><br>  <sup><em>* - Das Element auf der linken Seite bedeutet das Element aus dem verglichenen Paar, das n√§her am linken Rand des Arrays liegt.</em></sup>  <sup><em>Dementsprechend befindet sich das Element rechts n√§her am rechten Rand.</em></sup> <br><a name="habracut"></a><br>  Ich entschuldige mich sofort f√ºr die Wiederholung von bekanntem Material. Es ist unwahrscheinlich, dass mindestens einer der Algorithmen in diesem Artikel eine Offenbarung f√ºr Sie ist.  √úber diese Sortierungen auf Habr√© wurde bereits viele Male geschrieben (einschlie√ülich mir - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ) und gefragt, warum noch einmal auf dieses Thema zur√ºckgegriffen werden soll.  Da ich mich jedoch entschlossen habe, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusammenh√§ngende Artikelserie √ºber alle Sortierungen auf der Welt</a> zu schreiben, muss ich die Austauschmethoden auch in der Expressversion durchlaufen.  Wenn man die folgenden Klassen betrachtet, wird es bereits viele neue (und nur wenige Leute kennen) Algorithmen geben, die separate interessante Artikel verdienen. <br><br>  Traditionell umfassen "Austauscher" Sortierungen, bei denen sich Elemente zuf√§llig (pseudo) √§ndern (Bogosort, Bozosort, Permsort usw.).  Ich habe sie jedoch nicht in diese Klasse aufgenommen, da ihnen Vergleiche fehlen.  Es wird einen separaten Artikel √ºber diese Sortierungen geben, in dem wir viel √ºber Wahrscheinlichkeitstheorie, Kombinatorik und thermischen Tod des Universums philosophieren. <br><br><h1>  Dumme Sortierung :: Handlanger-Sortierung </h1><br><img width="342" height="96" src="https://habrastorage.org/web/eb5/6f6/820/eb56f6820b904324a5df67714e2c8866.gif"><br><br><ol><li>  Vergleichen Sie die Elemente an den Enden des Subarrays (und √§ndern Sie sie gegebenenfalls). </li><li>  Wir nehmen zwei Drittel des Subarrays von Anfang an und wenden den allgemeinen Algorithmus rekursiv auf diese 2/3 an. </li><li>  Wir nehmen zwei Drittel des Subarrays von seinem Ende und wenden den allgemeinen Algorithmus rekursiv auf diese 2/3 an. </li><li>  Und wieder nehmen wir zwei Drittel des Subarrays von Anfang an und wenden den allgemeinen Algorithmus rekursiv auf diese 2/3 an. </li></ol><br>  Ein Subarray ist zun√§chst ein ganzes Array.  Und dann teilt die Rekursion das √ºbergeordnete Subarray in 2/3 auf, f√ºhrt Vergleiche / Austausch an den Enden der fragmentierten Segmente durch und ordnet schlie√ülich alles an. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j = None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: j = len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[j] &lt; data[i]: data[i], data[j] = data[j], data[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j - i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: t = (j - i + <span class="hljs-number"><span class="hljs-number">1</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> stooge_rec(data, i, j - t) stooge_rec(data, i + t, j) stooge_rec(data, i, j - t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stooge_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Es sieht schizophren aus, ist aber dennoch zu 100% korrekt. <br><br><h1>  Tr√§ge Sortierung :: Langsame Sortierung </h1><br><img width="342" height="96" src="https://habrastorage.org/web/f31/348/4f5/f313484f5bd44ea09b50e899e3d90548.gif"><br><br>  Und hier beobachten wir rekursive Mystik: <br><br><ol><li>  Wenn das Subarray aus einem Element besteht, schlie√üen wir die Rekursion ab. </li><li>  Wenn ein Subarray aus zwei oder mehr Elementen besteht, teilen Sie es in zwei H√§lften. </li><li>  Wir wenden den Algorithmus rekursiv auf die linke H√§lfte an. </li><li>  Wir wenden den Algorithmus rekursiv auf die rechte H√§lfte an. </li><li>  Elemente an den Enden des Subarrays werden verglichen (und bei Bedarf ge√§ndert). </li><li>  Wir wenden den Algorithmus rekursiv auf ein Subarray ohne das letzte Element an. </li></ol><br><br>  Ein Subarray ist zun√§chst das gesamte Array.  Und die Rekursion wird sich weiter halbieren, vergleichen und √§ndern, bis alles sortiert ist. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i, j)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data m = (i + j) // <span class="hljs-number"><span class="hljs-number">2</span></span> slow_rec(data, i, m) slow_rec(data, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, j) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[m] &gt; data[j]: data[m], data[j] = data[j], data[m] slow_rec(data, i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slow_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Es sieht nach Unsinn aus, aber das Array ist geordnet. <br><br><h3>  Warum funktionieren StoogeSort und SlowSort richtig? </h3><br>  Ein neugieriger Leser wird eine vern√ºnftige Frage stellen: Warum funktionieren diese beiden Algorithmen √ºberhaupt?  Sie scheinen einfach zu sein, aber es ist nicht sehr offensichtlich, dass Sie so etwas sortieren k√∂nnen. <br><br>  Schauen wir uns zuerst Slow sort an.  Der letzte Punkt dieses Algorithmus deutet darauf hin, dass die rekursiven Bem√ºhungen der schleppenden Sortierung nur darauf abzielen, das gr√∂√üte Element im Subarray ganz rechts zu platzieren.  Dies macht sich insbesondere dann bemerkbar, wenn Sie den Algorithmus auf ein nachgeordnetes Array anwenden: <br><br><img width="342" height="96" src="https://habrastorage.org/webt/lk/mx/nu/lkmxnutci_ufoymes6b4rksoqua.gif"><br><br>  Es ist deutlich zu sehen, dass die Maxima auf allen Rekursionsebenen schnell nach rechts wandern.  Dann werden diese Maxima, wo sie ben√∂tigt werden, aus dem Spiel ausgeschaltet: Der Algorithmus ruft sich selbst auf - aber ohne das letzte Element. <br><br>  Bei Stooge passiert eine √§hnliche Magie: <br><br><img width="672" height="454" src="https://habrastorage.org/webt/d-/pd/vj/d-pdvj8zcvmnlywcedlhkmhyfku.png"><br><br>  In der Tat wird der Schwerpunkt auch auf maximale Elemente gelegt.  Nur die langsame Sortierung verschiebt sie nacheinander zum Ende, und die Stooge-Sortierung dr√ºckt ein Drittel der Elemente des Subarrays (das gr√∂√üte von ihnen) in das am weitesten rechts liegende Drittel des Zellenraums. <br><br>  Wir wenden uns Algorithmen zu, bei denen bereits alles ganz offensichtlich ist. <br><br><h1>  Dumme Sortierung :: Dumme Sortierung </h1><br><img width="336" height="109" src="https://habrastorage.org/webt/sz/i3/hh/szi3hhaimi67d84kjaivphl4a9q.gif"><br><br>  Sehr sorgf√§ltige Sortierung.  Es geht vom Anfang des Arrays bis zum Ende und vergleicht benachbarte Elemente.  Wenn zwei benachbarte Elemente ausgetauscht werden mussten, kehrt die Sortierung f√ºr alle F√§lle zum Anfang des Arrays zur√ºck und beginnt von vorne. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stupid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; data[i]: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Gnome sort :: Gnome sort </h1><br><img width="570" height="95" src="https://habrastorage.org/web/2af/c2a/b73/2afc2ab738d54ca1b65a0bbcac9eaa19.gif"><br><br>  Fast das Gleiche, aber das Sortieren w√§hrend des Austauschs kehrt nicht zum Anfang des Arrays zur√ºck, sondern geht nur einen Schritt zur√ºck.  Es stellt sich heraus, dass dies ausreicht, um alles zu kl√§ren. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Optimierte Zwergsortierung </h3><br><img width="570" height="95" src="https://habrastorage.org/web/37c/91c/9fc/37c91c9fcffd4b1a9d1f225171bbdc64.gif"><br><br>  Sie k√∂nnen aber nicht nur beim R√ºckzug sparen, sondern auch beim Vorw√§rtsbewegen.  Bei mehreren aufeinander folgenden Austauschen m√ºssen Sie so viele Schritte zur√ºcktreten.  Und dann m√ºssen Sie zur√ºckgehen (indem Sie die Elemente vergleichen, die bereits relativ zueinander angeordnet sind).  Wenn Sie sich an die Position erinnern, von der aus der Austausch begonnen hat, k√∂nnen Sie sofort zu dieser Position springen, wenn der Austausch abgeschlossen ist. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, j, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span>: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Blasensortierung :: Blasensortierung </h1><br><img width="570" height="95" src="https://habrastorage.org/web/b68/67d/5b7/b6867d5b7d064421b5f7b1f6fae6d058.gif"><br><br>  Im Gegensatz zur dummen und gnomeischen Sortierung treten beim Austausch von Elementen in der Blase keine R√ºckgaben auf - sie bewegt sich weiter vorw√§rts.  Wenn Sie das Ende erreichen, wird das gr√∂√üte Element des Arrays bis zum Ende verschoben. <br><br>  Dann wiederholt der Sortiervorgang den gesamten Vorgang erneut, wodurch sich das zweite Element im Dienstalter an vorletzter Stelle befindet.  Bei der n√§chsten Iteration ist das drittgr√∂√üte Element das dritte vom Ende usw. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> changed: changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Optimierte Blasensortierung </h3><br><img width="570" height="95" src="https://habrastorage.org/web/ca0/9e7/20f/ca09e720f56c417bbbb8204aa8c35a7d.gif"><br><br>  Sie k√∂nnen ein wenig an den G√§ngen am Anfang des Arrays profitieren.  Dabei werden die ersten Elemente vor√ºbergehend relativ zueinander angeordnet (dieses sortierte Teil √§ndert st√§ndig seine Gr√∂√üe - es nimmt ab, es nimmt zu).  Dies l√§sst sich leicht beheben und mit einer neuen Iteration k√∂nnen Sie einfach √ºber eine Gruppe solcher Elemente springen. <br>  <sub><em>(Ich werde die getestete Implementierung in Python hier etwas sp√§ter hinzuf√ºgen. Ich hatte keine Zeit, sie vorzubereiten.)</em></sub> <br><br><br><h1>  Shaker Sort :: Shaker Sort <br>  (Cocktail-Sorte :: Cocktail-Sorte) </h1><br><img width="570" height="95" src="https://habrastorage.org/web/616/739/0f8/6167390f8005452e8dbcbeeacb5c95fc.gif"><br><br>  Eine Art Blase.  Schieben Sie beim ersten Durchgang wie gewohnt das Maximum bis zum Ende.  Dann drehen wir uns scharf um und schieben das Minimum an den Anfang.  Die sortierten Randbereiche des Arrays werden nach jeder Iteration gr√∂√üer. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> up = range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> indices <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (up, reversed(up)): swapped = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indices: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] swapped = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> swapped: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Odd-Even-Sortierung :: Odd-Even-Sortierung </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/yn/9t/oy/yn9toy8yjzuud4azxdffcb-6mwm.gif"><br><br>  Wieder Iterationen √ºber den paarweisen Vergleich benachbarter Elemente beim Bewegen von links nach rechts.  Nur zuerst vergleichen wir die Paare, in denen das erste Element beim Z√§hlen ungerade ist und das zweite gerade ist (d. H. Das erste und zweite, dritte und vierte, f√ºnfte und sechste usw.).  Und dann umgekehrt - gerade + ungerade (zweite und dritte, vierte und f√ºnfte, sechste und siebte usw.).  In diesem Fall machen viele gro√üe Elemente des Arrays bei einer Iteration gleichzeitig einen Schritt vorw√§rts (in der Blase erreicht das gr√∂√üte f√ºr die Iteration das Ende, aber der Rest der ziemlich gro√üen Elemente bleibt fast an Ort und Stelle). <br><br>  √úbrigens war dies urspr√ºnglich eine parallele Sortierung mit O (n) -Komplexit√§t.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AlgoLab muss</a> im Abschnitt "Parallele Sortierung" implementiert werden. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd_even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> n = len(data) isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isSorted == <span class="hljs-number"><span class="hljs-number">0</span></span>: isSorted = <span class="hljs-number"><span class="hljs-number">1</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Kammsortierung :: Kammsortierung </h1><br><img width="570" height="95" src="https://habrastorage.org/web/52f/41b/2fb/52f41b2fbd024cf8b9dfdba8d0dbd239.gif"><br><br>  Die erfolgreichste Modifikation der Blase.  Der Geschwindigkeitsalgorithmus konkurriert mit der schnellen Sortierung. <br><br>  In allen vorherigen Variationen haben wir die Nachbarn verglichen.  Dabei werden zun√§chst Elementpaare betrachtet, die sich in maximalem Abstand voneinander befinden.  Bei jeder neuen Iteration wird dieser Abstand gleichm√§√üig kleiner. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> gap = len(data) swaps = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> gap &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swaps: gap = max(<span class="hljs-number"><span class="hljs-number">1</span></span>, int(gap / <span class="hljs-number"><span class="hljs-number">1.25</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># minimum gap is 1 swaps = False for i in range(len(data) - gap): j = i + gap if data[i] &gt; data[j]: data[i], data[j] = data[j], data[i] swaps = True return data</span></span></code> </pre> <br><br><h1>  Schnelle Sortierung :: Schnelle Sortierung </h1><br><img width="684" height="95" src="https://habrastorage.org/webt/b1/xb/ve/b1xbvefydxsfynp91mnxaxluvfe.gif"><br><br>  Nun, der fortschrittlichste Austauschalgorithmus. <br><br><ol><li>  Teilen Sie das Array in zwei H√§lften.  Das mittlere Element ist die Referenz. </li><li>  Wir bewegen uns vom linken Rand des Arrays nach rechts, bis wir ein Element finden, das gr√∂√üer als das Referenzelement ist. </li><li>  Wir bewegen uns vom rechten Rand des Arrays nach links, bis wir ein Element finden, das kleiner als das Referenzelement ist. </li><li>  Wir tauschen die beiden Elemente aus den Punkten 2 und 3 aus. </li><li>  Wir f√ºhren die Punkte 2-3-4 weiter aus, bis aufgrund der gegenseitigen Bewegung ein Treffen stattfindet. </li><li>  Am Treffpunkt ist das Array in zwei Teile unterteilt.  F√ºr jeden Teil wenden wir rekursiv einen schnellen Sortieralgorithmus an. </li></ol><br>  Warum funktioniert es?  Links vom Treffpunkt befinden sich Elemente, die kleiner oder gleich dem Referenzpunkt sind.  Rechts vom Treffpunkt befinden sich Elemente, die gr√∂√üer oder gleich der Referenz sind.  Das hei√üt, jedes Element von der linken Seite ist kleiner oder gleich einem Element von der rechten Seite.  Daher kann das Array am Treffpunkt sicher in zwei Subarrays unterteilt werden und jedes Subarray auf √§hnliche Weise rekursiv sortieren. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> less = [] pivotList = [] more = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(data) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivot = data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; pivot: less.append(i) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i &gt; pivot: more.append(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivotList.append(i) less = quick(less) more = quick(more) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> less + pivotList + more</code> </pre> <br><br><h1>  K-sort :: K-sort </h1><br>  Auf Habr√© wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine √úbersetzung</a> eines der Artikel ver√∂ffentlicht, die √ºber die Modifikation von QuickSort berichtet, die die pyramidenf√∂rmige Sortierung um 7 Millionen Elemente √ºbertrifft.  Dies ist √ºbrigens an sich eine zweifelhafte Leistung, da die klassische pyramidenf√∂rmige Sortierung keine Leistungsrekorde bricht.  Insbesondere erreicht seine asymptotische Komplexit√§t unter keinen Umst√§nden O (n) (ein Merkmal dieses Algorithmus). <br><br>  Aber die Sache ist anders.  Nach dem (und offensichtlich falschen) Pseudocode des Autors ist es im Allgemeinen nicht m√∂glich zu verstehen, was tats√§chlich die Hauptidee des Algorithmus ist.  Pers√∂nlich hatte ich den Eindruck, dass die Autoren einige Gauner sind, die nach dieser Methode handelten: <br><ol><li>  Wir erkl√§ren die Erfindung eines Supersortieralgorithmus. </li><li>  Wir verst√§rken die Aussage mit einem nicht funktionierenden und unverst√§ndlichen Pseudocode (wie klug und so klar, aber Dummk√∂pfe k√∂nnen es immer noch nicht verstehen). </li><li>  Wir pr√§sentieren Grafiken und Tabellen, die angeblich die praktische Geschwindigkeit des Algorithmus f√ºr Big Data demonstrieren.  Aufgrund des Mangels an wirklich funktionierendem Code kann niemand diese statistischen Berechnungen √ºberpr√ºfen oder widerlegen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Wir ver√∂ffentlichen Unsinn</a> auf Arxiv.org unter dem Deckmantel eines wissenschaftlichen Artikels. </li><li>  GEWINN !!! </li></ol><br>  Vielleicht spreche ich vergeblich mit Leuten und tats√§chlich funktioniert der Algorithmus?  Kann jemand erkl√§ren, wie k-sort funktioniert? <br><br>  <strong>UPD</strong>  <strong>Meine pauschalen Anschuldigungen, Autoren von Betrug zu sortieren, erwiesen sich als unbegr√ºndet :) Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">jetsys</a> hat den Pseudocode des Algorithmus herausgefunden, eine funktionierende Version in PHP geschrieben und mir diese in privaten Nachrichten gesendet:</strong> <br><br><div class="spoiler">  <b class="spoiler_title">K-Sort in PHP</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a,$left,$right)</span></span></span></span>{ $ke=$a[$left]; $i=$left; $j=$right+<span class="hljs-number"><span class="hljs-number">1</span></span>; $k=$p=$left+<span class="hljs-number"><span class="hljs-number">1</span></span>; $temp=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($j-$i&gt;=<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($ke&lt;=$a[$p]){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(($p!=$j) &amp;&amp; ($j!=($right+<span class="hljs-number"><span class="hljs-number">1</span></span>))){ $a[$j]=$a[$p]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($j==($right+<span class="hljs-number"><span class="hljs-number">1</span></span>)){ $temp=$a[$p]; } $j--; $p=$j; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a[$i]=$a[$p]; $i++; $k++; $p=$k; } } $a[$i]=$ke; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($temp) $a[$i+<span class="hljs-number"><span class="hljs-number">1</span></span>]=$temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($left&lt;($i<span class="hljs-number"><span class="hljs-number">-1</span></span>)) _ksort($a,$left,$i<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($right&gt;($i+<span class="hljs-number"><span class="hljs-number">1</span></span>)) _ksort($a,$i+<span class="hljs-number"><span class="hljs-number">1</span></span>,$right); }</code> </pre> </div></div><br><br><h2>  Ank√ºndigung </h2><br>  Es war alles eine Theorie, es ist Zeit, mit der Praxis fortzufahren.  Im n√§chsten Artikel wird der Sortieraustausch f√ºr verschiedene Datens√§tze getestet.  Wir werden herausfinden: <br><br><ul><li>  Welche Sortierung ist die schlechteste - albern, langweilig oder langweilig? </li><li>  Helfen Optimierungen und Modifikationen der Blasensortierung wirklich? </li><li>  Unter welchen Bedingungen sind langsame Algorithmen in der Geschwindigkeit von QuickSort leicht schnell? </li></ul><br><br>  Und wenn wir die Antworten auf diese wichtigsten Fragen herausfinden, k√∂nnen wir beginnen, die n√§chste Klasse zu studieren - Einf√ºgungsarten. <br><br><h1>  Referenzen </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab</a> , mit der Sie Schritt f√ºr Schritt die Visualisierung dieser (und nicht nur dieser) Sorten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> k√∂nnen. <br><br>  <b>Wiki</b> - <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dumm</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Handlanger</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Langsam</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Zwerg</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gnom</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Blase</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Blase</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shaker</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shaker</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ungerade</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gerade</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kamm</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kamm</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Schnell</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Schnell</a></nobr> <br><br><h3>  Serienartikel </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <b>Sorte austauschen</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich der Austauschsortierung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Insertion Sorts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Auswahl sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortierungen zusammenf√ºhren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Verteilung sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hybridsortierung</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414653/">https://habr.com/ru/post/de414653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414639/index.html">Hacker-Dienste im dunklen Internet</a></li>
<li><a href="../de414641/index.html">XBRL z√§hmen: Analystenhinweise</a></li>
<li><a href="../de414643/index.html">Shop-Codierung: Gewinner des M.SMART-Hackathons</a></li>
<li><a href="../de414645/index.html">ONETRAK - intelligente Armb√§nder und mehr</a></li>
<li><a href="../de414651/index.html">3D-Scanner Shining 3D Einscan SE. 3D-Scanner√ºbersicht</a></li>
<li><a href="../de414655/index.html">Virtueller Router DD-WRT x86 auf VirtualBox</a></li>
<li><a href="../de414657/index.html">Gef√§hrliches AMF3-Protokoll</a></li>
<li><a href="../de414661/index.html">Die Tr√§gerrakete Sojus-5SL wird mit sowjetischen Motoren arbeiten</a></li>
<li><a href="../de414663/index.html">Professioneller Burnout: ein Wort an Experten</a></li>
<li><a href="../de414667/index.html">[Mini-Fan-Thema] FIFA-Meisterschaftstabelle im Terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>