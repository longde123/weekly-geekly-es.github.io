<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏾 💪 ☎️ Sorte austauschen 👐🏻 👨‍🎤 🎂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie in einigen Sätzen beschreiben, wie das Prinzip des Sortieraustauschs funktioniert, dann: 



1. Array-Elemente werden paarweise verglichen 
2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sorte austauschen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414653/"><div style="text-align:center;"><img width="700" height="312" src="https://habrastorage.org/webt/cf/xj/x_/cfxjx_qzr1qqhjmwvqz8eyygnxm.png"></div><br><br>  Wenn Sie in einigen Sätzen beschreiben, wie das Prinzip des Sortieraustauschs funktioniert, dann: <br><br><ol><li>  Array-Elemente werden paarweise verglichen </li><li>  Wenn das Element links <sup>*</sup> größer als das Element rechts ist, werden die Elemente vertauscht </li><li>  Wiederholen Sie die Schritte 1-2, bis das Array sortiert ist </li></ol><br>  <sup><em>* - Das Element auf der linken Seite bedeutet das Element aus dem verglichenen Paar, das näher am linken Rand des Arrays liegt.</em></sup>  <sup><em>Dementsprechend befindet sich das Element rechts näher am rechten Rand.</em></sup> <br><a name="habracut"></a><br>  Ich entschuldige mich sofort für die Wiederholung von bekanntem Material. Es ist unwahrscheinlich, dass mindestens einer der Algorithmen in diesem Artikel eine Offenbarung für Sie ist.  Über diese Sortierungen auf Habré wurde bereits viele Male geschrieben (einschließlich mir - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ) und gefragt, warum noch einmal auf dieses Thema zurückgegriffen werden soll.  Da ich mich jedoch entschlossen habe, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusammenhängende Artikelserie über alle Sortierungen auf der Welt</a> zu schreiben, muss ich die Austauschmethoden auch in der Expressversion durchlaufen.  Wenn man die folgenden Klassen betrachtet, wird es bereits viele neue (und nur wenige Leute kennen) Algorithmen geben, die separate interessante Artikel verdienen. <br><br>  Traditionell umfassen "Austauscher" Sortierungen, bei denen sich Elemente zufällig (pseudo) ändern (Bogosort, Bozosort, Permsort usw.).  Ich habe sie jedoch nicht in diese Klasse aufgenommen, da ihnen Vergleiche fehlen.  Es wird einen separaten Artikel über diese Sortierungen geben, in dem wir viel über Wahrscheinlichkeitstheorie, Kombinatorik und thermischen Tod des Universums philosophieren. <br><br><h1>  Dumme Sortierung :: Handlanger-Sortierung </h1><br><img width="342" height="96" src="https://habrastorage.org/web/eb5/6f6/820/eb56f6820b904324a5df67714e2c8866.gif"><br><br><ol><li>  Vergleichen Sie die Elemente an den Enden des Subarrays (und ändern Sie sie gegebenenfalls). </li><li>  Wir nehmen zwei Drittel des Subarrays von Anfang an und wenden den allgemeinen Algorithmus rekursiv auf diese 2/3 an. </li><li>  Wir nehmen zwei Drittel des Subarrays von seinem Ende und wenden den allgemeinen Algorithmus rekursiv auf diese 2/3 an. </li><li>  Und wieder nehmen wir zwei Drittel des Subarrays von Anfang an und wenden den allgemeinen Algorithmus rekursiv auf diese 2/3 an. </li></ol><br>  Ein Subarray ist zunächst ein ganzes Array.  Und dann teilt die Rekursion das übergeordnete Subarray in 2/3 auf, führt Vergleiche / Austausch an den Enden der fragmentierten Segmente durch und ordnet schließlich alles an. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j = None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: j = len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[j] &lt; data[i]: data[i], data[j] = data[j], data[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j - i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: t = (j - i + <span class="hljs-number"><span class="hljs-number">1</span></span>) // <span class="hljs-number"><span class="hljs-number">3</span></span> stooge_rec(data, i, j - t) stooge_rec(data, i + t, j) stooge_rec(data, i, j - t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stooge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stooge_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Es sieht schizophren aus, ist aber dennoch zu 100% korrekt. <br><br><h1>  Träge Sortierung :: Langsame Sortierung </h1><br><img width="342" height="96" src="https://habrastorage.org/web/f31/348/4f5/f313484f5bd44ea09b50e899e3d90548.gif"><br><br>  Und hier beobachten wir rekursive Mystik: <br><br><ol><li>  Wenn das Subarray aus einem Element besteht, schließen wir die Rekursion ab. </li><li>  Wenn ein Subarray aus zwei oder mehr Elementen besteht, teilen Sie es in zwei Hälften. </li><li>  Wir wenden den Algorithmus rekursiv auf die linke Hälfte an. </li><li>  Wir wenden den Algorithmus rekursiv auf die rechte Hälfte an. </li><li>  Elemente an den Enden des Subarrays werden verglichen (und bei Bedarf geändert). </li><li>  Wir wenden den Algorithmus rekursiv auf ein Subarray ohne das letzte Element an. </li></ol><br><br>  Ein Subarray ist zunächst das gesamte Array.  Und die Rekursion wird sich weiter halbieren, vergleichen und ändern, bis alles sortiert ist. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, i, j)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data m = (i + j) // <span class="hljs-number"><span class="hljs-number">2</span></span> slow_rec(data, i, m) slow_rec(data, m + <span class="hljs-number"><span class="hljs-number">1</span></span>, j) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[m] &gt; data[j]: data[m], data[j] = data[j], data[m] slow_rec(data, i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slow_rec(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Es sieht nach Unsinn aus, aber das Array ist geordnet. <br><br><h3>  Warum funktionieren StoogeSort und SlowSort richtig? </h3><br>  Ein neugieriger Leser wird eine vernünftige Frage stellen: Warum funktionieren diese beiden Algorithmen überhaupt?  Sie scheinen einfach zu sein, aber es ist nicht sehr offensichtlich, dass Sie so etwas sortieren können. <br><br>  Schauen wir uns zuerst Slow sort an.  Der letzte Punkt dieses Algorithmus deutet darauf hin, dass die rekursiven Bemühungen der schleppenden Sortierung nur darauf abzielen, das größte Element im Subarray ganz rechts zu platzieren.  Dies macht sich insbesondere dann bemerkbar, wenn Sie den Algorithmus auf ein nachgeordnetes Array anwenden: <br><br><img width="342" height="96" src="https://habrastorage.org/webt/lk/mx/nu/lkmxnutci_ufoymes6b4rksoqua.gif"><br><br>  Es ist deutlich zu sehen, dass die Maxima auf allen Rekursionsebenen schnell nach rechts wandern.  Dann werden diese Maxima, wo sie benötigt werden, aus dem Spiel ausgeschaltet: Der Algorithmus ruft sich selbst auf - aber ohne das letzte Element. <br><br>  Bei Stooge passiert eine ähnliche Magie: <br><br><img width="672" height="454" src="https://habrastorage.org/webt/d-/pd/vj/d-pdvj8zcvmnlywcedlhkmhyfku.png"><br><br>  In der Tat wird der Schwerpunkt auch auf maximale Elemente gelegt.  Nur die langsame Sortierung verschiebt sie nacheinander zum Ende, und die Stooge-Sortierung drückt ein Drittel der Elemente des Subarrays (das größte von ihnen) in das am weitesten rechts liegende Drittel des Zellenraums. <br><br>  Wir wenden uns Algorithmen zu, bei denen bereits alles ganz offensichtlich ist. <br><br><h1>  Dumme Sortierung :: Dumme Sortierung </h1><br><img width="336" height="109" src="https://habrastorage.org/webt/sz/i3/hh/szi3hhaimi67d84kjaivphl4a9q.gif"><br><br>  Sehr sorgfältige Sortierung.  Es geht vom Anfang des Arrays bis zum Ende und vergleicht benachbarte Elemente.  Wenn zwei benachbarte Elemente ausgetauscht werden mussten, kehrt die Sortierung für alle Fälle zum Anfang des Arrays zurück und beginnt von vorne. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stupid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; data[i]: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Gnome sort :: Gnome sort </h1><br><img width="570" height="95" src="https://habrastorage.org/web/2af/c2a/b73/2afc2ab738d54ca1b65a0bbcac9eaa19.gif"><br><br>  Fast das Gleiche, aber das Sortieren während des Austauschs kehrt nicht zum Anfang des Arrays zurück, sondern geht nur einen Schritt zurück.  Es stellt sich heraus, dass dies ausreicht, um alles zu klären. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Optimierte Zwergsortierung </h3><br><img width="570" height="95" src="https://habrastorage.org/web/37c/91c/9fc/37c91c9fcffd4b1a9d1f225171bbdc64.gif"><br><br>  Sie können aber nicht nur beim Rückzug sparen, sondern auch beim Vorwärtsbewegen.  Bei mehreren aufeinander folgenden Austauschen müssen Sie so viele Schritte zurücktreten.  Und dann müssen Sie zurückgehen (indem Sie die Elemente vergleichen, die bereits relativ zueinander angeordnet sind).  Wenn Sie sich an die Position erinnern, von der aus der Austausch begonnen hat, können Sie sofort zu dieser Position springen, wenn der Austausch abgeschlossen ist. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gnome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> i, j, size = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, len(data) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= data[i]: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] = data[i], data[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span>: i, j = j, j + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Blasensortierung :: Blasensortierung </h1><br><img width="570" height="95" src="https://habrastorage.org/web/b68/67d/5b7/b6867d5b7d064421b5f7b1f6fae6d058.gif"><br><br>  Im Gegensatz zur dummen und gnomeischen Sortierung treten beim Austausch von Elementen in der Blase keine Rückgaben auf - sie bewegt sich weiter vorwärts.  Wenn Sie das Ende erreichen, wird das größte Element des Arrays bis zum Ende verschoben. <br><br>  Dann wiederholt der Sortiervorgang den gesamten Vorgang erneut, wodurch sich das zweite Element im Dienstalter an vorletzter Stelle befindet.  Bei der nächsten Iteration ist das drittgrößte Element das dritte vom Ende usw. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> changed: changed = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] changed = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h3>  Optimierte Blasensortierung </h3><br><img width="570" height="95" src="https://habrastorage.org/web/ca0/9e7/20f/ca09e720f56c417bbbb8204aa8c35a7d.gif"><br><br>  Sie können ein wenig an den Gängen am Anfang des Arrays profitieren.  Dabei werden die ersten Elemente vorübergehend relativ zueinander angeordnet (dieses sortierte Teil ändert ständig seine Größe - es nimmt ab, es nimmt zu).  Dies lässt sich leicht beheben und mit einer neuen Iteration können Sie einfach über eine Gruppe solcher Elemente springen. <br>  <sub><em>(Ich werde die getestete Implementierung in Python hier etwas später hinzufügen. Ich hatte keine Zeit, sie vorzubereiten.)</em></sub> <br><br><br><h1>  Shaker Sort :: Shaker Sort <br>  (Cocktail-Sorte :: Cocktail-Sorte) </h1><br><img width="570" height="95" src="https://habrastorage.org/web/616/739/0f8/6167390f8005452e8dbcbeeacb5c95fc.gif"><br><br>  Eine Art Blase.  Schieben Sie beim ersten Durchgang wie gewohnt das Maximum bis zum Ende.  Dann drehen wir uns scharf um und schieben das Minimum an den Anfang.  Die sortierten Randbereiche des Arrays werden nach jeder Iteration größer. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> up = range(len(data) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> indices <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (up, reversed(up)): swapped = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indices: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] swapped = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> swapped: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Odd-Even-Sortierung :: Odd-Even-Sortierung </h1><br><img width="570" height="95" src="https://habrastorage.org/webt/yn/9t/oy/yn9toy8yjzuud4azxdffcb-6mwm.gif"><br><br>  Wieder Iterationen über den paarweisen Vergleich benachbarter Elemente beim Bewegen von links nach rechts.  Nur zuerst vergleichen wir die Paare, in denen das erste Element beim Zählen ungerade ist und das zweite gerade ist (d. H. Das erste und zweite, dritte und vierte, fünfte und sechste usw.).  Und dann umgekehrt - gerade + ungerade (zweite und dritte, vierte und fünfte, sechste und siebte usw.).  In diesem Fall machen viele große Elemente des Arrays bei einer Iteration gleichzeitig einen Schritt vorwärts (in der Blase erreicht das größte für die Iteration das Ende, aber der Rest der ziemlich großen Elemente bleibt fast an Ort und Stelle). <br><br>  Übrigens war dies ursprünglich eine parallele Sortierung mit O (n) -Komplexität.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AlgoLab muss</a> im Abschnitt "Parallele Sortierung" implementiert werden. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odd_even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> n = len(data) isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> isSorted == <span class="hljs-number"><span class="hljs-number">0</span></span>: isSorted = <span class="hljs-number"><span class="hljs-number">1</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[i] &gt; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]: data[i], data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>], data[i] isSorted = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br><h1>  Kammsortierung :: Kammsortierung </h1><br><img width="570" height="95" src="https://habrastorage.org/web/52f/41b/2fb/52f41b2fbd024cf8b9dfdba8d0dbd239.gif"><br><br>  Die erfolgreichste Modifikation der Blase.  Der Geschwindigkeitsalgorithmus konkurriert mit der schnellen Sortierung. <br><br>  In allen vorherigen Variationen haben wir die Nachbarn verglichen.  Dabei werden zunächst Elementpaare betrachtet, die sich in maximalem Abstand voneinander befinden.  Bei jeder neuen Iteration wird dieser Abstand gleichmäßig kleiner. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> gap = len(data) swaps = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> gap &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swaps: gap = max(<span class="hljs-number"><span class="hljs-number">1</span></span>, int(gap / <span class="hljs-number"><span class="hljs-number">1.25</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># minimum gap is 1 swaps = False for i in range(len(data) - gap): j = i + gap if data[i] &gt; data[j]: data[i], data[j] = data[j], data[i] swaps = True return data</span></span></code> </pre> <br><br><h1>  Schnelle Sortierung :: Schnelle Sortierung </h1><br><img width="684" height="95" src="https://habrastorage.org/webt/b1/xb/ve/b1xbvefydxsfynp91mnxaxluvfe.gif"><br><br>  Nun, der fortschrittlichste Austauschalgorithmus. <br><br><ol><li>  Teilen Sie das Array in zwei Hälften.  Das mittlere Element ist die Referenz. </li><li>  Wir bewegen uns vom linken Rand des Arrays nach rechts, bis wir ein Element finden, das größer als das Referenzelement ist. </li><li>  Wir bewegen uns vom rechten Rand des Arrays nach links, bis wir ein Element finden, das kleiner als das Referenzelement ist. </li><li>  Wir tauschen die beiden Elemente aus den Punkten 2 und 3 aus. </li><li>  Wir führen die Punkte 2-3-4 weiter aus, bis aufgrund der gegenseitigen Bewegung ein Treffen stattfindet. </li><li>  Am Treffpunkt ist das Array in zwei Teile unterteilt.  Für jeden Teil wenden wir rekursiv einen schnellen Sortieralgorithmus an. </li></ol><br>  Warum funktioniert es?  Links vom Treffpunkt befinden sich Elemente, die kleiner oder gleich dem Referenzpunkt sind.  Rechts vom Treffpunkt befinden sich Elemente, die größer oder gleich der Referenz sind.  Das heißt, jedes Element von der linken Seite ist kleiner oder gleich einem Element von der rechten Seite.  Daher kann das Array am Treffpunkt sicher in zwei Subarrays unterteilt werden und jedes Subarray auf ähnliche Weise rekursiv sortieren. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> less = [] pivotList = [] more = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(data) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivot = data[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; pivot: less.append(i) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> i &gt; pivot: more.append(i) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pivotList.append(i) less = quick(less) more = quick(more) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> less + pivotList + more</code> </pre> <br><br><h1>  K-sort :: K-sort </h1><br>  Auf Habré wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Übersetzung</a> eines der Artikel veröffentlicht, die über die Modifikation von QuickSort berichtet, die die pyramidenförmige Sortierung um 7 Millionen Elemente übertrifft.  Dies ist übrigens an sich eine zweifelhafte Leistung, da die klassische pyramidenförmige Sortierung keine Leistungsrekorde bricht.  Insbesondere erreicht seine asymptotische Komplexität unter keinen Umständen O (n) (ein Merkmal dieses Algorithmus). <br><br>  Aber die Sache ist anders.  Nach dem (und offensichtlich falschen) Pseudocode des Autors ist es im Allgemeinen nicht möglich zu verstehen, was tatsächlich die Hauptidee des Algorithmus ist.  Persönlich hatte ich den Eindruck, dass die Autoren einige Gauner sind, die nach dieser Methode handelten: <br><ol><li>  Wir erklären die Erfindung eines Supersortieralgorithmus. </li><li>  Wir verstärken die Aussage mit einem nicht funktionierenden und unverständlichen Pseudocode (wie klug und so klar, aber Dummköpfe können es immer noch nicht verstehen). </li><li>  Wir präsentieren Grafiken und Tabellen, die angeblich die praktische Geschwindigkeit des Algorithmus für Big Data demonstrieren.  Aufgrund des Mangels an wirklich funktionierendem Code kann niemand diese statistischen Berechnungen überprüfen oder widerlegen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Wir veröffentlichen Unsinn</a> auf Arxiv.org unter dem Deckmantel eines wissenschaftlichen Artikels. </li><li>  GEWINN !!! </li></ol><br>  Vielleicht spreche ich vergeblich mit Leuten und tatsächlich funktioniert der Algorithmus?  Kann jemand erklären, wie k-sort funktioniert? <br><br>  <strong>UPD</strong>  <strong>Meine pauschalen Anschuldigungen, Autoren von Betrug zu sortieren, erwiesen sich als unbegründet :) Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">jetsys</a> hat den Pseudocode des Algorithmus herausgefunden, eine funktionierende Version in PHP geschrieben und mir diese in privaten Nachrichten gesendet:</strong> <br><br><div class="spoiler">  <b class="spoiler_title">K-Sort in PHP</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a,$left,$right)</span></span></span></span>{ $ke=$a[$left]; $i=$left; $j=$right+<span class="hljs-number"><span class="hljs-number">1</span></span>; $k=$p=$left+<span class="hljs-number"><span class="hljs-number">1</span></span>; $temp=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($j-$i&gt;=<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($ke&lt;=$a[$p]){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(($p!=$j) &amp;&amp; ($j!=($right+<span class="hljs-number"><span class="hljs-number">1</span></span>))){ $a[$j]=$a[$p]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($j==($right+<span class="hljs-number"><span class="hljs-number">1</span></span>)){ $temp=$a[$p]; } $j--; $p=$j; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a[$i]=$a[$p]; $i++; $k++; $p=$k; } } $a[$i]=$ke; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($temp) $a[$i+<span class="hljs-number"><span class="hljs-number">1</span></span>]=$temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($left&lt;($i<span class="hljs-number"><span class="hljs-number">-1</span></span>)) _ksort($a,$left,$i<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($right&gt;($i+<span class="hljs-number"><span class="hljs-number">1</span></span>)) _ksort($a,$i+<span class="hljs-number"><span class="hljs-number">1</span></span>,$right); }</code> </pre> </div></div><br><br><h2>  Ankündigung </h2><br>  Es war alles eine Theorie, es ist Zeit, mit der Praxis fortzufahren.  Im nächsten Artikel wird der Sortieraustausch für verschiedene Datensätze getestet.  Wir werden herausfinden: <br><br><ul><li>  Welche Sortierung ist die schlechteste - albern, langweilig oder langweilig? </li><li>  Helfen Optimierungen und Modifikationen der Blasensortierung wirklich? </li><li>  Unter welchen Bedingungen sind langsame Algorithmen in der Geschwindigkeit von QuickSort leicht schnell? </li></ul><br><br>  Und wenn wir die Antworten auf diese wichtigsten Fragen herausfinden, können wir beginnen, die nächste Klasse zu studieren - Einfügungsarten. <br><br><h1>  Referenzen </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab</a> , mit der Sie Schritt für Schritt die Visualisierung dieser (und nicht nur dieser) Sorten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> können. <br><br>  <b>Wiki</b> - <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dumm</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Handlanger</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Langsam</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Zwerg</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gnom</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Blase</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Blase</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shaker</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Shaker</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ungerade</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Gerade</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kamm</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Kamm</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Schnell</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Schnell</a></nobr> <br><br><h3>  Serienartikel </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <b>Sorte austauschen</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich der Austauschsortierung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Insertion Sorts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Auswahl sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortierungen zusammenführen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nach Verteilung sortieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hybridsortierung</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414653/">https://habr.com/ru/post/de414653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414639/index.html">Hacker-Dienste im dunklen Internet</a></li>
<li><a href="../de414641/index.html">XBRL zähmen: Analystenhinweise</a></li>
<li><a href="../de414643/index.html">Shop-Codierung: Gewinner des M.SMART-Hackathons</a></li>
<li><a href="../de414645/index.html">ONETRAK - intelligente Armbänder und mehr</a></li>
<li><a href="../de414651/index.html">3D-Scanner Shining 3D Einscan SE. 3D-Scannerübersicht</a></li>
<li><a href="../de414655/index.html">Virtueller Router DD-WRT x86 auf VirtualBox</a></li>
<li><a href="../de414657/index.html">Gefährliches AMF3-Protokoll</a></li>
<li><a href="../de414661/index.html">Die Trägerrakete Sojus-5SL wird mit sowjetischen Motoren arbeiten</a></li>
<li><a href="../de414663/index.html">Professioneller Burnout: ein Wort an Experten</a></li>
<li><a href="../de414667/index.html">[Mini-Fan-Thema] FIFA-Meisterschaftstabelle im Terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>