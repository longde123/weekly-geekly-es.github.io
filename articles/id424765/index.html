<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🏭 🍩 👩🏼‍🚒 Manajemen negara dalam aplikasi Flutter 🤸🏿 👶🏿 🏂🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prinsip umum 


 Flutter adalah kerangka kerja reaktif, dan bagi pengembang yang berspesialisasi dalam pengembangan asli, filosofinya mungkin tidak bi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen negara dalam aplikasi Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424765/"><p><img src="https://habrastorage.org/webt/4r/cs/fa/4rcsfacb6jeocfr5aprzgmk7-a0.jpeg"></p><br><h1 id="obschie-principy">  Prinsip umum </h1><br><p>  Flutter adalah kerangka kerja reaktif, dan bagi pengembang yang berspesialisasi dalam pengembangan asli, filosofinya mungkin tidak biasa.  Karena itu, kami mulai dengan ulasan singkat. </p><br><p> Antarmuka pengguna pada Flutter, seperti dalam kebanyakan kerangka kerja modern, terdiri dari pohon komponen (widget).  Ketika suatu komponen berubah, ini dan semua komponen turunannya dirender kembali (dengan optimisasi internal, yang dijelaskan di bawah).  Ketika tampilan berubah secara global (misalnya, memutar layar), seluruh pohon widget digambar ulang. </p><a name="habracut"></a><br><p>  Pendekatan ini mungkin tampak tidak efektif, tetapi pada kenyataannya memberikan kontrol programmer atas kecepatan kerja.  Jika Anda memperbarui antarmuka pada tingkat tertinggi tanpa perlu, semuanya akan bekerja lambat, tetapi dengan tata letak widget yang benar, aplikasi pada Flutter bisa sangat cepat. </p><br><p>  Flutter memiliki dua jenis widget - Stateless dan Stateful.  Yang pertama (analog dengan Komponen Murni dalam Bereaksi) tidak memiliki keadaan dan sepenuhnya dijelaskan oleh parameter mereka.  Jika kondisi tampilan tidak berubah (misalnya, ukuran area di mana widget harus ditampilkan) dan parameternya, sistem menggunakan kembali representasi visual widget yang dibuat sebelumnya, sehingga menggunakan widget Stateless memiliki efek yang baik pada kinerja.  Pada saat yang sama, bagaimanapun, setiap kali widget digambar ulang, sebuah objek baru secara resmi dibuat dan konstruktor diluncurkan. </p><br><p>  Widget stateful mempertahankan beberapa kondisi antara rendering.  Untuk melakukan ini, mereka dijelaskan oleh dua kelas.  Kelas pertama, widget itu sendiri, menjelaskan objek yang dibuat selama setiap rendering.  Kelas kedua menjelaskan keadaan widget dan objeknya ditransfer ke objek widget yang dibuat.  Widget stateful state adalah sumber utama redrawing antarmuka.  Untuk melakukan ini, Anda perlu mengubah propertinya di dalam panggilan ke metode SetState.  Dengan demikian, tidak seperti banyak kerangka kerja lainnya, Flutter tidak memiliki pelacakan status implisit - perubahan apa pun pada properti widget di luar metode SetState tidak mengarah pada menggambar ulang antarmuka. </p><br><p>  Sekarang, setelah menjelaskan dasar-dasarnya, Anda bisa mulai dengan aplikasi sederhana yang menggunakan widget Stateless dan Stateful: </p><br><div class="spoiler">  <b class="spoiler_title">Aplikasi dasar</b> <div class="spoiler_text"><pre><code class="plaintext hljs">import 'dart:math'; import 'package:flutter/material.dart'; void main() =&gt; runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new MyHomePage(), ), ); } } class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { Random rand = Random(); @override Widget build(BuildContext context) { return new ListView.builder(itemBuilder: (BuildContext context, int index) { return Text('Random number ${rand.nextInt(100)}',); }); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh lengkap</a> </p><br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sd/bv/nv/sdbvnvms7mjzadqujfg8vjm2wgs.png"></p></div></div><br><h1 id="esli-nuzhny-bolee-zhivuchie-sostoyaniya">  Jika Anda membutuhkan kondisi yang lebih ulet </h1><br><p>  Mari kita lanjutkan.  Keadaan widget tetap dipertahankan di antara antarmuka menggambar ulang, tetapi hanya selama widget diperlukan, mis.  benar-benar terletak di layar.  Mari kita lakukan eksperimen sederhana - letakkan daftar kami di tab: </p><br><div class="spoiler">  <b class="spoiler_title">Aplikasi tab</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { Random rand = Random(); TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [ new ListView.builder(itemBuilder: (BuildContext context, int index) { return Text('Random number ${rand.nextInt(100)}',); }), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh lengkap</a> </p><br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/va/fw/km/vafwkmelvxeapujubze6ixv4him.gif"></p></div></div><br><p>  Saat memulai, Anda dapat melihat bahwa saat berpindah antar tab, status dihapus (metode buang () dipanggil), saat dikembalikan, dibuat lagi (metode initState ()).  Ini masuk akal, karena menyimpan status widget yang tidak dapat ditampilkan akan menghabiskan sumber daya sistem.  Dalam hal keadaan widget harus selamat dari penyembunyian lengkapnya, beberapa pendekatan mungkin: </p><br><p>  Pertama, Anda dapat menggunakan objek terpisah (ViewModel) untuk menyimpan status.  Dart di tingkat bahasa mendukung konstruktor pabrik yang dapat digunakan untuk membuat pabrik dan lajang yang menyimpan data yang diperlukan. </p><br><p>  Saya lebih suka pendekatan ini, karena  Ini memungkinkan Anda untuk mengisolasi logika bisnis dari antarmuka pengguna.  Ini terutama benar karena Flutter Release Preview 2 menambahkan kemampuan untuk membuat antarmuka pixel-sempurna untuk iOS, tetapi Anda perlu melakukan ini, tentu saja, pada widget yang sesuai. </p><br><p>  Kedua, adalah mungkin untuk menggunakan pendekatan peningkatan-negara, yang akrab dengan programmer Bereaksi, ketika data disimpan dalam komponen yang terletak di hulu.  Karena Flutter menggambar ulang antarmuka hanya ketika metode setState () dipanggil, data ini dapat diubah dan digunakan tanpa rendering.  Pendekatan ini agak lebih kompleks dan meningkatkan konektivitas widget dalam struktur, tetapi memungkinkan Anda untuk menentukan tingkat penyimpanan data secara langsung. </p><br><p>  Akhirnya, ada perpustakaan penyimpanan negara seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flutter_redux</a> . </p><br><p>  Untuk mempermudah, kami menggunakan pendekatan pertama.  Mari kita buat kelas ListData yang terpisah, singleton, yang menyimpan nilai untuk daftar kita.  Saat menampilkan, kami akan menggunakan kelas ini. </p><br><div class="spoiler">  <b class="spoiler_title">Aplikasi Pemulihan Data Tab</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [ new ListView.builder(itemBuilder: ListData().build), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } } class ListData { static ListData _instance = ListData._internal(); ListData._internal(); factory ListData() { return _instance; } Random _rand = Random(); Map&lt;int, int&gt; _values = new Map(); Widget build (BuildContext context, int index) { if (!_values.containsKey(index)) { _values[index] = _rand.nextInt(100); } return Text('Random number ${_values[index]}',); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh lengkap</a> </p><br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/pk/tu/s1/pktus1ysyqw1xzdhvdr-jdy5o-k.gif"></p></div></div><br><h1 id="sohranenie-pozicii-skrolla">  Menyimpan posisi gulir </h1><br><p>  Jika Anda menggulir ke bawah daftar dari contoh sebelumnya, lalu beralih di antara tab, mudah untuk melihat bahwa posisi gulir tidak disimpan.  Ini logis, karena ini tidak disimpan di kelas ListData kami, dan status widget itu sendiri tidak bertahan beralih antar tab.  Kami menerapkan penyimpanan keadaan gulir secara manual, tetapi untuk bersenang-senang kami akan menambahkannya bukan ke kelas yang terpisah dan tidak ke ListData, tetapi ke status tingkat yang lebih tinggi untuk menunjukkan cara bekerja dengannya. </p><br><p>  Perhatikan widget ScrollController dan NotificationListener (serta DefaultTabController yang sebelumnya digunakan).  Konsep widget yang tidak memiliki tampilan sendiri harus familier bagi pengembang yang bekerja dengan React / Redux - komponen kontainer secara aktif digunakan dalam bundel ini.  Di Flutter, widget non-display biasanya digunakan untuk menambah fungsionalitas ke widget child.  Ini memungkinkan Anda untuk membiarkan widget visual itu sendiri tetap ringan dan tidak memroses acara sistem yang tidak diperlukan. </p><br><p>  Kode ini didasarkan pada solusi yang diusulkan oleh Marcin Szałek di Stakoverflow ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/45341721/flutter-listview-inside-on--tabbarview-loses-its-scroll-position</a> ).  Rencananya adalah sebagai berikut: </p><br><ol><li>  Tambahkan ScrollController ke daftar untuk bekerja dengan posisi gulir. </li><li>  Tambahkan NotificationListener ke daftar untuk melewati status gulir. </li><li>  Kami menyimpan posisi gulir di _MyHomePageState (yang satu tingkat di atas tab) dan mengaitkannya dengan daftar gulir. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Aplikasi dengan menyimpan posisi gulir</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { double listViewOffset=0.0; TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [new ListTab( getOffsetMethod: () =&gt; listViewOffset, setOffsetMethod: (offset) =&gt; this.listViewOffset = offset, ), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } } class ListTab extends StatefulWidget { ListTab({Key key, this.getOffsetMethod, this.setOffsetMethod}) : super(key: key); final GetOffsetMethod getOffsetMethod; final SetOffsetMethod setOffsetMethod; @override _ListTabState createState() =&gt; _ListTabState(); } class _ListTabState extends State&lt;ListTab&gt; { ScrollController scrollController; @override void initState() { super.initState(); //Init scrolling to preserve it scrollController = new ScrollController( initialScrollOffset: widget.getOffsetMethod() ); } @override Widget build(BuildContext context) { return NotificationListener( child: new ListView.builder( controller: scrollController, itemBuilder: ListData().build, ), onNotification: (notification) { if (notification is ScrollNotification) { widget.setOffsetMethod(notification.metrics.pixels); } }, ); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh lengkap</a> </p><br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rd/me/am/rdmeamzm7c-4jgyc-2qjqbmr9oq.gif"></p></div></div><br><h1 id="perezhivaem-vyklyuchenie-prilozheniya">  Mengalami shutdown aplikasi </h1><br><p>  Menyimpan informasi selama durasi aplikasi itu baik, tetapi seringkali Anda ingin menyimpannya di antara sesi, terutama mengingat kebiasaan sistem operasi untuk menutup aplikasi latar belakang ketika tidak ada cukup memori.  Opsi utama untuk penyimpanan data persisten di Flutter adalah: </p><br><ol><li>  Preferensi bersama ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pub.dartlang.org/packages/shared_preferences</a> ) adalah pembungkus di sekitar NSUserDefaults (di iOS) dan SharedPreferences (di Android) dan memungkinkan Anda untuk menyimpan sejumlah kecil pasangan nilai kunci.  Bagus untuk menyimpan pengaturan. </li><li>  sqflite ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pub.dartlang.org/packages/sqflite</a> ) adalah plugin untuk bekerja dengan SQLite (dengan beberapa batasan).  Mendukung kueri dan pembantu tingkat rendah.  Selain itu, dengan analogi dengan Kamar, ini memungkinkan Anda untuk bekerja dengan versi skema database dan mengatur kode untuk memperbarui skema ketika memperbarui aplikasi. </li><li>  Cloud Firestore ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pub.dartlang.org/packages/cloud_firestore</a> ) adalah bagian dari keluarga plugin FireBase resmi. </li></ol><br><p>  Untuk mendemonstrasikan, kami akan menyimpan status gulir di Preferensi bersama.  Untuk melakukan ini, tambahkan pemulihan posisi gulir saat menginisialisasi keadaan _MyHomePageState dan simpan saat menggulir. </p><br><p>  Di sini kita perlu memikirkan model Flutter / Dart asinkron, karena semua layanan eksternal bekerja pada panggilan asinkron.  Prinsip operasi model ini mirip dengan node.js - ada satu utas utama eksekusi (utas), yang terganggu oleh panggilan asinkron.  Pada setiap interupsi berikutnya (dan UI membuatnya terus-menerus), hasil dari operasi asinkron yang selesai diproses. Pada saat yang sama, dimungkinkan untuk menjalankan perhitungan berat di utas latar belakang (melalui fungsi komputasi). </p><br><p>  Jadi, menulis dan membaca di SharedPreferences dilakukan secara asinkron (walaupun perpustakaan memungkinkan pembacaan secara sinkron dari cache).  Untuk mulai dengan, kita akan berurusan dengan membaca.  Pendekatan standar untuk pengambilan data asinkron terlihat seperti ini - mulai proses asinkron, dan setelah selesai, jalankan SetState, tulis nilai yang diterima.  Akibatnya, antarmuka pengguna akan diperbarui menggunakan data yang diterima.  Namun, dalam hal ini, kami tidak bekerja dengan data, tetapi dengan posisi gulir.  Kita tidak perlu memperbarui antarmuka, kita hanya perlu memanggil metode jumpTo di ScrollController.  Masalahnya adalah bahwa hasil pemrosesan permintaan asinkron dapat kembali kapan saja dan tidak harus apa dan di mana gulir.  Agar dijamin untuk melakukan operasi pada antarmuka sepenuhnya diinisialisasi, kita perlu ... masih gulir di dalam setState. </p><br><p>  Kami mendapatkan sesuatu seperti kode ini: </p><br><div class="spoiler">  <b class="spoiler_title">Pengaturan negara</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> @override void initState() { super.initState(); //Init scrolling to preserve it scrollController = new ScrollController( initialScrollOffset: widget.getOffsetMethod() ); _restoreState().then((double value) =&gt; scrollController.jumpTo(value)); } Future&lt;double&gt; _restoreState() async { SharedPreferences prefs = await SharedPreferences.getInstance(); return prefs.getDouble('listViewOffset'); } void setScroll(double value) { setState(() { scrollController.jumpTo(value); }); }</code> </pre> </div></div><br><p>  Dengan catatan itu, semuanya jadi lebih menarik.  Faktanya adalah bahwa dalam proses pengguliran, peristiwa yang melaporkan hal ini selalu terjadi.  Memulai perekaman asinkron setiap kali nilai diubah dapat menyebabkan kesalahan aplikasi.  Kami hanya perlu memproses acara terakhir dari rantai.  Dalam hal pemrograman reaktif, ini disebut debounce dan kami akan menggunakannya.  Dart mendukung fitur-fitur utama pemrograman reaktif melalui aliran data, jadi kita perlu membuat aliran dari pembaruan posisi gulir dan berlangganan, mengubahnya dengan menggunakan Debounce.  Untuk mengonversi, kita memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka stream_transformasi</a> .  Sebagai pendekatan alternatif, Anda dapat menggunakan RxDart dan bekerja dengan ReactiveX. </p><br><p>  Ternyata kode berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Catatan Status</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> StreamSubscription _stream; StreamController&lt;double&gt; _controller = new StreamController&lt;double&gt;.broadcast(); @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); _stream = _controller.stream.transform(debounce(new Duration(milliseconds: 500))).listen(_saveState); } void _saveState(double value) async { SharedPreferences prefs = await SharedPreferences.getInstance(); await prefs.setDouble('listViewOffset', value); }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh lengkap</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424765/">https://habr.com/ru/post/id424765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424753/index.html">Apa yang Baru di YouTrack 2018.3</a></li>
<li><a href="../id424755/index.html">Uang suka tagihan: bagaimana mobil menyortir tagihan</a></li>
<li><a href="../id424757/index.html">Intisari acara untuk profesional SDM di bidang TI pada Oktober 2018</a></li>
<li><a href="../id424761/index.html">Pengantar proses boot dan boot kernel Linux</a></li>
<li><a href="../id424763/index.html">Editor teks bukan matematika tertinggi Anda, di sini Anda perlu berpikir</a></li>
<li><a href="../id424767/index.html">Kami membuat kue dari Habr. Lagi</a></li>
<li><a href="../id424771/index.html">Pengalaman pribadi: dari ide dan lembar kosong hingga versi konsep situs</a></li>
<li><a href="../id424773/index.html">Pemodelan biofarma dan numerik: Pengalaman dan praktik Amgen</a></li>
<li><a href="../id424777/index.html">Menggunakan Konsul untuk Skala Layanan Stateful</a></li>
<li><a href="../id424779/index.html">SPA multi-halaman dalam Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>