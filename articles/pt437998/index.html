<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üïäÔ∏è ü§µüèª Fil√≥sofos "modernos" de restaurantes em C ++ por meio de atores e CSP ‚ô£Ô∏è üå± üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° algum tempo, um link para o artigo "Modernos fil√≥sofos gastron√¥micos" se espalhou por recursos como Reddit e HackerNews. O artigo √© interessante, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fil√≥sofos "modernos" de restaurantes em C ++ por meio de atores e CSP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437998/"><p>  H√° algum tempo, um link para o artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">"Modernos fil√≥sofos gastron√¥micos" se</a> espalhou por recursos como Reddit e HackerNews.  O artigo √© interessante, mostra v√°rias solu√ß√µes para essa tarefa bem conhecida, implementada no C ++ moderno usando uma abordagem baseada em tarefas.  Se algu√©m ainda n√£o leu este artigo, faz sentido gastar tempo e l√™-lo. </p><br><p>  No entanto, n√£o posso dizer que as solu√ß√µes apresentadas no artigo pareciam simples e compreens√≠veis para mim.  Isso provavelmente se deve ao uso de tarefas.  Muitos deles s√£o criados e despachados atrav√©s de uma variedade de expedidores / serializadores.  Portanto, nem sempre √© claro onde, quando e quais tarefas s√£o executadas. </p><br><p>  Al√©m disso, a abordagem baseada em tarefas n√£o √© a √∫nica poss√≠vel para resolver esses problemas.  Por que n√£o ver como a tarefa dos "fil√≥sofos do jantar" √© resolvida atrav√©s dos modelos de Atores e CSP? </p><br><p>  Portanto, tentei procurar e implementar v√°rias solu√ß√µes para esse problema usando Atores e CSP.  O c√≥digo para essas solu√ß√µes pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">no reposit√≥rio no GitHub</a> .  E sob o cortador, explica√ß√µes e explica√ß√µes, para quem estiver interessado, seja bem-vindo. </p><a name="habracut"></a><br><h1 id="neskolko-obschih-slov">  Algumas palavras comuns </h1><br><p>  Eu n√£o tinha o objetivo de repetir exatamente as decis√µes mostradas no pr√≥prio artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">"Fil√≥sofos modernos de restaurantes"</a> , especialmente porque eu n√£o gosto de nada de fundamental: na verdade, o fil√≥sofo n√£o faz nada com essas decis√µes.  Ele apenas diz "eu quero comer", e ent√£o algu√©m lhe d√° garfos magicamente, ou ele diz "agora n√£o vai funcionar". </p><br><p>  Fica claro por que o autor recorreu a esse comportamento: permite o uso da mesma implementa√ß√£o do ‚Äúfil√≥sofo‚Äù em conjunto com diferentes implementa√ß√µes dos ‚Äúprotocolos‚Äù.  No entanto, parece-me pessoalmente que √© mais interessante quando o "fil√≥sofo" tenta desconectar um primeiro e depois outro.  E quando o "fil√≥sofo" √© for√ßado a lidar com tentativas frustradas de capturar os garfos. </p><br><p>  √â precisamente essas realiza√ß√µes da tarefa dos "fil√≥sofos do jantar" que tentei realizar.  Ao mesmo tempo, algumas solu√ß√µes usaram as mesmas abordagens do artigo mencionado (por exemplo, implementadas pelos protocolos ForkLevelPhilosopherProtocol e WaiterFair). </p><br><p>  Eu constru√≠ minhas decis√µes com base no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> , o que dificilmente surpreender√° quem j√° leu meus artigos antes.  Se algu√©m ainda n√£o ouviu falar do SObjectizer, em poucas palavras: esta √© uma das poucas "estruturas de ator" ao vivo e em desenvolvimento do OpenSource para C ++ (o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">CAF</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">QP / C ++</a> tamb√©m podem ser mencionados, entre outros).  Espero que os exemplos acima com meus coment√°rios sejam suficientemente claros, mesmo para aqueles que n√£o est√£o familiarizados com o SObjectizer.  Caso contr√°rio, terei prazer em responder √†s perguntas nos coment√°rios. </p><br><h1 id="resheniya-na-baze-aktorov">  Solu√ß√µes para Atores </h1><br><p>  Come√ßaremos a discuss√£o das solu√ß√µes implementadas com as baseadas nos Atores.  Primeiro, considere a implementa√ß√£o da solu√ß√£o Edsger Dijkstra, depois passe para v√°rias outras solu√ß√µes e veja como o comportamento de cada uma das solu√ß√µes difere. </p><br><h2 id="reshenie-deykstry">  Decis√£o de Dijkstra </h2><br><p>  Edsger Dijkstra, ele n√£o apenas formulou a tarefa de ‚Äúcomer filofos‚Äù (a formula√ß√£o usando ‚Äúgarfos‚Äù e ‚Äúespaguete‚Äù foi dublado por Tony Hoar), mas tamb√©m prop√¥s uma solu√ß√£o muito simples e bonita.  A saber: os fil√≥sofos s√≥ devem pegar os garfos para aumentar o n√∫mero de garfos, e se o fil√≥sofo conseguiu pegar o primeiro garfo, ele n√£o o largar√° at√© receber o segundo garfo. </p><br><p>  Por exemplo, se um fil√≥sofo precisa usar garfos com os n√∫meros 5 e 6, ent√£o um fil√≥sofo deve primeiro pegar um garfo do n√∫mero 5. Somente ent√£o ele pode pegar um garfo do n√∫mero 6. Assim, se os garfos com n√∫meros mais baixos estiverem √† esquerda dos fil√≥sofos, o fil√≥sofo deve primeiro pegue o garfo esquerdo e s√≥ ent√£o ele poder√° pegar o garfo direito. </p><br><p>  O √∫ltimo fil√≥sofo da lista, que precisa lidar com os garfos nos n√∫meros (N-1) e 0, faz o oposto: ele primeiro pega a bifurca√ß√£o direita com o n√∫mero 0 e depois a bifurca√ß√£o esquerda com o n√∫mero (N-1). </p><br><p>  Para implementar essa abordagem, ser√£o necess√°rios dois tipos de atores: um para garfos e outro para fil√≥sofos.  Se o fil√≥sofo quiser comer, ele envia uma mensagem ao ator de forquilha correspondente para captur√°-lo, e o ator de forquilha responde com uma mensagem de resposta. </p><br><p>  O c√≥digo para implementar essa abordagem pode ser visto <a href="" rel="nofollow">aqui</a> . </p><br><h3 id="soobscheniya">  Mensagens </h3><br><p>  Antes de falar sobre atores, voc√™ precisa observar as mensagens que os atores trocar√£o: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  Quando o ator-fil√≥sofo deseja desligar, ele envia a mensagem <code>take_t</code> para o fork fork, e o fork fork responde com a mensagem <code>taken_t</code> .  Quando o ator-fil√≥sofo termina de comer e quer colocar os garfos de volta na mesa, ele envia mensagens de put_t ao <code>put_t</code> garfos. </p><br><p>  Na mensagem <code>take_t</code> , o campo <code>take_t</code> indica a caixa de correio (aka mbox) do ator fil√≥sofo.  Uma mensagem de resposta <code>taken_t</code> deve ser enviada para esta <code>taken_t</code> .  O segundo campo de <code>take_t</code> n√£o √© usado neste exemplo, precisamos dele quando chegarmos √†s implementa√ß√µes de waiter_with_queue e waiter_with_timestamps. </p><br><h3 id="aktor-vilka">  Garfo de ator </h3><br><p>  Agora podemos ver o que √© um ator de fork.  Aqui est√° o c√≥digo dele: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     'free'. this &gt;&gt;= st_free; //   'free'    . st_free .event( [this]( mhood_t&lt;take_t&gt; cmd ) { this &gt;&gt;= st_taken; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } ); //   'taken'   . st_taken .event( [this]( mhood_t&lt;take_t&gt; cmd ) { //     . m_queue.push( cmd-&gt;m_who ); } ) .event( [this]( mhood_t&lt;put_t&gt; ) { if( m_queue.empty() ) //     . this &gt;&gt;= st_free; else { //      . const auto who = m_queue.front(); m_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); } private : //    . const state_t st_free{ this, "free" }; const state_t st_taken{ this, "taken" }; //   . std::queue&lt; so_5::mbox_t &gt; m_queue; };</span></span></code> </pre> <br><p>  Cada ator no SObjectizer deve ser derivado da classe base <code>agent_t</code> .  O que vemos aqui para o tipo <code>fork_t</code> . </p><br><p>  O m√©todo <code>so_define_agent()</code> √© substitu√≠do na classe <code>so_define_agent()</code> .  Este √© um m√©todo especial, chamado automaticamente pelo SObjectizer ao registrar um novo agente.  No m√©todo <code>so_define_agent()</code> , o <code>so_define_agent()</code> √© "configurado" para funcionar no SObjectizer: o estado inicial √© alterado, as mensagens necess√°rias s√£o assinadas. </p><br><p>  Cada ator no SObjectizer √© uma m√°quina de estados com estados (mesmo que um ator use apenas um estado padr√£o).  O ator <code>fork_t</code> possui dois estados: <em>livre</em> e <em>obtido</em> .  Quando um ator est√° em um estado <em>livre</em> , o plug pode ser "capturado" pelo fil√≥sofo.  E depois de capturar o "fork", o ator <code>fork_t</code> deve entrar no estado <em>tomado</em> .  Dentro da classe <code>fork_t</code> estados s√£o representados por inst√¢ncias de <code>st_free</code> e <code>st_taken</code> tipo especial <code>state_t</code> . </p><br><p>  Os estados permitem processar mensagens recebidas de diferentes maneiras.  Por exemplo, no estado <em>livre</em> , o agente responde apenas a <code>take_t</code> e essa rea√ß√£o √© muito simples: o estado do ator muda e a resposta <code>taken_t</code> : </p><br><pre> <code class="cpp hljs">st_free .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } );</code> </pre> <br><p>  Enquanto todas as outras mensagens, incluindo <code>put_t</code> no estado <em>livre</em> , s√£o simplesmente ignoradas. </p><br><p>  No estado <em>tomado</em> , o ator processa duas mensagens e, mesmo a mensagem <code>take_t</code> processa de maneira diferente: </p><br><pre> <code class="cpp hljs">st_taken .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { m_queue.push( cmd-&gt;m_who ); } ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_queue.empty() ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> who = m_queue.front(); m_queue.pop(); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( who ); } } );</code> </pre> <br><p>  O manipulador para <code>put_t</code> mais interessante <code>put_t</code> : se a fila de fil√≥sofos em espera estiver vazia, podemos voltar a <em>liberar</em> , mas se n√£o estiver vazia, o primeiro deles precisar√° ser enviado como <code>taken_t</code> . </p><br><h3 id="aktor-filosof">  Ator fil√≥sofo </h3><br><p>  <a href="" rel="nofollow">O c√≥digo do ator-fil√≥sofo √©</a> muito mais volumoso, por isso n√£o o darei aqui na √≠ntegra.  Discutiremos apenas os fragmentos mais significativos. </p><br><p>  Um ator-fil√≥sofo tem um pouco mais de estados: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_thinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"thinking.normal"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_left{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_right{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_eating{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"eating"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_done{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span> };</code> </pre> <br><p>  O ator come√ßa seu trabalho em um estado de <em>pensamento</em> , depois muda para <em>wait_left</em> , depois <em>wait_right</em> e depois para <em>comer</em> .  Ao <em>comer, um</em> ator pode voltar a <em>pensar</em> ou pode <em>terminar</em> se o fil√≥sofo comeu tudo o que deveria. </p><br><p>  O diagrama de estado para um ator-fil√≥sofo pode ser representado da seguinte maneira: </p><br><p><img src="https://habrastorage.org/webt/ir/j0/sm/irj0smrzaedcsud20y71aynfqb4.png" alt="imagem"></p><br><p>  A l√≥gica do comportamento do ator √© descrita na implementa√ß√£o de seu m√©todo <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   thinking     stop_thinking. st_thinking .event( [=]( mhood_t&lt;stop_thinking_t&gt; ) { //    . this &gt;&gt;= st_wait_left; so_5::send&lt; take_t &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); //        taken. st_wait_left .event( [=]( mhood_t&lt;taken_t&gt; ) { //     .   . this &gt;&gt;= st_wait_right; so_5::send&lt; take_t &gt;( m_right_fork, so_direct_mbox(), m_index ); } ); //    ,    taken. st_wait_right .event( [=]( mhood_t&lt;taken_t&gt; ) { //    ,  . this &gt;&gt;= st_eating; } ); //      stop_eating. st_eating // 'stop_eating'        'eating'. .on_enter( [=] { so_5::send_delayed&lt; stop_eating_t &gt;( *this, eat_pause() ); } ) .event( [=]( mhood_t&lt;stop_eating_t&gt; ) { //      . so_5::send&lt; put_t &gt;( m_right_fork ); so_5::send&lt; put_t &gt;( m_left_fork ); //     . ++m_meals_eaten; if( m_meals_count == m_meals_eaten ) this &gt;&gt;= st_done; //  ,  ,  . else think(); } ); st_done .on_enter( [=] { //   ,   . completion_watcher_t::done( so_environment(), m_index ); } ); }</span></span></code> </pre> <br><p>  Talvez o √∫nico ponto que deva ser particularmente enfatizado seja a abordagem para imitar os processos de "pensar" e "comer".  N√£o h√° <code>this_thread::sleep_for</code> no c√≥digo do ator ou qualquer outra maneira de bloquear o segmento de trabalho atual.  Em vez disso, as mensagens pendentes s√£o usadas.  Por exemplo, quando um ator entra no estado <em>alimentar</em> , ele envia para si uma mensagem pendente <code>stop_eating_t</code> .  Esta mensagem √© dada ao cron√¥metro do SObjectizer e o cron√¥metro entrega a mensagem ao ator quando chegar a hora. </p><br><p>  O uso de mensagens atrasadas permite executar todos os atores no contexto de um √∫nico encadeamento de trabalho.  Grosso modo, um encadeamento l√™ mensagens de alguma fila e arranca o pr√≥ximo manipulador de mensagens do ator destinat√°rio correspondente.  Mais sobre contextos de trabalho para atores ser√£o discutidos abaixo. </p><br><h3 id="rezultaty">  Resultados </h3><br><p>  Os resultados desta implementa√ß√£o podem ter a seguinte apar√™ncia (um pequeno fragmento): </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttLRRRRRRRRRRRRRREEEEEEEttttttttLRRRRRRRRRRRRRREEEEEEEEEEEEE Plato: ttttttttttEEEEEEEEEEEEEEEEttttttttttRRRRRREEEEEEEEEEEEEEttttttttttLLL Aristotle: ttttEEEEEtttttttttttLLLLLLRRRREEEEEEEEEEEEttttttttttttLLEEEEEEEEEEEEE Descartes: tttttLLLLRRRRRRRREEEEEEEEEEEEEtttLLLLLLLLLRRRRREEEEEEttttttttttLLLLLL Spinoza: ttttEEEEEEEEEEEEEttttttttttLLLRRRREEEEEEEEEEEEEttttttttttRRRREEEEEEtt Kant: ttttttttttLLLLLLLRREEEEEEEEEEEEEEEttttttttttLLLEEEEEEEEEEEEEEtttttttt Schopenhauer: ttttttEEEEEEEEEEEEEttttttLLLLLLLLLEEEEEEEEEttttttttLLLLLLLLLLRRRRRRRR Nietzsche: tttttttttLLLLLLLLLLEEEEEEEEEEEEEttttttttLLLEEEEEEEEEttttttttRRRRRRRRE Wittgenstein: ttttEEEEEEEEEEtttttLLLLLLLLLLLLLEEEEEEEEEttttttttttttRRRREEEEEEEEEEEt Heidegger: tttttttttttLLLEEEEEEEEEEEEEEtttttttLLLLLLREEEEEEEEEEEEEEEtttLLLLLLLLR Sartre: tttEEEEEEEEEttttLLLLLLLLLLLLRRRRREEEEEEEEEtttttttLLLLLLLLRRRRRRRRRRRR</code> </pre> <br><p>  Leia isto da seguinte maneira: </p><br><ul><li>  <code>t</code> denota que o fil√≥sofo est√° "pensando"; </li><li>  <code>L</code> significa que o fil√≥sofo espera capturar o garfo esquerdo (no estado <em>wait_left</em> ) </li><li>  <code>R</code> significa que o fil√≥sofo espera capturar a bifurca√ß√£o correta (est√° no estado <em>wait_right</em> ); </li><li>  <code>E</code> significa que o fil√≥sofo "come". </li></ul><br><p>  Podemos ver que S√≥crates pode pegar o garfo √† esquerda somente depois que Sartre o der.  Ap√≥s o que S√≥crates esperar√° at√© Plat√£o soltar o garfo certo.  S√≥ depois S√≥crates poder√° comer. </p><br><h2 id="prostoe-reshenie-bez-arbitra-oficianta">  Uma decis√£o simples sem um √°rbitro (gar√ßom) </h2><br><p>  Se analisarmos o resultado da decis√£o de Dijkstra, veremos que os fil√≥sofos passam muito tempo esperando a captura dos garfos.  O que n√£o √© bom, porque  esse tempo tamb√©m pode ser gasto em reflex√£o.  N√£o √© √† toa que existe uma opini√£o de que, se voc√™ pensar com o est√¥mago vazio, poder√° obter resultados muito mais interessantes e inesperados;) </p><br><p>  Vejamos a solu√ß√£o mais simples, na qual o fil√≥sofo retorna o primeiro garfo capturado se n√£o puder capturar o segundo (no artigo "Fil√≥sofos modernos de restaurantes" mencionado acima, essa solu√ß√£o √© implementada pelo ForkLevelPhilosopherProtocol). </p><br><p>  O c√≥digo fonte desta implementa√ß√£o pode ser visto <a href="" rel="nofollow">aqui</a> e o c√≥digo do ator fil√≥sofo correspondente <a href="" rel="nofollow">aqui</a> . </p><br><h3 id="soobscheniya-1">  Mensagens </h3><br><p>  Esta solu√ß√£o usa quase o mesmo conjunto de mensagens: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">busy_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  A √∫nica diferen√ßa √© a presen√ßa do sinal <code>busy_t</code> .  O ator-garfo envia esse sinal em resposta ao fil√≥sofo-ator se o garfo j√° foi capturado por outro fil√≥sofo. </p><br><h3 id="aktor-vilka-1">  Garfo de ator </h3><br><p>  O ator de garfo nesta solu√ß√£o √© ainda mais simples do que na solu√ß√£o da Dijkstra: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; st_free.event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } ); st_taken.event( []( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( cmd-&gt;m_who ); } ) .just_switch_to&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( st_free ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_taken{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; };</code> </pre> <br><p>  Aqui nem precisamos manter a fila de fil√≥sofos que aguardam. </p><br><h3 id="aktor-filosof-1">  Ator fil√≥sofo </h3><br><p>  O fil√≥sofo-ator nesta implementa√ß√£o √© semelhante ao da solu√ß√£o de Dijkstra, mas aqui o fil√≥sofo-ator tamb√©m precisa processar <code>busy_t</code> , de modo que o diagrama de estado se parece com o seguinte: </p><br><p><img src="https://habrastorage.org/webt/xa/ek/c8/xaekc8xbxewoj1e7myao4le6jn0.png" alt="imagem"></p><br><p>  Da mesma forma, toda a l√≥gica de um ator-fil√≥sofo √© definida em <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ st_thinking .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_thinking_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_left; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); st_wait_left .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_right; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_right_fork, so_direct_mbox(), m_index ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { think( st_hungry_thinking ); } ); st_wait_right .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_eating; } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); think( st_hungry_thinking ); } ); st_eating .on_enter( [=] { so_5::send_delayed&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, eat_pause() ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_right_fork ); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); ++m_meals_eaten; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_meals_count == m_meals_eaten ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_done; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> think( st_normal_thinking ); } ); st_done .on_enter( [=] { <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span>::done( so_environment(), m_index ); } ); }</code> </pre> <br><p>  Em geral, esse √© quase o mesmo c√≥digo da solu√ß√£o da Dijkstra, exceto alguns manipuladores para <code>busy_t</code> . </p><br><h3 id="rezultaty-1">  Resultados </h3><br><p>  Os resultados do trabalho parecem diferentes: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttL..R.....EEEEEEEEEEEEttttttttttR...LL..EEEEEEEttEEEEEE Plato: ttttEEEEEEEEEEEttttttL.....L..EEEEEEEEEEEEEEEttttttttttL....L.... Aristotle: ttttttttttttL..LR.EEEEEEtttttttttttL..L....L....R.....EEEEEEEEE Descartes: ttttttttttEEEEEEEEttttttttttttEEEEEEEEttttEEEEEEEEEEEttttttL..L.. Spinoza: ttttttttttL.....L...EEEEEEtttttttttL.L......L....L..L...R...R...E Kant: tttttttEEEEEEEttttttttL.L.....EEEEEEEEttttttttR...R..R..EEEEEtttt Schopenhauer: tttR..R..L.....EEEEEEEttttttR.....L...EEEEEEEEEEEEEEEEttttttttttt Nietzsche: tttEEEEEEEEEEtttttttttEEEEEEEEEEEEEEEttttL....L...L..L....EEEEEEE Wittgenstein: tttttL.L..L.....RR....L.....L....L...EEEEEEEEEEEEEEEtttttttttL. Heidegger: ttttR..R......EEEEEEEEEEEEEttttttttttR..L...L...L..L...EEEEtttttt Sartre: tttEEEEEEEtttttttL..L...L....R.EEEEEEEtttttEEEEtttttttR.....R..R.</code> </pre> <br><p>  Aqui vemos um novo s√≠mbolo, o que significa que o ator-fil√≥sofo est√° em "pensamentos famintos". </p><br><p>  Mesmo neste pequeno fragmento, pode-se ver que h√° longos per√≠odos de tempo durante os quais o fil√≥sofo n√£o pode comer.  Isso ocorre porque esta solu√ß√£o est√° protegida do problema de conflito, mas n√£o possui prote√ß√£o contra a fome. </p><br><h2 id="reshenie-s-oficiantom-i-ocheredyu">  A decis√£o com o gar√ßom e a fila </h2><br><p>  A solu√ß√£o mais simples mostrada acima sem um √°rbitro n√£o protege contra a fome.  O artigo "Fil√≥sofos modernos de restaurantes" mencionado acima cont√©m uma solu√ß√£o para o problema do jejum na forma de um protocolo WaiterFair.  A conclus√£o √© que existe um √°rbitro (gar√ßom), ao qual os fil√≥sofos recorrem quando querem comer.  E o gar√ßom tem uma fila de pedidos de fil√≥sofos.  E o fil√≥sofo s√≥ consegue os garfos se os dois estiverem livres agora, e n√£o h√° nenhum vizinho do fil√≥sofo que se voltou para o gar√ßom na fila. </p><br><p>  Vamos dar uma olhada em como essa mesma solu√ß√£o pode aparecer nos atores. </p><br><p>  O c√≥digo fonte desta implementa√ß√£o pode ser encontrado <a href="" rel="nofollow">aqui</a> . </p><br><h3 id="tryuk">  Truque </h3><br><p>  A maneira mais f√°cil seria introduzir um novo conjunto de mensagens atrav√©s do qual os fil√≥sofos pudessem se comunicar com o gar√ßom.  Mas eu queria salvar n√£o apenas o conjunto de mensagens j√° existente (por exemplo, <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> , <code>put_t</code> ).  Eu tamb√©m queria que o mesmo ator-fil√≥sofo fosse usado como na solu√ß√£o anterior.  Portanto, tive que resolver um problema complicado: como fazer o ator-fil√≥sofo se comunicar com o √∫nico ator-gar√ßom, mas ao mesmo tempo pensei que ele interage diretamente com os atores-garfos (que j√° se foram). </p><br><p>  Esse problema foi resolvido usando um truque simples: um ator-gar√ßom cria um conjunto de mbox-s, links aos quais s√£o dados aos fil√≥sofos-atores como links para atores-mbox de plugues.  Ao mesmo tempo, o ator-gar√ßom se inscreve nas mensagens de todas essas mboxes (o que √© facilmente implementado no SObjectizer, porque o SObjectizer √© uma implementa√ß√£o n√£o apenas / do maior n√∫mero de modelos de atores, mas tamb√©m de suporte a publica√ß√£o / publica√ß√£o) . </p><br><p>  No c√≥digo, parece algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waiter_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">waiter_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> forks_count ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } , m_fork_states( forks_count, <span class="hljs-keyword"><span class="hljs-keyword">fork_state_t</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//  mbox-   "" m_fork_mboxes.reserve( forks_count ); for( std::size_t i{}; i != forks_count; ++i ) m_fork_mboxes.push_back( so_environment().create_mbox() ); } ... void so_define_agent() override { //      "". for( std::size_t i{}; i != m_fork_mboxes.size(); ++i ) { //     .   . //          //    . so_subscribe( fork_mbox( i ) ) .event( [i, this]( mhood_t&lt;take_t&gt; cmd ) { on_take_fork( std::move(cmd), i ); } ) .event( [i, this]( mhood_t&lt;put_t&gt; cmd ) { on_put_fork( std::move(cmd), i ); } ); } } private : ... //     "". std::vector&lt; so_5::mbox_t &gt; m_fork_mboxes;</span></span></code> </pre> <br><p>  I.e.  Primeiro, crie um vetor de mbox-s para "garfos" inexistentes e depois assine cada um deles.  Sim, assinamos para saber a qual plug espec√≠fico o pedido se refere. </p><br><p>  O manipulador real da solicita√ß√£o de entrada <code>on_take_fork()</code> √© o m√©todo <code>on_take_fork()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_take_fork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">take_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,       //    . if( fork_index == cmd-&gt;m_philosopher_index ) handle_take_left_fork( std::move(cmd), fork_index ); else handle_take_right_fork( std::move(cmd), fork_index ); }</span></span></code> </pre> <br><p>  A prop√≥sito, foi aqui que precis√°vamos do segundo campo da mensagem <code>take_t</code> . </p><br><p>  Portanto, em <code>on_take_fork()</code> , temos a solicita√ß√£o original e o √≠ndice da bifurca√ß√£o √† qual a solicita√ß√£o est√° relacionada.  Portanto, podemos determinar se o fil√≥sofo pede um garfo esquerdo ou direito.  E, portanto, podemos process√°-los de maneira diferente (e precisamos process√°-los de maneira diferente). </p><br><p>  Como o fil√≥sofo sempre pede primeiro o garfo esquerdo, precisamos fazer todas as verifica√ß√µes necess√°rias neste exato momento.  E podemos nos encontrar em uma das seguintes situa√ß√µes: </p><br><ol><li>  Ambos os garfos s√£o gratuitos e podem ser dados ao fil√≥sofo que enviou o pedido.  Nesse caso, <code>taken_t</code> fil√≥sofo e marcamos o garfo direito como reservado, para que ningu√©m mais possa peg√°-lo. </li><li>  Forks n√£o pode ser dado ao fil√≥sofo.  N√£o importa o porqu√™.  Talvez alguns deles estejam ocupados agora.  Ou na fila √© um dos vizinhos do fil√≥sofo.  Enfim, colocamos o fil√≥sofo que enviou a solicita√ß√£o na fila, ap√≥s o que <code>busy_t</code> ele. </li></ol><br><p>  Gra√ßas a essa l√≥gica de trabalho, o fil√≥sofo que recebeu o <code>taken_t</code> para a bifurca√ß√£o esquerda pode enviar com seguran√ßa um pedido de <code>take_t</code> para a bifurca√ß√£o direita.  Este pedido ser√° imediatamente satisfeito, como  o garfo j√° est√° reservado para esse fil√≥sofo. </p><br><h3 id="rezultaty-2">  Resultados </h3><br><p>  Se voc√™ executar a solu√ß√£o resultante, poder√° ver algo como: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttL....EEEEEEEEEEEEEEttttttttttL...L...EEEEEEEEEEEEEtttttL. Plato: tttttttttttL....L..L..L...L...EEEEEEEEEEEEEtttttL.....L....L.....EEE Aristotle: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Descartes: ttEEEEEEEEEEtttttttL.L..EEEEEEEEEEEEtttL..L....L....L.....EEEEEEEEEE Spinoza: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Kant: ttEEEEEEEEEEEEEtttttttL...L.....L.....EEEEEttttL....L...L..L...EEEEE Schopenhauer: ttttL...L.....L.EEEEEEEEEEEEEEEEEtttttttttttL..L...L..EEEEEEEttttttt Nietzsche: tttttttttttL....L..L..L...L...L.....L....EEEEEEEEEEEEttL.....L...L.. Wittgenstein: tttttttttL....L...L....L....L...EEEEEEEttttL......L.....L.....EEEEEE Heidegger: ttttttL..L...L.....EEEEEEEEEEEEtttttL...L..L.....EEEEEEEEEEEttttttL. Sartre: ttEEEEEEEEEEEEEttttttttL.....L...EEEEEEEEEEEEttttttttttttL.....EEEEE</code> </pre> <br><p>  Voc√™ pode prestar aten√ß√£o √† falta de caracteres <code>R</code>  Isso ocorre porque falhas ou expectativas n√£o podem ocorrer em uma solicita√ß√£o de bifurca√ß√£o correta. </p><br><h2 id="esche-odno-reshenie-s-ispolzovaniem-arbitra-oficianta">  Outra decis√£o usando um √°rbitro (gar√ßom) </h2><br><p>  Em alguns casos, a solu√ß√£o waiter_with_queue anterior pode mostrar resultados semelhantes a este: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttEEEEEEEEEEEEEEtttL.....LL...L....EEEEEEEEEttttttttttL....L.....EE Plato: tttttL..L..L....LL...EEEEEEEEEEEEEEEttttttttttttL.....EEEEEEEEEttttttt Aristotle: tttttttttttL..L...L.....L.....L....L.....EEEEEEEEEEEEtttttttttttL....L.. Descartes: ttttttttttEEEEEEEEEEttttttL.....L....L..L.....L.....L..L...L..EEEEEEEEtt Spinoza: tttttttttttL..L...L.....L.....L....L.....L..L..L....EEEEEEEEEEtttttttttt Kant: tttttttttL....L....L...L...L....L..L...EEEEEEEEEEEttttttttttL...L......E Schopenhauer: ttttttL....L..L...L...LL...L...EEEEEtttttL....L...L.....EEEEEEEEEttttt Nietzsche: tttttL..L..L....EEEEEEEEEEEEEttttttttttttEEEEEEEEEEEEEEEttttttttttttL... Wittgenstein: tttEEEEEEEEEEEEtttL....L....L..EEEEEEEEEtttttL..L..L....EEEEEEEEEEEEEEEE Heidegger: tttttttttL...L..EEEEEEEEttttL..L.....L...EEEEEEEEEtttL.L..L...L....L...L Sartre: ttttttttttL..L....L...L.EEEEEEEEEEEtttttL...L..L....EEEEEEEEEEtttttttttt</code> </pre> <br><p>  Voc√™ pode ver a presen√ßa de per√≠odos suficientemente longos em que os fil√≥sofos n√£o podem comer, apesar da presen√ßa de garfos gratuitos.  Por exemplo, os garfos esquerdo e direito de Kant ficam livres por um longo tempo, mas Kant n√£o pode peg√°-los, porque  seus vizinhos j√° est√£o esperando na fila.  Que est√£o esperando por seus vizinhos.  Quem est√° esperando seus vizinhos, etc. </p><br><p>  Portanto, a implementa√ß√£o de waiter_with_queue discutida acima protege contra a fome no sentido de que mais cedo ou mais tarde o fil√≥sofo comer√°.  Isso √© garantido para ele.  Mas os per√≠odos de jejum podem ser bastante longos.  E a utiliza√ß√£o de recursos pode n√£o ser ideal √†s vezes. </p><br><p>  Para resolver esse problema, implementei outra solu√ß√£o, waiter_with_timestamp (seu c√≥digo pode ser encontrado <a href="" rel="nofollow">aqui</a> ).  Em vez de fazer fila, eles priorizam solicita√ß√µes de fil√≥sofos, levando em considera√ß√£o o tempo de seu jejum.  Quanto mais o fil√≥sofo passa fome, mais prioriza seu pedido. </p><br><p>  N√£o consideraremos o c√≥digo para esta solu√ß√£o, porque  em geral, o principal √© o mesmo truque com um conjunto de mboxes para "garfos" inexistentes, que j√° discutimos na conversa sobre a implementa√ß√£o de waiter_with_queue. </p><br><h2 id="neskolko-detaley-realizacii-na-kotorye-hotelos-by-obratit-vnimanie">  Alguns detalhes de implementa√ß√£o que gostaria de chamar a aten√ß√£o </h2><br><p>  Existem v√°rios detalhes nas implementa√ß√µes baseadas nos atores que eu gostaria de prestar aten√ß√£o, porque  esses detalhes demonstram recursos interessantes do SObjectizer. </p><br><h3 id="rabochiy-kontekst-dlya-aktorov">  Contexto de trabalho para atores </h3><br><p>  Nas implementa√ß√µes consideradas, todos os principais atores ( <code>fork_t</code> , <code>philosopher_t</code> , <code>waiter_t</code> ) trabalharam no contexto de um thread de trabalho comum.  O que n√£o significa que no SObjectizer todos os atores trabalhem em apenas um √∫nico thread.  No SObjectizer, voc√™ pode vincular atores a diferentes contextos, o que pode ser visto, por exemplo, no c√≥digo de fun√ß√£o <code>run_simulation()</code> na solu√ß√£o no_waiter_simple. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo Run_simulation de no_waiter_simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * &gt; forks( count, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) forks[ i ] = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span> &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span> &gt;( i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</code> </pre> </div></div><br><p>  Nesta fun√ß√£o, atores adicionais dos tipos <code>trace_maker_t</code> e <code>completion_watcher_t</code> .  Eles trabalhar√£o em contextos de trabalho individuais.  Para fazer isso, duas inst√¢ncias do expedidor do tipo <code>one_thread</code> s√£o <code>one_thread</code> e os atores s√£o vinculados a essas inst√¢ncias dos expedidores.  O que significa que esses atores funcionar√£o como <em>objetos ativos</em> : cada um ter√° seu pr√≥prio segmento de trabalho. </p><br><p>  O SObjectizer fornece um conjunto de v√°rios despachantes diferentes que podem ser usados ‚Äã‚Äãimediatamente.  Nesse caso, o desenvolvedor pode criar em seu aplicativo quantas inst√¢ncias de expedidores quantas forem necess√°rias. </p><br><p>    ,        ,       . ,      <code>fork_t</code>     ,   <code>philosopher_t</code>   . </p><br><div class="spoiler"> <b class="spoiler_title"> run_simulation  no_waiter_simple_tp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-comment"><span class="hljs-comment">//     thread_pool-. so_5::disp::thread_pool::bind_params_t bind_params; bind_params.fifo( so_5::disp::thread_pool::fifo_t::individual ); std::vector&lt; so_5::agent_t * &gt; forks( count, nullptr ); //     -. auto fork_disp = so_5::disp::thread_pool::create_private_disp( env, 3u //  . ); for( std::size_t i{}; i != count; ++i ) //      . forks[ i ] = coop.make_agent_with_binder&lt; fork_t &gt;( fork_disp-&gt;binder( bind_params ) ); //     -. auto philosopher_disp = so_5::disp::thread_pool::create_private_disp( env, 6u //  . ); for( std::size_t i{}; i != count; ++i ) coop.make_agent_with_binder&lt; philosopher_t &gt;( philosopher_disp-&gt;binder( bind_params ), i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + 1) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</span></span></code> </pre> </div></div><br><p>            <code>fork_t</code>  <code>philosopher_t</code> . </p><br><h3 id="trassirovka-smeny-sostoyaniy-aktorov">     </h3><br><p>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Modern dining philosophers</a>    ,     , : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ eventLog_.startActivity(ActivityType::eat); wait(randBetween(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>)); eventLog_.endActivity(ActivityType::eat);</code> </pre> <br><p>          SObjectizer   .  ,   , .  Devido a qu√™? </p><br><p>   ,   SObjectizer-   :   .       <code>agent_state_listener_t</code> .     ,  SObjectizer        . </p><br><p>        <code>greedy_philosopher_t</code>  <code>philosopher_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>(...) ... { so_add_destroyable_listener( <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::make( so_environment(), index ) ); }</code> </pre> <br><p>  <code>state_watcher_t</code> ‚Äî       . </p><br><div class="spoiler"> <b class="spoiler_title"> state_watcher_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_watcher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_index; <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_unique_ptr_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span>::make_mbox(env), index } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">agent_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">state_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; state )</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> </div></div><br><p>   <code>state_watcher_t</code>    SObjectizer   <code>changed()</code>    .    <code>state_watcher_t::changed</code>      -. </p><br><div class="spoiler"> <b class="spoiler_title">  state_watcher_t::changed</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::changed( so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> &amp; state ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> detect_label = []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; name ) {...}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state_label = detect_label( state.query_name() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">'?'</span></span> == state_label ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; so_5::send&lt; trace::<span class="hljs-keyword"><span class="hljs-keyword">state_changed_t</span></span> &gt;( m_mbox, m_index, state_label ); }</code> </pre> </div></div><br><h1 id="resheniya-na-baze-csp">    CSP </h1><br><p>     ,     .       (no_waiter_dijkstra, no_waiter_simple, waiter_with_timestamps)     <code>std::thread</code>  SObjectizer- mchain- (,  ,  CSP- ). ,  ,  CSP-        (   <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ). </p><br><p>  CSP-  ""   .   ,         <code>std::thread</code> . </p><br><h2 id="reshenie-deykstry-1">   </h2><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki">    </h3><br><p>         :       +    <code>take_t</code>  <code>put_t</code> .    <code>fork_process</code>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //   . std::queue&lt; so_5::mbox_t &gt; wait_queue; //        . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) //  ,     . wait_queue.push( cmd-&gt;m_who ); else { //    . taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( wait_queue.empty() ) taken = false; //     . else { //       . const auto who = wait_queue.front(); wait_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); }</span></span></code> </pre> <br><p>   <code>fork_process</code>   :  ,   -   . </p><br><p>    <code>fork_process</code> ‚Äî  ""       ,     .        <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) {...} );</code> </pre> <br><p>  SObjectizer-     <code>receive()</code>       .           .      .   ,      .   ,    . </p><br><p>      -.           <code>fork_t</code>     . ,  ,  . </p><br><h3 id="nit-dlya-filosofa">    </h3><br><p>       <code>philosopher_process</code> .      ,        . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">oid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-comment"><span class="hljs-comment">//         . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type_t::normal ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type_t::normal ) ); //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    .  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //     . so_5::send&lt; put_t &gt;( right_fork ); } ); //     . so_5::send&lt; put_t &gt;( left_fork ); } ); } //   ,   . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span></span></code> </pre> <br><p>         . </p><br><p>     SObjectizer- ,             ,       Actor-.         : </p><br><pre> <code class="cpp hljs">tracer.thinking_started( philosopher_index, <span class="hljs-keyword"><span class="hljs-keyword">thinking_type_t</span></span>::normal );</code> </pre> <br><p>   <code>tracer</code>      ,     . </p><br><p>  <code>control_ch</code>  ,       <code>philosopher_done_t</code>  ,    ,   .            . </p><br><p>  <code>left_fork</code>  <code>right_fork</code>      .        <code>take_t</code>  <code>put_t</code> .    ,     <code>mbox_t</code>  <code>mchain_t</code> ? </p><br><p>   !       ,    .    ,  mchain ‚Äî  -   mbox-,    mchain-     <code>mbox_t</code> . </p><br><p>    ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> self_ch = so_5::create_mchain( control_ch-&gt;environment() );</code> </pre> <br><p>     ‚Äî  <code>self_ch</code> .    ,         . </p><br><p>           .  I.e.       ,     . </p><br><p>  ,        ,       <code>this_thread::sleep_for</code>   . </p><br><p>       ,      : </p><br><pre> <code class="cpp hljs">so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index );</code> </pre> <br><p>       <code>take_t</code> .       <code>mbox_t</code> ,   <code>self_ch</code>   <code>mchain_t</code> .              <code>as_mbox()</code> . </p><br><p>     <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p>         <code>taken_t</code>    .      .  ,         . </p><br><p>  -   ,       <code>philosopher_process</code> .        <code>receive()</code>      : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} ); ... } );</code> </pre> <br><p>           -  . </p><br><h3 id="funkciya-zapuska-simulyacii">    </h3><br><p>             <code>run_simulation()</code> ,         .      CSP-  <code>run_simulation()</code>   .     ,       ,       (      ). </p><br><div class="spoiler"> <b class="spoiler_title">   run_simulation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> table_size = names.size(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> join_all = []( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; &amp; threads ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; t : threads ) t.join(); }; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> tracer{ env, names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() }; <span class="hljs-comment"><span class="hljs-comment">//  . std::vector&lt; so_5::mchain_t &gt; fork_chains; std::vector&lt; std::thread &gt; fork_threads( table_size ); for( std::size_t i{}; i != table_size; ++i ) { //     . fork_chains.emplace_back( so_5::create_mchain(env) ); //     . fork_threads[ i ] = std::thread{ fork_process, fork_chains.back() }; } //      . auto control_ch = so_5::create_mchain( env ); //  . const auto philosopher_maker = [&amp;](auto index, auto left_fork_idx, auto right_fork_idx) { return std::thread{ philosopher_process, std::ref(tracer), control_ch, index, fork_chains[ left_fork_idx ]-&gt;as_mbox(), fork_chains[ right_fork_idx ]-&gt;as_mbox(), default_meals_count }; }; std::vector&lt; std::thread &gt; philosopher_threads( table_size ); for( std::size_t i{}; i != table_size - 1u; ++i ) { //      . philosopher_threads[ i ] = philosopher_maker( i, i, i+1u ); } //        . philosopher_threads[ table_size - 1u ] = philosopher_maker( table_size - 1u, table_size - 1u, 0u ); //     . so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::mhood_t&lt;philosopher_done_t&gt; cmd ) { fmt::print( "{}: done\n", names[ cmd-&gt;m_philosopher_index ] ); } ); //     . join_all( philosopher_threads ); //     . for( auto &amp; ch : fork_chains ) so_5::close_drop_content( ch ); //       . join_all( fork_threads ); //  . tracer.done(); //   SObjectizer. env.stop(); }</span></span></code> </pre> </div></div><br><p>  ,    <code>run_simulation()</code>   - .      . </p><br><p>      .        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; fork_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; }</code> </pre> <br><p>       ,   ,    .         .      ,    <code>join</code>  . </p><br><p>                , ..      <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; philosopher_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>; ++i ) { philosopher_threads[ i ] = philosopher_maker( i, i, i+<span class="hljs-number"><span class="hljs-number">1u</span></span> ); } philosopher_threads[ table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span> ] = philosopher_maker( table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, <span class="hljs-number"><span class="hljs-number">0u</span></span> );</code> </pre> <br><p>          .        : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_done_t</span></span>&gt; cmd ) { fmt::print( <span class="hljs-string"><span class="hljs-string">"{}: done\n"</span></span>, names[ cmd-&gt;m_philosopher_index ] ); } );</code> </pre> <br><p>   <code>receive()</code>      <code>table_size</code>   <code>philosopher_done_t</code> . </p><br><p>      <code>philosopher_done_t</code>    . </p><br><p>  <code>join</code>     : </p><br><pre> <code class="cpp hljs">join_all( philosopher_threads );</code> </pre> <br><p>     <code>join</code>    .    <code>join</code> , ..    .        <code>receive()</code>     .              <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ch : fork_chains ) so_5::close_drop_content( ch ); join_all( fork_threads );</code> </pre> <br><p>          . </p><br><h4 id="neskolko-slov-o-noexcept">    noexcept </h4><br><p> ,   <code>run_simulation</code>        ,      <em>noexcept</em> .   ,    exception-safety     .            ‚Äî     . </p><br><p>   <code>run_simulation</code>       ? </p><br><p>  ,                .    - exception-safety      ,    .  -  ,            : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( ... ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != fork_chains.size(); ++i ) { so_5::close_drop_content( fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fork_threads[ i ].joinable() ) fork_threads[ i ].join(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre> <br><p>  ,     .  Porque         ,       .    -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_threads_stuff_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; m_fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; m_fork_threads; <span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> table_size ) : m_fork_threads( table_size ) {} ~<span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_chains.size(); ++i ) { so_5::close_drop_content( m_fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_fork_threads[ i ].joinable() ) m_fork_threads[ i ].join(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_threads.size(); ++i ) { m_fork_chains.emplace_back( so_5::create_mchain(env) ); m_fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, m_fork_chains.back() }; } } } fork_threads_stuff{ table_size }; <span class="hljs-comment"><span class="hljs-comment">//   . fork_threads_stuff.run(); //     . //       fork_threads_stuff.</span></span></code> </pre> <br><p>     ,           (, Boost- ScopeExit-, GSL- finally()   ). </p><br><p>         .       . </p><br><p> ,        exception-safety  <code>run_simulation()</code> ,   <code>run_simulation()</code>   ,    .      ,          -.       exception-safety  <code>run_simulation()</code>     <em>noexcept</em> ,     <code>std::terminate</code>    . ,          . </p><br><p>   ,   ,       ,       ,   .    ,     <code>join</code> ,            <code>join</code> .         . </p><br><h2 id="prostoe-reshenie-bez-ispolzovaniya-arbitra-oficianta">      () </h2><br><p>    ,   CSP-          ,   . </p><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki-1">    </h3><br><p>      <code>fork_process</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //      . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) so_5::send&lt; busy_t &gt;( cmd-&gt;m_who ); else { taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( taken ) taken = false; } ); }</span></span></code> </pre> <br><p>  ,   <code>fork_process</code> ,      (      ,      ). </p><br><h3 id="nit-dlya-filosofa-1">    </h3><br><p>      <code>philosopher_process</code> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//       . thinking_type_t thinking_type{ thinking_type_t::normal }; random_pause_generator_t pause_generator; //      . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type ) ); //  ,     . thinking_type = thinking_type_t::hungry; //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    ,  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //      . so_5::send&lt; put_t &gt;( right_fork ); //        "normal". thinking_type = thinking_type_t::normal; } ); //       . so_5::send&lt; put_t &gt;( left_fork ); } ); } //    . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>  -  <code>philosopher_process</code>     <code>philosopher_process</code>   .     . </p><br><p> -,   <code>thinking_type</code> .    ,      ,     ,      "" . </p><br><p> -,     <code>busy_t</code> .       <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p> ,   <code>busy_t</code> ,   ,           <code>receive()</code> ,       <code>receive()</code> .    <code>busy_t</code>    .      , ..    <code>receive()</code>   <code>busy_t</code>  .     <code>receive()</code>        <code>busy_t</code> . </p><br><h2 id="reshenie-s-oficiantom-i-vremennymi-otmetkami">       </h2><br><p>   CSP-     ,       .            ():    waiter_with_queue,      ,      waiter_with_timestamps.         :    mbox-   ,  mbox-  ,    mbox-  . </p><br><p>      CSP-  ,        <code>philosopher_process</code>   no_waiter_simple.       mchain-           ,  ? </p><br><p>  , . </p><br><p>   mchain-  .   ,       mchain-. </p><br><p>  SObjectizer-   <code>select()</code> ,    , ,    : </p><br><pre> <code class="cpp hljs">so_5::select( so_5::from_all(), case_(ch1, one_handler_1, one_handler_2, one_handler_3, ...), case_(ch2, two_handler_1, two_handler_2, two_handler_3, ...), ...);</code> </pre> <br><p>   <code>select()</code> ,            -.       " "        .   CSP-           . </p><br><p>     . </p><br><p> ,   ,     <code>take_t</code>  <code>put_t</code>      .     -   .         <code>take_t</code>  <code>put_t</code> ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_take_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_take_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> who, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> philosopher_index, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_who{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(who) } , m_philosopher_index{ philosopher_index } , m_fork_index{ fork_index } {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_put_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_put_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_fork_index{ fork_index } {} };</code> </pre> <br><blockquote>  ,       <code>so_5::message_t</code> ,         (     ).         ,      SObjectizer- . </blockquote><p>    ,         .       <code>take_t</code>  <code>put_t</code> ,    <code>extended_take_t</code>  <code>extended_put_t</code> ,    . </p><br><p>      mbox.   :) </p><br><div class="spoiler"> <b class="spoiler_title">  mbox-</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapping_mbox_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_target; //  ,      . const std::size_t m_fork_index; //    . static std::type_index original_take_type; static std::type_index original_put_type; public : wrapping_mbox_t( const so_5::mbox_t &amp; target, std::size_t fork_index ) : base_type_t{ target } , m_target{ target } , m_fork_index{ fork_index } {} //    so_5::abstract_message_box_t   . //       . void do_deliver_message( const std::type_index &amp; msg_type, const so_5::message_ref_t &amp; message, unsigned int overlimit_reaction_deep ) const override { if( original_take_type == msg_type ) { //     . const auto &amp; original_msg = so_5::message_payload_type&lt;::take_t&gt;:: payload_reference( *message ); //     . so_5::send&lt; extended_take_t &gt;( m_target, original_msg.m_who, original_msg.m_philosopher_index, m_fork_index ); } else if( original_put_type == msg_type ) { //     . so_5::send&lt; extended_put_t &gt;( m_target, m_fork_index ); } else base_type_t::do_deliver_message( msg_type, message, overlimit_reaction_deep ); } //       wrapping_mbox_t. static auto make( const so_5::mbox_t &amp; target, std::size_t fork_index ) { return so_5::mbox_t{ new wrapping_mbox_t{ target, fork_index } }; } }; std::type_index wrapping_mbox_t::original_take_type{ typeid(::take_t) }; std::type_index wrapping_mbox_t::original_put_type{ typeid(::put_t) };</span></span></code> </pre> </div></div><br><p>        mbox-:    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">so_5_extra</a>  ,        .           <code>so_5::abstract_message_box_t</code>      . </p><br><p>     ,    <code>wrapping_mbox_t</code> .          ,       .      wrapping_mbox,          mchain .   <code>waiter_process</code> ,      ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waiter_ch, details::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">waiter_logic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; logic )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        . so_5::receive( so_5::from( waiter_ch ), [&amp;]( so_5::mhood_t&lt;details::extended_take_t&gt; cmd ) { logic.on_take_fork( std::move(cmd) ); }, [&amp;]( so_5::mhood_t&lt;details::extended_put_t&gt; cmd ) { logic.on_put_fork( std::move(cmd) ); } ); }</span></span></code> </pre> <br><p>  ,               ,      .      waiter_with_timestamps <a href="" rel="nofollow"></a> . </p><br><p>       : "      <code>philosopher_process</code>  mbox-?"  ,    waiter_with_timestamps    mbox,   mchain. </p><br><p>  ,       mchain.       , ..  so_5_extra        mchain- (    ).          mbox-  mchain-. </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p> , ,  ,          CSP .       ,     .   ,  ,     . ,  -   . </p><br><p>     ,   SObjectizer-.    ,         ""  SObjectizer ‚Äî  5.6,     5.5.        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"></a> ). -   ,    SO-5.6   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"></a> (      ). </p><br><p>     ,          ! </p><br><p>  PS.  ""      ,       .        C++14. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437998/">https://habr.com/ru/post/pt437998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437988/index.html">Tutorial React, Parte 12: Workshop, Aplica√ß√£o TODO da Fase 3</a></li>
<li><a href="../pt437990/index.html">Tutorial Reagir Parte 13: Componentes baseados em classe</a></li>
<li><a href="../pt437992/index.html">Microsservi√ßos. Controle de vers√£o em sistemas de integra√ß√£o cont√≠nua e implanta√ß√£o Estudo de caso de CI / CD usando TFS</a></li>
<li><a href="../pt437994/index.html">Ordenha autom√°tica e estufas autom√°ticas: como funciona uma pequena fazenda de alta tecnologia</a></li>
<li><a href="../pt437996/index.html">SITIS CTF: como o selo ajudou o CTF a vencer</a></li>
<li><a href="../pt438000/index.html">Sucesso e falha na cria√ß√£o do seu projeto (inicializa√ß√£o)</a></li>
<li><a href="../pt438002/index.html">Configurar proxy reverso para Nextcloud e ONLYOFFICE</a></li>
<li><a href="../pt438004/index.html">Apple ou Soul Electronics: desafios e lideran√ßa para fones de ouvido sem fio para fitness</a></li>
<li><a href="../pt438006/index.html">Small Business CRM: segredos para a implementa√ß√£o bem-sucedida</a></li>
<li><a href="../pt438008/index.html">Configurando o equipamento inteligente Zyxel nos modos aut√¥nomo e na nuvem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>