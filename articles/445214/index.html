<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèº üåÅ üë©üèø‚Äçüíº Bombeamos ganchos React con FRP üìá üë©üèæ‚Äçü§ù‚Äçüë®üèº üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habiendo dominado los ganchos, muchos desarrolladores de React han experimentado euforia, finalmente obteniendo un kit de herramientas simple y conven...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bombeamos ganchos React con FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Habiendo dominado los ganchos, muchos desarrolladores de React han experimentado euforia, finalmente obteniendo un kit de herramientas simple y conveniente que le permite implementar tareas con significativamente menos c√≥digo.  Pero, ¬øsignifica esto que los ganchos est√°ndar useState y useReducer que se ofrecen listos para usar son todo lo que necesitamos para administrar el estado? </p><br><p>  En mi opini√≥n, en su forma cruda, su uso no es muy conveniente, es m√°s probable que puedan considerarse como la base para construir ganchos de administraci√≥n estatal realmente convenientes.  Los propios desarrolladores de React fomentan el desarrollo de ganchos personalizados, entonces, ¬øpor qu√© no hacerlo?  Debajo del corte, veremos un ejemplo muy simple y comprensible, lo que est√° mal con los ganchos ordinarios y c√≥mo se pueden mejorar, tanto que se niegan completamente a usarlos en su forma pura. </p><a name="habracut"></a><br><p>  Hay un cierto campo para la entrada, condicionalmente, un nombre.  Y hay un bot√≥n al hacer clic en el cual debemos realizar una solicitud al servidor con el nombre ingresado (una b√∫squeda determinada).  Parece que podr√≠a ser m√°s f√°cil?  Sin embargo, la soluci√≥n est√° lejos de ser obvia.  La primera implementaci√≥n ingenua: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  ¬øQu√© est√° mal aqu√≠?  Si el usuario, ingresando algo en el campo, env√≠a el formulario dos veces, solo la primera solicitud funcionar√° para nosotros, porque  en el segundo clic, la solicitud no cambiar√° y useEffect no funcionar√°.  Si imaginamos que nuestra aplicaci√≥n es un servicio de b√∫squeda de tickets, y el usuario puede enviar el formulario una y otra vez sin hacer cambios, ¬°tal implementaci√≥n no funcionar√° para nosotros!  Usar el nombre como una dependencia para useEffect tambi√©n es inaceptable, de lo contrario, el formulario se enviar√° inmediatamente cuando cambie el texto.  Bueno, tienes que mostrar ingenio. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Ahora, con cada clic, cambiaremos el significado de la solicitud al opuesto, lo que lograr√° el comportamiento deseado.  Esta es una muleta muy peque√±a e inocente, pero hace que el c√≥digo sea algo confuso de entender.  Quiz√°s ahora te parezca que succiono el problema de mi dedo e inflo su escala.  Bueno, para responder si es cierto o no, debe comparar este c√≥digo con otras implementaciones que ofrecen un enfoque m√°s expresivo. </p><br><p>  Veamos este ejemplo a nivel te√≥rico usando abstracci√≥n de hilo.  Es muy conveniente para describir el estado de las interfaces de usuario.  Entonces, tenemos dos flujos: datos ingresados ‚Äã‚Äãen el campo de texto (nombre $) y un flujo de clics en el bot√≥n de env√≠o del formulario (clic $).  A partir de ellos, necesitamos crear un tercer flujo combinado de solicitudes al servidor. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Aqu√≠ est√° el comportamiento que necesitamos lograr.  Cada flujo tiene dos aspectos: el valor que tiene y el momento en el que los valores fluyen a trav√©s de √©l.  En diversas situaciones, podemos necesitar uno u otro aspecto, o ambos.  Puedes comparar esto con el ritmo y la armon√≠a de la m√∫sica.  Las secuencias para las cuales solo el tiempo de respuesta es esencial tambi√©n se denominan se√±ales. </p><br><p>  En nuestro caso, hacer clic en $ es una se√±al pura: no importa qu√© valor fluya a trav√©s de √©l (indefinido / verdadero / Evento / lo que sea), es importante solo cuando esto sucede.  Nombre del caso $ <br>  lo contrario: sus cambios de ninguna manera implican cambios en el sistema, pero es posible que necesitemos su significado en alg√∫n momento.  Y a partir de estos dos flujos necesitamos hacer el tercero, tomando desde el primer tiempo, desde el segundo valor. </p><br><p>  En el caso de Rxjs, tenemos un operador casi listo para esto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  Sin embargo, el uso pr√°ctico de Rx en React puede ser bastante inconveniente.  Una opci√≥n m√°s adecuada es la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mrr</a> , construida sobre los mismos principios funcionales-reactivos que Rx, pero especialmente adaptada para su uso con React seg√∫n el principio de "reactividad total" y conectada como un gancho. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  La interfaz useMrr es similar a useState o useReducer: devuelve un objeto de estado (valores de todos los hilos) y un setter para poner los valores en hilos.  Pero dentro de todo es un poco diferente: cada campo de estado (= secuencia), excepto aquellos en los que colocamos valores directamente de los eventos DOM, se describe mediante una funci√≥n y una lista de subprocesos principales, cuyo cambio har√° que el ni√±o se recalcule.  En este caso, los valores de los hilos primarios ser√°n sustituidos en la funci√≥n.  Si solo queremos obtener el valor de la secuencia, pero no responder a su cambio, entonces escribimos un "menos" delante del nombre, como en el caso del nombre. </p><br><p>  Conseguimos el comportamiento deseado, en esencia, en una l√≠nea.  Pero esto no es solo brevedad.  Comparemos los resultados obtenidos con m√°s detalle y, en primer lugar, con respecto a un par√°metro como la legibilidad y la claridad del c√≥digo resultante. </p><br><p>  En mrr, podr√° separar casi por completo la "l√≥gica" de la "plantilla": no tendr√° que escribir ning√∫n manejador imperativo complejo en JSX.  Todo es extremadamente declarativo: simplemente asignamos el evento DOM al flujo correspondiente, pr√°cticamente sin conversi√≥n (para los campos de entrada, el valor e.target.value se extrae autom√°ticamente, a menos que especifique lo contrario), y ya en la estructura useMrr describimos c√≥mo se forman los flujos base filiales  Por lo tanto, en el caso de las transformaciones de datos sincr√≥nicas y asincr√≥nicas, siempre podemos rastrear f√°cilmente c√≥mo se forma nuestro valor. </p><br><p>  Comparando con Px: ni siquiera tuvimos que usar operadores adicionales: si, como resultado, las funciones de mrr reciben una promesa, esperar√° autom√°ticamente hasta que se resuelva y ponga los datos recibidos en la secuencia.  Adem√°s, en lugar de withLatestFrom, utilizamos <br>  escucha pasiva (signo menos), lo cual es m√°s conveniente.  Imagine que adem√°s del nombre necesitaremos enviar otros campos.  Luego, en mrr agregaremos otra secuencia de escucha pasiva: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  Y en Rx tienes que esculpir uno m√°s con LatestFrom con un mapa, o primero combinar nombre y apellido en una secuencia. </p><br><p>  Pero volvamos a ganchos y mrr.  Un registro m√°s legible de las dependencias, que siempre muestra c√≥mo se forman los datos, es quiz√°s una de las principales ventajas.  La interfaz actual useEffect b√°sicamente no permite responder a flujos de se√±al, raz√≥n por la cual <br>  Tengo que pensar en diferentes giros. </p><br><p>  Otro punto es que la opci√≥n de ganchos ordinarios conlleva representaciones adicionales.  Si el usuario acaba de hacer clic en el bot√≥n, esto a√∫n no implica ning√∫n cambio en la interfaz de usuario que la reacci√≥n necesita dibujar.  Sin embargo, se llamar√° un render.  En la variante con mrr, el estado devuelto solo se actualizar√° cuando ya haya llegado una respuesta del servidor.  ¬øAhorrando en f√≥sforos, dices?  Bueno, tal vez.  Pero para m√≠ personalmente, el principio de "volver a representarte en cualquier situaci√≥n incomprensible", que es la base de los ganchos b√°sicos, causa rechazo. </p><br><p>  Renders adicionales significan una nueva formaci√≥n de controladores de eventos.  Por cierto, aqu√≠ los ganchos comunes son todos malos.  Los manejadores no solo son imprescindibles, sino que tambi√©n deben regenerarse cada vez que se procesan.  Y no ser√° posible usar el almacenamiento en cach√© aqu√≠, porque  muchos manejadores deben estar bloqueados a las variables de componentes internos.  Los manejadores mrr son m√°s declarativos, y el almacenamiento en cach√© ya est√° integrado en mrr: set ('name') se generar√° solo una vez, y se sustituir√° de la cach√© para los renderizados posteriores. </p><br><p>  Con un aumento en la base del c√≥digo, los controladores imperativos pueden volverse a√∫n m√°s engorrosos.  Digamos que tambi√©n necesitamos mostrar el n√∫mero de env√≠os de formularios realizados por el usuario. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  No muy bien parecido.  Por supuesto, puede representar el controlador como una funci√≥n separada dentro del componente.  La legibilidad aumentar√°, pero permanecer√° el problema de regenerar la funci√≥n con cada render, as√≠ como el problema de la imperativa.  En esencia, este es un c√≥digo de procedimiento regular, a pesar de la creencia generalizada de que React API est√° cambiando gradualmente hacia un enfoque funcional. </p><br><p>  Para aquellos para quienes la escala del problema parece exagerada, puedo responder que, por ejemplo, los desarrolladores de React est√°n conscientes del problema de la generaci√≥n excesiva de controladores, ofreci√©ndonos inmediatamente una muleta en forma de useCallback. </p><br><p>  En mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  Una alternativa m√°s conveniente es useReducer, que le permite abandonar el imperativo de los controladores.  Pero quedan otros problemas importantes: la falta de trabajo con las se√±ales (ya que el mismo useEffect ser√° responsable de los efectos secundarios), as√≠ como la peor legibilidad durante las conversiones asincr√≥nicas (en otras palabras, es m√°s dif√≠cil rastrear la relaci√≥n entre los campos de la tienda, debido al mismo useEffect )  Si en mrr el gr√°fico de dependencia entre los campos de estado (subprocesos) es claramente visible de inmediato, en los ganchos debe mirar un poco hacia arriba y hacia abajo. </p><br><p>  Adem√°s, compartir useState y useReducer en el mismo componente no es muy conveniente (de nuevo, habr√° controladores complejos e imperativos que cambiar√°n algo en useState <br>  y acci√≥n de env√≠o), por lo que, muy probablemente, antes de desarrollar el componente, deber√° aceptar una u otra opci√≥n. </p><br><p>  Por supuesto, la consideraci√≥n de todos los aspectos a√∫n puede continuar.  Para no ir m√°s all√° del alcance del art√≠culo, tocar√© algunos puntos menos importantes en su totalidad. </p><br><p>  Registro centralizado, depuraci√≥n.  Como en mrr todas las transmisiones est√°n contenidas en un concentrador, para la depuraci√≥n es suficiente agregar un indicador: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Despu√©s de eso, todos los cambios en las transmisiones se mostrar√°n en la consola.  Para acceder a todo el estado (es decir, los valores actuales de todos los subprocesos), hay un pseudo-flujo $ state: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Por lo tanto, si necesita o est√° muy acostumbrado al estilo editorial, puede escribir en estilo editor en mrr, devolviendo un nuevo valor de campo basado en el evento y todo el estado anterior.  Pero lo contrario (escribir en useReducer o un editor en el estilo mrr) no funcionar√°, debido a la falta de reactividad en estos. </p><br><p>  Trabaja con el tiempo.  ¬øRecuerdas dos aspectos de los flujos: significado y tiempo de respuesta, armon√≠a y ritmo?  Entonces, trabajar con el primero en ganchos ordinarios es bastante simple y conveniente, pero con el segundo, no.  Al trabajar a lo largo del tiempo, me refiero a la formaci√≥n de flujos secundarios, cuyo "ritmo" es diferente del de los padres.  Esto es principalmente todo tipo de filtros, debowns, trotl, etc.  Es muy probable que tenga que implementar todo esto.  En mrr, puede usar declaraciones listas para usar listas para usar.  El conjunto de caballeros MRR es inferior a la variedad de operadores Rx, pero tiene un nombre m√°s intuitivo. </p><br><p>  Interacci√≥n intercomponente.  Recuerdo que en el Editor se consideraba una buena pr√°ctica crear solo una historia.  Si usamos useReducer en muchos componentes, <br>  Puede haber un problema con la organizaci√≥n de la interacci√≥n entre las partes.  En MRR, los flujos pueden "fluir" libremente de un componente a otro hacia arriba o hacia abajo de la jerarqu√≠a, pero esto no crear√° problemas debido al enfoque declarativo.  M√°s detalles <br>  Este tema, as√≠ como otras caracter√≠sticas de la API de MRR, se describen en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actores + FRP en React</a> </p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  Los nuevos ganchos de reacci√≥n son geniales y simplifican nuestras vidas, pero tienen algunos defectos que un gancho de prop√≥sito general de nivel superior (gesti√≥n del estado) puede solucionar.  UseMrr de la biblioteca mrr funcional-reactiva fue propuesta y considerada como tal. </p><br><p>  Problemas y sus soluciones: </p><br><ul><li>  recuentos innecesarios de datos en cada render (en mrr est√°n ausentes debido a la reactividad basada en push) </li><li>  Representaciones adicionales cuando un cambio de estado no implica un cambio en la interfaz de usuario </li><li>  mala legibilidad del c√≥digo con conversiones asincr√≥nicas (en comparaci√≥n con las sincr√≥nicas).  En mrr, el c√≥digo asincr√≥nico no es inferior al sincr√≥nico en cuanto a legibilidad y expresividad.  La mayor√≠a de los problemas discutidos en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo reciente sobre useEffect</a> en mrr son b√°sicamente imposibles </li><li>  controladores imperativos que no siempre se pueden almacenar en cach√© (en mrr se almacenan en cach√© autom√°ticamente, casi siempre se pueden almacenar en cach√©, declarativos) </li><li>  Usar useState y useReducer al mismo tiempo puede crear un c√≥digo inc√≥modo </li><li>  falta de herramientas para convertir flujos a lo largo del tiempo (rebote, aceleraci√≥n, condici√≥n de carrera) </li></ul><br><p>  En muchos puntos, se puede argumentar que pueden resolverse mediante ganchos personalizados.  Pero esto es precisamente lo que se propone, pero en lugar de implementaciones dispares, para cada tarea separada, se propone una soluci√≥n hol√≠stica y consistente. </p><br><p>  Muchos problemas se han vuelto demasiado familiares para que podamos ser claramente reconocidos.  Por ejemplo, las conversiones asincr√≥nicas siempre parec√≠an m√°s complicadas y confusas que las sincr√≥nicas, y los ganchos en este sentido no son peores que los enfoques anteriores (eds, etc.).  Para darse cuenta de esto como un problema, primero debe ver otros enfoques que ofrecen una mejor soluci√≥n. </p><br><p>  Este art√≠culo no pretende imponer puntos de vista espec√≠ficos, sino llamar la atenci√≥n sobre el problema.  Estoy seguro de que existen o se est√°n creando otras soluciones que pueden convertirse en una alternativa valiosa, pero que a√∫n no se conocen ampliamente.  La pr√≥xima API React Cache tambi√©n puede hacer una gran diferencia.  Estar√© encantado de criticar y discutir en los comentarios. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los</a> interesados ‚Äã‚Äãtambi√©n pueden ver una presentaci√≥n sobre este tema en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kyivjs</a> el 28 de marzo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445214/">https://habr.com/ru/post/445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445204/index.html">Conversi√≥n de flujo de bases de datos Firebird 2.5 a formato ODS12 (Firebird 3.0)</a></li>
<li><a href="../445206/index.html">Reduzca el tiempo de inactividad al actualizar Zimbra</a></li>
<li><a href="../445208/index.html">Niveles de madurez de TI empresarial</a></li>
<li><a href="../445210/index.html">Colonia de criptomonedas</a></li>
<li><a href="../445212/index.html">NetBIOS en manos de un hacker</a></li>
<li><a href="../445220/index.html">AMD Radeon VII: Chip de gama alta (Parte 3)</a></li>
<li><a href="../445222/index.html">Obtenga una oferta en 1 d√≠a para el equipo de backend en el D√≠a de la Cosmon√°utica</a></li>
<li><a href="../445226/index.html">El desarrollo de un cohete capaz de alcanzar la luna le costar√° a Rusia 740 mil millones de rublos</a></li>
<li><a href="../445228/index.html">Criptograf√≠a en Java. Clase de Mac</a></li>
<li><a href="../445230/index.html">Comenz√≥ la inscripci√≥n para la II conferencia de TI para principiantes SMARTRHINO-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>