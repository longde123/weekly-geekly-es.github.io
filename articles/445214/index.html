<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏼 🌁 👩🏿‍💼 Bombeamos ganchos React con FRP 📇 👩🏾‍🤝‍👨🏼 💅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habiendo dominado los ganchos, muchos desarrolladores de React han experimentado euforia, finalmente obteniendo un kit de herramientas simple y conven...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bombeamos ganchos React con FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Habiendo dominado los ganchos, muchos desarrolladores de React han experimentado euforia, finalmente obteniendo un kit de herramientas simple y conveniente que le permite implementar tareas con significativamente menos código.  Pero, ¿significa esto que los ganchos estándar useState y useReducer que se ofrecen listos para usar son todo lo que necesitamos para administrar el estado? </p><br><p>  En mi opinión, en su forma cruda, su uso no es muy conveniente, es más probable que puedan considerarse como la base para construir ganchos de administración estatal realmente convenientes.  Los propios desarrolladores de React fomentan el desarrollo de ganchos personalizados, entonces, ¿por qué no hacerlo?  Debajo del corte, veremos un ejemplo muy simple y comprensible, lo que está mal con los ganchos ordinarios y cómo se pueden mejorar, tanto que se niegan completamente a usarlos en su forma pura. </p><a name="habracut"></a><br><p>  Hay un cierto campo para la entrada, condicionalmente, un nombre.  Y hay un botón al hacer clic en el cual debemos realizar una solicitud al servidor con el nombre ingresado (una búsqueda determinada).  Parece que podría ser más fácil?  Sin embargo, la solución está lejos de ser obvia.  La primera implementación ingenua: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  ¿Qué está mal aquí?  Si el usuario, ingresando algo en el campo, envía el formulario dos veces, solo la primera solicitud funcionará para nosotros, porque  en el segundo clic, la solicitud no cambiará y useEffect no funcionará.  Si imaginamos que nuestra aplicación es un servicio de búsqueda de tickets, y el usuario puede enviar el formulario una y otra vez sin hacer cambios, ¡tal implementación no funcionará para nosotros!  Usar el nombre como una dependencia para useEffect también es inaceptable, de lo contrario, el formulario se enviará inmediatamente cuando cambie el texto.  Bueno, tienes que mostrar ingenio. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Ahora, con cada clic, cambiaremos el significado de la solicitud al opuesto, lo que logrará el comportamiento deseado.  Esta es una muleta muy pequeña e inocente, pero hace que el código sea algo confuso de entender.  Quizás ahora te parezca que succiono el problema de mi dedo e inflo su escala.  Bueno, para responder si es cierto o no, debe comparar este código con otras implementaciones que ofrecen un enfoque más expresivo. </p><br><p>  Veamos este ejemplo a nivel teórico usando abstracción de hilo.  Es muy conveniente para describir el estado de las interfaces de usuario.  Entonces, tenemos dos flujos: datos ingresados ​​en el campo de texto (nombre $) y un flujo de clics en el botón de envío del formulario (clic $).  A partir de ellos, necesitamos crear un tercer flujo combinado de solicitudes al servidor. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Aquí está el comportamiento que necesitamos lograr.  Cada flujo tiene dos aspectos: el valor que tiene y el momento en el que los valores fluyen a través de él.  En diversas situaciones, podemos necesitar uno u otro aspecto, o ambos.  Puedes comparar esto con el ritmo y la armonía de la música.  Las secuencias para las cuales solo el tiempo de respuesta es esencial también se denominan señales. </p><br><p>  En nuestro caso, hacer clic en $ es una señal pura: no importa qué valor fluya a través de él (indefinido / verdadero / Evento / lo que sea), es importante solo cuando esto sucede.  Nombre del caso $ <br>  lo contrario: sus cambios de ninguna manera implican cambios en el sistema, pero es posible que necesitemos su significado en algún momento.  Y a partir de estos dos flujos necesitamos hacer el tercero, tomando desde el primer tiempo, desde el segundo valor. </p><br><p>  En el caso de Rxjs, tenemos un operador casi listo para esto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  Sin embargo, el uso práctico de Rx en React puede ser bastante inconveniente.  Una opción más adecuada es la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mrr</a> , construida sobre los mismos principios funcionales-reactivos que Rx, pero especialmente adaptada para su uso con React según el principio de "reactividad total" y conectada como un gancho. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  La interfaz useMrr es similar a useState o useReducer: devuelve un objeto de estado (valores de todos los hilos) y un setter para poner los valores en hilos.  Pero dentro de todo es un poco diferente: cada campo de estado (= secuencia), excepto aquellos en los que colocamos valores directamente de los eventos DOM, se describe mediante una función y una lista de subprocesos principales, cuyo cambio hará que el niño se recalcule.  En este caso, los valores de los hilos primarios serán sustituidos en la función.  Si solo queremos obtener el valor de la secuencia, pero no responder a su cambio, entonces escribimos un "menos" delante del nombre, como en el caso del nombre. </p><br><p>  Conseguimos el comportamiento deseado, en esencia, en una línea.  Pero esto no es solo brevedad.  Comparemos los resultados obtenidos con más detalle y, en primer lugar, con respecto a un parámetro como la legibilidad y la claridad del código resultante. </p><br><p>  En mrr, podrá separar casi por completo la "lógica" de la "plantilla": no tendrá que escribir ningún manejador imperativo complejo en JSX.  Todo es extremadamente declarativo: simplemente asignamos el evento DOM al flujo correspondiente, prácticamente sin conversión (para los campos de entrada, el valor e.target.value se extrae automáticamente, a menos que especifique lo contrario), y ya en la estructura useMrr describimos cómo se forman los flujos base filiales  Por lo tanto, en el caso de las transformaciones de datos sincrónicas y asincrónicas, siempre podemos rastrear fácilmente cómo se forma nuestro valor. </p><br><p>  Comparando con Px: ni siquiera tuvimos que usar operadores adicionales: si, como resultado, las funciones de mrr reciben una promesa, esperará automáticamente hasta que se resuelva y ponga los datos recibidos en la secuencia.  Además, en lugar de withLatestFrom, utilizamos <br>  escucha pasiva (signo menos), lo cual es más conveniente.  Imagine que además del nombre necesitaremos enviar otros campos.  Luego, en mrr agregaremos otra secuencia de escucha pasiva: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  Y en Rx tienes que esculpir uno más con LatestFrom con un mapa, o primero combinar nombre y apellido en una secuencia. </p><br><p>  Pero volvamos a ganchos y mrr.  Un registro más legible de las dependencias, que siempre muestra cómo se forman los datos, es quizás una de las principales ventajas.  La interfaz actual useEffect básicamente no permite responder a flujos de señal, razón por la cual <br>  Tengo que pensar en diferentes giros. </p><br><p>  Otro punto es que la opción de ganchos ordinarios conlleva representaciones adicionales.  Si el usuario acaba de hacer clic en el botón, esto aún no implica ningún cambio en la interfaz de usuario que la reacción necesita dibujar.  Sin embargo, se llamará un render.  En la variante con mrr, el estado devuelto solo se actualizará cuando ya haya llegado una respuesta del servidor.  ¿Ahorrando en fósforos, dices?  Bueno, tal vez.  Pero para mí personalmente, el principio de "volver a representarte en cualquier situación incomprensible", que es la base de los ganchos básicos, causa rechazo. </p><br><p>  Renders adicionales significan una nueva formación de controladores de eventos.  Por cierto, aquí los ganchos comunes son todos malos.  Los manejadores no solo son imprescindibles, sino que también deben regenerarse cada vez que se procesan.  Y no será posible usar el almacenamiento en caché aquí, porque  muchos manejadores deben estar bloqueados a las variables de componentes internos.  Los manejadores mrr son más declarativos, y el almacenamiento en caché ya está integrado en mrr: set ('name') se generará solo una vez, y se sustituirá de la caché para los renderizados posteriores. </p><br><p>  Con un aumento en la base del código, los controladores imperativos pueden volverse aún más engorrosos.  Digamos que también necesitamos mostrar el número de envíos de formularios realizados por el usuario. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  No muy bien parecido.  Por supuesto, puede representar el controlador como una función separada dentro del componente.  La legibilidad aumentará, pero permanecerá el problema de regenerar la función con cada render, así como el problema de la imperativa.  En esencia, este es un código de procedimiento regular, a pesar de la creencia generalizada de que React API está cambiando gradualmente hacia un enfoque funcional. </p><br><p>  Para aquellos para quienes la escala del problema parece exagerada, puedo responder que, por ejemplo, los desarrolladores de React están conscientes del problema de la generación excesiva de controladores, ofreciéndonos inmediatamente una muleta en forma de useCallback. </p><br><p>  En mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  Una alternativa más conveniente es useReducer, que le permite abandonar el imperativo de los controladores.  Pero quedan otros problemas importantes: la falta de trabajo con las señales (ya que el mismo useEffect será responsable de los efectos secundarios), así como la peor legibilidad durante las conversiones asincrónicas (en otras palabras, es más difícil rastrear la relación entre los campos de la tienda, debido al mismo useEffect )  Si en mrr el gráfico de dependencia entre los campos de estado (subprocesos) es claramente visible de inmediato, en los ganchos debe mirar un poco hacia arriba y hacia abajo. </p><br><p>  Además, compartir useState y useReducer en el mismo componente no es muy conveniente (de nuevo, habrá controladores complejos e imperativos que cambiarán algo en useState <br>  y acción de envío), por lo que, muy probablemente, antes de desarrollar el componente, deberá aceptar una u otra opción. </p><br><p>  Por supuesto, la consideración de todos los aspectos aún puede continuar.  Para no ir más allá del alcance del artículo, tocaré algunos puntos menos importantes en su totalidad. </p><br><p>  Registro centralizado, depuración.  Como en mrr todas las transmisiones están contenidas en un concentrador, para la depuración es suficiente agregar un indicador: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Después de eso, todos los cambios en las transmisiones se mostrarán en la consola.  Para acceder a todo el estado (es decir, los valores actuales de todos los subprocesos), hay un pseudo-flujo $ state: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Por lo tanto, si necesita o está muy acostumbrado al estilo editorial, puede escribir en estilo editor en mrr, devolviendo un nuevo valor de campo basado en el evento y todo el estado anterior.  Pero lo contrario (escribir en useReducer o un editor en el estilo mrr) no funcionará, debido a la falta de reactividad en estos. </p><br><p>  Trabaja con el tiempo.  ¿Recuerdas dos aspectos de los flujos: significado y tiempo de respuesta, armonía y ritmo?  Entonces, trabajar con el primero en ganchos ordinarios es bastante simple y conveniente, pero con el segundo, no.  Al trabajar a lo largo del tiempo, me refiero a la formación de flujos secundarios, cuyo "ritmo" es diferente del de los padres.  Esto es principalmente todo tipo de filtros, debowns, trotl, etc.  Es muy probable que tenga que implementar todo esto.  En mrr, puede usar declaraciones listas para usar listas para usar.  El conjunto de caballeros MRR es inferior a la variedad de operadores Rx, pero tiene un nombre más intuitivo. </p><br><p>  Interacción intercomponente.  Recuerdo que en el Editor se consideraba una buena práctica crear solo una historia.  Si usamos useReducer en muchos componentes, <br>  Puede haber un problema con la organización de la interacción entre las partes.  En MRR, los flujos pueden "fluir" libremente de un componente a otro hacia arriba o hacia abajo de la jerarquía, pero esto no creará problemas debido al enfoque declarativo.  Más detalles <br>  Este tema, así como otras características de la API de MRR, se describen en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actores + FRP en React</a> </p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  Los nuevos ganchos de reacción son geniales y simplifican nuestras vidas, pero tienen algunos defectos que un gancho de propósito general de nivel superior (gestión del estado) puede solucionar.  UseMrr de la biblioteca mrr funcional-reactiva fue propuesta y considerada como tal. </p><br><p>  Problemas y sus soluciones: </p><br><ul><li>  recuentos innecesarios de datos en cada render (en mrr están ausentes debido a la reactividad basada en push) </li><li>  Representaciones adicionales cuando un cambio de estado no implica un cambio en la interfaz de usuario </li><li>  mala legibilidad del código con conversiones asincrónicas (en comparación con las sincrónicas).  En mrr, el código asincrónico no es inferior al sincrónico en cuanto a legibilidad y expresividad.  La mayoría de los problemas discutidos en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo reciente sobre useEffect</a> en mrr son básicamente imposibles </li><li>  controladores imperativos que no siempre se pueden almacenar en caché (en mrr se almacenan en caché automáticamente, casi siempre se pueden almacenar en caché, declarativos) </li><li>  Usar useState y useReducer al mismo tiempo puede crear un código incómodo </li><li>  falta de herramientas para convertir flujos a lo largo del tiempo (rebote, aceleración, condición de carrera) </li></ul><br><p>  En muchos puntos, se puede argumentar que pueden resolverse mediante ganchos personalizados.  Pero esto es precisamente lo que se propone, pero en lugar de implementaciones dispares, para cada tarea separada, se propone una solución holística y consistente. </p><br><p>  Muchos problemas se han vuelto demasiado familiares para que podamos ser claramente reconocidos.  Por ejemplo, las conversiones asincrónicas siempre parecían más complicadas y confusas que las sincrónicas, y los ganchos en este sentido no son peores que los enfoques anteriores (eds, etc.).  Para darse cuenta de esto como un problema, primero debe ver otros enfoques que ofrecen una mejor solución. </p><br><p>  Este artículo no pretende imponer puntos de vista específicos, sino llamar la atención sobre el problema.  Estoy seguro de que existen o se están creando otras soluciones que pueden convertirse en una alternativa valiosa, pero que aún no se conocen ampliamente.  La próxima API React Cache también puede hacer una gran diferencia.  Estaré encantado de criticar y discutir en los comentarios. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los</a> interesados ​​también pueden ver una presentación sobre este tema en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kyivjs</a> el 28 de marzo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445214/">https://habr.com/ru/post/445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445204/index.html">Conversión de flujo de bases de datos Firebird 2.5 a formato ODS12 (Firebird 3.0)</a></li>
<li><a href="../445206/index.html">Reduzca el tiempo de inactividad al actualizar Zimbra</a></li>
<li><a href="../445208/index.html">Niveles de madurez de TI empresarial</a></li>
<li><a href="../445210/index.html">Colonia de criptomonedas</a></li>
<li><a href="../445212/index.html">NetBIOS en manos de un hacker</a></li>
<li><a href="../445220/index.html">AMD Radeon VII: Chip de gama alta (Parte 3)</a></li>
<li><a href="../445222/index.html">Obtenga una oferta en 1 día para el equipo de backend en el Día de la Cosmonáutica</a></li>
<li><a href="../445226/index.html">El desarrollo de un cohete capaz de alcanzar la luna le costará a Rusia 740 mil millones de rublos</a></li>
<li><a href="../445228/index.html">Criptografía en Java. Clase de Mac</a></li>
<li><a href="../445230/index.html">Comenzó la inscripción para la II conferencia de TI para principiantes SMARTRHINO-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>