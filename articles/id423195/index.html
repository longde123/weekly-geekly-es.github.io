<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐻 👨🏽 🔄 Apa yang Baru di JPA 2.2 🍄 🦗 📝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat berlibur untuk semua! 

 Sangat tiba-tiba terjadi bahwa dimulainya grup kedua "Java Enterprise Developer" bertepatan dengan hari ke-256 tahun ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang Baru di JPA 2.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Selamat berlibur untuk semua! <br><br>  Sangat tiba-tiba terjadi bahwa dimulainya grup kedua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Java Enterprise Developer"</a> bertepatan dengan hari ke-256 tahun itu.  <s>Kebetulan?</s>  <s>Saya kira tidak.</s> <br><br>  Yah, kami berbagi minat kedua dari belakang: hal-hal baru apa yang dibawa JPA 2.2 hasil streaming, peningkatan konversi tanggal, anotasi baru - hanya beberapa contoh perbaikan yang bermanfaat. <br><br>  Ayo pergi! <br><br>  Java Persistence API (JPA) adalah spesifikasi Java EE mendasar yang banyak digunakan dalam industri.  Terlepas dari apakah Anda mengembangkan untuk platform Java EE atau untuk kerangka Java alternatif, JPA adalah pilihan Anda untuk menyimpan data.  JPA 2.1 meningkatkan spesifikasi, yang memungkinkan pengembang untuk memecahkan masalah seperti pembuatan skema database otomatis dan pekerjaan efisien dengan prosedur yang tersimpan dalam database.  Versi terbaru, JPA 2.2, meningkatkan spesifikasi berdasarkan perubahan ini. <br>  Pada artikel ini saya akan berbicara tentang fungsionalitas baru dan memberikan contoh yang akan membantu Anda memulai.  Sebagai sampel, saya menggunakan proyek "Java EE 8 Playground", yang tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Aplikasi sampel didasarkan pada spesifikasi Java EE 8 dan menggunakan JavaServer Faces (JSF), Enterprise JavaBeans (EJB), dan kerangka kerja JPA untuk kegigihan.  Anda harus terbiasa dengan JPA untuk memahami apa ini. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Menggunakan JPA 2.2</b> <br><br>  JPA versi 2.2 adalah bagian dari platform Java EE 8. Perlu dicatat bahwa hanya server aplikasi yang kompatibel dengan Java EE 8 yang menyediakan spesifikasi yang siap digunakan di luar kotak.  Pada saat penulisan ini (akhir 2017), ada beberapa server aplikasi semacam itu.  Namun, menggunakan JPA 2.2 dengan Java EE7 mudah.  Pertama, Anda perlu mengunduh file JAR yang sesuai menggunakan <a href="">Maven Central</a> dan menambahkannya ke proyek.  Jika Anda menggunakan Maven dalam proyek Anda, tambahkan koordinat ke file POM Maven: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Kemudian, pilih implementasi JPA yang ingin Anda gunakan.  Dimulai dengan JPA 2.2, EclipseLink dan Hibernate memiliki implementasi yang kompatibel.  Sebagai contoh dalam artikel ini, saya menggunakan <a href="">EclipseLink</a> dengan menambahkan ketergantungan berikut: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Jika Anda menggunakan server yang kompatibel dengan Java EE 8, seperti GlassFish 5 atau Payara 5, Anda harus dapat menentukan area "yang disediakan" untuk dependensi ini dalam file POM.  Jika tidak, tentukan area "kompilasi" untuk memasukkannya dalam perakitan proyek. <br><br>  <b>Dukungan Tanggal dan Waktu Java 8</b> <br><br>  Mungkin salah satu tambahan paling positif adalah dukungan Java 8 Date and Time API.  Sejak rilis Java SE 8 pada tahun 2014, pengembang telah menggunakan solusi untuk menggunakan API Tanggal dan Waktu dengan JPA.  Meskipun sebagian besar penyelesaiannya cukup mudah, kebutuhan untuk menambahkan dukungan dasar untuk API Tanggal dan Waktu yang diperbarui sudah lama terlambat.  Dukungan JPA untuk API Tanggal dan Waktu mencakup jenis-jenis berikut: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Untuk pemahaman yang lebih baik, saya pertama-tama akan menjelaskan bagaimana dukungan API Tanggal dan Waktu berfungsi tanpa JPA 2.2.  JPA 2.1 hanya dapat bekerja dengan konstruksi tanggal yang lebih lama seperti <code>java.util.Date</code> dan <code>java.sql.Timestamp</code> .  Oleh karena itu, Anda harus menggunakan konverter untuk mengubah tanggal yang disimpan dalam database menjadi desain lama yang didukung oleh JPA 2.1, dan kemudian mengubahnya menjadi API Tanggal dan Waktu yang diperbarui untuk digunakan dalam aplikasi.  Konverter tanggal di JPA 2.1 yang mampu melakukan konversi tersebut mungkin terlihat seperti Listing 1. Konverter di dalamnya digunakan untuk mengkonversi antara <code>LocalDate</code> dan <code>java.util.Date</code> . <br><br>  <i>Listing 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  JPA 2.2 tidak perlu lagi menulis konverter seperti itu, karena Anda menggunakan tipe waktu tanggal yang didukung.  Dukungan untuk tipe-tipe tersebut sudah ada di dalam, jadi Anda bisa menentukan tipe yang didukung di bidang kelas entitas tanpa kode tambahan.  Cuplikan kode di bawah ini menunjukkan konsep ini.  Perhatikan bahwa tidak perlu menambahkan anotasi ke kode <code>@Temporal</code> , karena pemetaan tipe terjadi secara otomatis. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Karena tipe tanggal-waktu yang didukung adalah objek kelas satu di JPA, mereka dapat ditentukan tanpa upacara tambahan.  Dalam JPA 2.1 <code>@Temporal</code> anotasi harus dijelaskan di semua bidang dan properti konstan tipe <code>java.util.Date</code> dan <code>java.util.Calendar</code> . <br><br>  Perlu dicatat bahwa hanya bagian dari tipe data-waktu yang didukung dalam versi ini, tetapi konverter atribut dapat dengan mudah dihasilkan untuk bekerja dengan tipe lain, misalnya, untuk mengonversi <code>LocalDateTime</code> ke <code>ZonedDateTime</code> .  Masalah terbesar dalam menulis konverter seperti itu adalah untuk menentukan cara terbaik untuk mengkonversi antara berbagai jenis.  Untuk mempermudah, konverter atribut sekarang dapat diterapkan.  Saya akan memberikan contoh implementasi di bawah ini. <br><br>  Kode dalam Listing 2 menunjukkan bagaimana mengkonversi waktu dari <code>LocalDateTime</code> ke <code>ZonedDateTime</code> . <br><br>  <i>Listing 2</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Secara khusus, contoh ini sangat mudah karena <code>ZonedDateTime</code> berisi metode yang mudah dikonversi.  Konversi terjadi dengan memanggil metode <code>toLocalDateTime()</code> .  Konversi terbalik dapat dilakukan dengan memanggil metode <code>ZonedDateTimeOf()</code> dan meneruskan nilai <code>LocalDateTime</code> bersama dengan <code>ZoneId</code> untuk menggunakan zona waktu. <br><br>  <b>Konverter Atribut Tertanam</b> <br><br>  Konverter atribut adalah tambahan yang sangat bagus untuk JPA 2.1, karena mereka memungkinkan tipe atribut menjadi lebih fleksibel.  Pembaruan JPA 2.2 menambahkan kemampuan yang berguna untuk membuat konverter atribut dapat diterapkan.  Ini berarti bahwa Anda dapat menanamkan sumber daya Konteks dan Ketergantungan Injeksi (CDI) langsung ke konverter atribut.  Modifikasi ini konsisten dengan perangkat tambahan CDI lainnya dalam spesifikasi Java EE 8, seperti konverter JSF canggih, karena sekarang mereka juga dapat menggunakan injeksi CDI. <br><br>  Untuk memanfaatkan fitur baru ini, cukup masukkan sumber daya CDI di konverter atribut, sesuai kebutuhan.  Listing 2 memberikan contoh konverter atribut, dan sekarang saya akan memisahkannya, menjelaskan semua detail penting. <br><br>  Kelas konverter harus mengimplementasikan antarmuka <code>javax.persistence.AttributeConverter</code> , melewati nilai X dan Y. Nilai X sesuai dengan tipe data dalam objek Java, dan nilai Y harus sesuai dengan jenis kolom database.  Kemudian, kelas konverter harus dijelaskan dengan <code>@Converter</code> .  Akhirnya, kelas harus mengganti metode <code>convertToDatabaseColumn()</code> dan <code>convertToEntityAttribute()</code> .  Implementasi di masing-masing metode ini harus mengkonversi nilai dari tipe tertentu dan kembali ke sana. <br><br>  Untuk secara otomatis menerapkan konverter setiap kali tipe data yang ditentukan digunakan, tambahkan "otomatis", seperti pada <code>@Converter(autoApply=true)</code> .  Untuk menerapkan konverter ke satu atribut, gunakan anotasi @Converter di tingkat atribut, seperti yang ditunjukkan di sini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  Konverter juga dapat diterapkan di tingkat kelas: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Misalkan saya ingin mengenkripsi nilai-nilai yang terkandung dalam bidang <code>creditLimit</code> entitas <code>Customer</code> ketika disimpan.  Untuk menerapkan proses ini, nilai-nilai harus dienkripsi sebelum disimpan, dan didekripsi setelah diambil dari database.  Ini dapat dilakukan oleh konverter dan, menggunakan JPA 2.2, saya dapat menanamkan objek enkripsi di konverter untuk mencapai hasil yang diinginkan.  Listing 3 memberikan contoh. <br><br>  <i>Listing 3</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  Dalam kode ini, proses dilakukan dengan <code>CreditLimitEncryptor</code> kelas <code>CreditLimitEncryptor</code> ke konverter dan kemudian menggunakannya untuk membantu proses. <br><br>  <b>Streaming Hasil Permintaan</b> <br><br>  Sekarang Anda dapat dengan mudah memanfaatkan fitur Java SE 8 stream saat bekerja dengan hasil kueri.  Utas tidak hanya menyederhanakan membaca, menulis, dan memelihara kode, tetapi juga membantu meningkatkan kinerja kueri dalam beberapa situasi.  Beberapa implementasi utas juga membantu menghindari sejumlah besar permintaan data secara simultan yang sangat besar, meskipun dalam beberapa kasus menggunakan pagination <code>ResultSet</code> mungkin bekerja lebih baik daripada stream. <br><br>  Untuk mengaktifkan fungsi ini, metode <code>getResultStream()</code> telah ditambahkan ke <code>TypedQuery</code> <code>Query</code> dan <code>TypedQuery</code> .  Perubahan kecil ini memungkinkan JPA untuk hanya mengembalikan aliran hasil alih-alih daftar.  Jadi, jika Anda bekerja dengan <code>ResultSet</code> besar, masuk akal untuk membandingkan kinerja antara implementasi utas baru dan <code>ResultSets</code> atau pagination yang dapat digulir.  Alasannya adalah implementasi utas mengambil semua catatan sekaligus, menyimpannya dalam daftar, dan kemudian mengembalikannya.  Teknik <code>ResultSet</code> dan pagination yang dapat digulir mengambil sedikit demi sedikit data, yang mungkin lebih baik untuk set data besar. <br><br>  Penyedia ketekunan mungkin memutuskan untuk mengganti metode <code>getResultStream()</code> implementasi yang ditingkatkan.  Hibernate sudah menyertakan metode stream () yang menggunakan <code>ResultSet</code> dapat digulir untuk mengurai hasil rekaman alih-alih mengembalikannya sepenuhnya.  Ini memungkinkan Hibernate untuk bekerja dengan dataset yang sangat besar dan melakukannya dengan baik.  Penyedia lain dapat diharapkan untuk mengganti metode ini untuk menyediakan fitur serupa yang bermanfaat bagi JPA. <br><br>  Selain kinerja, kemampuan untuk mengalirkan hasil adalah tambahan yang bagus untuk JPA, yang menyediakan cara yang nyaman untuk bekerja dengan data.  Saya akan menunjukkan beberapa skenario di mana ini mungkin berguna, tetapi kemungkinan itu sendiri tidak terbatas.  Dalam kedua skenario, saya meminta entitas <code>Job</code> dan mengembalikan aliran.  Pertama, lihat kode berikut, di mana saya hanya menguraikan aliran <code>Jobs</code> terhadap <code>Customer</code> tertentu dengan memanggil metode antarmuka <code>Query</code> <code>getResultStream()</code> .  Kemudian, saya menggunakan utas ini untuk menampilkan detail tentang <code>customer</code> dan <code>work date</code> Job'a. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Metode ini dapat sedikit dimodifikasi sehingga mengembalikan daftar hasil menggunakan metode <code>Collectors .toList()</code> sebagai berikut. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  Dalam skenario berikut, yang ditunjukkan di bawah ini, saya menemukan <code>List</code> tugas yang terkait dengan kumpulan formulir tertentu.  Dalam hal ini, saya mengembalikan semua tugas yang cocok dengan formulir yang dikirimkan sebagai string.  Mirip dengan contoh pertama, pertama saya mengembalikan aliran catatan <code>Jobs</code> .  Lalu, saya memfilter catatan berdasarkan formulir kumpulan pelanggan.  Seperti yang Anda lihat, kode yang dihasilkan sangat kompak dan mudah dibaca. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Seperti yang saya sebutkan sebelumnya, penting untuk mengingat kinerja dalam skenario di mana sejumlah besar data dikembalikan.  Ada kondisi di mana utas lebih berguna dalam kueri basis data, tetapi ada juga di mana mereka dapat menyebabkan penurunan kinerja.  Aturan praktis yang baik adalah bahwa jika data dapat ditanyakan sebagai bagian dari query SQL, masuk akal untuk melakukan hal itu.  Terkadang, manfaat menggunakan sintaks ulir elegan tidak melebihi kinerja terbaik yang dapat dicapai menggunakan penyaringan SQL standar. <br><br>  <b>Dukungan Anotasi Duplikat</b> <br><br>  Ketika Java SE 8 dirilis, duplikat anotasi menjadi mungkin, memungkinkan Anda untuk menggunakan kembali anotasi dalam deklarasi.  Beberapa situasi memerlukan penggunaan anotasi yang sama di kelas atau bidang beberapa kali.  Misalnya, mungkin ada lebih dari satu penjelasan <code>@SqlResultSetMapping</code> untuk kelas entitas yang diberikan.  Dalam situasi di mana dukungan untuk anotasi ulang diperlukan, anotasi wadah harus digunakan.  Duplikat anotasi tidak hanya mengurangi persyaratan untuk membungkus koleksi anotasi identik dalam anotasi wadah, tetapi juga dapat membuat kode lebih mudah dibaca. <br><br>  Ini berfungsi sebagai berikut: implementasi kelas anotasi harus ditandai dengan meta-anotasi <code>@Repeatable</code> untuk menunjukkan bahwa itu dapat digunakan lebih dari sekali.  <code>@Repeatable</code> meta <code>@Repeatable</code> mengambil tipe kelas anotasi wadah.  Misalnya, <code>NamedQuery</code> anotasi <code>NamedQuery</code> sekarang ditandai dengan <code>@Repeatable(NamedQueries.class)</code> .  Dalam hal ini, anotasi wadah masih digunakan, tetapi Anda tidak harus memikirkannya saat menggunakan anotasi yang sama pada deklarasi atau kelas, karena <code>@Repeatable</code> mengabstraksikan detail ini. <br><br>  Kami memberi contoh.  Jika Anda ingin menambahkan lebih dari satu penjelasan <code>@NamedQuery</code> ke kelas entitas di JPA 2.1, Anda perlu merangkumnya di dalam penjelasan <code>@NamedQueries</code> , seperti yang ditunjukkan pada Listing 4. <br><br>  <i>Listing 4</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Namun, dalam JPA 2.2, semuanya berbeda.  Karena <code>@NamedQuery</code> adalah anotasi duplikat, ini dapat ditentukan dalam kelas entitas lebih dari sekali, seperti yang ditunjukkan pada Listing 5. <br><br>  <i>Listing 5</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Daftar duplikat anotasi: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Kesimpulan</b> <br><br>  Versi JPA 2.2 memiliki beberapa perubahan, tetapi peningkatan yang disertakan cukup signifikan.  Akhirnya, JPA disejajarkan dengan Java SE 8, memungkinkan pengembang untuk menggunakan fitur-fitur seperti Date and Time API, streaming hasil kueri, dan pengulangan anotasi.  Rilis ini juga meningkatkan konsistensi CDI dengan menambahkan kemampuan untuk menanamkan sumber daya CDI di konverter atribut.  JPA 2.2 sekarang tersedia dan merupakan bagian dari Java EE 8, saya pikir Anda akan suka menggunakannya. <br><br>  AKHIR <br><br>  Seperti biasa, kami menunggu pertanyaan dan komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423195/">https://habr.com/ru/post/id423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423185/index.html">Jangan memakannya! Pencetakan Gula 3D yang Berguna</a></li>
<li><a href="../id423187/index.html">Root dan sertifikat perantara dari Otoritas Sertifikasi resmi Rusia</a></li>
<li><a href="../id423189/index.html">Penelitian: setengah dari perusahaan menambal kerentanan dalam sebulan - mengapa?</a></li>
<li><a href="../id423191/index.html">Peluncuran elemen platform lepas pantai. Bagian 1</a></li>
<li><a href="../id423193/index.html">Konfigurasikan Pemberitahuan Dorong Web menggunakan pywebpush langkah demi langkah</a></li>
<li><a href="../id423197/index.html">LOLWUT: sebuah karya seni dalam tim db</a></li>
<li><a href="../id423203/index.html">Pemimpin tim yang keren akan bertanggung jawab atas layanan ini</a></li>
<li><a href="../id423205/index.html">Proyek penyimpanan pada MS SQL Server, integrasi dengan 1C 7.7 dan otomatisasi pengembangan dalam SSDT</a></li>
<li><a href="../id423207/index.html">Cara membuat pembaruan otomatis dari klien game online</a></li>
<li><a href="../id423209/index.html">Killer Form 2? Tinjauan Umum tentang Printer 3D MoonRay S100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>