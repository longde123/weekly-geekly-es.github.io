<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌯 👄 ✋🏾 Kursus MIT "Keamanan Sistem Komputer". Kuliah 4: “Berbagi Hak Istimewa,” Bagian 3 💰 💆🏼 🧗🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 4: “Berbagi Hak Istimewa,” Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418211/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: “Pendahuluan: model ancaman” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: “Buffer Overflows: Exploits and Protection” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: “Pemisahan Hak Istimewa” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Jadi, gambar kami menggambarkan "karya seni", yang coba dilindungi oleh penciptanya dari ancaman.  Dalam kasus mereka, saya pikir mereka sangat khawatir, karena dengan membuat <b>situs</b> kencan <b>okcupid.com</b> , mereka benar-benar ingin memastikan bahwa reputasi pengguna situs tidak akan terpengaruh oleh pengungkapan data pribadi.  Dari percakapan dengan salah satu pengembang situs yang menulis artikel tentang ini, diketahui bahwa mereka sebenarnya tidak dikompromikan.  Setidaknya, ada kehilangan data akibat penggunaan <b>OKWS</b> arsitektur dan sebagian karena pemantauan aktivitas berbahaya belum terjadi. <br><br>  Alasan orang tidak memecah aplikasi mereka menjadi komponen yang lebih kecil adalah karena proses ini membutuhkan usaha.  Penting untuk memilih semua bagian kode, mendefinisikan antarmuka yang jelas di antara mereka, dan memutuskan data yang harus diakses oleh setiap komponen.  Jika Anda memutuskan untuk mengimplementasikan fungsi baru, Anda harus mengubah data yang dapat diakses oleh setiap komponen program, untuk memberikannya keistimewaan baru atau untuk memilih beberapa, dan seterusnya.  Jadi ini adalah proses yang agak memakan waktu. <br><br><img src="https://habrastorage.org/webt/th/7c/nb/th7cnbytweb-shrbg6mai4qmhpw.jpeg"><br><br>  Mari kita coba memahami bagaimana server web dirancang, dan mungkin satu cara untuk melakukan ini adalah melacak bagaimana permintaan http diproses oleh server <b>OKWS</b> .  Jadi, mirip dengan yang ditunjukkan pada gambar sebelumnya, kami memiliki browser web yang ingin pergi ke <b>okcupid.com</b> .  Para pengembang proyek situs membayangkan bahwa mereka akan memiliki banyak mesin, tetapi kita hanya akan melihat antarmuka situs tempat <b>OKWS</b> akan bekerja, dan mesin lain di latar belakang yang akan menyimpan database.  mesin kedua ini menggunakan <b>MySQL,</b> karena merupakan perangkat lunak yang baik untuk berbagai tugas.  Mereka ingin benar-benar melindungi data ini karena sangat sulit untuk sampai ke disk <b>mentah</b> atau database dengan datagram mentah mentah. <br><br>  Jadi, bagaimana cara kerjanya, bagaimana permintaan diproses oleh server <b>OKWS</b> ?  Pertama, ia tiba dan diproses oleh proses yang disebut <b>okd</b> untuk dispatcher <b>OKWS</b> .  Dia memeriksa apakah dia meminta permintaan ini, dan kemudian melakukan beberapa hal.  Karena Anda mungkin perlu mendaftarkan permintaan ini terlebih dahulu, itu mengarahkannya ke komponen yang disebut <b>oklogd</b> , setelah itu Anda perlu membuat beberapa templat, dan mungkin perlu membuatnya bahkan sebelum permintaan itu tiba.  Dan itu komponen lain yang disebut <b>pubd</b> . <br><br><img src="https://habrastorage.org/webt/wq/uz/o0/wquzo0-ivmzrydzbxgj_ckcecsw.jpeg"><br><br>  Dan akhirnya, ada layanan yang pasti untuk yang permintaan dikirim, sehingga <b>OKD</b> ada satu set meja layanan yang mendukung.  Agaknya permintaan ini datang ke salah satu layanan ini, jadi setelah meninjau <b>okd akan</b> mengarahkan permintaan ini ke proses layanan <b>SVD</b> tertentu.  Layanan ini akan melakukan persis apa yang diminta oleh permintaan, misalnya, berlangganan pengguna ke buletin, atau memungkinkan untuk melihat direktori pengguna <b>ocupid</b> menggunakan database, dll. <br><br>  Dan untuk ini, Anda mungkin perlu layanan untuk meninggalkan informasi aplikasi di <b>log</b> komponen <b>oklogd</b> .  Dan pada akhirnya, ia harus "berbicara" dengan database.  Pembuat situs ini telah menerapkan proses "komunikasi" ini sedikit berbeda dari yang biasanya terjadi di <b>Apache</b> , di mana Anda cukup berkomunikasi dengan database dan mengeluarkan pertanyaan <b>SQL</b> sewenang-wenang.  Mereka datang dengan konsep database proxy, <b>dbproxy,</b> yang terletak di depan <b>database MySQL,</b> dan menerima permintaan dari <b>svc layanan,</b> untuk melakukan itu.  Saya pikir ilustrasi ini pada dasarnya menunjukkan cara kerja <b>OKWS</b> . <br><br><img src="https://habrastorage.org/webt/e1/nb/be/e1nbbexq_wqwyqtsop6vnvlmfd0.jpeg"><br><br>  Ada komponen lain yang memulai semua ini, disebut <b>okld</b> , dan bertanggung jawab untuk memulai semua proses dalam antarmuka server web ini.  Saya berharap beberapa dari hal-hal ini terlihat akrab bagi Anda, karena ini persis arsitektur yang dipertimbangkan di laboratorium.  Sepertinya ini desain yang bagus.  Anda tidak memiliki <b>pubd</b> , <b>logd</b> dan <b>dbproxy di LR</b> , tetapi Anda memiliki <b>okd</b> dan <b>svc</b> .  Ada pertanyaan tentang <b>OKWS</b> ? <br><br>  <b>Pemirsa:</b> Kami mengerti benar bahwa <b>dbproxy</b> tidak mengambil SQL-query, dan jenis lain dari permintaan? <br><br>  <b>Profesor:</b> ya benar!  Seperti apa tampilan antarmuka ini?  Mereka tidak menggambarkan ini dengan sangat rinci, tetapi satu hal yang dapat Anda lakukan dengan <b>dbproxy</b> ini adalah untuk menyimpan banyak argumen untuk templat kueri <b>SQL</b> .  Misalnya, itu bisa menjadi templat permintaan pencarian untuk teman Anda, memilih mereka berdasarkan <b>ID</b> . <br><br><img src="https://habrastorage.org/webt/0e/fv/33/0efv33jbe-yuwdw82mwqzxof_xc.jpeg"><br><br>  Misalkan ada template seperti "pilih <b>^ ID</b> dari daftar teman Anda, di mana <b>^ ID ="% S "</b> .  Misalkan Anda ingin menemukan <b>Alice di</b> antara teman-teman Anda dan mengirim permintaan <b>S</b> , di mana argumennya adalah <b>"alice"</b> .  Biarkan aplikasi kami, tersedia dalam antarmuka, tahu bahwa <b>dbproxy</b> siap untuk melakukan tiga jenis permintaan atas namanya.  Jika Anda ingin menjalankan kueri No. 1, dan argumennya adalah <b>"Alice"</b> , maka ia memberi Anda akses ke database. <br><br>  <b>Pemirsa:</b> dapatkah pengguna eksternal di tingkat peramban web mengirim permintaan seperti itu ke basis data atau apakah semua itu hanya berlaku untuk pengguna internal jaringan? <br><br>  <b>Profesor:</b> ya, mungkin.  Jadi bagaimana cara kerjanya?  Bahkan, itu adalah aneh bahwa database terletak pada mesin yang terpisah, karena itu mungkin untuk menghubungkan ke database <b>OKWS</b> atau ke <b>server MySQL?</b>  Jadi apa yang menghentikan ini? <br><br>  <b>Pemirsa:</b> firewall? <br><br>  <b>Profesor:</b> ya, mungkin pada tingkat tertentu.  Pengembang tidak menjelaskan hal ini dengan terlalu rinci, tetapi mungkin ada beberapa jaringan internal pada mesin kedua, dan ada pergantian antara antarmuka dan basis data yang tidak dapat dijangkau dari dunia luar.  Faktanya, kedua mesin berada di jaringan yang sama, tetapi ada firewall <b>Fw</b> yang memiliki aturan tertentu.  Mungkin mereka adalah Anda hanya dapat terhubung ke komputer antarmuka ini melalui port 80, tetapi tidak secara langsung ke server internal.  Ini adalah salah satu opsi perlindungan. <br><br><img src="https://habrastorage.org/webt/uu/lq/pt/uulqptu9yvouev1n-gdwegusujc.jpeg"><br><br>  Lain, mungkin, adalah bahwa ketika Anda terhubung ke <b>proxy</b> database <b>dbproxy</b> ini, Anda perlu memberikan token kriptografi 20-byte, atau kunci, dan jika Anda tidak menyediakannya, <b>dbproxy akan</b> menolak koneksi Anda.  Jadi aturannya adalah Anda membuka koneksi TCP, mengirim 20 byte, dan jika salah, koneksi ditutup.  Ini, saya pikir, adalah arti dari desain sistem semacam itu. <br><br>  Jadi, mari kita coba mencari tahu bagaimana proses yang berbeda ini diisolasi di sini.  Bagaimana Anda bisa memastikan bahwa semua komponen ini tidak saling membanjiri? <br><br>  <b>Hadirin:</b> hak root dan ID pengguna berbeda? <br><br>  <b>Profesor:</b> ya, hampir setiap komponen ini bekerja sebagai <b>uid yang</b> berbeda, jadi di sini, dalam deskripsi sistem, ada seluruh tabel yang menjelaskan untuk setiap komponen di mana ia bekerja dan dengan apa <b>uid</b> .  Jadi kita dapat menulis bahwa <b>okd</b> memiliki <b>uid</b> sendiri, <b>pubd</b> memiliki <b>uid</b> sendiri dan <b>oklogd</b> juga memiliki <b>uid</b> sendiri. <br><br>  <b>Okld</b> berfungsi sebagai <b>root</b> , yang agak tidak berhasil, tapi mungkin ini bukan masalah besar.  Lalu ada sejumlah pengidentifikasi pengguna yang ditugaskan secara dinamis untuk setiap layanan, misalnya ID 51001, dll. <br><br><img src="https://habrastorage.org/webt/hc/bp/bj/hcbpbjjrkwqqhtdun36v3fm7b_s.jpeg"><br><br>  Dengan demikian, ini memastikan bahwa setiap layanan tidak dapat mengganggu proses layanan lainnya.  <b>Chroot</b> juga banyak digunakan di sini, sehingga beberapa komponen ini memiliki hak <b>chroot</b> di direktori terpisah.  Sebagai contoh, <b>okd</b> dan <b>svc</b> diberkahi dengan hak <b>chroot yang</b> umum di beberapa direktori.  Menurut Anda mengapa kedua komponen ini memiliki komponen <b>chroot yang</b> terpisah dan tidak umum? <br><br>  <b>Pemirsa:</b> karena <b>okd</b> tidak memiliki hak akses root. <br><br>  <b>Profesor:</b> ya, tapi mengapa mereka tidak memasukkan <b>pubd</b> , <b>oklogd</b> , dan semua orang di <b>chroot yang</b> sama? <br><br>  <b>Audiens: apakah</b> mungkin jika layanan perlu berbagi banyak data, haruskah mereka diisolasi satu sama lain? <br><br>  <b>Profesor:</b> bisa.  Saya pikir mereka harus berbagi beberapa data, tetapi data ini tidak ada dalam file, mereka ditransfer melalui soket dari <b>okd</b> ke layanan.  Tetapi pada kenyataannya, tidak satu pun dari komponen ini menyimpan sesuatu yang menarik dalam sistem file. <br><br>  Oleh karena itu, tidak ada yang menarik di direktori <b>chroot</b> , dan saya pikir orang-orang dari <b>OKWS</b> hanya memutuskan untuk mengurangi biaya tidak produktif untuk <b>chroot</b> , seperti kebutuhan untuk membuat salinan direktori.  Mungkin mereka juga ingin menyingkirkan beberapa overhead manajemen untuk setiap perintah <b>chroot</b> .  Tetapi karena tidak ada file nyata di sini, maka semuanya beres. <br><br>  Alasan orang-orang ini memberikan <b>chroot yang</b> berbeda untuk komponen lingkungan adalah karena beberapa hal menarik.  Mungkin ada template, tetapi di sini, mungkin, ada file log, jadi mereka tidak ingin file log dibaca secara tidak sengaja, dan sejenisnya. <br><br>  <b>Pemirsa</b> bukan apakah file layanan ini, misalnya, ketik <b>aspx?</b> <br><br>  <b>Profesor:</b> seperti yang mereka jelaskan di artikel, layanan ini adalah biner <b>C ++</b> tunggal yang dikompilasi, jadi sebenarnya tidak ada file tambahan. <br><br>  Ada template, tetapi mereka benar-benar ditransmisikan melalui mekanisme aneh ini: <b>pubd</b> memiliki template dalam direktori-nya, menampilkannya di beberapa pra-komputer, form rumah di <b>okd</b> , dan <b>okd</b> sudah menyediakan template untuk semua layanan melalui panggilan <b>RPC</b> .  Dengan demikian, mereka duduk di memori, tetapi sebenarnya tidak dapat diakses langsung melalui sistem file.  Ini adalah desain yang agak paranoid ketika saya bahkan tidak bisa membaca template. <br>  Jadi, apa gunanya memisahkan semua komponen ini?  Mengapa kita perlu <b>oklogd</b> terpisah? <br><br>  <b>Audiens:</b> untuk menghilangkan kemungkinan menimpa atau memangkas jurnal? <br><br>  <b>Profesor:</b> ya, jadi kami benar-benar ingin memastikan bahwa jika terjadi kesalahan, jurnal, setidaknya, tidak akan rusak.  Dengan demikian, ada file log terpisah yang dapat ditulis oleh <b>uid</b> ini, dan semua pesan log dikirim sebagai <b>RPC</b> untuk layanan log ini.  Dan bahkan jika semuanya hancur, yah, dengan pengecualian <b>okld</b> , majalah itu akan tetap tidak terluka. <br><br>  <b>Hadirin:</b> bagaimana jika Anda secara tidak sengaja menemukan cara untuk membaca majalah dan tidak melihat apa yang telah dilakukan orang lain dengan majalah itu? <br><br>  <b>Profesor:</b> tidak, saya pikir jika Anda "meretas" suatu layanan, <b>pubd</b> atau sesuatu yang lain, Anda dapat menulis apa pun di jurnal.  Oleh karena itu, membuat <b>entri oklogd</b> terpisah <b>masuk</b> akal.  Sebenarnya, <b>oklogd</b> adalah proses yang terpisah, dan tidak hanya diperbarui dengan melampirkan file sebagai file <b>append-only</b> .  Dengan demikian, <b>oklogd</b> tidak dapat menambahkan beberapa informasi tambahan untuk setiap entri log, karena jika OS mendukung file <b>append-only</b> , Anda tidak akan tahu bahwa seseorang telah menulis ke file ketika ini terjadi.  Sementara <b>oklogd</b> menempatkan stempel waktu untuk setiap pesan dan memungkinkan Anda untuk mengetahui layanan mana yang membuat rekaman atau berasal dari <b>okd</b> .  Karena itu, Anda benar-benar mendapatkan informasi tambahan dalam file log ini karena ini adalah layanan terpisah. <br><br>  Dan apa arti pemisahan <b>okld</b> dan mengapa harus bekerja dengan hak root?  Saya pikir ada beberapa alasan untuk ini. <br><br>  Audiens: jika Anda tidak ingin orang lain bertindak dengan hak akses root, Anda perlu mendelegasikan fungsi otentikasi pengguna <b>okld</b> . <br><br><img src="https://habrastorage.org/webt/xg/c2/p0/xgc2p0qzezaptmg1jagd1l3koxi.jpeg"><br><br>  <b>Profesor:</b> ya.  Seseorang harus mengkonfigurasi semua ini <b>uro chroot</b> , dan Anda perlu <b>root</b> untuk <b>Unix</b> ini, jadi <b>okld</b> menyediakan ini.  Ini salah satu alasannya.  Ada lagi? <br><br>  <b>Hadirin:</b> 80 definisi port? <br><br>  <b>Profesor:</b> Ya, tentu saja!  Anda harus mengikat mendengarkan port 80, yang mana <b>okld</b> dan memberikan hal lain? <br><br>  <b>Pemirsa:</b> ini melengkapi pembukaan file log <b>oklogd</b> karena kami tidak ingin membiarkan <b>oklogd</b> terbuka untuk mencegah akses ke file log. <br><br>  <b>Profesor:</b> mungkin.  Tapi saya tidak tahu apakah pengembang benar-benar melakukannya karena mereka tidak melihat kode sumber mereka.  Anda berpikir, <b>okld</b> membuka file log dan mengirimkannya <b>oklogd?</b>  Mungkin <br><br>  <b>Hadirin:</b> karena jika tidak, penyerang yang berkompromi dengan <b>oklogd</b> dapat menghapus seluruh log. <br><br>  <b>Profesor:</b> ya, itu benar.  Mungkin Anda ingin membukanya dalam mode <b>append</b> dan kemudian meneruskannya <b>oklogd</b> , maka Anda memiliki jaminan keamanan lebih untuk log.  Ini adalah sesuatu yang tidak dapat Anda lakukan tanpa hak root. <br><br>  Jadi, kami memiliki pertanyaan tentang pekerjaan rumah, apa yang akan terjadi ketika token 20-byte ini “bocor” untuk mengakses database.  Kerusakan apa yang dapat menyebabkan ini?  Haruskah kita khawatir tentang ini? <br><br>  <b>Hadirin:</b> dalam hal ini, penyerang dapat mengambil kendali atas layanan tertentu. <br><br>  <b>Profesor:</b> ya, benar, karena sekarang Anda dapat terhubung dan mendapatkan semua templat kueri.  Ini sebenarnya terlihat cukup sederhana.  Anda mungkin perlu kompromi salah satu komponen ini agar dapat terhubung ke database server terlebih dahulu.  Jadi saya pikir jika Anda memiliki token ini dan Anda dapat kompromi salah satu komponen ini yang ditunjukkan pada gambar, maka Anda dapat menggunakan semua pertanyaan ini. <br><br>  Sekarang mari kita lihat bagaimana desain <b>OKWS</b> ini dapat ditingkatkan?  Misalnya, akan dimungkinkan untuk mengalokasikan unit <b>UID</b> terpisah untuk setiap pengguna, selain mengalokasikan <b>UID</b> terpisah untuk setiap layanan.  Di sini, setiap layanan, misalnya, berita, mencari teman, atau membuat akun, memiliki <b>userid</b> terpisah, tetapi setiap pengguna <b>OKWS</b> tidak direpresentasikan sebagai <b>uix</b> <b>Unix</b> .  Sebenarnya tidak ada <b>userid di</b> sini, hanya <b>ID</b> layanan yang ada di sini.  Apakah Anda pikir Anda harus memiliki <b>uid yang</b> berbeda untuk setiap klien <b>OKWS</b> ? <br><br>  <b>Pemirsa:</b> dalam kasus ini, ternyata jika satu pengguna “meretas” suatu layanan, ia akan dapat mengakses semua data pengguna lain dari server ini. <br><br>  <b>Profesor:</b> ya, benar! <br><br>  <b>Hadirin:</b> tetapi jika Anda memiliki, pada kenyataannya, layanan terpisah dan <b>dbproksi</b> terpisah untuk setiap pengguna, maka tidak mungkin untuk mengakses data orang lain. <br><br>  <b>Profesor:</b> ya, tetapi mungkinkah ini model yang lebih kuat?  Saya pikir pengembang <b>OKWS</b> tidak mengambil langkah seperti itu karena dua alasan.  Yang pertama adalah kinerja.  Jika Anda memiliki beberapa juta pengguna situs <b>okcupid</b> , beberapa juta proses yang berjalan, dan beberapa juta <b>dbproxie</b> , maka overhead kinerja dimungkinkan.  Dan ini tidak akan memungkinkan untuk mencapai kinerja yang sama dengan yang <b>disediakan oleh</b> arsitektur <b>OKWS</b> . <br><br>  <b>Pemirsa:</b> deskripsi <b>OKWS</b> mengatakan bahwa kinerja sistem ini lebih baik daripada sistem lain.  Bagaimana ini dicapai? <br><br>  <b>Profesor:</b> Saya pikir ini sebagian karena mereka menyesuaikan desain mereka dengan beban kerja tertentu, di samping itu, mereka menulis semua ini di <b>C ++</b> .  Alternatifnya adalah menulis beberapa hal dalam <b>PHP</b> , maka kemungkinan besar Anda akan mendapatkan manfaat di bagian depan ini. <br><br>  Selain itu, mereka tidak memiliki banyak fitur yang dimiliki <b>Apache</b> .  Ini memiliki desain tujuan umum, sehingga memiliki banyak proses kerja, dan memuatnya dari waktu ke waktu.  Ada banyak koneksi <b>TTP</b> yang memastikan durasi proses koneksi dan mempertahankan aktivitasnya.  Ini juga meningkatkan jumlah proses yang berjalan pada sistem.  <b>Apache telah</b> dibuat lebih universal dan dapat melakukan segala sesuatu yang Anda ingin dapatkan dari server Internet, dan orang-orang dari <b>OKWS</b> lebih fokus untuk menyelesaikan masalah tertentu. <br><br>  Tapi saya pikir ada server web lain <b>hari</b> ini yang mungkin bisa cocok dengan kinerja <b>OKWS</b> .  Misalnya, <b>Nginx</b> adalah server web yang sangat optimal yang dapat Anda jalankan hari ini.  Jika Anda ingin aplikasi berkinerja tinggi di sisi server, Anda mungkin ingin proses panjang sangat mirip dengan layanan <b>OKWS</b> .  Dan itu akan memiliki mekanisme untuk antarmuka gateway <b>CGI</b> cepat umum untuk menghubungkan program eksternal dengan server web, atau semacam protokol yang dapat digunakan di sisi server untuk mengimplementasikan ini bahkan di <b>Apache</b> atau <b>Nginx</b> .  Oleh karena itu, saya pikir banyak dari ide-ide ini tidak eksklusif untuk <b>OKWS</b> , mereka dapat diimplementasikan di server web lain.  Mereka hanya menunjukkan bahwa meningkatkan keamanan tidak menghalangi penggunaan "trik" ini.  Saya pikir mereka mulai dengan skema yang mirip dengan <b>Apache</b> , tetapi berpikir itu tidak akan cukup aman. <br><br>  Jadi saya berpikir bahwa salah satu alasan mengapa pembuat <b>OKWS</b> tidak ingin memperkenalkan hak istimewa terpisah untuk pengguna adalah kemungkinan penurunan kinerja. <br><br><img src="https://habrastorage.org/webt/ai/s9/zb/ais9zbrgrmnoslcojxk0jacxdyc.jpeg"><br><br>  Alasan lain adalah bahwa model aplikasi lengkap mereka “berputar” di sekitar layanan yang mencoba mengakses data masing-masing pengguna, seperti mencari teman di <b>okcupid</b> atau seseorang yang dapat Anda undang saat kencan.  Akibatnya, model isolasi pengguna ini tidak masuk akal, karena, pada akhirnya, harus ada layanan yang Anda kirim permintaan, dan itu akan melihat semua data lain untuk menemukan kecocokan untuk permintaan Anda.  Jadi, bahkan jika Anda memiliki pengidentifikasi pengguna atau mekanisme untuk mengisolasi mereka, Anda masih harus membuka akses ke layanan untuk setiap pengguna. <br><br>  Untuk layanan lain, seperti <b>Gmail</b> atau <b>Dropbox</b> , yang jauh lebih fokus pada pengguna tertentu dan tidak memberikan kemampuan terbuka untuk berbagi file, mengisolasi pengguna dapat memberikan lebih banyak keuntungan.  Misalnya, di server <b>Dropbox</b> ada <b>userid</b> untuk setiap klien <b>Dropbox</b> .  Dan jika ada proses yang berjalan untuk Anda dan proses yang berjalan untuk orang lain, maka bahkan menggunakan exploit berbahaya, Anda tidak akan bisa mendapatkan informasi orang lain. <br>  Sekarang mari kita lihat apakah <b>OKWS benar-benar</b> berhasil meningkatkan keamanan dalam model server seperti itu.  Untuk mengevaluasi keamanan, Anda perlu mempertimbangkan setiap komponen sistem dan menentukan jenis serangan apa yang dapat merusaknya. <br><br>  Mari kita mulai dengan <b>okd</b> .  Itu dapat diserang dengan permintaan melalui browser, misalnya, menyebabkan buffer overflow.       c++,  ,       - ,   <b>okd</b>  .      ? <br><br><img src="https://habrastorage.org/webt/qz/md/d9/qzmdd9xheqlsc2fpbgs4e5to3_i.jpeg"><br><br> <b>:</b>        ? <br><br> <b>:</b> ,  ,      .   ? <br><br> <b>:</b>       ,  . <br><br> <b>:</b> ,  .  , ,       ,        <b>http</b> ,   ,   ,     .  ,     . <br><br> <b>:</b>           ? <br><br> <b>:</b> ,       .    ,  ,      ,        , ,  <b>match.com</b>    . , ,      <b>OkCupid</b> . , - ?          ? <br><br> <b>:</b> ,    ,      <b>okd</b> .           ,    ? <br><br> <b>:</b> .   , <b>okd</b>     . <br><br> <b>:</b> ,     ? <br><br> <b>:</b> !      ,      , , ,      ,   .      ,   , ,   ,      . , ,   .   «» <b>okd</b> ,     ,     ,         . <br><br> <b>:</b>         DOS-? <br><br> <b>:</b> ,  , , «»       «»  ,   DOS-    -   . <br><br> <b>:</b>       <b>okd</b> ,     ,  … <br><br> <b>:</b> ,  .  ,   , <b>okd</b>    ,         <b>okd</b> ,     .     <b>okd</b> ,           .  ,    <b>okd</b>  ,       ,      ,   ,            . <br><br> <b>:</b>          . <br><br> <b>:</b> ,    .  , <b>okd</b>     .   ,    <b>oklogd</b> ?    ? <br><br> <b>:</b>      . <br><br> <b>:</b> ,          ,             ,   ?       <b>pubd</b> ,  ,     ,  -  . <br><br> <b>:</b> ,    ,   «»  <b>oklogd</b> . <br><br> <b>:</b> ,  .      ,      ,   <b>append-only</b>    ,        . <br><br> <b>:</b> ,      … <br><br> <b>:</b> ,        ,   .          . <br><br>     <b>svc</b> ? ,  ,   .       , ,   <b>okd</b>  <b>oklogd</b>    .         ,  ,        . <br><br>   <b>svc</b>  - -,        ,       ,         .   ,         ,        ,       . <br><br>      <b>okld</b> ?       ,      root.       ? ,       .           <b>dbproxy</b> .    <b>okld</b> ?      «»?    ? <br><br> <b>:</b> ,  -   ? <br><br> <b>:</b> ,       .          ,    ,       . ,        ,  -    ,     , ,     -    .         -     .          root-   . <br><br> <b>:</b> -,    ,     -   <b>dbproxy</b> . <br><br> <b>:</b> ! <br><br> <b>:</b>  ,     ,  ,     <b>RPC</b> ,       ,     ,     ,  ,   !      . <br><br><img src="https://habrastorage.org/webt/qs/cu/x6/qscux6nxwgoo9wqu10wj04npz38.jpeg"><br><br> <b>:</b> ,    .       <b>dbproxy</b> ?  ,            .   ,   «»   ,      <b>dbproxy</b>  - . <br><br> <b>:</b>      ,   <b>svc</b>  … <br><br> <b>:</b> ,  <b>svc</b>   ,     ! <br><br> <b>:</b>  ,    ,     ! <br><br> <b>:</b>  ,  ,      <b>«»</b> ,       … <br><br> <b>:</b>   <b></b>     <b>dbproxy</b> . <br><br> <b>:</b> . ,      <b>dbproxy</b> ,   . <br><br> ,  ,      .    ,   .    ,     . , ,       ,       ,    . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dNl22h1kW1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418211/">https://habr.com/ru/post/id418211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418201/index.html">Bisakah kita menghidupkan kembali Perburuan Bebek?</a></li>
<li><a href="../id418203/index.html">GraphQL API (CRUD) on Go</a></li>
<li><a href="../id418205/index.html">Bahasa Space, Vol. 2: Selamat Datang, GJ273b</a></li>
<li><a href="../id418207/index.html">Ulasan laptop gaming ASUS ROG Strix GL504GS SCAR II dan ASUS ROG Strix GL504GM HERO II</a></li>
<li><a href="../id418209/index.html">Kami menerima data dari konter Mercury 203.2T di RS-485</a></li>
<li><a href="../id418213/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 5: "Dari mana sistem keamanan berasal," bagian 1</a></li>
<li><a href="../id418215/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 5: "Dari Mana Kesalahan Sistem Keamanan Berasal," Bagian 2</a></li>
<li><a href="../id418217/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: "Peluang", bagian 1</a></li>
<li><a href="../id418219/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: Peluang, Bagian 2</a></li>
<li><a href="../id418221/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: "Peluang", bagian 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>