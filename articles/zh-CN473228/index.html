<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏽 🚫 👩🏻‍🚀 让Perl从1987年开始 👆🏽 🎡 🚃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在LINUX.ORG.RU 上阅读了“ Perl解释器代码已正式移植到GitHub ”的新闻之后，我决定看一下现在已经在GitHub上的Perl 5存储库。 

 令人惊奇的是，他们震惊与敬畏，不仅绝对保留了整个项目32年的历史，而且还保留了错误报告（陷入问题），补丁（陷入PR），发行版和分支。 文...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>让Perl从1987年开始</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473228/">在LINUX.ORG.RU <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl解释器代码正式移植到GitHub，有关LINUX.ORG.RU资源的新闻">上</a>阅读了“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl解释器代码正式移植到GitHub，有关LINUX.ORG.RU资源的新闻">Perl解释器代码已正式移植到GitHub</a> ”的新闻之后，我决定看一下现在已经在GitHub上的Perl 5存储库。 <br><br> 令人惊奇的是，他们震惊与敬畏，不仅绝对保留了整个项目32年的历史，而且还保留了错误报告（陷入问题），补丁（陷入PR），发行版和分支。 文件旁边的题词“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="32年前，在Perl源文件上，是Perl 5官方GitHub存储库。">32年前</a> ”引起不由自主的微笑。 <br><br> 在这个沉闷的星期五晚上，当雨和雪在街道上令人毛骨悚然地下着毛毛雨，而所有的街道都陷在秋天的泥泞中时，还有什么可做的呢？ 是的，红眼睛！ 因此，出于实验和兴趣的考虑，我决定在具有最新版本<strong>GCC 9.2.0</strong>的现代x86_64机器上编译并组装古老的Perl。 这样的旧代码可以通过时间的考验吗？ <br><br><div style="text-align:center;"><img title="Linux现代的Linux Arch Linux发行版，m twm（X窗口系统的第一个窗口管理器）的演示。" src="https://habrastorage.org/webt/-0/d5/wt/-0d5wtkg6ylqdd-h5g1hbtdiypi.png"></div><br>  <i>在现代Arch Linux发行版中，展示了X窗口系统的首批窗口管理器<strong>twm</strong> 。</i> <br><br> 为了完全真实可靠，我部署了一个带有裸X和窗口管理器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="twm，维基百科页面。">twm</a>的虚拟机，该虚拟机也于1987年发布。 谁知道，也许<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="拉里·沃尔（Larry Wall），维基百科页面。">拉里·沃尔</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="拉里·沃尔（Larry Wall），维基百科页面。">Larry Wall</a> ）恰好使用<strong>twm</strong>编写了他的Perl，可以说<em>是</em>那个时代的<em>尖端技术</em> 。 使用的发行版是Arch Linux。 只是因为他的存储库中有一些有用的东西，后来才派上用场。 所以走吧！ <br><a name="habracut"></a><br><a name="article-content"></a><h2> 内容： </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.准备环境</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.配置源代码</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3. Yacc语法文件错误</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.“ C”上的代码编译错误</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.纠正一些错误分段错误</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.总结</a> <br><br><a name="environment"></a><h2>  1.准备环境 </h2><br> 首先，我们在虚拟机上已部署的操作系统上安装了汇编和编辑源代码所需的所有绅士工具集和编译器： <strong>gcc</strong> ， <strong>make</strong> ， <strong>vim</strong> ， <strong>git</strong> ， <strong>gdb</strong>等。其中一些已经安装，而另一些则在meta包中提供。 <strong>base-devel</strong> ，如果未安装，则必须安装。 一旦环境准备好采取行动，我们将获得32年历史的Perl源代码的副本！ <br><br><pre><code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Perl/perl5/ --depth=1 -b perl-1.0</code> </pre> <br> 借助Git的功能，我们无需拖一堆文件即可到达项目的第一个版本： <br><br><pre> <code class="plaintext hljs">* commit 8d063cd8450e59ea1c611a2f4f5a21059a2804f1 (grafted, HEAD, tag: perl-1.0) Commit: Larry Wall &lt;lwall@jpl-devvax.jpl.nasa.gov&gt; CommitDate: Fri Dec 18 00:00:00 1987 +0000 a "replacement" for awk and sed</code> </pre><br> 我们仅下载少量数据，因此，带有Perl第一个版本的源代码的存储库仅占用150 KB。 <br><br> 在那黑暗而密集的时间里，没有诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="GNU Autotools，Wikipedia页面。">自动工具之</a>类的基本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="GNU Autotools，Wikipedia页面。">工具</a> （真是太<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="GNU Autotools，Wikipedia页面。">幸运</a> <em>了！</em> ），但是，存储库根目录中有一个<strong>Configure</strong>脚本。 怎么了 但事实是，拉里·沃尔（Larry Wall）是此类脚本的发明者，这些脚本允许为当时最混乱的UNIX计算机生成Makefile。 正如Wikipedia上有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="配置脚本，历史记录，维基百科页面。">同名</a>脚本的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="配置脚本，历史记录，维基百科页面。">文章</a>所述，Larry Wall在编写Perl的三年后就向<strong>Configure</strong>文件提供了一些软件，例如新闻阅读器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="rn，新闻阅读器，维基百科页面。">rn</a> 。 随后，Perl也不例外，并且使用已经在许多计算机上运行的脚本来构建它。 后来，其他开发人员（例如Trolltech的程序员）也采纳了这个想法。 他们使用类似的脚本来配置其Qt框架的构建，许多人将其与<strong>autotools的</strong> <strong>configure</strong>混淆了。 正是来自不同开发人员的此类脚本的动物园，它们为创建用于简化和自动生成的工具提供了动力。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>&lt;&lt;跳到内容</em></a> <br><br><a name="configure"></a><h2>  2.配置源代码 </h2><br>  “老派”的<strong>配置</strong>脚本，从其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Shebang，Unix，维基百科页面。">Shebang</a> '中已经很明显了，该脚本有一个空格： <br><br><pre> <code class="bash hljs">$ cat Configure | head -5 <span class="hljs-comment"><span class="hljs-comment">#! /bin/sh # # If these # comments don't work, trim them. Don't worry about any other # shell scripts, Configure will trim # comments from them for you. #</span></span></code> </pre><br> 根据评论，事实证明脚本中存在无法发表评论的shell！ 空间状况看起来很不正常，但是一旦成为常态，请在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="＃之间允许有空格！和/ bin / bash在shebang吗？ -Unix和Linux Stack Exchange。">此处</a>查看链接以获取更多信息。 最重要的是，对于现代的shell解释器而言，是否存在空间没有什么区别。 <br><br> 足够的歌词，让我们开始吧！ 我们启动脚本并看到一个有趣的假设，事实并非完全如此： <br><br><pre> <code class="plaintext hljs">$ ./Configure (I see you are using the Korn shell. Some ksh's blow up on Configure, especially on exotic machines. If yours does, try the Bourne shell instead.) Beginning of configuration questions for perl kit. Checking echo to see how to suppress newlines... ...using -n. Type carriage return to continue. Your cursor should be here--&gt;</code> </pre><br> 令人惊讶的是，脚本是交互式的，并且包含大量的各种背景信息。 用户交互模型建立在对话框上，分析脚本更改其参数所依据的答案，并根据脚本随后生成Makefile。 我个人有兴趣检查所有shell命令是否都到位？ <br><br><pre> <code class="plaintext hljs">Locating common programs... expr is in /bin/expr. sed is in /bin/sed. echo is in /bin/echo. cat is in /bin/cat. rm is in /bin/rm. mv is in /bin/mv. cp is in /bin/cp. tr is in /bin/tr. mkdir is in /bin/mkdir. sort is in /bin/sort. uniq is in /bin/uniq. grep is in /bin/grep. Don't worry if any of the following aren't found... test is in /bin/test. egrep is in /bin/egrep. I don't see Mcc out there, offhand.</code> </pre><br> 显然，在此之前还远非如此。 我想知道<strong>Mcc</strong>实用程序负责什么，找不到哪个？ 有趣的是，该脚本具有当时最好的黑客传统，充满了幽默。 现在，您几乎看不到： <br><br><pre> <code class="plaintext hljs">Is your "test" built into sh? [n] (OK to guess) OK Checking compatibility between /bin/echo and builtin echo (if any)... They are compatible. In fact, they may be identical. Your C library is in /lib/libc.a. You're normal. Extracting names from /lib/libc.a for later perusal...done Hmm... Looks kind of like a USG system, but we'll see... Congratulations. You aren't running Eunice. It's not Xenix... Nor is it Venix... Checking your sh to see if it knows about # comments... Your sh handles # comments correctly. Okay, let's see if #! works on this system... It does. Checking out how to guarantee sh startup... Let's see if '#!/bin/sh' works... Yup, it does.</code> </pre><br> 我用默认值或脚本为我提供的内容回答了大多数问题。 对编译器和链接器的标志请求特别高兴和惊讶： <br><br><pre> <code class="plaintext hljs">Any additional cc flags? [none] Any additional ld flags? [none]</code> </pre><br> 您可以在其中编写一些有趣的内容，例如<strong>-m32</strong>来构建32位可执行文件或库，这是链接期间所需的。 最后一个脚本问题： <br><br><pre> <code class="plaintext hljs">Now you need to generate make dependencies by running "make depend". You might prefer to run it in background: "make depend &gt; makedepend.out &amp;" It can take a while, so you might not want to run it right now. Run make depend now? [n] y</code> </pre><br> 我回答肯定。 通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="makedepend，历史记录，维基百科页面。">其</a> Wikipedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="makedepend，历史记录，维基百科页面。">页面</a>判断，古老的<strong>makedepend</strong>实用程序是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="雅典娜计划，维基百科页面。">Athena项目</a>生命的一开始就创建的，以方便使用Makefiles。 该项目为我们提供了X窗口系统，Kerberos，Zephyr，并影响了当今许多其他熟悉的事物。 所有这些都很棒，但是这个实用程序在现代Linux环境中从何而来？ 长期以来，没人和任何地方都在使用它。 但是，如果您仔细查看存储库的根目录，就会发现Larry Wall编写了其替代脚本版本，我们仔细解压缩并执行了配置脚本。 <br><br>  <strong>Makedepend</strong>完成时出现一些奇怪的错误： <br><br><pre> <code class="bash hljs">./makedepend: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> substitution: line 82: unexpected EOF <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> looking <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> matching `<span class="hljs-string"><span class="hljs-string">''</span></span> ./makedepend: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> substitution: line 83: syntax error: unexpected end of file ./makedepend: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> substitution: line 82: unexpected EOF <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> looking <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> matching `<span class="hljs-string"><span class="hljs-string">''</span></span> ./makedepend: <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> substitution: line 83: syntax error: unexpected end of file</code> </pre><br> 也许是由引起问题的他们才对生成的Makefile稍加咀嚼： <br><br><pre> <code class="bash hljs">$ make make: *** No rule to make target <span class="hljs-string"><span class="hljs-string">'&lt;built-in&gt;'</span></span>, needed by <span class="hljs-string"><span class="hljs-string">'arg.o'</span></span>. Stop.</code> </pre><br> 我绝对不想进入<strong>makedepend</strong>实用程序复杂的贝壳面的丛林，我决定仔细看一下Makefile，其中出现了一种奇怪的模式： <br><br><pre> <code class="plaintext hljs">arg.o: arg.c arg.o: arg.h arg.o: array.h arg.o: &lt;built-in&gt; arg.o: cmd.h arg.o: &lt;command-line&gt; arg.o: config.h arg.o: EXTERN.h ... array.o: arg.h array.o: array.c array.o: array.h array.o: &lt;built-in&gt; array.o: cmd.h array.o: &lt;command-line&gt; array.o: config.h array.o: EXTERN.h ...</code> </pre><br> 显然，某些实用程序错误地将其参数插入到了尾声中。 拿起<s>ax</s>实用程序<strong>sed，</strong>我决定稍微解决一下这个问题： <br><br><pre> <code class="bash hljs">$ sed -i <span class="hljs-string"><span class="hljs-string">'/built-in/d'</span></span> Makefile $ sed -i <span class="hljs-string"><span class="hljs-string">'/command-line/d'</span></span> Makefile</code> </pre><br> 出乎意料的是，这个技巧成功了，Makefiles可以正常工作了！ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>&lt;&lt;跳到内容</em></a> <br><br><a name="yacc"></a><h2>  3. Yacc语法文件错误 </h2><br> 如果具有32年历史的代码可以毫无问题地进行汇编，那将是令人难以置信的。 不幸的是，奇迹没有发生。 在研究源代码树时，我遇到了一个<strong>perl.y</strong>文件，该文件是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="yacc，维基百科页面。">yacc</a>实用程序的语法说明，该实用程序在现代发行版中早已被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="GNU Bison，维基百科页面。">bison</a>取代。 位于<strong>/ usr / bin / yacc</strong>路径中的脚本仅在与<strong>yacc</strong>兼容的模式下调用<strong>bison</strong> 。 只是这种兼容性还不完全，并且在处理此文件时会涌入大量错误，我不知道该如何更正，也不是真的想要，因为我最近学到了另一种解决方案。 <br><br> 一两年前，KDE的开发者Helio Chissini de Castro做了类似的工作，并将KDE 1，2和Qt 1，2适应了现代环境和编译器。 我对他的工作很感兴趣，下载了项目的源代码，但是在组装过程中，由于<strong>yacc</strong>和<strong>bison</strong>的不兼容而遇到了类似的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Qlio 2的现代改编，Helio Castro，发行，GitHub存储库。">陷阱</a> ，而<strong>yacc</strong>和<strong>bison</strong>却被用来构建<strong>moc</strong>元编译器的古老版本。 随后，我设法以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="伯克利·雅克（Berkeley Yacc），官方页面。">byacc</a>实用程序（Berkeley Yacc）替代<strong>bison</strong>的形式找到了解决此问题的方法，该实用程序证明与<strong>yacc的</strong>旧语法兼容，并且在许多Linux发行版中都可用。 <br><br> 在构建系统中用<strong>byacc</strong>轻松替换<strong>yacc</strong>可以帮助我，尽管时间不长，因为稍后在<strong>byacc的</strong>新版本中， <strong>它们</strong>仍然破坏了与<strong>yacc的</strong>兼容性，中断了与<strong>yydebug</strong>实体相关的调试。 因此，我不得不稍微<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="修复未定义的引用错误，Pull Requests，Helio Castro的GitHub存储库的Qt 2现代改编。">更正该</a>实用程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="修复未定义的引用错误，Pull Requests，Helio Castro的GitHub存储库的Qt 2现代改编。">的语法</a> 。 <br><br> 因此，以前的经验曾预测过纠正<strong>perl.y</strong>文件中的构造错误的策略：安装<strong>byacc</strong>实用程序，在所有Makefile <strong>中将</strong> <strong>yacc</strong>更改为<strong>byacc</strong> ，然后从任何地方剪切<strong>yydebug</strong> 。 这些操作解决了该文件的所有问题，错误消失了，编译继续进行。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>&lt;&lt;跳到内容</em></a> <br><br><a name="c-errors"></a><h2>  4.“ C”上的代码编译错误 </h2><br>  Perl的古老代码充满了恐惧，例如K＆R类型的函数定义早已过时且被遗忘的表示法： <br><br><pre> <code class="cpp hljs">format(orec,fcmd) <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">outrec</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">orec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> FCMD *fcmd; { ... } <span class="hljs-function"><span class="hljs-function">STR * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hfetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tb,key)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">register</span></span></span><span class="hljs-function"> HASH *tb</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *key; { ... } <span class="hljs-comment"><span class="hljs-comment">/*VARARGS1*/</span></span> fatal(pat,a1,a2,a3,a4) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pat; { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>,pat,a1,a2,a3,a4); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br> 例如，在同样很古老的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="有趣的考古学。或PVS-Studio在Habr资源上检查Microsoft Word 1.1a，文章。">Microsoft Word 1.1a</a>代码中也发现了类似的功能。 编程语言“ C”的第一个标准称为“ C89”，将仅在两年内出现。 现代的编译器能够使用这样的代码，但是某些IDE并不容易解析这样的定义并将其突出显示为语法错误，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Qt Creator IDE，维基百科页面。">Qt Creator</a>在将其中的代码解析到<strong>libclang</strong>库之前犯了罪。 <br><br>  GCC 9.2.0编译器发出了大量警告，并承诺编译Perl第一版的古老代码。 警告中的内容如此之大，以至于要找出错误，我们不得不向上滚动几页。 令我惊讶的是，大多数编译错误都是典型的错误，主要与预定义定义有关，预定义定义在程序集中起标志的作用。 <br><br><div style="text-align:center;"><img title="twm窗口管理器和xterm终端仿真器中的现代GCC 9.2.0编译器和GDB 8.3.1调试器的工作。" src="https://habrastorage.org/getpro/habr/post_images/3a9/b3c/004/3a9b3c0041c48a06e6805bd39883c6a4.png"></div><br>  <i><strong>twm</strong>窗口管理器和<strong>xterm</strong>终端仿真器中的现代GCC 9.2.0编译器和GDB 8.3.1调试器的工作。</i> <br><br> 在STDSTDIO之下<strong>，</strong>拉里·沃尔<strong>（</strong> Larry Wall）试用了一些古老的非标准编程语言库“ C”，并且在DEBUGGING下使用了臭名昭著的<strong>yydebug</strong>调试信息，如上所述。 默认情况下，这些标志是启用的。 通过在<strong>perl.h</strong>文件中关闭它们并添加一些被遗忘的定义，我能够显着减少错误的数量。 <br><br> 另一种错误类型是重写标准库和POSIX层的当前标准化功能。 该项目具有自己的<strong>malloc（）</strong> ， <strong>setenv（）</strong>以及其他产生冲突的实体。 <br><br> 几个地方定义了没有声明的静态函数。 随着时间的流逝，编译器开始对这个问题采取更严格的方法， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="如何解决GCC C代码中的非静态声明之后的静态声明？ -堆栈溢出。">并将警告变成错误</a> 。 最后，还有几个被遗忘的标题，如果没有它们，您将去哪里。 <br><br> 令我惊讶的是，这个具有32年历史的代码的补丁是如此之小，以至于可以在此处完整引用： <br><br><pre> <code class="diff hljs">diff --git a/malloc.cb/malloc.c index 17c3b27..a1dfe9c 100644 --- a/malloc.c +++ b/malloc.c @@ -79,6 +79,9 @@ static u_int nmalloc[NBUCKETS]; #include &lt;stdio.h&gt; #endif +static findbucket(union overhead *freep, int srchlen); +static morecore(register bucket); + #ifdef debug #define ASSERT(p) if (!(p)) botch("p"); else static diff --git a/perl.hb/perl.h index 3ccff10..e98ded5 100644 --- a/perl.h +++ b/perl.h @@ -6,16 +6,16 @@ * */ -#define DEBUGGING -#define STDSTDIO /* eventually should be in config.h */ +//#define DEBUGGING +//#define STDSTDIO /* eventually should be in config.h */ #define VOIDUSED 1 #include "config.h" -#ifndef BCOPY -# define bcopy(s1,s2,l) memcpy(s2,s1,l); -# define bzero(s,l) memset(s,0,l); -#endif +//#ifndef BCOPY +//# define bcopy(s1,s2,l) memcpy(s2,s1,l); +//# define bzero(s,l) memset(s,0,l); +//#endif #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; @@ -183,11 +183,11 @@ double atof(); long time(); struct tm *gmtime(), *localtime(); -#ifdef CHARSPRINTF - char *sprintf(); -#else - int sprintf(); -#endif +//#ifdef CHARSPRINTF +// char *sprintf(); +//#else +// int sprintf(); +//#endif #ifdef EUNICE #define UNLINK(f) while (unlink(f) &gt;= 0) diff --git a/perl.yb/perl.y index 16f8a9a..1ab769f 100644 --- a/perl.y +++ b/perl.y @@ -7,6 +7,7 @@ */ %{ +#include &lt;stdlib.h&gt; #include "handy.h" #include "EXTERN.h" #include "search.h" diff --git a/perly.cb/perly.c index bc32318..fe945eb 100644 --- a/perly.c +++ b/perly.c @@ -246,12 +246,14 @@ yylex() static bool firstline = TRUE; retry: +#ifdef DEBUGGING #ifdef YYDEBUG if (yydebug) if (index(s,'\n')) fprintf(stderr,"Tokener at %s",s); else fprintf(stderr,"Tokener at %s\n",s); +#endif #endif switch (*s) { default: diff --git a/stab.cb/stab.c index b9ef533..9757cfe 100644 --- a/stab.c +++ b/stab.c @@ -7,6 +7,7 @@ */ #include &lt;signal.h&gt; +#include &lt;errno.h&gt; #include "handy.h" #include "EXTERN.h" #include "search.h" diff --git a/util.hb/util.h index 4f92eeb..95cb9bf 100644 --- a/util.h +++ b/util.h @@ -28,7 +28,7 @@ void prexit(); char *get_a_line(); char *savestr(); int makedir(); -void setenv(); +//void setenv(); int envix(); void notincl(); char *getval();</code> </pre><br>  32年旧代码的绝佳结果！ 通过将<em>-lcrypt</em>指令添加到带有适当的<strong>libcrypt</strong>库的Makefile中，可以解决<strong>对'crypt'</strong>链接错误的<strong>未定义引用</strong> ，此后，我终于获得了所需的Perl解释器可执行文件： <br><br><pre> <code class="bash hljs">$ file perl perl: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=fd952ceae424613568530b3a2ca88ebd6477e0ae, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 3.2.0, not stripped</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>&lt;&lt;跳到内容</em></a> <br><br><a name="segfaults"></a><h2>  5.纠正一些错误分段错误 </h2><br> 经过几乎没有麻烦的编译后，运气转过了我头。 启动组装好的Perl解释器后，我立即得到一些奇怪的错误和一个Segmentation错误： <br><br><pre> <code class="bash hljs">$ ./perl -e <span class="hljs-string"><span class="hljs-string">'print "Hello World!\n";'</span></span> Corrupt malloc ptr 0x2db36040 at 0x2db36000 Corrupt malloc ptr 0x2db36880 at 0x2db36800 Corrupt malloc ptr 0x2db36080 at 0x2db36040 Corrupt malloc ptr 0x2db37020 at 0x2db37000 Segmentation fault (core dumped)</code> </pre><br> 了短语<em>Corrupt malloc</em>的源文本后，结果发现，从1982年起，就不再使用系统<strong>malloc（）</strong>了某种自定义分配器。 有趣的是， <strong>Berkeley是</strong>用源代码中的字符串文字之一编写的，而<strong>Caltech则是</strong>在其旁边的注释中编写的。 这些大学之间的合作非常明显。 总的来说，我注释掉了这个黑客分配器并重建了源代码。 内存损坏错误消失了，但是分段错误仍然存​​在。 所以这不是重点，现在我们需要发现调试器。 <br><br> 在<strong>gdb</strong>下运行程序<strong>，</strong>我发现当从libc创建临时文件<strong>mktemp（）</strong>的函数被调用时，发生崩溃： <br><br><pre> <code class="plaintext hljs">$ gdb --args ./perl -e 'print "Hello, World!\n";' (gdb) r Starting program: /home/exl/perl5/perl -e print\ \"Hello\ World\!\\n\"\; Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7cd20c7 in __gen_tempname () from /usr/lib/libc.so.6 (gdb) bt #0 0x00007ffff7cd20c7 in __gen_tempname () from /usr/lib/libc.so.6 #1 0x00007ffff7d71577 in mktemp () from /usr/lib/libc.so.6 #2 0x000055555556bb08 in main ()</code> </pre><br> 顺便说一下，链接器以前在此功能时发誓。 不是编译器，而是链接器，这让我感到惊讶： <br><br><pre> <code class="plaintext hljs">/usr/bin/ld: perl.o: in function `main': perl.c:(.text+0x978c): warning: the use of `mktemp' is dangerous, better use `mkstemp' or `mkdtemp'</code> </pre><br> 您可能也想到的第一个想法就是用我做的<strong>mkstemp（）</strong>替换<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="GNU C库，临时文件，GNU官方文档。">不安全的函数</a> <strong>mktemp（）</strong> 。 链接器警告消失了，但是分段错误仍然保留在该位置，只是现在它在<strong>mkstemp（）</strong>函数中。 <br><br> 因此，现在您需要非常仔细地查看与此功能关联的代码段。 在那里，我发现了一个很奇怪的东西，该片段中突出显示了这一点： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *e_tmpname = <span class="hljs-string"><span class="hljs-string">"/tmp/perl-eXXXXXX"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ mktemp(e_tmpname); e_fp = f_open(e_tmpname, <span class="hljs-string"><span class="hljs-string">"w"</span></span>); ... }</code> </pre><br> 事实证明， <strong>mktemp（）</strong>试图更改掩码的文字，该掩码位于<strong>.rodata</strong>节中，这显然注定要失败。 还是毕竟，在32年前，这是可以接受的，在代码中得到了满足，甚至以某种方式起作用了？ <br><br> 当然，用<strong>char</strong> <strong>e_tmpname []</strong>替换<strong>char * e_tmpname</strong> <strong>可解决</strong>此细分错误，并且我能够获得整个晚上都被杀死的信息： <br><br><pre> <code class="bash hljs">$ ./perl -e <span class="hljs-string"><span class="hljs-string">'print "Hello World!\n";'</span></span> $ Hello, World! $ ./perl -e <span class="hljs-string"><span class="hljs-string">'$a = 5; $b = 6.3; $c = $a+$b; print $c."\n";'</span></span> $ 11.3000000000000007 $ ./perl -v <span class="hljs-variable"><span class="hljs-variable">$Header</span></span>: perly.c,v 1.0 87/12/18 15:53:31 root Exp $ Patch level: 0</code> </pre><br> 我们从命令行检查了执行情况，但是文件呢？ 我从互联网上下载了Perl编程语言的第一个“ Hello World”： <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">################# test.pl #!/usr/bin/perl # # The traditional first program. # Strict and warnings are recommended. use strict; use warnings; # Print a message. print "Hello, World!\n";</span></span></code> </pre><br> 然后，我尝试运行它，但是，遗憾的是，细分错误再次在等我。 这次在完全不同的地方： <br><br><pre> <code class="plaintext hljs">$ gdb --args ./perl test.pl (gdb) r Starting program: /home/exl/perl5/perl test.pl Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7d1da75 in __strcpy_sse2_unaligned () from /usr/lib/libc.so.6 (gdb) bt #0 0x00007ffff7d1da75 in __strcpy_sse2_unaligned () from /usr/lib/libc.so.6 #1 0x00005555555629ea in yyerror () #2 0x0000555555568dd6 in yyparse () #3 0x000055555556bd4f in main ()</code> </pre><br> 在<strong>yyerror（）</strong>函数中发现了以下有趣的观点，我引用了原始代码段： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// perl.y char *tokename[] = { "256", "word", "append", ... // perl.c yyerror(s) char *s; { char tmpbuf[128]; char *tname = tmpbuf; if (yychar &gt; 256) { tname = tokename[yychar-256]; // ??? if (strEQ(tname,"word")) strcpy(tname,tokenbuf); // Oops! else if (strEQ(tname,"register")) sprintf(tname,"$%s",tokenbuf); // Oops! ...</span></span></code> </pre><br> 同样，情况与我上面写过的情况类似。  <strong>.rodata</strong>节中的数据被<strong>再次修改</strong> 。 也许是由于复制粘贴而造成的错别字，而不是他们想写<strong>tmpbuf</strong>而不是<strong>tname</strong> ？ 还是它背后确实有某种隐藏的含义？ 无论如何，用<strong>char</strong> <strong>tokename [] [32]</strong>替换<strong>char * tokename []</strong> <strong>都会</strong>消除分段错误，Perl会告诉我们以下内容： <br><br><pre> <code class="bash hljs">$ ./perl test.pl syntax error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file test.pl at line 7, next token <span class="hljs-string"><span class="hljs-string">"strict"</span></span> Execution aborted due to compilation errors.</code> </pre><br> 事实证明，他不喜欢各种<strong>严格</strong>的新奇<strong>用法</strong> ，这就是他要告诉我们的！ 如果删除或注释掉文件中的这些行，程序将启动： <br><br><pre> <code class="bash hljs">$ ./perl test.pl Hello, World!</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>&lt;&lt;跳到内容</em></a> <br><br><a name="theend"></a><h2>  6.总结 </h2><br> 实际上，我实现了自己的目标，并且使1987年的古老代码不仅可以编译，而且可以在现代Linux环境中工作。 毫无疑问，仍然存在大量的各种分段错误，可能与64位体系结构上的指针大小有关。 在准备好调试器几个晚上之后，可以清理所有这些东西。 但这不是一项非常令人愉快且乏味的任务。 毕竟，最初，这个实验被计划为一个无聊的夜晚的娱乐活动，而不是作为一项成熟的工作，而这项工作将结束。 采取的行动有什么实际的好处？ 也许有一天，一些数字考古学家会遇到这篇文章，这对他很有用。 但是在我看来，即使在现实世界中，即使是从此类研究中获得的经验也不太有价值。 <br><br> 如果有人感兴趣，我会发布一组两个补丁。 第一个修复了编译错误，第二个修复了一些Segmentation错误。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="修复编译错误补丁，EXLMOTODEV GitHub存储库。"><strong>Perl1987-修复编译错误.patch</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="修复了一些Segmentation Faults补​​丁程序，EXLMOTODEV GitHub存储库。"><strong>Perl1987-修复某些分段错误.patch</strong></a> </li></ul><br>  PS我急于让<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl单行程序，Lurkmore文章。">破坏性单线游戏玩家</a>感到不快，这在这里不起作用。 也许Perl的版本太旧了，无法进行此类娱乐。 <br>  PPS一切都很好，周末愉快。 感谢<strong>kawaii_neko</strong>的一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl直接来自1987，对LINUX.ORG.RU资源的评论">小问题</a> 。 <br><br>  <em>更新2019年10月28日：</em> LINUX.ORG.RU论坛的用户使用昵称<strong>utf8nowhere</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl直接来自1987，对LINUX.ORG.RU资源的评论">在他</a>对本文的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl直接来自1987，对LINUX.ORG.RU资源的评论">评论中</a>提供了非常有趣的链接，该信息不仅澄清了可变字符串文字的情况，甚至还考虑了上述使用问题。 <strong>mktemp（）</strong>函数！ 让我引用这些资料，这些资料描述了非标准化的K＆R C和GNU C之间的各种不兼容性： <br><blockquote>  <strong>GCC的不兼容</strong> <br>  GNU C和K＆R（非ISO）版本的C之间存在一些值得注意的不兼容性。 <br><br>  GCC通常使字符串常量为只读。 如果使用了几个外观相同的字符串常量，则GCC仅存储该字符串的一个副本。 <br> 结果是您不能使用字符串常量参数调用<strong>mktemp</strong> 。 函数<strong>mktemp</strong>总是更改其参数指向的字符串。 <br><br> 另一个结果是，在将字符串常量作为格式控制字符串或输入传递时， <strong>sscanf</strong>在某些系统上不起作用。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是因为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sscanf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误地尝试写入字符串常量。</font><font style="vertical-align: inherit;">同样是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fscanf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scanf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些问题的最佳解决方案是将程序更改为使用</font><font style="vertical-align: inherit;">带初始化字符串的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -array变量而不是字符串常量来达到这些目的。</font><font style="vertical-align: inherit;">但是，如果这不可能，则可以使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-fwritable-strings</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志，该标志指示GCC以与大多数C编译器相同的方式处理字符串常量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料来源：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="使用GNU编译器集合（GCC 3.3）官方手册。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用GNU编译器集合（GCC 3.3）官方手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></blockquote><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-fwritable-strings</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器标志</font><font style="vertical-align: inherit;">在GCC 3.4中已弃用，并在GCC 4.0中被永久删除。</font></font><br><blockquote> <strong>ANSI C rationale | String literals</strong> <br> String literals are specified to be unmodifiable. This specification allows implementations to share copies of strings with identical text, to place string literals in read-only memory, and perform certain optimizations. However, string literals do not have the type array of const char, in order to avoid the problems of pointer type checking, particularly with library functions, since assigning a pointer to const char to a plain pointer to char is not valid. Those members of the Committee who insisted that string literals should be modifiable were content to have this practice designated a common extension (see F.5.5). <br><br> Existing code which modifies string literals can be made strictly conforming by replacing the string literal with an initialized static character array. For instance, <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p, *make_temp(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> p = make_temp(<span class="hljs-string"><span class="hljs-string">"tempXXX"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* make_temp overwrites the literal */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* with a unique name */</span></span></code> </pre><br> can be changed to: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p, *make_temp(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>[ ] = <span class="hljs-string"><span class="hljs-string">"tempXXX"</span></span>; p = make_temp( <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ); }</code> </pre><br> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Rationale for American National Standard for Information Systems, Programming Language C, String literals.">Rationale for American National Standard for Information Systems, Programming Language C</a> . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VarfolomeyKote4ka</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Perl   1987 ,    LINUX.ORG.RU"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣gryaznenky黑客</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，允许你绕过错误分段错误，当您尝试区间变化数据</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.RODATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过将其转换成部分</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.rwdata</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。不久前，</font><font style="vertical-align: inherit;">程序员</font><strong><font style="vertical-align: inherit;">Guye1296</font></strong><font style="vertical-align: inherit;">在Internet上刊登了一篇非常有趣的文章，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="From .rodata to .rwdata – introduction to memory mapping and LD scripts, Guy on BITS."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“从.rodata到.rwdata-内存映射和LD脚本简介”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中介绍了如何实现此技巧。为了促进获得期望的结果，本文的作者为标准链接程序</font><strong><font style="vertical-align: inherit;">ld</font></strong><font style="vertical-align: inherit;"> - </font><a href="" title="rwdata.ld script for ld linker, guye1296, GitHub repository."><font style="vertical-align: inherit;">rwdata.ld</font></a><font style="vertical-align: inherit;">准备了相当多的脚本。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><a href="" title="rwdata.ld script for ld linker, guye1296, GitHub repository."><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只需下载此脚本，将其放在Perl源目录的根目录中，</font><font style="vertical-align: inherit;">按如下所示</font><font style="vertical-align: inherit;">纠正</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LDFLAGS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志</font><font style="vertical-align: inherit;">：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LDFLAGS = -T rwdata.ld</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后重建项目。</font><font style="vertical-align: inherit;">结果，我们得到以下结果：</font></font><br><br><pre> <code class="bash hljs">$ make clean &amp;&amp; make -j1 $ mv perl perl_rodata $ curl -LOJ https://raw.githubusercontent.com/guye1296/ld_script_elf_blog_post/master/rwdata.ld $ sed -i <span class="hljs-string"><span class="hljs-string">'s/LDFLAGS =/LDFLAGS = -T rwdata.ld/'</span></span> Makefile $ make clean &amp;&amp; make -j1 $ mv perl perl_rwdata $ objdump -s -j .rodata perl_rodata | grep tmp -2 19da0 21233f5e 7e3d2d25 30313233 34353637 !<span class="hljs-comment"><span class="hljs-comment">#?^~=-%01234567 19db0 38392e2b 262a2829 2c5c2f5b 7c002400 89.+&amp;*(),\/[|.$. 19dc0 73746465 7272002f 746d702f 7065726c stderr./tmp/perl 19dd0 2d655858 58585858 00323536 00617070 -eXXXXXX.256.app 19de0 656e6400 6c6f6f70 63746c00 66756e63 end.loopctl.func $ objdump -s -j .rwdata perl_rodata | grep tmp -2 objdump: section '.rwdata' mentioned in a -j option, but not found in any input file $ objdump -s -j .rwdata perl_rwdata | grep tmp -2 41d9c0 21233f5e 7e3d2d25 30313233 34353637 !#?^~=-%01234567 41d9d0 38392e2b 262a2829 2c5c2f5b 7c002400 89.+&amp;*(),\/[|.$. 41d9e0 73746465 7272002f 746d702f 7065726c stderr./tmp/perl 41d9f0 2d655858 58585858 00323536 00617070 -eXXXXXX.256.app 41da00 656e6400 6c6f6f70 63746c00 66756e63 end.loopctl.func $ objdump -s -j .rodata perl_rwdata | grep tmp -2 objdump: section '.rodata' mentioned in a -j option, but not found in any input file $ ./perl_rodata -e 'print "Hello, World!\n";' Segmentation fault (core dumped) $ ./perl_rwdata -e 'print "Hello, World!\n";' Hello, World!</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，由于存在这种黑客攻击，几乎可以忽略第二个补丁中的所有更改！</font><font style="vertical-align: inherit;">当然，尽管使代码成为不违反标准的视图仍然是可取的。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;&lt;跳到内容</font></font></em></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473228/">https://habr.com/ru/post/zh-CN473228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473212/index.html">投资者放低特斯拉股价上涨后每天损失超过14亿美元</a></li>
<li><a href="../zh-CN473218/index.html">首席开发商Ivan Kruglov的访谈：Service Mesh和“非标准” Booking.com工具</a></li>
<li><a href="../zh-CN473220/index.html">Wolfram语言中慢代码破坏的基石：加速代码数十，数百和数千倍</a></li>
<li><a href="../zh-CN473222/index.html">使用zabbix作为示例的Docker自定义iptables规则</a></li>
<li><a href="../zh-CN473224/index.html">高等教育与能力。 俄罗斯联邦宪法法院法官关于高等教育状况的单独意见</a></li>
<li><a href="../zh-CN473230/index.html">卫星互联网是新的太空竞赛吗？</a></li>
<li><a href="../zh-CN473232/index.html">您使用什么版本控制系统（在实际工作中，大多数）？</a></li>
<li><a href="../zh-CN473234/index.html">使用Node.js和Oracle数据库创建REST API</a></li>
<li><a href="../zh-CN473236/index.html">在云中从事IT，项目管理，PD监管和开发工作：1cloud.ru中的megadigest</a></li>
<li><a href="../zh-CN473238/index.html">Netflix如何运作</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>