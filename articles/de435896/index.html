<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã üí∏ üíº Verwenden von DiagnosticSource in .NET Core: Theorie üë® üõï üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DiagnosticSource ist ein einfacher, aber sehr n√ºtzlicher Satz von APIs (verf√ºgbar im NuGet-Paket System.Diagnostics.DiagnosticSource ), mit denen eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von DiagnosticSource in .NET Core: Theorie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ozontech/blog/435896/"><p>  DiagnosticSource ist ein einfacher, aber sehr n√ºtzlicher Satz von APIs (verf√ºgbar im NuGet-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.Diagnostics.DiagnosticSource</a> ), mit denen einerseits verschiedene Bibliotheken benannte Ereignisse √ºber ihre Arbeit senden k√∂nnen und andererseits Anwendungen diese Ereignisse und Prozesse abonnieren k√∂nnen sie. </p><br><p>  Jedes dieser Ereignisse enth√§lt zus√§tzliche Informationen (Nutzdaten). Da Ereignisse im selben Prozess wie das Senden verarbeitet werden, k√∂nnen diese Informationen fast alle Objekte enthalten, ohne dass eine Serialisierung / Deserialisierung erforderlich ist. </p><br><p> DiagnosticSource wird bereits in AspNetCore, EntityFrameworkCore, HttpClient und SqlClient verwendet. Dadurch k√∂nnen Entwickler eingehende / ausgehende http-Anforderungen, Datenbankanforderungen, Zugriffsobjekte wie <code>HttpContext</code> , <code>DbConnection</code> , <code>DbCommand</code> , <code>HttpRequestMessage</code> und viele andere <code>HttpRequestMessage</code> Objekte, falls erforderlich. </p><br><p>  Ich beschloss, meine Geschichte √ºber DiagnosticSource in zwei Artikel zu unterteilen.  In diesem Artikel werden wir das Funktionsprinzip des Mechanismus anhand eines einfachen Beispiels analysieren. Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten</a> Artikel werde ich auf Ereignisse in .NET eingehen, die mit ihm verarbeitet werden k√∂nnen, und einige Beispiele f√ºr seine Verwendung in OZON.ru zeigen. </p><a name="habracut"></a><br><h2 id="primer">  Beispiel </h2><br><p>  Betrachten Sie ein kleines Beispiel f√ºr das Abfangen von Datenbankabfragen, um besser zu verstehen, wie DiagnosticSource funktioniert.  Stellen Sie sich vor, wir haben eine einfache Konsolenanwendung, die eine Anforderung an die Datenbank sendet und das Ergebnis in der Konsole anzeigt. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ConnectionString = <span class="hljs-string"><span class="hljs-string">@"Data Source=localhost;Initial Catalog=master;User ID=sa;Password=Password12!;"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> answer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetAnswerAsync(); Console.WriteLine(answer); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnswerAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnection(ConnectionString)) { <span class="hljs-comment"><span class="hljs-comment">// using Dapper return await connection.QuerySingleAsync&lt;int&gt;("SELECT 42;"); } } }</span></span></code> </pre> <br><p>  Der Einfachheit halber habe ich SQL Server in einem Docker-Container ausgel√∂st. </p><br><div class="spoiler">  <b class="spoiler_title">Docker laufen</b> <div class="spoiler_text"><pre> <code class="bash hljs">docker run --rm --detach --name mssql-server \ --publish 1433:1433 \ --env ACCEPT_EULA=Y \ --env SA_PASSWORD=Password12! \ mcr.microsoft.com/mssql/server:2017-latest</code> </pre> </div></div><br><p>  Stellen Sie sich nun vor, wir haben eine Aufgabe: Wir m√ºssen die Ausf√ºhrungszeit aller Abfragen an die Datenbank mithilfe der <code>Stopwatch</code> messen und die Paare "Request" - "Runtime" in der Konsole anzeigen. </p><br><p>  Nat√ºrlich k√∂nnen Sie den <code>QuerySingleAsync</code> Aufruf einfach <code>QuerySingleAsync</code> Code <code>QuerySingleAsync</code> , der die <code>Stopwatch</code> erstellt und startet, sie nach Ausf√ºhrung der Abfrage stoppt und das Ergebnis anzeigt, aber es gibt mehrere Schwierigkeiten gleichzeitig: </p><br><ul><li>  Was ist, wenn die Anwendung mehr als eine Anfrage hat? </li><li>  Was passiert, wenn der Code, der die Anforderung ausf√ºhrt, bereits kompiliert ist, als NuGet-Paket mit der Anwendung verbunden ist und wir keine M√∂glichkeit haben, ihn zu √§ndern? </li><li>  Was ist, wenn die Abfrage an die Datenbank nicht √ºber Dapper, sondern beispielsweise √ºber EntityFramework erfolgt und wir keinen Zugriff auf das <code>DbCommand</code> Objekt oder den generierten Abfragetext haben, der tats√§chlich ausgef√ºhrt wird? </li></ul><br><p>  Versuchen wir, dieses Problem mit DiagnosticSource zu l√∂sen. </p><br><h3 id="ispolzovanie-nuget-paketa-systemdiagnosticsdiagnosticsource">  Verwenden des NuGet System.Diagnostics.DiagnosticSource-Pakets </h3><br><p>  Nachdem Sie das NuGet-Paket von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.Diagnostics.DiagnosticSource verbunden haben</a> , m√ºssen Sie zun√§chst eine Klasse erstellen, die die f√ºr uns interessanten Ereignisse behandelt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> { }</code> </pre> <br><p>  Um mit der Verarbeitung von Ereignissen zu beginnen, m√ºssen Sie eine Instanz dieser Klasse erstellen und als Beobachter im statischen Objekt <code>DiagnosticListener.AllListeners</code> (im <code>System.Diagnostics</code> Namespace) registrieren.  Wir tun dies ganz am Anfang der Hauptfunktion: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleDiagnosticObserver(); IDisposable subscription = DiagnosticListener.AllListeners.Subscribe(observer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> answer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetAnswerAsync(); Console.WriteLine(answer); }</code> </pre> <br><p>  In diesem Fall <code>ExampleDiagnosticObserver</code> uns der Compiler zu Recht mit, dass die <code>ExampleDiagnosticObserver</code> Klasse die <code>IObserver&lt;DiagnosticListener&gt;</code> -Schnittstelle implementieren soll.  Lassen Sie es uns implementieren: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { Console.WriteLine(diagnosticListener.Name); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { } }</code> </pre> <br><p>  Wenn wir diesen Code jetzt ausf√ºhren, wird Folgendes in der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">SqlClientDiagnosticListener SqlClientDiagnosticListener 42</code> </pre> <br><p>  Dies bedeutet, dass irgendwo in .NET zwei Objekte vom Typ <code>DiagnosticListener</code> mit dem Namen <code>"SqlClientDiagnosticListener"</code> registriert sind, die bei der Ausf√ºhrung dieses Codes funktionierten. </p><br><div class="spoiler">  <b class="spoiler_title">Hier sind sie auf github.com</b> <div class="spoiler_text"><p>  Es gibt tats√§chlich drei davon, aber da wir <code>SqlTransaction</code> nicht verwendet <code>SqlTransaction</code> , haben nur zwei funktioniert: </p><br><ul><li>  <a href="">https://github.com/dotnet/corefx/blob/v2.2.1/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlConnection.cs#L50</a> </li><li>  <a href="">https://github.com/dotnet/corefx/blob/v2.2.1/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlCommand.cs#L31</a> </li><li>  <a href="">https://github.com/dotnet/corefx/blob/v2.2.1/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlTransaction.cs#L16</a> </li></ul></div></div><br><p>  Die <code>IObserver&lt;DiagnosticListener&gt;.OnNext</code> wird <strong>bei der ersten Verwendung</strong> f√ºr jede Instanz des <code>DiagnosticListener</code> , die in der Anwendung erstellt wird, <strong>einmal</strong> aufgerufen (normalerweise werden sie als statische Eigenschaften erstellt).  Jetzt haben wir nur den Namen der <code>DiagnosticListener</code> Instanzen in der Konsole angezeigt. In der Praxis muss diese Methode diesen Namen √ºberpr√ºfen und, wenn wir Ereignisse aus dieser Instanz verarbeiten m√∂chten, mit der <code>Subscribe</code> Methode <code>Subscribe</code> . </p><br><p>  Ich m√∂chte auch darauf hinweisen, dass wir beim Aufrufen von <code>DiagnosticListener.AllListeners.Subscribe</code> als Ergebnis ein <code>subscription</code> , das die <code>IDisposable</code> Schnittstelle implementiert.  Das Aufrufen der <code>Dispose</code> Methode f√ºr dieses Objekt f√ºhrt zur Abmeldung, die in der <code>IObserver&lt;DiagnosticListener&gt;.OnCompleted</code> . </p><br><p>  Implementieren wir den <code>IObserver&lt;DiagnosticListener&gt;</code> erneut: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;IDisposable&gt; _subscriptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IDisposable&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diagnosticListener.Name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.Subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _subscriptions.Add(subscription); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { _subscriptions.ForEach(x =&gt; x.Dispose()); _subscriptions.Clear(); } }</code> </pre> <br><p>  Jetzt <code>ExampleDiagnosticObserver</code> uns der Compiler mit, dass unsere <code>ExampleDiagnosticObserver</code> Klasse auch die <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</code> -Schnittstelle implementieren soll.  Hier m√ºssen wir den <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnNext</code> , die als Parameter <code>KeyValuePair&lt;string, object&gt;</code> akzeptiert, wobei der Schl√ºssel der Name des Ereignisses ist und der Wert ein anonymes Objekt (normalerweise) mit beliebigen Parametern ist, die wir verwenden k√∂nnen nach eigenem Ermessen.  F√ºgen wir eine Implementierung dieser Schnittstelle hinzu: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">KeyValuePair</span></span>&lt;<span class="hljs-title"><span class="hljs-title">string</span></span>, <span class="hljs-title"><span class="hljs-title">object</span></span>&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// IObserver&lt;DiagnosticListener&gt; implementation // ... void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnNext(KeyValuePair&lt;string, object&gt; pair) { Write(pair.Key, pair.Value); } void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnError(Exception error) { } void IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;.OnCompleted() { } private void Write(string name, object value) { Console.WriteLine(name); Console.WriteLine(value); Console.WriteLine(); } }</span></span></code> </pre> <br><p>  Wenn wir jetzt den resultierenden Code ausf√ºhren, wird Folgendes in der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">System.Data.SqlClient.WriteConnectionOpenBefore { OperationId = 3da1b5d4-9ce1-4f28-b1ff-6a5bfc9d64b8, Operation = OpenAsync, Connection = System.Data.SqlClient.SqlConnection, Timestamp = 26978341062 } System.Data.SqlClient.WriteConnectionOpenAfter { OperationId = 3da1b5d4-9ce1-4f28-b1ff-6a5bfc9d64b8, Operation = OpenAsync, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Connection = System.Data.SqlClient.SqlConnection, Statistics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978631500 } System.Data.SqlClient.WriteCommandBefore { OperationId = 5c6d300c-bc49-4f80-9211-693fa1e2497c, Operation = ExecuteReaderAsync, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Command = System.Data.SqlClient.SqlComman d } System.Data.SqlClient.WriteCommandAfter { OperationId = 5c6d300c-bc49-4f80-9211-693fa1e2497c, Operation = ExecuteReaderAsync, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Command = System.Data.SqlClient.SqlComman d, Statistics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978709490 } System.Data.SqlClient.WriteConnectionCloseBefore { OperationId = 3f6bfd8f-e5f6-48b7-82c7-41aeab881142, Operation = Close, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Connection = System.Data.SqlClient.SqlConnection, Stat istics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978760625 } System.Data.SqlClient.WriteConnectionCloseAfter { OperationId = 3f6bfd8f-e5f6-48b7-82c7-41aeab881142, Operation = Close, ConnectionId = 84bd0095-9831-456b-8ebc-cb9dc2017368, Connection = System.Data.SqlClient.SqlConnection, Stat istics = System.Data.SqlClient.SqlStatistics+StatisticsDictionary, Timestamp = 26978772888 } 42</code> </pre> <br><p>  Insgesamt werden wir sechs Veranstaltungen sehen.  Zwei davon werden vor und nach dem √ñffnen der Verbindung zur Datenbank ausgef√ºhrt, zwei - vor und nach dem Ausf√ºhren des Befehls und zwei weitere - vor und nach dem Schlie√üen der Verbindung zur Datenbank. </p><br><p>  Jedes Ereignis enth√§lt eine Reihe von Parametern wie <code>OperationId</code> , <code>ConnectionId</code> , <code>Connection</code> , <code>Command</code> , die normalerweise als Eigenschaften eines anonymen Objekts √ºbergeben werden.  Sie k√∂nnen typisierte Werte f√ºr diese Eigenschaften beispielsweise mithilfe von Reflection abrufen.  (In der Praxis ist die Verwendung von Reflexion m√∂glicherweise nicht sehr w√ºnschenswert. Wir verwenden DynamicMethod, um Ereignisparameter abzurufen.) </p><br><p>  Jetzt k√∂nnen wir das anf√§ngliche Problem l√∂sen - die Ausf√ºhrungszeit aller Anforderungen an die Datenbank messen und zusammen mit der urspr√ºnglichen Anforderung in der Konsole anzeigen. </p><br><p>  √Ñndern Sie die Implementierung der <code>Write</code> Methode wie folgt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">KeyValuePair</span></span>&lt;<span class="hljs-title"><span class="hljs-title">string</span></span>, <span class="hljs-title"><span class="hljs-title">object</span></span>&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">// IObserver&lt;DiagnosticListener&gt; implementation // ... // IObserver&lt;KeyValuePair&lt;string, object&gt;&gt; implementation // ... private readonly AsyncLocal&lt;Stopwatch&gt; _stopwatch = new AsyncLocal&lt;Stopwatch&gt;(); private void Write(string name, object value) { switch (name) { case "System.Data.SqlClient.WriteCommandBefore": { //           _stopwatch.Value = Stopwatch.StartNew(); break; } case "System.Data.SqlClient.WriteCommandAfter": { //           var stopwatch = _stopwatch.Value; stopwatch.Stop(); var command = GetProperty&lt;SqlCommand&gt;(value, "Command"); Console.WriteLine($"CommandText: {command.CommandText}"); Console.WriteLine($"Elapsed: {stopwatch.Elapsed}"); Console.WriteLine(); break; } } } private static T GetProperty&lt;T&gt;(object value, string name) { return (T) value.GetType() .GetProperty(name) .GetValue(value); } }</span></span></code> </pre> <br><p>  Hier fangen wir die Start- und Endereignisse der Anfrage an die Datenbank ab.  Bevor wir die Anforderung ausf√ºhren, erstellen und starten wir die Stoppuhr und speichern sie in einer Variablen vom <code>AsyncLocal&lt;Stopwatch&gt;</code> , um sie sp√§ter wieder zu erhalten.  Nach dem Ausf√ºhren der Anforderung erhalten wir die zuvor gestartete Stoppuhr, stoppen sie, rufen den ausgef√ºhrten Befehl √ºber Reflektion aus dem Wertparameter ab und drucken das Ergebnis auf der Konsole aus. </p><br><p>  Wenn wir jetzt den resultierenden Code ausf√ºhren, wird Folgendes in der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">CommandText: SELECT 42; Elapsed: 00:00:00.0341357 42</code> </pre> <br><p>  Es scheint, dass wir unser Problem bereits gel√∂st haben, aber ein kleines Detail bleibt √ºbrig.  Tatsache ist, dass wir beim Abonnieren von <code>DiagnosticListener</code> Ereignissen auch Ereignisse empfangen, die f√ºr uns nicht interessant sind. Da f√ºr jedes Ereignis ein anonymes Objekt mit Parametern gesendet wird, kann dies zu einer zus√§tzlichen Belastung des GC f√ºhren. </p><br><p>  Um diese Situation zu vermeiden und Ihnen mitzuteilen, welche Ereignisse von <code>DiagnosticListener</code> verarbeitet werden sollen, k√∂nnen Sie beim Abonnieren einen speziellen Delegaten vom Typ <code>Predicate&lt;string&gt;</code> angeben, der den Namen des Ereignisses als Parameter verwendet und <code>true</code> zur√ºckgibt <code>true</code> wenn dieses Ereignis verarbeitet werden soll. </p><br><p>  <code>IObserver&lt;DiagnosticListener&gt;.OnNext</code> in unserer Klasse <code>IObserver&lt;DiagnosticListener&gt;.OnNext</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diagnosticListener.Name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.Subscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, IsEnabled); _subscriptions.Add(subscription); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEnabled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == <span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandBefore"</span></span> || name == <span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandAfter"</span></span>; }</code> </pre> <br><p>  Jetzt wird unsere <code>Write</code> Methode nur f√ºr die Ereignisse <code>"System.Data.SqlClient.WriteCommandBefore"</code> und <code>"System.Data.SqlClient.WriteCommandAfter"</code> aufgerufen. </p><br><h3 id="ispolzovanie-nuget-paketa-microsoftextensionsdiagnosticadapter">  Verwenden des NuGet Package.Extensions.DiagnosticAdapter von Microsoft </h3><br><p>  Da die Ereignisparameter, die wir von <code>DiagnosticListener</code> erhalten, normalerweise als anonymes Objekt √ºbergeben werden, kann das Abrufen durch Reflexion zu teuer sein.  Gl√ºcklicherweise gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft.Extensions.DiagnosticAdapter</a> NuGet-Paket, das dies f√ºr uns mithilfe der Laufzeitcodegenerierung aus dem <code>System.Reflection.Emit</code> . </p><br><p>  Um dieses Paket beim Abonnieren von Ereignissen aus einer Instanz von <code>DiagnosticListener</code> anstelle der <code>Subscribe</code> Methode zu verwenden, m√ºssen Sie die <code>SubscribeWithAdapter</code> Erweiterungsmethode verwenden.  Die Implementierung der <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</code> in diesem Fall nicht mehr erforderlich.  Stattdessen m√ºssen wir f√ºr jedes Ereignis, das wir behandeln m√∂chten, eine separate Methode deklarieren und diese mit dem Attribut <code>DiagnosticNameAttribute</code> (aus dem <code>Microsoft.Extensions.DiagnosticAdapter</code> Namespace) kennzeichnen.  Die Parameter dieser Methoden sind die Parameter des Ereignisses, das verarbeitet wird. </p><br><p>  Wenn wir unsere <code>ExampleDiagnosticObserver</code> Klasse mit diesem NuGet-Paket neu <code>ExampleDiagnosticObserver</code> , erhalten wir den folgenden Code: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;IDisposable&gt; _subscriptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IDisposable&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diagnosticListener.Name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.SubscribeWithAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _subscriptions.Add(subscription); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { _subscriptions.ForEach(x =&gt; x.Dispose()); _subscriptions.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AsyncLocal&lt;Stopwatch&gt; _stopwatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncLocal&lt;Stopwatch&gt;(); [DiagnosticName(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandBefore"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCommandBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _stopwatch.Value = Stopwatch.StartNew(); } [DiagnosticName(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandAfter"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCommandAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DbCommand command</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stopwatch = _stopwatch.Value; stopwatch.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"CommandText: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{command.CommandText}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Elapsed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{stopwatch.Elapsed}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(); } }</code> </pre> <br><p>  Auf diese Weise k√∂nnen wir jetzt die Ausf√ºhrungszeit aller Abfragen an die Datenbank aus unserer Anwendung messen, praktisch ohne den Code der Anwendung selbst zu √§ndern. </p><br><h2 id="sozdanie-sobstvennyh-ekzemplyarov-diagnosticlistener">  Erstellen eigener DiagnosticListener-Instanzen </h2><br><p>  Wenn Sie DiagnosticSource in der Praxis verwenden, abonnieren Sie in den meisten F√§llen vorhandene Ereignisse.  Sie m√ºssen h√∂chstwahrscheinlich keine eigenen Instanzen von <code>DiagnosticListener</code> erstellen und keine eigenen Ereignisse senden (nur wenn Sie keine Bibliothek entwickeln), daher werde ich mich nicht lange mit diesem Abschnitt befassen. </p><br><p>  Um eine eigene Instanz von <code>DiagnosticListener</code> zu erstellen, m√ºssen Sie diese irgendwo im Code als statische Variable deklarieren: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DiagnosticSource _myDiagnosticSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DiagnosticListener(<span class="hljs-string"><span class="hljs-string">"MyLibraty"</span></span>);</code> </pre> <br><p>  Danach k√∂nnen Sie zum Senden eines Ereignisses ein Design des Formulars verwenden: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_myDiagnosticSource.IsEnabled(<span class="hljs-string"><span class="hljs-string">"MyEvent"</span></span>)) _myDiagnosticSource.Write(<span class="hljs-string"><span class="hljs-string">"MyEvent"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* parameters */</span></span> });</code> </pre> <br><p>  Weitere Informationen zum Erstellen eigener <code>DiagnosticListener</code> Instanzen finden Sie im <a href="">DiagnosticSource-Benutzerhandbuch</a> , in dem die Best Practices f√ºr die Verwendung von DiagnosticSource aufgef√ºhrt sind. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Das Beispiel, das wir untersucht haben, ist sicherlich sehr abstrakt und in einem realen Projekt wahrscheinlich nicht n√ºtzlich.  Es zeigt jedoch perfekt, wie dieser Mechanismus zur √úberwachung und Diagnose Ihrer Anwendungen verwendet werden kann. </p><br><p>  Im n√§chsten Artikel werde ich eine Liste der mir bekannten Ereignisse geben, die √ºber DiagnosticSource verarbeitet werden k√∂nnen, und einige praktische Beispiele f√ºr deren Verwendung zeigen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435896/">https://habr.com/ru/post/de435896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435884/index.html">Metallsuche und ... neuronales Netzwerk</a></li>
<li><a href="../de435886/index.html">SpaceX zeigte den Prototyp Starship und wird 10% des Personals reduzieren</a></li>
<li><a href="../de435890/index.html">Die dunklen Seiten einer aktiven Person</a></li>
<li><a href="../de435892/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 281 (vom 7. bis 13. Januar)</a></li>
<li><a href="../de435894/index.html">Privatunterricht. Versteckt in PHP</a></li>
<li><a href="../de435898/index.html">Woran Sie bei einem NALSD-Interview denken sollten</a></li>
<li><a href="../de435900/index.html">Verkapseln Sie es</a></li>
<li><a href="../de435902/index.html">Sie k√∂nnen SELECT nicht einfach nehmen und schreiben, wenn der Anbieter dies nicht zul√§sst ... aber wir werden schreiben</a></li>
<li><a href="../de435904/index.html">KI √ºbersetzte Gehirnaktivit√§t in Sprache</a></li>
<li><a href="../de435906/index.html">Schrittmacher-Cluster-Speicher + DRBD (Dual Primary) + ctdb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>