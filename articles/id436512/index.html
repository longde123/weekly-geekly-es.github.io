<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‚ğŸ» ğŸ‘¨â€ğŸ« ğŸ¤¹ğŸ¿ Bagaimana kami menemukan rilis bermasalah dengan Graphite dan Moira. Rasakan Yandex.Money ğŸ§‘ğŸ¾ ğŸ¤´ğŸ½ ğŸ¦ƒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Setelah cukup istirahat setelah liburan panjang, kami siap melakukan kebaikan Anda dengan semua cara yang tersedia. Kolega dari departemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menemukan rilis bermasalah dengan Graphite dan Moira. Rasakan Yandex.Money</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/436512/"><p>  Halo, Habr!  Setelah cukup istirahat setelah liburan panjang, kami siap melakukan kebaikan Anda dengan semua cara yang tersedia.  Kolega dari departemen TI selalu memiliki sesuatu untuk diceritakan, dan hari ini kami berbagi dengan Anda laporan oleh Alexander Prizov, administrator sistem Yandex.Money, dari pertemuan JavaJam. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QpVS4mf4SJs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  Bagaimana kami membangun aliran umpan balik untuk mendeteksi rilis masalah menggunakan Graphite dan Moira.  Kami akan memberi tahu Anda cara mengumpulkan dan menganalisis metrik tentang jumlah kesalahan dalam aplikasi. </blockquote><a name="habracut"></a><br><p>  - Halo semuanya, nama saya Alexander Prizov, saya bekerja di departemen otomatisasi operasi di Yandex.Money, dan hari ini saya akan memberi tahu Anda tentang bagaimana kami mengumpulkan, memproses, menganalisis informasi tentang sistem kami. </p><br><p>  Anda mungkin bertanya-tanya mengapa laporan itu disebut The Second Way (nama laporan pada pertemuan itu ed.).  Semuanya cukup sederhana.  Di jantung DevOps adalah sejumlah prinsip yang secara kondisional dibagi menjadi tiga kelompok. </p><br><p>  <strong>Cara pertama</strong> adalah prinsip flow.  <strong>Cara kedua</strong> melibatkan prinsip umpan balik.  <strong>Cara ketiga</strong> adalah pembelajaran dan eksperimen yang berkelanjutan. </p><br><p>  Sebagai aturan, dalam hal pengembangan dan pengoperasian produk perangkat lunak, umpan balik berarti telemetri, yang kami kumpulkan tentang sistem kami, dan kasus yang paling umum adalah pengumpulan dan pemrosesan metrik. </p><br><p>  Mengapa kita membutuhkan metrik ini?  Dengan bantuan metrik, kami mendapatkan umpan balik dari sistem dan kami dapat mengetahui status sistem kami, apakah semuanya berjalan dengan baik, bagaimana perubahan kami memengaruhi operasinya, dan apakah diperlukan intervensi untuk menyelesaikan masalah tertentu. </p><br><h2 id="kakie-metriki-mysobiraem">  Metrik apa yang kami kumpulkan? </h2><br><p>  Kami mengumpulkan metrik dari tiga level. </p><br><p>  <em>Tingkat bisnis</em> mencakup indikator yang menarik dari sudut pandang tugas bisnis apa pun.  Misalnya, kita bisa mendapatkan jawaban atas pertanyaan seperti berapa banyak pengguna yang telah kita daftarkan, seberapa sering pengguna masuk ke sistem kita, berapa banyak pengguna aktif yang dimiliki aplikasi seluler kita. </p><br><p>  Level selanjutnya adalah <em>level aplikasi</em> .  Metrik tingkat ini paling sering dilihat oleh pengembang, karena indikator ini memberikan jawaban untuk pertanyaan seberapa baik aplikasi kita bekerja, seberapa cepat aplikasi memproses permintaan, apakah ada kekurangan dalam kinerja.  Ini termasuk waktu respons, jumlah permintaan, panjang antrian, dan banyak lagi. </p><br><p> Dan akhirnya, <em>tingkat infrastruktur</em> .  Semuanya sangat jelas di sini.  Dengan menggunakan metrik ini, kami dapat memperkirakan jumlah sumber daya yang dikonsumsi, cara memperkirakannya, dan mengidentifikasi masalah terkait infrastruktur. </p><br><p>  Singkatnya, saya akan menjelaskan bagaimana kami mengirim, memproses, dan di mana kami menyimpan metrik ini.  Di sebelah aplikasi, kami memiliki pengumpul metrik.  Dalam kasus kami, ini adalah layanan Heka, yang mendengarkan port UDP dan mengharapkan metrik dalam format StatsD sebagai input. </p><br><p>  Format StatsD adalah sebagai berikut: <br><img src="https://habrastorage.org/webt/le/81/nz/le81nz05apfzg1z55ruxwhaue_q.png"></p><br><p>  Yaitu, kami menentukan nama metrik, menunjukkan nilai metrik ini, yaitu 1, 26, dan seterusnya, dan menunjukkan jenisnya.  Secara total, StatsD memiliki sekitar empat atau lima jenis.  Jika Anda tiba-tiba tertarik, Anda dapat melihat secara detail <a href="">deskripsi jenis ini</a> . </p><br><p><img src="https://habrastorage.org/webt/fn/vl/ma/fnvlma7zzczcko8ucurdce7dhew.png"></p><br><p>  Setelah aplikasi mengirim data Heka, metrik dikumpulkan untuk waktu tertentu.  Dalam kasus kami, ini adalah 30 detik, setelah itu Heka mengirimkan data ke carbon-c-relay, yang melakukan fungsi penyaringan, perutean, memperbarui metrik, yang, pada gilirannya, mengirimkan metrik ke penyimpanan kami, kami menggunakan clickhouse (ya, itu tidak memperlambat) ), serta di Moira.  Jika ada yang tidak tahu, ini adalah layanan yang memungkinkan Anda mengonfigurasi pemicu tertentu untuk metrik.  Saya akan berbicara tentang Moira sedikit kemudian.  Jadi, kami melihat metrik apa yang kami kumpulkan, bagaimana kami mengirim dan memprosesnya.  Dan langkah logis berikutnya adalah analisis metrik ini. </p><br><h2 id="kak-myanaliziruem-metriki">  Bagaimana kami menganalisis metrik? </h2><br><p>  Saya akan memberikan situasi nyata di mana analisis metrik memberi kami hasil nyata.  Ambil proses rilis sebagai contoh.  Secara umum, ini termasuk langkah-langkah berikut. </p><br><p><img src="https://habrastorage.org/webt/ob/my/pb/obmypbobncrdmgxutbxbetxom3o.png"></p><br><p>  Rilis ini dikerahkan ke host kenari.  Ini menyumbang sekitar lima persen dari lalu lintas pengguna.  Setelah rilis ke host kenari selesai, kami memberi tahu orang yang bertanggung jawab untuk rilis bahwa ia harus memeriksa apakah semuanya baik-baik saja dengan rilis.  Dan dia harus memberikan reaksi, bereaksi terhadap rilis ini dan mengklik tombol dengan keputusan apakah rilis ini harus diputar, atau harus diputar kembali. </p><br><p>  Tidak sulit untuk menebak bahwa ada kelemahan yang signifikan dalam skema ini, yaitu, bahwa kita mengharapkan reaksi yang bertanggung jawab.  Jika orang yang bertanggung jawab saat ini karena suatu alasan tidak dapat merespons dengan cepat, maka jika kami memiliki rilis bug, maka untuk beberapa waktu lima persen dari lalu lintas datang ke simpul masalah.  Jika semuanya sesuai dengan rilis, maka kami hanya menghabiskan waktu menunggu, dan dengan demikian memperlambat proses rilis. </p><br><blockquote>  Tanpa bug - kami memperlambat proses rilis <br>  Dengan bug - kasih sayang pengguna </blockquote><p>  Dengan memahami masalah ini, kami memutuskan untuk mencari tahu apakah mungkin untuk mengotomatiskan proses pengambilan keputusan pada apakah rilis itu bermasalah atau tidak. </p><br><p>  Tentu saja, kami berpaling kepada pengembang kami untuk memahami bagaimana pemeriksaan rilis dilakukan.  Ternyata, dan tampaknya cukup logis, bahwa indikator utama bahwa rilis itu bermasalah adalah peningkatan jumlah kesalahan dalam log aplikasi ini. <br></p><br><p>  Apa yang dilakukan pengembang?  Mereka membuka Kibana, membuat pilihan sesuai dengan tingkat KESALAHAN dari blok aplikasi, dan jika mereka melihat daftar, mereka berpikir ada sesuatu yang salah dengan aplikasi tersebut.  Perlu disebutkan bahwa log aplikasi kita disimpan dalam Elastis, dan tampaknya semuanya terlihat cukup sederhana.  Kami memiliki log di Elastis, kami hanya harus membuat permintaan di Elastis, membuat pilihan dan memahami berdasarkan data ini apakah rilis itu bermasalah atau tidak.  Namun keputusan ini bagi kami tampaknya tidak terlalu baik. </p><br><h2 id="pochemu-neelastic">  Kenapa tidak elastis? </h2><br><p>  Pertama-tama, kami khawatir bahwa kami mungkin tidak dapat dengan cepat menerima data dari Elastic.  Ada kasus-kasus seperti itu, misalnya, selama pengujian stres, ketika kita memiliki aliran data yang besar, dan cluster mungkin tidak mengatasinya, dan, pada akhirnya, ada keterlambatan pengiriman log selama sekitar 10-15 menit. </p><br><p>  Ada juga alasan sekunder, misalnya, kurangnya nama seragam untuk indeks.  Ini harus diperhitungkan dalam alat otomatisasi.  Dan juga aplikasi pada platform yang berbeda dapat memiliki format log yang berbeda. </p><br><p>  Kami pikir, mengapa tidak mencoba membuat semacam metrik berdasarkan mana kita dapat memutuskan apakah rilis itu bermasalah atau tidak.  Pada saat yang sama, kami tidak ingin membebani pengembang kami untuk membuat perubahan pada basis kode.  Dan, sepertinya bagi kami, kami menemukan solusi yang agak elegan dengan menambahkan append tambahan ke log4j. </p><br><p>  <strong>Seperti apa bentuknya</strong> </p><br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Configuration</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">status</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"warn"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${sys:application.name}"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"logsCountStatsDFormat"</span></span></span><span class="hljs-tag">&gt;</span></span>app_name.logs.%level:1|c<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Properties</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Appenders</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Socket</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STATSD"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">host</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"127.0.0.1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">port</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"8125"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">protocol</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UDP"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PatternLayout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pattern</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${logsCountStatsDFormat}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Socket</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Appenders</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Loggers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Root</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">level</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"INFO"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">AppenderRef</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"STATSD"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Loggers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Pertama, kami menentukan format metrik yang kami kirim.  Berikut ini adalah lampiran tambahan yang mengirimkan catatan dalam format yang kami miliki di atas ke port 8125 melalui UDP, yaitu ke Heka.  Apa yang ini berikan pada kita?  Log4j mengirimkan metrik tipe Penghitung ke setiap entri log dengan tingkat catatan yang ditentukan ERROR, INFO, PERINGATAN, dan sebagainya. </p><br><p>  Namun, kami segera menyadari bahwa mengirim metrik ke setiap entri log dapat membuat beban yang cukup signifikan, dan kami menulis pustaka yang mengagregasi metrik untuk waktu tertentu dan mengirimkan metrik yang sudah teragregasi ke layanan Heka.  Sebenarnya, kami menambahkan aplikasi ini ke logger, dan dengan pendekatan ini kami sekarang tahu berapa banyak aplikasi kami menulis log untuk leveling, kami memiliki nama terpadu untuk metrik, terlepas dari platform mana yang digunakan.  Kita dapat dengan mudah memahami berapa banyak kesalahan dalam log aplikasi.  Dan akhirnya, kami dapat mengotomatiskan proses pengambilan keputusan untuk rilis yang bermasalah. </p><br><h2 id="avtomatizaciya">  Otomasi </h2><br><p><img src="https://habrastorage.org/webt/ip/6j/ek/ip6jekzqqxrfswkbbwuvagplgqe.png"></p><br><p>  Alih-alih memeriksa secara manual setelah rilis, kami menunggu lima menit, setelah itu kami mengumpulkan data pada jumlah entri dalam log aplikasi.  Setelah kami menjalankan skrip, yang, berdasarkan dua sampel, sebelum rilis dan setelah, memutuskan apakah rilis itu bermasalah.  Dengan demikian, kami mengurangi jumlah waktu yang kami habiskan untuk membuat keputusan menjadi lima menit. </p><br><p>  Selain fakta bahwa informasi tentang jumlah kesalahan dalam log berguna selama rilis, ternyata bonus yang bagus juga berguna selama operasi.  Jadi, misalnya, kita dapat memvisualisasikan jumlah kesalahan dalam log di Grafana dan mencatat lonjakan anomali di log aplikasi. </p><br><p><img src="https://habrastorage.org/webt/gy/16/mc/gy16mcxb5mwvi10zwrb8mbwnlwk.png"></p><br><p>  Model matematika yang cukup sederhana digunakan di sini.  Garis hijau adalah jumlah kesalahan dalam log aplikasi.  Merah tua adalah median kali faktor sensitivitas.  Dalam kasus ketika jumlah kesalahan dalam log melewati median, pemicu dipicu, ketika dipicu, pemberitahuan dikirim melalui Moira. </p><br><p><img src="https://habrastorage.org/webt/qz/eb/3o/qzeb3oasmipjyjyeapvo6vb7ody.png"></p><br><p>  Seperti yang saya janjikan, saya akan bercerita sedikit tentang Moira, bagaimana cara kerjanya.  Kami menetapkan metrik target yang ingin kami amati.  Ini adalah jumlah kesalahan dan median bergerak, serta kondisi di mana pemicu ini akan bekerja, yaitu, ketika jumlah kesalahan dalam log melebihi median kali koefisien sensitivitas.  Ketika pemicu dipicu, pengembang menerima pemberitahuan bahwa ledakan kesalahan yang abnormal telah dicatat dalam aplikasi, dan beberapa tindakan harus diambil. </p><br><p><img src="https://habrastorage.org/webt/o7/da/bm/o7dabmq35xnknjkgkkxbjd6o2ak.png"></p><br><p>  Apa yang kita miliki pada akhirnya?  Kami telah mengembangkan mekanisme umum untuk semua aplikasi backend kami, yang memungkinkan kami untuk mendapatkan informasi tentang jumlah entri dalam log pada level tertentu.  Selain itu, dengan menggunakan metrik tentang jumlah kesalahan dalam log aplikasi, kami dapat mengotomatiskan proses pengambilan keputusan apakah rilisnya bermasalah atau tidak.  Mereka juga menulis perpustakaan untuk log4j, yang dapat Anda gunakan jika Anda ingin mencoba pendekatan yang saya jelaskan.  Tautan ke perpustakaan di bawah ini. </p><br><p>  Mungkin itu semua untuk saya.  Terima kasih </p><br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Log4j-count-appender</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moira</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436512/">https://habr.com/ru/post/id436512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436502/index.html">Pampers Berlangganan atau Cara Menjual Lebih Banyak ke Pelanggan yang Sama</a></li>
<li><a href="../id436504/index.html">Sistem dalam Paket, atau Penutup Paket Apa Yang Ada Dalam Chip?</a></li>
<li><a href="../id436506/index.html">Cara membuat AI-rasis tanpa banyak usaha</a></li>
<li><a href="../id436508/index.html">Investasi $ 10 juta dan pujian Wozniak - menciptakan komputer pendidikan untuk anak-anak</a></li>
<li><a href="../id436510/index.html">Data inti secara detail</a></li>
<li><a href="../id436514/index.html">Membuat cerita untuk Instagram dari PHP</a></li>
<li><a href="../id436518/index.html">Haiku Î²1 - buat / b / OS hebat lagi</a></li>
<li><a href="../id436520/index.html">Jangan menggunakan layanan verifikasi online ketika membocorkan data pribadi</a></li>
<li><a href="../id436522/index.html">Bertentangan dengan instruksi</a></li>
<li><a href="../id436524/index.html">Pengalaman pemrograman Unix *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>