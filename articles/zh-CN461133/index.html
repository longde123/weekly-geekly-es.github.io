<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏿 📞 🤦 使用tSQLt测试SQL Server代码 👨🏿‍💼 🐣 🚾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="仅供参考：本文是我关于SQA第25天的报告的扩展版本。 

 根据与同事沟通的经验，我可以说在数据库中测试代码不是一种常见的做法。 这可能是潜在的危险。 数据库中的逻辑由编写“常规”代码的同一个人编写。 因此，那里也可能出现错误，并且还可能给产品，企业和消费者带来负面影响。 不管是帮助后端的存储过程...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用tSQLt测试SQL Server代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/461133/">  <i>仅供参考：本文是我关于SQA第25天的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a>的扩展版本。</i> <br><br> 根据与同事沟通的经验，我可以说在数据库中测试代码不是一种常见的做法。 这可能是潜在的危险。 数据库中的逻辑由编写“常规”代码的同一个人编写。 因此，那里也可能出现错误，并且还可能给产品，企业和消费者带来负面影响。 不管是帮助后端的存储过程，还是将数据转换为存储的ETL，都存在风险，测试可以大大降低风险。 我想告诉您什么是tSQLt，以及它如何帮助我们在SQL Server中测试代码。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2e/-h/nx/2e-hnxb3bddbq3ck_8vi4jwah8i.jpeg"></div><br><a name="habracut"></a><br><h1> 语境 </h1><br>  SQL Server上有一个大型仓库，其中包含各种临床研究数据。 它来自各种来源（主要是面向文档的数据库）。 在服务器本身内部，使用ETL反复转换数据。 将来，可以将这些数据上载到较小的数据库，以供解决某些小的特定问题的Web应用程序使用。 一些客户的客户还要求API以满足其内部需求。 在此类API的实现中，经常使用存储过程和查询。 <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/iw/vu/rz/iwvurz8sbflhuz3mkj39ipf9rag.png"></div><br> 通常，代码按顺序位于DBMS一侧。 <br><br><h1> 为什么需要所有这些 </h1><br> 从介绍中已经可以理解，数据库中的代码是相同的代码 <br> 应用程序，就像其他应用程序一样，也可能会出现错误。 <br><br> 我认为许多人都知道该bug的价格取决于其发现的时间，该发现通常归因于Barry Bohem。 由于需要反复进行很多阶段（编码，单元，集成，系统测试等）来定位错误并将校正后的代码带回原处，因此在早期阶段发现并在后期阶段发现的错误可能会更加昂贵。发现问题的阶段。 该效果也与仓库情况有关。 如果错误蔓延到某个ETL中，并且数据经历了多次转换，那么如果在数据中检测到错误，则必须： <br><br><ol><li> 重新执行所有转换步骤以定位问题。 </li><li> 解决问题。 </li><li> 重新获取更正的数据（不排除手动更正）。 </li><li> 验证由错误引起的错误数据没有出现在其他地方。 </li></ol><br> 不要忘记我们不出售毛绒玩具。 临床研究等领域的错误不仅会给企业造成伤害，还会给人们的健康造成伤害。 <br><br><h1> 怎么测试？ </h1><br> 因为我们在谈论代码测试，所以我们指的是单元测试和集成测试。 这些事情非常排练，涉及不断的回归。 严格来说，没有人手动进行这样的测试（嗯，也许除了一些完全退化的案例外）。 <br><br> 一个不错的好处：在记录代码时，测试可以作为辅助材料。 顺便说一句，客户需求可能看起来像这样（可点击）： <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/fh/af/xb/fhafxb5yph-tgvy2zhka9jfcvmk.png"></a> </div><br>  Excel，带有需求的两列+其他列中分散的支持信息+标注标记，这比提供帮助更令人困惑。 如有必要，恢复原始愿望可能很困难。 测试可以帮助更准确地捕获实现的细微差别（当然，您不应将它们视为等效的文档）。 <br><br> 不幸的是，随着代码的复杂性，测试的复杂性也在增加，并且这种影响可以得到平均化。 <br><br> 测试可以作为抵御自发海象的附加安全层。 由于形式主义导致的CI自检有助于解决此问题。 <br><br> 如果我们的选择落在自动化的道路上，那么我们需要确定实现自动化的工具。 <br><br><h1> 怎么测试？ </h1><br> 在测试数据库中的代码的情况下，我区分两种方法：基于SQL的（即直接在DBMS中运行）和基于非SQL的方法。 我能够强调以下细微差别： <br><div class="scrollable-table"><table><tbody><tr><th>  SQL驱动 <br></th><th> 非sql-powered <br></th></tr><tr><td> 需要在数据库中安装对象 <br></td><td> 需要向数据库安装其他外部工具 <br></td></tr><tr><td> 测试始终独立于数据库外部应用程序中使用的技术 <br></td><td> 测试可能取决于数据库外使用的技术。 <br></td></tr><tr><td> 框架始终与特定的DBMS绑定 </td><td> 该框架通常支持多个DBMS。 </td></tr><tr><td> 对于编写测试，只需要了解DBMS； 对于开发，您可以使用手动测试仪或DBA </td><td> 编写测试通常需要任何编程语言和/或技术的额外知识； 经常需要程序员的帮助 <br></td></tr><tr><td>  DBMS级执行允许使用更高级的伪造和断言 <br></td><td> 外部执行可能会限制工具的功能 <br></td></tr></tbody></table></div> 在SQL Server中，我们有一些选择： <br><div class="scrollable-table"><table><tbody><tr><th colspan="6" align="center"> 一般资讯 </th></tr><tr><th> 职称 </th><th> 方法 </th><th> 建筑学 </th><th> 写在 </th><th> 测试 </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td>  SQL驱动 </td><td> 单位 </td><td>  T-SQL + CLR </td><td>  T-SQL </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TSQLUnit</a> </td><td>  SQL驱动 </td><td> 单位 </td><td>  T-SQL </td><td>  T-SQL </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">utTSQL</a> </td><td>  SQL驱动 </td><td> 单位 </td><td>  T-SQL </td><td>  T-SQL </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tst</a> </td><td>  SQL驱动 </td><td> 单位 </td><td>  T-SQL </td><td>  T-SQL </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td> 非sql-powered </td><td> 健身小姐 </td><td>  C＃/ java </td><td>  Wiki降价 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">懒人</a> </td><td> 非sql-powered </td><td>  RSpec（面向BDD） </td><td> 红宝石 </td><td> 红宝石 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUnit</a>等 </td><td> 非sql-powered </td><td> 单位 </td><td> 不适用 </td><td> 不适用 </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="4" align="center"> 日期 </th></tr><tr><th> 职称 </th><th> 初次露面 </th><th> 最后提交 </th><th> 最新版本 </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td>  2007-07-27 </td><td>  2019/07/07 </td><td>  2016年1月1日 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TSQLUnit</a> </td><td>  2006-12-16（0.9） <br>  2007-07-21（0.91 rc1） </td><td>  2018年4月26日（GitHub） </td><td>  04/09/2011（SourceForge） </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">utTSQL</a> </td><td>  2003-03-12 </td><td>  2003-03-12 </td><td>  2003-03-12 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tst</a> </td><td>  2009年2月3日（v1.0） </td><td> 不适用 </td><td>  2012年3月30日 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td>  2009年12月1日 </td><td>  10-09-2018 </td><td>  2015年8月15日 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">懒人</a> </td><td>  2011年6月23日 </td><td>  2018/12/12 </td><td>  2018/12/12 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUnit</a>等 </td><td> 不适用 </td><td> 不适用 </td><td> 不适用 </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="7" align="center"> 可能性 </th></tr><tr><th> 职称 </th><th> 不需要CLR </th><th>  XML输出 </th><th> 包装在交易中的测试 </th><th> 假货 </th><th> 错误处理程序 </th><th> 断言 </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td>  -- </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td> 太好了 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TSQLUnit</a> </td><td>  + </td><td>  -- </td><td>  + </td><td>  -- </td><td>  -- </td><td> 很差 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">utTSQL</a> </td><td>  + </td><td>  -- </td><td>  -- </td><td>  -- </td><td>  -- </td><td> 不好 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tst</a> </td><td>  + </td><td>  + </td><td>  +（可选） </td><td>  -- </td><td>  + </td><td> 太好了 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td>  + </td><td>  -- </td><td>  +（可选） </td><td>  -- </td><td>  + </td><td> 好 有细微差别 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">懒人</a> </td><td>  + </td><td>  -- </td><td>  +（可选） </td><td>  -- </td><td>  -- </td><td> 好 有细微差别 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUnit</a>等 </td><td>  + </td><td>  + </td><td> 不适用 </td><td> 不适用 </td><td> 不适用 </td><td> 太好了 有细微差别 </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="3" align="center"> 其他 </th></tr><tr><th> 职称 </th><th> 该文件 </th><th> 社区活动 </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td> 太好了 有细微差别 </td><td> 太好了 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TSQLUnit</a> </td><td> 不好 </td><td> 不好 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">utTSQL</a> </td><td> 太好了 </td><td> 不好 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tst</a> </td><td> 太好了 </td><td> 不好 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a> </td><td> 太好了 </td><td> 好吧 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">懒人</a> </td><td> 太好了 </td><td> 好吧 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NUnit</a>等 </td><td> 太好了 </td><td> 太好了 </td></tr></tbody></table></div> 对“好不好”的评价是主观的，抱歉，没有这个，就没有地方。 <br><br> 说明：“首次出现”是我设法找到的框架生命周期中最早的日期，即最早的发布或提交。 <br><br> 您可能会注意到，基于SQL的替代方法已经放弃了相当长的一段时间，并且tSQLt是唯一受支持的选项。 从功能上讲，tSQLt也可以胜出。 唯一的问题是，在断言方面，TST的选择比tSQLt稍微丰富一些，但是，tSQLt的缺点不大。 <br><br>  tSQLt文档中有细微差别，但我稍后会讨论。 <br><br> 在非SQL驱动的世界中，事情并不是那么简单。 尽管不是超级活跃的替代方案正在开发中。  DbFit是一个基于FitNesse框架的有趣工具。 他提供有关Wiki标记的写作测试。  Slacker也是一个奇怪的事情-为数据库编写测试时的BDD方法。 <br><br> 我将讨论非SQL驱动的断言。 从表面上看，它们的数量减少了，因此可以说它们更糟。 但是在这里值得考虑的是它们与tSQLt根本不同。 并非一切都那么简单。 <br><br> 最后一行是“ NUnit等”  -这是一个提醒。 日常工作中熟悉的许多单元测试框架都可以使用辅助库在辅助数据库上使用。 该表有很多N / A，因为该行实际上包括许多工具。 断言列中的“细微差别”来自同一点-在不同的工具中，它们的设置可能有所不同，并且对数据库的适用性问题尚待解决。 <br><br> 作为另一个有趣的指标，我们可以考虑<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google的趋势</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/2u/km/ud2ukmcoyjvstvhcu2taegpib34.png"></div><br> 细微差别： <br><br><ol><li> 我没有包括Slacker，因为这个名称可能意味着很多事情（并且“ Slacker framework”之类的请求在图表上并不是特别明显）。 </li><li> 出于好奇，TST趋势有所增加，但是它也并不能反映事务的状态，因为它是一个缩写，表示很多不同的事物。 </li><li> 我没有包括NUnit及其类似物，因为它们最初是用于测试应用程序自身代码的框架，并且它们的趋势并不表示我们的情况。 </li></ol><br> 一般而言，可以说tSQLt在类似物的背景下看起来很不错。 <br><br><h1> 什么是tSQLt？ </h1><br> 您可能会猜到，tSQLt是一个基于SQL的单元测试框架。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方网站</a> <br><br> 从2005 SP2开始，已经宣布了对SQL Server的支持。 我从来没有能够回顾过去，但是在开发服务器上有2012年，在本地有2017年-没问题。 <br><br> 开源的Apache 2.0许可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可在GitHub上获得</a> 。 您可以在商业项目中免费进行分叉，走私和使用，而且最重要的是，不要害怕CLR中的书签。 <br><br><h1> 工作技工 </h1><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/1v/kx/wi/1vkxwixwjyna756vsce7uhwqzw0.png"></div><br> 测试用例是存储过程。 它们被组合成测试类（以xUnit表示的测试套件）。 <br><br> 测试类只不过是常规的数据库模式。 它们在框架表中的注册与其他方案不同。 您可以通过调用一个过程-tSQLt.NewTestClass进行这种注册。 <br><br> 在测试类内部，还可以定义一个SetUp过程，该过程将在每个单独的测试用例执行之前运行。 <br><br> 不需要拆卸测试程序即可在测试用例完成时恢复系统。 每个测试用例与SetUp过程一起在单独的事务中执行，该事务在收集结果后回滚。 这很方便，但是会带来一些负面影响，我将在下面讨论。 <br><br> 该框架允许您一次运行单个测试用例，整个测试类或所有已注册的测试类。 <br><br><h1> 示例功能 </h1><br> 我不想重述已经很简单的官方指南，而是使用示例来讨论该框架的可能性。 <br><br>  <i>免责声明：</i> <br><br><ul><li>  <i>例子被简化；</i> </li><li>  <i>最初，并不是所有的测试代码都是由我编写的，而是集体创造力的结晶。</i> </li><li>  <i>发明示例2是为了更全面地演示tSQLt的功能。</i> </li></ul><br><h3> 示例1：CsvSql </h3><br> 应一位客户的要求，实施了以下方法。  Nvarchar（MAX）字段中的数据库存储SQL查询。 要查看这些查询，需要使用最少的前端。 这些请求返回的结果集被后端用来生成CSV文件，以通过API调用返回。 <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/5q/mu/oy/5qmuoyyjjvlphk79jt-xtawwjn8.png"></div><br> 结果集非常繁重，包含许多列。 这种结果集的条件示例： <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/dg/50/bb/dg50bbx25qaw6ycwpfqcsfj5kyk.png"></div><br> 该结果集是一些临床试验数据。 让我们仔细看看ClinicsNum的考虑方式-研究中涉及的诊所数量。 我们有两个表：[Trial]和[Clinic]： <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/qo/mu/n-/qomun-gdbdl05teniypbtzi8jio.png"></div><br> 有FK：[Clinic]。[TrialID]-&gt; [Trial]。[TrialID]。 显然，要计算诊所数量，我们只需要通常的COUNT（*）。 <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*), ...  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.Trial  <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.Clinic    <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Trial.ID = Clinic.TrialID  <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Trial.Name = @trialName  <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ...</code> </pre> <br> 我们如何测试这样的请求？ 首先，我们可以使用方便的存根-FakeTable，它将大大简化后续工作。 <br><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable 'dbo.Trial'; EXEC tSQLt.FakeTable 'dbo.Clinic';</code> </pre> <br>  FakeTable做一件简单的事情-重命名旧表并在其位置创建新表。 相同的名称，相同的列，但没有约束'ov和trigger'ov。 <br><br> 我们为什么需要这个： <br><br><ol><li> 测试数据库中可能有一些数据可能会干扰测试。 感谢FakeTable，我们不依赖于它们。 </li><li> 通常，对于测试，您只需要填写几列。 表格中可能有很多，其中有些会有约束。 这样，我们简化了测试数据的进一步安装-我们将仅插入测试用例真正需要的那些数据。 </li><li> 插入测试数据时，我们绝对不会影响任何触发器，也不必担心不必要的后效应。 </li></ol><br> 接下来，插入我们需要的测试数据： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Trial ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-string"><span class="hljs-string">'Valerian'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Clinic ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [TrialID], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic1'</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic2'</span></span>);</code> </pre> <br> 我们从数据库中获取查询，创建实际表并用查询的结果集填充它： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @sqlStatement <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>… <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> actual ([TrialID], ...); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> actual EXEC sp_executesql @sqlStatement, ...</code> </pre> <br> 填写预期-预期值： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> expected (   ClinicsNum <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br> 我想提请您注意以下事实：在Expected表中，只有一列，而在Actual中，则有一组。 <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/qd/gx/ga/qdgxgaqr4cjp2eayoz0eycjs8cg.png"></div><br> 这是由于AssertEqualsTable过程的功能所致，我们将使用该过程检查值。 <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEqualsTable   'expected',   'actual',   'incorrect number of clinics';</code> </pre> <br> 它仅比较两个被比较表中存在的列。 在我们的例子中，这很方便，因为测试查询返回很多列，每个列都有自己的逻辑，有时会很混乱。 我们不想增加测试用例，因此此功能对我们非常有用。 当然，这是一把双刃剑。 如果在“实际”中通过“ SELECT TOP 0”自动填充了一组列，并且在某个时刻突然出现了一个额外的列，则此刻的测试用例将无法解决。 要处理这种情况，您需要进行其他检查。 <br><br><h3> 姊妹程序AssertEqualsTable </h3><br> 值得一提的是，tSQLt包含两个类似于AssertEqualsTable的过程。 这些是AssertEqualsTableSchema和AssertResultSetsHaveSameMetaData。 第一个与AssertEqualsTable相同，但是在表元数据上。 第二个进行了类似的比较，但是对结果集的元数据进行了比较。 <br><br><h3> 示例2：约束 </h3><br> 在前面的示例中，我们看到了如何删除constraint'y。 但是，如果我们需要检查它们怎么办？ 从技术上讲，这也是逻辑的一部分，也可以视为测试覆盖范围的候选对象。 <br><br> 考虑上一个示例的情况。 两个表-[Trial]和[Clinic]；  [TrialID] FK： <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-8/zu/v3/-8zuv3clqoo3ygm9wko5hpibc90.png"></div><br> 让我们尝试编写一个测试用例来测试此约束。 首先，与上次一样，我们伪造表。 <br><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable '[dbo].[Trial]' EXEC tSQLt.FakeTable '[dbo].[Clinic]'</code> </pre> <br> 目标是相同的-摆脱不必要的限制。 我们希望没有不必要的手势的孤立检查。 <br><br> 接下来，我们使用ApplyConstraint过程将所需的约束返回到位置： <br><br><pre> <code class="sql hljs">EXEC tSQLt.ApplyConstraint   '[dbo].[Clinic]',   'Trial_FK';</code> </pre> <br> 在这里，我们将方便的配置放在一起进行直接验证。 检查本身将包含以下事实：尝试插入数据将不可避免地导致异常。 为了使测试用例正常工作，我们需要捕获此异常。  ExpectException异常处理程序将帮助我们解决此问题。 <br><br><pre> <code class="sql hljs">EXEC tSQLt.ExpectException   @ExpectedMessage = 'The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted...<span class="hljs-string"><span class="hljs-string">',   @ExpectedSeverity = 16,   @ExpectedState = 0;</span></span></code> </pre> <br> 安装处理程序后，您可以尝试插入不可插入的内容。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> [dbo].[Clinic] ([TrialID])   <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 捕获异常。 测试通过。 <br><br><h3> 姊妹程序ApplyConstraint </h3><br>  TSQLt开发人员为我们提供了一种类似的测试触发器的方法。 您可以使用ApplyTrigger过程将触发器返回到伪表。 此外，一切都与上面的示例相同-我们触发触发器，检查结果。 <br><br><h3>  ExpectNoException-ExpectException的反义词 </h3><br> 对于绝对不应发生异常的情况，有一个ExpectNoException过程。 它与ExpectException的工作方式相同，不同之处在于，如果发生异常，则认为测试失败。 <br><br><h3> 示例3：信号量 </h3><br> 情况如下。 有许多存储过程和Windows服务。 它们执行的开始可能是由各种外部事件引起的。 在这种情况下，其执行的允许顺序是固定的。 信号量用于区分对数据库表的访问。 它是一组存储过程。 <br><br> 例如，考虑以下过程之一。 我们有两个表： <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-m/hz/8-/-mhz8-fm_n1w7njpryiv8z3epiw.png"></div><br> 表[Process]包含允许执行的进程的列表，[ProcStatus]-这些进程的状态的列表。 <br><br> 我们的程序做什么？ 调用时，首先进行一系列检查： <br><br><ol><li> 在过程参数中传递的要启动过程的名称在[Process]表的[Name]字段中查找。 </li><li> 如果找到了进程名称，则检查当前是否可以启动它-[Process]表的[IsRunable]标志。 </li><li> 如果事实证明该过程可以执行，那么仍然可以确保该过程尚未运行。 在表[ProcStatus]中，检查是否存在状态为'InProg'的有关此过程的记录。 </li></ol><br> 如果一切正常，则将有关此过程的状态为“ InProg”的新记录添加到ProcStatus（这被视为启动），该记录的ID与ProcStatusId参数一起返回。 如果任何验证失败，那么我们期望以下几点： <br><br><ol><li> 一封信将发送给系统管理员。 </li><li> 返回ProcStatusId = -1。 </li><li> 未在[ProcStatus]中添加新条目。 </li></ol><br> 让我们编写一个测试用例，以测试该过程不在可接受列表中的情况。 <br><br> 为了方便起见，请立即应用FakeTable。 在这里，它并不是那么重要，但它可能会有用： <br><br><ol><li> 我们保证会删除所有可能干扰测试用例正确执行的数据。 </li><li> 我们将简化ProcStatus中缺少条目的进一步验证。 </li></ol><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable 'dbo.Process'; EXEC tSQLt.FakeTable 'dbo.ProcStatus';</code> </pre> <br> 要发送消息，请使用我们的程序员编写的[SendEmail]过程。 要检查发给管理员的信，我们需要接听她的电话。 对于这种情况，tSQLt为我们提供了使用SpyProcedure的功能。 <br><br><pre> <code class="sql hljs">EXEC tSQLt.SpyProcedure 'dbo.SendEmail'</code> </pre> <br>  SpyProcedure执行以下操作： <br><br><ol><li> 创建一个格式为[dbo]。[SendEmail_SpyProcedureLog]的表。 </li><li> 与FakeTable一样，它用自己的名称相同但包含日志记录逻辑的原始过程替换。 如果需要，您可以添加任何自己的逻辑。 </li></ol><br> 您可能会猜到，日志记录发生在表[dbo] [SendEmail_SpyProcedureLog]中。 该表包含[_ID_]列-过程调用的序列号。 随后的列带有传递给该过程的参数的名称，并且在调用中传递的值被收集在其中。 如有必要，也可以检查它们。 <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/ko/gh/4h/kogh4hgcdsxagldk2bmdcfrptzi.png"></div><br> 在调用信号量并进行检查之前，我们需要做的最后一件事是创建一个变量，在该变量中，我们将放置[ProcStatus]表中的记录ID（更确切地说，为-1，因为不会添加记录）。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @ProcStatusId <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>;</code> </pre> <br> 调用信号量： <br><br><pre> <code class="sql hljs">EXEC dbo.[Semaphore_JobStarter]   'SomeProcess',   @ProcStatusId OUTPUT; <span class="hljs-comment"><span class="hljs-comment">--    -1</span></span></code> </pre> <br> 就这样，现在我们有了所有必要的数据进行验证。 让我们从检查装运开始。 <br> 信件： <br><br><pre> <code class="sql hljs">IF NOT EXISTS (   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *   <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.SendEmail_SpyProcedureLog) EXEC tSQLt.Fail <span class="hljs-string"><span class="hljs-string">'SendEmail has not been run.'</span></span>;</code> </pre> <br> 在这种情况下，我们决定不检查发送过程中发送的参数，而只是检查事实本身。 我提请您注意tSQLt.Fail过程。 它允许您“正式”失败测试用例。 如果需要构建一些特定的结构，则tSQLt.Fail将允许您执行此操作。 <br><br> 接下来，检查[dbo]中是否缺少条目[ProcStatus]： <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEmptyTable 'dbo.ProcStatus';</code> </pre> <br> 这是我们一开始就应用的FakeTable帮助我们的地方。 多亏他，我们才能期待空虚。 没有它，为了进行准确的验证，我们应该很好地比较信号量前后的记录数量。 <br><br> 等于ProcStatusId = -1，我们可以轻松地使用AssertEquals进行检查： <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEquals   -1,       @ProcStatusId,       'Wrong ProcStatusId.';</code> </pre> <br>  AssertEquals非常简单-它只比较两个值，没有什么超自然的。 <br><br><h3>  AssertEquals同级程序 </h3><br> 为了比较这些值，我们提供了许多过程： <br><br><ul><li> 断言等于 </li><li> 断言不等于 </li><li>  AssertEqualsString </li><li>  Assertike </li></ul><br> 我认为他们的名字说明了一切。 唯一值得注意的是存在单独的AssertEqualsString过程。 问题是AssertEquals / AssertNotEquals / AssertLike与SQL_VARIANT一起使用，并且NVARCHAR（MAX）不适用于它，因此tSQLt开发人员必须分配一个单独的过程来测试NVARCHAR（MAX）。 <br><br><h3> 伪造功能 </h3><br> 可以稍作拉伸的FakeFunction可以称为类似于SpyProcedure的过程。 这种伪造品使您可以用必要的简单功能替换任何功能。 由于SQL Server中的功能是按照带有牙膏的管子的原理工作的-它们通过“唯一的技术漏洞”给出结果，因此，不幸的是，没有提供记录功能。 只能替代逻辑。 <br><br><h1> 陷阱 </h1><br> 值得注意的是，在使用tSQLt时可能会遇到一些陷阱。 在这种情况下，我的陷阱是指由于SQL Server的限制而产生的某些问题，以及/或者框架的开发人员无法解决的问题。 <br><br><h3> 交易取消/损坏 </h3><br> 我们团队面临的第一个也是最重要的问题是取消交易。  SQL Server不知道如何单独回滚嵌套的事务-仅将所有内容作为整体回滚到最外部。 鉴于tSQLt将每个测试用例包装在单独的事务中的事实，这成为一个问题。 毕竟，测试过程中的事务回滚可能会中断测试执行，从而导致非描述性执行错误。 <br><br> 为了避免这个问题，我们使用保存点。 这个想法很简单。 在测试过程中开始事务之前，我们检查是否已经在事务中。 如果结果是肯定的，那么我们假设这是一个tSQLt事务，则将保存点放入而不是开始。 然后，如有必要，我们将回滚到该保存点，而不是事务开始。 这样的嵌套不是。 <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/zk/0u/jc/zk0ujc2gmggccs7bg7icraan3da.png"></div><br> 事务损坏使问题复杂化。 如果突然出了点问题并且异常起作用了，那么交易可能就注定了。 这样的事务不仅可以提交，还可以回滚到保存点，仅回滚整个事情。 <br><br> 鉴于以上所有内容，您必须应用以下设计： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY BEGIN CATCH   DECLARE @isCommitable BIT =       CASE WHEN XACT_STATE() = 1           THEN 'true'           ELSE 'false'   END;   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       ROLLBACK TRANSACTION SavepointName;   ELSE       ROLLBACK;   THROW; END CATCH;</span></span></code> </pre> <br> 考虑部分代码。 首先，我们需要确定我们是否在事务内： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br> 收到@isNestedTransaction标志后，根据情况运行TRY块并设置保存点或事务的开始。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful</span></span></code> </pre> <br> 完成一些有用的操作后，如果这是过程的“真实”开始，请提交。 <br><br><pre> <code class="sql hljs">       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY</span></span></code> </pre> <br> 当然，如果这是从测试用例启动的，则无需提交任何内容。 在执行结束时，tSQLt会简单地回滚所有更改。 如果突然出了点问题，我们进入了CATCH块，那么首先要做的就是找出我们的交易是否可以提交。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH   <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isCommitable <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =       <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> XACT_STATE() = <span class="hljs-number"><span class="hljs-number">1</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br> 只有在以下情况下，我们才能回滚到保存点： <br><br><ol><li> 委托交易 </li><li> 进行测试运行，即 保存点存在。 </li></ol><br> 在其他情况下，我们需要回滚整个交易。 <br><br><pre> <code class="sql hljs">   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;   ELSE       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;   THROW; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH;</code> </pre> <br> 是的，不幸的是，如果在测试运行期间我们遇到了无法提交的事务，那么在执行测试用例时仍然会出错。 <br><br><h3>  FakeTable和外键问题 </h3><br> 考虑熟悉的表[Trial]和[Clinic]： <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/fy/k7/nm/fyk7nmhfha_fnezignyxclpflay.png"></div><br> 我们记得[TrialID] FK。 这会导致什么问题？ 在前面给出的示例中，我们一次将FakeTable应用于两个表。 如果仅将其应用于[Trial]，则会出现以下情况： <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/og/to/3-/ogto3-drjheieblpi1_gsyup4hs.png"></div><br> 尝试以这种方式在[诊所]中插入条目可能会失败（即使我们在[Trial]表的伪造版本中准备了所有必要的数据）。 <br><br><pre> <code class="sql hljs">[dbo].[Test_FK_Problem] failed: (Error) The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> <span class="hljs-string"><span class="hljs-string">"Trial_Fk"</span></span>. The conflict occurred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">"HabrDemo"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">"dbo.tSQLt_tempobject_ba8f36353f7a44f6a9176a7d1db02493"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">'TrialID'</span></span>.[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]{Test_FK_Problem,<span class="hljs-number"><span class="hljs-number">14</span></span>}</code> </pre> <br> 结论：您需要伪造一切，或者不伪造任何东西。 在第二种情况下，很明显必须事先准备好底座以进行测试。 <br><br><h3> 系统程序上的SpyProcedure </h3><br>  las，监视系统过程的调用将失败。 <br><br><pre> <code class="sql hljs">[HabrDemo].[test_test] failed: (Error) Cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> SpyProcedure <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sys.sp_help because the <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>] {tSQLt.Private_ValidateProcedureCanBeUsedWithSpyProcedure,<span class="hljs-number"><span class="hljs-number">7</span></span>}</code> </pre> <br> 在信号量示例中，我们跟踪了开发人员编写的对[SendEmail]过程的调用。 在这种情况下，编写单独的过程是由于需要在直接发送消息之前收集和处理一些其他信息。 通常，必须为以下事实做好心理准备：一个人可能仅出于测试目的就必须为某些系统过程编写中间层过程。 <br><br><h1> 优势优势 </h1><br><h3> 快速安装 </h3><br> 安装分为两个阶段，大约需要2分钟。 您只需激活服务器上的CLR（如果尚未完成），然后执行一个脚本即可。 一切都可以添加第一个测试类并编写测试用例。 <br><br><h3> 快速发展 </h3><br>  tSQLt是一个易于学习的工具。 我花了几天的时间来掌握它。 我问了使用该框架的同事，结果发现每个人都会花费大约一天的时间。 <br><br><h3> 在CI中快速实施 </h3><br> 在我们的项目中，在CI中设置集成大约需要2个小时。 时间当然可以变化，但是通常这不是问题，并且集成可以非常快速地进行。 <br><br><h3> 种类繁多的工具 </h3><br> 这是一个主观评估，但是我认为tSQLt提供的功能非常丰富，可以满足实践中绝大部分需求。 在极少数情况下，如果没有足够的内置伪造和断言，则存在tSQLt.Fail。 <br><br><h3> 方便的文档 </h3><br> 官方文档既方便又一致。 有了它的帮助，即使这是您的第一个单元测试工具，您也可以在短时间内轻松理解使用tSQLt的本质。 <br><br><h3> 方便的输出 </h3><br> 可以以非常清晰的文本形式获取数据： <br><br><pre> <code class="plaintext hljs">[tSQLtDemo].[test_error_messages] failed: (Failure) Expected an error to be raised. [tSQLtDemo].[test_tables_comparison] failed: (Failure) useful and descriptive error message Unexpected/missing resultset rows! |_m_|Column1|Column2| +---+-------+-------+ |&lt; |2 |Value2 | |= |1 |Value1 | |= |3 |Value3 | |&gt; |2 |Value3 | +----------------------+ |Test Execution Summary| +----------------------+ |No|Test Case Name |Dur(ms)|Result | +--+------------------------------------+-------+-------+ |1 |[tSQLtDemo].[test_constraint] | 83|Success| |2 |[tSQLtDemo].[test_trial_view] | 83|Success| |3 |[tSQLtDemo].[test_error_messages] | 127|Failure| |4 |[tSQLtDemo].[test_tables_comparison]| 147|Failure| ----------------------------------------------------------------------------- Msg 50000, Level 16, State 10, Line 1 Test Case Summary: 4 test case(s) executed, 2 succeeded, 2 failed, 0 errored. -----------------------------------------------------------------------------</code> </pre><br> 您还可以从数据库中提取（可单击）... <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-f/83/la/-f83lajcz1mfcnkhtttz45b0x3g.png"></a> </div><br>  ...或以XML格式获取。 <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tests</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">errors</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">failures</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">timestamp</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2019-06-22T16:46:06"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.433"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hostname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BLAHBLAHBLAH\SQL2017"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_constraint"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.097"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_error_messages"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.153"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">failure</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Expected an error to be raised."</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt.Fail"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_trial_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.156"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-out</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-err</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 后一个选项使您可以轻松地将测试集成到CI中。 尤其是，在Atlassian Bamboo下，一切对我们都有效。 <br><br><h3>  Redgate支持 </h3><br> 这些优点包括对像RedGate这样的大型DBA工具提供程序的支持。  SQL Test-他们的SQL Server Management Studio插件-可以立即使用tSQLt。 此外，正如Google Group的开发人员本人所言，RedGate为使用开发环境的tSQLt主要开发人员提供了帮助。 <br><br><h1> 缺点 </h1><br><h3> 没有临时餐桌假货 </h3><br>  tSQLt不允许伪造的临时表。 如有必要，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非官方插件</a> 。 不幸的是，此加载项仅受SQL Server 2016+支持。 <br><br><h3> 无法访问外部数据库 </h3><br> 仅为存储框架保留单独的基础将不起作用。  tSQLt旨在测试同一数据库中的内容。  ake ，，不会起作用。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>]   EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'[AdventureWorks2017].[Person].[Password]'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ga/au/ny/gaaunygdr124sssxhonbb2s0b_0.png"></div><br> 断言似乎起作用，但是没有人保证其性能。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db_assertions] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> *   <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-comment"><span class="hljs-comment">#Actual   FROM [AdventureWorks2017].[Person].[Password]   SELECT *   INTO #Expected   FROM (          SELECT 'bE3XiWw=' AS [PasswordSalt]   ) expectedresult;   EXEC tSQLt.AssertEqualsTable '#Expected', '#Actual', 'The salt is not salty'; END</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/dk/ow/cgdkowych69imevqmbirkkgsniq.png"></div><br><h3> 文档错误 </h3><br> 尽管我在上面写过关于文档的一致性和可访问性的事实，但它也包含一些问题。 其中有一些过时的时刻。 <br><br> 示例1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“快速入门指南”</a>建议从SourceForge下载该框架。 他们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在2015年</a>与SourceForge道别。 <br><br> 示例2.示例中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ApplyConstraint指南</a>使用带有Fail过程的繁重结构来捕获异常，用ExpectException替换异常会更容易且更直观。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> ConstraintTests.[<span class="hljs-keyword"><span class="hljs-keyword">test</span></span> ReferencingTable_ReferencedTable_FK prevents <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> orphaned <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'dbo.ReferencedTable'</span></span>; EXEC tSQLt.FakeTable 'dbo.ReferencingTable'; EXEC tSQLt.ApplyConstraint 'dbo.ReferencingTable','ReferencingTable_ReferencedTable_FK'; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* []     ExceptException ? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.ReferencingTable ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, ReferencedTableId ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span> ) ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = ERROR_MESSAGE(); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%ReferencingTable_ReferencedTable_FK%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.Fail <span class="hljs-string"><span class="hljs-string">'Expected error message containing ''ReferencingTable_ReferencedTable_FK'' but got: '''</span></span>,@ErrorMessage,<span class="hljs-string"><span class="hljs-string">'''!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre><br> 这是自然的，因为它发生了... <br><br><h3> 部分遗弃 </h3><br> 从2016年初到2019年6月，tSQLt的开发有很长的时间。是的，不幸的是，该工具已被部分弃用。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>看来，2019年一点一点，开发仍在向前发展。 尽管正式的Google Groups <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有一个线程</a>可以直接向tSQLt的主要开发人员Sebastian询问开发的命运。 最后一个问题是在2019年3月2日提出的，尚未收到答案。 <br><br><h3>  SQL Server 2017问题 </h3><br> 如果您使用的是SQL Server 2017，那么对您来说，可能需要安装tSQLt进行一些其他操作。    ,    2012   SQL Server  security-.       «CLR strict security»,      ( SAFE).       (,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>     ).      . <br><br>   , ,     « »,       tSQLt,        ,    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> GitHub   issue</a> , ,       2017 (.  ). <br><br><h1>  (±)    </h1><br>        . tSQLt      . ,    (CLR,   T-SQL     SQL ),        ,       . ,     tSQLt  ,       SQL-powered   . <br><br> ,  PostgreSQL       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ptTAP</a> .      «» PL/pgSQL      TAP.  MySQL  ,       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MyTAP</a> .       Oracle,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">utPLSQL</a> —     (   ,  )  . <br><br><h1> 结论 </h1><br> ,         . <br><br>  —     .     SQL Server, Oracle  MySQL — .          ,       .       ,       ,    ,  , ,  . <br><br>   —   .  ,     ,   SQL Server,  tSQLt    100% ,    ,      .        ,     ,   . <br><br><div class="spoiler"> <b class="spoiler_title">,    ( )</b> <div class="spoiler_text"> DbFit — Automated Open Source Database Testing: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.methodsandtools.com/tools/dbfit.php</a> <br><br> DbFit Documentation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://dbfit.github.io/dbfit/docs/</a> <br><br> Slacker wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/vassilvk/slacker/wiki</a> <br><br> TST documentation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://archive.codeplex.com/projects/TST/4e04e281-9f35-4891-809a-15f09d304f4e</a> <br><br> NUnit Assertions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/nunit/docs/wiki/Assertions</a> <br><br> utTSQL code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://sourceforge.net/p/uttsql/code/HEAD/tree/</a> <br><br> Junit Class Assert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://junit.org/junit4/javadoc/latest/org/junit/Assert.html</a> <br><br> pgTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://pgtap.org/</a> <br><br> utPLSQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://utplsql.org/</a> <br><br> MyTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/hepabolu/mytap</a> <br><br> tSQLt Google groups: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://groups.google.com/forum/#!forum/tsqlt</a> <br><br> tSQLt official website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tsqlt.org/</a> <br><br> tSQLt GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/tSQLt-org/tSQLt</a> <br><br> Google trends: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://bit.ly/2x7BQL6</a> <br><br> How to ROLLBACK a transaction when testing using tSQLt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://stackoverflow.com/questions/8973138/how-to-rollback-a-transaction-when-testing-using-tsqlt</a> <br><br> What are the Pros and Cons of Manual Unit Testing against the Automated Unit Testing?: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://stackoverflow.com/questions/2948337/what-are-the-pros-and-cons-of-manual-unit-testing-against-the-automated-unit-tes#2948354</a> <br><br> The Good, the Bad, and the Ugle̅e̅: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://sqlquantumleap.com/2017/08/07/sqlclr-vs-sql-server-2017-part-1-clr-strict-security/</a> <br><br> Rex Black, Erik Van Veenendal, Dorothy Graham, Foundations of Software Testing, Third edition, 2012 Cengage Learning EMEA <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461133/">https://habr.com/ru/post/zh-CN461133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461121/index.html">微控制器中的小型多任务实验</a></li>
<li><a href="../zh-CN461125/index.html">在Visual Studio的源代码中创建顺序编号代码以对消息编号的任务（例如C＃）</a></li>
<li><a href="../zh-CN461127/index.html">VMware vSphere中的VM性能分析。 第3部分：存储</a></li>
<li><a href="../zh-CN461129/index.html">关于kote，妻子，两个儿子，这个主意……而不仅仅是。 延续故事</a></li>
<li><a href="../zh-CN461131/index.html">ROS购物车第2部分。</a></li>
<li><a href="../zh-CN461137/index.html">我们如何开发一种用于监视驾驶员注意力的设备。 体验Yandex.Taxi</a></li>
<li><a href="../zh-CN461141/index.html">我与Hai句的第一天：她出奇地好</a></li>
<li><a href="../zh-CN461143/index.html">当前游戏设计的问题及其解决方法。 从下面查看</a></li>
<li><a href="../zh-CN461145/index.html">团队应该领导什么：角色，责任和技能</a></li>
<li><a href="../zh-CN461147/index.html">如何通过组合PowerPoint中的键来节省64小时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>