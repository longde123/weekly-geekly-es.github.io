<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤩 🗂️ 😣 在云端使用自动更新的SSL托管Node.js https服务器，以及如何设置开发周期（+ git，react） 🧓🏻 📨 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前言 
 首先，有一天我想创建一个应用程序。 产生这种愿望的原因是我喜欢阅读，但是在广阔的俄罗斯互联网中根本没有任何普通的图书汇总商。 实际上，由于不费吹灰之力来寻找要阅读的东西并试图回忆起我最近读过的书的名称以及我停在哪一章，因此诞生了创建所有这样的Web应用程序的愿望，该应用程序将使这一切变得可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在云端使用自动更新的SSL托管Node.js https服务器，以及如何设置开发周期（+ git，react）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439952/"><h2> 前言 </h2><br> 首先，有一天我想创建一个应用程序。 产生这种愿望的原因是我喜欢阅读，但是在广阔的俄罗斯互联网中根本没有任何普通的图书汇总商。 实际上，由于不费吹灰之力来寻找要阅读的东西并试图回忆起我最近读过的书的名称以及我停在哪一章，因此诞生了创建所有这样的Web应用程序的愿望，该应用程序将使这一切变得可能且方便。 值得注意的是，没有开发，编程等方面的经验。 我没有，我的工作根本与此无关。 然而，欲望克服了懒惰，成长为具体的行为，是一种爱好。 <br><br> 我不会告诉我如何学习javascript，node.js，react，html，css等。我们将继续介绍目前所学的内容，我想与您分享的内容，当然，还要听听对专家的建设性批评。 <br><br> 像许多人一样，我在自己的本地主机上的PC上进行了培训：3000，创建了前端/后端，进行了排版，使用了api等，但是我一直担心如何将所有这些信息稍后转移到托管？ 能行吗 因此是否需要重写代码？  <b>最重要的是，是否可以配置所有内容，以便我可以从任何PC上处理该应用程序，并轻松将所有内容转移到生产环境中？</b>  <b>我将讨论这个。</b> <br><a name="habracut"></a><br><h2> 托管选择 </h2><br> 对于我的业余爱好，我准备每月花费10美元，因此我选择了将来打算使用的主机。 正如我所说，在此之前，我有0点经验，包括网站托管。 我尝试并拒绝了以下内容： <br><br>  <b>Jelastic</b> ：美观和用户友好的界面，一切似乎都是直观，可扩展且易于理解的。 但是，我在设置时遇到了困难（nginx由于某种原因不想从vps上工作，只能使用其单独的模块），并且通过标准方式将SSL（和自动更新）连接到俄语域（他们答应修复该错误，但我不想等待） <br><br>  <b>云托管REG.RU</b> ：我在那里也有一个域，因此该解决方案似乎合乎逻辑，但是他们没有分别配置PostgreSQL，并且由于我不想与数据库管理部门联系，所以我开始进行进一步的研究。 <br><br>  <b>AWS和Google云</b> ：我尝试过，一切似乎都很好，但是我记得我们的“奇妙”法律以及将用户数据放在俄罗斯联邦服务器上的要求。 不幸的是，这些家伙在俄罗斯联邦没有服务器。 不是律师，而是出于罪恶，决定在俄罗斯联邦寻找带有服务器的云。  <b>如果您的应用不太可能出现法律问题，那么一个不错的选择。</b> <br><br> 尽管俄罗斯联邦的服务器上有云，但我仍然希望有一些东西可以使我免于不得不投入PostgreSQL管理。 不久前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Yandex</a>出现了这种冲动。我尝试了一下可用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">云</a> ，似乎一切都很简单方便，所以我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">暂时</a>停下来了。 值得注意的是PostgreSQL托管立即提供1core和4GB的RAM，每月花费约2k卢布，因此，在开发和低负载的时候，我计划在VPS上运行PostgreSQL〜300r，并以增加的负载转移数据库， Yandex从事管理和更新。 <br><br><h2> 设置Yandex.Cloud </h2><br><h3> 虚拟私有云 </h3><br>  1）为您的站点创建一个目录： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35e/3de/581/35e3de5819d0344d34cc9a03251cbf65.png" alt="图片"><br><br>  2）创建一个虚拟私有云： <br><br> 他在当前阶段给我的主要内容是从外部访问创建的资源的IP。 我初步了解了子网，区域，隔离和容错功能，如有必要，我会赶上来。 <br><br>  3）创建一个子网并为其分配一个内部IP（据我所知，它就像一个本地网络） <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f25/42d/f6c/f2542df6c7141d6e96738f6f1d3e6cf1.png" alt="图片"><br><br>  4）转到IP选项卡并为自己保留一个静态IP。 <br><br> 在它上面，我们将在家和其他地方连接。 您可能可以使用动态，但我不知道它在什么情况下会更改。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47c/ef6/265/47cef626515785d83ba86cb6f5f8c185.png" alt="图片"><br><br><h3> 计算云 </h3><br> 在这里，我们将进行计算：)也就是说，我们将使用Linux创建虚拟机（我选择ubuntu 18.04），安装node.js应用程序和postgreSQL。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/265/293/e0c/265293e0c462dd9dd2452874799c2157.png" alt="图片"><br><br> 我们单击以创建一个VM，将所有设置最小化，因为在开发过程中将没有负载（当我们发布应用程序时，再扭曲一点，好了，我们将通过图形进行监视）。 <br><br><h4>  SSH </h4><br> 我在此阶段遇到的问题点是SSH： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/687/476/389/68747638934544e751f6a0b21f43e683.png" alt="图片"><br><br> 那是什么，为什么我不知道，所以我去学习。 事实证明，这只是一种访问方法，不是通过密码，而是通过生成的SSH密钥。 要实际生成它，请按照我们的建议下载并安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Putty</a> 。 <br><br> 运行C：\ Program Files \ PuTTY \ puttygen.exe <br><br><img src="https://habrastorage.org/getpro/habr/post_images/333/03a/e02/33303ae02d9b14983cf0627087dfd8ee.png" alt="图片"><br><br> 我们按下“生成”按钮并移动鼠标以使生成的键具有随机性（据我所知）。 接下来，将以ssh-rsa开头的行复制到文本文件中的某处，然后单击“保存私钥”，“保存公钥”。 复制到文本文件的密钥将插入到Yandex Yandex页面的密钥的SSH字段中。 我们将root指定为登录名，否则您将无法使用将要从home / work连接到云的应用程序的图形文件系统时进行访问（也许有办法，但我不明白）。 <br>  <b>正如Andreymal所指出的那样，最好不要使用root，这样中国的bot才不可以获取您的云密码，但是由于Yandex.cloud仅具有SSH访问权限，因此您可以这样生活。</b> <b><br><br></b>  <b>主机上的应用程序应专门由非root用户启动，以免攻击者通过应用程序中的漏洞执行恶意代码。</b> <b><br></b> <br><br><h3> 我们从PC连接到云，然后选择一个免费的SSH客户端 </h3><br> 标准的Putty仅允许您在命令行上工作，并且由于我对Windows用户不熟悉，因此我开始寻找带有伪资源管理器的客户端。 最初，我尝试使用Mobaxterm，但是在一段时间不活动之后，它关闭了，资源管理器完全冻结，所以现在我正在使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bitvise ssh</a> ，到目前为止，我还没有看到Mobaxterm这样的问题。 <br><br><h3> 配置bitvise ssh </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a2/019/f4c/8a2019f4cafa7b44ef72286664175010.png" alt="图片"><br><br> 在“服务器”&gt;“主机”字段中，指示我们的外部IP云。 端口22。单击“客户端密钥管理器”&gt;“导入”，然后在其中指定先前生成的私钥。 您可能仍然需要一个关键词，选择一些您不会忘记的东西。 关闭此窗口并在身份验证字段中指定用户名：root，方法publick密钥，客户端密钥-选择先前导入的密钥。 单击登录，如果我们一切正确，则连接到云： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4b/e6a/a9d/b4be6aa9df15651829c0b23749f18b41.png" alt="图片"><br><br><h2> 安装Node.js </h2><br> 在这里，我建议您使用digitalocean.com上的说明，该说明非常详细，许多使用俄语。 通常我会在Google上搜索“ digitalocean ubuntu 18.04 node.js”或您要在此处安装或配置的任何文件。 <br><br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>阅读如何安装Node.js。 <br><br> 简而言之，我们转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nodesource</a> （可以在此处安装最新版本的node.js），在此处进行以下操作： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/aa7/0c9/3adaa70c90a1466c1a55b71eb25f2105.png" alt="图片"><br><br> 依次复制并运行命令： <br><br><pre><code class="javascript hljs">curl -sL https:<span class="hljs-comment"><span class="hljs-comment">//deb.nodesource.com/setup_11.x | sudo -E bash - sudo apt-get install -y nodejs</span></span></code> </pre> <br> 我们检查团队如何建立它 <br><br><pre> <code class="javascript hljs">nodejs -v</code> </pre> <br> 我们将看到node.js的版本 <br><br><pre> <code class="javascript hljs">npm -v</code> </pre> <br> 我们将显示node.js的软件包管理器的版本。 <br><br> 接下来，转到/ opt / mysuperapp文件夹（my_super_app_name-您必须创建此文件夹）。 长时间搜索“将应用程序的node.js文件放入ubuntu适当的位置”之后，选择opt目录作为应用程序的位置。 <br><br> 最后，创建server.js文件，它将是应用程序的入口，然后将简单的服务器代码粘贴到node.js上： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hostname = <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> { res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>; res.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>); res.end(<span class="hljs-string"><span class="hljs-string">'Hello World!\n'</span></span>); }); server.listen(port, hostname, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server running at http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hostname}</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">/`</span></span>); });</code> </pre> <br> 端口80用于http请求，端口443用于https。 虽然我们在http上有一个服务器。 <br><br> 我们保存所有内容并运行命令： <br><br><pre> <code class="plaintext hljs">node server.js</code> </pre> <br> 控制台应显示“服务器在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本地主机上</a>运行的服务器：80 /”行 <br><br> 现在，您可以打开浏览器，输入一个外部IP（您的ubuntu VM的Yandex云中的一个），我们将看到“ Hello World！”。 <br><br><h2> 我们使用git方便地完成所有工作或开发周期 </h2><br> 一切似乎都可以正常工作，但是我们不会一直连接到云。 而且，突然之间，我们将来不会独自工作。 <br><br><h2>  Github </h2><br>  Github是我们应用程序代码所在的地方。 简而言之，一个人的工作原则如下： <br><br><ul><li> 我们正在家用PC上开发应用程序。 </li><li> 一键保存并在Github上卸载代码。 </li><li> 在托管或另一台PC上，从github下载我们的应用程序，重新启动服务器（如果正在托管），那么我们的Web应用程序的新版本可以在万维网上找到。 </li></ul><br> 一切都是快速，简单和方便的。 <br><br> 实际在Github上注册并为我们的应用程序创建一个私有存储库（该存储库仅对我们可用）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a10/e93/4b3/a10e934b3516444c1c8aad1b45035494.png" alt="图片"><br><br> 复制<a href="">github.com/ReTWi/mysuperapp.git</a>行以下载该应用程序。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/959/824/4659598241a27171fbbaa8e61c3a66c2.png" alt="图片"><br><br><ol><li> 我们返回bitvise命令行，按ctrl + c停止应用程序（如果仍然有效）。 </li><li> 转到/ opt目录，并使用我们创建的应用程序删除该文件夹 </li></ol><br> 我们将使用Git将应用程序上传到github，然后从那里上传到托管或其他PC。  Git是一个单独的讨论主题，所以现在让我们开始讨论。 <br> 使用以下命令<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在主机上</a>安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">git</a> ： <br><br><pre> <code class="javascript hljs">sudo apt update sudo apt install git</code> </pre> <br> 检查一切是否成立： <br><br><pre> <code class="javascript hljs">git --version</code> </pre> <br>  git版本应该出现。 <br><br> 我们填写git数据（我不明白为什么，但是显然可能会有一些无聊的警告）。 <br><br><pre> <code class="javascript hljs">git config --global user.name <span class="hljs-string"><span class="hljs-string">"Your Name"</span></span> git config --global user.email <span class="hljs-string"><span class="hljs-string">"youremail@domain.com"</span></span></code> </pre> <br> 最后，我们使用以下命令将应用程序上载到主机： <br>  （应该有到您的应用程序的链接） <br><br><pre> <code class="javascript hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/ReTWi/mysuperapp.git</span></span></code> </pre> <br> 一个新的mysuperapp将出现在/ opt目录中，该文件是从github下载的应用程序文件所在的位置。 <br><br> 现在是时候对PC重复相同的操作并关闭PC链了（不同）-&gt; Github-&gt;托管 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在PC上</a>安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">node.js。</a> <br><br><h2>  Visual Studio代码 </h2><br> 首先，选择我们将在其中工作的源代码编辑器。 我选择了Visual Studio代码，因此它简单，方便，具有许多插件，并且如果您使用多个设备，则可以配置设置的同步。 实际上，我们下载，安装，启动并选择共享的应用程序文件夹，因为git clone将为我们创建自己的文件夹。 <br><br> 我使用的插件如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e5/5c2/17f/7e55c217f685490573a70f44970e0780.png" alt="图片"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为PC安装git</a> 。 <br> 使用ctrl + shift +`or terminal&gt; new terminal在VScode中打开一个控制台 <br><br>  <i>撤退：</i> <i><br><br></i>  <i>在Windows控制台中，俄语字符不好用，因此无需打开文件&gt;首选项&gt;设置，在字段中输入terminal.integrated.shellArgs.windows，然后单击</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/787/6a5/a707876a56e4c0a2b601358d4aa7caf1.png" alt="图片"><br><br></i>  <i>并添加“ terminal.integrated.shellArgs.windows”行：[“ -NoExit”，“ / c”，“ chcp 65001”]，</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/57d/217/da6/57d217da62d4189b8640eb854f07a8a0.png" alt="图片"></i> <br><br> 重复命令以从github下载文件： <br><br><pre> <code class="javascript hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/ReTWi/mysuperapp.git</span></span></code> </pre> <br> 在VScode中，单击文件&gt;打开文件夹，然后打开我们应用程序的文件夹。 <br><br> 使用相同的简单服务器代码创建server.js文件： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hostname = <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> { res.statusCode = <span class="hljs-number"><span class="hljs-number">200</span></span>; res.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>); res.end(<span class="hljs-string"><span class="hljs-string">'Hello World!\n'</span></span>); }); server.listen(port, hostname, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server running at http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hostname}</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">/`</span></span>); });</code> </pre> <br> 安装nodemon以在对代码进行更改时自动重新启动服务器： <br><br><pre> <code class="javascript hljs">npm i nodemon -g</code> </pre> <br>  i-安装简称 <br>  g-全局安装（可在控制台中使用），而不仅仅是我们的应用程序。 <br><br> 运行命令： <br><br><pre> <code class="javascript hljs">nodemon server.js</code> </pre> <br> 在浏览器中打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">localhost</a> ：80 /或仅在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">localhost</a> ：80中打开Hello World。 <br><br> 现在是时候查看我们的PC链&gt; Github&gt;托管了。 <br><br> 下载Github桌面以获得更大的便利，连接您的github帐户，然后单击添加本地存储库文件并指定我们的应用程序的目录。 <br><br> 在应用程序中，我们看到与从Github下载的版本（我们添加了server.js）相比所做的更改： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/568/3d0/52b/5683d052b9fbba8fe609035fd8ba253f.png" alt="图片"><br><br> 单击“提交到母版”&gt;“推送原点”，从而将文件从PC下载到Github。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eeb/234/bf6/eeb234bf61a0ed5b2708b196e32da7d8.png" alt="图片"><br><br> 我们在浏览器中转到我们的github帐户，并查看下载的server.js文件： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e6/cf8/e1b/1e6cf8e1b08c5a15d596193dd8b0efb3.png" alt="图片"><br><br> 让我们多做一些练习，在VScode中，我们替换行“ res.end（'Hello World！\ N'）;” 改为“ res.end（'OmNomNom'）;”。 我们将看到服务器本身重新启动： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/8cc/a53/8c88cca53e4d8d15632cc49e183817e7.png" alt="图片"><br><br> 我们将在浏览器中签到，然后在此处查看我们“ OmNomNom”所做的更改。 <br><br> 桌面github也将向我们展示我们已更改了这一行： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/020/39b/7a0/02039b7a00fabe3c07037f6a356c1919.png" alt="图片"><br><br> 再次，单击提交给master&gt; push origin将文件发送到github。 <br><br> 切换到托管命令行。 <br><br> 如果应用程序仍在运行（ctrl + c），我们将停止它。 <br><br> 使用以下命令下载我们更新的应用程序： <br><br><pre> <code class="javascript hljs">git config credential.helper store git pull</code> </pre><br> 第一个将保存我们的数据，这样您就不必不断输入用户名和密码。 将来，git pull对我们来说足够了。 <br><br> 安装pm2-与nodemon类似，仅用于托管： <br><br><pre> <code class="javascript hljs">npm i pm2 -g</code> </pre> <br> 让我们使用pm2启动应用程序，它将通过托管上的下一个git pull重新启动服务器： <br><br><pre> <code class="javascript hljs">pm2 start server.js --watch</code> </pre> <br> 在我们的外部IP云上打开浏览器，然后查看“ OmNomNom”。 <br><br> 因此，我们关闭了应用程序及其在主机上的快速部署的工作链。 <br><br><h2> 我们在本地主机和主机上为HTTPS创建临时SSL证书 </h2><br> 我们转到网站<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">zerossl.com</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/be3/00c/151be300c4226e87b30b7f4735e09c83.png" alt="图片"><br><br> 在域ip ...字段中，首先输入localhost，单击生成并通过按钮下载2个文件： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a1/b4d/24a/8a1b4d24a65f44c3ba5a604a569e1811.png" alt="图片"><br><br> 我们将它们保存在ssl / localhost文件夹中的项目中。 <br><br> 对外部IP云重复此过程，并将其保存在ssl / myapp中。 <br><br><h2> 启动更复杂的https服务器node.js </h2><br> 应用结构： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/330/6da/e58/3306dae5836d651136b030b2cc64041e.png" alt="图片"><br><br><ul><li> 客户-我们的前端就在这里。 我有反应 </li><li> 日志-托管日志将在此处删除 </li><li>  node_modules-node.js模块 </li><li> 私人-您的私人文件，我将SSH访问存储在此处 </li><li> 服务器是您的后端 </li><li>  ssl-用于在本地主机和主机上运行https的ssl证书 </li><li>  .babelrc-webpack'om应用程序响应构建设置（允许您在开发前端时使用更现代的JS） </li><li>  .gitignore-不会移动到github的文件（git似乎看不到它们） </li><li>  client.js-生成反应汇编的入口点 </li><li>  package.json-您正在使用的node_modeles和各种命令摘要。 </li><li>  package-lock.json-模块中的更改（据我所知，该文件将检查主机和PC上是否安装了相同的模块）。 </li><li>  pm2-watch.json-托管的pm2启动设置 </li><li>  README.md-github的封面 </li><li>  server.js-后端Node.js服务器的起点 </li><li>  webpack.config.js-反应构建配置 </li></ul><br><h3>  .gitignore </h3><br> 在这里，我们指出了我们不想上传到github的文件/文件夹。 他们只会在此设备上，而git不会跟踪/显示他们的更改。 打开并插入： <br><br><pre> <code class="javascript hljs">/node_modules/ <span class="hljs-regexp"><span class="hljs-regexp">/logs/</span></span>* # exception to the rule !logs/.gitkeep /public/react_bundle.js /public/isProd.js</code> </pre> <br> 由于github不会卸载空文件夹，因此您可以在其中放入一些东西，例如，空的.gitkeep文件。 保存文件并关闭。 <br><br><h3>  package.json </h3><br> 打开并粘贴以下内容（在//添加注释之后） <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"myapp"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    "version": "1.0.0", "description": "OmNomNom", "main": "server.js", "scripts": { "server": "pm2 start pm2-watch.json", //  npm run server     "client": "webpack -w --mode development", //  npm client    .        ,   . "client-prod": "webpack --mode production", //     production "client-analyze": "webpack --mode production --analyze true" //     production       .    }, "repository": { "type": "git", "url": "git+https://github.com/myapp/knigam.git" //     github }, "author": "rtw", "license": "UNLICENSED", //     ( ) "bugs": { "url": https://github.com/myapp/knigam.git" }, "homepage": "https://github.com/myapp/knigam.git#readme", "dependencies": { "@babel/core": "^7.2.2", //  js  frontend "@babel/plugin-transform-runtime": "^7.2.0", //  js  frontend "@babel/preset-env": "^7.3.1", //  js  frontend "@babel/preset-react": "^7.0.0", //  js  frontend "ajv": "^6.8.1", //    "babel-loader": "^8.0.5", //  js  frontend "babel-plugin-styled-components": "^1.10.0", //   styled-components "css-loader": "^2.1.0", //   webpack'om css "fastify": "^2.0.0-rc.6", //  express,      "fastify-cookie": "^2.1.6", //    "fastify-static": "^2.2.0", //     "moment": "^2.24.0", //    "pg": "^7.8.0", //    "pino": "^5.11.1", //   postgreSQL  node.js "pino-pretty": "^2.5.0", //     "react": "^16.8.1", // Frontend .      Vue.js,    .      ,     "react-dom": "^16.8.1", // React     "style-loader": "^0.23.1", //   webpack'om ,    "styled-components": "^4.1.3", // CSS in JS,           "webpack": "^4.29.3", //    "webpack-bundle-analyzer": "^3.0.3", //       "webpack-cli": "^3.2.3" //    ,     } }</span></span></code> </pre><br> 我将重点介绍为应用程序选择的两个主要框架/库： <br> 选择Fastify作为Express.js的替代产品，因为第一个已经对htpp2提供了实验性支持，因此它正在积极开发中，在我看来，它比Express.js拥有更多的前途，后者已经变得非常缓慢并且正在以某种方式开发。 另一方面，express.js已经使用了很长时间，您可以更轻松地找到有关它的信息。 <br><br> 之所以选择React，是因为它让我更轻松地使用它，自己理解和尝试一切。  Vue-似乎有自己的规则和方向。 尽管在Vue中可能需要用自己的双手少写一些东西，但是由于训练的重点是优先级高，并且对于以前没有编程的人来说，做出反应要容易些。 <br><br> 我们保存package.json文件，并使用以下命令安装在依赖项中指定的所有模块： <br><br><pre> <code class="javascript hljs">npm i</code> </pre> <br> 我们将有一个node_modules文件夹，其中将包含我们应用程序的所有模块。 <br><br> 客户端-空文件夹 <br>  logs-.gitkeep文件位于其中，因此该文件夹迁移到托管，并且日志成功落入该位置。 在开发过程中，我们会将所有内容输出到控制台。 <br><br><h3> 公开的 </h3><br> 我们网站的静态文件将位于此处，其中包含图片，网站图标等。 <br> 让我们关注两个文件： <br>  index.html： <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;base href="/" /&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;MyApp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="cookies"&gt;    react_bundle   &lt;/div&gt; &lt;noscript &gt;:       Javscript&lt;/noscript &gt; &lt;script src="react_bundle.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br>  -在这里，我们加载了一个反应前端，并通过其ID呈现到标签中。 <br><br>  isProd.js包含一行“ module.exports = false” <br> 由于它在.gitignore异常中，因此不可移植。 因此，我们在PC上将其设置为false，在主机上将其设置为true。 然后，我们使用此文件来了解我们当前所处的环境（开发/生产）。 在我看来，这似乎是最方便的，此外，您可以在开发过程中部分更改代码并检查生产中模块的运行情况。 <br><br>  ssl-本地主机和myapp文件夹中以前保存了证书 <br><br><h3>  .babelrc </h3><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"presets"</span></span>: [ [ <span class="hljs-string"><span class="hljs-string">"@babel/preset-env"</span></span>, { <span class="hljs-string"><span class="hljs-string">"targets"</span></span>: { <span class="hljs-string"><span class="hljs-string">"browsers"</span></span>: [<span class="hljs-string"><span class="hljs-string">"&gt;0.25%"</span></span>, <span class="hljs-string"><span class="hljs-string">"not ie 11"</span></span>, <span class="hljs-string"><span class="hljs-string">"not op_mini all"</span></span>] } } ], <span class="hljs-string"><span class="hljs-string">"@babel/preset-react"</span></span> ], <span class="hljs-string"><span class="hljs-string">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"babel-plugin-styled-components"</span></span>, <span class="hljs-string"><span class="hljs-string">"@babel/plugin-transform-runtime"</span></span> ] }</code> </pre><br> 超过0.25％的用户使用用于创建具有浏览器支持的react_bundle的设置。 <br><br><h3>  client.js </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { render } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span> render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">!!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'cookies'</span></span>))</code> </pre> <br><br> 使用Cookie标签在div中渲染前端。 <br><br>  pm2-watch.json-允许您在主机上使用“ npm run server”命令运行服务器，并跟踪代码中的更改并自动重新引导。 <br><br><h3>  webpack.config.js </h3><br> 反应堆应用程序生成器： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webpack = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack'</span></span>), path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>), BundleAnalyzerPlugin = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-bundle-analyzer'</span></span>).BundleAnalyzerPlugin <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, argv</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prod = argv.mode == <span class="hljs-string"><span class="hljs-string">'production'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config = { <span class="hljs-attr"><span class="hljs-attr">entry</span></span>: <span class="hljs-string"><span class="hljs-string">'./client.js'</span></span>, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'./public'</span></span>), <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'react_bundle.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.(js|jsx)$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">exclude</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/node_modules/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'babel-loader'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [<span class="hljs-string"><span class="hljs-string">'style-loader'</span></span>, <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>] } ] }, <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: { <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: { <span class="hljs-attr"><span class="hljs-attr">client</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'./client/shared'</span></span>), <span class="hljs-attr"><span class="hljs-attr">public</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'./public'</span></span>) } }, <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ argv.analyze ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BundleAnalyzerPlugin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, prod ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.optimize.AggressiveMergingPlugin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.ContextReplacementPlugin(<span class="hljs-regexp"><span class="hljs-regexp">/moment[\/\\]locale$/</span></span>, /ru/) ].filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>), <span class="hljs-attr"><span class="hljs-attr">optimization</span></span>: { <span class="hljs-attr"><span class="hljs-attr">minimize</span></span>: prod ? <span class="hljs-literal"><span class="hljs-literal">true</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">performance</span></span>: { <span class="hljs-attr"><span class="hljs-attr">hints</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config }</code> </pre><br> 简而言之，他打开client.js文件及其内部的所有内容，收集react_bundle并将其放置在公用文件夹中，从该文件夹中通过打开的index.html对其进行加载。 <br><br><h3>  server.js </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isProd = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./public/isProd'</span></span>), fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>), log = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./server/logger'</span></span>), path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   node.js,      process.on('unhandledRejection', (reason, promise) =&gt; { log.error({ reason, promise }, '  unhandledRejection') }) process.on('uncaughtException', err =&gt; { log.error({ err }, '  uncaughtException') }) // Redirect server from http port 80 to https 443 const fastifyHttp = require('fastify')({ logger: log, ignoreTrailingSlash: true }) fastifyHttp.listen(80, '::', (err, address) =&gt; { if (err) { log.error({ err, address }, '   HTTP ') } else { log.warn('Http c ') } }) // Let's Encrypt challenge fastifyHttp.get('/.well-known/acme-challenge/:file', (req, res) =&gt; { let stream = fs.createReadStream( path.join(__dirname + '/ssl/.well-known/acme-challenge/' + req.params.file) ) res.type('text/html').send(stream) }) fastifyHttp.get('/*', (req, res) =&gt; { res.redirect(301, 'https://' + req.headers.host + req.raw.url) }) fastifyHttp.get('/', (req, res) =&gt; { res.redirect(301, 'https://' + req.headers.host + req.raw.url) }) //  let fastifyOptions = { logger: log, ignoreTrailingSlash: true, http2: true } fastifyOptions.https = isProd ? { allowHTTP1: true, key: fs.readFileSync('./ssl/myapp/key.txt'), cert: fs.readFileSync('./ssl/myapp/crt.txt') } : { allowHTTP1: true, key: fs.readFileSync('./ssl/localhost/cert.key'), cert: fs.readFileSync('./ssl/localhost/cert.pem') } const fastify = require('fastify')(fastifyOptions) fastify.listen(443, '::', (err, address) =&gt; { if (err) { log.error({ err, address }, '   ') } else { log.warn( `   ${ isProd ? '' : ' ' }` ) } }) //  fastify.setSchemaCompiler(schema =&gt; { return ajv.compile(schema) }) //  fastify fastify.setErrorHandler((err, req, res) =&gt; { log.error({ err, req }, 'fastify errorHandler') //     if (err.validation) { return res.send({ error: '   ' }) } else { return res.send({ error: ' errorHandler' }) } }) //   fastify.register(require('fastify-static'), { root: path.join(__dirname, './public') }) //  fastify.register(require('fastify-cookie'), err =&gt; { if (err) log.error({ err }, 'fastify-cookie') }) //       /   //       index.html,     //        api,   GET /api/userdata fastify.setNotFoundHandler((req, res) =&gt; { res.sendFile('index.html') }) // Routes fastify.register( async openRoutes =&gt; { //    openRoutes.register(require('./server/api/open')) openRoutes.register(async withSession =&gt; { //         //    , : ///withSession.addHook('preHandler', async (req, res) =&gt; { // if (!(await sessionManagerIsOk(req, res))) return // }) withSession.register(require('./server/api/with_session')) }) }, { prefix: '/api' } //    )</span></span></code> </pre><br><h3> 服务器文件夹 </h3><br> 后端和所有方式都在这里。 <br>  logger.js-根据环境的不同，isProd会记录到控制台或错误日志中。 <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pino = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pino'</span></span>), isProd = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../public/isProd'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logOptions = isProd ? { <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'warn'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   timestamp: () =&gt; { return ',"time":"' + new Date() + '"' } } : { level: 'warn', prettifier: require('pino-pretty'), prettyPrint: { levelFirst: true, translateTime: true } } let dest = isProd ? pino.destination('./logs/errors.log') : pino.destination(1) let log = pino(logOptions, dest) module.exports = log</span></span></code> </pre><br> 服务器/ API / <br>  open.js-在此处添加我们的路径。 <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastify, options, next</span></span></span><span class="hljs-function">) </span></span>{ fastify.route({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'api / route'</span></span>) } }) fastify.route({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/hi'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'api / route hi'</span></span>) } }) next() }</code> </pre> <br> 在Localhost上设置并检查所有内容之后，我们只需将所有内容上传到github，然后从git pull到托管。 在托管上需要做的所有事情就是使用“ npm i”命令安装node.js模块并创建isProd.js文件。 <br><br><h2>  SSL自动更新 </h2><br> 当您购买域名并将其绑定到IP云时，这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是REG.RU</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明示例</a> ，您可以在服务器上安装自动更新的免费SSL，以使站点可以通过https工作。 <br><br> 我们的服务器在没有nginx的情况下可以工作。 将来我们可能会需要它作为负载均衡器或速度更快的HTTP服务器来分发静态文件，但到目前为止，我仍然没有必要。 我们还不需要负​​载平衡，但是我还没有发现关于静态分布速度的比较。 <br><br> 在ssl文件夹中进行安装之前，请创建.well-known文件夹，并在其中进行acme-challenge。 原来/ opt / myapp / ssl /。众所周知/ acme挑战 <br><br> 要在没有nginx的具有node.js的服务器上安装自动更新的SSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，请单击链接</a> 。 依次在托管控制台中执行命令： <br><br><pre> <code class="javascript hljs">sudo apt-get update sudo apt-get install software-properties-common sudo add-apt-repository universe sudo add-apt-repository ppa:certbot/certbot sudo apt-get update sudo apt-get install certbot sudo certbot certonly</code> </pre><br> 我们选择第二种验证方法，该方法会将特定文件放在/opt/myapp/ssl/.well-known/acme-challenge文件夹中，并在确认服务器所有者后将其删除。 <br><br> 我们根据请求指示我们的域，例如：“ example.com”和应用程序的ssl文件夹的路径（服务器已配置为可以提供由bot创建的文件）“ / opt / myapp / ssl”。 <br><br> 僵尸程序会将cron任务本身配置为在证书过期90天内更新证书。 <br><br> 我认为不需要花太多时间来编写所有内容，到凌晨4点，我可能已经错过了一些东西：/ <br><br> 掌握了此画布或阅读了一些个人观点的哈布拉人和专家的观点很有趣。 您的开发周期如何安排？ 有什么地方我会误会或做错事吗？ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439952/">https://habr.com/ru/post/zh-CN439952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439942/index.html">Docker：每个.Net开发人员需要了解的内容</a></li>
<li><a href="../zh-CN439944/index.html">用于假人的SAPUI5第5部分：完整的分步练习</a></li>
<li><a href="../zh-CN439946/index.html">我们为什么选择电子</a></li>
<li><a href="../zh-CN439948/index.html">英特尔SVT-AV1：重型开源AV1编码器</a></li>
<li><a href="../zh-CN439950/index.html">第三届图灵测试：获奖者的参与条件和奖品</a></li>
<li><a href="../zh-CN439958/index.html">CodeFest X 3月30日至31日。 未来科</a></li>
<li><a href="../zh-CN439962/index.html">我们与Atlassian服务台合作，从Riada Insight插件中获得最大收益-Atlassian用户组会议的报告</a></li>
<li><a href="../zh-CN439964/index.html">Runc CVE-2019-5736主机中的漏洞</a></li>
<li><a href="../zh-CN439966/index.html">用于算术运算的简单解析器</a></li>
<li><a href="../zh-CN439968/index.html">生成空间和机会空间</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>