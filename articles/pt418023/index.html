<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèè üåí üå®Ô∏è Ponteiros em C s√£o mais abstratos do que voc√™ imagina üï∑Ô∏è üë±üèø üå©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O ponteiro refere - se a uma c√©lula de mem√≥ria e desreferenciar um ponteiro significa ler o valor da c√©lula especificada. O valor do ponteiro em si √© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ponteiros em C s√£o mais abstratos do que voc√™ imagina</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  O ponteiro <i>refere</i> - <i>se</i> a uma c√©lula de mem√≥ria e <i>desreferenciar um</i> ponteiro significa ler o valor da c√©lula especificada.  O valor do ponteiro em si √© o endere√ßo da c√©lula de mem√≥ria.  O padr√£o da linguagem C n√£o especifica o formul√°rio para representar os endere√ßos de mem√≥ria.  Este √© um ponto muito importante, pois diferentes arquiteturas podem usar diferentes modelos de endere√ßamento.  A maioria das arquiteturas modernas usa espa√ßo de endere√ßo linear ou similar.  No entanto, mesmo essa quest√£o n√£o √© especificada estritamente, pois os endere√ßos podem ser f√≠sicos ou virtuais.  Algumas arquiteturas usam uma representa√ß√£o n√£o num√©rica.  Portanto, o Symbolics Lisp Machine opera com tuplas do formul√°rio <i>(objeto, deslocamento)</i> como endere√ßos. <br><a name="habracut"></a><table><tbody><tr><td>  Algum tempo depois, ap√≥s a publica√ß√£o da tradu√ß√£o em Habr√©, o autor fez grandes modifica√ß√µes no texto do artigo.  Atualizar uma tradu√ß√£o no Habr√© n√£o √© uma boa ideia, pois alguns coment√°rios perdem o significado ou ficam fora de lugar.  N√£o quero publicar o texto como um novo artigo.  Portanto, acabamos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atualizar a tradu√ß√£o do artigo</a> no viva64.com, e aqui deixamos tudo como est√°.  Se voc√™ √© um novo leitor, sugiro que leia uma tradu√ß√£o mais recente em nosso site, clicando no link acima. </td></tr></tbody></table><br>  O padr√£o n√£o estipula a forma de apresenta√ß√£o dos ponteiros, mas estipula - em maior ou menor grau - as opera√ß√µes com eles.  Abaixo, consideramos essas opera√ß√µes e os recursos de sua defini√ß√£o no padr√£o.  Vamos come√ßar com o seguinte exemplo: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Se compilarmos esse c√≥digo GCC com o n√≠vel de otimiza√ß√£o 1 e executarmos o programa no Linux x86-64, ele imprimir√° o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Observe que os ponteiros <i>peq se</i> referem ao mesmo endere√ßo.  No entanto, o resultado da express√£o <i>p == q</i> √© <i>falso</i> , e isso √† primeira vista parece estranho.  Dois ponteiros para o mesmo endere√ßo n√£o devem ser iguais? <br><br>  Veja como o padr√£o C define o resultado da verifica√ß√£o de dois ponteiros quanto √† igualdade: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.9, n.o 6</b> <br><br>  Dois ponteiros s√£o iguais se, e somente se, ambos s√£o zero, apontam para o mesmo objeto (incluindo um ponteiro para o objeto e o primeiro subobjeto no objeto) ou uma fun√ß√£o, ou apontam para a posi√ß√£o ap√≥s o √∫ltimo elemento da matriz ou um ponteiro refere-se √† posi√ß√£o ap√≥s o √∫ltimo elemento da matriz e a outra refere-se ao in√≠cio de outra matriz imediatamente ap√≥s a primeira no mesmo espa√ßo de endere√ßo. </td></tr></tbody></table><br>  Antes de tudo, surge a pergunta: o que √© um "objeto <i>"</i> ?  Como estamos falando da linguagem C, √© √≥bvio que aqui os objetos n√£o t√™m nada a ver com objetos nas linguagens OOP como C ++.  No padr√£o C, esse conceito n√£o est√° completamente definido: <br><table><tbody><tr><td>  <b>C11 ¬ß 3.15</b> <br><br>  Um objeto √© uma √°rea de armazenamento de tempo de execu√ß√£o cujo conte√∫do pode ser usado para representar valores <br><br>  NOTA Quando mencionado, um objeto pode ser considerado como tendo um tipo espec√≠fico;  ver 6.3.2.1. </td></tr></tbody></table><br>  Vamos acertar.  Uma vari√°vel inteira de 16 bits √© um conjunto de dados na mem√≥ria que pode representar valores inteiros de 16 bits.  Portanto, essa vari√°vel √© um objeto.  Dois ponteiros ser√£o iguais se um deles se referir ao primeiro byte de um n√∫mero inteiro e o segundo ao segundo byte do mesmo n√∫mero?  O comit√™ de padroniza√ß√£o de idiomas, √© claro, n√£o quis dizer isso.  Mas aqui deve-se notar que, a esse respeito, ele n√£o tem explica√ß√µes claras e somos for√ßados a adivinhar o que realmente significava. <br><br><h3>  Quando o compilador atrapalha </h3><br>  Vamos voltar ao nosso primeiro exemplo.  O ponteiro <i>p √©</i> obtido no objeto <i>ae o</i> ponteiro <i>q</i> √© do objeto <i>b</i> .  No segundo caso, a aritm√©tica do endere√ßo √© usada, definida para os operadores de mais e menos da seguinte maneira: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6, cl√°usula 7</b> <br><br>  Quando usado com esses operadores, um ponteiro para um objeto que n√£o √© um elemento da matriz se comporta como um ponteiro para o in√≠cio de uma matriz com o comprimento de um elemento, cujo tipo corresponde ao tipo do objeto original. </td></tr></tbody></table><br>  Como qualquer ponteiro para um objeto que n√£o seja uma matriz <i>realmente</i> se torna um ponteiro para uma matriz com o comprimento de um elemento, o padr√£o define a aritm√©tica do endere√ßo apenas para ponteiros para matrizes - esse √© o ponto 8. Estamos interessados ‚Äã‚Äãna seguinte parte: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6, cl√°usula 8</b> <br><br>  Se uma express√£o inteira for adicionada ou subtra√≠da do ponteiro, o ponteiro resultante ser√° do mesmo tipo que o ponteiro original.  Se o ponteiro de origem se referir a um elemento da matriz e a matriz tiver comprimento suficiente, a fonte e os elementos resultantes ser√£o separados um do outro, para que a diferen√ßa entre seus √≠ndices seja igual ao valor da express√£o inteira.  Em outras palavras, se a express√£o <i>P</i> apontar para o i-√©simo elemento da matriz, as express√µes <i>(P) + N</i> (ou seu equivalente <i>N + (P)</i> ) e <i>(P) -N</i> (onde <i>N</i> tem o valor n) indicar√£o respectivamente (i + n) th e (i - n) th elementos da matriz, desde que existam.  Al√©m disso, se a express√£o <i>P</i> apontar para o √∫ltimo elemento da matriz, a express√£o <i>(P) +1</i> indica a posi√ß√£o ap√≥s o √∫ltimo elemento da matriz, e se a express√£o <i>Q</i> indica a posi√ß√£o ap√≥s o √∫ltimo elemento da matriz, a express√£o <i>(Q) -1</i> indica o √∫ltimo elemento array.  Se a fonte e os ponteiros resultantes fizerem refer√™ncia a elementos da mesma matriz ou √† posi√ß√£o ap√≥s o √∫ltimo elemento da matriz, o estouro ser√° exclu√≠do;  caso contr√°rio, o comportamento √© indefinido.  Se o ponteiro resultante se referir √† posi√ß√£o ap√≥s o √∫ltimo elemento da matriz, o operador un√°rio <i>*</i> n√£o poder√° ser aplicado a ele. </td></tr></tbody></table><br>  Daqui resulta que o resultado da express√£o <i>&amp; b + 1</i> deve ser definitivamente um endere√ßo e, portanto, <i>peq</i> s√£o indicadores v√°lidos.  Deixe-me lembr√°-lo como a igualdade de dois ponteiros no padr√£o √© definida: " <i>Dois ponteiros s√£o iguais se e somente [...] se um ponteiro se refere √† posi√ß√£o ap√≥s o √∫ltimo elemento da matriz e o outro ao in√≠cio de outra matriz imediatamente ap√≥s o primeiro na mesma endere√ßo "</i> (C11 ¬ß 6.5.9, cl√°usula 6).  √â exatamente isso que observamos em nosso exemplo.  O ponteiro q se refere √† posi√ß√£o ap√≥s o objeto b, imediatamente seguido pelo objeto a, ao qual o ponteiro p se refere.  Ent√£o, existe um bug no GCC?  Essa contradi√ß√£o foi descrita em 2014 como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bug # 61502</a> , mas os desenvolvedores do GCC n√£o a consideram um bug e, portanto, n√£o v√£o corrigi-lo. <br><br>  Um problema semelhante foi encontrado em 2016 pelos programadores do Linux.  Considere o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Os s√≠mbolos <i>_start</i> e <i>_end</i> especificam os limites da √°rea de mem√≥ria.  Como eles s√£o transferidos para um arquivo externo, o compilador n√£o sabe como as matrizes est√£o realmente localizadas na mem√≥ria.  Por esse motivo, ele deve ser cuidadoso aqui e prosseguir com a suposi√ß√£o de que eles se seguem no espa√ßo de endere√ßo.  No entanto, o GCC compila a condi√ß√£o do loop para que seja sempre verdadeira, o que torna o loop infinito.  Esse problema √© descrito aqui neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post no LKML</a> - um fragmento de c√≥digo semelhante √© usado l√°.  Parece que, nesse caso, os autores do GCC, no entanto, levaram em conta os coment√°rios e alteraram o comportamento do compilador.  Pelo menos n√£o consegui reproduzir esse erro no GCC vers√£o 7.3.1 no Linux x86_64. <br><br><h3>  Solu√ß√£o - no relat√≥rio de bug # 260? </h3><br>  Nosso caso pode esclarecer o relat√≥rio de erro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 260</a> .  √â mais sobre valores incertos, mas voc√™ pode encontrar um coment√°rio curioso do comit√™: <br><br>  <i>As implementa√ß√µes do compilador [...] tamb√©m podem distinguir ponteiros obtidos de diferentes objetos, mesmo se esses ponteiros tiverem o mesmo conjunto de bits.</i> <br><br>  Se considerarmos esse coment√°rio literalmente, √© l√≥gico que o resultado da express√£o <i>p == q</i> seja ‚Äúfalso‚Äù, pois <i>peq s√£o</i> obtidos de diferentes objetos que n√£o est√£o conectados de forma alguma.  Parece que estamos nos aproximando da verdade - ou n√£o?  At√© agora, lidamos com operadores de igualdade, mas e os operadores de rela√ß√µes? <br><br><h3>  A pista final est√° em rela√ß√£o aos operadores? </h3><br>  A defini√ß√£o dos operadores de relacionamento <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> e <i>&gt; =</i> no contexto de compara√ß√µes de ponteiros cont√©m um pensamento curioso: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.8 n.o 5</b> <br><br>  O resultado da compara√ß√£o de dois ponteiros depende da posi√ß√£o relativa dos objetos indicados no espa√ßo de endere√ßo.  Se dois ponteiros para tipos de objetos se referirem ao mesmo objeto, ou ambos se referem √† posi√ß√£o ap√≥s o √∫ltimo elemento da mesma matriz, esses ponteiros s√£o iguais.  Se os objetos indicados forem membros do mesmo objeto composto, os ponteiros para os membros da estrutura declarados posteriormente ser√£o mais do que os ponteiros para os membros declarados anteriormente e os ponteiros para os elementos de uma matriz com √≠ndices mais altos ser√£o mais do que os ponteiros para os elementos da mesma matriz com os √≠ndices mais baixos.  Todos os ponteiros para membros da mesma associa√ß√£o s√£o iguais.  Se a express√£o <i>P</i> apontar para um elemento da matriz e a express√£o <i>Q</i> apontar para o √∫ltimo elemento da mesma matriz, o valor da express√£o indicadora <i>Q + 1 ser√°</i> maior que o valor da express√£o <i>P.</i>  Em todos os outros casos, o comportamento n√£o est√° definido. </td></tr></tbody></table><br>  De acordo com essa defini√ß√£o, o resultado da compara√ß√£o de ponteiros √© determinado apenas se os ponteiros forem obtidos do <i>mesmo</i> objeto.  Mostramos isso com dois exemplos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Aqui, os ponteiros <i>peq se</i> referem a dois objetos diferentes que n√£o est√£o interconectados.  Portanto, o resultado de sua compara√ß√£o n√£o est√° definido.  Mas no exemplo a seguir: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  ponteiros <i>peq se</i> referem ao mesmo objeto e, portanto, est√£o interconectados.  Portanto, eles podem ser comparados - a menos que o <i>malloc</i> retorne um valor nulo. <br><br><h3>  Sum√°rio </h3><br>  O padr√£o C11 n√£o descreve adequadamente compara√ß√µes de ponteiros.  O ponto mais problem√°tico que encontramos foi o par√°grafo 6 ¬ß 6.5.9, onde √© explicitamente permitido comparar dois ponteiros que referenciam duas matrizes diferentes.  Isso contradiz o coment√°rio do relat√≥rio de erro # 260.  No entanto, estamos falando de significados indefinidos, e eu n√£o gostaria de construir meu racioc√≠nio com base apenas nesse coment√°rio e interpret√°-lo em outro contexto.  Ao comparar ponteiros, os operadores de relacionamento s√£o definidos de maneira ligeiramente diferente dos operadores de igualdade - ou seja, os operadores de relacionamento s√£o definidos apenas se os dois ponteiros forem obtidos do <i>mesmo</i> objeto. <br><br>  Se ignorarmos o texto do padr√£o e perguntarmos se √© poss√≠vel comparar dois indicadores obtidos de dois objetos diferentes, em qualquer caso, a resposta provavelmente ser√° "n√£o".  O exemplo no in√≠cio do artigo demonstra um problema te√≥rico.  Como as vari√°veis <i>aeb</i> t√™m dura√ß√µes autom√°ticas de armazenamento, nossas suposi√ß√µes sobre sua coloca√ß√£o na mem√≥ria n√£o s√£o confi√°veis.  Em alguns casos, podemos adivinhar, mas √© √≥bvio que esse c√≥digo n√£o pode ser portado com seguran√ßa, e voc√™ pode descobrir o significado do programa apenas compilando e executando ou desmontando o c√≥digo, e isso contradiz qualquer paradigma de programa√ß√£o s√©rio. <br><br>  No entanto, em geral, n√£o estou satisfeito com a reda√ß√£o do padr√£o C11 e, como v√°rias pessoas j√° encontraram esse problema, a pergunta permanece: por que n√£o formular as regras com mais clareza? <br><br><h3>  Adi√ß√£o <br>  Ponteiros para a posi√ß√£o ap√≥s o √∫ltimo elemento da matriz </h3><br>  Quanto √† regra sobre compara√ß√£o e endere√ßamento aritm√©tico de ponteiros para a posi√ß√£o ap√≥s o √∫ltimo elemento da matriz, muitas vezes voc√™ pode encontrar exce√ß√µes.  Suponha que o padr√£o n√£o permita comparar dois ponteiros obtidos da <i>mesma</i> matriz, mesmo que pelo menos um deles se refira √† posi√ß√£o al√©m do final da matriz.  O c√≥digo a seguir n√£o funcionaria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Usando um loop, percorremos todo o array <i>x</i> , composto por 64 elementos, ou seja,  o corpo do loop deve ser executado exatamente 64 vezes.  Mas, de fato, a condi√ß√£o √© verificada 65 vezes - uma vez mais que o n√∫mero de elementos na matriz.  Nas primeiras 64 itera√ß√µes, o ponteiro <i>i</i> sempre se refere ao interior da matriz <i>x</i> , enquanto a express√£o <i>&amp; x [num]</i> sempre indica a posi√ß√£o ap√≥s o √∫ltimo elemento da matriz.  Na 65¬™ itera√ß√£o, o ponteiro <i>i</i> tamb√©m se referir√° √† posi√ß√£o al√©m do final da matriz <i>x</i> , por causa da qual a condi√ß√£o do loop se torna falsa.  Essa √© uma maneira conveniente de ignorar toda a matriz e se baseia em uma exce√ß√£o √† regra da incerteza no comportamento ao comparar esses indicadores.  Observe que o padr√£o descreve apenas o comportamento ao comparar ponteiros;  a desreferencia√ß√£o √© uma quest√£o separada. <br><br>  √â poss√≠vel mudar nosso exemplo para que nenhum ponteiro se refira √† posi√ß√£o ap√≥s o √∫ltimo elemento da matriz <i>x</i> ?  √â poss√≠vel, mas ser√° mais dif√≠cil.  Teremos que alterar a condi√ß√£o do loop e proibir o incremento da vari√°vel <i>i</i> na √∫ltima itera√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Este c√≥digo est√° cheio de sutilezas t√©cnicas, as quais perturbam a distra√ß√£o da tarefa principal.  Al√©m disso, um ramo adicional apareceu no corpo do loop.  Portanto, acho razo√°vel que o padr√£o permita exce√ß√µes ao comparar ponteiros de posi√ß√£o ap√≥s o √∫ltimo elemento de uma matriz. <br><br>  <b><i>Nota da equipe do PVS-Studio</i></b> <br><br>  <i>Ao desenvolver o analisador de c√≥digo PVS-Studio, √†s vezes precisamos lidar com quest√µes sutis para tornar o diagn√≥stico mais preciso ou fornecer consultas detalhadas aos nossos clientes.</i>  <i>Este artigo nos pareceu interessante, pois aborda quest√µes em que n√≥s mesmos n√£o nos sentimos totalmente confiantes.</i>  <i>Por isso, pedimos ao autor para publicar sua tradu√ß√£o.</i>  <i>Esperamos que mais programadores de C e C ++ a conhe√ßam e entendam que n√£o √© t√£o simples e que, quando o analisador repentinamente exibir uma mensagem estranha, n√£o se apresse em consider√°-la um falso positivo :).</i> <br><br>  <i>O artigo foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>publicado</i></a> pela primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>vez</i></a> em ingl√™s em stefansf.de.</i>  <i>As tradu√ß√µes s√£o publicadas com permiss√£o do autor.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418023/">https://habr.com/ru/post/pt418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418009/index.html">Node.js e renderiza√ß√£o de servidor no Airbnb</a></li>
<li><a href="../pt418011/index.html">P√°ginas individuais e SEO. Segredos de otimiza√ß√£o</a></li>
<li><a href="../pt418013/index.html">O Intel Core i7-8086K (parte 3)</a></li>
<li><a href="../pt418015/index.html">Novo Vasyuki. Desenvolvimento inovador de Moscou at√© 2100</a></li>
<li><a href="../pt418017/index.html">An√°lise do comportamento do Trojan Pegasus na rede</a></li>
<li><a href="../pt418025/index.html">O livro ‚ÄúAprendendo Java EE. Programa√ß√£o moderna para grandes empresas "</a></li>
<li><a href="../pt418027/index.html">Microservice Blitz</a></li>
<li><a href="../pt418029/index.html">ReactOS 0.4.9: haters ter√£o que procurar novos argumentos</a></li>
<li><a href="../pt418031/index.html">Empilhamento em massa de modelos ML em produ√ß√£o: real ou n√£o?</a></li>
<li><a href="../pt418035/index.html">Apresentando a linha do tempo na Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>