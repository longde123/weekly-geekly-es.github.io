<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∑ üíà üé§ Entwicklung in einem Monorepository. Yandex-Bericht ‚ùî üë©üèø‚Äçü§ù‚Äçüë©üèæ üßíüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Azat Razetdinov, ich bin seit 12 Jahren in Yandex und leite den Schnittstellenentwicklungsservice in Y. Real Estate. Heute m√∂chte ich √ºb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung in einem Monorepository. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/469021/">  Mein Name ist Azat Razetdinov, ich bin seit 12 Jahren in Yandex und leite den Schnittstellenentwicklungsservice in Y. Real Estate.  Heute m√∂chte ich √ºber ein Monorepository sprechen.  Wenn Sie nur ein Repository am Werk haben - herzlichen Gl√ºckwunsch, leben Sie bereits in einem einzigen Repository.  Nun dar√ºber, warum andere es brauchen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/v_/vr/gi/v_vrgiiye4emmloccesmmogxlim.jpeg"></a> <br><br><blockquote>  Laut Marina Pereskokova, der Leiterin des Yandex.Mart API-Entwicklungsdienstes, hat mein Gro√üvater eine Monorepa gepflanzt, und eine Monorepa ist gro√ü geworden. </blockquote><br><a name="habracut"></a>  - Wir bei Yandex haben verschiedene Arten der Arbeit mit mehreren Diensten ausprobiert und festgestellt - sobald Sie mehr als einen Dienst haben, werden unweigerlich gemeinsame Teile angezeigt: Modelle, Dienstprogramme, Tools, Codeteile, Vorlagen, Komponenten.  Die Frage ist: Wo soll das alles hingelegt werden?  Nat√ºrlich k√∂nnen Sie kopieren und einf√ºgen, wir k√∂nnen es tun, aber ich m√∂chte es sch√∂n. <br><br>  Wir haben sogar eine Entit√§t wie SVN externals f√ºr diejenigen ausprobiert, die sich erinnern.  Wir haben Git-Submodule ausprobiert.  Wir haben npm-Pakete ausprobiert, als sie erschienen.  Aber das alles war irgendwie lang oder so.  Sie unterst√ºtzen jedes Paket, finden einen Fehler und nehmen Korrekturen vor.  Dann m√ºssen Sie eine neue Version ver√∂ffentlichen, die Dienste durchgehen, auf diese Version aktualisieren, √ºberpr√ºfen, ob alles funktioniert, die Tests ausf√ºhren, den Fehler finden, zum Bibliotheksrepository zur√ºckkehren, den Fehler beheben, die neue Version freigeben, die Dienste durchgehen, aktualisieren und so weiter Kreis.  Es wurde einfach zu Schmerz. <br><br><img src="https://habrastorage.org/webt/rq/ie/uo/rqieuoverzzoq6wrhpujf4qz8vw.jpeg"><br><br>  Dann √ºberlegten wir, ob wir in einem Repository zusammenkommen sollten.  Nehmen Sie alle unsere Dienste und Bibliotheken, √ºbertragen und entwickeln Sie sie in einem Repository.  Es gab viele Vorteile.  Ich sage nicht, dass dieser Ansatz ideal ist, aber aus Sicht des Unternehmens und sogar der Abteilung mehrerer Gruppen ergeben sich erhebliche Vorteile. <br><br>  F√ºr mich pers√∂nlich ist das Wichtigste die Atomizit√§t der Commits, dass ich als Entwickler die Bibliothek reparieren, alle Dienste umgehen, √Ñnderungen vornehmen, Tests ausf√ºhren, √ºberpr√ºfen kann, ob alles funktioniert, sie in den Master √ºbertragen und all dies mit einer √Ñnderung.  Sie m√ºssen nichts neu erstellen, ver√∂ffentlichen oder aktualisieren. <br><br>  Aber wenn alles so gut ist, warum sind noch nicht alle in das Mono-Repository umgezogen?  Nat√ºrlich gibt es auch Nachteile. <br><br><img src="https://habrastorage.org/webt/bb/1u/pv/bb1upvyscjzd_csjkvxce0yh9a0.jpeg"><br><br>  Laut Marina Pereskokova, der Leiterin des Yandex.Map API-Entwicklungsdienstes, hat mein Gro√üvater eine Monorepa gepflanzt, und eine Monorepa ist gro√ü geworden.  Dies ist eine Tatsache, kein Witz.  Wenn Sie viele Dienste in einem einzigen Repository sammeln, w√§chst es unweigerlich.  Und wenn es sich um Git handelt, das alle Dateien sowie deren gesamten Verlauf f√ºr die gesamte Existenz Ihres Codes abruft, ist dies ein ziemlich gro√üer Speicherplatz. <br><br>  Das zweite Problem ist die Injektion in den Master.  Sie haben eine Poolanfrage vorbereitet, eine √úberpr√ºfung durchlaufen und sind bereit, sie zusammenzuf√ºhren.  Und es stellt sich heraus, dass es jemandem gelungen ist, vor Ihnen zu kommen, und Sie Konflikte l√∂sen m√ºssen.  Sie haben die Konflikte gel√∂st, waren wieder bereit, sich darauf einzulassen, und hatten erneut keine Zeit.  Dieses Problem wird gel√∂st, es gibt Zusammenf√ºhrungswarteschlangensysteme, wenn ein spezieller Roboter diese Arbeit automatisiert, Poolanforderungen verfolgt und versucht, Konflikte zu l√∂sen, wenn dies m√∂glich ist.  Wenn er nicht kann, ruft er den Autor an.  Ein solches Problem besteht jedoch.  Es gibt L√∂sungen, die dies ausgleichen, aber Sie m√ºssen dies ber√ºcksichtigen. <br><br>  Dies sind technische, aber auch organisatorische Punkte.  Angenommen, Sie haben mehrere Teams, die verschiedene Dienste erbringen.  Wenn sie in ein einzelnes Repository wechseln, beginnt ihre Verantwortung zu schwinden.  Weil sie eine Ver√∂ffentlichung gemacht haben, die in der Produktion eingef√ºhrt wurde - etwas ist kaputt gegangen.  Wir beginnen mit der Nachbesprechung.  Es stellt sich heraus, dass es sich um einen Entwickler eines anderen Teams handelt, der etwas f√ºr den allgemeinen Code festgelegt hat. Wir haben es gezogen, unver√∂ffentlicht, nicht gesehen, alles ist kaputt gegangen.  Und es ist nicht klar, wer daf√ºr verantwortlich ist.  Es ist wichtig, alle m√∂glichen Methoden zu verstehen und anzuwenden: Komponententests, Integrationstests, Linter - alles, was m√∂glich ist, um dieses Problem des Einflusses eines Codes auf alle anderen Dienste zu verringern. <br><br>  Interessanterweise nutzt au√üer Yandex und anderen Spielern noch jemand das Mono-Repository?  Sehr viele Leute.  Dies sind React, Jest, Babel, Ember, Meteor, Angular.  Die Leute verstehen - es ist einfacher, billiger und schneller, npm-Pakete aus einem einzigen Repository zu entwickeln und zu ver√∂ffentlichen als aus mehreren kleinen Repositorys.  Das Interessanteste ist, dass sich zusammen mit diesem Prozess Werkzeuge f√ºr die Arbeit mit einem Monorepository entwickelten.  Nur √ºber sie und ich m√∂chte reden. <br><br>  Alles beginnt mit der Erstellung eines Monorepositorys.  Das weltweit bekannteste Front-End-Tool daf√ºr hei√üt lerna. <br><br><img src="https://habrastorage.org/webt/2a/n9/my/2an9myv3k_dokzcizjfhshporh0.jpeg"><br><br>  √ñffnen Sie einfach Ihr Repository, f√ºhren Sie npx lerna init aus. Es werden Ihnen einige interessante Fragen gestellt und Ihrer Arbeitskopie einige Entit√§ten hinzugef√ºgt.  Die erste Entit√§t ist die Konfiguration lerna.json, die mindestens zwei Felder angibt: die End-to-End-Version aller Ihrer Pakete und den Speicherort Ihrer Pakete im Dateisystem.  Standardm√§√üig werden alle Pakete zum Paketordner hinzugef√ºgt, aber Sie k√∂nnen dies nach Belieben konfigurieren, Sie k√∂nnen sie sogar zum Stammverzeichnis hinzuf√ºgen, lerna kann es auch abholen. <br><br>  Der n√§chste Schritt ist, wie Sie Ihre Repositorys zum Mono-Repository hinzuf√ºgen und wie Sie sie √ºbertragen. <br><br>  Was wollen wir erreichen?  H√∂chstwahrscheinlich haben Sie bereits eine Art Repository, in diesem Fall A und B. <br><br><img src="https://habrastorage.org/webt/gd/yl/d0/gdyld0xwsgytno9mhaz7g-t-ikc.jpeg"><br><br>  Dies sind zwei Dienste, jeder in seinem eigenen Repository, und wir m√∂chten sie in das neue Mono-Repository im Paketordner √ºbertragen, vorzugsweise mit einem Verlauf von Commits, damit Sie Git-Schuld, Git-Protokoll usw. machen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/rd/td/z1/rdtdz1-3hqxrjvgsgf4tb4wq5fy.jpeg"><br><br>  Hierf√ºr gibt es ein Herna-Import-Tool.  Sie geben einfach den Speicherort Ihres Repositorys an und lerna √ºbertr√§gt ihn an Ihren Monorepo.  Gleichzeitig erstellt sie zun√§chst eine Liste aller Commits, √§ndert jedes Commit, √§ndert den Pfad zu den Dateien vom Stammverzeichnis zu packages / package_name, wendet sie nacheinander an und √ºberlagert sie in Ihrem Mono-Repository.  Tats√§chlich wird jedes Commit vorbereitet und die darin enthaltenen Dateipfade ge√§ndert.  Im Wesentlichen macht Herna Git-Magie f√ºr Sie.  Wenn Sie den Quellcode lesen, werden dort einfach Git-Befehle in einer bestimmten Reihenfolge ausgef√ºhrt. <br><br>  Dies ist der erste Weg.  Es hat einen Nachteil: Wenn Sie in einem Unternehmen arbeiten, in dem es Produktionsprozesse gibt, in dem bereits Code geschrieben wird, und Sie diese in einen Monorep √ºbersetzen, ist es unwahrscheinlich, dass Sie dies an einem Tag tun.  Sie m√ºssen herausfinden, konfigurieren, √ºberpr√ºfen, ob alles startet, testen.  Aber die Leute haben keine Arbeit, sie machen weiter etwas. <br><br><img src="https://habrastorage.org/webt/u5/w4/je/u5w4jenpjqspns44ok1grkidxug.jpeg"><br><br>  F√ºr einen reibungsloseren √úbergang zu Mono-Rap gibt es ein Tool wie den Git-Teilbaum.  Dies ist eine komplexere Sache, aber gleichzeitig in git integriert, wodurch Sie nicht nur einzelne Repositorys mit einem Pr√§fix in ein Mono-Repository importieren, sondern auch √Ñnderungen hin und her austauschen k√∂nnen.  Das hei√üt, das Team, das den Service erstellt, kann problemlos in seinem eigenen Repository weiterentwickelt werden, w√§hrend Sie die √Ñnderungen durch das Ziehen von Git-Teilb√§umen abrufen, Ihre eigenen √Ñnderungen vornehmen und sie durch das Dr√ºcken von Git-Teilb√§umen zur√ºckschieben k√∂nnen.  Und leben Sie in der √úbergangszeit so lange, wie Sie m√∂chten. <br><br>  Wenn Sie alles eingerichtet und √ºberpr√ºft haben, ob alle Tests ausgef√ºhrt werden, die Bereitstellung funktioniert, das gesamte CI / die gesamte CD konfiguriert ist, k√∂nnen Sie sagen, dass es Zeit ist, fortzufahren.  F√ºr die √úbergangszeit empfehle ich eine tolle L√∂sung. <br><br>  Nun, wir haben unsere Repositories in ein Mono-Repository verschoben, aber wo ist die Magie irgendwo?  Aber wir wollen die gemeinsamen Teile hervorheben und sie irgendwie verwenden.  Und daf√ºr gibt es einen "Abh√§ngigkeitsbindungsmechanismus".  Was ist Abh√§ngigkeitsbindung?  Es gibt ein lerna-Bootstrap-Tool, ein Befehl, der der npm-Installation √§hnelt und nur die npm-Installation in all Ihren Paketen ausf√ºhrt. <br><br><img src="https://habrastorage.org/webt/kh/tg/cw/khtgcwjnzf2kjxoy61wgmkevopo.jpeg"><br><br>  Aber das ist noch nicht alles.  Dar√ºber hinaus sucht sie nach internen Abh√§ngigkeiten.  Sie k√∂nnen ein anderes in einem Paket in Ihrem Repository verwenden.  Wenn Sie beispielsweise Paket A haben, das in diesem Fall von Jest abh√§ngt, gibt es Paket B, das von Jest und Paket A abh√§ngt. Wenn Paket A ein allgemeines Tool ist, eine gemeinsame Komponente, dann ist Paket B ein Dienst, der es hat verwendet. <br><br>  Lerna definiert solche internen Abh√§ngigkeiten und ersetzt diese Abh√§ngigkeit physisch durch eine symbolische Verkn√ºpfung im Dateisystem. <br><br><img src="https://habrastorage.org/webt/or/lk/am/orlkampii1gcc_kxupnpc5k-hxy.jpeg"><br><br><img src="https://habrastorage.org/webt/ia/dp/oo/iadpoole-lvonlr_o30aqvbc8no.jpeg"><br><br>  Nachdem Sie lerna bootstrap direkt im Ordner node_modules anstelle des physischen Ordners A ausgef√ºhrt haben, wird ein symbolischer Link angezeigt, der zum Ordner mit Paket A f√ºhrt. Dies ist sehr praktisch, da Sie den Code in Paket A bearbeiten und das Ergebnis in Paket B sofort √ºberpr√ºfen k√∂nnen , f√ºhren Sie Tests, Integration, Einheiten, was auch immer Sie wollen.  Die Entwicklung ist stark vereinfacht. Sie m√ºssen Paket A nicht mehr neu zusammensetzen, ver√∂ffentlichen und Paket B verbinden. Es wurde nur hier behoben und dort √ºberpr√ºft. <br><br>  Bitte beachten Sie, dass wir das installierte Modul dupliziert haben, wenn Sie sich die Ordner node_modules ansehen und dort und dort ein Scherz ist.  Im Allgemeinen dauert es ziemlich lange, bis Sie lerna bootstrap starten und warten, bis alles aufh√∂rt, da es jede Menge wiederholter Arbeiten gibt. In jedem Paket werden doppelte Abh√§ngigkeiten erhalten. <br><br>  Um die Installation von Abh√§ngigkeiten zu beschleunigen, wird der Mechanismus zum Ausl√∂sen von Abh√§ngigkeiten verwendet.  Die Idee ist sehr einfach: Sie k√∂nnen die allgemeinen Abh√§ngigkeiten zu den Stammknotenmodulen √ºbernehmen. <br><br><img src="https://habrastorage.org/webt/so/lj/kr/soljkrixddhlkrth4w95b1bk5ek.jpeg"><br><br>  Wenn Sie die Option --hoist angeben (dies ist ein Upgrade von Englisch), werden fast alle Abh√§ngigkeiten einfach in die Stammknotenmodule verschoben.  Und es funktioniert fast immer.  Noda ist so arrangiert, dass sie, wenn sie die Abh√§ngigkeiten auf ihrer Ebene nicht gefunden hat, beginnt, eine Ebene h√∂her zu suchen, wenn nicht dort, eine andere Ebene h√∂her und so weiter.  Fast nichts √§ndert sich.  Tats√§chlich haben wir unsere Abh√§ngigkeiten √ºbernommen und dedupliziert und die Abh√§ngigkeiten an die Wurzel √ºbertragen. <br><br>  Gleichzeitig ist lerna klug genug.  Wenn es einen Konflikt gibt, zum Beispiel wenn Paket A Jest Version 1 und Paket B Version 2 verwendet, wird einer von ihnen angezeigt und der zweite bleibt auf seiner Ebene.  Dies ist ungef√§hr das, was npm tats√§chlich im normalen Ordner node_modules tut. Es versucht auch, Abh√§ngigkeiten zu deduplizieren und sie maximal zum Stamm zu √ºbertragen. <br><br>  Leider funktioniert diese Magie nicht immer, besonders bei Werkzeugen, bei Babel, bei Jest.  Es kommt oft vor, dass er startet, weil Jest ein eigenes System zum Aufl√∂sen von Modulen hat, Noda anf√§ngt zu verz√∂gern, einen Fehler zu werfen.  Insbesondere in solchen F√§llen, in denen das Tool die Abh√§ngigkeiten, die zum Stammverzeichnis gegangen sind, nicht bew√§ltigt, gibt es die Option nohoist, mit der Sie darauf hinweisen k√∂nnen, dass diese Pakete nicht zum Stammverzeichnis √ºbertragen werden, sondern an Ort und Stelle bleiben. <br><br><img src="https://habrastorage.org/webt/2z/sx/9z/2zsx9zvtkofxy_2uk4au8x1uxbu.jpeg"><br><br>  Wenn Sie --nohoist = jest angeben, werden alle Abh√§ngigkeiten au√üer jest an den Stamm gesendet, und jest bleibt auf Paketebene.  Kein Wunder, dass ich ein solches Beispiel gegeben habe - es ist ein Scherz, der Probleme mit diesem Verhalten hat, und Nohoist hilft dabei. <br><br>  Ein weiteres Plus der Abh√§ngigkeitswiederherstellung: <br><br><img src="https://habrastorage.org/webt/yp/1n/ur/yp1nurrr-zokokzjy7rgzvmozzi.jpeg"><br><br>  Wenn Sie zuvor f√ºr jeden Dienst, f√ºr jedes Paket, eine separate package-lock.json hatten, wird beim Hochfahren alles nach oben verschoben, und die einzige package-lock.json bleibt erhalten.  Dies ist unter dem Gesichtspunkt des Eingie√üens in den Master und der L√∂sung von Konflikten praktisch.  Sobald alle get√∂tet wurden, und das war's. <br><br>  Aber wie erreicht lerna das?  Sie ist ziemlich aggressiv mit npm.  Wenn Sie hoist angeben, wird Ihre package.json im Stammverzeichnis gespeichert, gesichert, durch eine andere ersetzt, alle Ihre Abh√§ngigkeiten darin zusammengefasst, npm install ausgef√ºhrt und fast alles im Stammverzeichnis abgelegt.  Dann wird dieses tempor√§re package.json entfernt und Ihr wiederhergestellt.  Wenn Sie danach einen Befehl mit npm ausf√ºhren, z. B. npm remove, wird npm nicht verstehen, was passiert ist, warum pl√∂tzlich alle Abh√§ngigkeiten im Stammverzeichnis angezeigt wurden.  Lerna verletzt die Abstraktionsebene, sie kriecht in das Werkzeug, das unter ihrer Ebene liegt. <br><br>  Die Jungs von Yarn waren die ersten, die dieses Problem bemerkten und sagten: Was qu√§len wir, lassen Sie uns alles f√ºr Sie tun, damit alles sofort funktioniert. <br><br><img src="https://habrastorage.org/webt/4l/0q/yb/4l0qybezxp0nwi_fulfgleb11oe.jpeg"><br><br>  Garn kann bereits das Gleiche sofort tun: Abh√§ngigkeiten binden. Wenn er sieht, dass Paket B von Paket A abh√§ngt, erstellt er kostenlos einen Symlink f√ºr Sie.  Er wei√ü, wie man Abh√§ngigkeiten aufwirft, macht es standardm√§√üig, alles summiert sich zur Wurzel.  Wie bei lerna kann es die einzige Garnverriegelung im Stammverzeichnis des Repositorys belassen.  Alle anderen Garn.Lock brauchen Sie nicht mehr. <br><br><img src="https://habrastorage.org/webt/wj/bu/e7/wjbue7nf67iucirzohdpfxk75xe.jpeg"><br><br>  Es ist auf √§hnliche Weise konfiguriert.  Leider geht Garn davon aus, dass alle Einstellungen zu package.json hinzugef√ºgt wurden. Ich wei√ü, dass es Leute gibt, die versuchen, alle Einstellungen der Werkzeuge von dort wegzunehmen, wobei nur ein Minimum √ºbrig bleibt.  Leider hat Garn noch nicht gelernt, dies in einer anderen Datei anzugeben, nur in package.json.  Es gibt zwei neue Optionen, eine neue und eine obligatorische.  Da davon ausgegangen wird, dass das Root-Repository niemals ver√∂ffentlicht wird, muss f√ºr Garn private = true angegeben werden. <br><br>  Die Einstellungen f√ºr Arbeitsbereiche werden jedoch in derselben Taste gespeichert.  Die Einstellung ist den Lerna-Einstellungen sehr √§hnlich, es gibt ein Paketfeld, in dem Sie den Speicherort Ihrer Pakete angeben, und es gibt eine Nohoist-Option, die der Nohoist-Option in Lerna sehr √§hnlich ist.  Geben Sie einfach diese Einstellungen an und erhalten Sie die gleiche Struktur wie in lerna.  Alle g√§ngigen Abh√§ngigkeiten gingen an die Wurzel, und die im Nohoist-Schl√ºssel angegebenen blieben auf ihrer Ebene. <br><br><img src="https://habrastorage.org/webt/6w/rj/8c/6wrj8cm-b68sgcbsm0gstgmwzm8.jpeg"><br><br>  Das Beste daran ist, dass lerna mit Garn arbeiten und seine Einstellungen √ºbernehmen kann.  Es reicht aus, zwei Felder in lerna.json anzugeben. Lerna wird sofort verstehen, dass Sie Garn verwenden, in package.json gehen, alle Einstellungen von dort abrufen und mit ihnen arbeiten.  Diese beiden Tools kennen sich bereits und arbeiten zusammen. <br><br><img src="https://habrastorage.org/webt/q5/hs/em/q5hsemi5za3meeg_s7zjj0sak4g.jpeg"><br><br>  Und warum wurde bei npm noch keine Unterst√ºtzung geleistet, wenn so viele gro√üe Unternehmen ein Mono-Repository verwenden? <br><br><img src="https://habrastorage.org/webt/h1/al/n6/h1aln6qeuati1bbhmojwgtao1xo.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sub></sup> </h5><br>  Sie sagen, dass alles sein wird, aber in der siebten Version.  Grundlegende Unterst√ºtzung im siebten, erweitert - im achten.  Dieser Beitrag wurde vor einem Monat ver√∂ffentlicht, aber gleichzeitig ist das Datum noch nicht bekannt, an dem die siebte npm ver√∂ffentlicht wird.  Wir warten darauf, dass er endlich das Garn einholt. <br><br>  Wenn Sie mehrere Dienste in einem Mono-Repository haben, stellt sich unweigerlich die Frage, wie diese verwaltet werden sollen, um nicht zu jedem Ordner zu wechseln und keine Befehle auszuf√ºhren.  Daf√ºr gibt es massive Operationen. <br><br><img src="https://habrastorage.org/webt/8f/9z/lk/8f9zlkf-hdow1itwrmkiczqm5pk.jpeg"><br><br><img src="https://habrastorage.org/webt/ux/z_/ed/uxz_edv1rkl4bjlydo8q8pndty8.jpeg"><br><br>  Garn hat einen Garnarbeitsbereichsbefehl, gefolgt vom Namen des Pakets und dem Namen des Befehls.  Da Garn aus der Box im Gegensatz zu npm alle drei Dinge tun kann: eigene Befehle ausf√ºhren, eine Abh√§ngigkeit von Scherz hinzuf√ºgen, Skripte aus package.json wie test ausf√ºhren und auch ausf√ºhrbare Dateien aus dem Ordner node_modules / .bin ausf√ºhren.  Er wird mit Hilfe von Heuristiken f√ºr Sie unterrichten, er wird verstehen, was Sie wollen.  Es ist sehr praktisch, den Garnarbeitsbereich f√ºr Punktoperationen an einem Paket zu verwenden. <br><br>  Es gibt einen √§hnlichen Befehl, mit dem Sie einen Befehl f√ºr alle vorhandenen Pakete ausf√ºhren k√∂nnen. <br><br><img src="https://habrastorage.org/webt/-e/yn/vd/-eynvdikhrjyxn0we1fkw0loqcw.jpeg"><br><br>  Geben Sie nur Ihre Befehle mit allen Argumenten an. <br><br><img src="https://habrastorage.org/webt/qk/_t/lx/qk_tlxutn7it2owurvm5ne444o8.jpeg"><br><br>  Von den Profis ist es sehr praktisch, verschiedene Teams zu leiten.  Von den Minuspunkten ist es beispielsweise unm√∂glich, Shell-Befehle auszuf√ºhren.  Angenommen, ich m√∂chte alle Ordner der Knotenmodule l√∂schen. Ich kann keine Garnarbeitsbereiche ausf√ºhren, die rm ausf√ºhren. <br>  Es ist nicht m√∂glich, eine Liste von Paketen anzugeben. Ich m√∂chte beispielsweise die Abh√§ngigkeit in nur zwei Paketen entfernen, jeweils nur in einem oder separat. <br><br>  Nun, er st√ºrzt beim ersten Fehler ab.  Wenn ich die Abh√§ngigkeit von allen Paketen entfernen m√∂chte - und tats√§chlich haben nur zwei von ihnen sie, aber ich m√∂chte nicht dar√ºber nachdenken, wo sie sich befindet, sondern ich m√∂chte sie nur entfernen -, l√§sst das Garn dies nicht zu, es st√ºrzt in der ersten Situation ab wo dieses Paket nicht in den Abh√§ngigkeiten ist.  Dies ist nicht sehr praktisch. Manchmal m√∂chten Sie Fehler ignorieren und alle Pakete durchlaufen. <br><br><img src="https://habrastorage.org/webt/gv/bj/ax/gvbjax1gepdak6jwcxpf7q9u8ea.jpeg"><br><br>  Lerna hat ein viel interessanteres Toolkit, es gibt zwei separate Run- und Exec-Befehle.  Run kann Skripte aus package.json ausf√ºhren und im Gegensatz zu Garn alles nach Paket filtern. Sie k√∂nnen --scope angeben, Sie k√∂nnen Sternchen und Globs verwenden, alles ist ziemlich universell.  Sie k√∂nnen diese Vorg√§nge parallel ausf√ºhren und Fehler √ºber den Schalter --no-jail ignorieren. <br><br><img src="https://habrastorage.org/webt/j9/f_/km/j9f_kmpn1tkhfr88nsjykrunm5g.jpeg"><br><br>  Exec ist sehr √§hnlich.  Im Gegensatz zu Garn k√∂nnen Sie damit nicht nur ausf√ºhrbare Dateien aus node_modules.bin ausf√ºhren, sondern auch beliebige Shell-Befehle ausf√ºhren.  Sie k√∂nnen beispielsweise node_modules entfernen oder make ausf√ºhren, was immer Sie m√∂chten.  Und die gleiche Option wird unterst√ºtzt. <br><br><img src="https://habrastorage.org/webt/t4/f4/tv/t4f4tv2z0646cgezhzwamag6qgm.jpeg"><br><br>  Sehr praktische Werkzeuge, einige Pluspunkte.  Dies ist der Fall, wenn Lerna Garn zerrei√üt und sich auf der richtigen Abstraktionsebene befindet.  Genau das braucht lerna: vereinfachen sie die arbeit mit mehreren paketen in monorepe. <br><br>  Bei Monoreps gibt es noch ein Minus.  Wenn Sie eine CI / CD haben, k√∂nnen Sie diese nicht optimieren.  Je mehr Dienste Sie haben, desto l√§nger dauert alles.  Angenommen, Sie testen alle Services f√ºr jede Poolanforderung. Je mehr Services vorhanden sind, desto l√§nger dauert die Arbeit.  Selektive Operationen k√∂nnen verwendet werden, um diesen Prozess zu optimieren.  Ich werde drei verschiedene Arten nennen.  Die ersten beiden k√∂nnen nicht nur in Monorep, sondern auch in Ihren Projekten verwendet werden, wenn Sie diese Methoden aus irgendeinem Grund nicht verwenden. <br><br>  Das erste sind Flusenstufen, mit denen Sie Linter, Tests und alles, was Sie wollen, nur f√ºr Dateien ausf√ºhren k√∂nnen, die sich ge√§ndert haben oder in diesem Commit festgeschrieben werden.  F√ºhren Sie die gesamten Flusen nicht f√ºr Ihr gesamtes Projekt aus, sondern nur f√ºr die Dateien, die sich ge√§ndert haben. <br><br><img src="https://habrastorage.org/webt/7v/qj/4z/7vqj4zxxvjc3fyt_bs5nfbk85nc.jpeg"><br><br><img src="https://habrastorage.org/webt/dx/if/eu/dxifeu43kvhxy7kthspwefr2o8m.jpeg"><br><br>  Das Setup ist sehr einfach.  Setzen Sie fusself√∂rmige, heisere Pre-Commit-Hooks und sagen Sie, dass Sie beim √Ñndern einer js-Datei eslint ausf√ºhren m√ºssen.  Somit wird die Pr√ºfung vor dem Festschreiben stark beschleunigt.  Besonders wenn Sie viele Dienste haben, ein sehr gro√ües Mono-Repository.  Dann ist es zu teuer, eslint f√ºr alle Dateien auszuf√ºhren, und Sie k√∂nnen auf diese Weise Pre-Commit-Hooks f√ºr Lint optimieren. <br><br><img src="https://habrastorage.org/webt/x9/n7/dg/x9n7dgdih-y-zepifpkfd9czys8.jpeg"><br><br>  Wenn Sie Tests auf Jest schreiben, stehen auch Tools zum selektiven Ausf√ºhren von Tests zur Verf√ºgung. <br><br><img src="https://habrastorage.org/webt/gd/fp/op/gdfpopeopfjlht4excpli5ec0d8.jpeg"><br><br>  Mit dieser Option k√∂nnen Sie eine Liste der Quelldateien erstellen und alle Tests finden, die sich auf die eine oder andere Weise auf diese Dateien auswirken.  Was kann in Verbindung mit Fusseln verwendet werden?  Bitte beachten Sie, dass ich hier nicht alle js-Dateien spezifiziere, sondern nur die Quelle.  Wir schlie√üen die js-Dateien selbst mit Tests darin aus, wir betrachten nur die Quelle.  Wir starten findRelatedTests und beschleunigen den Lauf der Einheit erheblich, um sie nach Ihren W√ºnschen vorab festzulegen oder vorab zu pushen. <br><br>  Und die dritte Methode ist mit Monorepositories verbunden.  Dies ist lerna, die bestimmen kann, welche Pakete sich im Vergleich zum Basis-Commit ge√§ndert haben.  Hier geht es eher nicht um Hooks, sondern um Ihr CI / CD: Travis oder einen anderen Dienst, den Sie verwenden. <br><br><img src="https://habrastorage.org/webt/bn/is/ij/bnisijuykjzbkbi6-mhd19lwvmq.jpeg"><br><br><img src="https://habrastorage.org/webt/ul/d4/u2/uld4u2saou9lwemuj2ky4usffyu.jpeg"><br><br>  Die Befehle run und exec haben die Option Since, mit der Sie jeden Befehl nur in den Paketen ausf√ºhren k√∂nnen, die sich seit einer Art Festschreibung ge√§ndert haben.  In einfachen F√§llen k√∂nnen Sie einen Assistenten angeben, wenn Sie alles hineingie√üen.  Wenn Sie genauer wollen, ist es besser, das Basis-Commit Ihrer Pool-Anfrage √ºber Ihr CI / CD-Tool anzugeben. Dies ist ein ehrlicherer Test. <br><br>  Da lerna alle Abh√§ngigkeiten in den Paketen kennt, kann es auch indirekte Abh√§ngigkeiten erkennen.  Wenn Sie die Bibliothek A √§ndern, die in der Bibliothek B verwendet wird, die in Dienst C verwendet wird, wird lerna dies verstehen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie √§ndern den Code in Bibliothek A. Anschlie√üend wird transitiv festgelegt, dass Paket C getestet werden muss - beispielsweise mithilfe des von Ihnen geschriebenen Integrationstests. </font><font style="vertical-align: inherit;">Und lerna f√ºhrt diesen Befehl f√ºr Paket C aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind einige Links, die n√ºtzlich sein k√∂nnen: die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lerna-Website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empfehlung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Garnarbeitsbereichen</font></a><font style="vertical-align: inherit;"> und eine theoretische </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vor- und Nachteile eines Monorepositorys im Prinzip.</font></font><br><br>  ,   .  ,   .    .  ?    ,        ,       ,   .  ,         ,     .    ,   -      . ,      Babel.     ,   ,     .                  .     ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte mich bei meinen Kollegen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedanken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Mischa </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;">Mischanga</font></a><font style="vertical-align: inherit;"> Troshev und Gosha Besedin. </font><font style="vertical-align: inherit;">Sie haben viel Zeit damit verbracht, die Tools zu studieren, die wir heute √ºberpr√ºft haben, und ihre Erfahrungen und Kenntnisse geteilt. </font><font style="vertical-align: inherit;">Das ist alles, danke.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469021/">https://habr.com/ru/post/de469021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469007/index.html">RubyRussia 2019. Nikita Shilnikov √ºber algebraische Effekte</a></li>
<li><a href="../de469009/index.html">Frachtkult in der Softwareentwicklung</a></li>
<li><a href="../de469011/index.html">11 Mythen √ºber USB Typ C.</a></li>
<li><a href="../de469015/index.html">Slurm: Moskau intensiv von Kubernetes und anderen Ank√ºndigungen</a></li>
<li><a href="../de469019/index.html">SPA Meetup 5: Jest-Integration mit QA, leistungsstarkes UIKit, Komponentenbibliotheken, DI f√ºr die Skalierung, Plattformbefehle</a></li>
<li><a href="../de469023/index.html">So finden Sie einen Job mit Umzug nach Europa: ein praktischer Leitfaden f√ºr IT-Experten</a></li>
<li><a href="../de469025/index.html">K√ºhlen Sie den Wein schnell ab! Russische Erfindung</a></li>
<li><a href="../de469027/index.html">Ivanovo! Mitap: Wie baue ich eine Karriere in Digital auf?</a></li>
<li><a href="../de469031/index.html">12 neue k√ºnstliche Intelligenz f√ºr Azure Media Services</a></li>
<li><a href="../de469033/index.html">Starten der Elbrus-Plattform f√ºr neuronale PuzzleLib-Netzwerke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>