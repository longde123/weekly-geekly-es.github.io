<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèª üèè üéÉ JS nach Elbrus portieren ü¶â üêë üì•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine Geschichte √ºber das Portieren von JavaScript auf die heimische Elbrus-Plattform, die von Leuten von UniPro erstellt wurde. Der Artikel b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS nach Elbrus portieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/419155/">  Dies ist eine Geschichte √ºber das Portieren von JavaScript auf die heimische Elbrus-Plattform, die von Leuten von UniPro erstellt wurde.  Der Artikel bietet eine kurze vergleichende Analyse von Plattformen, Prozessdetails und Fallstricken. <br><br><img src="https://habrastorage.org/webt/6x/ai/-j/6xai-jeiycantp_i5sdieoiglzc.jpeg"><br><br>  Der Artikel basiert auf einem Bericht von Dmitry ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dbezheckov</a> ) Bezhetskov und Vladimir ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">volodyabo</a> ) Anufrienko mit HolyJS 2018 Piter.  Unter dem Schnitt finden Sie Video- und Textabschriften des Berichts. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1zWUN6y2WbI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Teil 1. Elbrus, urspr√ºnglich aus Russland </h2><br>  Zuerst werden wir verstehen, was Elbrus ist.  Hier sind einige wichtige Funktionen dieser Plattform im Vergleich zu x86. <br><br><h3>  VLIW-Architektur </h3><br>  Eine v√∂llig andere architektonische L√∂sung als die superskalare Architektur, die derzeit auf dem Markt √ºblich ist.  Mit VLIW k√∂nnen Sie Absichten im Code feiner ausdr√ºcken, da alle unabh√§ngigen Arithmetik-Logik-Ger√§te (ALUs) explizit gesteuert werden, √ºber die Elbrus √ºbrigens verf√ºgt. 4. Dies schlie√üt die M√∂glichkeit von Ausfallzeiten einiger ALUs nicht aus, erh√∂ht jedoch die theoretische Leistung um einen Taktzyklus der Prozessor. <br><br><h3>  Teamb√ºndelung </h3><br>  Bereit Prozessorbefehle werden in Bundles (Bundles) zusammengefasst.  Ein Bundle ist eine gro√üe Anweisung, die pro bedingter Uhr ausgef√ºhrt wird.  Es enth√§lt viele atomare Anweisungen, die unabh√§ngig und unmittelbar in der Elbrus-Architektur ausgef√ºhrt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e77/da3/ebc/e77da3ebc083c57d019b34bbc58483af.png"><br><br>  Im Bild rechts geben die grauen Rechtecke die B√ºndel an, die durch Verarbeiten des JS-Codes links erhalten wurden.  Wenn mit den Anweisungen ldd, fmuld, faddd, fsqrts alles ungef√§hr klar ist, ist die return-Anweisung ganz am Anfang des ersten Bundles f√ºr Leute √ºberraschend, die mit dem Elbrus-Assembler nicht vertraut sind.  Diese Anweisung l√§dt die R√ºcksprungadresse von der aktuellen floatMath-Funktion vorab in das ctpr3-Register, damit der Prozessor die erforderlichen Anweisungen herunterladen kann.  Dann machen wir im letzten Bundle bereits den √úbergang zur vorinstallierten Adresse in ctpr3. <br><br>  Es ist auch erw√§hnenswert, dass Elbrus viel mehr Register 192 + 32 + 32 hat als 16 + 16 + 8 f√ºr x86. <br><br><h3>  Explizite spekulative versus implizite </h3><br>  Elbrus unterst√ºtzt explizite Spekulativit√§t auf Befehlsebene.  Daher k√∂nnen wir a.bar aufrufen und aus dem Speicher laden, noch bevor wir √ºberpr√ºfen, ob es nicht null ist, wie im Code auf der rechten Seite zu sehen ist.  Wenn sich das logische Lesen am Ende als ung√ºltig herausstellt, wird der Wert in b einfach als Hardware als falsch markiert und es ist nicht m√∂glich, darauf zuzugreifen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/822/ec0/bcb/822ec0bcbb07ec7cff3a3e35656ef99e.png"><br><br><h3>  Unterst√ºtzung f√ºr bedingte Ausf√ºhrung </h3><br>  Elbrus unterst√ºtzt auch die bedingte Ausf√ºhrung.  Betrachten Sie dies im folgenden Beispiel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a34/39b/005/a3439b00564ddec3a66383e76bb58b96.png"><br><br>  Wie wir sehen k√∂nnen, wird der Code aus dem vorherigen Beispiel √ºber Spekulativit√§t auch aufgrund der Verwendung der Faltung des bedingten Ausdrucks in Abh√§ngigkeit reduziert, nicht durch Kontrolle, sondern durch Daten.  Die Elbrus-Hardware unterst√ºtzt Pr√§dikatregister, in denen Sie nur zwei wahre oder falsche Werte speichern k√∂nnen.  Ihr Hauptmerkmal ist, dass Sie Anweisungen mit einem solchen Pr√§dikat markieren k√∂nnen. Abh√§ngig von ihrem Wert zum Zeitpunkt der Ausf√ºhrung wird die Anweisung ausgef√ºhrt oder nicht.  In diesem Beispiel f√ºhrt der Befehl cmpeq den Vergleich durch und f√ºgt sein logisches Ergebnis in das Pr√§dikat P1 ein, das dann als Marker verwendet wird, um den Wert von b in das Ergebnis zu laden.  Wenn das Pr√§dikat gleich true war, blieb dementsprechend der Wert 0 im Ergebnis. <br><br>  Mit diesem Ansatz k√∂nnen Sie ein ziemlich komplexes Programmsteuerungsdiagramm in eine Pr√§dikatausf√ºhrung umwandeln und dementsprechend die F√ºlle des Bundles erh√∂hen.  Jetzt k√∂nnen wir unabh√§ngigere Teams unter verschiedenen Pr√§dikaten generieren und sie mit B√ºndeln f√ºllen.  Elbrus unterst√ºtzt 32 Pr√§dikatregister, mit denen Sie 65 Kontrollfl√ºsse codieren k√∂nnen (plus eines f√ºr das Fehlen eines Pr√§dikats im Befehl). <br><br><h3>  Drei Hardware-Stacks im Vergleich zu einem in Intel </h3><br>  Zwei davon sind vor √Ñnderungen durch den Programmierer gesch√ºtzt.  Einer - der Kettenstapel - ist f√ºr das Speichern von Adressen f√ºr R√ºckgaben von Funktionen verantwortlich, der andere - der Registerstapel - enth√§lt die Parameter, durch die sie √ºbergeben werden.  Der dritte - Benutzerstapel - speichert Benutzervariablen und Daten.  In Intel wird alles auf einem Stapel gespeichert, was zu Sicherheitsl√ºcken f√ºhrt, da sich alle Adressen von √úberg√§ngen und Parametern an einem Ort befinden, der nicht durch √Ñnderungen durch den Benutzer gesch√ºtzt ist. <br><br><h3>  Kein dynamischer Verzweigungspr√§diktor </h3><br>  Stattdessen wird ein Schema mit if-Konvertierungs- und √úbergangsvorbereitungen verwendet, damit die Ausf√ºhrungspipeline nicht gestoppt wird. <br><br><h3>  Warum brauchen wir JS auf Elbrus? </h3><br><ol><li>  Substitution importieren. <br></li><li>  Elbrus 'Einf√ºhrung in den Heimcomputermarkt, wo Javascript bereits f√ºr denselben Browser ben√∂tigt wird. <br></li><li>  Elbrus wird in der Branche bereits ben√∂tigt, zum Beispiel mit Node.js.  Daher m√ºssen Sie Node auf diese Architektur portieren. <br></li><li>  Die Entwicklung der Architektur von Elbrus sowie Spezialisten auf diesem Gebiet. <br></li></ol><br><h3>  Wenn es keinen Interpreter gibt, kommen zwei Compiler </h3><br>  Die vorherige Implementierung von v8 von Google wurde als Grundlage genommen.  Das funktioniert so: Aus dem Quellcode wird ein abstrakter Syntaxbaum erstellt. Je nachdem, ob der Code ausgef√ºhrt wurde oder nicht, wird mit einem der beiden Compiler (Crankshaft oder FullCodegen) optimierter oder nicht optimierter Bin√§rcode erstellt.  Es gibt keinen Dolmetscher. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/569/0ab/9f1/5690ab9f1edaf8273f6fe62b64110d27.png"><br><br><h3>  Wie funktioniert FullCodegen? </h3><br>  Die Knoten des Syntaxbaums werden in Bin√§rcode √ºbersetzt, wonach alles ‚Äûzusammengeklebt‚Äú wird.  Ein Knoten besteht aus ungef√§hr 300 Codezeilen in einem Makroassembler.  Dies bietet zum einen einen weiten Horizont an Optimierungen, zum anderen gibt es keine Bytecode-√úberg√§nge wie beim Interpreter.  Es ist einfach, aber gleichzeitig gibt es ein Problem - w√§hrend der Portierung m√ºssen Sie viel Code im Makro-Assembler neu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b8/38c/79a/6b838c79ab83cd76a498d82bf4ac3884.png"><br><br>  Trotzdem wurde dies alles getan und das Ergebnis war eine FullCodegen 1.0-Compilerversion f√ºr Elbrus.  Alles wurde √ºber C ++ Runtime v8 erledigt, sie haben nichts optimiert, der Assembler-Code wurde einfach von x86 in die Elbrus-Architektur umgeschrieben. <br><br><h3>  Codegen 1.1 </h3><br>  Infolgedessen war das Ergebnis nicht ganz das gleiche wie erwartet, und es wurde beschlossen, FullCodegen 1.1 zu ver√∂ffentlichen: <br><br><ul><li>  Weniger Laufzeit gemacht, auf einem Makro-Assembler geschrieben; <br></li><li>  Manuelle if-Konvertierungen hinzugef√ºgt (in der Abbildung wird als Beispiel die Variable js auf wahr oder falsch gepr√ºft); <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/588/974/2f1/5889742f19fa70280dcb5665e1e733d8.png"><br><br>  Beachten Sie, dass die √úberpr√ºfung auf NaN, undefiniert, null, gleichzeitig erfolgt, ohne if zu verwenden, was in der Intel-Architektur erforderlich w√§re. <br><br><ul><li>  Der Code wurde nicht nur mit Intel neu geschrieben, sondern auch in Spekulationen spekulativ implementiert und auch √ºber MAsm (Macro Assembler) als Fast-Path implementiert. <br></li></ul><br>  Tests wurden in Google Octane durchgef√ºhrt.  Pr√ºfmaschinen: <br><br><ul><li>  Elbrus: E2S 750 MHz, 24 GB <br></li><li>  Intel: Core i7 3,4 GHz, 16 GB <br></li></ul><br>  Weitere Ergebnisse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/922/ff5/fb4922ff553518321227b4a0c57f91bd.png"><br><br>  Auf dem Histogramm ist das Verh√§ltnis der Ergebnisse, d.h.  Wie oft ist Elbrus schlimmer als Intel?  Bei zwei Tests, Crypto und zlib, sind die Ergebnisse deutlich schlechter, da Elbrus noch keine Hardwareanweisungen f√ºr die Arbeit mit Verschl√ºsselung hat.  Im Allgemeinen fiel es angesichts der unterschiedlichen Frequenzen ziemlich gut aus. <br><br>  Das Folgende ist ein Test im Vergleich zum js-Interpreter von Firefox, der Teil der Standardverteilung von Elbrus ist.  Mehr ist besser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ab/c77/0d4/0abc770d4a1717ca18156070f0b762a4.png"><br>  Fazit - der Compiler hat wieder gute Arbeit geleistet. <br><br><h3>  Entwicklungsergebnisse </h3><br><ul><li>  Die neue JS-Engine hat test262-Tests bestanden.  Dies gibt ihm das Recht, als vollwertige Laufzeitumgebung ECMAScript 262 bezeichnet zu werden. <br></li><li>  Die Produktivit√§t stieg im Vergleich zum vorherigen Motor - dem Dolmetscher - im Durchschnitt um das F√ºnffache. <br></li><li>  Node.js 6.10 wurde auch als Beispiel f√ºr die Verwendung von V8 portiert, da dies nicht schwierig war. <br></li><li>  Es ist jedoch immer noch siebenmal schlechter als Core i7 auf FullCodegen. <br></li></ul><br><h3>  Nichts schien darauf hinzudeuten </h3><br>  Alles w√§re in Ordnung, aber hier hat Google angek√ºndigt, dass es FullCodegen und Crankshaft nicht mehr unterst√ºtzt und sie werden gel√∂scht.  Danach erhielt das Team einen Entwicklungsauftrag f√ºr den Firefox-Browser und dazu sp√§ter mehr. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d7/f15/543/9d7f155439ad3b1436ebc4cc9c59d50a.png"><br><br><h2>  Teil 2. Firefox und sein Klammeraffe </h2><br>  Es geht um die Firefox-Browser-Engine - SpiderMonkey.  In der Abbildung sind die Unterschiede zwischen diesem Motor und dem neueren V8. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/301/274/c9130127464ac436103ab6e8ed8c187d.png"><br><br>  Es ist ersichtlich, dass in der ersten Phase alles so aussieht, als w√ºrde der Quellcode in einen abstrakten Syntaxbaum, dann in Bytecode analysiert, und dann beginnen die Unterschiede. <br><br>  In SpiderMonkey wird der Bytecode vom C ++ - Interpreter interpretiert, der im Wesentlichen einem gro√üen Schalter √§hnelt, innerhalb dessen Bytecodespr√ºnge ausgef√ºhrt werden.  Ferner gelangt der interpretierte Code in die neotimisierende Compiler-Baseline.  In der letzten Phase wird dann der optimierende Compiler Ion in den Fall aufgenommen.  In der V8-Engine wird der Bytecode vom Ingnition-Interpreter und dann vom TurboFan-Compiler verarbeitet. <br><br><h3>  Baseline, ich w√§hle dich! </h3><br>  Die Portierung wurde mit dem Baseline-Compiler gestartet.  Es ist im Wesentlichen eine gestapelte Maschine.  Das hei√üt, es gibt einen bestimmten Stapel, aus dem er Variablen entnimmt, sich diese merkt und einige Aktionen mit ihnen ausf√ºhrt. Danach gibt er sowohl die Variablen als auch die Ergebnisse der Aktionen an die Zellen des Stapels zur√ºck.  Nachfolgend in einigen Bildern wird dieser Mechanismus in Bezug auf die einfache Funktion foo Schritt f√ºr Schritt gezeigt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4a/8fb/d66/d4a8fbd66d65c39e23a22ed8c21b844e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/744/c7a/927/744c7a92704b61ec0063a5223de84bda.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdd/0bb/b3f/fdd0bbb3f000f2738af72ee77afbc719.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfe/b02/db2/cfeb02db22e24368fca8632db5cf93f2.png"><br><br><h3>  Was ist ein Rahmen? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/4a8/386/e3c/4a8386e3c926b0175dcd7508cfbd0783.png"><br><br>  In den Bildern oben sehen Sie den Wortrahmen.  Grob gesagt ist dies ein Javascript-Kontext auf Hardware, dh ein Datensatz auf dem Stapel, der eine Ihrer Funktionen beschreibt.  In der Abbildung unten ist die Funktion foo und rechts davon sieht sie auf dem Stapel aus: Argumente, Beschreibung der Funktion, R√ºcksprungadresse, Angabe des vorherigen Frames, da die Funktion von irgendwoher aufgerufen wurde und um korrekt zum Ort des Aufrufs zur√ºckzukehren, sollten diese Informationen gespeichert werden Stapel und dann lokale Variablen selbst Funktionen und Operanden f√ºr Berechnungen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14d/c18/a75/14dc18a750ddcddf752bc1ed53a6eed0.png"><br><br>  Somit sind die <b>Vorteile von Baseline</b> : <br><br><ul><li>  Sieht aus wie FullCodegen, daher hat sich seine Portierungserfahrung als n√ºtzlich erwiesen. <br></li><li>  Portieren Sie den Assembler und holen Sie sich einen funktionierenden Compiler. <br></li><li>  Es ist bequem zu debuggen; <br></li><li>  Jeder Stub kann umgeschrieben werden. <br></li></ul><br>  Es gibt aber auch <b>Nachteile</b> : <br><br><ul><li>  Linearer Code, bis Sie einen Bytecode ausf√ºhren, k√∂nnen Sie Folgendes nicht ausf√ºhren, was f√ºr Architekturen mit parallelem Rechnen nicht sehr gut ist. <br></li><li>  Da es mit Bytecode funktioniert, optimieren Sie nicht wirklich. <br></li></ul><br>  Es blieb nur noch, den Makro-Assembler zu implementieren und einen vorgefertigten Compiler zu erhalten.  Das Debuggen war kein gutes Zeichen, es reichte aus, den Stapel auf der x86-Architektur und dann den Stapel zu betrachten, der beim Portieren erhalten wurde, um das Problem zu finden. <br><br>  Bei Tests mit dem neuen Compiler hat sich die Produktivit√§t verdreifacht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79e/20b/20b/79e20b20b8126f69cd9031c406af0da0.png"><br><br>  Octane unterst√ºtzt jedoch keine Ausnahmen.  Und ihre Umsetzung ist sehr wichtig. <br><br><h3>  Au√üergew√∂hnliche Arbeit </h3><br>  Lassen Sie uns zun√§chst sehen, wie Ausnahmen unter x86 funktionieren.  W√§hrend das Programm ausgef√ºhrt wird, werden die R√ºcksprungadressen der Funktionen in den Stapel geschrieben.  Irgendwann tritt eine Ausnahme auf.  Wir √ºbergeben an den Laufzeitausnahmehandler, der die oben genannten Frames verwendet.  Wir finden heraus, wo genau die Ausnahme aufgetreten ist. Danach m√ºssen wir den Stapel in den gew√ºnschten Zustand zur√ºckspulen, und dann √§ndert sich die R√ºcksprungadresse in die Adresse, in der die Ausnahme verarbeitet wird. <br><br>  Das Problem ist, dass dies aufgrund eines anderen Stapelger√§ts in der Elbrus-Architektur nicht funktioniert.  Durch Systemaufrufe muss berechnet werden, wie viel Sie im Kettenstapel zur√ºckspulen m√ºssen.  Als n√§chstes f√ºhren wir einen Systemaufruf durch, um den Aufrufstapel abzurufen.  Als n√§chstes ersetzen wir in der Adresse im Kettenstapel die Adresse, die die R√ºckgabe vornimmt. <br><br>  Unten sehen Sie eine Darstellung der Abfolge dieser Schritte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21e/288/52b/21e28852b593e04e9712f55ced7484a5.png"><br><br>  Nicht der schnellste Weg, jedoch wird die Ausnahme behandelt.  Trotzdem sieht es bei Intel etwas einfacher aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4d/e44/ee6/f4de44ee6d999e24e8a275b027c4442e.png"><br><br>  Mit Elbrus wird es mehr Spr√ºnge zum Handler geben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cc/239/b1f/8cc239b1f908dc1ab6c02953ef7641d9.png"><br>  Deshalb sollten Sie die Programmlogik nicht auf Ausnahmen st√ºtzen, insbesondere nicht auf Elbrus. <br><br><h3>  Optimiere es! </h3><br>  Die Ausnahmebehandlung ist also implementiert.  Jetzt erz√§hlen wir Ihnen, wie wir alles etwas schneller gemacht haben: <br><br><ul><li>  Inline-Caches neu geschrieben; <br></li></ul><br><ul><li>  Manuelle (und dann automatische) Anordnung der Verz√∂gerungen; <br></li><li>  Sie haben Vorbereitungen f√ºr √úberg√§nge getroffen (h√∂her im Code): Je fr√ºher der √úbergang vorbereitet wird, desto besser; <br></li><li>  Unterst√ºtzter inkrementeller Garbage Collector <br></li></ul><br>  Der zweite Absatz wird etwas detaillierter behandelt.  Wir haben bereits ein kleines Beispiel f√ºr die Arbeit mit Bundles untersucht und werden darauf eingehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/805/722/9dd/8057229ddec6aa5091fa132de5506a9a.png"><br><br>  Eine Operation, zum Beispiel das Laden, wird nicht in einem Zyklus ausgef√ºhrt, in diesem Fall in drei Zyklen.  Wenn wir also zwei Zahlen multiplizieren m√∂chten, haben wir die Multiplikationsoperation eingegeben, aber die Operanden selbst sind noch nicht geladen. Der Prozessor kann nur warten, bis sie geladen sind.  Und er wird auf eine bestimmte Anzahl von Ma√ünahmen warten, ein Vielfaches von vier.  Wenn Sie die Verz√∂gerung jedoch manuell einstellen, kann die Wartezeit verk√ºrzt werden, wodurch die Leistung verbessert wird.  Ferner wurde der Prozess der Anordnung der Verz√∂gerungen automatisiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af7/721/cba/af7721cba060984416301fb89004a502.png"><br><br>  Ergebnisse der Optimierung BaseLine v1.0 vs Baseline v1.1.  Klar, der Motor ist schneller geworden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f3/d34/6cf/8f3d346cf9c1731bff2d85d0e52df5eb.png"><br><br><h3>  Wie k√∂nnen Programmierer keine Ionenpistole herstellen? </h3><br>  Auf der Erfolgswelle der Implementierung von Baseline v1.1 wurde beschlossen, den optimierenden Compiler Ion zu portieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b97/887/d35/b97887d35eae9e30d300fa7d60b24942.png"><br><br>  Wie funktioniert der optimierende Compiler?  Der Quellcode wird interpretiert, die Kompilierung gestartet.  W√§hrend der Ausf√ºhrung des Bytecodes sammelt Ion Daten zu den im Programm verwendeten Typen und zur Analyse von ‚ÄûHot-Funktionen‚Äú, die h√§ufiger als andere ausgef√ºhrt werden.  Danach wird die Entscheidung getroffen, sie besser zu kompilieren, zu optimieren.  Als n√§chstes wird eine allgemeine Darstellung des Compilers, ein Operationsgraph, erstellt.  Der Graph wird optimiert (opt 1, opt 2, opt ...), es wird eine Darstellung auf niedriger Ebene erstellt, die aus Maschinenbefehlen besteht, Register werden reserviert, ein direkt optimierter Bin√§rcode wird generiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/294/80d/48a/29480d48a92487c40bd4a7de91c7b1ef.png"><br><br>  Es gibt mehr Register auf Elbrus und die Teams selbst sind gro√ü, deshalb brauchen wir: <br><br><ul><li>  Teamplaner <br></li><li>  Eigener Registerverteiler; <br></li><li>  Eigenes LIR (Low-Level Intermediate Representation); <br></li><li>  Eigener Code-Generator. <br></li></ul><br>  Das Team hatte bereits Erfahrung mit der Portierung von Java nach Elbrus. Es entschied sich, dieselbe Bibliothek f√ºr die Codegenerierung f√ºr die Portierung von Ion zu verwenden.  Sie hei√üt TANGO.  Es hat: <br><br><ul><li>  Teamplaner <br></li><li>  Eigener Registerverteiler; <br></li><li>  Optimierungen auf niedriger Ebene. <br></li></ul><br>  Es bleibt eine hochrangige Darstellung in TANGO einzuf√ºhren, um eine Auswahl zu treffen.  Das Problem ist, dass die Ansicht auf niedriger Ebene in TANGO wie ein Assembler ist, der schwer zu warten und zu debuggen ist.  Wie soll der Compiler innen aussehen?  Zum besseren Verst√§ndnis hat Mozilla einen eigenen HolyJit-Compiler erstellt. Es besteht auch die M√∂glichkeit, eine eigene Minisprache f√ºr die √úbersetzung zwischen einer Darstellung auf hoher und niedriger Ebene zu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a3/6b2/94b/0a36b294b7fb8241b5be77a22a4d0e09.png"><br><br>  Die Entwicklung ist noch im Gange.  Gut und weiter dar√ºber, wie man es nicht mit Optimierung √ºbertreibt. <br><br><h2>  Teil 3. Das Beste ist der Feind des Guten </h2><br><h3>  Zusammenstellung wie sie ist </h3><br>  Der Optimierungsprozess in Ion ist gierig, wenn sich der Code erw√§rmt und dann kompiliert und optimiert. Dies ist im folgenden Beispiel zu sehen. <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{
 &nbsp;<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{
 &nbsp;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1100</span></span>; ++i) {
 &nbsp;&nbsp;&nbsp;print(foo(obj,obj));
 &nbsp;}
}

doSomeStuff(<span class="hljs-string"><span class="hljs-string">"HollyJS"</span></span>);
doSomeStuff({<span class="hljs-attr"><span class="hljs-attr">n</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>});
</code></pre><br>
   JS Shell    (  ), &nbsp;&nbsp;   Mozilla,   :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7ab/cdb/646/7abcdb646a834281b059d5a418d659c2.png"><br>
<br>
 .  ,     ,   -     bailout ().  ,   .      foo     object,           ,     ,        .    ,  :<br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomeStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{
 &nbsp;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1100</span></span>; ++i) {
 &nbsp;&nbsp;&nbsp;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment"><span class="hljs-comment">// bailout</span></span>
 &nbsp;&nbsp;&nbsp;print(foo_only_str(obj, obj));
 &nbsp;}
}
</code></pre><br>
         ,            .<br>
<br>
       .   ,         ,   DCE.<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/677/41e/90f/67741e90f8b4e89225a55ab86c434601.png"><br>
<br>
<h2> </h2><br>
       ,  ,        ,          .<br>
<br>
   ,   ,    ,  SpiderMonkey  Resume Point. -   ,     .     ,       baseline .   ,   runtime   ,    .   lowering, regAlloc,     (snapshot),   ,    .      baseline .<br>
<br>
   :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd4/449/349/bd444934928405be1d22ecefc3926427.png"><br>
<br>
 runtime  x86    : ,        .        .  ,       ,    ,    ,      ,    . ,      ,   Type .   :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b39/e8a/1ca/b39e8a1ca896a3550e80405177ccbf48.png"><br>
<br>
    ,       ,           chain . ,     ,  . <br>
<br>
    :    ,       chain-,    N ,    ,         baseline,         . &nbsp;<br>
<br>
    ,        .<br>
<br>
    :<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f3/684/575/6f3684575e08d56fb5eaf64cede1e3c3.png"><br>
<br>
    Ion  4-            baseline.     :<br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9e6/325/b40/9e6325b406a27d6cdfee2ab2a9409488.png"><br>
<br>
<h2></h2><br>
,   ,     SpiderMonkey, V8  Node.    ‚Äî  .     . <br>
<br>
      .       ,   ,      chain-.<br>
<br>
<blockquote>  ,  : 24-25      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS</a>,      .      ‚Äî  ,      .</blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419155/">https://habr.com/ru/post/de419155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419145/index.html">Fintech Digest: Apples Kapitalisierung √ºberstieg 1 Billion US-Dollar. AI half eBay dabei, den Umsatz um Milliarden zu steigern</a></li>
<li><a href="../de419147/index.html">1000-dimensionaler W√ºrfel: Ist es heute m√∂glich, ein Rechenmodell des menschlichen Ged√§chtnisses zu erstellen?</a></li>
<li><a href="../de419149/index.html">Leitfaden f√ºr Mikrotik RoMON</a></li>
<li><a href="../de419151/index.html">Smart Home: Eine neue Dimension des Komforts und das Streben nach Spitzenleistungen. Teil zwei</a></li>
<li><a href="../de419153/index.html">Cyborg Rights Memorandum</a></li>
<li><a href="../de419159/index.html">JS-Code, r√∂mische Ziffern, geometrische R√§tsel: Wie wir unser Alter verschl√ºsseln</a></li>
<li><a href="../de419161/index.html">Modellierung der Wasseroberfl√§che mit FFT und NeuroMatrix DSP-Prozessor</a></li>
<li><a href="../de419165/index.html">Wir senden "anonyme" SMS von der Konsole an die gew√ºnschte Nummer mit dem Bytehand- und C ++ - Dienst</a></li>
<li><a href="../de419169/index.html">"Welt des Wilden Westens" mit den Augen des Entwicklers</a></li>
<li><a href="../de419171/index.html">Deaktivieren der Laufzeitstatuspr√ºfung in einer Android-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>