<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗯️ 🚏 👉🏻 Negara global: mengapa dan bagaimana cara menghindarinya ✋🏿 🐤 🧚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kondisi global. Ungkapan ini menyebabkan rasa takut dan sakit di hati setiap pengembang yang memiliki ketidakberuntungan menghadapi fenomena ini. Pern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Negara global: mengapa dan bagaimana cara menghindarinya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454946/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/il/xm/yl/ilxmyllyrjl50zu_shop-i-3fus.jpeg"></div><br>  Kondisi global.  Ungkapan ini menyebabkan rasa takut dan sakit di hati setiap pengembang yang memiliki ketidakberuntungan menghadapi fenomena ini.  Pernahkah Anda menemui perilaku aplikasi yang tidak terduga, tidak memahami alasannya, seperti seorang kesatria yang tidak bahagia yang mencoba membunuh Hydra dengan banyak kepala?  Anda berakhir dalam siklus coba-coba tanpa akhir, 90% dari waktu bertanya-tanya apa yang terjadi? <br><br>  Semua ini bisa menjadi konsekuensi menjengkelkan global: variabel tersembunyi yang mengubah keadaan mereka di tempat yang tidak diketahui, karena alasan yang belum Anda ketahui. <br><a name="habracut"></a><br>  Apakah Anda suka berkeliaran di kegelapan saat Anda mencoba mengubah aplikasi?  Tentu saja saya tidak menyukainya.  Untungnya, saya punya lilin untuk Anda: <br><br><ol><li>  Pertama, saya akan menggambarkan apa yang paling sering kita sebut negara global.  Istilah ini tidak selalu digunakan secara akurat, oleh karena itu memerlukan klarifikasi. <br></li><li>  Selanjutnya, kita akan mengetahui mengapa global berbahaya bagi basis kode kita. <br></li><li>  Kemudian saya akan menjelaskan bagaimana cara memangkas ruang lingkup global untuk mengubahnya menjadi variabel lokal. <br></li><li>  Akhirnya, saya akan berbicara tentang enkapsulasi dan mengapa perang salib terhadap variabel global hanyalah bagian dari masalah besar. <br></li></ol><br>  Saya harap artikel ini menjelaskan semua yang perlu Anda ketahui tentang negara global.  Jika Anda berpikir bahwa saya telah sangat merindukan dan Anda membenci saya untuk ini dan tidak ingin melihat saya lagi, tulis tentang itu di komentar.  Ini akan menyenangkan bagi saya, pembaca saya dan semua orang yang tiba-tiba muncul di halaman ini. <br><br>  Apakah Anda siap, pembaca yang budiman, untuk menunggang kuda dan mengenal musuh Anda?  Temukan global ini dan buat mereka merasakan baja pedang kita! <br><br><h1>  Apa itu kondisi? </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/7dd/561/59c/7dd56159c2c3d32176e249ea71ed13ad.jpg"><br><br>  Mari kita mulai dengan dasar-dasar sehingga Anda pengembang saling memahami. <br><br>  Suatu negara adalah definisi dari suatu sistem atau entitas.  Negara ditemukan dalam kehidupan nyata: <br><br><ul><li>  Saat komputer dimatikan, statusnya dimatikan. <br></li><li>  Ketika secangkir teh panas, kondisinya panas. <br></li></ul><br>  Dalam pengembangan perangkat lunak, beberapa konstruksi (seperti variabel) mungkin memiliki status.  Katakanlah string "halo" atau angka 11 tidak dianggap sebagai negara, melainkan nilai.  Mereka menjadi keadaan ketika mereka dilampirkan ke variabel dan ditempatkan di memori. <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// No state here! $lala = "hello"; // The variable $lala has the state 'hello'.</span></span></code> </pre> <br>  Dua jenis negara dapat dibedakan: <br><br>  Status variabel: setelah inisialisasi mereka, mereka dapat berubah selama eksekusi aplikasi Anda kapan saja. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $lala = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Initialisation of the variable. $lala = "hallo"; // The state of the variable $lala can be changed at runtime.</span></span></code> </pre> <br>  Status yang tidak dapat diubah: tidak dapat berubah selama eksekusi.  Anda menetapkan status pertama ke variabel Anda, dan nilainya tidak kemudian berubah.  "Konstanta" dalam kehidupan sehari-hari disebut sebagai contoh keadaan abadi: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">"GREETING"</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Constant definition. echo GREETING; GREETING = "hallo"; // This line will produce an error!</span></span></code> </pre> <br>  Sekarang mari kita dengarkan percakapan hipotetis antara Denis dan Vasily, sesama pengembang Anda: <br><br>  - Dan!  Anda telah membuat variabel global di mana-mana!  Mereka tidak dapat diubah tanpa semuanya melanggar!  Aku akan membunuhmu! <br>  - Nifiga, Vasek!  Nasib global saya luar biasa!  Saya memasukkan jiwa saya ke dalamnya, ini adalah karya agung!  Saya mengagumi para global saya! <br><br>  Paling sering, pengembang memanggil negara global, variabel global, atau global apa yang mereka sebut negara bisa berubah global.  Yaitu, status yang dapat dimodifikasi dalam lingkup terbesar yang tersedia untuk Anda: di seluruh aplikasi. <br><br>  Ketika suatu variabel tidak memiliki seluruh aplikasi sebagai ruang lingkup, kita berbicara tentang variabel lokal, atau lokal.  Mereka ada di beberapa area visibilitas tertentu, kurang dari area seluruh aplikasi. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Ecommerce</span></span>; $global = <span class="hljs-string"><span class="hljs-string">"I'm a mutable global variable!"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// global variable class Shipment { public $warehouse; // local variable existing in the whole class public function __construct() { $info = "You're creating a shipment object!"; // local variable bound to the constructor scope echo $info; } } class Product { public function __construct() { global $global; $global = "I change the state now 'cause I can!"; echo "You're creating a product object!"; // no state here } }</span></span></code> </pre> <br>  Anda mungkin berpikir: betapa mudahnya memiliki variabel yang dapat Anda akses dari mana saja dan mengubahnya!  Saya dapat mentransfer status dari satu bagian aplikasi ke yang lain!  Tidak perlu melewati mereka melalui fungsi dan menulis begitu banyak kode!  Salam, keadaan global yang bisa berubah! <br><br>  Jika Anda benar-benar berpikir begitu, saya sangat merekomendasikan untuk terus membaca. <br><br><h1>  Negara-negara global lebih buruk daripada wabah dan kolera? </h1><br><h2>  Diagram tautan terbesar </h2><br>  Fakta: akan lebih mudah bagi Anda untuk membuat diagram koneksi aplikasi yang akurat jika hanya berisi lokal dengan cakupan kecil dan pasti, tanpa global. <br><br>  Mengapa <br><br>  Katakanlah Anda memiliki aplikasi besar dengan variabel global.  Setiap kali Anda perlu mengubah sesuatu, Anda harus: <br><br><ul><li>  Ingatlah bahwa negara-negara global yang bisa berubah ini ada. <br></li><li>  Perkirakan apakah mereka akan memengaruhi ruang lingkup yang akan Anda ubah. <br></li></ul><br>  Biasanya Anda tidak perlu memikirkan variabel lokal yang ada di lingkup lain, tetapi apa pun yang Anda lakukan, Anda selalu perlu menjaga tempat di otak Anda yang lelah untuk keadaan global yang bisa berubah, karena mereka dapat mempengaruhi semua ruang lingkup. <br><br>  Selain itu, status global Anda yang dapat berubah dapat berubah di mana saja di aplikasi.  Orang biasanya bertanya-tanya seperti apa keadaan mereka saat ini.  Ini berarti bahwa Anda dipaksa untuk mencari di seluruh aplikasi, mencoba menghitung nilai-nilai global dalam ruang lingkup yang dapat dimodifikasi. <br><br>  Bukan itu saja.  Jika Anda perlu mengubah keadaan global, maka Anda tidak akan membayangkan ruang lingkup apa yang akan terpengaruh.  Apakah ini akan menyebabkan perilaku yang tidak terduga dari kelas, metode, atau fungsi lain?  Sukses dalam pencarian. <br><br>  Singkatnya, Anda menggabungkan semua kelas, metode, dan fungsi yang menggunakan status global yang sama.  Jangan lupa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketergantungan sangat meningkatkan kompleksitas</a> .  Apakah itu membuatmu takut?  Seharusnya begitu.  Area visibilitas khusus yang kecil sangat berguna: Anda tidak perlu mengingat seluruh aplikasi, cukup mengingat hanya area yang Anda gunakan. <br><br>  Orang tidak segera melacak sejumlah besar informasi.  Ketika kami mencoba melakukan ini, kami dengan cepat menghabiskan pasokan kemampuan kognitif, menjadi sulit bagi kami untuk berkonsentrasi, dan kami mulai membuat bug dan hal-hal bodoh.  Inilah sebabnya mengapa sangat tidak menyenangkan untuk bertindak dalam lingkup global aplikasi Anda. <br><br><h2>  Tabrakan Nama Global </h2><br>  Ada kesulitan menggunakan perpustakaan pihak ketiga.  Bayangkan Anda ingin menggunakan pustaka yang sangat keren yang secara acak mewarnai setiap karakter dengan efek flicker.  Impian setiap pengembang!  Jika perpustakaan ini juga menggunakan global yang memiliki nama yang sama dengan Anda, maka Anda akan menikmati tabrakan nama.  Aplikasi Anda akan macet dan Anda akan menebak alasannya, mungkin untuk waktu yang lama: <br><br><ul><li>  Pertama, Anda perlu mengetahui bahwa perpustakaan Anda menggunakan variabel global. <br></li><li>  Kedua, Anda perlu menghitung variabel mana yang digunakan selama eksekusi - milik Anda atau perpustakaan?  Tidak sesederhana itu, namanya sama! <br></li><li>  Ketiga, karena Anda tidak dapat mengubah perpustakaan sendiri, Anda harus mengubah nama variabel global yang dapat berubah.  Jika digunakan di seluruh aplikasi, Anda akan menangis. <br></li></ul><br>  Pada setiap tahap Anda akan merobek rambut Anda dari amarah dan keputusasaan.  Sebentar lagi Anda tidak lagi membutuhkan sisir.  Skenario ini tidak mungkin menggoda Anda.  Mungkin seseorang akan ingat bahwa pustaka JavaScript Mootools, Underscore, dan jQuery selalu berselisih satu sama lain jika mereka tidak ditempatkan di ruang lingkup yang lebih kecil.  Oh, dan objek <code>$</code> global terkenal di jQuery! <br><br><h2>  Pengujian akan berubah menjadi mimpi buruk </h2><br>  Jika saya belum meyakinkan Anda, mari kita lihat situasi dari sudut pandang pengujian unit: bagaimana Anda menulis tes di hadapan variabel global?  Karena tes dapat mengubah global, Anda tidak tahu tes apa yang sedang dilakukan.  Anda perlu mengisolasi tes satu sama lain, dan negara-negara global mengikatnya bersama. <br><br>  Pernahkah Anda memilikinya sehingga dalam tes isolasi berfungsi dengan baik, dan ketika Anda menjalankan seluruh paket, akankah mereka gagal?  Tidak  Dan saya memilikinya.  Setiap kali saya mengingat ini, saya menderita. <br><br><h2>  Masalah konkurensi </h2><br>  Status global variabel dapat menyebabkan banyak masalah jika Anda membutuhkan konkurensi.  Ketika Anda mengubah keadaan global dalam beberapa utas eksekusi, maka jungkir balik dalam kondisi yang kuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam lomba</a> . <br><br>  Jika Anda adalah pengembang PHP, maka ini tidak mengganggu Anda, kecuali jika Anda menggunakan perpustakaan yang memungkinkan Anda untuk membuat paralelisme.  Namun, ketika Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mempelajari bahasa baru</a> di mana paralelisme mudah diimplementasikan, saya harap Anda mengingat prosa saya. <br><br><h1>  Menghindari keadaan global yang bisa berubah </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/6df/acf/801/6dfacf801044e2e081ffd24ed7502a98.jpg"><br><br>  Walaupun negara-negara yang bisa berubah global dapat menyebabkan banyak masalah, mereka terkadang sulit untuk dihindari. <br><br>  Ambil REST API: titik akhir menerima semacam permintaan HTTP dengan parameter dan mengirim respons.  Parameter HTTP yang dikirim ke server ini dapat diminta di berbagai tingkat aplikasi Anda.  Sangat menggoda untuk membuat parameter ini mendunia saat menerima permintaan HTTP, memodifikasinya sebelum mengirim respons.  Tambahkan paralelisme di atas setiap permintaan, dan resep bencana siap. <br><br>  Negara yang bisa berubah global juga dapat secara langsung didukung dalam implementasi bahasa.  Misalnya, dalam PHP ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">superglobals</a> . <br><br>  Jika global datang dari suatu tempat, lalu bagaimana cara menghadapinya?  Bagaimana cara menolak aplikasi Denis, rekan pengembang Anda yang menciptakan global sedapat mungkin, karena dia belum membaca apa pun tentang pengembangan selama 20 tahun terakhir? <br><br><h2>  Argumen fungsi </h2><br>  Cara termudah untuk menghindari global adalah dengan mengirimkan variabel menggunakan argumen fungsi.  Ambil contoh sederhana: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Router</span></span>\<span class="hljs-title"><span class="hljs-title">HttpRequest</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Product</span></span>\<span class="hljs-title"><span class="hljs-title">ProductData</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Exceptions</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpRequest $httpReq)</span></span></span><span class="hljs-function"> </span></span>{ $productData = $httpReq-&gt;get(<span class="hljs-string"><span class="hljs-string">"productData"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;productModel-&gt;validateProduct($productData)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ValidationException(sprintf(<span class="hljs-string"><span class="hljs-string">"The product %d is not valid"</span></span>, $productData[<span class="hljs-string"><span class="hljs-string">"id"</span></span>])); } $product = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;productModel-&gt;createProduct($productData); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $productData)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function"> </span></span>{ $productData[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"SuperProduct"</span></span>.$productData[<span class="hljs-string"><span class="hljs-string">"name"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// This is not what you should do; I talk about it later in the article. try { $product = $this-&gt;productDao-&gt;find($productData["id"]); return product; } catch (NotFoundException $e) { $product = $this-&gt;productDao-&gt;save($productData); return $product; } } } class ProductDao { private $db; public function find(int $id): array { return $this-&gt;db-&gt;find(['product' =&gt; $id]); } public function save(array $productData): array { return $this-&gt;db-&gt;saveProduct($productData); } }</span></span></code> </pre> <br>  Seperti yang Anda lihat, <code>$productData</code> dari controller, melalui permintaan HTTP, melewati level yang berbeda: <br><br><ol><li>  Pengontrol menerima permintaan HTTP. <br></li><li>  Parameter diteruskan ke model. <br></li><li>  Parameter diteruskan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DAO</a> . <br></li><li>  Parameter disimpan dalam basis data aplikasi. <br></li></ol><br>  Kita bisa membuat array parameter ini global ketika kita mengambilnya dari permintaan HTTP.  Tampaknya sangat sederhana: tidak perlu mentransfer data ke 4 fungsi yang berbeda.  Namun, meneruskan parameter sebagai argumen ke fungsi: <br><br><ul><li>  Jelas akan menunjukkan bahwa fungsi-fungsi ini menggunakan <code>$productData</code> . <br></li><li>  Ini jelas akan menunjukkan fungsi mana yang menggunakan parameter mana.  Dapat dilihat bahwa untuk <code>ProductDao::find</code> dari <code>$productData</code> , hanya <code>$id</code> diperlukan, dan bukan segalanya. <br></li></ul><br>  Global membuat kode kurang dapat dipahami dan menghubungkan metode satu sama lain, yang merupakan harga yang sangat tinggi karena hampir tidak ada keuntungan. <br><br>  Anda sudah mendengar protes Denis: "Dan jika suatu fungsi memiliki tiga atau lebih argumen?  Jika Anda perlu menambahkan lebih banyak lagi, maka kompleksitas fungsi akan meningkat!  Dan bagaimana dengan variabel, objek, dan konstruksi lain yang diperlukan di mana-mana?  Apakah Anda akan meneruskannya ke setiap fungsi dalam aplikasi? " <br><br>  Pertanyaan itu adil, pembaca yang budiman.  Sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengembang yang baik</a> , Anda harus menjelaskan kepada Denis, menggunakan keterampilan komunikasi Anda, inilah yang: <br><br>  <i>“Denis, jika fungsi Anda memiliki terlalu banyak argumen, maka fungsi itu sendiri mungkin menjadi masalah.</i>  <i>Mereka mungkin melakukan terlalu banyak, bertanggung jawab atas terlalu banyak hal.</i>  <i>Anda tidak berpikir untuk membaginya menjadi fungsi yang lebih kecil? "</i>  . <br><br>  Merasa seperti seorang pembicara di Acropolis of Athens, Anda melanjutkan: <br><br>  <i>“Jika Anda membutuhkan variabel di banyak bidang visibilitas, maka ini merupakan masalah, dan segera kami akan membicarakannya.</i>  <i>Tetapi jika Anda benar-benar membutuhkannya, lalu apa yang salah dengan meneruskannya melalui argumen fungsi?</i>  <i>Ya, Anda harus mengetiknya di keyboard, tetapi kami adalah pengembang, tugas kami untuk menulis kode. "</i> <br><br>  Ini mungkin tampak lebih rumit ketika Anda memiliki lebih banyak argumen (mungkin memang demikian), tetapi saya ulangi, kelebihannya melebihi kerugiannya: lebih baik kodenya sejelas mungkin, dan tidak menggunakan status global yang bisa berubah yang tersembunyi. <br><br><h2>  Objek konteks </h2><br>  Objek kontekstual adalah objek yang berisi data yang ditentukan oleh beberapa konteks.  Biasanya, data ini disimpan sebagai pasangan kunci, seperti array asosiatif dalam PHP.  Objek seperti itu tidak memiliki perilaku, hanya data, mirip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan objek nilai</a> . <br><br>  Objek konteks dapat menggantikan keadaan global yang dapat berubah.  Kembali ke contoh kode sebelumnya.  Alih-alih mengirimkan data dari permintaan melalui level, kita dapat menggunakan objek yang merangkum data ini. <br><br>  Konteksnya adalah kueri itu sendiri: kueri lain - konteks lain - kumpulan data lain.  Kemudian objek konteks akan diteruskan ke metode apa pun yang membutuhkan data ini. <br><br>  Anda berkata: "Luar biasa dan semua itu, tapi apa manfaatnya?" <br><br><ul><li>  Data diringkas dalam suatu objek.  Paling sering, tugas Anda adalah membuat data tidak berubah, yaitu, sehingga Anda tidak dapat mengubah status - nilai data dalam objek setelah inisialisasi. <br></li><li>  Jelas, konteks membutuhkan data objek konteks, karena ditransfer ke semua fungsi (atau metode) yang membutuhkan data ini. <br></li><li>  Ini memecahkan masalah konkurensi: jika setiap permintaan memiliki objek konteksnya sendiri, Anda dapat dengan aman menulis atau membacanya di utas eksekusi mereka sendiri. <br></li></ul><br>  Tetapi segala sesuatu dalam pengembangan memiliki harga.  Objek konteks dapat berbahaya: <br><br><ul><li>  Melihat argumen fungsi, Anda tidak akan tahu data apa yang ada di objek konteks. <br></li><li>  Anda dapat meletakkan apa pun di objek konteks.  Berhati-hatilah untuk tidak memasukkan terlalu banyak, misalnya, seluruh sesi pengguna, atau bahkan sebagian besar data aplikasi Anda.  Dan kemudian ini bisa terjadi: <code>$context-&gt;getSession()-&gt;getUser()-&gt;getProfil()-&gt;getUsername()</code> .  Langgar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum Demeter</a> , dan kutukanmu akan menjadi kompleksitas yang gila. <br></li><li>  Semakin besar objek konteks, semakin sulit untuk menemukan data apa dan di mana ruang lingkup yang digunakannya. <br></li></ul><br>  Secara umum, saya akan menghindari menggunakan objek kontekstual sejauh mungkin.  Mereka dapat menyebabkan banyak keraguan.  Kekekalan data merupakan nilai tambah yang besar, tetapi kita tidak boleh melupakan kekurangannya.  Jika Anda menggunakan objek konteks, pastikan itu cukup kecil dan berikan ke lingkup yang kecil dan ditentukan dengan cermat. <br><br>  Jika sebelum menjalankan program Anda tidak tahu berapa banyak status yang akan diteruskan ke fungsi Anda (misalnya, parameter dari permintaan HTTP), maka objek konteks dapat bermanfaat.  Oleh karena itu, beberapa dari mereka menggunakannya, ingat, misalnya, objek <code>Request</code> di Symfony. <br><br><h2>  Injeksi Ketergantungan </h2><br>  Alternatif lain yang bagus untuk keadaan global yang bisa berubah adalah dengan menyematkan langsung data yang Anda butuhkan ke objek saat Anda membuatnya.  Ini adalah definisi injeksi ketergantungan: seperangkat teknik untuk menanamkan objek dalam komponen Anda (kelas). <br><br><h3>  Mengapa tepatnya injeksi ketergantungan? </h3><br>  Tujuannya adalah membatasi penggunaan variabel, objek, atau konstruksi lainnya, dan menempatkannya dalam ruang lingkup terbatas.  Jika Anda memiliki dependensi yang tertanam, dan karena itu hanya dapat bertindak dalam lingkup objek, maka akan lebih mudah bagi Anda untuk mengetahui dalam konteks mana mereka digunakan dan mengapa.  Tidak ada penderitaan dan siksaan! <br><br>  Ketergantungan injeksi membagi siklus hidup aplikasi menjadi dua fase penting: <br><br><ol><li>  Membuat objek aplikasi dan mengimplementasikan dependensinya. <br></li><li>  Gunakan objek untuk mencapai tujuan Anda. <br></li></ol><br>  Pendekatan ini membuat kode lebih jelas, Anda tidak perlu membuat instance segalanya di tempat acak, atau, lebih buruk lagi, menggunakan objek global di mana-mana. <br><br>  Banyak kerangka kerja menggunakan injeksi ketergantungan, kadang-kadang dalam skema yang cukup kompleks, dengan file konfigurasi dan Dependency Injection Container (DIC).  Tetapi sama sekali tidak perlu mempersulit hal-hal.  Anda cukup membuat dependensi di satu tingkat dan menerapkannya di tingkat yang lebih rendah.  Misalnya, di dunia Go, saya tidak tahu siapa pun yang akan menggunakan DIC.  Anda cukup membuat dependensi di file utama dengan kode (main.go), dan kemudian mentransfernya ke tingkat berikutnya.  Anda juga dapat instantiate segala sesuatu dalam paket yang berbeda untuk menunjukkan dengan jelas bahwa "fase injeksi ketergantungan" harus dilakukan hanya pada tingkat spesifik ini.  Di Go, lingkup paket bisa membuat segalanya lebih mudah daripada di PHP, di mana DIC digunakan secara luas dalam setiap kerangka kerja yang saya tahu, termasuk Symfony dan Laravel. <br><br><h3>  Implementasi melalui konstruktor atau setter </h3><br>  Ada dua cara untuk menyuntikkan dependensi: melalui konstruktor atau setter.  Saya menyarankan, jika mungkin, untuk tetap berpegang pada metode pertama: <br><br><ul><li>  Jika Anda perlu tahu apa dependensi kelas, yang harus Anda lakukan adalah menemukan konstruktor.  Tidak perlu mencari metode yang tersebar di seluruh kelas. <br></li><li>  Mengatur dependensi selama instalasi akan memberi Anda kepercayaan diri dalam keamanan menggunakan objek. <br></li></ul><br>  Mari kita bicara sedikit tentang poin terakhir: ini disebut "menegakkan invarian".  Dengan membuat instance objek dan mengimplementasikan dependensinya, Anda tahu bahwa apa pun yang dibutuhkan objek Anda, ia dikonfigurasikan dengan benar.  Dan jika Anda menggunakan setter, bagaimana Anda tahu bahwa dependensi Anda sudah ditetapkan pada saat menggunakan objek?  Anda dapat pergi ke tumpukan dan mencoba mencari tahu apakah setter dipanggil, tapi saya yakin Anda tidak ingin melakukan ini. <br><br><h1>  Pelanggaran enkapsulasi </h1><br>  Bagaimanapun, satu-satunya perbedaan antara negara-negara lokal dan global adalah cakupannya.  Mereka terbatas untuk negara bagian setempat, dan untuk global, seluruh aplikasi tersedia.  Namun, Anda mungkin mengalami masalah khusus untuk negara-negara global jika Anda menggunakan negara bagian.  Mengapa <br><br><h2>  Apakah Anda mengatakan enkapsulasi? </h2><br>  Menggunakan status global pada akhirnya akan memecah enkapsulasi, sama seperti Anda dapat memecahkannya dengan status lokal. <br><br>  Mari kita mulai dari awal.  Apa yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> katakan kepada kami tentang definisi enkapsulasi?  Mekanisme bahasa untuk membatasi akses langsung ke beberapa komponen objek.  Pembatasan akses?  Mengapa <br><br>  Seperti yang kita lihat di atas, jauh lebih mudah untuk berpikir dalam lingkup lokal daripada di global.  Negara yang bisa berubah global, menurut definisi, tersedia di mana-mana, dan ini bertentangan dengan enkapsulasi!  Tidak ada batasan akses untuk Anda. <br><br><h2>  Tumbuh ruang lingkup dan kebocoran negara </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/0a4/466/ed1/0a4466ed1a0cb8710127f819e160be0f.jpg"><br><br>  Mari kita bayangkan sebuah negara dalam lingkup kecilnya sendiri.  Sayangnya, seiring berjalannya waktu, aplikasi tumbuh, keadaan lokal ini dilewatkan sebagai argumen untuk fungsi di seluruh aplikasi.  Sekarang lokal Anda digunakan dalam banyak lingkup, dan di dalamnya semuanya akses langsung ke lokal tersebut diotorisasi.  Sekarang sulit bagi Anda untuk menghitung keadaan tepat lokal tanpa melihat ke semua area visibilitas di mana itu ada dan di mana ia dapat diubah.  Semua ini telah kita lihat dengan keadaan global yang bisa berubah. <br><br>  Ambil contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model Domain Anemik</a> dapat meningkatkan cakupan model yang bisa berubah-ubah.  Faktanya, Model Domain Anemik membagi data dan perilaku objek domain Anda menjadi dua kelompok: model (objek dengan data saja) dan layanan (objek hanya dengan perilaku).  Paling sering, model ini akan digunakan di semua layanan.  Oleh karena itu, ada kemungkinan bahwa beberapa model akan terus meningkatkan cakupannya.  Anda tidak akan mengerti model mana yang digunakan dalam konteks apa, keadaan mereka akan berubah, dan semua masalah yang sama akan menimpa Anda. <br><br>  Saya ingin menyampaikan ide penting: jika Anda menghindari keadaan global yang tidak bisa berubah, ini tidak berarti Anda bisa bersantai, memegang koktail di satu tangan, dan menekan tombol di tangan yang lain, menikmati hidup dan kode legendaris Anda. -, <a href="https://res.cloudinary.com/practicaldev/image/fetch/s--CWGA3Ax4--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/">    </a> ,  -,     ,           . <br><br>       ,       .   ,        . <br><br>     ?  -  .     ,         ,  -. <br><br> ,  -    ,    ,    .     ,      ,   —  .    ,   :       ,   .           .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br><h2>    </h2><br>            .      <code>Product</code> , ,   : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $productData)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function"> </span></span>{ $productData[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"SuperProduct"</span></span>.$productData[<span class="hljs-string"><span class="hljs-string">"name"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// This is not what you should do; I talk about it later in the article. try { $product = $this-&gt;productDao-&gt;find($productData["id"]); return product; } catch (NotFoundException $e) { $product = $this-&gt;productDao-&gt;save($productData); return $product; } } }</span></span></code> </pre> <br>  <code>$productData</code>   .      ,     ,      ,     . <br><br>         ,  .   ,   -   ?   ,        .         . <br><br>    ,       ,    .    . <br><br>   : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $productData)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Since $productData is passed to other variable, it has to be immutable. $name = "SuperProduct".$productData["name"]; try { $product = $this-&gt;productDao-&gt;find($productData["id"]); return product; } catch (NotFoundException $e) { $product = $this-&gt;productDao-&gt;save($name, $productData); return $product; } } }</span></span></code> </pre> <br>   ,      ,       <code>$productData</code> .  ,   .      <code>$productData</code>    ,    ,        HTTP-. <br><br>          ,    : «,     ». <br><br><h1>     ? </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/0cd/d30/a3f/0cdd30a3fbd1097b15e7f5457d3d5c55.jpg"><br><br>        . ,    . <br><br>    ? <br><br><ul><li>      ,      ,      . <br></li><li>  ,      ,        (,     ) . <br></li></ul><br>          .  ,      . <br><br>  ,  <code>ShipmentDelay</code>  , ,  ,     .   ,  -,   <code>ShipmentDelay</code>   ,    ,      ,     . ?    ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> DRY</a> . <br><br>           ,      ,     .       :      ,   ,        .  ,       ,    ,      .          ,    ,        . <br><br><h1>        ? </h1><br>  ,      (,   ),   ,    ,        .       ,    ,   ,    ,   . <br><br>    .  : <br><br><ul><li>        . <br></li><li>            ,     . <br></li><li>   —   :         ,    ,        . <br></li><li>     ,        . <br></li></ul><br>           .       ,       —      .  ,      . <br><br>   ,         ,  . <br><br>        ,   ,   .    ,        .  ,     ,     .  ,       ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454946/">https://habr.com/ru/post/id454946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454930/index.html">Pengumpulan sampah di V8: cara kerja Orinoco GC baru</a></li>
<li><a href="../id454936/index.html">Vivaldi: Pemblokiran iklan harus menjadi pilihan pengguna</a></li>
<li><a href="../id454938/index.html">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA</a></li>
<li><a href="../id454940/index.html">Asuransi kesehatan perjalanan: petunjuk terperinci</a></li>
<li><a href="../id454944/index.html">Cara kerja format JPEG</a></li>
<li><a href="../id454958/index.html">Pandangan dari dalam: sekolah pascasarjana di EPFL. Bagian 4.1: kehidupan sehari-hari</a></li>
<li><a href="../id454960/index.html">Mikrobiota. Bagaimana obat memengaruhi bakteri usus</a></li>
<li><a href="../id454962/index.html">Bagaimana perusahaan IT di dunia melindungi diri mereka dari pesaing di hadapan mantan karyawan?</a></li>
<li><a href="../id454964/index.html">Penggunaan visi komputer dalam penelitian kelautan atau 12 orang di dada orang mati</a></li>
<li><a href="../id454966/index.html">Buat game instan di Unity di Google Play Instant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>