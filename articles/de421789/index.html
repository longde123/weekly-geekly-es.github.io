<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨õÔ∏è üíÖ üë©üèΩ‚Äçüé§ Machen Sie das Frontend wieder zum "Backend" üçæ üç∫ üë™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikolai Ryzhikov schlug seine Version der Antwort auf die Frage vor, warum es so schwierig ist, eine Benutzeroberfl√§che zu entwickeln. Am Beispiel sei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machen Sie das Frontend wieder zum "Backend"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/421789/">  Nikolai Ryzhikov schlug seine Version der Antwort auf die Frage vor, warum es so schwierig ist, eine Benutzeroberfl√§che zu entwickeln.  Am Beispiel seines Projekts wird er zeigen, dass die Anwendung einiger Ideen aus dem Backend auf dem Frontend sowohl die Reduzierung der Entwicklungskomplexit√§t als auch die Testbarkeit des Frontends beeinflusst. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XBfi3Q74BnE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Das Material wurde auf der Grundlage eines Berichts von Nikolai Ryzhikov auf der Fr√ºhjahrskonferenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS 2018 Piter vorbereitet</a> . <br><a name="habracut"></a><br>  Derzeit arbeitet Nikolai Ryzhikov im Gesundheits-IT-Bereich an der Schaffung medizinischer Informationssysteme.  Mitglied der St. Petersburger Community der funktionalen Programmierer FPROG.  Aktives Mitglied der Online Clojure-Community, Mitglied des HL7 FHIR-Standards f√ºr den Austausch medizinischer Informationen.  Programmiert seit 15 Jahren. <br><br><hr><br>  - Die Frage, warum die grafische Benutzeroberfl√§che immer schwierig war, hat mich immer gequ√§lt.  Warum hat dies immer viele Fragen aufgeworfen? <br><br>  Heute werde ich versuchen zu spekulieren, ob es m√∂glich ist, eine Benutzeroberfl√§che effektiv zu entwickeln.  K√∂nnen wir die Komplexit√§t seiner Entwicklung reduzieren? <br><br><h3>  Was ist Effizienz? </h3><br>  Definieren wir, was Effizienz ist.  Unter dem Gesichtspunkt der Entwicklung einer Benutzeroberfl√§che bedeutet Effizienz: <br><br><ul><li>  Entwicklungsgeschwindigkeit </li><li>  Anzahl der Fehler </li><li>  Geldbetrag ausgegeben ... </li></ul><br>  Es gibt eine sehr gute Definition: <br><br><blockquote>  Effizienz macht mehr mit weniger </blockquote><br>  Nach dieser Bestimmung k√∂nnen Sie alles setzen, was Sie wollen - weniger Zeit, weniger Aufwand.  Beispiel: "Wenn Sie weniger Code schreiben, lassen Sie weniger Fehler zu" und erreichen Sie dasselbe Ziel.  Im Allgemeinen geben wir uns viel M√ºhe umsonst.  Und Effizienz ist ein ziemlich hohes Ziel - diese Verluste loszuwerden und nur das zu tun, was ben√∂tigt wird. <br><br><h3>  Was ist Komplexit√§t? </h3><br>  Komplexit√§t ist meiner Meinung nach das Hauptproblem in der Entwicklung. <br><br>  Fred Brooks schrieb 1986 einen Artikel mit dem Titel No Silver Bullet.  Darin reflektiert er Software.  Bei der Hardware sind die Fortschritte sprunghaft und mit der Software ist alles viel schlimmer.  Die Hauptfrage von Fred Brooks: Kann es eine solche Technologie geben, die uns sofort um eine Gr√∂√üenordnung beschleunigt?  Und er selbst gibt eine pessimistische Antwort und erkl√§rt, dass es in Software nicht m√∂glich ist, dies zu erreichen, und erkl√§rt seine Position.  Ich empfehle dringend, diesen Artikel zu lesen. <br><br>  Ein Freund von mir sagte, die UI-Programmierung sei so ein "schmutziges Problem".  Sie k√∂nnen sich nicht einmal hinsetzen und die richtige Option finden, damit das Problem f√ºr immer gel√∂st wird.  Dar√ºber hinaus hat die Komplexit√§t der Entwicklung in den letzten 10 Jahren nur zugenommen. <br><br><h3>  Vor 12 Jahren ... </h3><br>  Wir haben vor 12 Jahren mit der Entwicklung eines medizinischen Informationssystems begonnen.  Zuerst mit Blitz.  Dann haben wir uns angesehen, was Google Mail zu tun begann.  Es hat uns gefallen und wir wollten mit HTML zu JavaScript wechseln. <br><br>  In der Tat waren wir dann der Zeit weit voraus.  Wir haben ein Dojo genommen, und tats√§chlich hatten wir alles so wie jetzt.  Es gab Komponenten, die in Dojo-Widgets ziemlich gut waren, es gab ein modulares Build-System, f√ºr das der Google Clojure Compiler erstellt und minimiert werden musste (RequireJS und CommonJS rochen damals nicht einmal). <br><br>  Alles hat geklappt.  Wir haben uns Google Mail angesehen, waren begeistert und fanden, dass alles in Ordnung war.  Zuerst haben wir nur einen Patientenkartenleser geschrieben.  Dann wechselten sie schrittweise zur Automatisierung anderer Arbeitsabl√§ufe im Krankenhaus.  Und alles wurde kompliziert.  Das Team scheint professionell zu sein - aber jedes Feature begann zu knarren.  Diese Sensation trat vor 12 Jahren auf - und verl√§sst mich immer noch nicht. <br><br><h3>  Schienen Weg + jQuery </h3><br>  Wir haben die Systemzertifizierung durchgef√ºhrt und es war notwendig, ein Patientenportal zu schreiben.  Dies ist ein solches System, in dem der Patient seine medizinischen Daten einsehen kann. <br><br>  Unser Backend wurde dann in Ruby on Rails geschrieben.  Obwohl die Ruby on Rails-Community nicht sehr gro√ü ist, hat sie einen enormen Einfluss auf die Branche.  Aus Ihrer kleinen leidenschaftlichen Community sind alle Ihre Paketmanager, GitHub, Git, automatischen Make-ups usw. gekommen. <br><br>  Das Wesentliche an der Herausforderung war, dass wir das Patientenportal in zwei Wochen implementieren mussten.  Und wir haben uns entschlossen, Rails auszuprobieren - um alles auf dem Server zu erledigen.  So ein klassisches Web 2.0.  Und sie haben es getan - sie haben es wirklich in zwei Wochen getan. <br><br>  Wir waren dem ganzen Planeten voraus: Wir haben SPA gemacht, wir hatten eine REST-API, aber aus irgendeinem Grund war sie unwirksam.  Einige Funktionen konnten bereits Einheiten bilden, da nur sie all diese Komplexit√§t von Komponenten, die Beziehung des Backends zum Frontend, ber√ºcksichtigen konnten.  Und als wir den Rails-Weg eingeschlagen haben - ein bisschen veraltet f√ºr unsere Standards -, begannen die Funktionen pl√∂tzlich zu nieten.  Der durchschnittliche Entwickler begann innerhalb weniger Tage mit der Einf√ºhrung des Features.  Und wir haben sogar angefangen, einfache Tests zu schreiben. <br><br>  Auf dieser Basis habe ich tats√§chlich noch eine Verletzung: Es gab Fragen.  Als wir im Backend von Java auf Rails umgestiegen sind, hat sich die Entwicklungseffizienz um das Zehnfache erh√∂ht.  Als wir im SPA ein Tor erzielten, stieg auch die Entwicklungseffizienz erheblich an.  Wie so? <br><br><h3>  Warum war Web 2.0 effektiv? </h3><br>  Beginnen wir mit einer anderen Frage: Warum machen wir einen einseitigen Antrag, warum glauben wir daran? <br><br>  Sie sagen uns nur: Wir m√ºssen das tun - und wir tun es.  Und sehr selten in Frage stellen.  Ist die REST-API und die SPA-Architektur korrekt?  Ist es wirklich f√ºr den Fall geeignet, in dem wir es verwenden?  Wir denken nicht. <br><br>  Auf der anderen Seite gibt es herausragende umgekehrte Beispiele.  Jeder benutzt GitHub.  Wissen Sie, dass GitHub keine Einzelseitenanwendung ist?  GitHub ist eine regul√§re "Rail" -Anwendung, die auf dem Server gerendert wird und in der es nur wenige Widgets gibt.  Hat jemand Mehl daraus erfahren?  Ich denke, es gibt drei Leute.  Der Rest bemerkte es nicht einmal.  Dies hatte keinerlei Auswirkungen auf den Benutzer, aber gleichzeitig m√ºssen wir aus irgendeinem Grund zehnmal mehr f√ºr die Entwicklung anderer Anwendungen bezahlen (sowohl St√§rke als auch Komplexit√§t usw.).  Ein weiteres Beispiel ist Basecamp.  Twitter war einst nur eine Rails-Anwendung. <br><br>  Tats√§chlich gibt es so viele Rails-Anwendungen.  Dies wurde teilweise vom Genie DHH (David Heinemeier Hansson, Sch√∂pfer von Ruby on Rails) bestimmt.  Er war in der Lage, ein auf das Gesch√§ft ausgerichtetes Tool zu erstellen, mit dem Sie sofort das tun k√∂nnen, was Sie ben√∂tigen, ohne von technischen Problemen abgelenkt zu werden. <br><br>  Als wir den Rails-Weg benutzten, gab es nat√ºrlich viel schwarze Magie.  W√§hrend wir uns schrittweise entwickelten, wechselten wir von Ruby zu Clojure, wobei praktisch die gleiche Effizienz beibehalten wurde, aber alles um eine Gr√∂√üenordnung einfacher wurde.  Und es war wunderbar. <br><br><h3>  12 Jahre sind vergangen </h3><br>  Im Laufe der Zeit tauchten im Frontend neue Trends auf. <br><br>  Wir haben Backbone v√∂llig ignoriert, da die Dojo-Anwendung, die wir zuvor geschrieben haben, noch ausgefeilter war als das, was Backbone anbot. <br><br>  Dann kam Angular.  Es war ein ziemlich interessanter ‚ÄûLichtstrahl‚Äú - unter dem Gesichtspunkt der Effizienz ist Angular sehr gut.  Sie nehmen den durchschnittlichen Entwickler und er nietet die Funktion.  Unter dem Gesichtspunkt der Einfachheit bringt Angular jedoch eine Reihe von Problemen mit sich - es ist undurchsichtig, komplex, es gibt Beobachtung, Optimierung usw. <br><br>  Es erschien eine Reaktion, die ein wenig Einfachheit brachte (zumindest die Unkompliziertheit des Renderings, die es uns aufgrund des virtuellen DOM jedes Mal erm√∂glicht, einfach neu zu zeichnen, zu verstehen und einfach zu schreiben).  Aber in Bezug auf die Effizienz hat uns React, um ehrlich zu sein, erheblich zur√ºckgedr√§ngt. <br><br>  Das Schlimmste ist, dass sich in 12 Jahren nichts ge√§ndert hat.  Wir machen immer noch das Gleiche wie damals.  Es ist Zeit zum Nachdenken - hier stimmt etwas nicht. <br><br>  Laut Fred Brooks gibt es zwei Probleme bei der Softwareentwicklung.  Nat√ºrlich sieht er das Hauptproblem in der Komplexit√§t, aber er teilt es in zwei Gruppen ein: <br><br><ul><li>  erhebliche Komplexit√§t, die sich aus der Aufgabe selbst ergibt.  Es kann einfach nicht weggeworfen werden, weil es Teil der Aufgabe ist. </li><li>  zuf√§llige Komplexit√§t ist diejenige, die wir einbringen, um dieses Problem zu l√∂sen. </li></ul><br>  Die Frage ist, wie ist das Gleichgewicht zwischen ihnen.  Genau dar√ºber diskutieren wir jetzt. <br><br><h3>  Warum ist es so schmerzhaft, die Benutzeroberfl√§che zu erstellen? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d22/667/d4e/d22667d4e3249034be27b07250a635ff.png"><br><br>  Es scheint mir, dass der erste Grund unser mentales Anwendungsmodell ist.  Reaktionskomponenten sind ein reiner OOP-Ansatz.  Unser System ist ein dynamischer Graph von ver√§nderlichen Objekten, die miteinander verbunden sind.  Turing-Complete-Typen generieren st√§ndig Knoten dieses Diagramms, einige Knoten verschwinden.  Haben Sie jemals versucht, sich Ihre Anwendung in Ihrem Kopf vorzustellen?  Das ist schrecklich!  Normalerweise pr√§sentiere ich eine OOP-Anwendung wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cd/7b4/c7a/7cd7b4c7a846d2e973b012d566945a19.png"><br><br>  Ich empfehle, die Thesen von Roy Fielding (Autor der REST-Architektur) zu lesen.  Seine Dissertation tr√§gt den Titel "Architekturstile und das Design netzwerkbasierter Software".  Ganz am Anfang gibt es eine sehr gute Einf√ºhrung, in der er dar√ºber spricht, wie man zur Architektur im Allgemeinen gelangt, und die Konzepte einf√ºhrt: das System in Komponenten und die Beziehungen zwischen diesen Komponenten aufteilt.  Es hat eine "Null" -Architektur, in der alle Komponenten m√∂glicherweise allen zugeordnet werden k√∂nnen.  Das ist architektonisches Chaos.  Dies ist unsere Objektdarstellung der Benutzeroberfl√§che. <br><br>  Roy Fielding empfiehlt, nach einer Reihe von Einschr√§nkungen zu suchen und diese aufzuerlegen, da diese Einschr√§nkungen Ihre Architektur definieren. <br><br>  Das wahrscheinlich Wichtigste ist, dass Einschr√§nkungen Freunde des Architekten sind.  Suchen Sie nach diesen realen Einschr√§nkungen und entwerfen Sie daraus ein System.  Weil Freiheit b√∂se ist.  Freiheit bedeutet, dass Sie √ºber eine Million Optionen verf√ºgen, aus denen Sie ausw√§hlen k√∂nnen, und nicht √ºber ein einziges Kriterium, anhand dessen Sie bestimmen k√∂nnen, ob die Auswahl richtig war.  Suchen Sie nach Einschr√§nkungen und bauen Sie darauf auf. <br><br>  Es gibt einen ausgezeichneten Artikel namens OUT OF THE TAR PIT (‚ÄûEinfacher als eine Teergrube‚Äú), in dem die Jungs nach Brooks beschlossen, zu analysieren, was genau zur Komplexit√§t der Anwendung beitr√§gt.  Sie kamen zu dem entt√§uschenden Schluss, dass ein ver√§nderliches, staatlich verbreitetes System die Hauptursache f√ºr Komplexit√§t ist.  Hier ist es m√∂glich, rein kombinatorisch zu erkl√§ren - wenn Sie zwei Zellen haben und in jeder von ihnen eine Kugel liegen kann (oder nicht l√ºgen kann), wie viele Zust√§nde sind m√∂glich?  - Vier. <br><br>  Wenn drei Zellen - 2 <sup>3</sup> , wenn 100 Zellen - 2 <sup>100</sup> .  Wenn Sie Ihre Anwendung pr√§sentieren und verstehen, wie viel Status verschwommen ist, stellen Sie fest, dass es unendlich viele m√∂gliche Status Ihres Systems gibt.  Wenn Sie gleichzeitig durch nichts eingeschr√§nkt sind, ist es zu schwierig.  Und das menschliche Gehirn ist schwach, das haben bereits verschiedene Studien bewiesen.  Wir k√∂nnen bis zu drei Elemente gleichzeitig in unseren K√∂pfen halten.  Einige sagen sieben, aber selbst daf√ºr benutzt das Gehirn einen Hack.  Komplexit√§t ist daher f√ºr uns ein echtes Problem. <br><br>  Ich empfehle diesen Artikel zu lesen, in dem die Jungs zu dem Schluss kommen, dass mit diesem ver√§nderlichen Zustand etwas getan werden muss.  Beispielsweise gibt es relationale Datenbanken, in denen Sie den gesamten ver√§nderlichen Status entfernen k√∂nnen.  Und der Rest wird in einem rein funktionalen Stil erledigt.  Und sie haben gerade die Idee einer solchen funktional-relationalen Programmierung. <br><br>  Das Problem ergibt sich also aus der Tatsache, dass: <br><br><ul><li>  Erstens haben wir kein gutes Modell f√ºr eine feste Benutzeroberfl√§che.  Komponentenans√§tze f√ºhren uns in die existierende H√∂lle.  Wir legen keine Einschr√§nkungen fest, wir verbreiten den ver√§nderlichen Zustand, was dazu f√ºhrt, dass die Komplexit√§t des Systems uns irgendwann einfach zerquetscht. <br></li><li>  Zweitens, wenn wir eine klassische Backend-Frontend-Anwendung schreiben, handelt es sich bereits um ein verteiltes System.  Die erste Regel f√ºr verteilte Systeme lautet, keine verteilten Systeme zu erstellen (Erstes Gesetz f√ºr das Design verteilter Objekte: Verteilen Sie Ihre Objekte nicht - von Martin Fowler), da Sie die Komplexit√§t sofort um eine Gr√∂√üenordnung erh√∂hen.  Jeder, der eine Integration geschrieben hat, versteht, dass alle Projektsch√§tzungen mit 10 multipliziert werden k√∂nnen, sobald Sie in die system√ºbergreifende Interaktion eintreten. Wir vergessen dies jedoch einfach und wechseln zu verteilten Systemen.  Dies war wahrscheinlich die Haupt√ºberlegung, als wir zu Rails wechselten und die gesamte Kontrolle an den Server zur√ºckgaben. <br></li></ul><br>  All dies ist zu hart f√ºr ein armes menschliches Gehirn.  Lassen Sie uns dar√ºber nachdenken, was wir mit diesen beiden Problemen tun k√∂nnen - dem Fehlen von Einschr√§nkungen in der Architektur (dem Diagramm ver√§nderlicher Objekte) und dem √úbergang zu verteilten Systemen, die so komplex sind, dass Wissenschaftler immer noch r√§tseln, wie sie richtig gemacht werden sollen (gleichzeitig wir) verurteilen wir uns zu diesen Qualen in den einfachsten Gesch√§ftsanwendungen)? <br><br><h3>  Wie hat sich das Backend entwickelt? </h3><br>  Wenn wir das Backend im gleichen Stil schreiben, in dem wir jetzt die Benutzeroberfl√§che erstellen, wird es das gleiche ‚Äûblutige Durcheinander‚Äú geben.  Wir werden so viel Zeit damit verbringen.  Also wirklich einmal versucht zu tun.  Dann begannen sie allm√§hlich, Beschr√§nkungen aufzuerlegen. <br><br>  Die erste gro√üe Backend-Erfindung ist die Datenbank. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/d5a/8aa/777d5a8aa62a6623e0918cdc57abdbee.png"><br><br>  Im Programm hing zun√§chst unerkl√§rlicherweise der gesamte Staat, und es war schwierig, ihn zu verwalten.  Im Laufe der Zeit haben die Entwickler eine Datenbank erstellt und dort den gesamten Status entfernt. <br><br>  Der erste interessante Unterschied zwischen der Datenbank besteht darin, dass die Daten dort keine Objekte mit eigenem Verhalten sind, sondern reine Informationen.  Es gibt Tabellen oder andere Datenstrukturen (z. B. JSON).  Sie haben kein Verhalten, und das ist auch sehr wichtig.  Weil Verhalten eine Interpretation von Informationen ist und es viele Interpretationen geben kann.  Und die grundlegenden Fakten - sie bleiben grundlegend. <br><br>  Ein weiterer wichtiger Punkt ist, dass wir √ºber diese Datenbank eine Abfragesprache wie SQL haben.  Unter dem Gesichtspunkt der Einschr√§nkungen ist SQL in den meisten F√§llen keine Turing-vollst√§ndige Sprache, sondern einfacher.  Auf der anderen Seite ist es deklarativ - ausdrucksvoller, weil Sie in SQL "was" sagen, nicht "wie".  Wenn Sie beispielsweise zwei Bezeichnungen in SQL kombinieren, entscheidet SQL, wie dieser Vorgang effizient ausgef√ºhrt werden soll.  Wenn Sie etwas suchen, nimmt er einen Index f√ºr Sie auf.  Sie geben dies niemals explizit an.  Wenn Sie versuchen, etwas in JavaScript zu kombinieren, m√ºssen Sie daf√ºr eine Menge Code schreiben. <br><br>  Auch hier ist es wichtig, dass wir Beschr√§nkungen auferlegt haben, und jetzt gehen wir durch eine einfachere und ausdrucksst√§rkere Sprache zu dieser Basis.  Umverteilte Komplexit√§t. <br><br>  Nachdem das Backend die Basis betreten hatte, wurde die Anwendung zustandslos.  Dies f√ºhrt zu interessanten Effekten - jetzt haben wir beispielsweise m√∂glicherweise keine Angst mehr, die Anwendung zu aktualisieren (der Status h√§ngt nicht in der Anwendungsschicht im Speicher, die beim Neustart der Anwendung verschwindet).  F√ºr eine Anwendungsschicht ist zustandslos eine gute Funktion und eine hervorragende Einschr√§nkung.  Zieh es an, wenn du kannst.  Dar√ºber hinaus kann eine neue Anwendung auf die alte Basis gezogen werden, da Fakten und ihre Interpretation keine verwandten Dinge sind. <br><br>  Unter diesem Gesichtspunkt sind Objekte und Klassen schrecklich, weil sie Verhalten und Informationen zusammenf√ºgen.  Informationen sind reicher und leben l√§nger.  Datenbanken und Fakten √ºberleben Code, der in Delphi, Perl oder JavaScript geschrieben wurde. <br><br>  Als das Backend zu einer solchen Architektur kam, wurde alles viel einfacher.  Die goldene √Ñra des Web 2.0 ist angebrochen.  Es war m√∂glich, etwas aus der Datenbank zu holen, die Daten einer Vorlage zu unterziehen (reine Funktion) und das HTML-ku zur√ºckzugeben, das an den Browser gesendet wird. <br><br>  Wir haben gelernt, wie man ziemlich komplexe Anwendungen im Backend schreibt.  Und die meisten Anwendungen sind in diesem Stil geschrieben.  Sobald das Backend einen Schritt zur Seite macht - in die Unsicherheit - beginnen die Probleme erneut. <br><br>  Die Leute begannen dar√ºber nachzudenken und kamen auf die Idee, die PLO und die Rituale wegzuwerfen. <br><br>  Was machen unsere Systeme eigentlich?  Sie nehmen Informationen von irgendwoher - vom Benutzer, von einem anderen System und dergleichen -, legen sie in die Datenbank, transformieren sie, √ºberpr√ºfen sie irgendwie.  Von der Basis nehmen sie es mit listigen Abfragen (analytisch oder synthetisch) heraus und geben es zur√ºck.  Das ist alles.  Und das ist wichtig zu verstehen.  Unter diesem Gesichtspunkt sind Simulationen ein sehr falsches und schlechtes Konzept. <br><br>  Es scheint mir, dass im Allgemeinen die gesamte OOP tats√§chlich von der Benutzeroberfl√§che aus geboren wurde.  Die Leute versuchten, eine Benutzeroberfl√§che zu simulieren und zu simulieren.  Sie sahen ein bestimmtes Grafikobjekt auf dem Monitor und dachten: Es w√§re sch√∂n, es in unserer Laufzeit zusammen mit seinen Eigenschaften usw. zu stimulieren.  Diese ganze Geschichte ist sehr eng mit der OOP verflochten.  Die Simulation ist jedoch der einfachste und naivste Weg, um die Aufgabe zu l√∂sen.  Interessante Dinge werden getan, wenn Sie beiseite treten.  Unter diesem Gesichtspunkt ist es wichtiger, Informationen vom Verhalten zu trennen, diese seltsamen Objekte zu entfernen, und alles wird viel einfacher: Ihr Webserver empf√§ngt eine HTTP-Zeichenfolge und gibt eine HTTP-Antwortzeichenfolge zur√ºck.  Wenn Sie der Gleichung eine Basis hinzuf√ºgen, erhalten Sie eine allgemein reine Funktion: Der Server akzeptiert die Basis und die Anforderung, gibt eine neue Basis und Antwort zur√ºck (eingegebene Daten - Daten √ºbrig). <br><br>  Auf dem Weg zu dieser Vereinfachung warfen Funktion√§re ‚Öî mehr Gep√§ck, das sich im Backend angesammelt hatte.  Er wurde nicht gebraucht, es war nur ein Ritual.  Wir sind immer noch kein Spielentwickler - wir brauchen den Patienten und den Arzt nicht, um irgendwie zur Laufzeit zu leben, ihre Koordinaten zu bewegen und zu verfolgen.  Unser Informationsmodell ist etwas anderes.  Wir geben nicht vor, Medizin, Verkauf oder irgendetwas anderes zu sein.  Wir schaffen an der Kreuzung etwas Neues.  Beispielsweise simuliert Uber nicht das Verhalten von Bedienern und Maschinen, sondern f√ºhrt ein neues Informationsmodell ein.  In unserem Bereich schaffen wir auch etwas Neues, damit Sie die Freiheit sp√ºren k√∂nnen. <br><br>  Es ist nicht notwendig zu versuchen, vollst√§ndig zu simulieren - erstellen. <br><br><h3>  Clojure = JS-- </h3><br>  Es ist Zeit, Ihnen genau zu sagen, wie Sie alles wegwerfen k√∂nnen.  Und hier m√∂chte ich Clojure Script erw√§hnen.  Wenn Sie JavaScript kennen, kennen Sie Clojure.  In Clojure f√ºgen wir JavaScript keine Funktionen hinzu, sondern entfernen sie. <br><br><ul><li>  Wir werfen die Syntax weg - in Clojure (in Lisp) gibt es keine Syntax.  In einer gew√∂hnlichen Sprache schreiben wir Code, der dann analysiert und ein AST erhalten wird, der kompiliert und ausgef√ºhrt wird.  In Lisp schreiben wir sofort einen AST, der ausgef√ºhrt - interpretiert oder kompiliert werden kann. <br></li><li>  Wir werfen die Ver√§nderlichkeit aus.  In Clojure gibt es keine ver√§nderlichen Objekte oder Arrays.  Jede Operation wird wie eine neue Kopie generiert.  Dar√ºber hinaus ist diese Kopie sehr billig.  Das ist so geschickt gemacht, um billig zu sein.  Und so k√∂nnen wir wie in der Mathematik mit Werten arbeiten.  Wir √§ndern nichts - wir schaffen etwas Neues.  Sicher, einfach. <br></li><li>  Wir werfen Klassen, Spiele mit Prototypen usw.  Das ist einfach nicht da. </li></ul><br>  Infolgedessen verf√ºgen wir weiterhin √ºber Funktionen und Datenstrukturen, √ºber die wir arbeiten, sowie √ºber Grundelemente.  Hier ist die ganze Clojure.  Und darauf k√∂nnen Sie dasselbe tun wie in anderen Sprachen, wo es viele zus√§tzliche Tools gibt, die niemand verwenden kann. <br><br><h4>  Beispiele </h4><br>  Wie kommen wir √ºber AST nach Lisp?  Hier ist ein klassischer Ausdruck: <br><br><pre><code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Wenn wir versuchen, seinen AST beispielsweise in Form eines Arrays zu schreiben, wobei der Kopf der Knotentyp ist und der n√§chste Parameter ein Parameter ist, erhalten wir etwas √Ñhnliches (wir versuchen, dies in Java Script zu schreiben): <br><br><pre> <code class="hljs json">['minus', ['plus', <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Werfen Sie nun die zus√§tzlichen Anf√ºhrungszeichen weg, wir k√∂nnen das Minus durch <code>-</code> und das Plus durch <code>+</code> ersetzen.  Wirf die Kommas, die in Lisp Leerzeichen sind, weg.  Wir werden den gleichen AST bekommen: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Und in Lisp schreiben wir alle so.  Wir k√∂nnen √ºberpr√ºfen - dies ist eine rein mathematische Funktion (mein Emacs ist mit dem Browser verbunden; ich lasse das Skript dort fallen, es wertet den Befehl dort aus und sendet ihn zur√ºck an Emacs - Sie sehen den Wert nach dem Symbol <code>=&gt;</code> ): <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Wir k√∂nnen auch eine Funktion deklarieren: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> xplus [ab] (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) ((<span class="hljs-name"><span class="hljs-name">fn</span></span> [xy] (<span class="hljs-name"><span class="hljs-name">*</span></span> xy)) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Oder eine anonyme Funktion.  Vielleicht sieht das ein bisschen be√§ngstigend aus: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">type</span></span> xplus)</code> </pre><br>  Ihr Typ ist eine JavaScript-Funktion: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> xplus) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Wir k√∂nnen es aufrufen, indem wir ihm den Parameter √ºbergeben: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">xplus</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Das hei√üt, wir schreiben nur AST, das dann entweder in JS oder Bytecode kompiliert oder interpretiert wird. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> mymin [ab] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">a</span></span> &gt; b) ba))</code> </pre><br>  Clojure ist eine gehostete Sprache.  Daher werden Grundelemente aus der √ºbergeordneten Laufzeit verwendet, dh im Fall von Clojure Script haben wir JavaScript-Typen: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[Number]</code> </pre><br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "string") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[String]</code> </pre><br>  Also werden regul√§re Ausdr√ºcke geschrieben: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> #"^Cl.*$") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[RegExp]</code> </pre><br>  Die Funktionen, die wir haben, sind Funktionen: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> (fn [x] x)) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Als n√§chstes brauchen wir eine Art zusammengesetzte Typen. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Dies kann so gelesen werden, als w√ºrden Sie ein Objekt in JavaScript erstellen: <br><br><pre> <code class="hljs pgsql">(def <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> {<span class="hljs-type"><span class="hljs-type">name</span></span>: "niquola" ‚Ä¶</code> </pre><br>  In Clojure wird dies als Hashmap bezeichnet.  Dies ist ein Container, in dem Werte liegen.  Wenn eckige Klammern verwendet werden - dies wird als Vektor bezeichnet - ist dies Ihr Array: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} =&gt; #'intro/user (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Wir zeichnen alle Informationen mit Hashmaps und Vektoren auf. <br><br>  Seltsame Doppelpunktnamen ( <code>:name</code> ) sind die sogenannten Zeichen: konstante Zeichenfolgen, die erstellt werden, um als Schl√ºssel in Hashmaps verwendet zu werden.  In verschiedenen Sprachen werden sie unterschiedlich genannt - Symbole, etwas anderes.  Dies kann jedoch einfach als konstante Zeichenfolge verstanden werden.  Sie sind sehr effektiv - Sie k√∂nnen lange Namen schreiben und nicht viel Ressourcen daf√ºr ausgeben, da sie miteinander verbunden sind (d. H. Sie werden nicht wiederholt). <br><br>  Clojure bietet Hunderte von Funktionen, um diese generischen Datenstrukturen und Grundelemente zu verarbeiten.  Wir k√∂nnen neue Schl√ºssel hinzuf√ºgen.  Dar√ºber hinaus haben wir immer eine Kopiersemantik, dh jedes Mal, wenn wir eine neue Kopie erhalten.  Zuerst m√ºssen Sie sich daran gew√∂hnen, da Sie nicht mehr wie zuvor irgendwo in der Variablen etwas speichern und dann diesen Wert √§ndern k√∂nnen.  Ihre Berechnung sollte immer einfach sein - alle Argumente m√ºssen explizit an die Funktion √ºbergeben werden. <br><br>  Dies f√ºhrt zu einer wichtigen Sache.  In funktionalen Sprachen ist eine Funktion eine ideale Komponente, da sie alles explizit am Eingang empf√§ngt.  Keine versteckten Links im System.  Sie k√∂nnen eine Funktion von einem Ort √ºbernehmen, an einen anderen √ºbertragen und dort verwenden. <br><br>  In Clojure haben wir auch f√ºr komplexe Verbundtypen hervorragende Wertgleichheitsoperationen: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">=</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>}) =&gt; true</code> </pre><br>  Und diese Operation ist billig, weil listige unver√§nderliche Strukturen einfach durch Bezugnahme verglichen werden k√∂nnen.  Daher k√∂nnen wir sogar eine Hashmap mit Millionen von Schl√ºsseln in einer Operation vergleichen. <br><br>  √úbrigens haben die Jungs von React einfach die Clojure-Implementierung kopiert und unver√§nderliche JS gemacht. <br><br>  Clojure hat auch eine Reihe von Operationen, zum Beispiel, um etwas von einem verschachtelten Pfad in der Hashmap abzurufen: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">get-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>])</code> </pre><br>  F√ºgen Sie in der Hashmap etwas entlang des verschachtelten Pfads ein: <br><br><pre> <code class="hljs ruby">(assoc-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>] <span class="hljs-string"><span class="hljs-string">"LA"</span></span>) =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"LA"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}], <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>}</code> </pre><br>  Aktualisieren Sie einen Wert: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">update-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span>] (<span class="hljs-name"><span class="hljs-name">fn</span></span> [old] (<span class="hljs-name"><span class="hljs-name">str</span></span> old <span class="hljs-string"><span class="hljs-string">"+++++"</span></span>)))</code> </pre><br>  W√§hlen Sie nur einen bestimmten Schl√ºssel aus: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select-keys</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span>])</code> </pre><br>  Gleiches gilt f√ºr den Vektor: <br><br><pre> <code class="hljs pgsql">(def clojurists [{:<span class="hljs-type"><span class="hljs-type">name</span></span> "Rich"} {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Micael"}]) (first clojurists) (second clojurists) =&gt; {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Michael"}</code> </pre><br>  Es gibt Hunderte von Operationen aus der Basisbibliothek, mit denen Sie diese Datenstrukturen bearbeiten k√∂nnen.  Es gibt eine Interop mit dem Host.  Man muss sich ein bisschen daran gew√∂hnen: <br><br><pre> <code class="hljs pgsql">(js/alert "Hello!") =&gt; nil &lt;/csource&gt;         "".    <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: &lt;source lang="clojure"&gt; (.-<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>)</code> </pre><br>  Es gibt jeden Zucker entlang der Ketten: <br><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -href) =&gt; "http://localhost:3000/#/billing/dashboard"</code> </pre><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -host) =&gt; "localhost:3000"</code> </pre><br>  Ich kann das JS-Datum nehmen und das Jahr daraus zur√ºckgeben: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [d (<span class="hljs-name"><span class="hljs-name">js/Date</span></span>.)] (.getFullYear d)) =&gt; <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Rich Hickey, der Sch√∂pfer von Clojure, hat uns stark eingeschr√§nkt.  Wir haben wirklich nichts anderes, also machen wir alles durch generische Datenstrukturen.  Wenn wir beispielsweise SQL schreiben, schreiben wir es normalerweise mit einer Datenstruktur.  Wenn Sie genau hinschauen, werden Sie feststellen, dass dies nur eine Hashmap ist, in die etwas eingebettet ist.  Dann gibt es eine Funktion, die all dies in eine SQL-Zeichenfolge √ºbersetzt: <br><br><pre> <code class="hljs ruby">{select [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]} =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:select</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]}</code> </pre><br>  Wir schreiben auch Routings mit einer Datenstruktur und gesetzten Datenstrukturen: <br><br><pre> <code class="hljs ruby">{<span class="hljs-string"><span class="hljs-string">"users"</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:users-list</span></span>}} <span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:welcome-page</span></span>}}</code> </pre><br><pre> <code class="hljs json">[:div.row [:div {:on-click #(.log js/console <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)} <span class="hljs-string"><span class="hljs-string">"User "</span></span>]]</code> </pre><br><h3>  DB in der Benutzeroberfl√§che </h3><br>  Also haben wir √ºber Clojure gesprochen.  Aber ich habe bereits erw√§hnt, dass die Datenbank ein gro√üer Erfolg im Backend war.  Wenn Sie sich ansehen, was jetzt im Frontend passiert, werden wir sehen, dass die Jungs das gleiche Muster verwenden - sie geben die Datenbank in der Benutzeroberfl√§che ein (in einer einseitigen Anwendung). <br><br>  Datenbanken werden in der Ulmenarchitektur, in Clojure-Skripten und sogar in begrenzter Form in Flux und Redux eingef√ºhrt (zus√§tzliche Plugins m√ºssen hier gesetzt werden, um Anforderungen auszul√∂sen).  Ulmenarchitektur, Re-Frame und Flux wurden ungef√§hr zur gleichen Zeit gestartet und voneinander entlehnt.  Wir schreiben auf Re-Frame.  Als n√§chstes werde ich ein wenig dar√ºber sprechen, wie es funktioniert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/11e/ddf/8ff11eddf7c9e2eb3254a3d9eee47d3d.png"><br><br>  Ereignis (es ist ein bisschen wie Redux) fliegt aus dem View-Chi, das von einem bestimmten Controller gefangen wird.  Den Controller nennen wir Event-Handler.  Der Event-Handler gibt einen Effekt aus, der auch von der Datenstruktur interpretiert wird. <br><br>  Eine Art von Effekt ist das Aktualisieren der Datenbank.  Das hei√üt, es nimmt den aktuellen Datenbankwert und gibt einen neuen zur√ºck.  Wir haben auch so etwas wie ein Abonnement - ein Analogon von Anfragen im Backend.  Das hei√üt, dies sind einige reaktive Abfragen, die wir an diese Datenbank senden k√∂nnen.  Diese reaktiven Anfragen schlie√üen wir uns anschlie√üend der Ansicht an.  Im Falle einer Reaktion scheinen wir vollst√§ndig neu zu zeichnen, und wenn sich das Ergebnis dieser Anfrage ge√§ndert hat, ist dies praktisch. <br>  Die Reaktion ist bei uns nur irgendwo ganz am Ende vorhanden, und im Allgemeinen ist die Architektur in keiner Weise damit verbunden.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42b/655/922/42b65592288ba93676e13b086f3f48b7.png"><br><br>  Hier wird hinzugef√ºgt, was zum Beispiel in Redux-s fehlt. <br><br>  Zun√§chst trennen wir die Effekte.  Die Frontend-Anwendung ist nicht eigenst√§ndig.  Er hat ein bestimmtes Backend - eine Art "Quelle der Wahrheit".  Die Anwendung muss dort st√§ndig etwas schreiben und etwas von dort lesen.  Schlimmer noch, wenn er mehrere Backends hat, an die es gehen sollte.  In der einfachsten Implementierung k√∂nnte dies direkt im Action Creater erfolgen - in Ihrem Controller, aber das ist schlecht.  Daher f√ºhren die Jungs von Re-Frame eine zus√§tzliche Indirektionsebene ein: Eine bestimmte Datenstruktur fliegt aus dem Controller heraus, was besagt, was zu tun ist.  Und dieser Beitrag hat einen eigenen Handler, der die Drecksarbeit erledigt.  Dies ist eine sehr wichtige Einf√ºhrung, auf die wir sp√§ter noch eingehen werden. <br><br>  Es ist auch wichtig (manchmal vergessen sie es) - einige grundlegende Fakten sollten in der Basis sein.  Alles andere kann aus der Datenbank entfernt werden - und Abfragen tun dies normalerweise, sie transformieren die Daten - sie f√ºgen keine neuen Informationen hinzu, sondern strukturieren die vorhandenen korrekt.  Wir brauchen diese Abfrage.  In Redux bietet dies meiner Meinung nach jetzt eine erneute Auswahl, und in Re-Frame haben wir es sofort (eingebaut). <br><br>  Schauen Sie sich unser Architekturdiagramm an.  Wir haben ein kleines Backend (im Stil von Web 2.0) mit einer Basis-, Controller- und Ansicht reproduziert.  Das einzige, was hinzugef√ºgt wird, ist Reaktivit√§t.  Dies ist MVC sehr √§hnlich, au√üer dass sich alles an einem Ort befindet.  Sobald die fr√ºhen MVCs f√ºr jedes Widget ein eigenes Modell erstellt haben, ist hier alles in einer Basis zusammengefasst.  Im Prinzip k√∂nnen Sie √ºber den Effekt vom Controller aus mit dem Backend synchronisieren. Sie k√∂nnen ein allgemeineres Erscheinungsbild erstellen, sodass die Datenbank wie ein Proxy f√ºr das Backend funktioniert.  Es gibt sogar eine Art generischen Algorithmus: Sie schreiben in Ihre lokale Datenbank und diese wird mit der Hauptdatenbank synchronisiert. <br><br>  In den meisten F√§llen ist die Basis nur eine Art Objekt, in das wir etwas in Redux schreiben.  Aber im Prinzip kann man sich vorstellen, dass es sich weiter zu einer vollwertigen Datenbank mit einer reichen Abfragesprache entwickeln wird.  Vielleicht mit einer Art generischer Synchronisation.  Zum Beispiel gibt es datomic - eine logische Datenbank mit drei Speichern, die direkt im Browser ausgef√ºhrt wird.  Sie nehmen es auf und legen Ihren gesamten Staat dort ab.  Datomic hat eine ziemlich umfangreiche Abfragesprache, die in ihrer Leistung mit SQL vergleichbar ist und sogar irgendwo gewinnt.  Ein weiteres Beispiel ist Google Lovefield geschrieben.  Alles wird sich irgendwo hin bewegen. <br><br>  Als n√§chstes werde ich erkl√§ren, warum wir ein reaktives Abonnement ben√∂tigen. <br><br>  Jetzt bekommen wir die erste naive Wahrnehmung - wir haben den Benutzer aus dem Backend, haben ihn in die Datenbank gestellt und m√ºssen ihn dann zeichnen.  Zum Zeitpunkt des Renderns passiert eine Menge bestimmter Logik, aber wir mischen dies mit dem Rendern und der Ansicht.  Wenn wir diesen Benutzer sofort rendern, erhalten wir ein gro√ües, kniffliges St√ºck, das etwas mit dem virtuellen DOM und etwas anderem macht.  Und es ist gemischt mit dem logischen Modell unserer Sichtweise. <br><br>  Ein sehr wichtiges Konzept, das verstanden werden muss: Aufgrund der Komplexit√§t der Benutzeroberfl√§che muss es auch modelliert werden.  Es ist notwendig zu trennen, wie es gezeichnet wird (wie es erscheint), von seinem logischen Modell.  Dann ist das logische Modell stabiler.  Sie k√∂nnen es nicht mit der Abh√§ngigkeit von einem bestimmten Framework belasten - Angular, React oder VueJS.  Ein Modell ist der √ºbliche erstklassige B√ºrger in Ihrer Laufzeit.  Idealerweise, wenn es sich nur um einige Daten und eine Reihe von Funktionen dar√ºber handelt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7b/52f/9c3/c7b52f9c3c048a91276c3ae8dcd33771.png"><br><br>  Das hei√üt, aus dem Backend-Modell (Objekt) k√∂nnen wir ein Ansichtsmodell erhalten, in dem wir das logische Modell ohne Verwendung eines Renderings neu erstellen k√∂nnen.  Wenn es eine Art Men√º oder √§hnliches gibt, kann dies alles im Ansichtsmodell erfolgen. <br><br><h3>  Warum? </h3><br>  Warum machen wir das alle? <br><br>  Ich habe gute UI-Tests nur gesehen, wenn 10 Tester besch√§ftigt sind. <br>  Normalerweise gibt es keine UI-Tests.  Daher versuchen wir, diese Logik aus den Komponenten im Ansichtsmodell herauszuschieben.  Das Fehlen von Tests ist ein sehr schlechtes Zeichen daf√ºr, dass dort etwas nicht stimmt, irgendwie ist alles schlecht strukturiert. <br><br>  Warum ist die Benutzeroberfl√§che schwer zu testen?  Warum haben die Jungs im Backend gelernt, wie man ihren Code testet, eine enorme Abdeckung bietet und es wirklich hilft, mit dem Backend-Code zu leben?  Warum ist die Benutzeroberfl√§che falsch?  H√∂chstwahrscheinlich machen wir etwas falsch.  Und alles, was ich oben beschrieben habe, hat uns tats√§chlich in Richtung Testbarkeit bewegt. <br><br><h3>  Wie machen wir Tests? </h3><br>  Wenn Sie genau hinschauen, ist der Teil unserer Architektur, der den Controller, das Abonnement und die Datenbank enth√§lt, nicht einmal mit JS verbunden.  Das hei√üt, dies ist eine Art Modell, das einfach mit Datenstrukturen arbeitet: Wir f√ºgen sie irgendwo hinzu, transformieren sie irgendwie und nehmen die Abfrage heraus.  Durch Effekte werden wir von der Interaktion mit der Au√üenwelt getrennt.  Und dieses St√ºck ist voll tragbar.  Es kann im sogenannten cljc geschrieben werden - dies ist eine gemeinsame Teilmenge zwischen Clojure Script und Clojure, die sich dort und dort gleich verh√§lt.  Wir k√∂nnen dieses St√ºck einfach aus dem Frontend herausschneiden und in die JVM einf√ºgen - wo das Backend lebt.  Dann k√∂nnen wir einen weiteren Effekt in die JVM schreiben, der direkt auf den Endpunkt trifft - er zieht den Router ohne Konvertierung, Analyse usw. von http-Strings usw. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b2/b23/d1d/5b2b23d1d90d589a6cff9d99582d416d.png"><br><br>  Als Ergebnis k√∂nnen wir einen sehr einfachen Test schreiben - den gleichen Funktionsintegraltest, den die Jungs im Backend schreiben.  Wir werfen ein bestimmtes Ereignis aus, es l√∂st einen Effekt aus, der direkt auf den Endpunkt im Backend trifft.  Er gibt uns etwas zur√ºck, legt es in der Datenbank ab, berechnet das Abonnement und im Abonnement liegt eine logische Ansicht (wir setzen die Benutzeroberfl√§chenlogik dort auf das Maximum).  Wir behaupten diese Ansicht. <br><br>  Somit k√∂nnen wir 80% des Codes im Backend testen, w√§hrend uns alle Backend-Entwicklungstools zur Verf√ºgung stehen.  Mithilfe von Vorrichtungen oder einigen Fabriken k√∂nnen wir eine bestimmte Situation in der Datenbank neu erstellen. <br><br>  Zum Beispiel haben wir einen neuen Patienten oder etwas wird nicht bezahlt usw.  Wir k√∂nnen eine Reihe m√∂glicher Kombinationen durchgehen. <br><br>  Somit k√∂nnen wir uns mit dem zweiten Problem befassen - mit einem verteilten System.  Weil der Vertrag zwischen den Systemen genau der Hauptschmerzpunkt ist, weil dies zwei verschiedene Laufzeiten sind, zwei verschiedene Systeme: Das Backend hat etwas ge√§ndert und etwas ist an unserem Frontend kaputt gegangen (Sie k√∂nnen nicht sicher sein, dass dies nicht passieren wird). <br><br><h3>  Demonstration </h3><br>  So sieht es in der Praxis aus.  Dies ist ein Backend-Helfer, der die Basis ger√§umt und eine kleine Welt hineingeschrieben hat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/ef0/e23/919ef0e23883707631e051ff6c62acf6.png"><br><br>  Als n√§chstes werfen wir das Abonnement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/bcb/35a/2a1bcb35a77444806d276e859f7aaebb.png"><br><br>  Normalerweise definiert die URL die Seite vollst√§ndig und ein Ereignis wird ausgel√∂st - Sie befinden sich jetzt auf einer solchen Seite mit einer Reihe von Parametern.  Hier gingen wir in einen neuen Workflow und unser Abonnement kehrte zur√ºck: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/956/34e/776/95634e7760690ebbef5ce5bbc51de9d6.png"><br><br>  Hinter den Kulissen ging er zur Basis, holte etwas und legte es in unsere UI-Basis.  Das Abonnement hat funktioniert und daraus das logische Ansichtsmodell abgeleitet. <br><br>  Wir haben es initialisiert.  Und hier ist unser logisches Modell: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d84/ee7/e0a/d84ee7e0a7e22ab8da638d8488df8833.png"><br><br>  Auch ohne einen Blick auf die Benutzeroberfl√§che zu werfen, k√∂nnen wir erraten, was nach diesem Modell gezeichnet wird: Es werden einige Warnungen angezeigt, einige Informationen √ºber den Patienten, Begegnungen und eine Reihe von Links werden angezeigt (dies ist ein Workflow-Widget, das die Rezeption leitet in bestimmten Schritten, wenn der Patient ankommt). <br><br>  Hier kommen wir auf eine komplexere Welt.  Sie haben einige Zahlungen geleistet und auch nach der Initialisierung getestet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/032/f24/4ea032f24871cc57608dddf4687c30d7.png"><br><br>  Wenn er den Besuch bereits bezahlt hat, wird dies in der Benutzeroberfl√§che angezeigt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/71a/910/0b871a910ae3741ebd45e2b442f76d9c.png"><br><br>  F√ºhren Sie Tests aus, die auf CI eingestellt sind.  Die Synchronisation zwischen dem Backend und dem Frontend wird durch Tests garantiert und nicht ehrlich. <br><br><h3>  Zur√ºck zum Backend? </h3><br>  Wir haben die Tests vor sechs Monaten vorgestellt und es hat uns sehr gut gefallen.  Das Problem der unscharfen Logik bleibt bestehen.  Je intelligenter sich eine Gesch√§ftsanwendung verh√§lt, desto mehr Informationen werden f√ºr einige Schritte ben√∂tigt.  Wenn Sie versuchen, dort einen Workflow aus der realen Welt auszuf√ºhren, werden Abh√§ngigkeiten von allem angezeigt: F√ºr jede Benutzeroberfl√§che m√ºssen Sie etwas aus verschiedenen Teilen der Datenbank im Backend abrufen.  Wenn wir Buchhaltungssysteme schreiben, kann dies nicht vermieden werden.  Infolgedessen ist, wie gesagt, die gesamte Logik verschmiert. <br><br>  Mit Hilfe solcher Tests k√∂nnen wir zumindest in der Entwicklungszeit - zum Zeitpunkt der Entwicklung - die Illusion erzeugen, dass wir wie in den alten Tagen von Web 2.0 in einer Laufzeit auf dem Server sitzen und alles komfortabel ist. <br><br>  Eine andere verr√ºckte Idee kam auf (sie wurde noch nicht umgesetzt).  Warum nicht diesen Teil auf das Backend absenken?  Warum nicht jetzt ganz von der verteilten Anwendung wegkommen?  Lassen Sie dieses Abonnement und unser Ansichtsmodell im Backend generieren?  Dort steht die Basis zur Verf√ºgung, alles ist synchron.  Alles ist einfach und klar. <br><br>  Das erste Plus, das ich darin sehe, ist, dass wir die Kontrolle an einem Ort haben werden.  Wir vereinfachen einfach alles sofort im Vergleich zu unserer verteilten Anwendung.  Tests werden einfach, doppelte Validierungen verschwinden.  Die modische Welt interaktiver Mehrbenutzersysteme √∂ffnet sich (wenn zwei Benutzer dasselbe Formular aufrufen, erz√§hlen wir ihnen davon; sie k√∂nnen es gleichzeitig bearbeiten). <br><br>  Ein interessantes Feature erscheint: Wenn wir zum Backend und zur Aussicht auf die Sitzung gehen, k√∂nnen wir verstehen, wer sich derzeit im System befindet und was er tut.  Dies ist ein bisschen wie bei einem Spielentwickler, bei dem die Server so funktionieren.  Dort lebt die Welt auf dem Server und das Frontend rendert nur.  Infolgedessen k√∂nnen wir einen bestimmten Thin Client bekommen. <br><br>  Auf der anderen Seite schafft dies eine Herausforderung.  Wir ben√∂tigen einen Statefull-Server, auf dem diese Sitzungen ausgef√ºhrt werden.  Wenn wir mehrere App-Server haben, muss die Last irgendwie richtig verteilt oder die Sitzung repliziert werden.  Es besteht jedoch der Verdacht, dass dieses Problem geringer ist als die Anzahl der Pluspunkte, die wir erhalten. <br><br>  Daher kehre ich zum Hauptslogan zur√ºck: Es gibt viele Arten von Anwendungen, die nicht verteilt geschrieben werden k√∂nnen, um die Komplexit√§t zu verringern.  Und Sie k√∂nnen die Effizienz um ein Vielfaches steigern, wenn Sie die grundlegenden Postulate, auf die wir uns bei der Entwicklung verlassen haben, noch einmal √ºberarbeiten. <br><br><blockquote>  Wenn Ihnen der Bericht gefallen hat, achten Sie darauf: Am 24. und 25. November findet in Moskau ein neues <b>HolyJS</b> statt, und es wird dort auch viele interessante Dinge geben.  Bereits bekannte Informationen zum Programm finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Website. Dort</a> k√∂nnen Tickets gekauft werden. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421789/">https://habr.com/ru/post/de421789/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421775/index.html">Neuronales Netzwerk trainiert, um Depressionen durch willk√ºrliche Sprache einer Person ohne Kontext zu erkennen</a></li>
<li><a href="../de421779/index.html">OceanLotus: neue Hintert√ºr, alte Pl√§ne</a></li>
<li><a href="../de421783/index.html">Fun State Management Huex Framework</a></li>
<li><a href="../de421785/index.html">Kalifornien steht kurz vor einer vollst√§ndigen Ablehnung von Kohlenstoff bei der Energieerzeugung</a></li>
<li><a href="../de421787/index.html">Projektarchitekturentwicklung, Schiffe und JavaScript</a></li>
<li><a href="../de421791/index.html">Ethische Fragen der k√ºnstlichen Intelligenz</a></li>
<li><a href="../de421793/index.html">Auf der Suche nach den Besten oder wie wir das Blockchain-Netzwerk f√ºr das Projekt ausgew√§hlt haben</a></li>
<li><a href="../de421795/index.html">Datengesteuerte Entscheidung am Beispiel der Auswahl einer Farbe zum Streichen von W√§nden</a></li>
<li><a href="../de421797/index.html">Warum brauchst du Splunk? √úberwachung der IT-Infrastruktur</a></li>
<li><a href="../de421799/index.html">Wie bekomme ich einen Job aus der Ferne in einem Unternehmen, in dem keine Remote-Mitarbeiter besch√§ftigt sind?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>