<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñäÔ∏è üèçÔ∏è üò™ Teste p√∫blico: solu√ß√£o para privacidade e escalabilidade no Ethereum üÜò üë∑ ‚ôâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain √© uma tecnologia inovadora que promete melhorar muitas √°reas da vida humana. Ele transfere processos e produtos reais para o espa√ßo digital...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste p√∫blico: solu√ß√£o para privacidade e escalabilidade no Ethereum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471096/">  <b>Blockchain</b> √© uma tecnologia inovadora que promete melhorar muitas √°reas da vida humana.  Ele transfere processos e produtos reais para o espa√ßo digital, garante a velocidade e a confiabilidade das transa√ß√µes financeiras, reduz seus custos e tamb√©m permite criar aplicativos DAPP modernos usando contratos inteligentes em redes descentralizadas. <br><br>  Dadas as muitas vantagens e os diversos usos do blockchain, pode parecer estranho que essa tecnologia promissora ainda n√£o tenha penetrado em todos os setores.  O problema √© que as blockchains descentralizadas modernas n√£o t√™m escalabilidade.  A Ethereum processa cerca de 20 transa√ß√µes por segundo, o que n√£o √© suficiente para atender √†s necessidades dos neg√≥cios din√¢micos de hoje.  Ao mesmo tempo, as empresas que usam a tecnologia blockchain n√£o se atrevem a abandonar o Ethereum devido ao seu alto grau de prote√ß√£o contra hackers e falhas de rede. <br><br>  Para garantir a descentraliza√ß√£o, a seguran√ßa e a escalabilidade do blockchain, resolvendo o Trilemma de Escalabilidade, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">equipe de</a> desenvolvimento do Opporty criou o Plasma Cash - uma cadeia filha que consiste em um contrato inteligente e uma rede privada baseada no Node.js, transferindo periodicamente seu estado para a cadeia raiz ( Ethereum). <br><br><img src="https://habrastorage.org/webt/tc/kv/lg/tckvlgw0bbppuvkdlaght7jdwfa.jpeg"><br><a name="habracut"></a><br><h2>  Principais processos na Plasma Cash </h2><br>  <b>1. O</b> usu√°rio chama a fun√ß√£o do contrato inteligente de 'dep√≥sito', transferindo a quantia em ETH para ele, que ele deseja colocar no token de Plasma Cash.  A fun√ß√£o de contrato inteligente cria um token e gera um evento sobre ele. <br><br>  <b>2.</b> Os n√≥s do Plasma Cash inscritos nos eventos do contrato inteligente recebem um evento sobre a cria√ß√£o de um dep√≥sito e adicionam uma transa√ß√£o sobre a cria√ß√£o de um token ao pool. <br><br>  <b>3.</b> Periodicamente, n√≥s especiais do Plasma Cash pegam todas as transa√ß√µes do pool (at√© 1 milh√£o) e formam um bloco a partir delas, calculam a √°rvore Merkle e, consequentemente, o hash.  Este bloco √© enviado para outros n√≥s para verifica√ß√£o.  Os n√≥s verificam se o hash Merkle √© v√°lido, se as transa√ß√µes s√£o v√°lidas (por exemplo, se o remetente do token √© seu propriet√°rio).  Ap√≥s verificar o bloco, o n√≥ chama a fun√ß√£o `submitBlock` do contrato inteligente, que armazena o n√∫mero e o hash Merkle do bloco na cadeia de rastreio.  Um contrato inteligente gera um evento sobre a adi√ß√£o bem-sucedida de um bloco.  As transa√ß√µes s√£o exclu√≠das do pool. <br><br>  <b>4. Os</b> n√≥s que receberam o evento sobre o envio do bloco come√ßam a aplicar as transa√ß√µes que foram adicionadas ao bloco. <br><br>  <b>5.</b> Em algum momento, o propriet√°rio (ou n√£o propriet√°rio) do token deseja retir√°-lo do Plasma Cash.  Para fazer isso, ele chama a fun√ß√£o `startExit`, passando informa√ß√µes sobre as duas √∫ltimas transa√ß√µes no token, o que confirma que ele √© o propriet√°rio do token.  O contrato inteligente, usando o hash Merkle, verifica transa√ß√µes em blocos e envia um token para a sa√≠da, o que acontecer√° em duas semanas. <br><br>  <b>6.</b> Se a opera√ß√£o de retirada de token ocorreu com viola√ß√µes (o token foi gasto ap√≥s o in√≠cio do procedimento de retirada ou o token j√° era um estranho antes da retirada), o propriet√°rio do token pode refut√°-la dentro de duas semanas. <br><br><img src="https://habrastorage.org/webt/xm/hy/ks/xmhyksifhph5pfmw5ibsnoh_keq.jpeg"><br><br><h2>  A privacidade √© alcan√ßada de duas maneiras. </h2><br>  <b>1. A</b> cadeia raiz n√£o sabe nada sobre transa√ß√µes que s√£o formadas e encaminhadas dentro da cadeia filha.  Restam informa√ß√µes sobre quem iniciou e retirou a ETH de / para o Plasma Cash. <br><br>  <b>2.</b> A cadeia filha permite que voc√™ organize transa√ß√µes an√¥nimas usando zk-SNARKs. <br><br><h2>  Pilha tecnol√≥gica </h2><br><ul><li>  NodeJS </li><li>  Redis </li><li>  Ethereum </li><li>  Soild </li></ul><br><h2>  Teste </h2><br>  Ao desenvolver o Plasma Cash, testamos a velocidade do sistema e obtivemos os seguintes resultados: <br><br><ul><li>  at√© 35.000 transa√ß√µes por segundo s√£o adicionadas ao pool; </li><li>  at√© 1.000.000 de transa√ß√µes podem ser armazenadas no bloco. </li></ul><br>  Os testes foram realizados nos tr√™s servidores a seguir: <br><br>  <i>1. Intel Core i7-6700 Skylake de quatro n√∫cleos, incl.</i>  <i>SSD NVMe - 512 GB, 64 GB DDR4 RAM</i> <br>  Foram levantados 3 n√≥s de Plasma Cash validados. <br><br>  <i>2. AMD Ryzen 7 1700X Octa-Core ‚ÄúSummit Ridge‚Äù (Zen), SSD SATA - 500 GB, RAM DDR4 de 64 GB</i> <br>  O n√≥ ETH da Ropsten testnet foi criado. <br>  Foram levantados 3 n√≥s de Plasma Cash validados. <br><br>  <i>3. Intel Core i9-9900K Octa-Core incl.</i>  <i>SSD NVMe - 1 TB, 64 GB de RAM DDR4</i> <br>  1 O n√≥ Submit Plasma Cash foi criado. <br>  Foram levantados 3 n√≥s de Plasma Cash validados. <br>  Foi lan√ßado um teste para adicionar transa√ß√µes √† rede Plasma Cash. <br><br>  <b>Total:</b> 10 n√≥s do Plasma Cash em uma rede privada. <br><br><h3>  Teste 1 </h3><br>  H√° um limite de 1 milh√£o de transa√ß√µes por bloco.  Portanto, 1 milh√£o de transa√ß√µes se enquadram em 2 blocos (j√° que o sistema consegue participar das transa√ß√µes e envia enquanto s√£o enviadas). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VhJAtRlmXVE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Estado inicial: √∫ltimo bloco 7;  1 milh√£o de transa√ß√µes e tokens s√£o armazenados no banco de dados. <br><br>  00:00 - inicia o script de gera√ß√£o de transa√ß√£o <br>  01:37 - 1 milh√£o de transa√ß√µes foram criadas e o envio ao n√≥ come√ßou <br>  01:46 - o n√≥ de envio pegou 240k transa√ß√µes do pool e forma o bloco 8.  Tamb√©m vemos que 320k transa√ß√µes s√£o adicionadas ao pool em 10 segundos <br>  01:58 - o bloco 8 √© assinado e enviado para valida√ß√£o <br>  02:03 - o bloco 8 √© validado e a fun√ß√£o `submitBlock` do contrato inteligente com o hash Merkle e o n√∫mero do bloco √© chamada <br>  02:10 - o script de demonstra√ß√£o terminou de funcionar, o que enviou 1 milh√£o de transa√ß√µes em 32 segundos <br>  02:33 - os n√≥s come√ßaram a receber informa√ß√µes de que o bloco 8 foi adicionado √† cadeia raiz e come√ßaram a executar transa√ß√µes de 240k <br>  02:40 - 240k transa√ß√µes foram exclu√≠das do pool, que j√° est√£o no bloco 8 <br>  02:56 - o n√≥ de envio pegou as 760k transa√ß√µes restantes do pool e come√ßou a calcular o hash e o bloco de sinal Merkle # 9 <br>  03:20 - todos os n√≥s cont√™m transa√ß√µes e tokens de 1mln 240k <br>  03:35 - o bloco 9 √© assinado e enviado para valida√ß√£o para outros n√≥s <br>  03:41 - ocorreu um erro de rede <br>  04:40 - por tempo limite, a espera pela valida√ß√£o do bloco # 9 parou <br>  04:54 - o n√≥ de envio pegou as 760k transa√ß√µes restantes do pool e come√ßou a calcular o hash e o bloco de sinal Merkle # 9 <br>  05:32 - o bloco 9 √© assinado e enviado para valida√ß√£o para outros n√≥s <br>  05:53 - o bloco 9 √© validado e enviado para a cadeia raiz <br>  06:17 - os n√≥s come√ßaram a receber informa√ß√µes de que o bloco n ¬∞ 9 foi adicionado √† cadeia raiz e come√ßaram a executar transa√ß√µes de 760k <br>  06:47 - o pool limpo de transa√ß√µes que est√£o no bloco # 9 <br>  09:06 - todos os n√≥s cont√™m 2 milh√µes de transa√ß√µes e tokens <br><br><h3>  Teste 2 </h3><br>  H√° um limite de 350k por bloco.  Como resultado, temos 3 blocos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4BNpSYkwRvE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Estado inicial: √∫ltimo bloco # 9;  2 milh√µes de transa√ß√µes e tokens armazenados no banco de dados <br><br>  00:00 - o script de gera√ß√£o de transa√ß√£o j√° est√° em execu√ß√£o <br>  00:44 - 1 milh√£o de transa√ß√µes foram criadas e o envio ao n√≥ come√ßou <br>  00:56 - o n√≥ de envio retirou 320k transa√ß√µes do pool e forma o bloco # 10.  Tamb√©m vemos que 320k transa√ß√µes s√£o adicionadas ao pool em 10 segundos <br>  01:12 - o bloco 10 √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  01:18 - o script de demonstra√ß√£o terminou de funcionar, o que enviou 1 milh√£o de transa√ß√µes em 34 segundos <br>  01:20 - o bloco 10 √© validado e enviado para a cadeia raiz <br>  01:51 - todos os n√≥s receberam informa√ß√µes da cadeia raiz que o bloco n¬∫ 10 foi adicionado e est√£o come√ßando a aplicar transa√ß√µes de 320k <br>  02:01 - o pool foi limpo para 320k transa√ß√µes adicionadas ao bloco # 10 <br>  02:15 - o n√≥ de envio recebeu 350 mil transa√ß√µes do pool e forma o bloco # 11 <br>  02:34 - o bloco 11 √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  02:51 - o bloco 11 √© validado e enviado para a cadeia raiz <br>  02:55 - o √∫ltimo n√≥ executou transa√ß√µes do bloco # 10 <br>  10:59 - muito tempo na cadeia raiz, uma transa√ß√£o foi executada com o envio do bloco n¬∫ 9, mas foi conclu√≠da e todos os n√≥s receberam informa√ß√µes sobre isso e come√ßaram a executar transa√ß√µes de 350k <br>  11:05 - o pool foi limpo para 320k transa√ß√µes adicionadas ao bloco # 11 <br>  12:10 - todos os n√≥s cont√™m 1 milh√£o de transa√ß√µes e tokens de 670k <br>  12:17 - o n√≥ de envio recebeu 330k transa√ß√µes do pool e forma o bloco # 12 <br>  12:32 - o bloco 12 √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  12:39 - o bloco 12 √© validado e enviado para a cadeia raiz <br>  13:44 - todos os n√≥s receberam informa√ß√µes da cadeia raiz que o bloco n¬∫ 12 foi adicionado e est√£o come√ßando a aplicar transa√ß√µes de 330k <br>  14:50 - todos os n√≥s cont√™m 2 milh√µes de transa√ß√µes e tokens <br><br><h3>  Teste 3 </h3><br>  No primeiro e no segundo servidores, um n√≥ de valida√ß√£o foi substitu√≠do por um n√≥ de envio. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w5QHab3heIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Estado inicial: √∫ltimo bloco # 84;  0 transa√ß√µes e tokens s√£o armazenados no banco de dados <br><br>  00:00 - 3 scripts s√£o lan√ßados que geram e enviam 1 milh√£o de transa√ß√µes <br>  01:38 - 1 milh√£o de transa√ß√µes foram criadas e o envio para enviar o n√≥ n¬∫ 3 come√ßou <br>  01:50 - o n√≥ de envio 3 levou 330 mil transa√ß√µes do pool e forma o bloco 85 (f21).  Tamb√©m vemos que 350 mil transa√ß√µes s√£o adicionadas ao pool em 10 segundos <br>  01:53 - 1 milh√£o de transa√ß√µes foram criadas e o envio para o n√≥ n¬∫ 1 come√ßou <br>  01:50 - o n√≥ de envio 3 levou 330 mil transa√ß√µes do pool e forma o bloco 85 (f21).  Tamb√©m vemos que 350 mil transa√ß√µes s√£o adicionadas ao pool em 10 segundos <br>  02:01 - o n√≥ de envio n¬∫ 1 recebeu 250 mil transa√ß√µes do pool e forma o bloco n¬∫ 85 (65e) <br>  02:06 - o bloco 85 (f21) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  02:08 - o script de demonstra√ß√£o do servidor n¬∫ 3 terminou de funcionar, o que enviou transa√ß√µes de 1mln em 30 segundos <br>  02:14 - o bloco 85 (f21) √© validado e enviado para a cadeia raiz <br>  02:19 - o bloco 85 (65e) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  02:22 - 1 milh√£o de transa√ß√µes foram criadas e o envio para o n√≥ 2 foi iniciado <br>  02:27 - o bloco 85 (65e) √© validado e enviado para a cadeia raiz <br>  02:29 - o n√≥ de envio 2 retirou do pool 111855 transa√ß√µes e formul√°rios de bloco 85 (256). <br>  02:36 - o bloco 85 (256) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  02:36 - o script de demonstra√ß√£o do servidor n¬∫ 1 terminou de funcionar, que enviou transa√ß√µes de 1 mln em 42,5 segundos <br>  02:38 - o bloco 85 (256) √© validado e enviado para a cadeia raiz <br>  03:08 - o script do servidor n¬∫ 2, que enviou 1 milh√£o de transa√ß√µes em 47 segundos, terminou de funcionar <br>  03:38 - todos os n√≥s receberam informa√ß√µes da cadeia raiz de que os blocos # 85 (f21), # 86 (65e), # 87 (256) foram adicionados e est√£o come√ßando a aplicar transa√ß√µes de 330k, 250k, 111855 <br>  03:49 - o pool foi limpo em 330k, 250k, 111855 transa√ß√µes que foram adicionadas aos blocos # 85 (f21), # 86 (65e), # 87 (256) <br>  03:59 - enviar o n√≥ n¬∫ 1 do bloco 888145 de transa√ß√µes e formul√°rios do bloco # 88 (214), enviar n√≥ n¬∫ 2 do bloco de transa√ß√µes 750k e formul√°rios n¬∫ 750 (50a), enviar o n√≥ n¬∫ 3 do bloco 670k das transa√ß√µes e forma o bloco # 88 (d3b) <br>  04:44 - o bloco 88 (d3b) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  04:58 - o bloco 88 (214) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  05:11 - o bloco 88 (50a) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  05:11 - o bloco 85 (d3b) √© validado e enviado para a cadeia raiz <br>  05:36 - o bloco 85 (214) √© validado e enviado para a cadeia raiz <br>  05:43 - todos os n√≥s receberam informa√ß√µes da cadeia raiz que bloqueia # 88 (d3b), # 89 (214) foram adicionados e come√ßam a aplicar transa√ß√µes de 670k e 750k <br>  06:50 - devido a uma desconex√£o, o bloco 85 (50a) n√£o foi validado <br>  06:55 - o n√≥ de envio 2 retirou 888145 transa√ß√µes do pool e forma o bloco 90 (50a) <br>  08:14 - o bloco 90 (50a) √© assinado e enviado para outros n√≥s para valida√ß√£o <br>  09:04 - o bloco 90 (50a) √© validado e enviado para a cadeia raiz <br>  11:23 - todos os n√≥s receberam informa√ß√µes da cadeia raiz que adicionaram o bloco 90 (50a) e 888145 transa√ß√µes come√ßaram a ser aplicadas.  Ao mesmo tempo, o servidor n¬∫ 3 aplica transa√ß√µes h√° muito tempo dos blocos n¬∫ 88 (d3b), n¬∫ 89 (214) <br>  12:11 - todas as piscinas est√£o vazias <br>  13:41 - todos os n√≥s do servidor # 3 cont√™m 3 milh√µes de transa√ß√µes e tokens <br>  14:35 - todos os n√≥s do servidor # 1 cont√™m 3 milh√µes de transa√ß√µes e tokens <br>  19:24 - todos os n√≥s do servidor # 2 cont√™m 3 milh√µes de transa√ß√µes e tokens <br><br><h2>  Obst√°culos </h2><br>  Durante o desenvolvimento do Plasma Cash, encontramos os seguintes problemas, que gradualmente resolvemos e estamos resolvendo: <br><br>  <b>1.</b> O conflito de intera√ß√£o de v√°rias fun√ß√µes do sistema.  Por exemplo, a fun√ß√£o de adicionar transa√ß√µes ao pool bloqueou o envio e a valida√ß√£o de blocos e vice-versa, o que levou a uma redu√ß√£o na velocidade. <br><br>  <b>2.</b> N√£o ficou claro imediatamente como enviar um grande n√∫mero de transa√ß√µes e, ao mesmo tempo, minimizar o custo da transfer√™ncia de dados. <br><br>  <b>3.</b> N√£o ficou claro como e onde armazenar dados para obter altos resultados. <br><br>  <b>4.</b> N√£o ficou claro como organizar uma rede entre n√≥s, pois o tamanho do bloco com 1 milh√£o de transa√ß√µes leva cerca de 100 MB. <br><br>  <b>5.</b> Trabalhar no modo de thread √∫nico interrompe a conex√£o entre n√≥s quando ocorrem c√°lculos longos (por exemplo, construindo uma √°rvore Merkle e calculando seu hash). <br><br><h2>  Como lidamos com tudo isso? </h2><br>  A primeira vers√£o do n√≥ Plasma Cash era uma esp√©cie de combina√ß√£o que podia fazer tudo ao mesmo tempo: aceitar transa√ß√µes, enviar e validar blocos, fornecer uma API para acessar dados.  Como o NodeJS foi inicialmente encadeado √∫nico, a fun√ß√£o pesada de c√°lculo da √°rvore Merkle bloqueou a fun√ß√£o de adi√ß√£o de transa√ß√£o.  Vimos duas op√ß√µes para resolver esse problema: <br><br>  <b>1.</b> Execute v√°rios processos do NodeJS, cada um deles executando determinadas fun√ß√µes. <br><br>  <b>2.</b> Use worker_threads e coloque a execu√ß√£o do c√≥digo em threads. <br><br>  Como resultado, usamos as duas op√ß√µes ao mesmo tempo: dividimos logicamente um n√≥ em 3 partes, que podem funcionar separadamente, mas ao mesmo tempo de forma s√≠ncrona <br><br>  <b>1.</b> Envie um n√≥ que aceite transa√ß√µes para o pool e crie blocos. <br><br>  <b>2.</b> N√≥ de valida√ß√£o que verifica a validade dos n√≥s. <br><br>  <b>3.</b> API do n√≥ - fornece uma API para acessar dados. <br><br>  Ao mesmo tempo, voc√™ pode conectar-se a cada n√≥ atrav√©s de um soquete unix usando cli. <br><br>  Opera√ß√µes pesadas, como o c√°lculo da √°rvore Merkle, foram realizadas em um fluxo separado. <br><br>  Assim, alcan√ßamos a opera√ß√£o normal de todas as fun√ß√µes do Plasma Cash simultaneamente e sem falhas. <br><br>  Assim que o sistema funcionou funcionalmente, come√ßamos a testar a velocidade e, infelizmente, obtivemos resultados insatisfat√≥rios: 5.000 transa√ß√µes por segundo e at√© 50.000 transa√ß√µes em um bloco.  Eu tive que descobrir o que foi implementado incorretamente. <br><br>  Para come√ßar, come√ßamos a testar o mecanismo de comunica√ß√£o com o Plasma Cash para descobrir a capacidade de pico do sistema.  Escrevemos anteriormente que o n√≥ Plasma Cash fornece uma interface de soquete unix.  Foi originalmente textual.  Os objetos json foram enviados usando `JSON.parse ()` e `JSON.stringify ()`. <br><br><pre><code class="plaintext hljs">```json { "action": "sendTransaction", "payload":{ "prevHash": "0x8a88cc4217745fd0b4eb161f6923235da10593be66b841d47da86b9cd95d93e0", "prevBlock": 41, "tokenId": "57570139642005649136210751546585740989890521125187435281313126554130572876445", "newOwner": "0x200eabe5b26e547446ae5821622892291632d4f4", "type": "pay", "data": "", "signature": "0xd1107d0c6df15e01e168e631a386363c72206cb75b233f8f3cf883134854967e1cd9b3306cc5c0ce58f0a7397ae9b2487501b56695fe3a3c90ec0f61c7ea4a721c" } } ```</code> </pre> <br>  Medimos a velocidade de transfer√™ncia de tais objetos e recebemos ~ 130k por segundo.  Eles tentaram substituir as fun√ß√µes padr√£o pelo json, mas o desempenho n√£o melhorou.  Deve haver um mecanismo V8 bem otimizado para essas opera√ß√µes. <br><br>  O trabalho com transa√ß√µes, tokens, blocos foi realizado por meio de classes.  Ao criar essas classes, o desempenho caiu 2 vezes, o que indica: OOP n√£o √© adequado para n√≥s.  Eu tive que reescrever tudo em uma abordagem puramente funcional. <br><br><h2>  Gravar no banco de dados </h2><br>  Inicialmente, o Redis foi escolhido para armazenamento de dados como uma das solu√ß√µes mais produtivas que satisfazem nossos requisitos: armazenamento de valor-chave, trabalho com tabelas de hash e muitos.  Lan√ßamos o benchmark redis e obtivemos ~ 80k opera√ß√µes por segundo no modo 1 pipelining. <br><br>  Para alto desempenho, ajustamos o Redis com mais detalhes: <br><br><ul><li>  Estabeleceu uma conex√£o de soquete unix. </li><li>  Desative o salvamento de estado no disco (para confiabilidade, voc√™ pode configurar a r√©plica e j√° salvar no disco em um Redis separado). </li></ul><br>  No Redis, um pool √© uma tabela de hash, pois precisamos receber todas as transa√ß√µes em uma solicita√ß√£o e excluir transa√ß√µes uma a uma.  Tentamos usar uma lista regular, mas ela funciona mais lentamente ao descarregar a lista inteira. <br><br>  Usando a biblioteca NodeJS padr√£o, as bibliotecas Redis alcan√ßaram 18 mil transa√ß√µes por segundo de desempenho.  A velocidade caiu 9 vezes. <br><br>  Como o benchmark nos mostrou as possibilidades claramente 5 vezes mais, elas come√ßaram a otimizar.  Alteramos a biblioteca para ioredis e obtivemos um desempenho de 25k por segundo.  Adicionamos transa√ß√µes uma a uma usando o comando `hset`.  Assim, geramos muitas solicita√ß√µes no Redis.  Havia uma id√©ia de mesclar transa√ß√µes em pacotes configur√°veis ‚Äã‚Äãe envi√°-las com um comando hmset.  O resultado √© 32k por segundo. <br><br>  Por v√°rias raz√µes, que ser√£o descritas abaixo, trabalhamos com dados usando o `Buffer` e, como se viu, se voc√™ o traduzir em texto (` buffer.toString ('hex') `) antes de escrever, voc√™ poder√° obter desempenho adicional.  Assim, a velocidade foi aumentada para 35k por segundo.  No momento, decidimos suspender a otimiza√ß√£o adicional. <br><br>  Tivemos que mudar para o protocolo bin√°rio porque: <br><br>  <b>1.</b> O sistema geralmente calcula hashes, assinaturas etc., e para isso precisa de dados no `Buffer. <br><br>  <b>2.</b> Ao transferir entre servi√ßos, os dados bin√°rios pesam menos que o texto.  Por exemplo, ao enviar um bloco com 1 milh√£o de transa√ß√µes, os dados no texto podem ocupar mais de 300 megabytes. <br><br>  <b>3.</b> A convers√£o cont√≠nua de dados afeta o desempenho. <br><br>  Portanto, tomamos como base nosso pr√≥prio protocolo bin√°rio para armazenamento e transmiss√£o de dados, desenvolvido com base na maravilhosa biblioteca de dados bin√°rios. <br><br>  Como resultado, temos as seguintes estruturas de dados: <br><br><h3>  - Transa√ß√£o </h3><br><pre> <code class="plaintext hljs"> ```json { prevHash: BD.types.buffer(20), prevBlock: BD.types.uint24le, tokenId: BD.types.string(null), type: BD.types.uint8, newOwner: BD.types.buffer(20), dataLength: BD.types.uint24le, data: BD.types.buffer(({current}) =&gt; current.dataLength), signature: BD.types.buffer(65), hash: BD.types.buffer(32), blockNumber: BD.types.uint24le, timestamp: BD.types.uint48le, } ```</code> </pre><br><h3>  - Token </h3><br><pre> <code class="plaintext hljs"> ```json { id: BD.types.string(null), owner: BD.types.buffer(20), block: BD.types.uint24le, amount: BD.types.string(null), } ```</code> </pre><br><h3>  - Bloco </h3><br><pre> <code class="plaintext hljs"> ```json { number: BD.types.uint24le, merkleRootHash: BD.types.buffer(32), signature: BD.types.buffer(65), countTx: BD.types.uint24le, transactions: BD.types.array(Transaction.Protocol, ({current}) =&gt; current.countTx), timestamp: BD.types.uint48le, } ```</code> </pre><br>  Pelos comandos usuais `BD.encode (block, Protocol) .slice ();` e `BD.decode (buffer, Protocol)` convertemos os dados em `Buffer` para salv√°-los no Redis ou transferi-los para outro n√≥ e recuper√°-los novamente. <br><br>  Tamb√©m temos 2 protocolos bin√°rios para transferir dados entre servi√ßos: <br><br>  <i>- Protocolo para interagir com o Plasma Node via soquete unix</i> <br><br><pre> <code class="plaintext hljs"> ```json { type: BD.types.uint8, messageId: BD.types.uint24le, error: BD.types.uint8, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  onde: <br><br><ul><li>  <b>`type`</b> - a√ß√£o a ser executada, por exemplo, 1 - sendTransaction, 2 - getTransaction; </li><li>  <b>`carga √∫til '</b> - dados a serem transferidos para a fun√ß√£o correspondente; </li><li>  <b>`messageId`</b> - ID da mensagem para que a resposta possa ser identificada. </li></ul><br>  <i>- Protocolo de intera√ß√£o entre n√≥s</i> <br><br><pre> <code class="plaintext hljs"> ```json { code: BD.types.uint8, versionProtocol: BD.types.uint24le, seq: BD.types.uint8, countChunk: BD.types.uint24le, chunkNumber: BD.types.uint24le, length: BD.types.uint24le, payload: BD.types.buffer(({node}) =&gt; node.length) } ```</code> </pre><br>  onde: <br><br><ul><li>  <b>`code`</b> - c√≥digo de mensagem, por exemplo 6 - PREPARE_NEW_BLOCK, 7 - BLOCK_VALID, 8 - BLOCK_COMMIT; </li><li>  <b>`versionProtocol`</b> - vers√£o do protocolo, j√° que n√≥s com vers√µes diferentes podem ser criados na rede e podem trabalhar de maneiras diferentes; </li><li>  <b>`seq`</b> - identificador de mensagem; </li><li>  <b>`countChunk` e`</b> <b>chunkNumber` s√£o</b> necess√°rios para dividir mensagens grandes; </li><li>  <b>`</b> <b>length` e` payload` o</b> comprimento e os dados em si. </li></ul><br>  Desde que digitamos os dados de antem√£o, o sistema final √© muito mais r√°pido que a biblioteca `rlp` do Ethereum.  Infelizmente, ainda n√£o fomos capazes de recusar, pois √© necess√°rio refinar o contrato inteligente, que planejamos fazer no futuro. <br><br>  Se conseguimos atingir uma velocidade de <b>35.000</b> transa√ß√µes por segundo, tamb√©m precisamos process√°-las no tempo ideal.  Como o tempo aproximado de forma√ß√£o do bloco leva 30 segundos, precisamos incluir <b>1.000.000 de</b> transa√ß√µes no bloco, o que significa enviar mais de <b>100</b> mb de dados. <br><br>  Inicialmente, usamos a biblioteca `ethereumjs-devp2p` para comunicar n√≥s, mas ela n√£o suportava tantos dados.  Como resultado, usamos a biblioteca `ws` e configuramos a transfer√™ncia de dados bin√°rios no websocket.  Obviamente, tamb√©m encontramos problemas ao enviar pacotes de dados grandes, mas os dividimos em partes e agora n√£o existem esses problemas. <br><br>  Al√©m disso, a forma√ß√£o da √°rvore Merkle e o c√°lculo do hash <b>de 1.000.000</b> transa√ß√µes requerem cerca de <b>10</b> segundos de c√°lculo cont√≠nuo.  Durante esse per√≠odo, a conex√£o com todos os n√≥s consegue quebrar.  Decidiu-se transferir esse c√°lculo para um thread separado. <br><br><h2>  Conclus√µes: </h2><br>  De fato, nossas descobertas n√£o s√£o novas, mas, por algum motivo, muitos especialistas as esquecem durante o desenvolvimento. <br><br><ul><li>  Usar a Programa√ß√£o Funcional em vez da Programa√ß√£o Orientada a Objetos aumenta o desempenho. </li><li>  Um mon√≥lito √© pior que uma arquitetura de servi√ßo para um sistema de produ√ß√£o no NodeJS. </li><li>  O uso de `worker_threads` para computa√ß√£o pesada melhora a capacidade de resposta do sistema, especialmente ao trabalhar com opera√ß√µes de E / S. </li><li>  O soquete unix √© mais est√°vel e mais r√°pido que as solicita√ß√µes http. </li><li>  Se voc√™ precisar transferir rapidamente grandes dados pela rede, √© melhor usar os soquetes da Web e enviar dados bin√°rios, divididos em partes, que podem ser encaminhadas se n√£o chegarem e depois mesclados em uma √∫nica mensagem. </li></ul><br>  Convidamos voc√™ a visitar o projeto <b>GitHub</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/opporty-com/Plasma-Cash/tree/new-version</a> <br><br>  O artigo foi co-escrito por <i>Alexander Nashivan</i> , desenvolvedor s√™nior da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Clever Solution Inc.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471096/">https://habr.com/ru/post/pt471096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471086/index.html">Gerador de capa de m√∫sica Python no Blender</a></li>
<li><a href="../pt471088/index.html">Especialistas em TI Burn Out: 4 hist√≥rias do gerente, desenvolvedor, produto e administrador. E a receita de Southbridge</a></li>
<li><a href="../pt471090/index.html">[N√£o] use CDN</a></li>
<li><a href="../pt471092/index.html">Comando cp: copiando pastas de arquivo para * nix corretamente</a></li>
<li><a href="../pt471094/index.html">O Tutu.ru e o Clube de Programadores de Moscou s√£o convidados para uma reuni√£o de back-end em 17 de outubro</a></li>
<li><a href="../pt471098/index.html">Inova√ß√£o digital - como foi</a></li>
<li><a href="../pt471100/index.html">Intera√ß√£o entre componentes angulares usando RxJS</a></li>
<li><a href="../pt471102/index.html">DNS din√¢mico personalizado com CloudFlare</a></li>
<li><a href="../pt471104/index.html">Resumo dos eventos de TI de outubro (parte dois)</a></li>
<li><a href="../pt471112/index.html">Raz√£o est√∫pida por que seu aplicativo de vis√£o de m√°quina astuto n√£o funciona: orienta√ß√£o em EXIF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>