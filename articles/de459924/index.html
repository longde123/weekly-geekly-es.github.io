<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↙️ 🥤 ▪️ Vollständiger Reaktionstestzyklus. Auto.ru-Bericht 👨🏽‍🏫 👈🏻 🤶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Wunsch, sich von manuellen Regressionstests zu lösen, ist ein guter Grund, Autotests einzuführen. Die Frage ist welche? Die Schnittstellenentwickl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vollständiger Reaktionstestzyklus. Auto.ru-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459924/"> Der Wunsch, sich von manuellen Regressionstests zu lösen, ist ein guter Grund, Autotests einzuführen.  Die Frage ist welche?  Die Schnittstellenentwickler Natalya Stus und Alexei Androsov erinnerten sich daran, wie ihr Team mehrere Iterationen durchlaufen und Frontend-Tests in Auto.ru basierend auf Jest und Puppeteer erstellt hat: Komponententests, Tests für einzelne React-Komponenten, Integrationstests.  Das interessanteste dieser Erfahrung ist das isolierte Testen von React-Komponenten in einem Browser ohne Selenium Grid, Java und andere Dinge. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/yr/np/zo/yrnpzon4-5momllzoy0bg1zz-ie.jpeg"></a> <br><br>  Alexey: <br>  - Zuerst müssen Sie ein wenig erzählen, was Automotive News ist.  Dies ist eine Seite, die Autos verkauft.  Es gibt eine Suche, ein persönliches Konto, Autoservices, Ersatzteile, Bewertungen, Händler und vieles mehr.  Auto.ru ist ein sehr großes Projekt, viel Code.  Wir schreiben den gesamten Code in einem großen Monorepe, weil alles durcheinander ist.  Dieselben Personen erledigen ähnliche Aufgaben, z. B. für Mobilgeräte und Desktops.  Es stellt sich eine Menge Code heraus, und Monorepa ist für uns von entscheidender Bedeutung.  Die Frage ist, wie man es testet? <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/vn/qv/qf/vnqvqfbci0v-wlfceczgd5snhgi.jpeg"><br><br>  Wir haben React und Node.js, die serverseitiges Rendern durchführen und Daten vom Backend anfordern.  Verbleibende und kleine Stücke auf dem BEM. <br><br><img src="https://habrastorage.org/webt/xb/1p/_b/xb1p_b-9j8huy-rle317mtp5sjc.jpeg"><br><br>  Natalya: <br>  - Wir haben angefangen, an Automatisierung zu denken.  Der Release-Zyklus unserer einzelnen Anwendungen umfasste mehrere Schritte.  Zunächst wird die Funktion vom Programmierer in einem separaten Zweig entwickelt.  Danach wird die Funktion in demselben separaten Zweig von manuellen Testern getestet.  Wenn alles in Ordnung ist, fällt die Aufgabe in den Release-Kandidaten.  Wenn nicht, kehren Sie erneut zur Entwicklungsiteration zurück und testen Sie erneut.  Bis der Tester sagt, dass in dieser Funktion alles in Ordnung ist, fällt sie nicht in den Release-Kandidaten. <br><br>  Nach dem Zusammenstellen des Release-Kandidaten erfolgt eine manuelle Regression - nicht nur Auto.ru, sondern nur das Paket, das wir rollen werden.  Wenn wir beispielsweise das Desktop-Web rollen, gibt es eine manuelle Regression des Desktop-Web.  Dies sind viele manuelle Testfälle.  Eine solche Regression dauerte ungefähr einen Arbeitstag eines manuellen Testers. <br><br>  Wenn die Regression abgeschlossen ist, erfolgt eine Freigabe.  Danach verschmilzt der Release-Zweig mit dem Master.  Zu diesem Zeitpunkt können wir nur den Mastercode einfügen, den wir nur für das Desktop-Web getestet haben, und dieser Code kann beispielsweise das mobile Web beschädigen.  Dies wird nicht sofort überprüft, sondern erst bei der nächsten manuellen Regression - dem mobilen Web. <br><br><img src="https://habrastorage.org/webt/uc/pp/f6/ucppf6mqcfn6rcjayzc7mzgzzwe.jpeg"><br><br>  Der schmerzhafteste Punkt in diesem Prozess war natürlich die manuelle Regression, die sehr lange dauerte.  Natürlich haben alle manuellen Tester es satt, jeden Tag das Gleiche zu tun.  Deshalb haben wir uns entschlossen, alles zu automatisieren.  Die erste Lösung, die ausgeführt wurde, waren die Selenium- und Java-Selbsttests, die von einem separaten Team geschrieben wurden.  Dies waren End-to-End-Tests, e2e, bei denen die gesamte Anwendung getestet wurde.  Sie haben ungefähr fünftausend solcher Tests geschrieben.  Womit sind wir gelandet? <br><br>  Natürlich haben wir die Regression beschleunigt.  Autotests bestehen viel schneller als ein manueller Tester, etwa zehnmal schneller.  Dementsprechend wurden die Routinemaßnahmen, die sie jeden Tag ausführten, aus den manuellen Testern entfernt.  Gefundene Fehler aus Autotests sind leichter zu reproduzieren.  Starten Sie diesen Test einfach neu oder sehen Sie sich die Schritte an, die er ausführt - im Gegensatz zum manuellen Tester, der sagt: "Ich habe auf etwas geklickt und alles ist kaputt gegangen." <br><br>  Vorausgesetzt, Stabilität der Beschichtung.  Wir führen immer die gleichen Lauftests durch - im Gegensatz zu manuellen Tests, bei denen der Tester feststellen kann, dass wir diesen Ort nicht berührt haben, und ich werde es diesmal nicht überprüfen.  Wir haben Tests hinzugefügt, um Screenshots zu vergleichen, und die Genauigkeit beim Testen der Benutzeroberfläche verbessert. Jetzt überprüfen wir die Diskrepanz in einigen Pixeln, die der Tester mit seinen Augen nicht sehen kann.  Alles dank Screenshot-Tests. <br><br>  Aber es gab Nachteile.  Die größte - für e2e-Tests benötigen wir eine Testumgebung, die vollständig mit dem Produkt übereinstimmt.  Es muss immer auf dem neuesten Stand und betriebsbereit sein.  Dies erfordert fast so viel Kraft wie der Verkauf von Stabilitätsunterstützung.  Das können wir uns natürlich nicht immer leisten.  Daher hatten wir oft Situationen, in denen die Testumgebung lügt oder irgendwo etwas kaputt ist und Tests fehlschlagen, obwohl das vorderste Paket keine Probleme aufwies. <br><br>  Diese Tests werden auch von einem separaten Team entwickelt, das seine eigenen Aufgaben hat, seine eigene Aufgabe im Task-Tracker hat und neue Funktionen werden mit einiger Verzögerung behandelt.  Sie können nicht sofort nach der Veröffentlichung einer neuen Funktion kommen und sofort Autotests darauf schreiben.  Da die Tests teuer und schwer zu schreiben und zu warten sind, decken wir nicht alle Szenarien ab, sondern nur die kritischsten.  Gleichzeitig wird ein separates Team benötigt, das über separate Tools und eine separate Infrastruktur verfügt.  Die Analyse der gefallenen Tests ist auch für manuelle Tester oder Entwickler eine nicht triviale Aufgabe.  Ich werde einige Beispiele zeigen. <br><br><img src="https://habrastorage.org/webt/gn/ix/c6/gnixc6p8h1phrdhcjlosttb0ai8.jpeg"><br><br>  Wir haben Tests durchgeführt.  500 Tests bestanden, von denen einige fielen.  Wir können so etwas im Bericht sehen.  Hier hat der Test einfach nicht begonnen und es ist nicht klar, ob dort alles gut ist oder nicht. <br><br><img src="https://habrastorage.org/webt/40/70/6p/40706pwn5i1vfzfpl4ekmfhpeom.jpeg"><br><br>  Ein weiteres Beispiel: Der Test wurde gestartet, stürzte jedoch mit einem solchen Fehler ab.  Er konnte kein Element auf der Seite finden, aber warum - wir wissen es nicht.  Entweder wurde dieses Element einfach nicht angezeigt, oder es stellte sich heraus, dass es sich auf der falschen Seite befand, oder der Locator wurde geändert.  Alles was Sie brauchen, um Hände zu debazhen. <br><br><img src="https://habrastorage.org/webt/vh/_f/xd/vh_fxdrktlr3llkbrcloced22ks.jpeg"><br><br>  Screenshot-Tests geben uns auch nicht immer eine gute Genauigkeit.  Hier laden wir eine Art Karte, sie hat sich leicht bewegt, unser Test ist gefallen. <br><br><img src="https://habrastorage.org/webt/_r/1y/dm/_r1ydm4pdscdlxgdse5focstyje.jpeg"><br><br>  Wir haben versucht, eine Reihe dieser Probleme zu lösen.  Wir haben begonnen, einen Teil der Tests auf dem Produkt durchzuführen - diejenigen, die keine Auswirkungen auf Benutzerdaten haben, ändern nichts in der Datenbank.  Das heißt, wir haben bei prod eine separate Maschine hergestellt, die in die Prod-Umgebung schaut.  Wir installieren einfach ein neues Frontend-Paket und führen dort Tests durch.  Das Produkt ist zumindest stabil. <br><br>  Wir haben einige der Tests auf Mokeys übertragen, aber wir haben viele verschiedene Backends, verschiedene APIs, und das Sperren ist eine sehr schwierige Aufgabe, insbesondere für 5.000 Tests.  Dafür wurde ein spezieller Dienst namens Mockritsa geschrieben, der es einfach macht, die notwendigen Mokas für das Frontend zu erstellen, und der ziemlich einfach zu vertreten ist. <br><br>  Wir mussten auch ein paar Eisen kaufen, damit unser Selenium-Gitter von Geräten, von denen diese Tests gestartet werden, größer war, damit sie nicht herunterfielen, weil sie den Browser nicht anheben konnten und dementsprechend schneller gingen.  Selbst nachdem wir versucht hatten, diese Probleme zu lösen, kamen wir zu dem Schluss, dass solche Tests nicht für CI geeignet sind, sondern sehr lange dauern.  Wir können sie nicht bei jeder Poolanforderung ausführen.  Wir werden diese Berichte, die für jede Poolanforderung generiert werden, später in unserem Leben einfach nie analysieren. <br><br><img src="https://habrastorage.org/webt/od/0z/rl/od0zrladzvsshl04e52vipgtcvo.jpeg"><br><br>  Dementsprechend benötigen wir für CI schnelle und stabile Tests, die aus zufälligen Gründen nicht fehlschlagen.  Wir möchten Tests für Poolanfragen ohne Teststände, Backends, Datenbanken und ohne komplizierte Benutzerfälle ausführen. <br><br>  Wir möchten, dass diese Tests gleichzeitig mit dem Code geschrieben werden und dass die Testergebnisse sofort deutlich machen, in welcher Datei etwas schief gelaufen ist. <br><br>  Alexey: <br>  - Ja, und wir haben beschlossen, alles zu versuchen, was wir wollen, um alles von Anfang bis Ende in derselben Jest-Infrastruktur zu verbessern.  Warum haben wir uns für Jest entschieden?  Wir haben bereits Unit-Tests zu Jest geschrieben, es hat uns gefallen.  Dies ist ein beliebtes, unterstütztes Tool, das bereits eine Reihe vorgefertigter Integrationen enthält: React Test Render, Enzyme.  Alles funktioniert sofort, nichts muss gebaut werden, alles ist einfach. <br><br><img src="https://habrastorage.org/webt/js/bo/sa/jsbosapwtytq_x6a8zkvxl6gdv0.jpeg"><br><br>  Und Jest hat persönlich für mich gewonnen, da es im Gegensatz zu jedem Moka schwierig ist, die Nebenwirkung eines Tests eines Drittanbieters in Ihr Bein zu schießen, wenn ich vergessen habe, ihn oder etwas anderes zu reinigen.  In Moka wird dies ein- oder zweimal gemacht, aber in Jest ist es schwierig: Es wird ständig in separaten Threads gestartet.  Es ist möglich, aber schwierig.  Und für e2e Puppeteer haben wir uns auch entschlossen, es zu versuchen.  Das haben wir bekommen. <br><br><img src="https://habrastorage.org/webt/ab/ph/oa/abphoap_rzksxw_spwh4t_0nfra.jpeg"><br><br>  Natalya: <br>  "Ich werde auch mit einem Beispiel für Unit-Tests beginnen."  Wenn wir Tests nur für eine Funktion schreiben, gibt es keine besonderen Probleme.  Wir rufen diese Funktion auf, übergeben einige Argumente, vergleichen, was passiert ist, mit dem, was hätte passieren sollen. <br><br>  Wenn wir über React-Komponenten sprechen, wird alles etwas komplizierter.  Wir müssen sie irgendwie rendern.  Es gibt einen React-Test-Renderer, der jedoch für Unit-Tests nicht sehr praktisch ist, da wir Komponenten nicht isoliert testen können.  Es wird die Komponente vollständig bis zum Ende rendern, bis zum Layout. <br><br>  Und ich möchte zeigen, wie es mit Enzyme möglich ist, Unit-Tests für React-Komponenten anhand eines Beispiels für eine solche Komponente zu schreiben, für die wir eine bestimmte MyComponent haben.  Er bekommt eine Art Requisite, er hat eine Art Logik.  Dann gibt er die Foo-Komponente zurück, die wiederum die Balkenkomponente zurückgibt, die bereits in der Balkenkomponente tatsächlich das Layout an uns zurückgibt. <br><br><img src="https://habrastorage.org/webt/h2/1e/e6/h21ee6qkeeucwkgnvye6ewsgxog.jpeg"><br><br>  Wir können ein Enzym-Tool wie das flache Rendern verwenden.  Dies ist genau das, was wir brauchen, um die MyComponent-Komponente isoliert zu testen.  Und diese Tests hängen nicht davon ab, was die Komponenten foo und bar in sich enthalten.  Wir werden nur die Logik der Komponente MyComponent testen. <br><br>  Jest hat so etwas wie Snapshot, und sie können uns auch hier helfen.  "Erwarten Sie etwas zu MatchSnapshot" erstellt eine solche Struktur für uns, nur eine Textdatei, in der tatsächlich gespeichert wird, was wir erwartet haben, was passiert und wenn dieser Test zum ersten Mal ausgeführt wird, wird diese Datei geschrieben.  Bei weiteren Testläufen wird das Erhaltene mit dem in der Datei MyComponent.test.js.snap enthaltenen Standard verglichen. <br><br>  Hier sehen wir nur, dass das gesamte Rendering genau das zurückgibt, was die Rendermethode von MyComponent zurückgibt, und was foo ist, ist im Allgemeinen egal.  Wir können solche zwei Tests für unsere zwei Fälle schreiben, für unsere zwei Fälle für die MyComponent-Komponente. <br><br><img src="https://habrastorage.org/webt/wu/b3/iw/wub3iwlwsatz7ytgzpeim8vsbqs.jpeg"><br><br>  Im Prinzip können wir dasselbe ohne einen Snapshot testen, indem wir nur die benötigten Skripte überprüfen, zum Beispiel, welche Requisite an die foo-Komponente übergeben wird.  Dieser Ansatz hat jedoch ein Minus.  Wenn wir MyComponent, unserem neuen Test, ein anderes Element hinzufügen, wird dies in keiner Weise angezeigt. <br><br><img src="https://habrastorage.org/webt/pd/9e/vy/pd9evyrhuh7kfzrqcukvwpbudaq.jpeg"><br><br>  Schnappschuss-Tests sind daher diejenigen, die uns fast alle Änderungen innerhalb der Komponente zeigen.  Wenn wir jedoch beide Tests in Snapshot schreiben und dann dieselben Änderungen an der Komponente vornehmen, werden wir feststellen, dass beide Tests fallen.  Im Prinzip sagen uns die Ergebnisse dieser gefallenen Tests ungefähr dasselbe, dass wir dort eine Art „Hallo“ hinzugefügt haben. <br><br><img src="https://habrastorage.org/webt/gv/c1/dc/gvc1dcwq9aw2m3owq6c-esulpsg.jpeg"><br><br>  Und das ist auch überflüssig, daher glaube ich, dass es besser ist, einen Snapshot-Test für dieselbe Struktur zu verwenden.  Überprüfen Sie den Rest der Logik irgendwie anders, ohne Snapshot, da Snapshot nicht sehr bezeichnend ist.  Wenn Sie Snapshot sehen, sehen Sie nur, dass etwas gerendert wurde, aber es ist nicht klar, welche Logik Sie hier getestet haben.  Dies ist für TDD völlig ungeeignet, wenn Sie es verwenden möchten.  Und es funktioniert nicht wie eine Dokumentation.  Das heißt, wenn Sie sich diese Komponente ansehen, werden Sie feststellen, dass Snapshot zwar etwas entspricht, aber welche Logik es gab, ist nicht sehr klar. <br><br><img src="https://habrastorage.org/webt/wa/yc/ia/wayciagk2zoa51amkq8bb9xcqic.jpeg"><br><br><img src="https://habrastorage.org/webt/zk/mj/sa/zkmjsaoqa-34pqk2flku7_n7nsy.jpeg"><br><br>  Auf die gleiche Weise werden wir Unit-Tests für die foo-Komponente schreiben, für die Balkenkomponente, zum Beispiel Snapshot. <br><br><img src="https://habrastorage.org/webt/bg/eu/lk/bgeulklgkyqg-woog9tkqhkkpco.jpeg"><br><br>  Wir erhalten eine 100% ige Abdeckung für diese drei Komponenten.  Wir glauben, dass wir alles überprüft haben, wir sind gut gemacht. <br><br>  Nehmen wir an, wir haben etwas an der Stangenkomponente geändert, eine neue Requisite hinzugefügt und natürlich einen Test für die Stangenkomponente durchgeführt.  Wir haben den Test korrigiert und alle drei Tests bestehen mit uns. <br><br><img src="https://habrastorage.org/webt/4i/pe/xc/4ipexciijx7ss998ugl84hr6smi.jpeg"><br><br>  Wenn wir jedoch diese ganze Geschichte sammeln, funktioniert nichts, da MyComponent mit einem solchen Fehler nicht zurechtkommt.  Wir geben die erwartete Stütze nicht an die Stangenkomponente weiter.  Daher sprechen wir über die Tatsache, dass wir in diesem Fall auch Integrationstests benötigen, die prüfen, ob wir die untergeordnete Komponente von unserer Komponente korrekt aufrufen. <br><br><img src="https://habrastorage.org/webt/8e/aa/zk/8eaazkltwuurjeh7fhef39ovblq.jpeg"><br><br>  Wenn Sie solche Komponenten haben und eine davon ändern, sehen Sie sofort, welche Auswirkungen diese Komponente hat. <br><br>  Welche Möglichkeiten haben wir in Enzyme, Integrationstests durchzuführen?  Flaches Rendern selbst gibt eine solche Struktur zurück.  Es enthält eine Tauchmethode. Wenn es für eine React-Komponente aufgerufen wird, schlägt es darin fehl.  Wenn wir es auf der foo-Komponente aufrufen, erhalten wir dem, was die foo-Komponente rendert. Dies ist bar. Wenn wir den Tauchgang erneut durchführen, erhalten wir tatsächlich das Layout, das die bar-Komponente an uns zurückgibt.  Dies ist nur ein Integrationstest. <br><br><img src="https://habrastorage.org/webt/oo/jm/af/oojmafj91rsbbpprnhyqf868qoy.jpeg"><br><br>  Oder Sie können alles auf einmal mit der Mount-Methode rendern, die das vollständige DOM-Rendering implementiert.  Ich rate jedoch nicht dazu, da es ein sehr schwieriger Schnappschuss sein wird.  In der Regel müssen Sie nicht die gesamte Struktur vollständig überprüfen.  Sie müssen jeweils nur die Integration zwischen der übergeordneten und der untergeordneten Komponente überprüfen. <br><br><img src="https://habrastorage.org/webt/q9/ud/i-/q9udi-03qar0hjqhxe6th8an6zc.jpeg"><br><br>  Und für MyComponent fügen wir einen Integrationstest hinzu, also füge ich im ersten Test nur Tauchen hinzu, und es stellt sich heraus, dass wir nicht nur die Logik der Komponente selbst getestet haben, sondern auch deren Integration mit der foo-Komponente.  Ebenso fügen wir den Integrationstest für die foo-Komponente hinzu, die die Balkenkomponente korrekt aufruft, und überprüfen dann die gesamte Kette. Wir sind sicher, dass keine Änderungen uns beim Rendern von MyComponent stören werden <br><br><img src="https://habrastorage.org/webt/ff/zu/fq/ffzufq_vcw5lmuygnztd0lycvao.jpeg"><br><br>  Ein weiteres Beispiel, bereits aus einem realen Projekt.  Nur kurz darüber, was Jest und Enzyme sonst noch können.  Scherz kann Moki machen.  Wenn Sie eine externe Funktion in Ihrer Komponente verwenden, können Sie diese sperren.  In diesem Beispiel rufen wir beispielsweise eine Art API auf. Wir möchten natürlich nicht in eine API im Komponententest gehen, also löschen wir einfach die Funktion getResource mit einem jest.fn-Objekt.  In der Tat die Scheinfunktion.  Dann können wir überprüfen, ob es aufgerufen wurde oder nicht, wie oft es aufgerufen wurde, mit welchen Argumenten.  All dies ermöglicht es Ihnen, Scherz zu machen. <br><br><img src="https://habrastorage.org/webt/z8/lb/ap/z8lbapgq_qzer-1vz3yazx9wo-o.jpeg"><br><br>  Beim flachen Rendern können Sie den Speicher an eine Komponente übergeben.  Wenn Sie ein Geschäft benötigen, können Sie es einfach dorthin übertragen, und es wird funktionieren. <br><br><img src="https://habrastorage.org/webt/y2/tl/ih/y2tlihjjqqwogsbftvcirxe_njc.jpeg"><br><br>  Sie können auch Status und Requisite in einer bereits gerenderten Komponente ändern. <br><br><img src="https://habrastorage.org/webt/ew/8g/hc/ew8ghcc6gtv3347yt8ik6o9v6s4.jpeg"><br><br>  Sie können die Simulationsmethode für eine Komponente aufrufen.  Es ruft nur den Handler an.  Wenn Sie beispielsweise einen Klick simulieren, wird hier onClick für die Schaltflächenkomponente aufgerufen.  All dies kann natürlich in der Dokumentation zu Enzyme, vielen nützlichen Stücken, nachgelesen werden.  Dies sind nur einige Beispiele aus einem realen Projekt. <br><br><img src="https://habrastorage.org/webt/tw/kn/9t/twkn9txihstmq5pdpc9yqgc1nnw.jpeg"><br><br>  Alexey: <br>  - Wir kommen zu der interessantesten Frage.  Wir können Jest testen, wir können Unit-Tests schreiben, Komponenten überprüfen, überprüfen, welche Elemente auf einen Klick falsch reagieren.  Wir sind in der Lage, ihre HTML zu überprüfen.  Jetzt müssen wir das Layout der Komponente CSS überprüfen. <br><br><img src="https://habrastorage.org/webt/fw/dj/8p/fwdj8pbfn6ywa4he7ejwjnq6hs4.jpeg"><br><br>  Und es ist ratsam, dies zu tun, damit sich das Prinzip des Testens in keiner Weise von dem unterscheidet, das ich zuvor beschrieben habe.  Wenn ich HTML überprüfe, dann habe ich flaches Rendern aufgerufen, es hat HTML genommen und für mich gerendert.  Ich möchte CSS überprüfen, einfach eine Art Render aufrufen und einfach überprüfen - ohne etwas zu erhöhen, ohne Werkzeuge einzurichten. <br><br><img src="https://habrastorage.org/webt/mz/u-/p2/mzu-p2y3eiblryntol0eelzghtc.jpeg"><br><br>  Ich fing an, danach zu suchen, und fast überall wurde die gleiche Antwort auf diese ganze Sache gegeben, die Puppenspieler oder Selen-Gitter genannt wurde.  Sie öffnen eine Registerkarte, gehen zu einer HTML-Seite, machen einen Screenshot und vergleichen ihn mit der vorherigen Option.  Wenn es sich nicht geändert hat, ist alles in Ordnung. <br><br>  Die Frage ist, was ist Seite HTML, wenn ich nur eine Komponente isoliert überprüfen möchte?  Es ist wünschenswert - unter verschiedenen Bedingungen. <br><br><img src="https://habrastorage.org/webt/w2/t0/vn/w2t0vni_fdskrtopftgiigmxows.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sub></sup> </h5><br>  Ich möchte nicht für jede Komponente, für jeden Status eine Reihe dieser HTML-Seiten schreiben.  Avito hat einen guten Lauf.  Roma Dvornov veröffentlichte einen Artikel über Habré, und er hatte übrigens eine Rede.  Was haben sie gemacht?  Sie nehmen Komponenten auf, setzen HTML durch ein Standard-Rendering zusammen.  Dann sammeln sie mit Hilfe von Plugins und allerlei Tricks alle Vermögenswerte, die sie haben - Bilder, CSS.  Fügen Sie alles in HTML ein und sie erhalten einfach das richtige HTML. <br><br><img src="https://habrastorage.org/webt/0j/yr/zk/0jyrzkzvwzebsx36hos2vvi1uvs.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sub></sup> </h5><br>  Und dann haben sie einen speziellen Server ausgelöst, dort HTML gesendet, es rendert es und gibt ein Ergebnis zurück.  Ein sehr interessanter Artikel, lesen Sie jedoch, Sie können viele interessante Ideen von dort zeichnen. <br><br><img src="https://habrastorage.org/webt/z5/xp/gb/z5xpgbasgyr6gooqi_dt-p4_mxw.jpeg"><br><br>  Was ich dort nicht mag.  Das Zusammenbauen einer Komponente unterscheidet sich von der Produktion.  Zum Beispiel haben wir ein Webpack, und dort wird es von einigen Babel-Assets gesammelt und auf andere Weise herausgezogen.  Ich kann nicht garantieren, dass ich getestet habe, was ich jetzt herunterladen werde. <br><br>  Und wieder ein separater Dienst für Screenshots.  Ich möchte es irgendwie einfacher machen.  Und es gab tatsächlich die Idee, dass wir es genau so sammeln sollten, wie wir es sammeln werden.  Und versuchen Sie etwas wie Docker zu verwenden, weil es so etwas ist, es kann auf einen Computer gestellt werden, lokal, es wird einfach, isoliert, berührt nichts, alles ist in Ordnung. <br><br><img src="https://habrastorage.org/webt/9k/nz/hm/9knzhmk3-qivjt6peujxtmjnovw.jpeg"><br><br>  Aber dieses Problem ist mit Seite HTML, es bleibt das gleiche, was es wirklich ist.  Und eine Idee wurde geboren.  Sie haben eine so vereinfachte webpack.conf und daraus gibt es einige EntryPoint für Client-JS.  Die Module werden beschrieben, wie man sie zusammenbaut, die Ausgabedatei, alle von Ihnen beschriebenen Plugins, alles ist konfiguriert, alles ist in Ordnung. <br><br><img src="https://habrastorage.org/webt/3f/km/ha/3fkmhal86lf6s38oq8rnnhchsdg.jpeg"><br><br>  Was ist, wenn mir das gefällt?  Er wird in meine Komponente gehen und sie isoliert sammeln.  Und es wird genau eine Komponente geben.  Wenn ich dort ein HTML-Webpack hinzufüge, wird mir auch HTML angezeigt, und diese Assets werden dort gesammelt, und dieses Ding kann jedoch bereits automatisch getestet werden. <br><br>  Und ich wollte das alles schreiben, aber dann fand ich das. <br><br><img src="https://habrastorage.org/webt/hq/ju/0s/hqju0sbemjp1z3ryufas0pk0tfu.jpeg"><br><br>  Jest-Puppenspieler-React, ein junges Plugin.  Und ich begann aktiv dazu beizutragen.  Wenn du es plötzlich probieren willst, kannst du zum Beispiel zu mir kommen, ich kann irgendwie helfen.  Das Projekt ist in der Tat nicht meins. <br><br>  Sie schreiben eine reguläre Datei als test.js, und diese Dateien müssen ein wenig separat geschrieben werden, um sie zu finden, damit nicht das gesamte Projekt für Sie kompiliert wird, sondern nur die erforderlichen Komponenten kompiliert werden.  In der Tat nehmen Sie die Webpack-Konfiguration.  Und die Eingabepunkte ändern sich in diese browser.js-Dateien, das heißt, genau das, was wir testen möchten, wird in HTML verpackt, und mit Hilfe von Puppeteer werden Screenshots erstellt. <br><br><img src="https://habrastorage.org/webt/3e/jh/fr/3ejhfrfte3ucybs-vvl6ncw28vo.jpeg"><br><br>  Was kann er tun?    ,         jest-image-snapshot.    .     ,     ,  js,   media-query, ,  . <br><br>    headless-,  ,    ,  ,   ,  headless-,     Chrome   .  web-,    , , ,   . <br><br>       Docker.          .  .  ,  Docker,  .   .  Docker     ,         , ,     Linux,   -   ,      -  .  Docker   ,            . <br><br><img src="https://habrastorage.org/webt/gt/26/zc/gt26zcwy-madcquchbm37l89lwo.jpeg"><br><br>      ?   ,       . ,  .    before-after,     ,  .   ,    .   ,         Chrome,       Firefox.    . <br><br>       .    pixelmatch.  ,   looksame,    «»,    .   ,         . <br><br><img src="https://habrastorage.org/webt/ep/zg/ov/epzgovfoqseh2bj5r7jcr8z0lr0.jpeg"><br><br>  —   .   ,  ,     .  ,    :    - ,             —    Enzyme.      Redux   store .  .    viewport,  ,      .   , ,     . <br><br><img src="https://habrastorage.org/webt/ln/wh/qu/lnwhqusfy-4mqef59zw0lmnoaus.jpeg"><br><br>      .  ,   .  ?     ,     . <br><br><img src="https://habrastorage.org/webt/ut/l6/xb/utl6xb7objmhjnhozdlamgwzjyk.jpeg"><br><br>   :       5-10        . Selenium    .    ,  , ,           .        . <br><br><img src="https://habrastorage.org/webt/md/qr/rf/mdqrrf6ueg73uu25m6wqfihyo3q.jpeg"><br><br>      Puppeteer,    e2e-.      ,          e2e- —   ,    Selenium. <br><br> : <br> — ,         Selenium Java ,    .     - JS   Puppeteer,    ,         . <br><br>     ,       .     ,           ,    . <br><br><img src="https://habrastorage.org/webt/0s/7u/ns/0s7uns7oaxi3dcwuejuhk5kwuoy.jpeg"><br><br>   —  Selenium  Java,   —  JS Puppeteer.   .   18  .          ,   ,    Java.  ,           ,       Java  Selenium. <br><br><img src="https://habrastorage.org/webt/kk/us/pj/kkuspjg5dwwz6h2tuhkwfkssth0.jpeg"><br><br> : <br> —     ?       .    , html-,    css   .   e2e. .  ,       . <br><br><img src="https://habrastorage.org/webt/sj/wg/58/sjwg58se3lov3vvrskvjjh2pw90.jpeg"><br><br>     ,    ,  .        . ,   , —  , .        ,     . -    , ,      :     ,     . <br><br>   ,         ,     .     git hook,  -,      .    green master —   ,   ,  ,      .  Vielen Dank. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459924/">https://habr.com/ru/post/de459924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459906/index.html">Tic Tac Toe, Teil 3: Rückgängig / Wiederherstellen mit Befehlsspeicher</a></li>
<li><a href="../de459910/index.html">Situation: Unternehmen haben es nicht eilig, Dienste für Sprachassistenten zu entwickeln - was sind die Risiken?</a></li>
<li><a href="../de459914/index.html">SQL Index Manager - ein kostenloses Tool zum Defragmentieren und Verwalten von Indizes</a></li>
<li><a href="../de459918/index.html">Problemlösung mit pwnable.kr 03 - bof. Pufferüberlauf auf Stapel</a></li>
<li><a href="../de459922/index.html">Entfernen von hochfrequenten Geräuschen aus den Signalen von Schwingungssensoren während der Schwingungsdiagnose von Lagern</a></li>
<li><a href="../de459928/index.html">Der Weg des Schülers zur Entwicklung mobiler Apps</a></li>
<li><a href="../de459930/index.html">Python-Importautomatisierung</a></li>
<li><a href="../de459934/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 306 (vom 8. bis 14. Juli)</a></li>
<li><a href="../de459936/index.html">9 weitere Tricks für die Arbeit mit Visual Studio</a></li>
<li><a href="../de459948/index.html">Implementierung physikalisch korrekter volumetrischer Wolken wie in Horizon Zero Dawn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>