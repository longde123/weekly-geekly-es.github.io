<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆖 🦅 🔗 Mari kita coba berbicara tentang mesin status hierarkis secara umum dan dukungannya pada SObjectizer-5 pada khususnya 👉🏽 🤠 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mesin negara yang terbatas mungkin adalah salah satu konsep yang paling mendasar dan banyak digunakan dalam pemrograman. Mesin keadaan terbatas (KA) s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mari kita coba berbicara tentang mesin status hierarkis secara umum dan dukungannya pada SObjectizer-5 pada khususnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423497/">  Mesin negara yang terbatas mungkin adalah salah satu konsep yang paling mendasar dan banyak digunakan dalam pemrograman.  Mesin keadaan terbatas (KA) secara aktif digunakan di banyak relung terapan.  Secara khusus, dalam relung seperti APCS dan telekomunikasi, yang memungkinkan untuk berurusan, pesawat ruang angkasa ditemukan sedikit lebih jarang daripada di setiap langkah. <br><br>  Oleh karena itu, dalam artikel ini kita akan mencoba untuk berbicara tentang pesawat ruang angkasa, terutama tentang mesin negara hingga hirarkis dan kemampuan canggihnya.  Dan ceritakan sedikit tentang dukungan untuk pesawat ruang angkasa di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer-5</a> , kerangka "aktor" untuk C ++.  Salah satu dari <s>dua</s> yang terbuka, bebas, lintas platform, dan masih hidup. <br><br>  Sekalipun Anda tidak tertarik pada SObjectizer, tetapi Anda belum pernah mendengar tentang mesin negara berhingga hingga hirarkis atau seberapa bermanfaat fitur canggih seperti pesawat ruang angkasa sebagai penangan input / output untuk negara atau riwayat status, maka Anda mungkin tertarik untuk mencari di bawah kucing dan baca setidaknya bagian pertama artikel. <br><a name="habracut"></a><br><h1>  Kata-kata umum tentang mesin negara hingga </h1><br>  Kami tidak akan mencoba untuk melakukan program pendidikan penuh dalam artikel tentang topik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">automata</a> dan variasi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin negara yang terbatas</a> .  Pembaca perlu memiliki setidaknya pemahaman dasar tentang jenis-jenis entitas ini. <br><br><h2>  Mesin negara hingga canggih dan kemampuannya </h2><br>  Wahana antariksa ini memiliki beberapa fitur "canggih" yang sangat meningkatkan kegunaan wahana antariksa dalam program tersebut.  Mari kita lihat fitur-fitur "canggih" ini. <br><br>  Penafian: jika pembaca mengenal diagram negara dari UML, maka dia tidak akan menemukan sesuatu yang baru untuk dirinya di sini. <br><br><h3>  Mesin negara hirarkis </h3><br>  Mungkin peluang yang paling penting dan berharga adalah pengorganisasian hierarki / persarangan negara.  Karena justru kemampuan untuk menempatkan negara ke satu sama lain yang menghilangkan "ledakan" jumlah transisi dari negara ke negara saat kompleksitas pesawat ruang angkasa meningkat. <br><br>  Lebih sulit untuk menjelaskan hal ini dengan kata-kata daripada menunjukkan dengan contoh.  Karena itu, mari kita bayangkan bahwa kita memiliki infokiosk di layar di mana pesan selamat datang pertama kali ditampilkan.  Pengguna dapat memilih item "Layanan" dan pergi ke bagian untuk memilih layanan yang ia butuhkan.  Atau dia dapat memilih item "Akun Pribadi" dan pergi ke bagian bekerja dengan data dan layanan pribadinya.  Atau dia dapat memilih bagian Bantuan.  Sejauh ini, semuanya tampak sederhana dan dapat diwakili oleh diagram keadaan berikut (sesederhana mungkin): <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  Tetapi mari kita coba untuk memastikan bahwa dengan mengklik tombol "Batal", pengguna dapat kembali dari bagian mana saja ke halaman awal dengan pesan selamat datang: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  Skema ini semakin rumit, tetapi masih terkendali.  Namun, mari kita ingat bahwa di bagian "Layanan" kami mungkin memiliki beberapa subbagian lagi, misalnya, "Layanan Populer", "Layanan Baru" dan "Daftar Lengkap".  Dan dari masing-masing bagian ini Anda juga perlu kembali ke halaman awal.  Pesawat ruang angkasa sederhana kami menjadi semakin sulit: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  Tapi ini jauh dari semua.  Kami belum memperhitungkan tombol "Kembali", yang dengannya kami harus kembali ke bagian sebelumnya.  Mari kita tambahkan reaksi ke tombol "Kembali" dan lihat apa yang kita dapatkan: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  Ya, sekarang kita melihat jalan menuju kesenangan nyata.  Tapi kami bahkan belum mempertimbangkan subbagian di bagian "Akun Saya" dan "Bantuan" ... Jika kita mulai, maka segera saja pesawat ruang angkasa kita yang sederhana, pada awalnya, akan berubah menjadi sesuatu yang tak terbayangkan. <br><br>  Di sini, persarangan negara bagian datang untuk membantu kami.  Mari kita bayangkan bahwa kita hanya memiliki dua status tingkat atas: WelcomeScreen dan UserSelection.  Semua bagian kami (yaitu, "Layanan", "Akun Saya" dan "Bantuan") akan "disarangkan" di negara bagian UserSelection.  Anda dapat mengatakan bahwa status ServicesScreen, ProfileScreen, dan HelpScreen akan menjadi anak-anak dari UserSelection.  Dan karena mereka adalah anak-anak, mereka akan mewarisi reaksi terhadap beberapa sinyal dari keadaan orang tua mereka.  Oleh karena itu, kita dapat menentukan respons terhadap tombol Batal di UserSelection.  Tetapi kita tidak perlu menentukan reaksi ini di semua cabang pembantu.  Apa yang membuat pesawat ruang angkasa kita lebih ringkas dan mudah dimengerti: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  Di sini Anda dapat mencatat bahwa reaksi untuk "Batal" dan "Kembali" telah kami tentukan di UserSelection.  Dan reaksi terhadap tombol Batal ini berfungsi untuk semua tanpa kecuali sub-kondisi UserSelection (termasuk sub-state ServicesSelection komposit lainnya).  Tetapi dalam sub-kondisi ServicesSelection, reaksi terhadap tombol Kembali sudah berbeda - pengembaliannya tidak di WelcomScreen, tetapi di ServicesScreen. <br><br>  CA yang menggunakan hierarki / bersarang negara disebut hierarchical finite state Machines (ICA). <br><br><h3>  Reaksi untuk masuk / keluar ke / dari negara </h3><br>  Fitur yang sangat berguna adalah kemampuan untuk menetapkan respons untuk memasuki keadaan tertentu, serta reaksi untuk keluar dari keadaan.  Jadi, dalam contoh di atas dengan infokiosk, pawang dapat digantung untuk memasuki setiap negara bagian, yang akan mengubah isi layar infokiosk. <br><br>  Contoh sebelumnya dapat diperluas sedikit.  Misalkan kita memiliki dua sub-kondisi di WelcomScreen: BrightWelcomScreen, di mana layar akan disorot secara normal, dan DarkWelcomScreen, di mana kecerahan layar akan berkurang.  Kita bisa membuat entri handler DarkWelcomScreen yang akan meredupkan layar.  Dan penangan keluar DarkWelcomScreen yang akan mengembalikan kecerahan normal. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3>  Perubahan status secara otomatis setelah waktu yang ditentukan </h3><br>  Kadang-kadang, mungkin perlu untuk membatasi tinggal pesawat ruang angkasa dalam keadaan tertentu.  Jadi, dalam contoh di atas, kita dapat membatasi waktu ICA kita tetap dalam status BrightWelcomScreen menjadi satu menit.  Begitu menit kedaluwarsa, ICA secara otomatis beralih ke status DarkWelcomScreen. <br><br><h3>  Sejarah pesawat ruang angkasa </h3><br>  Fitur lain yang sangat berguna dari ICA adalah sejarah keadaan pesawat ruang angkasa. <br><br>  Mari kita bayangkan bahwa kita memiliki semacam ICA abstrak dari jenis ini: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  ICA kami ini dapat beralih dari TopLevelState1 ke TopLevelState2 dan sebaliknya.  Tetapi di dalam TopLevelState1 ada beberapa negara bagian bersarang.  Jika ICA hanya berpindah dari TopLevelState2 ke TopLevelState1, maka dua status segera diaktifkan: TopLevelState1 dan NestedState1.  NestedState1 diaktifkan karena merupakan substrat awal dari status TopLevelState1. <br><br>  Sekarang bayangkan bahwa lebih lanjut ICA kami mengubah statusnya dari NestedState1 ke NestedState2.  Di dalam NestedState2, SubState InternalState1 diaktifkan (karena ini adalah substrat awal untuk NestedState2).  Dan dari InternalState1 kami pergi ke InternalState2.  Dengan demikian, kita secara simultan memiliki status berikut aktif: TopLevelState1, NestedState2 dan InternalState2.  Dan di sini kita pergi ke TopLevelState2 (mis. Kita umumnya meninggalkan TopLevelState1). <br><br>  Aktif menjadi TopLevelState2.  Setelah itu kami ingin kembali ke TopLevelState1.  Itu ada di TopLevelState1, dan tidak di substate tertentu di TopLevelState1. <br><br>  Jadi, dari TopLevelState2 kita pergi ke TopLevelState1 dan ke mana kita bisa? <br><br>  Jika TopLevelState1 tidak memiliki riwayat, maka kita akan datang ke TopLevelState1 dan NestedState1 (karena NestedState1 adalah media awal untuk TopLevelState1).  Yaitu  seluruh cerita tentang transisi di dalam TopLevelState1, yang terjadi sebelum meninggalkan TopLevelState2, benar-benar hilang. <br><br>  Jika TopLevelState1 memiliki yang disebut  sejarah dangkal, maka ketika kembali dari TopLevelState2 ke TopLevelState1 kita masuk ke NestedState2 dan InternalState1.  Kami masuk ke NestedState2 karena dicatat dalam riwayat status TopLevelState1.  Dan kita masuk ke InternalState1 karena ini adalah yang pertama untuk NestedState2.  Ternyata dalam sejarah dangkal untuk TopLevelState1, informasi disimpan hanya tentang substrat tingkat pertama.  Sejarah status tersemat di substrat ini tidak dipertahankan. <br><br>  Tetapi jika TopLevelState1 memiliki sejarah yang mendalam, maka ketika kita kembali dari TopLevelState2 ke TopLevelState1 kita masuk ke NestedState2 dan InternalState2.  Karena dalam riwayat yang mendalam, informasi lengkap tentang media aktif disimpan, terlepas dari dalamnya. <br><br><h3>  Keadaan ortogonal </h3><br>  Sejauh ini, kami telah memeriksa ICA di mana hanya satu substate yang bisa aktif di dalam negara.  Tetapi kadang-kadang mungkin ada situasi ketika dalam keadaan tertentu ICA harus ada beberapa substrat aktif secara bersamaan.  Substrat semacam itu disebut keadaan ortogonal. <br><br>  Contoh klasik yang menunjukkan status orthogonal adalah keyboard komputer yang sudah dikenal dan mode NumLock, CapsLock dan ScrollLock.  Kita dapat mengatakan bahwa bekerja dengan NumLock / CapsLock / ScrollLock dijelaskan oleh substrat ortogonal di dalam status aktif: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3>  Segala sesuatu yang Anda ingin tahu tentang mesin negara yang terbatas, tapi ... </h3><br>  Secara umum, ada artikel mendasar tentang notasi formal untuk diagram keadaan dari David Harel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Statecharts: A Formalism Visual Untuk Sistem Kompleks (1987)</a> . <br><br>  Di sana, berbagai situasi yang dapat ditemui ketika bekerja dengan mesin negara hingga diperiksa menggunakan contoh mengendalikan jam elektronik biasa.  Jika seseorang belum membacanya, saya sangat merekomendasikannya.  Pada dasarnya, semua yang dijelaskan Harel kemudian masuk ke notasi UML.  Tetapi ketika Anda membaca deskripsi diagram keadaan dari UML, Anda tidak selalu mengerti apa, mengapa, dan kapan Anda membutuhkannya.  Namun dalam artikel oleh Harel, presentasi beralih dari situasi sederhana ke situasi yang lebih kompleks.  Dan Anda lebih sadar semua kekuatan yang menyembunyikan mesin negara terbatas dalam diri mereka sendiri. <br><br><h1>  Mesin keadaan terbatas di SObjectizer </h1><br>  Selanjutnya kita akan berbicara tentang SObjectizer dan spesifiknya.  Jika Anda tidak cukup memahami contoh di bawah ini, mungkin masuk akal untuk mempelajari lebih lanjut tentang SObjectizer.  Misalnya, dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ulasan</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang SObjecizer</a> dan beberapa yang berikutnya yang memperkenalkan pembaca ke SObjectizer, bergerak dari yang sederhana ke kompleks (artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketiga</a> ). <br><br><h2>  Agen di SObjectizer adalah mesin negara </h2><br>  Agen di SObjectizer dari awal adalah mesin negara dengan status eksplisit.  Bahkan jika pengembang agen tidak mendeskripsikan salah satu dari statusnya sendiri di kelas agennya, agen masih memiliki status default, yang digunakan secara default.  Misalnya, jika pengembang membuat agen sepele seperti itu: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  maka dia mungkin bahkan tidak curiga bahwa pada kenyataannya semua langganan yang dibuatnya dibuat untuk keadaan default.  Tetapi jika pengembang menambahkan statusnya sendiri ke agen, maka Anda harus memikirkan untuk menandatangani agen dengan benar dalam kondisi yang benar.  Di sini, katakanlah, modifikasi agen yang sederhana (dan, seperti biasa) yang ditunjukkan di atas: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Kami menetapkan dua penangan yang berbeda untuk sinyal how_are_you, masing-masing untuk kondisi masing-masing. <br><br>  Dan kesalahan dalam modifikasi agen simple_demo ini adalah berada di st_free atau st_busy agen tidak akan merespon untuk berhenti sama sekali, karena  kami meninggalkan langganan berhenti dalam keadaan default, tetapi tidak membuat langganan yang sesuai untuk st_free dan st_busy.  Cara sederhana dan jelas untuk memperbaiki masalah ini adalah dengan menambahkan langganan yang sesuai ke st_free dan st_busy: <br><pre> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  Benar, metode ini berbau copy-paste, yang tidak bagus.  Anda dapat menghilangkan salin-tempel dengan memasukkan status induk umum untuk st_free dan st_busy: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Demi keadilan, harus ditambahkan bahwa awalnya agen SObjectizer hanya bisa menjadi mesin negara sederhana.  Dukungan untuk pesawat ruang angkasa hirarkis muncul relatif baru, pada Januari 2016. <br><br><h2>  Mengapa agen SObjectizer mesin negara terbatas? </h2><br>  Pertanyaan ini memiliki jawaban yang sangat sederhana: <s>Kebetulan bahwa</s> akar SObjectizer tumbuh dari dunia sistem kontrol proses, dan di sana mesin negara terbatas sangat sering digunakan.  Oleh karena itu, kami menganggap perlu bahwa agen di SObjectizer juga menjadi mesin negara.  Ini sangat nyaman jika dalam aplikasi yang SObjectizer mereka coba terapkan, CA digunakan.  Dan keadaan default, yang dimiliki semua agen, memungkinkan kita untuk tidak memikirkan pesawat ruang angkasa jika penggunaan pesawat ruang angkasa tidak diperlukan. <br><br>  Pada prinsipnya, jika Anda melihat Model Aktor itu sendiri, dan pada prinsip-prinsip di mana model ini dibangun: <br><br><ul><li>  seorang aktor adalah entitas dengan perilaku; </li><li>  aktor merespons pesan yang masuk; </li><li>  Setelah menerima pesan, aktor dapat: <br><ul><li>  mengirim sejumlah pesan ke aktor lain; </li><li>  membuat sejumlah aktor baru; </li><li>  Tetapkan perilaku baru untuk memproses pesan berikutnya. </li></ul></li></ul><br>  Seseorang dapat menemukan kesamaan yang kuat antara pesawat ruang angkasa sederhana dan aktor.  Anda bahkan bisa mengatakan bahwa aktor adalah mesin negara terbatas sederhana. <br><br><h2>  Fitur apa dari mesin canggih yang didukung SObjectizer? </h2><br>  Dari fitur-fitur di atas dari mesin keadaan terbatas tingkat lanjut, SObjectizer mendukung semuanya kecuali keadaan ortogonal.  Barang lain, seperti status bersarang, penangan input / output, pembatasan waktu yang dihabiskan di negara bagian, riwayat untuk negara bagian, didukung. <br><br>  Dengan dukungan negara ortogonal, pertama kalinya tidak tumbuh bersama.  Di satu sisi, arsitektur internal SObjectizer tidak dimaksudkan untuk mendukung beberapa keadaan agen yang independen dan aktif secara bersamaan.  Di sisi lain, ada pertanyaan ideologis tentang bagaimana agen yang memiliki keadaan ortogonal harus berperilaku.  Kusut pertanyaan-pertanyaan ini ternyata terlalu rumit, dan knalpot yang berguna terlalu kecil untuk menyelesaikan masalah ini.  Ya, dan dalam praktik kami, belum ada situasi di mana keadaan ortogonal diperlukan, tetapi tidak mungkin dilakukan, misalnya, dengan membagi pekerjaan di antara beberapa agen yang terkait dengan satu konteks kerja yang sama. <br><br>  Namun, jika seseorang membutuhkan fitur seperti status orthogonal, dan Anda memiliki contoh tugas dunia nyata di mana ini sangat diminati, maka mari kita bicara.  Mungkin, dengan memberikan contoh nyata di depan mata kita, kita dapat menambahkan fitur ini ke SObjectizer. <br><br><h2>  Bagaimana dukungan untuk fitur-fitur canggih ICA terlihat dalam kode </h2><br>  Pada bagian cerita ini, kami akan mencoba untuk dengan cepat membahas API SObjectizer-5 untuk bekerja dengan ICA.  Tanpa merinci lebih dalam, hanya agar pembaca memiliki gagasan tentang apa itu dan bagaimana tampilannya.  Informasi lebih rinci, jika diinginkan, dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di dokumentasi resmi</a> . <br><br><h3>  Amerika Serikat </h3><br>  Untuk mendeklarasikan status bersarang, Anda harus meneruskan ekspresi initial_substate_of atau substate_of ke konstruktor objek state_t yang sesuai: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  Jika negara S memiliki beberapa substrat C1, C2, ..., Cn, maka salah satu dari mereka (dan hanya satu) harus ditandai sebagai initial_substate_of.  Pelanggaran aturan ini didiagnosis pada saat run-time. <br><br>  Kedalaman maksimum keadaan sarang di SObjectizer-5 terbatas.  Dalam versi 5.5, ini adalah 16 level.  Pelanggaran aturan ini didiagnosis pada saat run-time. <br><br>  Trik paling penting dengan status bersarang adalah ketika kondisi yang memiliki status bersarang diaktifkan, maka beberapa negara diaktifkan sekaligus.  Misalkan ada keadaan A yang memiliki substrat B dan C, dan dalam substate B ada substrat D dan E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Ketika negara A diaktifkan, maka, pada kenyataannya, tiga negara diaktifkan segera: A, AB, dan ABD <br><br>  Fakta bahwa beberapa negara dapat aktif sekaligus memiliki efek paling serius pada dua hal kearsipan.  Pertama, untuk mencari pawang untuk pesan masuk berikutnya.  Jadi, dalam contoh yang baru saja ditampilkan, penangan pesan akan pertama-tama dicari dalam keadaan ABD. Jika tidak ada penangan yang cocok di sana, pencarian akan dilanjutkan dalam keadaan induknya, yaitu.  di AB Dan sudah sakit, jika perlu, pencarian akan terus dalam status A. <br><br>  Kedua, keberadaan beberapa status aktif mempengaruhi urutan pemanggilan penangan input / output untuk negara.  Tetapi ini akan dibahas di bawah. <br><br><h3>  Penangan I / O Negara </h3><br>  Untuk keadaan, masuk dan keluar negara penangan negara dapat ditentukan.  Ini dilakukan dengan menggunakan metode state_t :: on_enter dan state_t :: on_exit.  Biasanya, metode ini disebut dalam metode so_define_agent () (atau langsung di konstruktor agen jika agen itu sepele dan warisan dari itu tidak disediakan). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  Mungkin saat yang paling sulit dengan penangan on_enter / on_exit menggunakan mereka untuk status bersarang.  Mari kita kembali ke contoh dengan status A, B, C, D, dan E. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Misalkan setiap negara memiliki penangan on_enter dan on_exit. <br><br>  Biarkan A. menjadi kondisi agen saat ini.  status A, AB dan ABD diaktifkan Selama perubahan status agen, A.on_enter, ABon_enter, dan ABDon_enter akan dipanggil.  Dan dalam urutan itu. <br><br>  Misalkan ada transisi ke ABE. ABDon_exit dan ABEon_enter akan dipanggil. <br><br>  Jika kemudian kita menempatkan agen dalam kondisi AC, maka ABEon_exit, ABon_exit, ACon_enter akan dipanggil. <br><br>  Jika agen, sedang dalam kondisi AC, dideregistrasi, maka segera setelah penyelesaian metode so_evt_finish (), penangan ACon_exit dan A.on_exit akan dipanggil. <br><br><h3>  Batas waktu </h3><br>  Batas waktu untuk agen untuk tetap dalam keadaan tertentu diatur menggunakan metode state_t :: time_limit.  Seperti pada on_enter / on_exit, metode time_limit biasanya dipanggil di mana agen dikonfigurasi untuk bekerja di dalam SObjectizer: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  Jika batas waktu untuk keadaan diatur, maka segera setelah agen memasuki keadaan ini, SObjectizer mulai menghitung waktu yang dihabiskan di negara.  Jika agen meninggalkan negara, dan kemudian kembali ke negara ini lagi, maka hitung mundur dimulai lagi. <br><br>  Jika batas waktu ditetapkan untuk status tertanam, maka Anda harus berhati-hati, karena  mungkin ada trik-trik aneh: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  Misalkan agen memasuki negara A. I.e.  negara A dan C diaktifkan untuk A dan C.  Sebelumnya, ini akan berakhir untuk negara C dan agen akan beralih ke negara D. Ini akan memulai penghitungan mundur untuk tetap di negara D. Tetapi penghitungan mundur akan terus untuk tinggal di A!  Karena selama transisi dari C ke D, agen terus tetap dalam keadaan A. Dan lima detik setelah transisi paksa dari C ke D, agen akan pergi ke keadaan B. <br><br><h3>  Kisah demi keberuntungan </h3><br>  Secara default, status agen tidak memiliki riwayat.  Untuk mengaktifkan penyimpanan riwayat untuk suatu negara, berikan konstanta shallow_history (negara akan memiliki sejarah dangkal) atau deep_history (negara akan memiliki sejarah yang mendalam) ke konstruktor state_t.  Sebagai contoh: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  Sejarah negara adalah topik yang sulit, terutama ketika kedalaman negara bagian yang layak digunakan dan substrat memiliki sejarahnya sendiri.  Karena itu, untuk informasi yang lebih lengkap tentang topik ini, lebih baik merujuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke dokumentasi</a> , untuk bereksperimen.  Nah, untuk bertanya kepada kami apakah Anda tidak bisa mengetahuinya sendiri;) <br><br><h3>  just_switch_to, transfer_to_state, tekan </h3><br>  Kelas state_t memiliki sejumlah metode yang paling umum digunakan yang telah ditunjukkan di atas: event () untuk berlangganan acara ke pesan, on_enter () dan on_exit () untuk mengatur input / output handler, time_limit () untuk menetapkan batas waktu yang dihabiskan di suatu negara. <br><br>  Bersamaan dengan metode ini, ketika bekerja dengan ICA, metode berikut dari kelas state_t sangat berguna: <br><br>  Metode just_switch_to (), yang dirancang untuk kasus ketika satu-satunya reaksi terhadap pesan masuk adalah mentransfer agen ke keadaan baru.  Anda dapat menulis: <br><pre> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  bukannya: <br><pre> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  Metode transfer_to_state () sangat berguna ketika kita memiliki beberapa pesan M diproses dengan cara yang sama di dua negara bagian S1, S2, ..., Sn.  Tetapi, jika kita berada di negara S2, ..., Sn, maka pertama kita harus kembali ke S1, dan baru kemudian melakukan pemrosesan M. <br><br>  Jika ini terdengar rumit, maka mungkin dalam contoh kode situasi ini akan lebih dipahami: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  Tapi alih-alih mendefinisikan event handler yang sangat mirip untuk S2, ..., Sn, gunakan transfer_to_state: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  Metode suppress () menekan pencarian event handler untuk substate saat ini dan semua substrat induknya.  Misalkan kita memiliki status induk A di mana std :: abort () dipanggil pada pesan M.  Dan ada status anak B di mana M dapat diabaikan dengan aman.  Kita harus menentukan reaksi terhadap M dalam substate B, karena jika kita tidak melakukannya, maka pawang untuk B akan ditemukan dalam A. Oleh karena itu, kita perlu menulis sesuatu seperti: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  Metode suppress () memungkinkan Anda untuk menulis situasi ini dalam kode secara lebih eksplisit dan grafis: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2>  Contoh yang sangat sederhana </h2><br>  Contoh standar SObjectizer v.5.5 termasuk contoh sederhana, <a href="">blinking_led</a> , yang mensimulasikan pengoperasian indikator LED yang berkedip.  Diagram keadaan agen dari contoh ini adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  Dan di sini adalah kode agen lengkap dari contoh ini: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Di sini, semua pekerjaan aktual dilakukan di dalam penangan I / O untuk sub-negara blink_on.  Nah, ditambah, batas durasi tinggal di media blink_on dan blink_off berfungsi. <br><br><h2>  Bukan contoh yang sangat sederhana </h2><br>  Contoh standar SObjectizer v.5.5 juga mencakup contoh yang jauh lebih kompleks, <a href="">intercom_statechart</a> , yang meniru perilaku panel doorphone.  Dan diagram keadaan agen utama dalam contoh ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  Semuanya begitu keras karena peniruan ini mendukung tidak hanya memanggil apartemen dengan nomor, tetapi juga hal-hal seperti kode rahasia yang unik untuk setiap apartemen, serta kode layanan khusus.  Kode-kode ini memungkinkan Anda untuk membuka kunci pintu tanpa menekan nomor di mana pun. <br><br>  Masih ada hal-hal menarik dalam contoh ini.  Tetapi terlalu besar untuk dijelaskan secara rinci (bahkan artikel terpisah mungkin tidak cukup untuk ini).  Jadi jika Anda tertarik pada bagaimana ICA terlihat sangat rumit di SObjectizer, Anda dapat melihat dalam contoh ini.  Dan jika ada sesuatu yang tidak jelas, maka Anda dapat mengajukan pertanyaan kepada kami.  Misalnya dalam komentar di artikel ini. <br><br><h1>  Apakah mungkin untuk tidak menggunakan dukungan untuk pesawat ruang angkasa yang dibangun ke dalam SObjectizer-5? </h1><br>  Jadi, SObjectizer-5 memiliki dukungan bawaan untuk ICA dengan beragam fitur yang didukung.  Dukungan ini dibuat, tentu saja, untuk menggunakannya.  Secara khusus, mekanisme debug SObjectizer, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelacakan pengiriman pesan</a> , mengetahui keadaan agen dan menampilkan keadaan saat ini dalam pesan debug masing-masing. <br><br>  Namun demikian, jika pengembang tidak ingin karena alasan tertentu menggunakan alat SObjectizer-5 bawaan, maka ia mungkin tidak melakukan ini. <br><br>  Misalnya, Anda dapat menolak untuk menggunakan SObjectizer state_t dan yang lain menyukainya karena state_t adalah objek yang cukup berat dengan di dalam std :: string, beberapa std :: function, beberapa penghitung seperti std :: size_t, lima petunjuk ke berbagai objek dan beberapa lainnya.  Bersama-sama, ini pada Linux 64-bit dan GCC-5.5, misalnya, memberikan 160 byte per state_t (terlepas dari apa yang dapat dialokasikan dalam memori dinamis). <br><br>  Jika Anda memerlukan, katakanlah, sejuta agen dalam aplikasi, yang masing-masing akan memiliki 10 negara, maka overhead SObjectizer state_t mungkin tidak dapat diterima.  Dalam hal ini, Anda dapat menggunakan beberapa mekanisme lain untuk bekerja dengan mesin negara, mendelegasikan pemrosesan pesan secara manual ke mekanisme ini.  Sesuatu seperti: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  Dalam hal ini, Anda membayar untuk efisiensi dengan meningkatkan jumlah pekerjaan manual dan kurangnya bantuan dari mekanisme debugging SObjectizer.  Tapi di sini terserah pengembang untuk memutuskan. <br><br><h1>  Kesimpulan </h1><br>  Artikel itu ternyata sangat banyak, lebih dari yang direncanakan.  Terima kasih untuk semua orang yang membaca tempat ini.  Jika salah satu pembaca menganggap mungkin untuk meninggalkan umpan balik Anda di komentar ke artikel, maka itu akan sangat bagus. <br><br>  Jika sesuatu tetap tidak jelas, maka ajukan pertanyaan, kami akan menjawab dengan senang hati. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, dengan mengambil kesempatan ini, saya ingin menarik perhatian mereka yang tertarik pada SObjectizer, bahwa pekerjaan telah dimulai pada versi berikutnya dari SObjectizer dalam kerangka cabang 5.5. </font><font style="vertical-align: inherit;">Secara singkat tentang apa yang dipertimbangkan untuk implementasi di 5.5.23, dijelaskan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lebih lengkap, tetapi dalam bahasa Inggris, di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anda dapat meninggalkan pendapat Anda tentang salah satu fitur yang diusulkan untuk implementasi, atau menawarkan sesuatu yang lain.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada peluang nyata untuk mempengaruhi pengembangan SObjectizer. </font><font style="vertical-align: inherit;">Selain itu, setelah rilis v.5.5.23, mungkin ada jeda dalam pekerjaan pada SObjectizer dan kesempatan berikutnya untuk memasukkan sesuatu yang berguna dalam 201b SObjectizer mungkin tidak mungkin.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423497/">https://habr.com/ru/post/id423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423487/index.html">Node.js tanpa node_modules</a></li>
<li><a href="../id423489/index.html">Saya seorang dokter darurat dan saya ingin berbicara tentang elektrokardiogram Apple Watch yang baru</a></li>
<li><a href="../id423491/index.html">PHP Digest No. 139 (3 - 17 September 2018)</a></li>
<li><a href="../id423493/index.html">Android Go adalah miliar perangkat masa depan dan batas 50 MB. Kuliah Yandex</a></li>
<li><a href="../id423495/index.html">Apa yang ada di dalam XGBoost, dan apa yang harus dilakukan Go dengan itu?</a></li>
<li><a href="../id423499/index.html">DevBoy - bagaimana saya membuat proyek perangkat sumber terbuka dan meluncurkan proyek di Kickstarter</a></li>
<li><a href="../id423501/index.html">Cari dan kreasi gaya visual untuk proyek desain</a></li>
<li><a href="../id423503/index.html">Pengalaman saya bergerak, hidup dan belajar di Jerman</a></li>
<li><a href="../id423505/index.html">Zuckerberg menjual saham Facebook seharga $ 13 miliar sehingga "anak-anak kita tidak perlu sakit"</a></li>
<li><a href="../id423507/index.html">Bagaimana cara menyimpan memori pada tab browser, tetapi tidak kehilangan isinya. Pengalaman tim Yandex.Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>