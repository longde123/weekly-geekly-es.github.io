<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèΩ üåø üöæ Pig Flight, ou optimisation des interpr√®tes Bytecode üèÇüèø üíà ‚öôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Peu importe vos efforts, vous ne pouvez pas faire un cheval de course avec un porc. Vous pouvez cependant faire un porc plus rapide" (commentaire dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pig Flight, ou optimisation des interpr√®tes Bytecode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/428878/"><p><img src="https://habrastorage.org/webt/bg/lp/cz/bglpczwnjg-u0usatiwfxggd-zi.jpeg"></p><br><blockquote>  "Peu importe vos efforts, vous ne pouvez pas faire un cheval de course avec un porc. Vous pouvez cependant faire un porc plus rapide" (commentaire dans le code source d'Emax) </blockquote><p>  Tout le monde sait que les porcs ne volent pas.  Tout aussi populaire est l'opinion selon laquelle les interpr√®tes de bytecode en tant que technique pour ex√©cuter des langages de haut niveau ne peuvent pas √™tre acc√©l√©r√©s sans l'utilisation d'une compilation dynamique longue. </p><br><p>  Dans la deuxi√®me partie d'une s√©rie d'articles sur les interpr√®tes de bytecode, j'essaierai de montrer par l'exemple d'une petite machine virtuelle FDA empil√©e (Pig Virtual Machine) que tout n'est pas perdu pour les porcelets assidus et ambitieux et qu'il est tout √† fait possible d'acc√©l√©rer dans le cadre (principalement) de la norme C le travail de ces interpr√®tes est au moins une fois et demie. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premi√®re partie, introduction</a> <br>  Deuxi√®me partie, optimisation (actuelle) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Troisi√®me partie, appliqu√©e</a> </p><br><h1 id="porosenokvm">  Porcelet </h1><br><p>  Faisons connaissance. </p><br><p>  <a href="">Piglet</a> VM est une machine empil√©e ordinaire bas√©e sur un <a href="">exemple</a> de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie d'une</a> s√©rie d'articles.  Notre cochon ne conna√Æt qu'un seul type de donn√©es - un mot machine 64 bits, et tous les calculs (entiers) sont effectu√©s sur la pile avec une profondeur maximale de 256 mots machine.  En plus de la pile, ce porcelet a une m√©moire de travail de 65 536 mots machine.  Le r√©sultat de l'ex√©cution du programme - un mot machine - peut √™tre soit plac√© dans le registre des r√©sultats, soit simplement envoy√© vers la sortie standard (stdout). </p><br><p>  L'√©tat complet de la machine Piglet VM est stock√© dans une seule structure: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Current instruction pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-comment"><span class="hljs-comment">/* Fixed-size stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[STACK_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> *stack_top; <span class="hljs-comment"><span class="hljs-comment">/* Operational memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> memory[MEMORY_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* A single register containing the result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> result; } vm;</code> </pre> <br><p>  Ce qui pr√©c√®de nous permet d'attribuer cette machine √† des machines virtuelles de bas niveau, la quasi-totalit√© de la surcharge qui incombe √† la maintenance du cycle de programme principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(bytecode); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_PUSHI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: { <span class="hljs-comment"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * ... * Lots of other instruction handlers here * ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_END_OF_STREAM; }</code> </pre> <br><p>  Le code montre que pour chaque opcode, le piggy doit: </p><br><ol><li>  R√©cup√©rez l'opcode du flux d'instructions. </li><li>  Assurez-vous que l'opcode est dans la plage valide de valeurs d'opcode (cette logique est ajout√©e par le compilateur C lors de la g√©n√©ration du code de commutateur). </li><li>  Allez aux instructions du corps. </li><li>  Extrayez les arguments d'instruction de la pile ou d√©codez un argument d'instruction situ√© directement dans le bytecode. </li><li>  Effectuez une op√©ration. </li><li>  S'il y a un r√©sultat du calcul, mettez-le sur la pile. </li><li>  D√©placez le pointeur de l'instruction en cours √† la suivante. </li></ol><br><p>  La charge utile n'est ici que dans le cinqui√®me paragraphe, le reste est une surcharge: d√©codage ou r√©cup√©ration des arguments d'instruction de la pile (article 4), v√©rification de la valeur de l'opcode (article 2), retour √† plusieurs reprises au d√©but de la boucle principale et √† la transition conditionnelle difficile √† pr√©voir (article 3). </p><br><p>  En bref, le porc a clairement d√©pass√© l'indice de masse corporelle recommand√©, et si nous voulons le mettre en forme, nous devrons faire face √† tous ces exc√®s. </p><br><h1 id="svinskiy-yazyk-assemblera-i-resheto-eratosfena">  Langage d'assemblage de porcs et tamis d'Eratosth√®ne </h1><br><p>  D√©cidons d'abord des r√®gles du jeu. </p><br><p>  √âcrire des programmes pour une machine virtuelle directement en C est une mauvaise id√©e, mais la cr√©ation d'un langage de programmation est longue, nous avons donc d√©cid√© de nous limiter √† un langage d'assemblage piggy. </p><br><p>  Un programme qui calcule la somme des nombres de 1 √† 65 536 dans cet assembleur ressemble √† ceci: </p><br><pre> <code class="plaintext hljs"># sum numbers from 1 to 65535 # init the current sum and the index PUSHI 1 PUSHI 1 # stack s=1, i=1 STOREI 0 # stack: s=1 # routine: increment the counter, add it to the current sum incrementandadd: # check if index is too big LOADI 0 # stack: s, i ADDI 1 # stack: s, i+1 DUP # stack: s, i+1, i+1 GREATER_OR_EQUALI 65535 # stack: s, i+1, 1 or 0 JUMP_IF_TRUE done # stack: s, i+1 DUP # stack: s, i+1, i+1 STOREI 0 # stack: s, i+1 ADD # stack: s+i+1 JUMP incrementandadd done: DISCARD PRINT DONE</code> </pre> <br><p>  Pas Python, bien s√ªr, mais il y a tout ce dont vous avez besoin pour le bonheur des cochons: commentaires, balises, sauts conditionnels et inconditionnels, des mn√©moniques pour les instructions et la possibilit√© de sp√©cifier des arguments directs aux instructions. </p><br><p>  Complet avec la machine "Piglet VM" sont assembleur et d√©monteur, qui sont courageux dans l'esprit et ont beaucoup de temps libre, les lecteurs peuvent tester ind√©pendamment au combat. </p><br><p>  Les chiffres s'additionnent tr√®s rapidement, donc pour tester les performances, j'ai √©crit un autre programme - une impl√©mentation na√Øve du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tamis d'Eratosth√®ne</a> . </p><br><p>  En fait, le porcelet fonctionne de toute fa√ßon assez rapidement (ses instructions sont proches de celles de la machine), donc, pour obtenir des r√©sultats clairs, je ferai chaque mesure pour une centaine de d√©marrages du programme. </p><br><p>  La premi√®re version de notre porc non optimis√© fonctionne comme ceci: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null PROFILE: switch code finished took 545ms</code> </pre> <br><p>  Une demi-seconde!  La comparaison est certainement malhonn√™te, mais le m√™me algorithme Python fait une centaine de courses un peu plus lentement: </p><br><pre> <code class="plaintext hljs">&gt; python test/sieve.py &gt; /dev/null 4.66692185402</code> </pre> <br><p>  4,5 secondes, ou neuf fois plus lentement.  Nous devons rendre hommage au porcelet - il en a la capacit√©!  Eh bien, voyons maintenant si notre porc peut gonfler la presse. <br><img src="https://habrastorage.org/webt/ce/eq/ni/ceeqnik6-41cuvd3rwvkkuquoes.jpeg"></p><br><h1 id="uprazhnenie-pervoe-staticheskie-superinstrukcii">  Exercice 1: Superinstructions statiques </h1><br><p>  La premi√®re r√®gle du code rapide est de ne pas faire trop de travail.  La deuxi√®me r√®gle du code rapide est de ne jamais faire trop de travail.  Alors, quel genre de travail suppl√©mentaire fait Piglet VM? </p><br><p>  Premi√®re observation: le profilage de notre programme montre qu'il existe des s√©quences d'instructions plus courantes que d'autres.  Nous ne tourmenterons pas beaucoup notre cochon et nous limiterons √† quelques instructions: </p><br><ol><li>  LOADI 0, ADD - mettez sur la pile un num√©ro de la m√©moire √† l'adresse 0 et ajoutez-le au num√©ro en haut de la pile. </li><li>  PUSHI 65536, GREATER_OR_EQUAL - mettez un nombre sur la pile et comparez-le avec le num√©ro qui √©tait pr√©c√©demment en haut de la pile, en remettant le r√©sultat de la comparaison (0 ou 1) sur la pile. </li><li>  PUSHI 1, ADD - mettez un nombre sur la pile, ajoutez-le au num√©ro qui √©tait pr√©c√©demment en haut de la pile et remettez le r√©sultat de l'addition sur la pile. </li></ol><br><p>  Il y a un peu plus de 20 instructions dans la machine VM Piglet, et un octet entier est utilis√© pour l'encodage - 256 valeurs.  L'introduction de nouvelles instructions n'est pas un probl√®me.  Ce que nous ferons: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LOADADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get immediate argument as an memory address , add it to value from the address to the top * of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> addr = NEXT_ARG(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> val = vm.memory[addr]; *TOS_PTR() += val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_GREATER_OR_EQUALI:{ <span class="hljs-comment"><span class="hljs-comment">/* get the immediate argument, compare it with the value from the address to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() = PEEK() &gt;= arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* Add immediate value to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> }</code> </pre><br><p>  Rien de compliqu√©.  Voyons ce qui en est ressorti: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 410ms</code> </pre> <br><p>  Ouah!  Le code n'est que pour trois nouvelles instructions, et nous avons gagn√© une centaine de millisecondes! </p><br><p>  Le gain ici est obtenu du fait que notre piggy ne fait pas de mouvements inutiles lors de l'ex√©cution de telles instructions: le thread d'ex√©cution ne tombe pas dans la boucle principale, rien n'est d√©cod√©, et les arguments des instructions ne passent pas √† nouveau dans la pile. </p><br><p>  C'est ce qu'on appelle des superinstructions statiques, car des instructions suppl√©mentaires sont d√©finies statiquement, c'est-√†-dire par le programmeur de la machine virtuelle au stade du d√©veloppement.  Il s'agit d'une technique simple et efficace que toutes les machines virtuelles des langages de programmation utilisent sous une forme ou une autre. </p><br><p>  Le principal probl√®me des superinstructions statiques est que sans programme sp√©cifique, il est impossible de d√©terminer quelles instructions doivent √™tre combin√©es.  Diff√©rents programmes utilisent diff√©rentes s√©quences d'instructions, et vous ne pouvez d√©couvrir ces s√©quences qu'au stade du lancement d'un code sp√©cifique. </p><br><p>  L'√©tape suivante pourrait √™tre la compilation dynamique de superinstructions dans le contexte d'un programme sp√©cifique, c'est-√†-dire les superinstructions dynamiques (dans les ann√©es 90 et au d√©but des ann√©es 2000, cette technique jouait le r√¥le d'une compilation JIT primitive). </p><br><p>  Il est impossible de cr√©er des instructions √† la vol√©e dans le cadre du C ordinaire, et notre porcelet ne consid√®re pas √† juste titre qu'il s'agit d'une comp√©tition honn√™te.  Heureusement, j'ai quelques meilleurs exercices pour lui. </p><br><h1 id="uprazhnenie-vtoroe-proverka-intervala-znacheniy-opkodov">  Exercice 2: v√©rification de la plage de valeurs d'opcode </h1><br><p>  En suivant nos r√®gles de code rapide, nous nous posons une fois de plus l'√©ternelle question: que ne pouvez-vous pas faire? </p><br><p>  Lorsque nous nous sommes familiaris√©s avec le p√©riph√©rique de la machine VM Piglet, j'ai r√©pertori√© toutes les actions que la machine virtuelle effectue pour chaque opcode.  Et le point 2 (v√©rifier la valeur de l'opcode pour s'adapter √† la plage valide de valeurs de commutateur) est le plus suspect. </p><br><p>  Voyons comment GCC compile la construction du commutateur: </p><br><ol><li>  Une table de transition est construite, c'est-√†-dire une table qui affiche la valeur de l'opcode √† l'adresse du code ex√©cutant le corps de l'instruction. </li><li>  Un code est ins√©r√© qui v√©rifie si l'opcode re√ßu se situe dans la plage de toutes les valeurs de commutateur possibles et l'envoie √† l'√©tiquette par d√©faut s'il n'y a pas de gestionnaire pour l'opcode. </li><li>  Le code qui va au gestionnaire est ins√©r√©. </li></ol><br><p>  Mais pourquoi v√©rifier l'intervalle des valeurs pour chaque instruction?  Nous pensons que l'opcode est soit correct - mettant fin √† l'ex√©cution par l'instruction OP_DONE, soit incorrect - d√©passant le bytecode.  La queue du flux d'opcodes est marqu√©e par z√©ro et z√©ro est l'opcode de l'instruction OP_ABORT, qui termine l'ex√©cution du bytecode avec une erreur. </p><br><p>  Il s'av√®re que ce contr√¥le n'est pas du tout n√©cessaire!  Et le porcelet devrait √™tre en mesure de transmettre cette id√©e au compilateur.  Essayons de r√©parer un peu l'interrupteur principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-comment"><span class="hljs-comment">/* Let the compiler know that opcodes are always between 0 and 31 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* All the instructions here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span> ... <span class="hljs-number"><span class="hljs-number">0x1f</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*Handle the remaining 5 non-existing opcodes*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } }</code> </pre> <br><p>  Sachant que nous n'avons que 26 instructions, nous imposons un masque de bits (la valeur octale 0x1f est un 0b11111 binaire couvrant la plage de valeurs de 0 √† 31) sur l'opcode et ajoutons des gestionnaires aux valeurs inutilis√©es dans la plage de 26 √† 31. </p><br><p>  Les instructions de bits sont parmi les moins ch√®res de l'architecture x86, et elles sont certainement moins ch√®res que les branches conditionnelles probl√©matiques comme celle qui utilise la v√©rification d'intervalle.  Th√©oriquement, nous devrions gagner plusieurs cycles sur chaque instruction ex√©cutable si le compilateur comprend notre indice. </p><br><p>  Soit dit en passant, la fa√ßon de sp√©cifier la plage de valeurs dans le cas n'est pas la norme C, mais une extension GCC.  Mais pour nos besoins, ce code convient, d'autant plus qu'il n'est pas difficile de le refaire en plusieurs gestionnaires pour chacune des valeurs inutiles. </p><br><p>  Nous essayons: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 437ms PROFILE: switch code (no range check) finished took 383ms</code> </pre> <br><p>  Encore 50 millisecondes!  Porcelet, c'est comme si vous vous entendiez dans vos √©paules! .. </p><br><h1 id="uprazhnenie-trete-trassy">  Exercice trois: sentiers </h1><br><p>  Quels autres exercices peuvent aider notre porcelet?  Le plus grand gain de temps que nous avons obtenu gr√¢ce aux super instructions.  Et ils r√©duisent le nombre de sorties du cycle principal et vous permettent de vous d√©barrasser des frais g√©n√©raux correspondants. </p><br><p>  Le commutateur central est le principal probl√®me pour tout processeur avec une ex√©cution extraordinaire des instructions.  Les pr√©dicteurs de branche modernes ont appris √† bien pr√©dire m√™me des transitions indirectes aussi complexes, mais "√©taler" les points de branche le long du code peut aider le processeur √† passer rapidement d'une instruction √† l'autre. </p><br><p>  Un autre probl√®me est la lecture octet par octet des opcodes d'instructions et des arguments directs √† partir du bytecode.  Les machines physiques fonctionnent avec un mot machine 64 bits et ne l'aiment pas vraiment lorsque le code fonctionne avec des valeurs inf√©rieures. </p><br><p>  Les compilateurs fonctionnent souvent avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des blocs de base</a> , c'est-√†-dire des s√©quences d'instructions sans branches ni √©tiquettes √† l'int√©rieur.  Le bloc de base commence soit au d√©but du programme, soit √† partir de l'√©tiquette, et se termine par la fin du programme, une ramification conditionnelle ou un saut direct √† l'√©tiquette qui d√©marre le bloc de base suivant. </p><br><p>  Il y a de nombreux avantages √† travailler avec des unit√©s de base, mais notre porc s'int√©resse √† sa caract√©ristique cl√©: les instructions au sein de l'unit√© de base sont ex√©cut√©es s√©quentiellement.  Ce serait g√©nial d'isoler ces blocs de base et de suivre les instructions qu'ils contiennent sans perdre de temps √† entrer dans la boucle principale. </p><br><p>  Dans notre cas, vous pouvez m√™me √©tendre la d√©finition de l'unit√© de base √† la piste.  La piste en termes de machine Piglet VM comprendra tous les blocs de base connect√©s s√©quentiellement (c'est-√†-dire en utilisant des sauts inconditionnels). </p><br><p>  En plus de l'ex√©cution s√©quentielle des instructions, il serait bien de d√©coder √† l'avance les arguments directs des instructions. </p><br><p>  Tout cela semble assez effrayant et ressemble √† une compilation dynamique, que nous avons d√©cid√© de ne pas utiliser.  Le cochon doutait m√™me un peu de sa force, mais en pratique, cela ne s'est pas av√©r√© si mauvais. </p><br><p>  R√©fl√©chissons d'abord √† la fa√ßon dont vous pouvez imaginer les instructions incluses dans la piste: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg; trace_op_handler *handler; };</code> </pre> <br><p>  Ici arg est l'argument pr√©-d√©cod√© de l'instruction, et handler est un pointeur vers une fonction qui ex√©cute la logique de l'instruction. </p><br><p>  Maintenant, la vue de chaque trace ressemble √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> scode trace[MAX_TRACE_LEN];</code> </pre> <br><p>  Autrement dit, une trace est une s√©quence de codes s de longueur limit√©e.  Le cache de trace lui-m√™me √† l'int√©rieur de la machine virtuelle ressemble √† ceci: </p><br><pre> <code class="cpp hljs">trace trace_cache[MAX_CODE_LEN];</code> </pre> <br><p>  Il s'agit simplement d'un tableau de traces dont la longueur ne d√©passe pas la longueur de bytecode possible.  La solution est paresseuse, afin d'√©conomiser de la m√©moire, il est logique d'utiliser une table de hachage. </p><br><p>  Au d√©but de l'interpr√©teur, le premier gestionnaire de chaque trace se compilera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> trace_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; trace_i &lt; MAX_CODE_LEN; trace_i++ ) vm_trace.trace_cache[trace_i][<span class="hljs-number"><span class="hljs-number">0</span></span>].handler = trace_compile_handler;</code> </pre> <br><p>  La boucle d'interpr√©teur principale ressemble maintenant √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(vm_trace.is_running) { scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][<span class="hljs-number"><span class="hljs-number">0</span></span>]; code-&gt;handler(code); }</code> </pre> <br><p>  Un compilateur de trace est un peu plus compliqu√©, et en plus de construire une trace √† partir de l'instruction courante, il fait ce qui suit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_compile_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *trace_head)</span></span></span><span class="hljs-function"> </span></span>{ scode *trace_tail = trace_head; <span class="hljs-comment"><span class="hljs-comment">/* * Trace building here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* now, run the chain that has a trace_compile_handler replaced with proper instruction handler * function pointer */</span></span> trace_head-&gt;handler(trace_head); }</code> </pre><br><p>  Gestionnaire d'instructions normal: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_add_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-comment"><span class="hljs-comment">/* * Call the next trace handler * */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */</span></span> code++; code-&gt;handler(code); }</code> </pre> <br><p>  Un gestionnaire qui ne fait aucun appel √† la fin de la fonction termine chaque trace: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) code; vm_trace.is_running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vm_trace.error = SUCCESS; }</code> </pre> <br><p>  Tout cela, bien s√ªr, est plus compliqu√© que l'ajout de superinstructions, mais voyons si cela nous a donn√© quelque chose: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 427ms PROFILE: switch code (no range check) finished took 395ms PROFILE: trace code finished took 367ms</code> </pre> <br><p>  Vive, encore 30 millisecondes! </p><br><p>  Comment √ßa?  Au lieu de simplement naviguer dans les √©tiquettes, nous cr√©ons des cha√Ænes d'appels de gestionnaires d'instructions, passons du temps sur les appels et passons des arguments, mais notre piggy parcourt toujours les pistes plus rapidement qu'un simple commutateur avec ses √©tiquettes. </p><br><p>  Ce gain de performances sur piste est d√ª √† trois facteurs: </p><br><ol><li>  Il est facile de pr√©dire les branches dispers√©es √† diff√©rents endroits du code. </li><li>  Les arguments des gestionnaires sont toujours pr√©-encod√©s en un mot machine complet, et cela n'est fait qu'une seule fois - lors de la compilation de la trace. </li><li>  Le compilateur transforme les cha√Ænes de fonctions en un seul appel vers la premi√®re fonction de gestionnaire, ce qui est possible gr√¢ce √† l'optimisation de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appel de queue</a> . </li></ol><br><p>  Avant de r√©sumer les r√©sultats de notre formation, le porcelet et moi avons d√©cid√© d'essayer une autre technique ancienne d'interpr√©tation des programmes - le code cousu. </p><br><h1 id="uprazhnenie-chetvertoe-shityy-kod">  Exercice 4: code "cousu" </h1><br><p>  Tout cochon int√©ress√© par l'histoire des interpr√®tes a entendu un code filet√©.  Il existe de nombreuses options pour cette technique, mais elles se r√©sument toutes √† au lieu de suivre un tableau d'opcodes, en suivant un tableau, par exemple, des pointeurs vers des fonctions ou des √©tiquettes, en les suivant directement sans opcode interm√©diaire. </p><br><p>  Appeler des fonctions est une entreprise co√ªteuse et d√©nu√©e de sens de nos jours;  la plupart des autres versions du code cousu sont irr√©alisables dans le cadre de la norme C. M√™me la technique, qui sera discut√©e ci-dessous, utilise l'extension C r√©pandue, mais non standard, des pointeurs C vers les √©tiquettes. </p><br><p>  Dans la version du code cousu (code filet√© de jeton anglais) que j'ai choisi pour atteindre nos objectifs de cochon, nous enregistrons le bytecode, mais avant de commencer l'interpr√©tation, nous cr√©ons un tableau qui affiche les opcodes d'instructions √† l'adresse des √©tiquettes du gestionnaire d'instructions: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *labels[] = { [OP_PUSHI] = &amp;&amp;op_pushi, [OP_LOADI] = &amp;&amp;op_loadi, [OP_LOADADDI] = &amp;&amp;op_loadaddi, [OP_STORE] = &amp;&amp;op_store, [OP_STOREI] = &amp;&amp;op_storei, [OP_LOAD] = &amp;&amp;op_load, [OP_DUP] = &amp;&amp;op_dup, [OP_DISCARD] = &amp;&amp;op_discard, [OP_ADD] = &amp;&amp;op_add, [OP_ADDI] = &amp;&amp;op_addi, [OP_SUB] = &amp;&amp;op_sub, [OP_DIV] = &amp;&amp;op_div, [OP_MUL] = &amp;&amp;op_mul, [OP_JUMP] = &amp;&amp;op_jump, [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true, [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false, [OP_EQUAL] = &amp;&amp;op_equal, [OP_LESS] = &amp;&amp;op_less, [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal, [OP_GREATER] = &amp;&amp;op_greater, [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal, [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali, [OP_POP_RES] = &amp;&amp;op_pop_res, [OP_DONE] = &amp;&amp;op_done, [OP_PRINT] = &amp;&amp;op_print, [OP_ABORT] = &amp;&amp;op_abort, };</code> </pre> <br><p>  Faites attention aux symboles &amp;&amp; - ce sont des pointeurs vers des √©tiquettes avec le corps des instructions, l'extension la plus non standard de GCC. </p><br><p>  Pour commencer √† ex√©cuter le code, cliquez simplement sur le pointeur correspondant au premier opcode du programme: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()];</code> </pre> <br><p>  Il n'y a pas de cycle ici et il n'y en aura pas, chacune des instructions elle-m√™me fait un saut au gestionnaire suivant: </p><br><pre> <code class="cpp hljs">op_pushi: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-comment"><span class="hljs-comment">/* jump to the next instruction*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()]; }</code> </pre> <br><p>  L'absence d'un commutateur ¬´r√©partit¬ª les points de branchement le long des corps d'instructions, ce qui devrait en th√©orie aider le pr√©dicteur de branchement en cas d'ex√©cution extraordinaire des instructions.  C'est comme si nous avions int√©gr√© le commutateur directement dans les instructions et form√© manuellement une table de transition. </p><br><p>  C'est toute la technique.  Elle aimait le porcelet pour sa simplicit√©.  Voyons ce qui se passe dans la pratique: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 443ms PROFILE: switch code (no range check) finished took 389ms PROFILE: threaded code finished took 477ms PROFILE: trace code finished took 364ms</code> </pre> <br><p>  Oups!  C'est la plus lente de toutes nos techniques!  Que s'est-il pass√©?  Ex√©cutons les m√™mes tests, d√©sactivant toutes les optimisations GCC: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 969ms PROFILE: switch code (no range check) finished took 940ms PROFILE: threaded code finished took 824ms PROFILE: trace code finished took 1169ms</code> </pre> <br><p>  Ici, le code cousu fonctionne mieux. </p><br><p>  Trois facteurs jouent ici un r√¥le: </p><br><ol><li>  Le compilateur d'optimisation lui-m√™me va construire une table de conversion pas pire que notre plaque d'√©tiquette manuelle. </li><li>  Les compilateurs modernes se d√©barrassent remarquablement des appels de fonctions suppl√©mentaires. </li><li>  √Ä partir de la g√©n√©ration Haswell de processeurs Intel, les pr√©dicteurs de branche ont appris √† pr√©dire avec pr√©cision les transitions √† travers un seul point de branche. </li></ol><br><p>  Selon l'ancienne m√©moire, cette technique est encore utilis√©e dans le code de, par exemple, l'interpr√©teur Python VM, mais, franchement, de nos jours, c'est d√©j√† de l'archa√Øsme. </p><br><p>  R√©sumons et √©valuons enfin les succ√®s obtenus par notre porc. </p><br><h1 id="razbor-porosyachih-poletov">  D√©briefing </h1><br><p><img src="https://habrastorage.org/webt/co/vy/6k/covy6k28ts8__ozuzuswtqpcora.jpeg"><br>  Je ne sais pas trop comment cela peut √™tre appel√© un vol, mais avouons-le, notre cochon a parcouru un long chemin de 550 millisecondes pour une centaine de courses sur le "tamis" aux 370 millisecondes finales.  Nous avons utilis√© diff√©rentes techniques: super-instructions, se d√©barrasser de la v√©rification des intervalles de valeurs, m√©canique compliqu√©e des traces et, enfin, m√™me code cousu.  Dans le m√™me temps, nous avons, en g√©n√©ral, agi dans le cadre des choses impl√©ment√©es dans tous les compilateurs C populaires. L'acc√©l√©ration d'une fois et demie, comme il me semble, est un bon r√©sultat, et le porcelet m√©rite une portion suppl√©mentaire de son dans l'auge. </p><br><p>  L'une des conditions implicites que nous nous sommes fix√©es avec le cochon est de pr√©server l'architecture de pile de la machine VM Piglet.  La transition vers une architecture de registre, en r√®gle g√©n√©rale, r√©duit le nombre d'instructions n√©cessaires √† la logique des programmes et, en cons√©quence, peut aider √† √©liminer les sorties inutiles du gestionnaire d'instructions.  Je pense que 10 √† 20% du temps pourrait √™tre interrompu. </p><br><p>  Notre principale condition - le manque de compilation dynamique - n'est pas non plus une loi de la nature.  Pomper un cochon avec des st√©ro√Ødes sous forme de compilation JIT est tr√®s facile de nos jours: dans des biblioth√®ques comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Lightning</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LibJIT,</a> tout le sale boulot a d√©j√† √©t√© fait.  Mais le temps de d√©veloppement et la quantit√© totale de code m√™me en utilisant des biblioth√®ques augmentent √©norm√©ment. </p><br><p>  Il y a, bien s√ªr, d'autres astuces auxquelles notre petit cochon n'a pas atteint le sabot.    ,     ‚Äî       - ‚Äî    - .         ,       . </p><br><p> <strong>PS</strong>    ,  ,   ,   ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.instagram.com/vovazomb/</a> ),   . </p><br><p> <strong>PPS</strong>       ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">true-grue</a> -           ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PigletC</a> .     ! </p><br><p> <strong>PPPS</strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">iliazeus</a>    :      .            ;             .      <a href=""></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428878/">https://habr.com/ru/post/fr428878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428866/index.html">7 principes de design, attitude face aux tendances du design, portfolio UX-designer, ...</a></li>
<li><a href="../fr428868/index.html">Fichiers JAR √† plusieurs versions - mauvais ou bon?</a></li>
<li><a href="../fr428870/index.html">Mrr: FRP total pour React</a></li>
<li><a href="../fr428872/index.html">L'histoire d'un ≈ìil et de 20 op√©rations (non lisible) ou il voulait √™tre pilote, mais il n'√©tait pas autoris√© √† voler dans le ciel</a></li>
<li><a href="../fr428876/index.html">Il n'y a pas de retour en arri√®re: l'exp√©rience personnelle du testeur</a></li>
<li><a href="../fr428880/index.html">Nouvelles m√©thodes d'authentification - une menace pour la vie priv√©e?</a></li>
<li><a href="../fr428882/index.html">Mobile Yandex. Blitz: nous analysons les t√¢ches</a></li>
<li><a href="../fr428888/index.html">qml: puissance et simplicit√©</a></li>
<li><a href="../fr428890/index.html">Toute la v√©rit√© sur RTOS. Article # 18. Groupes d'indicateurs d'√©v√©nements: services d'assistance et structures de donn√©es</a></li>
<li><a href="../fr428892/index.html">Comment cr√©er un jeu AI: un guide pour les d√©butants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>