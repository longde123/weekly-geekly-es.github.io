<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ› ğŸ‘²ğŸ¼ ğŸ¦ Kami menulis aplikasi di Flutter bersama dengan Redux ğŸ‘¨ğŸ¿â€ğŸš’ ğŸ© ğŸ™ŒğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Pada artikel ini, saya ingin menunjukkan kepada Anda cara membuat aplikasi Flutter menggunakan Redux. Jika Anda tidak tahu apa itu Flut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis aplikasi di Flutter bersama dengan Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481624/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/kq/1p/xpkq1phvyqjcztfqddbiedcjijw.jpeg" alt="gambar"></div><br><br>  Halo semuanya!  Pada artikel ini, saya ingin menunjukkan kepada Anda cara membuat aplikasi Flutter menggunakan Redux.  Jika Anda tidak tahu apa itu <a href="https://flutter.dev/">Flutter</a> , maka ini adalah SDK open source untuk membuat aplikasi seluler dari Google.  Ini digunakan untuk mengembangkan aplikasi untuk Android dan iOS, dan itu juga satu-satunya cara untuk mengembangkan aplikasi untuk Google Fuchsia. <br><br>  Jika Anda terbiasa dengan Flutter dan ingin membuat aplikasi yang dirancang dengan baik, mudah diuji, dan memiliki perilaku yang sangat mudah ditebak, lanjutkan membaca artikel ini dan Anda akan segera mengetahuinya! <br><br>  Tetapi sebelum kita mulai menulis aplikasi itu sendiri.  Mari kita sedikit berkenalan dengan teori, mari kita mulai dengan menjelaskan apa itu Redux. <br><a name="habracut"></a><br><h3>  Apa itu Redux? </h3><br>  <a href="https://redux.js.org/">Redux</a> adalah arsitektur yang awalnya dibuat untuk bahasa JavaScript dan digunakan dalam aplikasi yang dibuat menggunakan <i><b>kerangka kerja reaktif</b></i> (seperti React Native atau Flutter).  Redux adalah versi sederhana dari arsitektur Flux yang dibuat oleh Facebook.  Intinya, Anda perlu tahu tiga hal: <br><br><ol><li>  Satu-satunya sumber kebenaran - seluruh <b>keadaan</b> aplikasi Anda disimpan hanya di satu tempat (disebut <b>store</b> ). </li><li>  state read-only / state read-only - untuk mengubah status aplikasi, Anda perlu mengirim tindakan (action), setelah itu negara baru akan dibuat </li><li>  perubahan dibuat menggunakan fungsi murni / fungsi murni - fungsi murni (untuk kesederhanaan, itu adalah fungsi tanpa efek samping) mengambil aplikasi keadaan saat ini dan tindakan dan mengembalikan keadaan aplikasi yang baru </li></ol><br>  <b>Catatan:</b> <i>Efek samping dari fungsi adalah kemampuan, dalam proses melakukan perhitungannya: untuk membaca dan memodifikasi nilai-nilai variabel global, melaksanakan operasi I / O, merespons situasi luar biasa, dan memanggil penangannya.</i>  <i>Jika Anda memanggil fungsi dengan efek samping dua kali dengan set nilai argumen input yang sama, mungkin terjadi bahwa nilai yang berbeda dikembalikan sebagai hasilnya.</i>  <i>Fungsi tersebut disebut fungsi non-deterministik dengan efek samping.</i> <br><br>  Kedengarannya keren, tetapi apa manfaat dari solusi ini? <br><br><ul><li>  kami memiliki kontrol atas <b>negara / negara bagian</b> - ini berarti bahwa kami tahu persis apa yang menyebabkan perubahan keadaan, kami tidak memiliki status rangkap, dan kami dapat dengan mudah memantau aliran data </li><li>  <b>Peredam</b> adalah fungsi murni yang mudah diuji - kita dapat melewati status, bertindak ke input dan memeriksa apakah hasilnya benar </li><li>  Aplikasi terstruktur dengan jelas - kami memiliki lapisan yang berbeda untuk tindakan, model, logika bisnis, dll. - sehingga Anda tahu persis di mana menambahkan <i>fitur</i> baru <i>lainnya</i> </li><li>  ini adalah arsitektur yang hebat untuk aplikasi yang lebih kompleks - Anda tidak perlu memberikan status melintasi seluruh pohon pandangan Anda dari orangtua ke anak </li><li>  dan ada satu lagi ... </li></ul><br><h3>  Perjalanan waktu redux </h3><br>  Redux memiliki satu peluang menarik - Perjalanan Waktu!  Dengan Redux dan alat terkait, Anda dapat melacak keadaan aplikasi Anda dari waktu ke waktu, memeriksa keadaan sebenarnya dan membuatnya kembali kapan saja.  Lihat fitur ini dalam aksi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/d8e/168/e4cd8e16824e262401b8c2f7fae2a181.gif" alt="gambar"></div><br><h3>  Widget Redux dengan Contoh Sederhana </h3><br>  Semua aturan di atas membuat aliran data di Redux searah.  Tapi apa artinya itu?  Dalam praktiknya, semua ini dilakukan dengan menggunakan <b>tindakan</b> , <b>reduksi</b> , <b>penyimpanan</b> , dan <b>status</b> .  Mari kita bayangkan aplikasi yang menampilkan penghitung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/eb8/5e8/871eb85e8a5a12340a0b03d81ada4635.png" alt="gambar"></div><br><ol><li>  Aplikasi Anda memiliki status tertentu saat startup (jumlah klik, yaitu 0) </li><li>  Berdasarkan kondisi ini, <b>tampilan</b> diberikan. </li><li>  Jika pengguna mengklik tombol, <b>tindakan</b> dikirim (misalnya, IncrementCounter) </li><li>  Setelah itu, <i>tindakan</i> menerima <b>peredam</b> yang mengetahui <i>keadaan</i> sebelumnya (penghitung 0), dan menerima <i>tindakan</i> (IncrementCounter) dan dapat mengembalikan <b>keadaan</b> baru (penghitung sekarang 1) </li><li>  Aplikasi kami memiliki status baru (penghitung adalah 1) </li><li>  Berdasarkan status baru, <b>tampilan</b> digambar ulang, yang menampilkan status saat ini </li></ol><br>  Jadi, seperti yang Anda lihat, biasanya ini semua tentang <b>keadaan</b> .  Anda memiliki satu status dari keseluruhan aplikasi, <b>status</b> <i>hanya-baca</i> , dan untuk membuat status baru Anda perlu mengirim <b>tindakan</b> .  <i>Tindakan</i> pengajuan meluncurkan <b>peredam</b> , yang menciptakan dan mengembalikan kepada kami <b>keadaan</b> baru.  Dan ceritanya berulang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/064/a28/abd064a286704f7c441d19257ed8a390.png" alt="gambar"></div><br>  Mari kita membuat aplikasi kecil dan mengenal implementasi pendekatan Redux dalam aksi, aplikasi akan disebut " <i>Daftar Belanja</i> " <br><br>  Kita akan melihat bagaimana Redux bekerja dalam praktiknya.  Kami akan membuat aplikasi ShoppingCart sederhana.  Aplikasi akan memiliki fitur-fitur seperti: <br><br><ul><li>  menambahkan pembelian </li><li>  Anda dapat menandai pembelian sebagai selesai </li><li>  dan itu pada dasarnya semua </li></ul><br>  Aplikasi akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b09/372/85cb09372a6f1e4fa72817ab2f2f855a.png" alt="gambar"></div><br>  Mari kita mulai menulis kode! <br><br><h3>  Prasyarat </h3><br>  Pada artikel ini, saya tidak akan menunjukkan pembuatan antarmuka pengguna untuk aplikasi ini.  <a href="https://github.com/pszklarska/flutter_shopping_cart">Anda dapat membiasakan diri dengan kode yang saya siapkan untuk Anda sebelum melanjutkan dengan penyelaman Redux</a> .  Setelah itu kami akan terus menulis kode dan menambahkan <i>Redux</i> ke aplikasi saat ini. <br><br>  <b>Catatan:</b> <i>Jika Anda belum pernah menggunakan Flutter sebelumnya, saya sarankan Anda mencoba <a href="https://codelabs.developers.google.com/codelabs/flutter/">Flutter Codelabs dari Google</a> .</i> <br><br><h3>  Persiapan awal </h3><br>  Untuk mulai menggunakan <b>Redux</b> untuk Flutter, kita perlu menambahkan dependensi ke file <i>pubspec.yaml</i> : <br><br><pre><code class="swift hljs">flutter_redux: ^<span class="hljs-number"><span class="hljs-number">0.5</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Anda juga dapat memeriksa versi dependensi ini dengan membuka halaman <a href="https://pub.dartlang.org/packages/flutter_redux">flutter_redux</a> . <br><br>  <i>Pada saat penulisan, versinya adalah, flutter_redux 0.6.0</i> <br><br><h3>  Model </h3><br>  Aplikasi kita harus bisa mengendalikan penambahan dan modifikasi elemen, jadi kita akan menggunakan model <i>CartItem</i> sederhana untuk menyimpan status satu elemen.  Semua status aplikasi kita hanya akan menjadi daftar CartItems.  Seperti yang Anda lihat, CartItem hanyalah sebuah objek. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CartItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">String</span></span> name; bool checked; <span class="hljs-type"><span class="hljs-type">CartItem</span></span>(this.name, this.checked); }</code> </pre><br>  Pertama, kita perlu menyatakan tindakan.  Sebenarnya, tindakan adalah segala niat yang dapat digunakan untuk mengubah status aplikasi.  Intinya, akan ada dua tindakan untuk menambah dan mengubah elemen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>(this.item); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToggleItemStateAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>(this.item); }</code> </pre><br>  Maka kita perlu memberi tahu aplikasi kita apa yang harus dilakukan dengan <i>tindakan</i> ini.  Itu sebabnya <i>reduksi</i> digunakan - mereka hanya mengambil status aplikasi saat ini dan tindakan (status aplikasi dan tindakan), lalu membuat dan mengembalikan status baru.  Kami akan memiliki dua metode <i>peredam</i> : <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; appReducers(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addItem(items, action); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toggleItemState(items, action); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items; } <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; addItem(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>.from(items)..add(action.item); } <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; toggleItemState(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.name == action.item.name ? action.item : item).toList(); }</code> </pre><br>  Metode <i>appReducers ()</i> mendelegasikan tindakan ke metode yang sesuai.  Kedua <i>metode addItem ()</i> dan <i>toggleItemState ()</i> mengembalikan daftar baru - ini adalah keadaan / keadaan baru kita.  Seperti yang Anda lihat, Anda <b>tidak boleh mengubah daftar saat ini</b> .  Sebagai gantinya, kami membuat daftar baru setiap kali. <br><br><h3>  StoreProvider </h3><br>  Sekarang kita memiliki <i>tindakan</i> dan <i>reduksi</i> , kita perlu menyediakan tempat untuk menyimpan <i>status aplikasi</i> .  Di Redux, ini disebut <b>toko</b> dan satu-satunya sumber kebenaran untuk aplikasi tersebut. <br><br><pre> <code class="swift hljs">void main() { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> store = new <span class="hljs-type"><span class="hljs-type">Store</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( appReducers, initialState: new <span class="hljs-type"><span class="hljs-type">List</span></span>()); runApp(new <span class="hljs-type"><span class="hljs-type">FlutterReduxApp</span></span>(store)); }</code> </pre><br>  Untuk membuat <b>toko</b> , kita harus melewati metode <i>reduksi</i> dan status awal.  Jika kami membuat <b>toko</b> , kami harus meneruskannya ke <i>StoreProvider</i> untuk memberi tahu aplikasi kami bahwa <i>toko itu</i> dapat digunakan oleh siapa saja yang ingin meminta <b>status</b> aplikasi saat ini. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlutterReduxApp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">Store</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt; store; <span class="hljs-type"><span class="hljs-type">FlutterReduxApp</span></span>(this.store); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreProvider</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( store: store, child: new <span class="hljs-type"><span class="hljs-type">ShoppingCartApp</span></span>(), ); } }</code> </pre><br>  Dalam contoh di atas, <i>ShoppingCartApp (</i> ) adalah widget utama aplikasi kita. <br><br><h3>  StoreConnector </h3><br>  Saat ini kami memiliki semuanya kecuali ... benar-benar menambahkan dan mengubah item untuk dibeli.  Bagaimana cara melakukannya?  Untuk memungkinkan ini, kita perlu menggunakan <i>StoreConnector</i> .  Ini adalah cara untuk mendapatkan <b>toko</b> dan mengirimkannya beberapa <i>tindakan</i> atau hanya mendapatkan kondisi saat ini. <br><br>  Pertama, kami ingin mendapatkan data saat ini dan menampilkannya sebagai daftar di layar: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( converter: (store) =&gt; store.state, builder: (context, list) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">ListView</span></span>.builder( itemCount: list.length, itemBuilder: (context, position) =&gt; new <span class="hljs-type"><span class="hljs-type">ShoppingListItem</span></span>(list[position])); }, ); } }</code> </pre><br>  Kode di atas membungkus <i>ListView.builder</i> dengan <i>StoreConnector</i> .  <b>StoreConnector</b> dapat menerima <b>keadaan</b> saat ini (yang merupakan daftar item <i>) dan dengan bantuan fungsi <i>peta</i> kita dapat mengubahnya menjadi apa pun.</i>  <i>Tetapi dalam kasus kami itu akan menjadi <b>negara yang</b> sama (Daftar), karena di sini kita membutuhkan daftar belanja.</i> <i><br><br></i>  <i>Selanjutnya, dalam fungsi <i>builder</i> , kita mendapatkan daftar - yang pada dasarnya adalah daftar <i>CartItems</i> dari <b>toko</b> , yang dapat kita gunakan untuk membuat <b>ListView</b> .</i> <i><br><br></i>  <i>Oke, keren - kami punya data.</i>  <i>Sekarang, bagaimana cara mengatur beberapa data?</i> <i><br><br></i>  <i>Untuk ini, kami juga akan menggunakan <i>StoreConnector</i> , tetapi dengan cara yang sedikit berbeda.</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialog</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span>&gt;( converter: (store) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (itemName) =&gt; store.dispatch(<span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>(<span class="hljs-type"><span class="hljs-type">CartItem</span></span>(itemName, <span class="hljs-literal"><span class="hljs-literal">false</span></span>))); }, builder: (context, callback) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">AddItemDialogWidget</span></span>(callback); }); } }typedef <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span> = <span class="hljs-type"><span class="hljs-type">Function</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span> itemName);</code></i> </pre> <i><br></i>  <i>Mari kita lihat kodenya.</i>  <i>Kami menggunakan <i>StoreConnector</i> , seperti pada contoh sebelumnya, tetapi kali ini, alih-alih mencocokkan daftar <i>CartItems</i> dengan daftar yang sama, kami akan melakukan konversi menggunakan <b>peta</b> ke <i>OnItemAddedCallback</i> .</i>  <i>Dengan demikian, kita dapat meneruskan <a href="https://developer.mozilla.org/ru/docs/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D1%258C/%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0">fungsi panggilan balik</a> ke <i>AddItemDialogWidget</i> dan menyebutnya ketika pengguna <i>menambahkan</i> elemen baru:</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialogWidgetState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialogWidget</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-type"><span class="hljs-type">String</span></span> itemName; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span> callback; <span class="hljs-type"><span class="hljs-type">AddItemDialogWidgetState</span></span>(this.callback); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">AlertDialog</span></span>( ... actions: &lt;<span class="hljs-type"><span class="hljs-type">Widget</span></span>&gt;[ ... new <span class="hljs-type"><span class="hljs-type">FlatButton</span></span>( child: const <span class="hljs-type"><span class="hljs-type">Text</span></span>('<span class="hljs-type"><span class="hljs-type">ADD'</span></span>), onPressed: () { ... callback(itemName); }) ], ); } }</code></i> </pre> <i><br></i>  <i>Sekarang setiap kali pengguna mengklik tombol ADD, fungsi callback mengirimkan <b>tindakan</b> <i>AddItemAction ()</i> .</i> <i><br><br></i>  <i>Sekarang kita dapat membuat implementasi yang sangat mirip untuk mengubah keadaan elemen.</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingListItem</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">ShoppingListItem</span></span>(this.item); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">OnStateChanged</span></span>&gt;( converter: (store) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (item) =&gt; store.dispatch(<span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>(item)); }, builder: (context, callback) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">ListTile</span></span>( title: new <span class="hljs-type"><span class="hljs-type">Text</span></span>(item.name), leading: new <span class="hljs-type"><span class="hljs-type">Checkbox</span></span>( value: item.checked, onChanged: (bool newValue) { callback(<span class="hljs-type"><span class="hljs-type">CartItem</span></span>(item.name, newValue)); }), ); }); } }</code></i> </pre> <i><br></i>  <i>Seperti pada contoh sebelumnya, kami menggunakan <b>StoreConnector</b> untuk menampilkan <i>Daftar untuk fungsi panggilan balik <i>OnStateChanged</i> .</i></i>  <i><i>Sekarang setiap kali flag berubah (dalam metode onChanged), fungsi callback <i>memecat</i> event <i>ToggleItemStateAction</i> .</i></i> <i><i><br><br></i></i> <h3>  <i><i>Ringkasan</i></i> </h3> <i><i><br></i></i>  <i><i>Itu saja!</i></i>  <i><i>Pada artikel ini, kami membuat aplikasi sederhana yang menampilkan daftar belanja dan sedikit terbenam dalam menggunakan arsitektur Redux.</i></i>  <i><i>Dalam aplikasi kita, kita dapat menambahkan elemen dan mengubah kondisinya.</i></i>  <i><i>Menambahkan fitur baru ke aplikasi ini semudah menambahkan <i>tindakan</i> dan <i>reduksi baru</i> .</i></i> <i><i><br><br></i></i>  <i><i><a href="https://github.com/pszklarska/FlutterShoppingCart">Di sini</a> Anda dapat menemukan kode sumber aplikasi ini, termasuk widget <b>Time Travel</b> :</i></i> <i><i><br><br></i></i>  <i><i>Semoga Anda menikmati posting ini!</i></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481624/">https://habr.com/ru/post/id481624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481610/index.html">PostgreSQL Antipatterns: memperbarui tabel besar yang sedang dimuat</a></li>
<li><a href="../id481612/index.html">Kontribusi Kecil Kami untuk Platform Avalonia UI's Fight for Fewer</a></li>
<li><a href="../id481616/index.html">Kubah geodesik. Tentang perangkat dan pengalaman perhitungan saya</a></li>
<li><a href="../id481618/index.html">MVP di Unity atau cara menyederhanakan hidup</a></li>
<li><a href="../id481620/index.html">Juniper SRX dan Cisco ASA: Next Series</a></li>
<li><a href="../id481626/index.html">Koleksi tampilan yang kompleks di iOS: masalah dan solusi pada contoh umpan VKontakte</a></li>
<li><a href="../id481628/index.html">Aturan untuk menulis langkah awal dalam kasus uji</a></li>
<li><a href="../id481630/index.html">Alat dan sumber daya bermanfaat terbaik untuk membuat startup lebih pintar di tahun 2019</a></li>
<li><a href="../id481632/index.html">Penyedia cloud: siapa yang terbaik di pasar?</a></li>
<li><a href="../id481634/index.html">Intisari Desain Makanan, November 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>