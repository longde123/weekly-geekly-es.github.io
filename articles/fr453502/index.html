<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💻 🍷 🚭 Mon râteau: des haillons aux richesses 🙏🏿 🕞 🤐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contexte 


 Je travaille en tant que développeur front-end depuis un an maintenant. Mon premier projet était un backend «ennemi». Il arrive que ce ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mon râteau: des haillons aux richesses</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453502/"><h2 id="predystoriya">  Contexte </h2><br><p>  Je travaille en tant que développeur front-end depuis un an maintenant.  Mon premier projet était un backend «ennemi».  Il arrive que ce ne soit pas un gros problème lorsque la communication est établie. </p><br><p>  Mais dans notre cas, ce n'était pas le cas. </p><a name="habracut"></a><br><p>  Nous avons développé le code, qui reposait sur le fait que le backend nous envoie certaines données, une certaine structure et un certain format.  Alors que le backend considérait normal de changer le contenu des réponses - sans avertissement.  Par conséquent, il nous a fallu des heures pour déterminer pourquoi une certaine partie du site avait cessé de fonctionner. </p><br><p>  Nous avons réalisé que nous devions vérifier ce que le backend renvoie avant de nous fier aux données qu'il nous a envoyées.  Nous avons créé une tâche de recherche sur la question de la validation des données depuis le front-end. </p><br><p>  Cette étude m'a été commandée. </p><br><p>  J'ai fait une liste de ce que je veux être dans l'outil que je voudrais utiliser pour la validation des données. </p><br><p>  Les points de sélection les plus importants étaient les points suivants: </p><br><ul><li>  description déclarative (schéma) de validation, qui est transformée en une fonction de validation qui renvoie vrai / faux (valide, non valide) </li><li>  seuil d'entrée bas; </li><li> similitude des données validées avec une description de la validation; </li><li>  facilité d'intégration des validations personnalisées; </li><li>  facilité d'intégration des messages d'erreur personnalisés. </li></ul><br><p>  Du coup, j'ai trouvé de nombreuses bibliothèques de validation, ayant revu le TOP-5 (ajv, joi, roi ...).  Ils sont tous très bons.  Mais il m'a semblé que pour résoudre 5% des cas complexes - ils ont condamné 95% des cas les plus courants à être assez verbeux et volumineux. </p><br><p>  J'ai donc pensé: pourquoi ne pas développer vous-même quelque chose qui me conviendrait. <br>  Quatre mois plus tard, la septième version de ma bibliothèque de validation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">quatuor</a> est sortie. <br>  C'était une version stable, entièrement testée, 11 000 téléchargements sur npm.  Nous l'avons utilisé sur trois projets dans une campagne de trois mois. </p><br><p>  Ces trois mois ont joué un rôle très utile.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">quatuor a</a> démontré tous ses avantages.  Il n'y a aucun problème de données avec le backend.  Chaque fois qu'ils ont changé la réponse, nous avons immédiatement jeté une erreur.  Le temps passé à rechercher les causes des bogues a considérablement diminué.  Il n'y a pratiquement plus de bogues de données. </p><br><p>  Mais des défauts ont également été identifiés. </p><br><p>  Par conséquent, j'ai décidé de les analyser et de publier une nouvelle version avec des corrections de toutes les erreurs qui ont été faites pendant le développement. <br>  Je parlerai de ces erreurs architecturales et de leurs solutions ci-dessous. </p><br><h2 id="arhitekturnye-grabli">  Râteau architectural </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  "Stroko" - une langue typique du schéma </h3><br><p>  Je vais donner un exemple de l'ancienne version du schéma pour l'objet de la personne. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p>  Ce schéma valide un objet avec trois propriétés: nom - doit être une chaîne, âge - doit être un nombre, lien vers un compte dans LinkedIn - doit être soit nul (s'il n'y a pas de compte) ou chaîne (s'il y a un compte). </p><br><p>  Ce schéma répond à mes exigences de lisibilité, de similitude avec les données validées, et je pense que le seuil d'entrée pour apprendre à écrire de tels schémas n'est pas élevé.  De plus, un tel schéma peut être facilement écrit avec une définition de type en tapuscrit: </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  (Comme vous pouvez le voir - les changements sont plus probablement cosmétiques) </p><br><p>  Lorsque j'ai pris une décision, ce qui devrait être utilisé pour les options de validation les plus fréquentes (par exemple, celles utilisées ci-dessus).  J'ai choisi d'utiliser - des chaînes, pour ainsi dire, les noms des validateurs. </p><br><p>  Mais le problème avec les chaînes est qu'elles ne sont pas disponibles pour le compilateur ou l'analyseur d'erreur.  La chaîne 'nombre' pour eux n'est pas très différente de 'numder'. </p><br><h3 id="reshenie">  Solution </h3><br><p>  La nouvelle version du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">quatuor</a> 8.0.0.  J'ai décidé de retirer du quatuor - l'utilisation de chaînes comme noms de validateurs dans le schéma. </p><br><p>  Le diagramme ressemble maintenant à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p>  Ce changement présente deux grands avantages: </p><br><ul><li>  compilateurs ou analyseurs d'erreurs - pourront détecter que le nom de la méthode est orthographié avec une erreur. </li><li>  Les lignes - ne sont plus utilisées comme élément de schéma.  Cela signifie que pour eux, vous pouvez sélectionner de nouvelles fonctionnalités dans la bibliothèque, qui seront décrites ci-dessous. </li></ul><br><h3 id="podderzhka-typescript">  Prise en charge de TypeScript </h3><br><p>  En général, les sept premières versions ont été développées en pur Javascript.  Lors du passage à un projet avec Typescript, il était nécessaire d'adapter la bibliothèque en quelque sorte.  Par conséquent, des déclarations de type pour la bibliothèque ont été écrites. </p><br><p>  Mais c'était un inconvénient - lors de l'ajout de fonctionnalités ou de la modification de certains éléments de la bibliothèque, il était toujours facile d'oublier de mettre à jour les déclarations de type. </p><br><p>  Il y avait aussi juste des inconvénients mineurs de ce genre: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Lorsque nous avons créé le validateur d'objet en ligne (0).  Nous aimerions après avoir vérifié la vraie réponse du backend en ligne (1) et traité l'erreur.  En ligne (2) pour que cette <code>person</code> type Personne.  Mais cela ne s'est pas produit.  Malheureusement, un tel contrôle n'était pas un type de garde. </p><br><h3 id="reshenie-1">  Solution </h3><br><p>  J'ai décidé de réécrire toute la bibliothèque du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">quatuor</a> sur Typescript afin que le compilateur soit engagé dans la vérification de la correspondance de la bibliothèque avec les types.  En cours de route, nous ajoutons à la fonction qui retourne le validateur compilé un paramètre de type qui déterminerait quel type garde ce type de validateur. </p><br><p>  Un exemple ressemble à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Maintenant en ligne (2) <code>person</code> est de type <code>Person</code> . </p><br><h3 id="chitaemost">  Lisibilité </h3><br><p>  Il y avait également deux cas où le code était mal lu: vérification de la conformité avec un certain ensemble de valeurs (vérification des énumérations) et vérification d'autres propriétés de l'objet. </p><br><p>  a) Vérifier les énumérations <br>  Au départ, il y avait une idée, à mon avis une bonne idée.  Nous allons le démontrer en ajoutant le champ "genre" à notre objet. <br>  L'ancienne version du circuit ressemblait à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p>  L'option est très lisible.  Mais comme d'habitude, tout s'est un peu déréglé. <br>  Avoir une énumération déclarée dans le programme, par exemple, ceci: </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p>  Naturellement, je veux l'utiliser à l'intérieur du circuit.  De sorte que lorsque vous modifiez l'une des valeurs (par exemple, «mâle» -&gt; «m», «femelle» -&gt; «f»), le schéma de validation doit également changer. </p><br><p>  Par conséquent, la validation d'énumération était presque toujours écrite comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p>  Ce qui semble assez volumineux. </p><br><p>  b) Validation des propriétés résiduelles de l'objet </p><br><p>  Supposons que nous ajoutions une telle caractéristique à notre objet - il peut avoir des champs supplémentaires, mais tous doivent être des liens vers des réseaux sociaux - cela signifie qu'ils doivent être soit <code>null</code> soit une chaîne. </p><br><p>  L'ancien schéma ressemblerait à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p>  Cette entrée a mis en évidence les propriétés restantes - de celles déjà répertoriées.  L'utilisation d'un opérateur de diffusion est plus susceptible de dérouter une personne qui veut comprendre ce schéma. </p><br><h3 id="reshenie-2">  Solution </h3><br><p>  Comme décrit ci-dessus, les chaînes ne font plus partie des schémas de validation.  Seuls trois types de valeurs Javascript restaient un schéma de validation.  Objet - pour décrire le schéma de validation de l'objet.  Tableau pour la description - plusieurs options de validité.  Fonction (générée par la bibliothèque ou personnalisée) - pour toutes les autres options de validation. </p><br><p>  Cette disposition a permis d'ajouter des fonctionnalités, ce qui a permis d'augmenter la lisibilité du circuit plusieurs fois. </p><br><p>  En fait, que se passe-t-il si nous voulons comparer la valeur avec la chaîne «male».  Avons-nous vraiment besoin de savoir autre chose que la valeur elle-même et la chaîne «male». </p><br><p>  Par conséquent, il a été décidé d'ajouter les valeurs des types primitifs comme élément du circuit.  Par conséquent, lorsque vous rencontrez une valeur primitive dans le schéma, cela signifie qu'il s'agit de la valeur valide que le validateur créé conformément à ce schéma doit vérifier.  Je ferais mieux de donner un exemple: </p><br><p>  Si nous devons vérifier le nombre d'égalité 42-esprit.  Ensuite, nous l'écrivons comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p>  Voyons comment cela affecte le schéma de la personne (sans tenir compte des propriétés supplémentaires): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p>  En utilisant des énumérations prédéfinies, nous pouvons le réécrire comme ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p>  Dans ce cas, la cérémonialité inutile a été supprimée sous la forme de l'utilisation de la méthode enum et de l'utilisation de l'opérateur d'étalement pour insérer des valeurs valides de l'objet comme paramètres dans cette méthode. </p><br><p>  Ce qui est considéré comme une valeur primitive: nombres, chaînes, caractères, <code>true</code> , <code>false</code> , <code>null</code> et <code>undefined</code> . </p><br><p>  Autrement dit, si nous devons comparer la valeur avec eux, nous utilisons simplement ces valeurs elles-mêmes.  Et une bibliothèque de validation - elle créera un validateur qui compare strictement la valeur à celles spécifiées dans le schéma. </p><br><p>  Pour valider les propriétés résiduelles, il a été choisi d'utiliser une propriété spéciale pour tous les autres champs de l'objet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p>  Ainsi, le circuit semble plus lisible.  Et plus comme des annonces Typescript. </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego">  Le validateur est lié à la fonction qui l'a créé </h3><br><p>  Dans les anciennes versions, les explications d'erreur ne faisaient pas partie du validateur.  Ils ont été ajoutés à un tableau à l'intérieur de la fonction <code>v</code> . </p><br><p>  Auparavant, pour obtenir une explication des erreurs de validation, vous deviez avoir un validateur avec vous (pour vérifier) ​​et v (pour obtenir une explication d'invalidité).  Tout cela ressemblait à ceci: <br><br>  a) Nous ajoutons des explications au schéma </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p>  À n'importe quel élément du circuit - vous pouvez ajouter une explication de l'erreur en utilisant le deuxième argument de la fonction de compilateur v. </p><br><p>  b) Effacer le tableau d'explication </p><br><p>  Avant la validation, il était nécessaire d'effacer ce tableau global dans lequel toutes les explications étaient enregistrées lors de la validation. </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c) Valider </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p>  Lors de cette vérification, si une validité a été trouvée, et au stade de la création du circuit - une explication lui a été donnée, cette explication est placée dans le <code>v.explanation</code> global <code>v.explanation</code> . </p><br><p>  d) Traitement des erreurs </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p>  Comme vous pouvez le voir ici, il y a un gros problème.  Car si on veut utiliser le validateur pas à la place de sa création.  Nous devrons le transmettre non seulement aux paramètres, mais aussi à la fonction qui l'a créé.  Parce que c'est en elle que se trouve le tableau dans lequel les explications seront ajoutées. </p><br><h3 id="reshenie-3">  Solution </h3><br><p>  Ce problème a été résolu comme suit: les explications sont devenues une partie de la fonction de validation elle-même.  Que peut-on comprendre de son type: <br>  type Validator = (valeur: any, explications?: any []) =&gt; booléen </p><br><p>  Maintenant, si vous avez besoin d'une explication de l'erreur, vous passez le tableau dans lequel vous souhaitez ajouter l'explication. </p><br><p>  Ainsi, le validateur devient une unité indépendante.  Une méthode a également été ajoutée qui peut transformer la fonction de validation en une fonction qui renvoie null si la valeur est valide et renvoie un tableau d'explications si la valeur n'est pas valide. </p><br><p>  Maintenant, la validation avec explications ressemble à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie">  Postface </h2><br><p>  J'ai souligné trois prémisses à cause desquelles j'ai dû tout réécrire: </p><br><ul><li>  L'espoir que les gens ne se trompent pas en écrivant des lignes </li><li>  Utilisation de variables globales (dans ce cas, tableau v.explanation) </li><li>  Tester avec de petits exemples au cours du développement - n'a pas montré les problèmes qui se posent lorsqu'il est utilisé dans de très gros cas. </li></ul><br><p>  Mais je suis heureux d'avoir effectué une analyse de ces problèmes, et la version publiée est déjà utilisée dans notre projet.  Et j'espère qu'il nous sera utile non moins que le précédent. </p><br><p>  Merci à tous pour la lecture, j'espère que mon expérience vous sera utile. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453502/">https://habr.com/ru/post/fr453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453484/index.html">Compteur BCD 4 bits</a></li>
<li><a href="../fr453486/index.html">Principes du marché libre américain</a></li>
<li><a href="../fr453490/index.html">Nouvelles du monde d'OpenStreetMap n ° 461 (14/05/2019 - 05/05/2019)</a></li>
<li><a href="../fr453492/index.html">Automatisation des processus d'affaires de la société Trello à l'aide de la technologie de modélisation sémantique</a></li>
<li><a href="../fr453496/index.html">Chimiste heureux, collègues</a></li>
<li><a href="../fr453508/index.html">Homme sans smartphone</a></li>
<li><a href="../fr453510/index.html">Tout à vous: nouveau didacticiel d'action pour UiPath RPA</a></li>
<li><a href="../fr453512/index.html">Transfert de style</a></li>
<li><a href="../fr453514/index.html">Guide des offres d'introduction sur iOS</a></li>
<li><a href="../fr453516/index.html">Automatisation pour les plus petits. Partie zéro. Planification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>