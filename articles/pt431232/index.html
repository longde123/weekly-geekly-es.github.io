<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüîß ü•ê üßò Geramos marcadores SVG bonitos no Node.js üëí üèõÔ∏è ‚ô®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Usar imagens SVG como espa√ßos reservados √© uma id√©ia muito boa, especialmente em nosso mundo, quando quase todos os sites consistem em v√°rias fotos qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geramos marcadores SVG bonitos no Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431232/"><p><img src="https://habrastorage.org/webt/ko/6n/vo/ko6nvoj9m3q1bdzvbeogrcbt09i.jpeg"></p><br><p> Usar imagens SVG como espa√ßos reservados √© uma id√©ia muito boa, especialmente em nosso mundo, quando quase todos os sites consistem em v√°rias fotos que estamos tentando carregar de forma ass√≠ncrona.  Quanto mais imagens e mais volumosas elas s√£o, maior a probabilidade de obter v√°rios problemas, come√ßando pelo fato de o usu√°rio n√£o entender bem o que √© carregado l√° e terminando com o conhecido salto de toda a interface ap√≥s o carregamento das imagens.  Especialmente na Internet de m√° qualidade do seu telefone - ele pode voar em v√°rias telas.  √â nesses momentos que os stubs v√™m em socorro.  Outra op√ß√£o para seu uso √© a censura.  H√° momentos em que voc√™ precisa ocultar uma imagem do usu√°rio, mas eu gostaria de manter o estilo geral da p√°gina, as cores e o local que a imagem ocupa. </p><br><p>  Mas na maioria dos artigos, todo mundo fala sobre teoria, que seria bom inserir todas essas imagens em p√°ginas em linha, e hoje veremos na pr√°tica como voc√™ pode ger√°-las ao seu gosto e cor usando o Node.js.  Vamos criar modelos de guid√£o a partir de imagens SVG e preench√™-los de diferentes maneiras, do preenchimento simples com cor ou gradiente √† triangula√ß√£o, mosaico Voronoi e uso de filtros.  Todas as a√ß√µes ser√£o classificadas em etapas.  Acredito que este artigo ser√° interessante para iniciantes que est√£o interessados ‚Äã‚Äãem como isso √© feito e precisam de uma an√°lise detalhada das a√ß√µes, mas desenvolvedores experientes tamb√©m podem gostar de algumas id√©ias. </p><a name="habracut"></a><br><h2 id="podgotovka">  Prepara√ß√£o </h2><br><p> Para come√ßar, iremos a um reposit√≥rio sem fundo de todos os tipos de coisas chamado NPM.  Como a tarefa de gerar nossas imagens stub envolve uma gera√ß√£o √∫nica delas no lado do servidor (ou mesmo na m√°quina do desenvolvedor, se estamos falando de um site mais ou menos est√°tico), n√£o trataremos da otimiza√ß√£o prematura.  Vamos conectar tudo o que gostamos.  Ent√£o, come√ßamos com o <code>npm init</code> spell e prosseguimos com a sele√ß√£o de depend√™ncias. </p><br><p>  Para iniciantes, este √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ColorThief</a> .  Voc√™ provavelmente j√° ouviu falar dele.  Uma biblioteca maravilhosa que pode isolar a paleta de cores das cores mais usadas na imagem.  S√≥ precisamos de algo assim para come√ßar. </p><br><pre> <code class="plaintext hljs">npm i --save color-thief</code> </pre> <br><p>  Ao instalar este pacote no Linux, ocorreu um problema - alguns pacotes cairo ausentes, que n√£o est√£o no diret√≥rio NPM.  Este erro estranho foi resolvido instalando vers√µes de desenvolvimento de algumas bibliotecas: </p><br><pre> <code class="plaintext hljs">sudo apt install libcairo2-dev libjpeg-dev libgif-dev</code> </pre> <br><p>  O funcionamento desta ferramenta ser√° observado no processo.  Mas n√£o ser√° sup√©rfluo conectar imediatamente o pacote rgb-hex para converter o formato de cores de RGB para Hex, o que √© √≥bvio em seu nome.  N√£o nos envolveremos no ciclismo com fun√ß√µes t√£o simples. </p><br><pre> <code class="plaintext hljs">npm i --save rgb-hex</code> </pre> <br><blockquote>  Do ponto de vista do treinamento, √© √∫til escrever essas coisas voc√™ mesmo, mas quando h√° uma tarefa de montar rapidamente um prot√≥tipo que funcione minimamente, √© uma boa id√©ia conectar tudo o que estiver no cat√°logo do NPM.  Economiza uma tonelada de tempo. </blockquote><p>  Um dos par√¢metros mais importantes para plugues s√£o as propor√ß√µes.  Eles devem corresponder √†s propor√ß√µes da imagem original.  Por conseguinte, precisamos saber seu tamanho.  Usaremos o pacote de tamanho da imagem para resolver esse problema. </p><br><pre> <code class="plaintext hljs">npm i --save image-size</code> </pre> <br><p>  Como tentaremos criar vers√µes diferentes das imagens e todas elas estar√£o no formato SVG, de uma forma ou de outra, a quest√£o dos modelos para elas surgir√°.  √â claro que voc√™ pode se esquivar das seq√º√™ncias de caracteres padr√£o em JS, mas por que tudo isso?  √â melhor usar um mecanismo de modelo "normal".  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guid√£o</a> .  Simples e de bom gosto, pois nossa tarefa ser√° perfeita. </p><br><pre> <code class="plaintext hljs">npm i --save handlebars</code> </pre> <br><p>  N√£o organizaremos imediatamente algum tipo de arquitetura complexa para este experimento.  Criamos o arquivo main.js e importamos todas as nossas depend√™ncias para l√°, al√©m de um m√≥dulo para trabalhar com o sistema de arquivos. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ColorThief = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'color-thief'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Handlebars = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'handlebars'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgbHex = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'rgb-hex'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sizeOf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'image-size'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>);</code> </pre> <br><p>  ColorThief requer inicializa√ß√£o adicional </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> thief = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorThief();</code> </pre> <br><p>  Usando as depend√™ncias que conectamos, resolver os problemas de "enviar uma foto para um script" e "obter o tamanho" n√£o √© dif√≠cil.  Digamos que temos uma imagem 1.jpg: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'1.jpg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size = sizeOf(<span class="hljs-string"><span class="hljs-string">'1.jpg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> height = size.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = size.width;</code> </pre> <br><p>  Para pessoas n√£o familiarizadas com o Node.js., vale dizer que quase tudo relacionado ao sistema de arquivos pode acontecer de forma s√≠ncrona ou ass√≠ncrona.  Para m√©todos s√≠ncronos, "Sync" √© adicionado no final do nome.  Vamos us√°-los para n√£o encontrar complica√ß√µes desnecess√°rias e n√£o quebrar nossos c√©rebros do nada. </p><br><p>  Vamos para o primeiro exemplo. </p><br><h2 id="zalivka-cvetom">  Preenchimento de cores </h2><br><p><img src="https://habrastorage.org/webt/xa/1p/7g/xa1p7gmnqwkm9rcdntn9qbtnrjm.jpeg"></p><br><p>  Para come√ßar, resolveremos o problema de simples preenchimento de um ret√¢ngulo.  Nossa imagem ter√° tr√™s par√¢metros - largura, altura e cor de preenchimento.  Criamos uma imagem SVG com um ret√¢ngulo, mas em vez desses valores substitu√≠mos pares de colchetes e os nomes dos campos que conter√£o os dados transmitidos a partir do script.  Voc√™ provavelmente j√° viu essa sintaxe com o HTML tradicional (por exemplo, o Vue usa algo semelhante), mas ningu√©m se incomoda em us√°-lo com uma imagem SVG - o mecanismo de modelo n√£o se importa com o que ser√° a longo prazo.  O texto √© ele e o texto na √Åfrica. </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'1.1'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'http://www.w3.org/2000/svg'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewBox</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0 0 100 100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">preserveAspectRatio</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'none'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ height }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ width }}'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Al√©m disso, o ColorThief fornece uma das cores mais comuns, no exemplo, √© cinza.  Para usar o modelo, lemos o arquivo com ele, digamos guid√£o para que esta biblioteca o compile e depois geramos uma linha com o stub SVG finalizado.  O pr√≥prio mecanismo de modelo substitui nossos dados (cor e tamanho) nos lugares certos. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateOneColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = thief.getColor(image); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-one-color.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, color }); fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'1-one-color.svg'</span></span>, svg, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); }</code> </pre> <br><p>  Resta apenas gravar o resultado em um arquivo.  Como voc√™ pode ver, trabalhar com o SVG √© muito bom - todos os arquivos s√£o de texto, voc√™ pode facilmente ler e escrever.  O resultado √© uma imagem retangular.  Nada interessante, mas pelo menos garantimos que a abordagem estava funcionando (um link para as fontes completas estar√° no final do artigo). </p><br><h2 id="zalivka-gradientom">  Preenchimento de gradiente </h2><br><p>  Usar gradientes √© uma abordagem mais interessante.  Aqui, podemos usar algumas cores comuns da imagem e fazer uma transi√ß√£o suave de uma para outra.  √Äs vezes, isso pode ser encontrado em sites que carregam longas fitas de fotos. </p><br><p><img src="https://habrastorage.org/webt/_e/hk/dp/_ehkdpgdhchgknqkcvbadu8dwpq.jpeg"></p><br><p>  Nosso modelo SVG agora foi expandido com esse mesmo gradiente.  Por exemplo, usaremos o gradiente linear usual.  Estamos interessados ‚Äã‚Äãem apenas dois par√¢metros - a cor no in√≠cio e a cor no final: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">linearGradient</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'my-gradient'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">gradientTransform</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'rotate(45)'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">offset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stop-color:{{ startColor }};stop-opacity:1'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">offset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stop-color:{{ endColor }};stop-opacity:1'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">linearGradient</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'url(#my-gradient)'</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  As pr√≥prias cores s√£o obtidas usando o mesmo ColorThief.  Ele tem dois modos de opera√ß√£o - ou fornece uma cor prim√°ria ou uma paleta com o n√∫mero de cores que especificamos.  Confort√°vel o suficiente.  Para o gradiente, precisamos de duas cores. </p><br><p>  Caso contr√°rio, este exemplo √© semelhante ao anterior: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateGradient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palette = thief.getPalette(image, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startColor = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...palette[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endColor = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...palette[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-gradient.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, startColor, endColor }); <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre> <br><p>  Dessa forma, voc√™ pode fazer todos os tipos de gradientes - n√£o necessariamente lineares.  Mas ainda assim este √© um resultado bastante chato.  Seria √≥timo criar algum tipo de mosaico que se parecesse remotamente com a imagem original. </p><br><h2 id="mozaika-iz-pryamougolnikov">  Mosaico retangular </h2><br><p>  Para come√ßar, vamos fazer muitos ret√¢ngulos e preench√™-los com cores da paleta que a mesma biblioteca nos fornecer√°. </p><br><p><img src="https://habrastorage.org/webt/l6/w2/hd/l6w2hd1l4bgc-pand_tz2gixe3s.jpeg"></p><br><p>  O guid√£o pode fazer muitas coisas diferentes, em particular, possui ciclos.  Passaremos a ele uma s√©rie de coordenadas e cores, e ent√£o ele descobrir√°.  N√≥s apenas envolvemos nosso ret√¢ngulo no modelo em cada um: </p><br><pre> <code class="xml hljs">{{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'11'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'11'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p>  Assim, no pr√≥prio script, agora temos uma paleta de cores completa, percorremos as coordenadas X / Y e fazemos um ret√¢ngulo com uma cor aleat√≥ria da paleta.  Tudo √© bem simples: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateMosaic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palette = thief.getPalette(image, <span class="hljs-number"><span class="hljs-number">16</span></span>); palette.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">color, index</span></span></span><span class="hljs-function">) </span></span>{ palette[index] = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...color); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rects = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; x += <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; y += <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = palette[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">15</span></span>)]; rects.push({ x, y, color }); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-mosaic.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, rects }); <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre><br><p>  Obviamente, o mosaico, embora parecido com a imagem, mas com o arranjo das cores, nem tudo √© como gostar√≠amos.  Os recursos do ColorThief nessa √°rea s√£o limitados.  Gostaria de obter um mosaico no qual a imagem original seria adivinhada, e n√£o apenas um conjunto de tijolos com mais ou menos as mesmas cores. </p><br><h2 id="uluchshaem-mozaiku">  Melhorando o mosaico </h2><br><p>  Aqui temos que ir um pouco mais fundo e obter as cores dos pixels da imagem ... </p><br><p><img src="https://habrastorage.org/webt/qf/mt/60/qfmt60p4wqhi0yil0r28wtdjskq.jpeg"></p><br><p>  Como obviamente n√£o temos uma tela no console a partir da qual geralmente obtemos esses dados, usaremos a ajuda na forma de um pacote get-pixels.  Ele pode extrair as informa√ß√µes necess√°rias do buffer com uma imagem que j√° temos. </p><br><pre> <code class="plaintext hljs">npm i --save get-pixels</code> </pre> <br><p>  Ser√° algo parecido com isto: </p><br><pre> <code class="javascript hljs">getPixels(image, <span class="hljs-string"><span class="hljs-string">'image/jpg'</span></span>, (err, pixels) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// . . . });</span></span></code> </pre> <br><p>  Obtemos um objeto que cont√©m o campo de dados - uma matriz de pixels, o mesmo que obtemos da tela.  Deixe-me lembr√°-lo de que, para obter a cor de um pixel por coordenadas (X, Y), voc√™ precisa fazer c√°lculos simples: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (y * width + x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ];</code> </pre> <br><p>  Assim, para cada ret√¢ngulo, podemos pegar a cor n√£o da paleta, mas diretamente da imagem e us√°-la.  Voc√™ obter√° algo assim (o principal aqui √© n√£o esquecer que as coordenadas na imagem diferem das nossas "normalizadas" de 0 a 100): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateImprovedMosaic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getPixels(image, <span class="hljs-string"><span class="hljs-string">'image/jpg'</span></span>, (err, pixels) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rects = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; x += <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realX = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(x * width / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; y += <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realY = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(y * height / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (realY * width + realX); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); rects.push({ x, y, color }); } } <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre> <br><p>  Para maior beleza, podemos aumentar um pouco o n√∫mero de "tijolos", reduzindo seu tamanho.  Como n√£o passamos esse tamanho para o modelo (√© claro, valeria a pena torn√°-lo o mesmo par√¢metro que a largura ou a altura da imagem), alteraremos os valores de tamanho no pr√≥prio modelo: </p><br><pre> <code class="xml hljs">{{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p>  Agora temos um mosaico que realmente se parece com a imagem original, mas ao mesmo tempo ocupa uma ordem de magnitude menos espa√ßo. </p><br><blockquote>  N√£o se esque√ßa que o GZIP compacta bem essas seq√º√™ncias repetidas nos arquivos de texto, para que, ao transferir para o navegador, o tamanho dessa visualiza√ß√£o se torne ainda menor. </blockquote><p>  Mas vamos seguir em frente. </p><br><h2 id="triangulyaciya">  Triangula√ß√£o </h2><br><p><img src="https://habrastorage.org/webt/by/h7/dq/byh7dqqiigv_3v5ayf-1lw8deyw.jpeg"></p><br><p>  Os ret√¢ngulos s√£o bons, mas os tri√¢ngulos geralmente d√£o resultados muito mais interessantes.  Ent√£o, vamos tentar fazer um mosaico a partir de uma pilha de tri√¢ngulos.  Existem diferentes abordagens para esse problema, usaremos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">triangula√ß√£o de Delaunay</a> : </p><br><pre> <code class="plaintext hljs">npm i --save delaunay-triangulate</code> </pre> <br><p>  A principal vantagem do algoritmo que usaremos √© que ele evita tri√¢ngulos com √¢ngulos muito n√≠tidos e obtusos sempre que poss√≠vel.  Para uma imagem bonita, n√£o precisamos de tri√¢ngulos estreitos e longos. </p><br><blockquote>  Esse √© um daqueles momentos em que √© √∫til saber quais algoritmos matem√°ticos em nosso campo existem e qual a diferen√ßa entre eles.  N√£o √© necess√°rio lembrar de todas as implementa√ß√µes, mas pelo menos √© √∫til saber o que pesquisar no Google. </blockquote><p>  Divida nossa tarefa em outras menores.  Primeiro voc√™ precisa gerar pontos para os v√©rtices dos tri√¢ngulos.  E seria bom adicionar alguma aleatoriedade √†s suas coordenadas: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateTriangulation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// . . . const basePoints = []; for (let x = 0; x &lt;= 100; x += 5) { for (let y = 0; y &lt;= 100; y += 5) { const point = [x, y]; if ((x &gt;= 5) &amp;&amp; (x &lt;= 95)) { point[0] += Math.floor(10 * Math.random() - 5); } if ((y &gt;= 5) &amp;&amp; (y &lt;= 95)) { point[1] += Math.floor(10 * Math.random() - 5); } basePoints.push(point); } } const triangles = triangulate(basePoints); // . . .</span></span></code> </pre> <br><p>  Depois de revisar a estrutura da matriz com tri√¢ngulos (console.log para nos ajudar), nos encontramos nos pontos em que tomaremos a cor do pixel.  Voc√™ pode simplesmente calcular a m√©dia aritm√©tica das coordenadas dos v√©rtices dos tri√¢ngulos.  Em seguida, movemos os pontos extras da borda extrema para que eles n√£o se arrastem para fora e, tendo recebido coordenadas reais e n√£o normalizadas, obtemos a cor do pixel, que se tornar√° a cor do tri√¢ngulo. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> polygons = []; triangles.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">triangle</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>]) / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-number"><span class="hljs-number">100</span></span>) { x = <span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y === <span class="hljs-number"><span class="hljs-number">100</span></span>) { y = <span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realX = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(x * width / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realY = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(y * height / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (realY * width + realX); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> points = <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>]; polygons.push({ points, color }); });</code> </pre> <br><p>  Resta apenas coletar as coordenadas dos pontos desejados em uma sequ√™ncia e envi√°-la juntamente com a cor ao Guiador para processamento, como fizemos anteriormente. </p><br><p>  No pr√≥prio modelo, agora n√£o teremos ret√¢ngulos, mas pol√≠gonos: </p><br><pre> <code class="xml hljs">{{# each polygons }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">polygon</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">points</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ points }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stroke-width:0.1;stroke:{{ color }};fill:{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p>  Triangula√ß√£o √© uma coisa muito interessante.  Ao aumentar o n√∫mero de tri√¢ngulos, voc√™ pode obter apenas imagens bonitas, porque ningu√©m diz que devemos us√°-las apenas como esbo√ßos. </p><br><h2 id="mozaika-voronogo">  Mosaico de Voronoi </h2><br><p>  H√° um problema, o espelho do anterior - uma parti√ß√£o ou um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico de Voronoi</a> .  J√° o usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ao trabalhar com shaders</a> , mas aqui tamb√©m pode ser √∫til. </p><br><p><img src="https://habrastorage.org/webt/ij/-y/4m/ij-y4mnhq9tlbbkewlmfeyn-q0k.jpeg"></p><br><p>  Como em outros algoritmos conhecidos, temos uma implementa√ß√£o pronta: </p><br><pre> <code class="plaintext hljs">npm i --save voronoi</code> </pre> <br><p>  A√ß√µes adicionais ser√£o muito semelhantes ao que fizemos no exemplo anterior.  A √∫nica diferen√ßa √© que agora temos uma estrutura diferente - em vez de uma matriz de tri√¢ngulos, temos um objeto complexo.  E as op√ß√µes s√£o um pouco diferentes.  Caso contr√°rio, tudo √© quase o mesmo.  Uma matriz de pontos base √© gerada da mesma maneira, pule-a para n√£o tornar a listagem muito longa: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateVoronoi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// . . . const box = { xl: 0, xr: 100, yt: 0, yb: 100 }; const diagram = voronoi.compute(basePoints, box); const polygons = []; diagram.cells.forEach((cell) =&gt; { let x = cell.site.x; let y = cell.site.y; if (x === 100) { x = 99; } if (y === 100) { y = 99; } const realX = Math.floor(x * width / 100); const realY = Math.floor(y * height / 100); const pixelPosition = 4 * (realY * width + realX); const rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + 1], pixels.data[pixelPosition + 2] ]; const color = '#' + rgbHex(...rgb); let points = ''; cell.halfedges.forEach((halfedge) =&gt; { const endPoint = halfedge.getEndpoint(); points += endPoint.x.toFixed(2) + ',' + endPoint.y.toFixed(2) + ' '; }); polygons.push({ points, color }); }); // . . .</span></span></code> </pre> <br><p>  Como resultado, obtemos um mosaico de pol√≠gonos convexos.  Tamb√©m √© um resultado muito interessante. </p><br><blockquote>  √â √∫til arredondar todos os n√∫meros para n√∫meros inteiros ou pelo menos algumas casas decimais.  A precis√£o excessiva no SVG √© completamente desnecess√°ria aqui, apenas aumentar√° o tamanho das imagens. </blockquote><br><h2 id="razmytaya-mozaika">  Mosaico turva </h2><br><p>  O √∫ltimo exemplo que veremos √© um mosaico emba√ßado.  Temos todo o poder do SVG em nossas m√£os, ent√£o por que n√£o usar filtros? </p><br><p><img src="https://habrastorage.org/webt/xt/us/k1/xtusk1lqy7g9zsolqqanjrmqcva.jpeg"></p><br><p>  Pegue o primeiro mosaico de ret√¢ngulos e adicione o filtro "desfoque" padr√£o: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'my-filter'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">feGaussianBlur</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'SourceGraphic'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stdDeviation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'2'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">g</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'url(#my-filter)'</span></span></span><span class="hljs-tag">&gt;</span></span> {{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">g</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O resultado √© uma visualiza√ß√£o borrada e "censurada" da nossa imagem, que ocupa quase 10 vezes menos espa√ßo (sem compress√£o), vetor e se estende a qualquer tamanho de tela.  Da mesma forma, voc√™ pode desfocar o restante de nossos mosaicos. </p><br><blockquote>  Ao aplicar esse filtro a um mosaico regular de ret√¢ngulos, o "efeito jipe" pode resultar; portanto, se voc√™ usar algo assim na produ√ß√£o, especialmente em fotos de tamanho grande, pode ser mais bonito aplicar o desfoque n√£o a ele, mas √† divis√£o de Voronoi. </blockquote><br><h2 id="vmesto-zaklyucheniya">  Em vez de uma conclus√£o </h2><br><p>  Neste artigo, vimos como voc√™ pode gerar todos os tipos de imagens stub SVG no Node.js e garantimos que essa n√£o seja uma tarefa t√£o dif√≠cil se voc√™ n√£o escrever tudo manualmente e, se poss√≠vel, montar m√≥dulos prontos.  Fontes completas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√£o dispon√≠veis no github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431232/">https://habr.com/ru/post/pt431232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431220/index.html">O olhar de um bi√≥logo sobre as ra√≠zes do nosso envelhecimento</a></li>
<li><a href="../pt431222/index.html">Arquivamento de sites</a></li>
<li><a href="../pt431226/index.html">O jogo Snake para FPGA Cyclone IV (com joystick VGA e SPI)</a></li>
<li><a href="../pt431228/index.html">Obst√°culo para luz: cristais l√≠quidos ajudam</a></li>
<li><a href="../pt431230/index.html">Armazenamento para infraestrutura HPC, ou como coletamos 65 PB de armazenamento no RIKEN Japan Research Center</a></li>
<li><a href="../pt431234/index.html">11 de dezembro de Moscou - Alfa JS MeetUp</a></li>
<li><a href="../pt431236/index.html">Como escrever no Objective-C em 2018. Parte 1</a></li>
<li><a href="../pt431238/index.html">O resumo de eventos para profissionais de RH na √°rea de TI em dezembro de 2018</a></li>
<li><a href="../pt431242/index.html">TLS e certificados da Web</a></li>
<li><a href="../pt431244/index.html">"Dois n√£o filtrados" ou uma maneira f√°cil de fotografar uma perna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>