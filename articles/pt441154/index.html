<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèæ üë§ üë™ Onze p√©rolas ocultas de Java 11 ‚è∫Ô∏è üöø üïµüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Java 11 n√£o apresentou nenhum recurso inovador, mas cont√©m v√°rias gemas das quais voc√™ talvez ainda n√£o tenha ouvido falar. J√° olhou o mais recente ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Onze p√©rolas ocultas de Java 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441154/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Java 11</a> n√£o apresentou nenhum recurso inovador, mas cont√©m v√°rias gemas das quais voc√™ talvez ainda n√£o tenha ouvido falar.  J√° olhou o mais recente em <code>String</code> , <code>Optional</code> , <code>Collection</code> e outros cavalos de trabalho?  Caso contr√°rio, voc√™ chegou ao endere√ßo: hoje veremos 11 j√≥ias escondidas do Java 11! </p><a name="habracut"></a><br><h3 id="vyvod-tipov-dlya-lyambda-parametrov">  Infer√™ncia de tipo para par√¢metros lambda </h3><br><p>  Ao escrever uma express√£o lambda, voc√™ pode escolher entre especificar tipos explicitamente e ignor√°-los: </p><br><pre> <code class="java hljs">Function&lt;String, String&gt; append = string -&gt; string + <span class="hljs-string"><span class="hljs-string">" "</span></span>; Function&lt;String, String&gt; append = (String s) -&gt; s + <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Java 10 apresentou</a> <code>var</code> , mas n√£o p√¥de ser usado em lambdas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Java 10 Function&lt;String, String&gt; append = (var string) -&gt; string + " ";</span></span></code> </pre> <br><p>  No Java 11 j√° √© poss√≠vel.  Mas porque?  N√£o parece que <code>var</code> deu mais do que apenas um passe de tipo.  Embora este seja o caso, o uso de <code>var</code> tem duas vantagens menores: </p><br><ul><li>  torna o uso de <code>var</code> mais universal, removendo a exce√ß√£o √† regra </li><li>  permite adicionar anota√ß√µes ao tipo de par√¢metro sem recorrer ao uso de seu nome completo </li></ul><br><p>  Aqui est√° um exemplo do segundo caso: </p><br><pre> <code class="java hljs">List&lt;EnterpriseGradeType&lt;With, Generics&gt;&gt; types = <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>; types .stream() <span class="hljs-comment"><span class="hljs-comment">// ,     @Nonnull   .filter(type -&gt; check(type)) //  Java 10    ~&gt;  .filter((@Nonnull EnterpriseGradeType&lt;With, Generics&gt; type) -&gt; check(type)) //  Java 11    ~&gt;   .filter((@Nonnull var type) -&gt; check(type))</span></span></code> </pre> <br><p>  Embora a mistura de tipos derivados, expl√≠citos e impl√≠citos em express√µes lambda da forma <code>(var type, String option, index) -&gt; ...</code> possa ser implementada, mas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na estrutura do JEP-323</a> ) este trabalho n√£o foi realizado.  Portanto, √© necess√°rio escolher uma das tr√™s abordagens e aderir a ela para todos os par√¢metros da express√£o lambda.  A necessidade de especificar <code>var</code> para todos os par√¢metros para adicionar anota√ß√£o para um deles pode ser um pouco irritante, mas geralmente suport√°vel. </p><br><h3 id="potokovaya-obrabotka-strok-s-stringlines">  Processamento de fluxo de strings com <code>'String::lines'</code> </h3><br><p>  Tem uma sequ√™ncia de v√°rias linhas?  Deseja fazer algo com cada linha?  Ent√£o <code>String::lines</code> √© a escolha certa: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiline = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n\r\n"</span></span>; multiline .lines() <span class="hljs-comment"><span class="hljs-comment">//Stream&lt;String&gt; .map(line -&gt; "// " + line) .forEach(System.out::println); // : //  //  //  // </span></span></code> </pre> <br><p>  Observe que a linha original usa os delimitadores <code>\r\n</code> Windows e, embora eu esteja no Linux, <code>lines()</code> ainda a quebrou.  Isso se deve ao fato de que, apesar do sistema operacional atual, esse m√©todo interpreta <code>\r</code> , <code>\n</code> e <code>\r\n</code> como quebras de linha - mesmo se elas estiverem misturadas na mesma linha. </p><br><p>  Um fluxo de linhas nunca cont√©m os pr√≥prios separadores de linhas.  As linhas podem estar vazias ( <code>"\n\n \n\n"</code> , que cont√©m 5 linhas), mas a √∫ltima linha da linha original ser√° ignorada se estiver vazia ( <code>"\n\n"</code> ; 2 linhas).  <em>(Observa√ß√£o pelo tradutor: √© conveniente que eles tenham <code>line</code> , mas que tenham <code>string</code> , e n√≥s temos as duas.)</em> </p><br><p>  Diferente da <code>split("\R")</code> , as <code>lines()</code> pregui√ßosas e, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cito</a> , "fornecem melhor desempenho [...] procurando mais rapidamente novas quebras de linha".  (Se algu√©m desejar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registrar uma</a> refer√™ncia no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JMH</a> para verifica√ß√£o, informe-me).  Tamb√©m reflete melhor o algoritmo de processamento e usa uma estrutura de dados mais conveniente (fluxo em vez de matriz). </p><br><h3 id="udalenie-probelnyh-simvolov-s-stringstrip-i-tp">  Removendo o espa√ßo em branco com <code>'String::strip'</code> etc. </h3><br><p>  Inicialmente, <code>String</code> tinha um m√©todo de remo√ß√£o para remover espa√ßos em branco, que era considerado tudo com c√≥digos at√© <code>U+0020</code> .  Sim, <code>BACKSPACE</code> ( <code>U+0008)</code> √© um espa√ßo em branco como <code>BELL</code> ( <code>U+0007</code> ), mas o <code>LINE SEPARATOR</code> ( <code>U+2028</code> ) n√£o √© mais considerado como tal. </p><br><p>  O Java 11 introduziu o m√©todo <code>strip</code> , cuja abordagem tem mais nuances.  Ele usa o <code>Character::isWhitespace</code> do Java 5 para determinar o que exatamente precisa ser removido.  A partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sua documenta√ß√£o</a> , √© claro que isso: </p><br><ul><li>  <code>SPACE SEPARATOR</code> , <code>SPACE SEPARATOR</code> <code>LINE SEPARATOR</code> , <code>LINE SEPARATOR</code> <code>PARAGRAPH SEPARATOR</code> , mas n√£o um espa√ßo inextric√°vel </li><li>  <code>HORIZONTAL TABULATION</code> ( <code>U+0009</code> ), <code>LINE FEED</code> ( <code>U+000A</code> ), <code>VERTICAL TABULATION</code> ( <code>U+000B</code> ), <code>FORM FEED</code> ( <code>U+000C</code> ), <code>CARRIAGE RETURN</code> ( <code>U+000D</code> ) </li><li>  <code>FILE SEPARATOR</code> ( <code>U+001C</code> ), <code>GROUP SEPARATOR</code> ( <code>U+001D</code> ), <code>RECORD SEPARATOR</code> ( <code>U+001E</code> ), <code>UNIT SEPARATOR</code> ( <code>U+001F</code> ) </li></ul><br><p>  Com a mesma l√≥gica, existem mais dois m√©todos de limpeza, <code>stripLeading</code> e <code>stripTailing</code> , que fazem exatamente o que √© esperado deles. </p><br><p>  E, finalmente, se voc√™ s√≥ precisa descobrir se a linha fica vazia depois de remover o espa√ßo em branco, n√£o h√° realmente necessidade de exclu√≠-la - basta usar <code>isBlank</code> : </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span>.isBlank(); <span class="hljs-comment"><span class="hljs-comment">//  ~&gt; true " ".isBlank(); //   ~&gt; false</span></span></code> </pre> <br><h3 id="povtorenie-strok-s-stringrepeat">  Repetindo strings com <code>'String::repeat'</code> </h3><br><p>  Capte a ideia: </p><br><h6 id="shag-1-pristalno-sledim-za-razvitiem-jdk">  Etapa 1: Vigiando o JDK </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/874/8df/a06/8748dfa06086f57aae4b16686d9c6c04.png" alt="Mantendo um olhar atento sobre o desenvolvimento do JDK"></p><br><h6 id="shag-2-razyskivaem-na-stackoverflow-svyazannye-voprosy">  Etapa 2: Localizando perguntas relacionadas ao StackOverflow </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df2/3f8/7ae/df23f87ae8d723f53beb5617017de913.png" alt="Procurando perguntas relacionadas no Stackoverflow"></p><br><h6 id="shag-3-priletaem-s-novym-otvetom-osnovannym-na-buduschih-izmeneniyah">  Etapa 3: chegando com uma nova resposta com base em altera√ß√µes futuras </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b68/556/748/b685567487db2b1ea3cab180b8f39089.png" alt="Entre com uma nova resposta com base nas pr√≥ximas altera√ß√µes"></p><br><h6 id="shag-4-">  Etapa 4: ???? </h6><br><h6 id="shag-4-profit">  Etapa 4: Lucro </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/695/015/36969501570588225baae6cd5dd3edb1.gif" alt="¬Ø \ _ („ÉÑ) _ / ¬Ø"></p><br><p>  Como voc√™ pode imaginar, <code>String</code> possui um novo m√©todo <code>repeat(int)</code> .  Funciona exatamente de acordo com as expectativas e h√° pouco a discutir. </p><br><h3 id="sozdanie-putey-s-pathof">  Criando caminhos com <code>'Path::of'</code> </h3><br><p>  Eu realmente gosto da API do <code>Path</code> , mas a convers√£o de caminhos entre diferentes modos de exibi√ß√£o (como <code>Path</code> , <code>File</code> , <code>URL</code> , <code>URI</code> e <code>String</code> ) ainda √© irritante.  Este ponto se tornou menos confuso no Java 11, copiando dois m√©todos <code>Paths::get</code> para <code>Path::of</code> methods: </p><br><pre> <code class="java hljs">Path tmp = Path.of(<span class="hljs-string"><span class="hljs-string">"/home/nipa"</span></span>, <span class="hljs-string"><span class="hljs-string">"tmp"</span></span>); Path codefx = Path.of(URI.create(<span class="hljs-string"><span class="hljs-string">"http://codefx.org"</span></span>));</code> </pre> <br><p>  Eles podem ser considerados can√¥nicos, pois os dois m√©todos antigos <code>Paths::get</code> usam novas op√ß√µes. </p><br><h3 id="chtenie-i-zapis-faylov-s-filesreadstring-i-fileswritestring">  Lendo e gravando arquivos com <code>'Files::readString'</code> e <code>'Files::writeString'</code> </h3><br><p>  Se eu precisar ler de um arquivo grande, normalmente uso o <code>Files::lines</code> para obter um fluxo lento de suas linhas.  Da mesma forma, para registrar uma grande quantidade de dados que n√£o podem ser armazenados inteiramente na mem√≥ria, eu uso o <code>Files::write</code> passando-os como <code>Iterable&lt;String&gt;</code> . </p><br><p>  Mas e o caso simples quando quero processar o conte√∫do de um arquivo como uma √∫nica linha?  Isso n√£o √© muito conveniente, pois o <code>Files::readAllBytes</code> e as variantes apropriadas do <code>Files::write</code> operam em matrizes de bytes. </p><br><p>  E, em seguida, o Java 11 aparece, adicionando <code>readString</code> e <code>writeString</code> aos <code>Files</code> : </p><br><pre> <code class="java hljs">String haiku = Files.readString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku.txt"</span></span>)); String modified = modify(haiku); Files.writeString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku-mod.txt"</span></span>), modified);</code> </pre> <br><p>  Claro e f√°cil de usar.  Se necess√°rio, voc√™ pode passar o conjunto de <code>readString</code> para <code>readString</code> e, em <code>writeString</code> tamb√©m uma matriz <code>OpenOptions</code> . </p><br><h3 id="pustoe-io-s-readernullreader-i-tp">  E / S vazia com <code>'Reader::nullReader'</code> , etc. </h3><br><p>  Precisa de um <code>OutputStream</code> que n√£o <code>OutputStream</code> lugar algum?  Ou um <code>InputStream</code> vazio?  E o <code>Reader</code> e o <code>Writer</code> que n√£o fazem nada?  O Java 11 tem tudo: </p><br><pre> <code class="java hljs">InputStream input = InputStream.nullInputStream(); OutputStream output = OutputStream.nullOutputStream(); Reader reader = Reader.nullReader(); Writer writer = Writer.nullWriter();</code> </pre> <br><p>  <em>(Nota do tradutor: no <code>commons-io</code> do Apache, essas classes existem desde 2014).</em> </p><br><p>  No entanto, estou surpreso - √© <code>null</code> realmente o melhor prefixo?  N√£o gosto de como √© usado para significar "aus√™ncia intencional" ... Talvez seja melhor usar <code>noOp</code> ?  <em>(Nota do tradutor: provavelmente esse prefixo foi escolhido devido ao uso comum de <code>/dev/null</code> .)</em> </p><br><h3 id="-----s-collectiontoarray">  <code>{ } ~&gt; [ ]</code> com <code>'Collection::toArray'</code> </h3><br><p>  Como voc√™ converte cole√ß√µes em matrizes? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Java 11 List&lt;String&gt; list = /*...*/; Object[] objects = list.toArray(); String[] strings_0 = list.toArray(new String[0]); String[] strings_size = list.toArray(new String[list.size()]);</span></span></code> </pre> <br><p>  A primeira op√ß√£o, <code>objects</code> , perde todas as informa√ß√µes sobre os tipos e, portanto, est√° em andamento.  E o resto?  Ambos s√£o volumosos, mas o primeiro √© mais curto.  O √∫ltimo cria uma matriz do tamanho necess√°rio, para que pare√ßa mais produtivo (ou seja, "parece mais produtivo", veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">credibilidade</a> ).  Mas √© realmente mais produtivo?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√£o, pelo contr√°rio, √© mais lento</a> (no momento). </p><br><p>  Mas por que eu deveria me importar com isso?  N√£o existe uma maneira melhor de fazer isso?  No Java 11, existem: </p><br><pre> <code class="java hljs">String[] strings_fun = list.toArray(String[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br><p>  Uma nova variante de <code>Collection::toArray</code> , que aceita <code>IntFunction&lt;T[]&gt;</code> , ou seja,  uma fun√ß√£o que recebe o tamanho da matriz e retorna uma matriz do tamanho necess√°rio.  Ele pode ser expresso brevemente como uma refer√™ncia a um construtor do formato <code>T[]::new</code> (para um <code>T</code> bem conhecido). </p><br><p>  Fato interessante: a implementa√ß√£o padr√£o da <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code> sempre passa <code>0</code> para o gerador de array.  Inicialmente, decidi que essa solu√ß√£o era baseada no melhor desempenho para matrizes de comprimento zero, mas agora acho que o motivo pode ser que, para algumas cole√ß√µes, calcular o tamanho possa ser uma opera√ß√£o muito cara e voc√™ n√£o deva usar essa abordagem na implementa√ß√£o padr√£o da <code>Collection</code> .  No entanto, implementa√ß√µes de cole√ß√µes espec√≠ficas, como <code>ArrayList</code> , podem alterar essa abordagem, mas n√£o s√£o alteradas no Java 11.  N√£o vale a pena, eu acho. </p><br><h3 id="proverka-otsutstviya-s-optionalisempty">  Verifica√ß√£o de aus√™ncia com <code>'Optional::isEmpty'</code> </h3><br><p>  Com o uso abundante do <code>Optional</code> , especialmente em grandes projetos, onde voc√™ frequentemente encontra uma abordagem n√£o <code>Optional</code> , √© necess√°rio verificar se ele tem um valor.  Existe um m√©todo <code>Optional::isPresent</code> para isso.  Mas com a mesma frequ√™ncia, voc√™ precisa saber o oposto - esse <code>Optional</code> vazio.  N√£o tem problema, basta usar <code>!opt.isPresent()</code> , certo? </p><br><p>  Obviamente, √© poss√≠vel assim, mas quase sempre √© mais f√°cil entender a l√≥gica <code>if</code> sua condi√ß√£o n√£o for invertida.  E, √†s vezes, o <code>Optional</code> aparece no final de uma longa cadeia de chamadas e, se voc√™ precisar checar por nada, ent√£o precisa apostar <code>!</code>  no come√ßo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isPresent(); }</code> </pre> <br><p>  Nesse caso, pule <code>!</code>  muito facil  A partir do Java 11, h√° uma op√ß√£o melhor: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isEmpty(); }</code> </pre> <br><h3 id="invertirovanie-predikatov-s-predicatenot">  Invertendo predicados com <code>'Predicate::not'</code> </h3><br><p>  Falando em inverter ... A interface do <code>Predicate</code> possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> <code>negate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inst√¢ncia</a> <code>negate</code> : retorna um novo predicado que executa a mesma verifica√ß√£o, mas inverte o resultado.  Infelizmente, eu raramente consigo us√°-lo ... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Stream .of("a", "b", "", "c") // ,  ~&gt;        .filter(s -&gt; !s.isBlank()) //          ~&gt;  .filter((String::isBlank).negate()) // ,  ~&gt;       .filter(((Predicate&lt;String&gt;) String::isBlank).negate()) .forEach(System.out::println);</span></span></code> </pre> <br><p>  O problema √© que raramente tenho acesso √† inst√¢ncia do <code>Predicate</code> .  Mais frequentemente, quero obter essa inst√¢ncia por meio de um link para um m√©todo (e invert√™-lo), mas, para que isso funcione, o compilador deve saber o que levar a refer√™ncia ao m√©todo - sem ele, ele n√£o pode fazer nada.  E √© exatamente isso que acontece se voc√™ usar a constru√ß√£o <code>(String::isBlank).negate()</code> : o compilador n√£o sabe mais o que <code>String::isBlank</code> deve estar nisso e desiste.  Uma casta especificada corretamente corrige isso, mas a que custo? </p><br><p>  Embora exista uma solu√ß√£o simples.  N√£o use o <code>negate</code> inst√¢ncia <code>negate</code> , mas use o novo m√©todo est√°tico <code>Predicate.not(Predicate&lt;T&gt;)</code> do Java 11: </p><br><pre> <code class="java hljs">Stream .of(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   `java.util.function.Predicate.not` .filter(not(String::isBlank)) .forEach(System.out::println);</span></span></code> </pre> <br><p>  J√° est√° melhor! </p><br><h3 id="regulyarnye-vyrazheniya-kak-predikat-s-patternasmatchpredicate">  Express√µes regulares como um predicado com <code>'Pattern::asMatchPredicate'</code> </h3><br><p>  Existe uma express√£o regular?  Precisa filtrar dados nele?  Que tal isso: </p><br><pre> <code class="java hljs">Pattern nonWordCharacter = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\W"</span></span>); Stream .of(<span class="hljs-string"><span class="hljs-string">"Metallica"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mot√∂rhead"</span></span>) .filter(nonWordCharacter.asPredicate()) .forEach(System.out::println);</code> </pre> <br><p>  Fiquei muito feliz em encontrar esse m√©todo!  Vale a pena acrescentar que este √© um m√©todo do Java 8. Opa, eu perdi ent√£o.  O Java 11 adicionou outro m√©todo semelhante: <code>Pattern::asMatchPredicate</code> .  Qual a diferen√ßa? </p><br><ul><li>  <code>asPredicate</code> verifica se a sequ√™ncia <strong>ou parte da sequ√™ncia</strong> corresponde ao padr√£o (funciona como <code>s -&gt; this.matcher(s).find()</code> ) </li><li>  <code>asMatchPredicate</code> verifica se a <strong>sequ√™ncia inteira</strong> corresponde ao padr√£o (funciona como <code>s -&gt; this.matcher(s).matches()</code> ) </li></ul><br><p>  Por exemplo, temos uma express√£o regular que verifica os n√∫meros de telefone, mas n√£o cont√©m <code>^</code> e <code>$</code> para rastrear o in√≠cio e o fim de uma linha.  Em seguida, o c√≥digo a seguir n√£o funcionar√° conforme o esperado: </p><br><pre> <code class="java hljs">prospectivePhoneNumbers .stream() .filter(phoneNumberPatter.asPredicate()) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::robocall);</code> </pre> <br><p>  Voc√™ percebeu um erro?  Uma linha como <code>" -152 ? +1-202-456-1414"</code> ser√° filtrada porque cont√©m um n√∫mero de telefone v√°lido.  Por outro lado, <code>Pattern::asMatchPredicate</code> n√£o permitir√° isso, porque a cadeia <strong>inteira</strong> n√£o corresponder√° <strong>mais</strong> ao padr√£o. </p><br><h3 id="samoproverka">  Auto-teste </h3><br><p>  Aqui est√° uma vis√£o geral de todas as onze p√©rolas - voc√™ ainda se lembra do que cada m√©todo faz?  Nesse caso, voc√™ passou no teste. </p><br><ul><li>  em <code>String</code> : <br><ul><li> <code>Stream&lt;String&gt; lines()</code> </li> <li> <code>String strip()</code> </li> <li> <code>String stripLeading()</code> </li> <li> <code>String stripTrailing()</code> </li> <li> <code>boolean isBlank()</code> </li> <li> <code>String repeat(int)</code> </li> </ul></li><li>  no <code>Path</code> : <br><ul><li> <code>static Path of(String, String...)</code> </li> <li> <code>static Path of(URI)</code> </li> </ul></li><li>  em <code>Files</code> : <br><ul><li> <code>String readString(Path) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, OpenOption...) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, Charset, OpenOption...) throws IOException</code> </li> </ul></li><li>  em <code>InputStream</code> : <code>static InputStream nullInputStream()</code> </li><li>  em <code>OutputStream</code> : <code>OutputStream</code> <code>static OutputStream nullOutputStream()</code> </li><li>  no <code>Reader</code> : <code>Reader</code> <code>static Reader nullReader()</code> </li><li>  no <code>Writer</code> : <code>static Writer nullWriter()</code> </li><li>  na <code>Collection</code> : <code>T[] toArray(IntFunction&lt;T[]&gt;)</code> </li><li>  em <code>Optional</code> : <code>boolean isEmpty()</code> </li><li>  no <code>Predicate</code> : <code>Predicate</code> <code>static Predicate&lt;T&gt; not(Predicate&lt;T&gt;)</code> </li><li>  em <code>Pattern</code> : <code>Predicate&lt;String&gt; asMatchPredicate()</code> </li></ul><br><p>  Divirta-se com o Java 11! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441154/">https://habr.com/ru/post/pt441154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441142/index.html">12 pontos de crescimento de convers√µes ou conte√∫do que realmente vende</a></li>
<li><a href="../pt441146/index.html">Redes sem fio industriais: qual escolher?</a></li>
<li><a href="../pt441148/index.html">Como lidar com os erros corretamente: o sil√™ncio nem sempre √© bom</a></li>
<li><a href="../pt441150/index.html">Primeira introdu√ß√£o ao protocolo HTTP, escrevendo o servidor Java Web mais simples</a></li>
<li><a href="../pt441152/index.html">Como minimizar erros ao integrar com servi√ßos externos: a experi√™ncia de um corretor online</a></li>
<li><a href="../pt441158/index.html">Como a √©tica se tornou a quest√£o mais cara do Vale do Sil√≠cio e a filosofia se tornou sua solu√ß√£o mais pr√°tica</a></li>
<li><a href="../pt441160/index.html">Como aprender a determinar quando dizer n√£o</a></li>
<li><a href="../pt441166/index.html">Obtemos a senha mestra do gerenciador de senhas bloqueadas 1Password 4</a></li>
<li><a href="../pt441168/index.html">DataChannels QUIC: Primeiros Passos</a></li>
<li><a href="../pt441172/index.html">Como o mercado de impress√£o 3D cresceu em 2018 e o que isso significa para os neg√≥cios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>