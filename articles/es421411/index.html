<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐺 🌘 📮 Introducción a los módulos Go 💃🏼 🤶🏾 🍩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El próximo lanzamiento de la versión 1.11 del lenguaje de programación Go traerá soporte experimental para módulos , un nuevo sistema de administració...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducción a los módulos Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  El próximo lanzamiento de la versión 1.11 del lenguaje de programación Go traerá soporte experimental para <em>módulos</em> , un nuevo sistema de administración de dependencias para Go.  (traducción de la nota: la <a href="">liberación tuvo lugar</a> ) </p><br><p>  Recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya escribí una pequeña publicación sobre esto</a> .  Desde entonces, algo ha cambiado ligeramente y nos hemos acercado al lanzamiento, por lo que me parece que ha llegado el momento de un nuevo artículo, agreguemos más práctica. </p><br><p>  Entonces, esto es lo que haremos: crear un nuevo paquete y luego hacer algunos lanzamientos para ver cómo funciona. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Creación del módulo </h2><br><p> Primero, crea nuestro paquete.  Llamémoslo testmod.  Detalle importante: <strong>el directorio del paquete debe colocarse <em>fuera de</em> su <code>$GOPATH</code> , porque, dentro de él, el soporte del módulo está deshabilitado de forma predeterminada</strong> .  Los módulos Go son el primer paso hacia un abandono completo de <code>$GOPATH</code> en el futuro. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Nuestro paquete es bastante simple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  El paquete está listo, pero aún no es un <em>módulo</em> .  Vamos a arreglarlo </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  Tenemos un nuevo archivo llamado <code>go.mod</code> en el directorio del paquete con los siguientes contenidos: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Un poco, pero eso es lo que convierte nuestro paquete en un <em>módulo</em> . </p><br><p>  Ahora podemos insertar este código en el repositorio: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p>  Hasta ahora, cualquier persona que quiera usar nuestro paquete aplicaría <code>go get</code> : </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  Y este comando traería el último código de la rama <code>master</code> .  Esta opción aún funciona, pero sería mejor si ya no lo hacemos, porque ahora "hay una mejor manera".  Tomar código directamente de la rama <code>master</code> es, de hecho, peligroso, ya que nunca sabemos con certeza si los autores del paquete no hicieron cambios que "rompan" nuestro código.  Para resolver este problema, se inventaron los módulos Go. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  Una pequeña digresión sobre los módulos de versiones </h2><br><p>  Los módulos Go están versionados, además hay cierta especificidad de las versiones individuales.  Tendrá que familiarizarse con los conceptos que subyacen a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las versiones semánticas</a> . </p><br><p>  Además, Go usa etiquetas de repositorio cuando busca versiones, y algunas versiones difieren del resto: por ejemplo, las versiones 2 y más deben tener una ruta de importación diferente que para las versiones 0 y 1 (llegaremos a esto). </p><br><p>  Por defecto, Go descarga la última <em>versión, que tiene una etiqueta</em> disponible en el repositorio. <br>  Esta es una característica importante, ya que se puede usar cuando se trabaja con la rama <code>master</code> . </p><br><p>  Para nosotros ahora es importante que al crear el lanzamiento de nuestro paquete, necesitemos poner una etiqueta con la versión en el repositorio. </p><br><p>  Hagámoslo </p><br><h2 id="delaem-svoy-pervyy-reliz">  Haciendo tu primer lanzamiento </h2><br><p>  Nuestro paquete está listo y podemos "extenderlo" a todo el mundo.  Hacemos esto usando etiquetas versionadas.  Deje que el número de versión sea 1.0.0: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p>  Estos comandos crean una etiqueta en mi repositorio de Github que marca la confirmación actual como versión 1.0.0. </p><br><p>  Go no insiste en esto, pero es una buena idea crear una nueva rama adicional ("v1") a la que podamos enviar parches. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p>  Ahora podemos trabajar en la rama <code>master</code> sin preocuparnos de que podamos romper nuestra versión. </p><br><h2 id="ispolzovanie-nashego-modulya">  Usando nuestro módulo </h2><br><p>  Usemos el módulo creado.  Escribiremos un programa simple que importe nuestro nuevo paquete: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Hasta ahora, ejecutaría <code>go get github.com/robteix/testmod</code> para descargar el paquete, pero con los módulos se vuelve más interesante.  Primero, necesitamos habilitar el soporte de módulos en nuestro nuevo programa. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  Como probablemente esperaba, según lo que leyó anteriormente, apareció un nuevo archivo <code>go.mod</code> en el directorio con el nombre del módulo dentro: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  La situación se vuelve aún más interesante cuando intentamos armar nuestro programa: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Como puede ver, el comando <code>go</code> encontró y descargó automáticamente el paquete importado por nuestro programa. <br>  Si revisamos nuestro archivo <code>go.mod</code> , veremos que algo ha cambiado: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Y tenemos otro nuevo archivo llamado <code>go.sum</code> , que contiene los hash de los paquetes para verificar la versión y los archivos correctos. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Hacer una versión de lanzamiento de corrección de errores </h2><br><p>  Ahora, supongamos que encontramos un problema en nuestro paquete: ¡no hay puntuación en el saludo! <br>  Algunas personas se pondrán furiosas porque nuestro saludo amistoso ya no es tan amistoso. <br>  Arreglemos esto y publiquemos una nueva versión: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  Hicimos este cambio directamente en la rama <code>v1</code> , porque no tiene nada que ver con lo que haremos a continuación en la rama <code>v2</code> , pero en la vida real, tal vez debería hacer estos cambios en <code>master</code> y luego transferirlos a <code>v1</code> .  En cualquier caso, la solución debe estar en la rama <code>v1</code> y debemos marcar esto como una nueva versión. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Actualización de módulos </h2><br><p>  Por defecto, Go no actualiza los módulos sin demanda.  "Y eso es bueno", ya que a todos nos gustaría la previsibilidad en nuestras compilaciones.  Si los módulos Go se actualizan automáticamente cada vez que se lanza una nueva versión, volveríamos a la "edad oscura anterior a Go1.11".  Pero no, debemos <em>decirle a</em> Go que actualice los módulos por nosotros. </p><br><p>  Y lo haremos con la ayuda de nuestro viejo amigo: <code>go get</code> : </p><br><ul><li><p>  ejecute <code>go get -u</code> para usar la última versión <em>menor o parche</em> (es decir, el comando se actualizará de 1.0.0 a, por ejemplo, 1.0.1 o 1.1.0, si dicha versión está disponible) </p><br></li><li><p>  ejecute <code>go get -u=patch</code> para usar la última versión del parche (es decir, el paquete se actualizará a 1.0.1, pero <em>no</em> a 1.1.0) </p><br></li><li><p>  ejecute <code>go get package@version</code> para actualizar a una versión específica (por ejemplo, <code>github.com/robteix/testmod@v1.0.1</code> ) </p><br></li></ul><br><p>  No hay forma en esta lista de actualizar a la última versión <em>principal</em> .  Hay una buena razón para esto, como veremos pronto. </p><br><p>  Como nuestro programa usó la versión 1.0.0 de nuestro paquete y acabamos de crear la versión 1.0.1, <em>cualquiera</em> de los siguientes comandos nos actualizará a 1.0.1: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p>  Después de comenzar (digamos <code>go get -u</code> ), nuestro <code>go.mod</code> ha cambiado: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Versión mayor </h2><br><p>  Según la especificación de las versiones semánticas, la versión principal <em>difiere</em> de la versión secundaria.  Las versiones principales pueden romper la compatibilidad con versiones anteriores.  Desde el punto de vista de los módulos Go, la versión principal es un <em>paquete</em> completamente <em>diferente</em> . </p><br><p>  Puede sonar salvaje al principio, pero tiene sentido: dos versiones de la biblioteca que son incompatibles entre sí son dos bibliotecas diferentes. </p><br><p>  Hagamos un cambio importante en nuestro paquete.  Supongamos que, con el tiempo, nos quedó claro que nuestra API es demasiado simple, demasiado limitada para los casos de nuestros usuarios, por lo que debemos cambiar la función <code>Hi()</code> para aceptar el idioma de bienvenida como parámetro: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¡Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Los programas existentes que usan nuestra API se interrumpirán porque a) no pasan el lenguaje como parámetro yb) no esperan un retorno de error.  Nuestra nueva API ya no es compatible con la versión 1.x, así que cumpla con la versión 2.0.0. </p><br><p>  Mencioné anteriormente que algunas versiones tienen características, y ahora este es el caso. <br>  <strong>La versión 2 <em>o posterior</em> debería cambiar la ruta de importación.</strong>  Ahora estas son bibliotecas diferentes. </p><br><p>  Haremos esto agregando una nueva <em>ruta versionada</em> al nombre de nuestro módulo. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Todo lo demás es igual: empujar, poner una etiqueta de que es v2.0.0 (y opcionalmente sod una rama v2) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Actualización de la versión principal </h2><br><p>  Aunque lanzamos una nueva versión incompatible de nuestra biblioteca, los programas existentes <em>no se rompieron</em> , porque continúan usando la versión 1.0.1. <br>  <code>go get -u</code> <em>no</em> descargará la versión 2.0.0. </p><br><p>  Pero en algún momento, yo, como usuario de la biblioteca, podría querer actualizar a la versión 2.0.0, porque, por ejemplo, soy uno de esos usuarios que necesitan soporte para varios idiomas. </p><br><p>  Para actualizar, necesito cambiar mi programa en consecuencia: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Ahora, cuando ejecuto <code>go build</code> , se "cierra" y descarga la versión 2.0.0 para mí.  Tenga en cuenta que aunque la ruta de importación ahora termina en "v2", Go todavía se refiere al módulo por su nombre real ("testmod"). </p><br><p>  Como dije, la versión principal es en todos los sentidos un paquete diferente.  Estos dos módulos Go no están conectados de ninguna manera.  Esto significa que podemos tener dos versiones incompatibles en un binario: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Y esto elimina el problema común con la gestión de dependencias cuando las dependencias dependen de diferentes versiones de la misma biblioteca. </p><br><h2 id="navodim-poryadok">  Ponemos las cosas en orden </h2><br><p>  Volvamos a la versión anterior, que usa solo testmod 2.0.0; si verificamos el contenido de <code>go.mod</code> , notaremos algo: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Por defecto, Go no elimina las dependencias de <code>go.mod</code> hasta que lo solicite.  Si tiene dependencias que ya no son necesarias y desea limpiarlas, puede usar el nuevo comando <code>tidy</code> : </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Ahora solo tenemos las dependencias que realmente usamos. </p><br><h2 id="vendoring">  Vending </h2><br><p>  Ir módulos por defecto ignora el <code>vendor/</code> directorio.  La idea es deshacerse gradualmente de la venta <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a></sup> .  Pero si aún queremos agregar las dependencias "separadas" a nuestro control de versiones, podemos hacer esto: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  El equipo creará el directorio <code>vendor/</code> en la raíz de nuestro proyecto, que contiene el código fuente de todas las dependencias. </p><br><p>  Sin embargo, <code>go build</code> por defecto aún ignora el contenido de este directorio.  Si desea recopilar dependencias del <code>vendor/</code> directorio, debe solicitarlo explícitamente. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p>  Supongo que muchos desarrolladores que quieran usar la venta automática ejecutarán <code>go build</code> <code>-mod vendor</code> , como de costumbre, en sus máquinas y usarán <code>-mod vendor</code> en su CI. </p><br><p>  Nuevamente, los módulos Go se están alejando de la idea de vender para usar proxies para módulos para aquellos que no desean depender directamente de los servicios de control de versiones ascendentes. </p><br><p>  Hay formas de garantizar que <code>go</code> red no esté disponible (por ejemplo, usando <code>GOPROXY=off</code> ), pero este es el tema del próximo artículo. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  El artículo puede parecer complicado para alguien, pero esto es porque traté de explicar mucho de una vez.  La realidad es que los módulos Go son generalmente simples hoy en día: nosotros, como de costumbre, importamos el paquete a nuestro código, y el equipo <code>go</code> hace el resto por nosotros.  Las dependencias se cargan automáticamente durante el ensamblaje. </p><br><p>  Los módulos también eliminan la necesidad de <code>$GOPATH</code> , que era un obstáculo para los nuevos desarrolladores de Go que tenían problemas para entender por qué deberían poner algo en un directorio específico. </p><br><p><del>  La venta (no oficial) ha quedado en desuso a favor del uso de un proxy. </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a></sup> <br>  Puedo hacer un artículo separado sobre proxies para los módulos Go. </p><br><p>  Notas: </p><br><p>  <sup>1</sup> Creo que esta es una expresión demasiado fuerte y algunos pueden tener la impresión de que se están eliminando las ventas en este momento.  Esto no es asi.  La venta sigue funcionando, aunque de forma ligeramente diferente que antes.  Aparentemente, existe el deseo de reemplazar la venta automática con algo mejor, por ejemplo, un proxy (no es un hecho).  Hasta ahora, esto es simplemente la búsqueda de una mejor solución.  Las ventas no desaparecerán hasta que se encuentre un buen reemplazo (si lo hay). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421411/">https://habr.com/ru/post/es421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421399/index.html">Análisis de puerta trasera de Turla Cybergroup Outlook</a></li>
<li><a href="../es421401/index.html">Anatomía de los sistemas de recomendación. Parte dos</a></li>
<li><a href="../es421403/index.html">Semana de la seguridad 32: drama de Fortnite-Android</a></li>
<li><a href="../es421407/index.html">Reunión técnica en San Petersburgo el 13 de septiembre: cómo hacer grandes cambios en el backend</a></li>
<li><a href="../es421409/index.html">Espiar cosas: guardar un secreto</a></li>
<li><a href="../es421413/index.html">Acceso adecuado a los métodos de interfaz predeterminados a través de la reflexión en Java 8, 9, 10</a></li>
<li><a href="../es421415/index.html">Magic Leap - basura triste</a></li>
<li><a href="../es421417/index.html">Cafetera para adictos al café, o cafetera móvil Wacaco</a></li>
<li><a href="../es421419/index.html">Oda al níquel "espumado", zafiros inexistentes y al viceministro soviético: icónico OTTO SX-P1 en Japón, Estados Unidos y la URSS</a></li>
<li><a href="../es421421/index.html">LAppS: Medio millón de mensajes de 1KB-WebSocket por segundo con TLS en una CPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>