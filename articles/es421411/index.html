<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Introducci贸n a los m贸dulos Go  ざ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El pr贸ximo lanzamiento de la versi贸n 1.11 del lenguaje de programaci贸n Go traer谩 soporte experimental para m贸dulos , un nuevo sistema de administraci贸...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci贸n a los m贸dulos Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421411/"><p>  El pr贸ximo lanzamiento de la versi贸n 1.11 del lenguaje de programaci贸n Go traer谩 soporte experimental para <em>m贸dulos</em> , un nuevo sistema de administraci贸n de dependencias para Go.  (traducci贸n de la nota: la <a href="">liberaci贸n tuvo lugar</a> ) </p><br><p>  Recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya escrib铆 una peque帽a publicaci贸n sobre esto</a> .  Desde entonces, algo ha cambiado ligeramente y nos hemos acercado al lanzamiento, por lo que me parece que ha llegado el momento de un nuevo art铆culo, agreguemos m谩s pr谩ctica. </p><br><p>  Entonces, esto es lo que haremos: crear un nuevo paquete y luego hacer algunos lanzamientos para ver c贸mo funciona. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Creaci贸n del m贸dulo </h2><br><p> Primero, crea nuestro paquete.  Llam茅moslo testmod.  Detalle importante: <strong>el directorio del paquete debe colocarse <em>fuera de</em> su <code>$GOPATH</code> , porque, dentro de 茅l, el soporte del m贸dulo est谩 deshabilitado de forma predeterminada</strong> .  Los m贸dulos Go son el primer paso hacia un abandono completo de <code>$GOPATH</code> en el futuro. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Nuestro paquete es bastante simple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  El paquete est谩 listo, pero a煤n no es un <em>m贸dulo</em> .  Vamos a arreglarlo </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  Tenemos un nuevo archivo llamado <code>go.mod</code> en el directorio del paquete con los siguientes contenidos: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Un poco, pero eso es lo que convierte nuestro paquete en un <em>m贸dulo</em> . </p><br><p>  Ahora podemos insertar este c贸digo en el repositorio: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git init <span class="hljs-variable"><span class="hljs-variable">$</span></span> git add * <span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-am</span></span> <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin master</code> </pre> <br><p>  Hasta ahora, cualquier persona que quiera usar nuestro paquete aplicar铆a <code>go get</code> : </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  Y este comando traer铆a el 煤ltimo c贸digo de la rama <code>master</code> .  Esta opci贸n a煤n funciona, pero ser铆a mejor si ya no lo hacemos, porque ahora "hay una mejor manera".  Tomar c贸digo directamente de la rama <code>master</code> es, de hecho, peligroso, ya que nunca sabemos con certeza si los autores del paquete no hicieron cambios que "rompan" nuestro c贸digo.  Para resolver este problema, se inventaron los m贸dulos Go. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  Una peque帽a digresi贸n sobre los m贸dulos de versiones </h2><br><p>  Los m贸dulos Go est谩n versionados, adem谩s hay cierta especificidad de las versiones individuales.  Tendr谩 que familiarizarse con los conceptos que subyacen a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las versiones sem谩nticas</a> . </p><br><p>  Adem谩s, Go usa etiquetas de repositorio cuando busca versiones, y algunas versiones difieren del resto: por ejemplo, las versiones 2 y m谩s deben tener una ruta de importaci贸n diferente que para las versiones 0 y 1 (llegaremos a esto). </p><br><p>  Por defecto, Go descarga la 煤ltima <em>versi贸n, que tiene una etiqueta</em> disponible en el repositorio. <br>  Esta es una caracter铆stica importante, ya que se puede usar cuando se trabaja con la rama <code>master</code> . </p><br><p>  Para nosotros ahora es importante que al crear el lanzamiento de nuestro paquete, necesitemos poner una etiqueta con la versi贸n en el repositorio. </p><br><p>  Hag谩moslo </p><br><h2 id="delaem-svoy-pervyy-reliz">  Haciendo tu primer lanzamiento </h2><br><p>  Nuestro paquete est谩 listo y podemos "extenderlo" a todo el mundo.  Hacemos esto usando etiquetas versionadas.  Deje que el n煤mero de versi贸n sea 1.0.0: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span></code> </pre> <br><p>  Estos comandos crean una etiqueta en mi repositorio de Github que marca la confirmaci贸n actual como versi贸n 1.0.0. </p><br><p>  Go no insiste en esto, pero es una buena idea crear una nueva rama adicional ("v1") a la que podamos enviar parches. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git checkout <span class="hljs-literal"><span class="hljs-literal">-b</span></span> v1 <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push <span class="hljs-literal"><span class="hljs-literal">-u</span></span> origin v1</code> </pre> <br><p>  Ahora podemos trabajar en la rama <code>master</code> sin preocuparnos de que podamos romper nuestra versi贸n. </p><br><h2 id="ispolzovanie-nashego-modulya">  Usando nuestro m贸dulo </h2><br><p>  Usemos el m贸dulo creado.  Escribiremos un programa simple que importe nuestro nuevo paquete: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Hasta ahora, ejecutar铆a <code>go get github.com/robteix/testmod</code> para descargar el paquete, pero con los m贸dulos se vuelve m谩s interesante.  Primero, necesitamos habilitar el soporte de m贸dulos en nuestro nuevo programa. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  Como probablemente esperaba, seg煤n lo que ley贸 anteriormente, apareci贸 un nuevo archivo <code>go.mod</code> en el directorio con el nombre del m贸dulo dentro: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  La situaci贸n se vuelve a煤n m谩s interesante cuando intentamos armar nuestro programa: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Como puede ver, el comando <code>go</code> encontr贸 y descarg贸 autom谩ticamente el paquete importado por nuestro programa. <br>  Si revisamos nuestro archivo <code>go.mod</code> , veremos que algo ha cambiado: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Y tenemos otro nuevo archivo llamado <code>go.sum</code> , que contiene los hash de los paquetes para verificar la versi贸n y los archivos correctos. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Hacer una versi贸n de lanzamiento de correcci贸n de errores </h2><br><p>  Ahora, supongamos que encontramos un problema en nuestro paquete: 隆no hay puntuaci贸n en el saludo! <br>  Algunas personas se pondr谩n furiosas porque nuestro saludo amistoso ya no es tan amistoso. <br>  Arreglemos esto y publiquemos una nueva versi贸n: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  Hicimos este cambio directamente en la rama <code>v1</code> , porque no tiene nada que ver con lo que haremos a continuaci贸n en la rama <code>v2</code> , pero en la vida real, tal vez deber铆a hacer estos cambios en <code>master</code> y luego transferirlos a <code>v1</code> .  En cualquier caso, la soluci贸n debe estar en la rama <code>v1</code> y debemos marcar esto como una nueva versi贸n. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> git commit <span class="hljs-literal"><span class="hljs-literal">-m</span></span> <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go <span class="hljs-variable"><span class="hljs-variable">$</span></span> git tag v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> git push -<span class="hljs-literal"><span class="hljs-literal">-tags</span></span> origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Actualizaci贸n de m贸dulos </h2><br><p>  Por defecto, Go no actualiza los m贸dulos sin demanda.  "Y eso es bueno", ya que a todos nos gustar铆a la previsibilidad en nuestras compilaciones.  Si los m贸dulos Go se actualizan autom谩ticamente cada vez que se lanza una nueva versi贸n, volver铆amos a la "edad oscura anterior a Go1.11".  Pero no, debemos <em>decirle a</em> Go que actualice los m贸dulos por nosotros. </p><br><p>  Y lo haremos con la ayuda de nuestro viejo amigo: <code>go get</code> : </p><br><ul><li><p>  ejecute <code>go get -u</code> para usar la 煤ltima versi贸n <em>menor o parche</em> (es decir, el comando se actualizar谩 de 1.0.0 a, por ejemplo, 1.0.1 o 1.1.0, si dicha versi贸n est谩 disponible) </p><br></li><li><p>  ejecute <code>go get -u=patch</code> para usar la 煤ltima versi贸n del parche (es decir, el paquete se actualizar谩 a 1.0.1, pero <em>no</em> a 1.1.0) </p><br></li><li><p>  ejecute <code>go get package@version</code> para actualizar a una versi贸n espec铆fica (por ejemplo, <code>github.com/robteix/testmod@v1.0.1</code> ) </p><br></li></ul><br><p>  No hay forma en esta lista de actualizar a la 煤ltima versi贸n <em>principal</em> .  Hay una buena raz贸n para esto, como veremos pronto. </p><br><p>  Como nuestro programa us贸 la versi贸n 1.0.0 de nuestro paquete y acabamos de crear la versi贸n 1.0.1, <em>cualquiera</em> de los siguientes comandos nos actualizar谩 a 1.0.1: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get <span class="hljs-literal"><span class="hljs-literal">-u</span></span>=patch <span class="hljs-variable"><span class="hljs-variable">$</span></span> go get github.com/robteix/testmod@v1.<span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br><p>  Despu茅s de comenzar (digamos <code>go get -u</code> ), nuestro <code>go.mod</code> ha cambiado: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Versi贸n mayor </h2><br><p>  Seg煤n la especificaci贸n de las versiones sem谩nticas, la versi贸n principal <em>difiere</em> de la versi贸n secundaria.  Las versiones principales pueden romper la compatibilidad con versiones anteriores.  Desde el punto de vista de los m贸dulos Go, la versi贸n principal es un <em>paquete</em> completamente <em>diferente</em> . </p><br><p>  Puede sonar salvaje al principio, pero tiene sentido: dos versiones de la biblioteca que son incompatibles entre s铆 son dos bibliotecas diferentes. </p><br><p>  Hagamos un cambio importante en nuestro paquete.  Supongamos que, con el tiempo, nos qued贸 claro que nuestra API es demasiado simple, demasiado limitada para los casos de nuestros usuarios, por lo que debemos cambiar la funci贸n <code>Hi()</code> para aceptar el idioma de bienvenida como par谩metro: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("隆Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Los programas existentes que usan nuestra API se interrumpir谩n porque a) no pasan el lenguaje como par谩metro yb) no esperan un retorno de error.  Nuestra nueva API ya no es compatible con la versi贸n 1.x, as铆 que cumpla con la versi贸n 2.0.0. </p><br><p>  Mencion茅 anteriormente que algunas versiones tienen caracter铆sticas, y ahora este es el caso. <br>  <strong>La versi贸n 2 <em>o posterior</em> deber铆a cambiar la ruta de importaci贸n.</strong>  Ahora estas son bibliotecas diferentes. </p><br><p>  Haremos esto agregando una nueva <em>ruta versionada</em> al nombre de nuestro m贸dulo. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Todo lo dem谩s es igual: empujar, poner una etiqueta de que es v2.0.0 (y opcionalmente sod una rama v2) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Actualizaci贸n de la versi贸n principal </h2><br><p>  Aunque lanzamos una nueva versi贸n incompatible de nuestra biblioteca, los programas existentes <em>no se rompieron</em> , porque contin煤an usando la versi贸n 1.0.1. <br>  <code>go get -u</code> <em>no</em> descargar谩 la versi贸n 2.0.0. </p><br><p>  Pero en alg煤n momento, yo, como usuario de la biblioteca, podr铆a querer actualizar a la versi贸n 2.0.0, porque, por ejemplo, soy uno de esos usuarios que necesitan soporte para varios idiomas. </p><br><p>  Para actualizar, necesito cambiar mi programa en consecuencia: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Ahora, cuando ejecuto <code>go build</code> , se "cierra" y descarga la versi贸n 2.0.0 para m铆.  Tenga en cuenta que aunque la ruta de importaci贸n ahora termina en "v2", Go todav铆a se refiere al m贸dulo por su nombre real ("testmod"). </p><br><p>  Como dije, la versi贸n principal es en todos los sentidos un paquete diferente.  Estos dos m贸dulos Go no est谩n conectados de ninguna manera.  Esto significa que podemos tener dos versiones incompatibles en un binario: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Y esto elimina el problema com煤n con la gesti贸n de dependencias cuando las dependencias dependen de diferentes versiones de la misma biblioteca. </p><br><h2 id="navodim-poryadok">  Ponemos las cosas en orden </h2><br><p>  Volvamos a la versi贸n anterior, que usa solo testmod 2.0.0; si verificamos el contenido de <code>go.mod</code> , notaremos algo: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  Por defecto, Go no elimina las dependencias de <code>go.mod</code> hasta que lo solicite.  Si tiene dependencias que ya no son necesarias y desea limpiarlas, puede usar el nuevo comando <code>tidy</code> : </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Ahora solo tenemos las dependencias que realmente usamos. </p><br><h2 id="vendoring">  Vending </h2><br><p>  Ir m贸dulos por defecto ignora el <code>vendor/</code> directorio.  La idea es deshacerse gradualmente de la venta <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a></sup> .  Pero si a煤n queremos agregar las dependencias "separadas" a nuestro control de versiones, podemos hacer esto: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  El equipo crear谩 el directorio <code>vendor/</code> en la ra铆z de nuestro proyecto, que contiene el c贸digo fuente de todas las dependencias. </p><br><p>  Sin embargo, <code>go build</code> por defecto a煤n ignora el contenido de este directorio.  Si desea recopilar dependencias del <code>vendor/</code> directorio, debe solicitarlo expl铆citamente. </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> go build <span class="hljs-literal"><span class="hljs-literal">-mod</span></span> vendor</code> </pre> <br><p>  Supongo que muchos desarrolladores que quieran usar la venta autom谩tica ejecutar谩n <code>go build</code> <code>-mod vendor</code> , como de costumbre, en sus m谩quinas y usar谩n <code>-mod vendor</code> en su CI. </p><br><p>  Nuevamente, los m贸dulos Go se est谩n alejando de la idea de vender para usar proxies para m贸dulos para aquellos que no desean depender directamente de los servicios de control de versiones ascendentes. </p><br><p>  Hay formas de garantizar que <code>go</code> red no est茅 disponible (por ejemplo, usando <code>GOPROXY=off</code> ), pero este es el tema del pr贸ximo art铆culo. </p><br><h2 id="zaklyuchenie">  Conclusi贸n </h2><br><p>  El art铆culo puede parecer complicado para alguien, pero esto es porque trat茅 de explicar mucho de una vez.  La realidad es que los m贸dulos Go son generalmente simples hoy en d铆a: nosotros, como de costumbre, importamos el paquete a nuestro c贸digo, y el equipo <code>go</code> hace el resto por nosotros.  Las dependencias se cargan autom谩ticamente durante el ensamblaje. </p><br><p>  Los m贸dulos tambi茅n eliminan la necesidad de <code>$GOPATH</code> , que era un obst谩culo para los nuevos desarrolladores de Go que ten铆an problemas para entender por qu茅 deber铆an poner algo en un directorio espec铆fico. </p><br><p><del>  La venta (no oficial) ha quedado en desuso a favor del uso de un proxy. </del>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a></sup> <br>  Puedo hacer un art铆culo separado sobre proxies para los m贸dulos Go. </p><br><p>  Notas: </p><br><p>  <sup>1</sup> Creo que esta es una expresi贸n demasiado fuerte y algunos pueden tener la impresi贸n de que se est谩n eliminando las ventas en este momento.  Esto no es asi.  La venta sigue funcionando, aunque de forma ligeramente diferente que antes.  Aparentemente, existe el deseo de reemplazar la venta autom谩tica con algo mejor, por ejemplo, un proxy (no es un hecho).  Hasta ahora, esto es simplemente la b煤squeda de una mejor soluci贸n.  Las ventas no desaparecer谩n hasta que se encuentre un buen reemplazo (si lo hay). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421411/">https://habr.com/ru/post/es421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421399/index.html">An谩lisis de puerta trasera de Turla Cybergroup Outlook</a></li>
<li><a href="../es421401/index.html">Anatom铆a de los sistemas de recomendaci贸n. Parte dos</a></li>
<li><a href="../es421403/index.html">Semana de la seguridad 32: drama de Fortnite-Android</a></li>
<li><a href="../es421407/index.html">Reuni贸n t茅cnica en San Petersburgo el 13 de septiembre: c贸mo hacer grandes cambios en el backend</a></li>
<li><a href="../es421409/index.html">Espiar cosas: guardar un secreto</a></li>
<li><a href="../es421413/index.html">Acceso adecuado a los m茅todos de interfaz predeterminados a trav茅s de la reflexi贸n en Java 8, 9, 10</a></li>
<li><a href="../es421415/index.html">Magic Leap - basura triste</a></li>
<li><a href="../es421417/index.html">Cafetera para adictos al caf茅, o cafetera m贸vil Wacaco</a></li>
<li><a href="../es421419/index.html">Oda al n铆quel "espumado", zafiros inexistentes y al viceministro sovi茅tico: ic贸nico OTTO SX-P1 en Jap贸n, Estados Unidos y la URSS</a></li>
<li><a href="../es421421/index.html">LAppS: Medio mill贸n de mensajes de 1KB-WebSocket por segundo con TLS en una CPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>