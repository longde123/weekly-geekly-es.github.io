<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåõ ‚ò∏Ô∏è üë®üèº‚Äçüåæ Du copier-coller aux composants: r√©utiliser le code dans diff√©rentes applications ‚¨áÔ∏è üê± üèáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo d√©veloppe plusieurs applications, et chacune d'elles est un produit distinct avec ses propres caract√©ristiques, √©quipes de gestion, de produit e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Du copier-coller aux composants: r√©utiliser le code dans diff√©rentes applications</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br><br>  Badoo d√©veloppe plusieurs applications, et chacune d'elles est un produit distinct avec ses propres caract√©ristiques, √©quipes de gestion, de produit et d'ing√©nierie.  Mais nous travaillons tous ensemble dans le m√™me bureau et r√©solvons des probl√®mes similaires. <br><br>  Le d√©veloppement de chaque projet s'est d√©roul√© √† sa mani√®re.  La base de code a √©t√© influenc√©e non seulement par des d√©lais et des solutions de produits diff√©rents, mais aussi par la vision des d√©veloppeurs.  En fin de compte, nous avons remarqu√© que les projets ont la m√™me fonctionnalit√©, qui est fondamentalement diff√©rente dans la mise en ≈ìuvre. <br><br>  Ensuite, nous avons d√©cid√© de parvenir √† une structure qui nous donnerait la possibilit√© de r√©utiliser les fonctionnalit√©s entre les applications.  Maintenant, au lieu de d√©velopper des fonctionnalit√©s dans des projets individuels, nous cr√©ons des composants communs qui s'int√®grent dans tous les produits.  Si vous √™tes int√©ress√© par la fa√ßon dont nous en sommes arriv√©s √† cela, bienvenue chez cat. <a name="habracut"></a><br><br>  Mais d'abord, attardons-nous sur les probl√®mes, dont la solution a conduit √† la cr√©ation de composants communs.  Il y en avait plusieurs: <br><br><ul><li>  copier-coller entre les applications; <br></li><li>  processus qui ins√®rent des b√¢tons dans les roues; <br></li><li>  architecture diff√©rente des projets. <br></li></ul><br><img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br><br>  <i>Cet article est une version texte de mon rapport avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf 2019</a> , qui peut √™tre consult√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</i> <br><br><h2>  Probl√®me: copier coller </h2><br>  Il y a quelque temps, lorsque les arbres √©taient plus flous, l'herbe √©tait plus verte et j'avais un an de moins, nous avions souvent la situation suivante. <br><br>  Il y a un d√©veloppeur, appelons-le Lesha.  Il cr√©e un module sympa pour sa t√¢che, en parle √† ses coll√®gues et le met dans le r√©f√©rentiel de son application, o√π il l'utilise. <br><br>  Le probl√®me est que toutes nos applications sont dans des r√©f√©rentiels diff√©rents. <br><br><img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br><br>  Le d√©veloppeur Andrey travaille actuellement sur une autre application dans un r√©f√©rentiel diff√©rent.  Il veut utiliser ce module dans sa t√¢che, qui est √©trangement similaire √† celle dans laquelle Lesha √©tait engag√©.  Mais il y a un probl√®me: le processus de r√©utilisation du code est compl√®tement d√©bogu√©. <br><br>  Dans cette situation, Andrei r√©digera sa d√©cision (ce qui se produit dans 80% des cas) ou copiera-collera la solution de Lyosha et y changera tout pour qu'elle corresponde √† son application, sa t√¢che ou son humeur. <br><br><img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br><br>  Apr√®s cela, Lesha peut mettre √† jour son module en ajoutant des modifications √† son code pour sa t√¢che.  Il ne conna√Æt pas une autre version et ne mettra √† jour que son r√©f√©rentiel. <br><br>  Cette situation pose plusieurs probl√®mes. <br><br>  Premi√®rement, nous avons plusieurs applications, chacune avec sa propre histoire de d√©veloppement.  Lorsqu'elle travaille sur chaque application, l'√©quipe produit cr√©e souvent des solutions difficiles √† apporter √† une seule structure. <br><br>  Deuxi√®mement, des √©quipes distinctes sont impliqu√©es dans les projets, qui communiquent mal entre elles et, par cons√©quent, s'informent rarement mutuellement des mises √† jour / r√©utilisation de l'un ou l'autre module. <br><br>  Troisi√®mement, l'architecture de l'application est tr√®s diff√©rente: du MVP au MVI, de l'activit√© divine √† l'activit√© unique. <br><br>  Eh bien, le ¬´point culminant du programme¬ª: les applications sont dans diff√©rents r√©f√©rentiels, chacun avec ses propres processus. <br><br>  Au d√©but de la lutte contre ces probl√®mes, nous avons fix√© l'objectif ultime: r√©utiliser nos meilleures pratiques (logiques et UI) entre toutes les applications. <br><br><h2>  D√©cisions: nous √©tablissons des processus </h2><br>  Parmi les probl√®mes ci-dessus, deux sont li√©s aux processus: <br><br><ol><li>  Deux r√©f√©rentiels qui partageaient des projets avec un mur imp√©n√©trable. <br></li><li>  √âquipes distinctes sans communication √©tablie et exigences diff√©rentes des √©quipes d'application de produit. <br></li></ol><br>  Commen√ßons par le premier: nous avons affaire √† deux r√©f√©rentiels avec la m√™me version de module.  Th√©oriquement, nous pourrions utiliser git-subtree ou des solutions similaires et placer les modules de projet communs dans des r√©f√©rentiels s√©par√©s. <br><br><img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br><br>  Le probl√®me se produit lors de la modification.  Contrairement aux projets open source, qui ont une API stable et sont distribu√©s via des sources externes, des changements se produisent souvent dans les composants internes qui cassent tout.  Lorsque vous utilisez un sous-arbre, chacune de ces migrations devient p√©nible. <br><br>  Mes coll√®gues de l'√©quipe iOS ont une exp√©rience similaire, et cela n'a pas √©t√© un grand succ√®s, comme Anton Schukin en a parl√© lors de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la conf√©rence Mobius</a> l'ann√©e derni√®re. <br><br>  Apr√®s avoir √©tudi√© et compris leur exp√©rience, nous sommes pass√©s √† un r√©f√©rentiel unique.  Toutes les applications Android se trouvent d√©sormais au m√™me endroit, ce qui nous offre certains avantages: <br><br><ul><li>  vous pouvez r√©utiliser le code en toute s√©curit√© √† l'aide des modules Gradle; <br></li><li>  nous avons r√©ussi √† connecter la cha√Æne d'outils sur CI en utilisant une seule infrastructure pour les builds et les tests; <br></li><li>  ces changements ont supprim√© la barri√®re physique et mentale entre les √©quipes, puisque nous sommes maintenant libres d'utiliser les d√©veloppements et les solutions des uns et des autres. <br></li></ul><br>  Bien entendu, cette solution pr√©sente √©galement des inconv√©nients.  Nous avons un √©norme projet, qui n'est parfois pas soumis √† l'IDE et √† Gradle.  Le probl√®me pourrait √™tre partiellement r√©solu par les modules de chargement / d√©chargement dans Android Studio, mais il est difficile de les utiliser si vous devez travailler simultan√©ment sur toutes les applications et souvent basculer. <br><br>  Le deuxi√®me probl√®me - l'interaction entre les √©quipes - consistait en plusieurs parties: <br><br><ul><li>  des √©quipes distinctes sans communication √©tablie; <br></li><li>  r√©partition indistincte de la responsabilit√© des modules communs; <br></li><li>  diff√©rentes exigences des √©quipes de produits. <br></li></ul><br>  Pour le r√©soudre, nous avons form√© des √©quipes engag√©es dans l'impl√©mentation de certaines fonctionnalit√©s dans chaque application: par exemple, le chat ou l'inscription.  En plus du d√©veloppement, ils sont √©galement charg√©s d'int√©grer ces composants dans l'application. <br><br>  Les √©quipes de produits ont d√©j√† entre les mains des composants existants, les am√©liorant et les adaptant aux besoins d'un projet particulier. <br><br>  Ainsi, la cr√©ation d'un composant r√©utilisable fait d√©sormais partie du processus pour toute l'entreprise, de l'√©tape de l'id√©e au d√©marrage de la production. <br><br><h2>  Solutions: rationaliser l'architecture </h2><br>  Notre prochaine √©tape vers la r√©utilisation a √©t√© de rationaliser l'architecture.  Pourquoi avons-nous fait √ßa? <br><br>  Notre base de code porte l'h√©ritage historique de plusieurs ann√©es de d√©veloppement.  Avec le temps et les gens, les approches ont chang√©.  Nous nous sommes donc retrouv√©s dans une situation avec tout un zoo d'architectures, ce qui a entra√Æn√© les probl√®mes suivants: <br><br><ol><li>  L'int√©gration de modules communs a √©t√© presque plus lente que la cr√©ation de nouveaux modules.  En plus des caract√©ristiques de la fonctionnalit√©, il √©tait n√©cessaire de supporter la structure du composant et de l'application. <br></li><li>  Les d√©veloppeurs qui devaient passer d'une application √† l'autre passaient tr√®s souvent beaucoup de temps √† ma√Ætriser de nouvelles approches. <br></li><li>  Souvent, les wrappers √©taient √©crits d'une approche √† une autre, ce qui repr√©sentait la moiti√© du code de l'int√©gration du module. <br></li></ol><br>  Au final, nous avons opt√© pour l'approche MVI, que nous avons structur√©e dans notre biblioth√®que MVICore ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> ).  Nous √©tions particuli√®rement int√©ress√©s par l'une de ses fonctionnalit√©s - les mises √† jour de l'√©tat atomique, qui garantissent toujours la validit√©.  Nous sommes all√©s un peu plus loin et avons combin√© les √©tats des couches logiques et de pr√©sentation, r√©duisant la fragmentation.  Ainsi, nous arrivons √† une structure o√π la seule entit√© est responsable de la logique, et la vue affiche uniquement le mod√®le cr√©√© √† partir de l'√©tat. <br><br><img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br><br>  La s√©paration des responsabilit√©s passe par la transformation des mod√®les entre les niveaux.  Gr√¢ce √† cela, nous obtenons un bonus sous forme de r√©utilisation.  Nous connectons les √©l√©ments de l'ext√©rieur, c'est-√†-dire que chacun d'eux ne soup√ßonne pas que l'autre existe - ils donnent simplement des mod√®les et r√©agissent √† ce qui leur vient.  Cela vous permet de retirer des composants et de les utiliser ailleurs en √©crivant des adaptateurs pour leurs mod√®les. <br><br>  Regardons un exemple d'√©cran simple √† quoi il ressemble en r√©alit√©. <br><br><img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br><br>  Nous utilisons les interfaces de base de RxJava pour indiquer les types avec lesquels l'√©l√©ment fonctionne.  L'entr√©e est indiqu√©e par l'interface Consumer &lt;T&gt;, la sortie - ObservableSource &lt;T&gt;. <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt; // output = ObservableSource&lt;Event&gt; class View( val events: PublishRelay&lt;Event&gt; ): ObservableSource&lt;Event&gt; by events, Consumer&lt;ViewModel&gt; { val button: Button val textView: TextView init { button.setOnClickListener { events.accept(Event.ButtonClick) } } override fun accept(model: ViewModel) { textView.text = model.text } }</span></span></code> </pre> <br>  En utilisant ces interfaces, nous pouvons exprimer View en tant que Consumer &lt;ViewModel&gt; et ObservableSource &lt;Event&gt;.  Notez que le ViewModel ne contient que l'√©tat de l'√©cran et a peu √† voir avec MVVM.  Apr√®s avoir re√ßu le mod√®le, nous pouvons afficher les donn√©es de celui-ci, et lorsque nous cliquons sur le bouton, nous envoyons l'√©v√©nement, qui est transmis √† l'ext√©rieur. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;Wish&gt; // output = ObservableSource&lt;State&gt; class Feature: ReducerFeature&lt;Wish, State&gt;( initialState = State(counter = 0), reducer = ReducerImpl() ) { class ReducerImpl: Reducer&lt;Wish, State&gt; { override fun invoke(state: State, wish: Wish) = when (wish) { is Increment -&gt; state.copy(counter = state.counter + 1) } } }</span></span></code> </pre> <br>  La fonctionnalit√© impl√©mente d√©j√† ObservableSource et Consumer pour nous;  nous devons y transf√©rer l'√©tat initial (compteur √©gal √† 0) et indiquer comment changer cet √©tat. <br><br>  Apr√®s le transfert de Wish, Reducer est appel√©, ce qui en cr√©e un nouveau en fonction du dernier √©tat.  En plus de Reducer, la logique peut √™tre d√©crite par d'autres composants.  Vous pouvez en savoir plus √† leur sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Apr√®s avoir cr√©√© les deux √©l√©ments, il nous reste √† les connecter. <br><br><img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventToWish: (Event) -&gt; Wish = { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ButtonClick -&gt; Increment } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateToModel: (State) -&gt; ViewModel = { ViewModel(text = state.counter.toString()) } Binder().apply { bind(view to feature using eventToWish) bind(feature to view using stateToModel) }</code> </pre> <br>  Tout d'abord, nous indiquons comment nous transformons un √©l√©ment d'un type en un autre.  Ainsi, ButtonClick devient Increment et le champ de compteur State passe au texte. <br><br>  Maintenant, nous pouvons cr√©er chacune des cha√Ænes avec la transformation souhait√©e.  Pour cela, nous utilisons Binder.  Il vous permet de cr√©er des relations entre ObservableSource et Consumer, en observant le cycle de vie.  Et tout cela avec une belle syntaxe.  Ce type de connexion nous conduit √† un syst√®me flexible qui nous permet d'extraire et d'utiliser des √©l√©ments individuellement. <br><br>  Les √©l√©ments MVICore fonctionnent assez bien avec notre ¬´zoo¬ª d'architectures apr√®s avoir √©crit des wrappers depuis ObservableSource et Consumer.  Par exemple, nous pouvons encapsuler les m√©thodes de cas d'utilisation de Clean Architecture dans Wish / State et les utiliser dans la cha√Æne au lieu de Feature. <br><br><img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br><br><h2>  Composant </h2><br>  Enfin, nous passons aux composants.  √Ä quoi ressemblent-ils? <br><br>  Consid√©rez l'√©cran dans l'application et divisez-le en parties logiques. <br><br><img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br><br>  On peut le distinguer: <br><br><ul><li>  barre d'outils avec logo et boutons en haut; <br></li><li>  une carte avec un profil et un logo; <br></li><li>  Section Instagram. <br></li></ul><br>  Chacune de ces pi√®ces est le composant m√™me qui peut √™tre r√©utilis√© dans un contexte compl√®tement diff√©rent.  Ainsi, la section Instagram peut faire partie de l'√©dition de profil dans une autre application. <br><br><img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br><br>  Dans le cas g√©n√©ral, un composant est constitu√© de plusieurs vues, √©l√©ments logiques et composants imbriqu√©s √† l'int√©rieur, unis par des fonctionnalit√©s communes.  Et imm√©diatement la question se pose: comment les assembler en une structure support√©e? <br><br>  Le premier probl√®me que nous avons rencontr√© est que MVICore aide √† cr√©er et √† lier des √©l√©ments, mais n'offre pas de structure commune.  Lors de la r√©utilisation d'√©l√©ments d'un module commun, il n'est pas clair o√π assembler ces pi√®ces: √† l'int√©rieur de la partie commune ou du c√¥t√© application? <br><br>  Dans le cas g√©n√©ral, nous ne voulons certainement pas donner √† l'application des pi√®ces √©parses.  Id√©alement, nous recherchons une sorte de structure qui nous permettra d'obtenir des d√©pendances et d'assembler le composant dans son ensemble avec le cycle de vie souhait√©. <br><br>  Au d√©part, nous avons divis√© les composants en √©crans.  La connexion des √©l√©ments a eu lieu √† c√¥t√© de la cr√©ation de conteneurs DI pour l'activit√© ou le fragment.  Ces conteneurs connaissent d√©j√† toutes les d√©pendances, ont acc√®s √† la vue et au cycle de vie. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SomeComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerSomeComponent.builder() .build() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SomeComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Array&lt;Disposable&gt; = arrayOf( Binder().apply { bind(feature().news to otherFeature()) bind(feature() to view()) } ) }</code> </pre> <br>  Les probl√®mes ont commenc√© √† deux endroits √† la fois: <br><br><ol><li>  DI a commenc√© √† travailler avec la logique, ce qui a conduit √† la description de l'ensemble du composant dans une seule classe. <br></li><li>  √âtant donn√© que le conteneur est attach√© √† une activit√© ou √† un fragment et d√©crit au moins tout l'√©cran, il y a beaucoup d'√©l√©ments sur un tel √©cran / conteneur, ce qui se traduit par une √©norme quantit√© de code pour connecter toutes les d√©pendances de cet √©cran. <br></li></ol><br>  Pour r√©soudre les probl√®mes dans l'ordre, nous avons commenc√© par placer la logique dans un composant distinct.  Ainsi, nous pouvons collecter toutes les fonctionnalit√©s √† l'int√©rieur de ce composant et communiquer avec View via les entr√©es et les sorties.  Du point de vue de l'interface, il ressemble √† un √©l√©ment MVICore normal, mais en m√™me temps il est cr√©√© √† partir de plusieurs autres. <br><br><img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br><br>  Apr√®s avoir r√©solu ce probl√®me, nous avons partag√© la responsabilit√© de connecter les √©l√©ments.  Mais nous partagions toujours les composants sur les √©crans, ce qui n'√©tait clairement pas √† notre port√©e, ce qui entra√Ænait un grand nombre de d√©pendances en un seul endroit. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params: ScreenParams, news: NewsRelay, <span class="hljs-meta"><span class="hljs-meta">@OnDisposeAction</span></span> onDisposeAction: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, globalFeature: GlobalFeature, conversationControlFeature: ConversationControlFeature, messageSyncFeature: MessageSyncFeature, conversationInfoFeature: ConversationInfoFeature, conversationPromoFeature: ConversationPromoFeature, messagesFeature: MessagesFeature, messageActionFeature: MessageActionFeature, initialScreenFeature: InitialScreenFeature, initialScreenExplanationFeature: InitialScreenExplanationFeature?, errorFeature: ErrorFeature, conversationInputFeature: ConversationInputFeature, sendRegularFeature: SendRegularFeature, sendContactForCreditsFeature: SendContactForCreditsFeature, screenEventTrackingFeature: ScreenEventTrackingFeature, messageReadFeature: MessageReadFeature?, messageTimeFeature: MessageTimeFeature?, photoGalleryFeature: PhotoGalleryFeature?, onlineStatusFeature: OnlineStatusFeature?, favouritesFeature: FavouritesFeature?, isTypingFeature: IsTypingFeature?, giftStoreFeature: GiftStoreFeature?, messageSelectionFeature: MessageSelectionFeature?, reportingFeature: ReportingFeature?, takePhotoFeature: TakePhotoFeature?, giphyFeature: GiphyFeature, goodOpenersFeature: GoodOpenersFeature?, matchExpirationFeature: MatchExpirationFeature, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pushIntegration: PushIntegration ) : AbstractMviComponent&lt;UiEvent, States&gt;(</code> </pre> <br>  La bonne solution dans cette situation est de casser le composant.  Comme nous l'avons vu ci-dessus, chaque √©cran se compose de nombreux √©l√©ments logiques que nous pouvons diviser en parties ind√©pendantes. <br><br>  Apr√®s une petite r√©flexion, nous sommes arriv√©s √† une structure arborescente et, en la construisant na√Øvement √† partir de composants existants, nous avons obtenu ce sch√©ma: <br><br><img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br><br>  Bien s√ªr, maintenir la synchronisation de deux arbres (depuis View et depuis la logique) est presque impossible.  Cependant, si le composant est responsable de l'affichage de sa vue, nous pouvons simplifier ce sch√©ma.  Apr√®s avoir √©tudi√© les solutions d√©j√† cr√©√©es, nous avons repens√© notre approche en nous appuyant sur les RIB d'Uber. <br><br><img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br><br>  Les id√©es derri√®re cette approche sont tr√®s similaires aux bases de MVICore.  Le RIB est une sorte de ¬´bo√Æte noire¬ª avec laquelle la communication se fait via une interface strictement d√©finie √† partir des d√©pendances (√† savoir, les entr√©es et les sorties).  Malgr√© la complexit√© apparente de la prise en charge d'une telle interface dans un produit it√©ratif rapide, nous avons de grandes opportunit√©s pour r√©utiliser le code. <br><br>  Ainsi, par rapport aux it√©rations pr√©c√©dentes, on obtient: <br><br><ul><li>  logique encapsul√©e √† l'int√©rieur d'un composant; <br></li><li>  prise en charge de l'imbrication, qui permet de diviser les √©crans en parties; <br></li><li>  interaction avec d'autres composants via une interface stricte d'entr√©e / sortie avec prise en charge de MVICore; <br></li><li>  connexion s√©curis√©e √† la compilation des d√©pendances des composants (en se basant sur Dagger comme DI). <br></li></ul><br>  Bien s√ªr, c'est loin d'√™tre tout.  Le r√©f√©rentiel sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> contient une description plus d√©taill√©e et √† jour. <br><br>  Et ici, nous avons un monde parfait.  Il a des composants √† partir desquels nous pouvons construire une arborescence enti√®rement r√©utilisable. <br><br>  Mais nous vivons dans un monde imparfait. <br><br><h2>  Bienvenue dans la r√©alit√©! </h2><br>  Dans un monde imparfait, il y a un tas de choses que nous devons supporter.  Nous nous inqui√©tons des √©l√©ments suivants: <br><br><ul><li>  diff√©rentes fonctionnalit√©s: malgr√© toute l'unification, nous avons toujours affaire √† des produits individuels avec des exigences diff√©rentes; <br></li><li>  support: comment sans nouvelles fonctionnalit√©s sous tests A / B? <br></li><li>  Legacy (tout ce qui a √©t√© √©crit avant notre nouvelle architecture). <br></li></ul><br>  La complexit√© des solutions augmente de fa√ßon exponentielle, car chaque application ajoute quelque chose de propre aux composants communs. <br><br>  Consid√©rez le processus d'enregistrement comme un exemple de composant commun qui s'int√®gre dans les applications.  En g√©n√©ral, l'enregistrement est une cha√Æne d'√©crans avec des actions qui affectent l'ensemble du flux.  Chaque application a des √©crans diff√©rents et sa propre interface utilisateur.  Le but ultime est de cr√©er un composant r√©utilisable flexible, qui nous aidera √©galement √† r√©soudre les probl√®mes de la liste ci-dessus. <br><br><img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br><br><h3>  Exigences diverses </h3><br>  Chaque application a ses propres variations d'enregistrement uniques, √† la fois du c√¥t√© logique et du c√¥t√© de l'interface utilisateur.  Par cons√©quent, nous commen√ßons √† g√©n√©raliser la fonctionnalit√© du composant avec un minimum: en t√©l√©chargeant des donn√©es et en acheminant l'ensemble du flux. <br><br><img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br><br>  Un tel conteneur transf√®re les donn√©es √† l'application depuis le serveur, qui est converti en un √©cran fini avec logique.  Seule condition: les √©crans transmis √† un tel conteneur doivent satisfaire des d√©pendances pour interagir avec la logique de l'ensemble du flux. <br><br>  Apr√®s avoir fait cette astuce avec quelques applications, nous avons remarqu√© que la logique des √©crans est presque la m√™me.  Dans un monde id√©al, nous cr√©erions une logique commune en personnalisant la vue.  La question est de savoir comment les personnaliser. <br><br>  Comme vous vous en souvenez de la description de MVICore, View et Feature sont bas√©s sur l'interface d'ObservableSource et Consumer.  En les utilisant comme abstraction, nous pouvons remplacer l'impl√©mentation sans changer les parties principales. <br><br><img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br><br>  Nous r√©utilisons donc la logique en divisant l'interface utilisateur.  En cons√©quence, le support devient beaucoup plus pratique. <br><br><h3>  Le soutien </h3><br>  Consid√©rez le test A / B pour la variation des √©l√©ments visuels.  Dans ce cas, notre logique ne change pas, ce qui nous permet de substituer une autre impl√©mentation de View √† l'interface existante d'ObservableSource et Consumer. <br><br><img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br><br>  Bien s√ªr, parfois de nouvelles exigences contredisent une logique d√©j√† √©crite.  Dans ce cas, nous pouvons toujours revenir au sch√©ma d'origine, o√π l'application fournit la totalit√© de l'√©cran.  Pour nous, c'est une sorte de ¬´bo√Æte noire¬ª, et peu importe pour le conteneur ce qu'il lui passe, tant que son interface est respect√©e. <br><br><h3>  Int√©gration </h3><br>  Comme le montre la pratique, la plupart des applications utilisent Activity comme unit√©s de base, dont les moyens de communication sont connus depuis longtemps.  Tout ce que nous avions √† faire √©tait d'apprendre √† encapsuler les composants dans Activity et √† transmettre les donn√©es via les entr√©es et les sorties.  Il s'est av√©r√© que cette approche fonctionne tr√®s bien avec des fragments. <br><br>  Pour les applications √† activit√© unique, rien ne change beaucoup.  Presque tous les frameworks proposent leurs √©l√©ments de base dans lesquels les composants RIB se laissent envelopper. <br><br><h2>  En fin de compte </h2><br>  Apr√®s avoir franchi ces √©tapes, nous avons consid√©rablement augment√© le pourcentage de r√©utilisation du code entre les projets de notre entreprise.  √Ä l'heure actuelle, le nombre de composants approche de 100, et la plupart d'entre eux impl√©mentent des fonctionnalit√©s pour plusieurs applications √† la fois. <br><br>  Notre exp√©rience montre que: <br><br><ul><li>  malgr√© la complexit√© accrue de la conception de composants communs, compte tenu des exigences des diff√©rentes applications, leur prise en charge est beaucoup plus facile √† long terme; <br></li><li>  en construisant des composants <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isol√©s les uns des autres</a> , nous avons grandement simplifi√© leur int√©gration dans des applications construites sur des principes diff√©rents; <br></li><li>  Les r√©visions de processus, associ√©es √† l'accent mis sur le d√©veloppement et le support des composants, ont un effet positif sur la qualit√© de la fonctionnalit√© globale. <br></li></ul><br>  Mon coll√®gue Zsolt Kocsi a pr√©c√©demment √©crit sur MVICore et les id√©es derri√®re.  Je recommande fortement de lire ses articles, que nous avons traduits sur notre blog ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> ). <br><br>  √Ä propos des semi-rigides, vous pouvez lire l'article original d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Uber</a> .  Et pour des connaissances pratiques, je recommande de prendre quelques le√ßons <a href="">de notre part</a> (en anglais). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466049/">https://habr.com/ru/post/fr466049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466033/index.html">Comment attirer une √©quipe dans le processus de recherche d'id√©es et obtenir bien plus que des id√©es</a></li>
<li><a href="../fr466039/index.html">Biblioth√®ques PHP pour le commerce √©lectronique: travailler avec ATOL et Payture, analyser les codes GS1 et autres t√¢ches</a></li>
<li><a href="../fr466041/index.html">Le premier √©v√©nement hors ligne du Facebook Developer Circle: la communaut√© de Moscou - Launch Event</a></li>
<li><a href="../fr466045/index.html">Comment revitaliser une marque: une narration qui a fonctionn√©</a></li>
<li><a href="../fr466047/index.html">Conception de boutiques en ligne. Partie 3. Page d'accueil et catalogue</a></li>
<li><a href="../fr466051/index.html">Automatisation du profilage Java Meetup 10/09</a></li>
<li><a href="../fr466053/index.html">Repr√©sentation des soci√©t√©s informatiques russes √† Singapour: pourquoi pas?</a></li>
<li><a href="../fr466059/index.html">Livre ¬´Design Thinking. De la perspicacit√© aux nouveaux produits et march√©s ¬ª</a></li>
<li><a href="../fr466065/index.html">R√©sum√© des nouvelles de PostgreSQL. Num√©ro 17</a></li>
<li><a href="../fr466067/index.html">√âconomiseur d'√©cran enchanteur pour Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>