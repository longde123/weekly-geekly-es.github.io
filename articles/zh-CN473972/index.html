<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦌 🕙 👨🏿‍🤝‍👨🏻 按嵌入式开发人员的顺序：在Amazon FreeRTOS中查找错误 💄 🚽 ⛱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对微控制器进行编程的每个人都可能了解FreeRTOS，或者至少听说过该操作系统。 亚马逊公司决定扩展此操作系统的功能以与AWS物联网服务一起使用-这就是Amazon FreeRTOS出现的方式。 我们，PVS-Studio代码分析器的开发人员，被要求检查邮件和文章下方的注释中的这些项目。 好吧，你问...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>按嵌入式开发人员的顺序：在Amazon FreeRTOS中查找错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/473972/"> 对微控制器进行编程的每个人都可能了解FreeRTOS，或者至少听说过该操作系统。 亚马逊公司决定扩展此操作系统的功能以与AWS物联网服务一起使用-这就是Amazon FreeRTOS出现的方式。 我们，PVS-Studio代码分析器的开发人员，被要求检查邮件和文章下方的注释中的这些项目。 好吧，你问-我们做到了。 这是怎么回事-请继续阅读。 <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/efa/d2f/8d2efad2f7885ec13add7368f6d2ff96.png" alt="图3"></div><a name="habracut"></a><br><h2> 关于项目的一点 </h2><br> 首先，我将向您介绍已检查项目的“爸爸”-FreeRTOS（您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到源代码）。 如Wikipedia所述，FreeRTOS是嵌入式系统的多任务实时操作系统。 <br><br> 它是用很好的旧C语言编写的，这并不奇怪-该操作系统应在微控制器的典型条件下工作：低计算能力，少量RAM等。  C语言允许您以较低的级别使用资源并具有高性能，因此它最适合开发此类OS。 <br><br> 现在回到亚马逊，它并没有停滞不前，而是在各个有前途的领域中发展。 例如，亚马逊正在开发Amazon Lumberyard游戏AAA引擎，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也对其进行了测试</a> 。 <br><br> 物联网（Internet of Things，IoT）就是这样的领域。 为了在这一领域发展，亚马逊决定编写自己的操作系统-他们以FreeRTOS内核为基础。 <br><br> 最终的系统Amazon FreeRTOS被定位为“提供安全连接到Amazon Web Services（例如AWS IoT Core或AWS IoT Greengrass）的能力”。 该项目的源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储</a>在Github上。 <br><br> 在本文中，我们将检查FreeRTOS中是否存在错误，以及就静态代码分析而言，该操作系统相对于Amazon的安全性如何。 <br><br><h2> 支票怎么样 </h2><br> 使用自动错误搜索工具PVS-Studio静态代码分析器检查代码。 它能够检测用C，C ++，C＃和Java编写的程序中的错误。 <br><br> 在开始分析之前，有必要组装项目-因此我将确保我具有所有必要的依赖关系，并且一切与该项目一致。 有几种验证项目的方法-例如，使用编译监视系统。 我使用Visual Studio插件进行了分析-很好的是，在两个项目的存储库中都有一组项目文件，可轻松在Windows下构建。 <br><br> 对我而言，所需要做的就是收集项目，以确保有必要进行验证。 接下来，我开始分析，瞧！  -在我眼前是现成的分析仪报告。 <br><br> 这些项目中包含的第三方库也可能包含错误，它们当然也可能影响程序的运行。 但是，为了叙述的纯正，我从分析中排除了它们。 <br><br> 因此，分析项目，接收报告，写出有趣的错误。 现在该继续进行他们的分析了！ <br><br><h2> 什么隐藏了FreeRTOS </h2><br> 最初，我希望写两篇单独的文章：每个操作系统一篇。 我已经揉了揉双手，准备写一篇关于FreeRTOS的好文章。 预期甚至会检测到几个多汁的错误（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-457</a> ），我热切地看着分析仪的一些警告，而……什么也没有。 我没有发现任何有趣的错误。 <br><br> 分析仪发出的许多警告与FreeRTOS无关。 例如，此类警告是64位缺陷，例如将<i>size_t</i>强制转换为<i>uint32_t</i> 。 这是由于FreeRTOS设计为可在指针大小不超过32位的设备上工作。 <br><br> 我仔细检查了所有与不相关结构的指针之间的强制转换有关的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1027</a>警告。 如果可还原结构具有相同的对齐方式，则这种转换不是错误。 而且我没有找到一个危险的演员！ <br><br> 所有其他可疑位置要么与编码样式相关，要么带有注释，以解释为什么在此处准确执行此操作以及为什么这不是错误。 <br><br> 通常，我想联系FreeRTOS的开发人员。 你们真的很棒！ 我们几乎从未遇到过像您这样的干净优质的项目。 我很高兴阅读干净，整洁且有据可查的代码。 向您致敬。 <br><br> 尽管那天我找不到任何有趣的错误，但我知道我不会就此止步。 我怀着坚定的信念回到家，将在Amazon 100％的版本中找到一些有趣的东西，并且明天我一定会为本文收集足够的错误。 您可能猜到了，我是对的。 <br><br><h2> 什么隐藏了Amazon FreeRTOS </h2><br> 事实证明，亚马逊的系统版本是...稍微说得有点差。  FreeRTOS的遗留物仍然很干净，但是新修订版却非常有趣。 <br><br> 在某些地方，程序的逻辑被违反，在某些地方指针不能正确使用。 在某些地方，代码可能导致未定义的行为，但是程序员在某些地方根本不了解他所犯的错误模式。 我什至发现了一些严重的潜在漏洞。 <br><br> 我在介绍时有所延迟。 让我们开始解析错误！ <br><br><h3> 程序逻辑违规 </h3><br> 让我们从有问题的区域开始，这些问题区域清楚地表明程序运行不完全符合程序员的预期。 第一个这样的地方将是对数组的可疑工作： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Pool of request and associated response buffers, * handles, and configurations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _requestPool_t _requestPool = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _scheduleAsyncRequest(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqIndex, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currentRange) { .... <span class="hljs-comment"><span class="hljs-comment">/* Set the user private data to use in the asynchronous callback context. */</span></span> _requestPool.pRequestDatas[reqIndex].pConnHandle = &amp;_connHandle; _requestPool.pRequestDatas[reqIndex].pConnConfig = &amp;_connConfig; _requestPool.pRequestDatas[reqIndex].reqNum = reqIndex; _requestPool.pRequestDatas[reqIndex].currRange = currentRange; _requestPool.pRequestDatas[reqIndex].currDownloaded = <span class="hljs-number"><span class="hljs-number">0</span></span>; _requestPool.pRequestDatas[reqIndex].numReqBytes = numReqBytes; .... _requestPool.pRequestDatas-&gt;scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  PVS-Studio为此段代码发出了两个警告： <br><br><ul><li>  V619数组'_requestPool.pRequestDatas'被用作指向单个对象的指针。  iot_demo_https_s3_download_async.c 973 </li><li>  V574'_requestPool.pRequestDatas'指针同时用作数组和指向单个对象的指针。 检查行：931、973。iot_demo_https_s3_download_async.c 973 </li></ul><br> 为了以防万一，让我提醒您：数组的名称是指向其第一个元素的指针。 也就是说，如果<i>_requestPool.pRequestDatas</i>是结构数组，则<i>_requestPool.pRequestDatas [i] .scheduled</i>可以访问数组第<i>i</i>个结构的<i>计划</i>成员。 而且，如果您编写<i>_requestPool.pRequestDatas-&gt; cheduled</i> ，这将意味着访问数组第一个结构的<i>Scheduled</i>成员。 <br><br> 这就是上面的代码片段中发生的情况。 最后一行始终仅更改数组第一个结构的成员的值。 就其本身而言，这样的调用已经是可疑的，但是这里的情况更加明显：在函数的整个主体中， <i>_requestPool.pRequestDatas</i>数组都由索引访问，并且只有在索引操作结束时才被忘记使用。 <br><br> 据我了解，最后一行应如下所示： <br><br><pre> <code class="cpp hljs">_requestPool.pRequestDatas[reqIndex].scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br> 以下错误在于一个小的函数，因此，我将完整介绍它： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Return true if the string " pcString" is found * inside the token pxTok in JSON file pcJson. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prvGGDJsoneq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcJson, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">jsmntok_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pxTok, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcString )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStringSize = ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;end - ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;start; BaseType_t xStatus = pdFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pxTok-&gt;type == JSMN_STRING ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( pcString ) == ulStringSize ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>( &amp;pcJson[ pxTok-&gt;start ], <span class="hljs-comment"><span class="hljs-comment">// &lt;= pcString, ulStringSize ) == 0 ) { xStatus = pdTRUE; } } } return xStatus; }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> V642 [CWE-197]将'strncmp'函数结果保存在'short'类型变量中是不合适的。 有效位可能会丢失，从而破坏程序的逻辑。 第637章 <br><br> 让我们看一下strncmp函数定义： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span></span>;</code> </pre> <br> 在该示例中，大小为32位的<i>int</i>类型的结果被转换为<i>int16_t</i>类型的变量。 通过这种“缩小”转换，将丢失返回值的最高有效位。 例如，如果<i>strncmp</i>函数返回<i>0x00010000</i> ，则在转换过程中将<i>丢失</i> <i>一个</i> ，并满足条件。 <br><br> 实际上，看到这样的演员处于某种状态是很奇怪的。 如果您可以将正常<i>int</i>与零进行比较，为什么还要这样做呢？ 另一方面，如果程序员有意识地希望函数有时返回<i>true</i> ，即使它不应该返回<i>true</i> ，那么为什么注释中没有描述这种棘手的行为呢？ 但是，这已经是一个书签。 总的来说，我倾向于认为这是一个错误。 你觉得呢 <br><br><h3> 未定义的行为和指针 </h3><br> 现在将有一个很大的例子。 它隐藏了空指针的潜在取消引用： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _networkReceiveCallback(....) { IotHttpsReturnCode_t status = IOT_HTTPS_OK; _httpsResponse_t* pCurrentHttpsResponse = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IotLink_t* pQItem = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-comment"><span class="hljs-comment">/* Get the response from the response queue. */</span></span> IotMutex_Lock(&amp;(pHttpsConnection-&gt;connectionMutex)); pQItem = IotDeQueue_PeekHead(&amp;(pHttpsConnection-&gt;respQ)); IotMutex_Unlock(&amp;(pHttpsConnection-&gt;connectionMutex)); <span class="hljs-comment"><span class="hljs-comment">/* If the receive callback is invoked * and there is no response expected, * then this a violation of the HTTP/1.1 protocol. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pQItem == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { IotLogError(....); fatalDisconnect = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; status = IOT_HTTPS_NETWORK_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> iotCleanup; } .... iotCleanup : <span class="hljs-comment"><span class="hljs-comment">/* Report errors back to the application. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != IOT_HTTPS_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pCurrentHttpsResponse-&gt;isAsync &amp;&amp; pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback) { pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback(....); } pCurrentHttpsResponse-&gt;syncStatus = status; } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> V522 [CWE-690]可能会取消引用潜在的空指针'pCurrentHttpsResponse'。  iot_https_client.c 1184 <br><br>  <i>如果</i>取消引用，则问题最底层。 让我们看看这里发生了什么。 <br><br> 在函数开始时， <i>pCurrentHttpsResponse</i>和<i>pQItem变量被</i>初始化为<i>NULL</i> ， <i>状态</i>变量被<i>初始化</i>为<i>IOT_HTTPS_OK</i> ，这意味着一切顺利。 <br><br> 接下来，为<i>pQItem</i>分配<i>IotDeQueue_PeekHead</i>函数返回的值，该函数返回指向双连接队列开头的指针。 <br><br> 如果队列为空会怎样？ 在这种情况下， <i>IotDeQueue_PeekHead</i>函数将返回<i>NULL</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotDeQueue_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotDeQueue_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pQueue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IotListDouble_PeekHead(pQueue); } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotListDouble_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotListDouble_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pList)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* @[declare_linear_containers_list_double_peekhead] */</span></span></span><span class="hljs-function"> </span></span>{ IotLink_t* pHead = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pList != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IotListDouble_IsEmpty(pList) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { pHead = pList-&gt;pNext; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pHead; }</code> </pre> <br> 接下来，满足条件<i>pQItem == NULL</i> ，并且控制流程通过<i>goto</i> <i>进入</i>功能主体的下部。 到这时， <i>pCurrentHttpsResponse</i>指针将保持为空，并且<i>状态将</i>不再等于<i>IOT_HTTPS_OK</i> 。 结果， <i>如果</i>和...更广泛，我们将属于那个分支！ 贬低您自己的后果是您自己知道的。 <br><br> 好吧 这是一个华丽的例子。 现在，我提请您注意一个非常简单且可以理解的潜在取消引用： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PKI_mbedTLSSignatureToPkcs11Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxSignaturePKCS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxMbedSignature )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * pxNextLength; <span class="hljs-comment"><span class="hljs-comment">/* The 4th byte contains the length of the R component */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ucSigComponentLength = pxMbedSignature[ <span class="hljs-number"><span class="hljs-number">3</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if( ( pxSignaturePKCS == NULL ) || ( pxMbedSignature == NULL ) ) { xReturn = FAILURE; } .... }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> V595 [CWE-476]在针对nullptr进行验证之前，已使用“ pxMbedSignature”指针。 检查行：52，54。iot_pki_utils.c 52 <br><br> 该函数获得两个指向<i>uint8_t的指针</i> 。 两个指针都检查为<i>NULL</i> ，这是一个好习惯-必须立即解决这种情况。 <br><br> 但是，这是不幸的事情：选中<i>pxMbedSignature时</i> ，它实际上已经在上面的一行中被取消引用。 塔达！ <br><br> 投机代码的另一个示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CK_RV </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vAppendSHA256AlgorithmIdentifierSequence</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x32ByteHashedMessage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x51ByteHashOidBuffer )</span></span></span><span class="hljs-function"> </span></span>{ CK_RV xResult = CKR_OK; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> xOidSequence[] = pkcs11STUFF_APPENDED_TO_RSA_SIG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( x32ByteHashedMessage == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) || ( x51ByteHashOidBuffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) { xResult = CKR_ARGUMENTS_BAD; } <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( x51ByteHashOidBuffer, xOidSequence, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( &amp;x51ByteHashOidBuffer[ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ], x32ByteHashedMessage, <span class="hljs-number"><span class="hljs-number">32</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xResult; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V1004 [CWE-628]在针对nullptr对其进行验证后，不安全地使用了x51ByteHashOidBuffer指针。 检查行：275、280。iot_pkcs11.c 280 </li><li>  V1004 [CWE-628]在针对nullptr进行验证之后，不安全地使用了x32ByteHashedMessage指针。 检查行：275、281。iot_pkcs11.c 281 </li></ul><br> 分析器警告说，在测试了<i>NULL</i>之后，不能安全地使用作为指针的函数参数。 实际上，已经检查了参数，但是如果其中任何一个结果为<i>NULL</i> ，则除了写入<i>xResult</i>之外，不执行任何操作。 这段代码似乎在说：“是的，这意味着论点证明是不好的。 我们现在将其记录下来，在您继续的同时，继续。” <br><br> 底线： <i>NULL</i>将传递给<i>memcpy</i> 。 这能带来什么？ 值将复制到哪里以及哪些值被复制？ 实际上，对此进行猜测是不值得的，因为 该标准<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">明确指出</a> ，这样的调用会导致未定义的行为（请参见第1段）。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/7d6/856/cf77d6856666f6a1529a1744832bd5bf.png" alt="图2"></div><br><br> 分析器报告仍然包含我在Amazon FreeRTOS中发现的带有指针的不正确操作的示例，但是我认为给出的示例已经足以向您展示PVS-Studio检测此类错误的功能。 考虑一些新事物。 <br><br><h3>  TRUE！= 1 </h3><br> 我发现的几种错误与一种模式有关，但不幸的是，这种错误经常被忘记。 <br><br> 事实是， <i>布尔</i>类型（来自C ++）不同于<i>布尔</i>类型（通常用于C语言）。 第一个只能包含<i>true</i>或<i>false</i> 。 第二个是某种整数类型（ <i>int</i> ， <i>long</i>等）的typedef。 对他来说，“ false”是值<i>0</i> ，“ true”是除零以外的任何值。 <br><br> 由于C中没有内置的布尔类型，为方便起见定义了以下常量： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FALSE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRUE 1</span></span></code> </pre> <br> 现在考虑一个示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mbedtls_hardware_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* output, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* olen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lStatus = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; HCRYPTPROV hProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Unferenced parameter. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)data; <span class="hljs-comment"><span class="hljs-comment">/* * This is port-specific for the Windows simulator, * so just use Crypto API. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptAcquireContextA( &amp;hProv, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptGenRandom(hProv, len, output)) { lStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; *olen = len; } CryptReleaseContext(hProv, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lStatus; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V676 [CWE-253]比较BOOL类型的变量和TRUE是不正确的。  aws_entropy_hardware_poll.c 48 </li><li>  V676 [CWE-253]比较BOOL类型的变量和TRUE是不正确的。 正确的表达式是：“ FALSE！= CryptGenRandom（hProv，len，输出）”。  aws_entropy_hardware_poll.c 51 </li></ul><br> 发现错误？ 它是:)函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>CryptAcquireContextA</i></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>CryptGenRandom</i></a>是<i>wincrypt.h</i>标头中的标准函数。 如果成功，它们将返回非零值。 我强调- <i>非零</i> 。 因此，从理论上讲，它可以是除零以外的任何值： <i>1、314、42、420</i> 。 <br><br> 显然，从示例中编写函数的程序员没有考虑过它，因此，将获得的值与1进行比较。 <br><br> 满足条件<i>TRUE == CryptGenRandom（....）的</i>概率是多少？ 很难说。 也许<i>CryptGenRandom</i>比其他值更经常返回一个单位，也许总是只返回一个。 我们不能肯定地知道：这个加密功能的实现对凡人程序员是隐藏的：) <br><br> 重要的是要记住，这样的比较有潜在的危险。 而不是： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == GetBOOL())</code> </pre> <br> 使用更安全的选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FALSE != GetBOOL())</code> </pre> <br><h3> 优化问题 </h3><br> 一些分析器警告已与运行缓慢的构造相关联。 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> V817查找'/'字符而不是字符串更有效。  iot_demo_https_common.c 205 <br><br> 简要清楚地说，不是吗？ 此处的<i>strstr</i>函数仅用于搜索一个字符，该字符作为字符串传递给参数（用双引号引起来）。 <br><br> 可以通过将<i>strstr</i>替换为<i>strchr</i>来优化该位置： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); .... }</code> </pre> <br> 然后搜索将更快一些。 有点琐事，但很好。 <br><br> 这样的优化当然是好的，而且分析仪发现了另一个可以更明显地优化的地方： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vRunOTAUpdateDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; ; ) { .... xConnectInfo.cleanSession = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xConnectInfo.clientIdentifierLength = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(clientcredentialIOT_THING_NAME); xConnectInfo.pClientIdentifier = clientcredentialIOT_THING_NAME; .... } }</code> </pre> <br>  <b>警告PVS-Studio：</b> V814性能下降。 在循环体内多次调用了“ strlen”函数。  aws_iot_ota_update_demo.c 235 <br><br> 嗯……在循环内部，每次迭代都会调用<i>strlen</i> ，每次都计算同一行的长度。 不是最有效的操作:) <br><br> 让我们看看<i>clientcredentialIOT_THING_NAME</i>的定义： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * @brief Host name. * * @todo Set this to the unique name of your IoT Thing. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> clientcredentialIOT_THING_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span></span></code> </pre> <br> 提示用户在此处输入其设备的名称。 默认情况下，它是空的，在这种情况下，一切都很好。 但是，如果用户想要在其中输入一些长而优美的名称怎么办？ 例如，我想称自己的想法为“ <i>热情而精致的BarBarista-N061E终极咖啡机</i> ”。 您能想象如果我那台漂亮的咖啡机开始工作慢一点后会感到惊讶吗？ 乱！ <br><br> 要解决该错误，应从循环体中取出<i>strlen</i> 。 毕竟，程序运行时设备的名称不会更改。 恩，这是C ++的<i>constexpr</i> ... <br><br> 好吧，好吧，我承认：在这里我有点胖了。 正如我的同事安德烈·卡波夫（Andrei Karpov）指出的那样，现代编译器知道<i>strlen是</i>什么<i>，</i>并且他本人观察到，如果他们知道字符串的长度不能改变，他们将如何简单地在二进制代码中使用常量。 因此，在发布版本的构建模式中，很有可能会使用以前计算出的值，而不是实际计算字符串长度，而是很有可能。 但是，这并不总是可行的，因此编写这样的代码不是一个好习惯。 <br><br><h2> 关于MISRA的几句话 </h2><br>  PVS-Studio分析仪具有大量规则，可让您检查代码是否符合MISRA C和MISRA C ++标准。 这些标准是什么？ <br><br>  MISRA是高响应嵌入式系统的编码标准。 它包含一组用于编写代码和设置开发过程的严格规则和准则。 这些规则中有很多，它们不仅旨在消除严重错误，而且还针对各种“代码味道”，以及编写最易懂和易读的代码。 <br><br> 因此，遵循MISRA标准不仅有助于避免错误和漏洞，而且还可以显着-显着！  -降低它们在现有代码中出现的可能性。 <br><br>  MISRA用于航空航天，医疗，汽车和军事行业-人们的生活取决于嵌入式软件的质量。 <br><br> 显然，Amazon FreeRTOS开发人员知道此标准，并且在大多数情况下都遵循它。 没错：如果您要为嵌入式系统编写基础广泛的OS，则必须考虑安全性。 <br><br> 但是，我发现很多违反MISRA标准的行为。 在这里，我将不提供“不使用并集”或“一个函数在主体末端仅应有一个收益”之类的规则示例-不幸的是，它们与大多数MISRA规则一样并不引人注目。 我最好举几个例子，说明可能会导致严重后果的违规行为。 <br><br> 让我们从宏开始： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FreeRTOS_ms_to_tick(ms) ( ( ms * configTICK_RATE_HZ + 500 ) / 1000 )</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOCKETS_htonl( ulIn ) ( ( uint32_t ) \ ( ( ( ulIn &amp; 0xFF ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24 ) | ( ( ulIn &amp; 0xFF00 ) &lt;&lt; 8 ) \ | ( ( ulIn &amp; 0xFF0000 ) &gt;&gt; 8 ) | ( ( ulIn &amp; 0xFF000000 ) &gt;&gt; 24 ) ) )</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEFT_ROTATE( x, c ) ( ( x </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; c ) | ( x &gt;&gt; ( 32 - c ) ) )</span></span></span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V2546 [MISRA C 20.7]宏及其参数应放在括号中。 考虑检查“ FreeRTOS_ms_to_tick”宏的“ ms”参数。  FreeRTOS_IP.h 201 </li><li>  V2546 [MISRA C 20.7]宏及其参数应放在括号中。 考虑检查“ SOCKETS_htonl”宏的“ ulIn”参数。  iot_secure_sockets.h 512 </li><li>  V2546 [MISRA C 20.7]宏及其参数应放在括号中。 考虑检查“ LEFT_ROTATE”宏的参数“ x”，“ c”。  iot_device_metrics.c 90 </li></ul><br> 是的，这正是您的想法。 这些宏的参数未括在方括号中。 如果有人不小心写了类似 <br><br><pre> <code class="cpp hljs">val = LEFT_ROTATE(A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span>, B);</code> </pre> <br> 那么这样的“调用”宏将在以下位置打开： <br><br><pre> <code class="cpp hljs">val = ( ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; B ) | ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; ( <span class="hljs-number"><span class="hljs-number">32</span></span> - B ) ) );</code> </pre> <br> 还记得运营的重点吗？ 首先，仅在按位“或”之后才执行按位移位。 因此，将违反程序的逻辑。 一个简单的例子：如果将表达式“ <i>x + y</i> ”传递给<i>FreeRTOS_ms_to_tick</i>宏会怎样？  MISRA的主要目标之一是防止此类情况的发生。 <br><br> 有人可能会反对：“如果您有对此一无所知的程序员，那么没有任何标准可以拯救您！”我也不同意。 程序员也是人，无论一个人有多经验，他也会在工作结束时感到疲倦并犯错。 这是MISRA强烈建议使用自动分析工具来验证项目是否符合标准的原因之一。 <br><br> 我转向Amazon FreeRTOS的开发人员：PVS-Studio发现了另外12个不安全的宏，因此您在使用它们时要格外小心:) <br><br> 另一个有趣的MISRA违规行为： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Callback for an asynchronous request to notify * that the response is complete. * * @param[in] 0pPrivData - User private data configured * with the HTTPS Client library request configuration. * @param[in] respHandle - Identifier for the current response finished. * @param[in] rc - Return code from the HTTPS Client Library * signaling a possible error. * @param[in] status - The HTTP response status. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _responseCompleteCallback(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pPrivData, IotHttpsResponseHandle_t respHandle, IotHttpsReturnCode_t rc, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> status) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* pUploadSuccess = (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>*)pPrivData; <span class="hljs-comment"><span class="hljs-comment">/* When the remote server response with 200 OK, the file was successfully uploaded. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == IOT_HTTPS_STATUS_OK) { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Post to the semaphore that the upload is finished. */</span></span> IotSemaphore_Post(&amp;(_uploadFinishedSem)); }</code> </pre> <br> 您可以自己找到错误吗？ <br><br>  <b>PVS-Studio警告：</b> V2537 [MISRA C 2.7]功能中不应包含未使用的参数。 考虑检查参数：“ rc”。  iot_demo_https_s3_upload_async.c 234 <br><br> 仔细看看： <i>rc</i>参数未在函数主体中的任何位置使用。 此外，在函数注释中明确指出该参数是另一个函数的返回码，并且它可以表示错误。 那么为什么不以任何方式处理此参数？ 显然这里有问题。 <br><br> 但是，即使没有这些注释，未使用的参数也经常表示程序逻辑已损坏。 否则，为什么在功能签名中需要它们？ <br><br> 在这里，我给出了一个非常适合本文中的示例的小函数。 除了她，我还发现了10个未使用的参数。 它们中的许多都用于较大的功能，而找到它们并不是最容易的事情。 <br><br> 怀疑之前没有找到它们。 确实，编译器可以轻松检测到这种情况。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/6c7/bb9/b806c7bb94c335ce2712e9b46cffc560.png" alt="图1"></div><br><br><h2> 结论 </h2><br> 这些并不是分析仪发现的所有问题区域，但是文章已经很大了。 我希望借此，Amazon FreeRTOS开发人员将能够解决一些缺陷，甚至可能希望自己<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试PVS-Studio</a> 。 这样，就可以更彻底地研究警告，并且确实，使用便捷的界面比查看文本报告要容易得多。 <br><br> 感谢您阅读我们的文章！ 下期再见：D <br><br>  PS恰好在10月31日发表了这篇文章。 因此，祝大家万圣节快乐！ <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br> 如果您想与讲英语的读者分享这篇文章，请使用翻译链接：George Gribkov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应嵌入式开发人员的要求：在Amazon FreeRTOS中检测错误</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473972/">https://habr.com/ru/post/zh-CN473972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473956/index.html">来自毒贩电话公司的秘密信息</a></li>
<li><a href="../zh-CN473958/index.html">来自NICT的日本人推出了工作带宽为1 Pbit / s的光纤集群</a></li>
<li><a href="../zh-CN473960/index.html">内容本地化策略</a></li>
<li><a href="../zh-CN473962/index.html">黑暗模式现在无处不在。 这样有用吗？ （在后期调查之后）</a></li>
<li><a href="../zh-CN473966/index.html">应嵌入式开发人员的要求：在Amazon FreeRTOS中检测错误</a></li>
<li><a href="../zh-CN473974/index.html">Intercom'19-Voximplant的通信自动化会议将于11月14日举行</a></li>
<li><a href="../zh-CN473976/index.html">AWS Elasticsearch：基本缺陷产品</a></li>
<li><a href="../zh-CN473978/index.html">这样的痛苦，这样的痛苦，收银机服务2：0</a></li>
<li><a href="../zh-CN473980/index.html">技术与现实世界：4家正在改变室内设计未来的初创企业</a></li>
<li><a href="../zh-CN473982/index.html">NB-IoT：它如何工作？ 第3部分：SCEF-操作员服务的单个访问窗口</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>