<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💵 🕛 ⌛️ Warum Physiker Fortran immer noch benutzen 👴🏻 💃🏼 💅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich weiß nicht, wie die Programmiersprache im Jahr 2000 aussehen wird, aber ich weiß, dass sie FORTRAN heißen wird. 
 - Charles Anthony Richard Hoar, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Physiker Fortran immer noch benutzen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400523/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich weiß nicht, wie die Programmiersprache im Jahr 2000 aussehen wird, aber ich weiß, dass sie FORTRAN heißen wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Anthony Richard Hoar, ca. </font><font style="vertical-align: inherit;">1982</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Branche wird Fortran heute nur noch selten verwendet - in einer der Listen der populären Sprachen belegte es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den 28. Platz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fortran ist jedoch nach wie vor die Hauptsprache für groß angelegte Simulationen physikalischer Systeme - beispielsweise für astrophysikalische </font><font style="vertical-align: inherit;">Modelle </font><font style="vertical-align: inherit;">von Sternen und Galaxien (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), großräumige Molekulardynamik, elektronische Strukturzählcodes ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIESTA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), Klimamodelle usw. Auf dem Gebiet des Hochleistungsrechnens, von dem eine Teilmenge numerische Simulationen in großem Maßstab sind, werden heute nur zwei Sprachen verwendet - C / C ++ und „modernes Fortran“ (Fortran 90/95/03/08). Beliebte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">offene MPI-</font></a><font style="vertical-align: inherit;"> Bibliotheken</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für diese beiden Sprachen wurden Tools zur Code-Parallelisierung entwickelt. Wenn Sie schnellen Code benötigen, der auf mehreren Prozessoren ausgeführt wird, haben Sie im Allgemeinen nur zwei Optionen. Im modernen Fortran gibt es eine Funktion wie " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coarray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", mit der direkt mit der Sprache in paralleler Programmierung gearbeitet werden kann. Coarray erschien in der Fortran 95-Erweiterung und wurde später in Fortran 2008 aufgenommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die aktive Nutzung von Fortran durch Physiker verwirrt häufig Informatiker und andere Personen, die nicht mit diesem Gebiet verwandt sind und Fortran für einen historischen Anachronismus halten.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte erklären, warum Fortran immer noch nützlich ist. Ich ermutige Studenten, die Physik studieren, nicht, Fortran zu unterrichten - da die meisten von ihnen forschen werden, sollten sie C / C ++ lernen (oder bei Matlab / Octave / Python anhalten). Ich möchte erklären, warum Fortran immer noch verwendet wird, und beweisen, dass dies nicht nur darauf zurückzuführen ist, dass Physiker „hinter der Zeit“ sind (obwohl dies manchmal so ist - letztes Jahr habe ich einen Physikstudenten gesehen, der mit Code gearbeitet hat Fortran 77, während weder er noch sein Manager etwas über Fortran 90 hörten). Informatiker sollten Fortrans Dominanz im numerischen Rechnen als Herausforderung betrachten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor ich mich mit dem Thema befasse, möchte ich die Geschichte diskutieren, denn wenn Leute das Wort "Fortran" hören, stellen sie sich sofort Lochkarten und Code mit nummerierten Zeilen vor. Die erste Fortran-Spezifikation wurde 1954 geschrieben. Das frühe Fortran (damals wurde sein Name in Großbuchstaben FORTRAN geschrieben) war nach modernen Maßstäben eine höllische Sprache, aber es war ein unglaublicher Fortschritt gegenüber früheren Assembler-Programmen. FORTRAN wurde oft mit Lochkarten programmiert, wie Professor Miriam Forman von der Stony Brook University ohne Vergnügen erinnert. Fortran hatte viele Versionen, von denen die bekanntesten die Standards 66, 77, 90, 95, 03 und 08 sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird oft gesagt, dass Fortran wegen seiner Geschwindigkeit immer noch verwendet wird. Aber ist er der Schnellste? Bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarksgame.alioth.debian.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich von C und Fortran</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in mehreren Tests unter vielen Sprachen. </font><font style="vertical-align: inherit;">In den meisten Fällen sind Fortran und C / C ++ die schnellsten. </font><font style="vertical-align: inherit;">Lieblings-Python-Programmierer bleiben oft 100-mal in der Geschwindigkeit zurück, aber dies ist in der Reihenfolge der Dinge für den interpretierten Code. </font><font style="vertical-align: inherit;">Python eignet sich nicht für komplexe numerische Berechnungen, ist aber für andere gut geeignet. </font><font style="vertical-align: inherit;">Interessanterweise übertrifft C / C ++ Fortran in allen bis auf zwei Tests, obwohl sie sich im Allgemeinen in den Ergebnissen kaum unterscheiden. </font><font style="vertical-align: inherit;">Die Tests, bei denen Fortran gewinnt, die "physikalischsten", sind die Simulation eines Systems von n Körpern und die Berechnung des Spektrums. </font><font style="vertical-align: inherit;">Die Ergebnisse hängen von der Anzahl der Prozessorkerne ab. Beispielsweise bleibt Fortran auf dem Quad-Core hinter C / C ++ zurück. </font><font style="vertical-align: inherit;">Die Tests, bei denen Fortran weit hinter C / C ++ zurückbleibt, lesen und schreiben die meiste Zeit Daten, und in dieser Hinsicht ist Fortrans Langsamkeit bekannt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ ist also so schnell wie Fortran und manchmal etwas schneller. </font><font style="vertical-align: inherit;">Wir sind interessiert an: "Warum raten Physikprofessoren ihren Studenten weiterhin, Fortran anstelle von C / C ++ zu verwenden?"</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortran hat Legacy-Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank der langen Geschichte von Fortran ist es nicht verwunderlich, dass Berge von Physikcode darauf geschrieben sind. </font><font style="vertical-align: inherit;">Physiker versuchen, die Programmierzeit zu minimieren. Wenn sie also früheren Code finden, werden sie ihn verwenden. </font><font style="vertical-align: inherit;">Selbst wenn der alte Code nicht lesbar, schlecht dokumentiert und nicht der effizienteste ist, wird der alte bewährte Code eher verwendet als ein neuer. </font><font style="vertical-align: inherit;">Die Aufgabe der Physiker ist es nicht, Code zu schreiben, sondern die Natur der Realität zu verstehen. </font><font style="vertical-align: inherit;">Die Professoren haben immer den geerbten Code zur Hand (oft haben sie diesen Code vor Jahrzehnten geschrieben) und geben ihn an ihre Studenten weiter. </font><font style="vertical-align: inherit;">Dies spart ihnen Zeit und beseitigt Unsicherheiten beim Fehlerkorrekturprozess.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physikstudenten lernen Fortran einfacher als C / C ++</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, Fortran ist leichter zu lernen als C / C ++. Fortran 90 und C sind sich sehr ähnlich, aber Fortran ist einfacher zu schreiben. C ist eine relativ primitive Sprache, daher beschäftigen sich Physiker, die sich für C / C ++ entscheiden, mit objektorientierter Programmierung. OOP kann nützlich sein, insbesondere in großen Softwareprojekten, aber studieren Sie es viel länger. Sie müssen Abstraktionen wie Klassen und Vererbung studieren. Das OOP-Paradigma unterscheidet sich stark von dem von Fortran verwendeten prozeduralen. Fortran basiert auf einem einfachen prozeduralen Paradigma, das näher an dem liegt, was unter der Haube eines Computers geschieht. Wenn Sie Code optimieren / vektorisieren, um die Geschwindigkeit zu erhöhen, ist es einfacher, mit dem prozeduralen Paradigma zu arbeiten. Physiker verstehen normalerweise, wie Computer funktionieren, und denken in physischen Prozessen, z. B. beim Übertragen von Daten von der Festplatte zum RAM und vom RAM zum Prozessor-Cache.Sie unterscheiden sich von Mathematikern, die es vorziehen, in abstrakten Funktionen und Logik zu denken. Auch dieses Denken unterscheidet sich von objektorientiert. Die Optimierung von OOP-Code ist aus meiner Sicht komplizierter als prozedural. Objekte sind sehr sperrige Strukturen im Vergleich zu den von Physikern bevorzugten Datenstrukturen: Arrays.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leichtigkeit Eins: Fortran Array Arbeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arrays oder, wie Physiker sie nennen, Matrizen bilden das Herzstück aller physischen Berechnungen. </font><font style="vertical-align: inherit;">In Fortran 90+ finden Sie viele Möglichkeiten, mit ihnen zu arbeiten, ähnlich wie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Matlab / Octave. </font><font style="vertical-align: inherit;">Arrays können kopiert, mit einem Skalar multipliziert und auf sehr intuitive Weise untereinander multipliziert werden:</font></font><br>
 <br>
<pre><code class="hljs lisp">A = B<font></font>
A = <span class="hljs-number"><span class="hljs-number">3.24</span></span>*B<font></font>
C = A*B<font></font>
B = exp(<span class="hljs-name"><span class="hljs-name">A</span></span>)<font></font>
norm = sqrt(<span class="hljs-name"><span class="hljs-name">sum</span></span>(<span class="hljs-name"><span class="hljs-name">A**2</span></span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind A, B, C Arrays mit einer bestimmten Dimension (z. B. 10 x 10 x 10). C = A * B gibt uns die elementweise Multiplikation von Matrizen, wenn A und B gleich groß sind. Für die Matrixmultiplikation wird C = matmul (A, B) verwendet. Fast alle internen Funktionen von Fortran (Sin (), Exp (), Abs (), Floor () usw.) verwenden Arrays als Argumente, was zu einfachem und sauberem Code führt. Es gibt einfach keinen ähnlichen Code in C / C ++. In einer grundlegenden C / C ++ - Implementierung erfordert das einfache Kopieren eines Arrays das Ausführen von for-Schleifen für alle Elemente oder das Aufrufen einer Bibliotheksfunktion. Wenn Sie in C ein Array mit der falschen Bibliotheksfunktion eingeben, tritt ein Fehler auf. Die Verwendung von Bibliotheken anstelle von internen Funktionen bedeutet, dass der resultierende Code nicht sauber und portabel oder leicht zu erlernen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Fortran funktioniert der Zugriff auf Array-Elemente über die einfache Syntax A [x, y, z], wenn Sie in C / C ++ A [x] [y] [z] schreiben müssen. </font><font style="vertical-align: inherit;">Elemente von Arrays beginnen mit 1, was dem Verständnis der Physiker für Matrizen entspricht, und in C / C ++ - Arrays beginnt die Nummerierung bei Null. </font><font style="vertical-align: inherit;">Hier sind einige weitere Funktionen für die Arbeit mit Arrays in Fortran.</font></font><br>
 <br>
<pre><code class="hljs lisp">A = (<span class="hljs-name"><span class="hljs-name">/</span></span> i , i = <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> /)<font></font>
B = A(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>)<font></font>
C(<span class="hljs-number"><span class="hljs-number">10</span></span>:) = B</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst wird der Vektor A durch eine implizite do-Schleife erzeugt, die auch als Array-Konstruktor bezeichnet wird. </font><font style="vertical-align: inherit;">Dann wird in einem Schritt von 10 ein Vektor B erzeugt, der aus jedem 10. Element von A besteht. Schließlich wird das Array B ausgehend vom 10. Element in das Array C kopiert. </font><font style="vertical-align: inherit;">Fortran unterstützt das Deklarieren von Arrays mit Null oder negativen Indizes:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, dimension(<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) :: myArray</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein negativer Index sieht zunächst albern aus, aber ich habe von ihrer Nützlichkeit gehört - stellen Sie sich zum Beispiel vor, dass dies ein zusätzlicher Bereich für die Veröffentlichung von Klarstellungen ist. </font><font style="vertical-align: inherit;">Fortran unterstützt auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektorindizes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Beispielsweise können Sie die Elemente 1,5 und 7 von einem Array A der Dimension N x 1 in ein Array B der Dimension 3 x 1 übertragen:</font></font><br>
 <br>
<pre><code class="hljs lisp">subscripts = (<span class="hljs-name"><span class="hljs-name">/</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> /)<font></font>
B = A(<span class="hljs-name"><span class="hljs-name">subscripts</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran unterstützt </font><font style="vertical-align: inherit;">Array- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in allen internen Funktionen. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise den Logarithmus aller Matrixelemente größer als Null berechnen müssen, verwenden wir:</font></font><br>
 <br>
<pre><code class="hljs lisp">log_of_A = log(<span class="hljs-name"><span class="hljs-name">A</span></span>, mask= A .gt. <span class="hljs-number"><span class="hljs-number">0</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder wir können alle negativen Elemente des Arrays in einer Zeile aufheben:</font></font><br>
 <br>
<pre><code class="hljs lisp">where(<span class="hljs-name"><span class="hljs-name">my_array</span></span> .lt. <span class="hljs-number"><span class="hljs-number">0.0</span></span>) my_array = <span class="hljs-number"><span class="hljs-number">0.0</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran macht es einfach, Arrays dynamisch zuzuweisen und freizugeben. </font><font style="vertical-align: inherit;">So platzieren Sie beispielsweise ein zweidimensionales Array:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span>, dimension(:,:), allocatable :: name_of_array<font></font>
allocate(name_of_array(xdim, ydim))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C / C ++ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert dies den folgenden Eintrag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;
<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(nrows * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *));<font></font>
 <font></font>
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
     <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ncolumns * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So geben Sie ein Array in Fortran frei</font></font><br>
 <br>
<pre><code class="hljs lisp">deallocate(<span class="hljs-name"><span class="hljs-name">name_of_array</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C / C ++ dafür</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
    <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]);<font></font>
}<font></font>
<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>);</code></pre><br>
<h2> :        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Sprachen wie C / C ++ werden alle Variablen als Wert übergeben, mit Ausnahme von Arrays, die als Referenz übergeben werden. In vielen Fällen ist es jedoch sinnvoller, ein Array als Wert zu übergeben. Lassen Sie die Daten beispielsweise aus Positionen von 100 Molekülen zu verschiedenen Zeitpunkten bestehen. Wir müssen die Bewegung eines Moleküls analysieren. Wir nehmen einen Teil des Arrays (Subarray), der den Koordinaten der Atome in diesem Molekül entspricht, und übergeben ihn an die Funktion. Darin werden wir uns mit einer komplexen Analyse des übertragenen Subarrays befassen. Wenn wir es als Referenz übergeben würden, würden sich die übertragenen Daten nicht in einer Reihe im Speicher befinden. Aufgrund der Art des Speicherzugriffs wäre die Arbeit mit einem solchen Array langsam. Wenn wir es als Wert übergeben, erstellen wir im Speicher ein neues Array, das in einer Reihe angeordnet ist. Zur Freude der Physiker übernimmt der Compiler die ganze schmutzige Arbeit der Speicheroptimierung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Fortran werden Variablen normalerweise als Referenz und nicht als Wert übergeben. </font><font style="vertical-align: inherit;">Unter der Haube optimiert der Fortran-Compiler automatisch seine Übertragung, um die Effizienz zu steigern. </font><font style="vertical-align: inherit;">Aus Sicht des Professors auf dem Gebiet der Optimierung der Speichernutzung sollte dem Compiler mehr vertraut werden als dem Studenten! </font><font style="vertical-align: inherit;">Als Ergebnis verwenden Physiker selten Zeiger, obwohl Fortran-90 + </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige weitere Beispiele für die Unterschiede zwischen Fortran und C.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran bietet verschiedene Optionen zum Verwalten des Compilers bei der Fehlerbehebung und Optimierung. </font><font style="vertical-align: inherit;">Fehler im Code können in der Kompilierungsphase und nicht während der Ausführung abgefangen werden. </font><font style="vertical-align: inherit;">Beispielsweise kann jede Variable als Parameter deklariert werden, dh als Konstante.</font></font><br>
<br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, parameter :: hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn sich der Parameter im Code ändert, gibt der Compiler einen Fehler zurück. </font><font style="vertical-align: inherit;">In C heißt das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const</font></font></a><br>
<br>
<pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass const real sich von simple real unterscheidet. Wenn eine Funktion, die real akzeptiert, const real erhält, wird ein Fehler zurückgegeben. Es ist leicht vorstellbar, wie dies zu Interoperabilitätsproblemen im Code führen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran hat auch eine Absichtsspezifikation, die dem Compiler mitteilt, ob das an die Funktion übergebene Argument eine Eingabe, Ausgabe oder sowohl ein Eingabe- als auch ein Ausgabeparameter ist. Dies hilft dem Compiler, den Code zu optimieren und seine Lesbarkeit und Zuverlässigkeit zu erhöhen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran verfügt über weitere Funktionen, die bei unterschiedlichen Frequenzen verwendet werden. </font><font style="vertical-align: inherit;">Zum Beispiel kann Fortran 95 Funktionen mit dem reinen Modifikator deklarieren. </font><font style="vertical-align: inherit;">Eine solche Funktion hat keine Nebenwirkungen - sie ändert nur ihre Argumente und keine globalen Variablen. </font><font style="vertical-align: inherit;">Ein Sonderfall einer solchen Funktion ist die Elementfunktion, die Skalare akzeptiert und zurückgibt. </font><font style="vertical-align: inherit;">Es wird verwendet, um Array-Elemente zu verarbeiten. </font><font style="vertical-align: inherit;">Die Information, dass die Funktion rein oder elementar ist, ermöglicht es dem Compiler, zusätzliche Optimierungen durchzuführen, insbesondere beim Parallelisieren von Code.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was erwartet Sie in Zukunft?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In wissenschaftlichen Berechnungen bleibt Fortran die Hauptsprache und wird in naher Zukunft nicht verschwinden. </font><font style="vertical-align: inherit;">In der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umfrage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter den Besuchern der Supercomputing Convention-Konferenz 2014, die diese Sprache verwenden, gaben 100% an, dass sie sie in den nächsten 5 Jahren verwenden werden. Aus der Umfrage geht auch hervor, dass 90% eine Mischung aus Fortran und C verwendeten. In Erwartung einer zunehmenden Vermischung dieser Sprachen enthalten die Entwickler der Fortran 2015-Spezifikation mehr Funktionen für die Code-Interoperabilität. Fortran-Code wird zunehmend aus Python-Code aufgerufen. Informatiker, die die Verwendung von Fortran kritisieren, verstehen nicht, dass diese Sprache eindeutig für das angepasst bleibt, wonach sie benannt wurde - FOrmula-ÜBERSETZUNG, Übersetzung von Formeln, dh die Umwandlung physikalischer Formeln in Code. Vielen von ihnen ist nicht bewusst, dass sich die Sprache weiterentwickelt und ständig neue Funktionen enthält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen des modernen Fortran 90+ alt ist dasselbe wie das Aufrufen des alten C ++, da C 1973 entwickelt wurde. Andererseits ist sogar der neueste Fortran 2008-Standard abwärtskompatibel mit Fortran 77 und dem größten Teil von Fortran 66. Daher ist die Entwicklung der Sprache mit gewissen Schwierigkeiten verbunden. </font><font style="vertical-align: inherit;">Kürzlich haben Forscher am MIT beschlossen, diese Schwierigkeiten zu überwinden, indem sie eine Sprache für HPC namens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Julia entwickelt haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die erstmals 2012 veröffentlicht wurde. </font><font style="vertical-align: inherit;">Ob Julia den Platz von Fortran einnimmt, bleibt abzuwarten. </font><font style="vertical-align: inherit;">Auf jeden Fall vermute ich, dass dies sehr lange dauern wird.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de400523/">https://habr.com/ru/post/de400523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de400511/index.html">Über die moderne Methode zur Lagerung abgebrannter Brennelemente</a></li>
<li><a href="../de400513/index.html">Gödels Unvollständigkeitssatz in 20 Minuten</a></li>
<li><a href="../de400515/index.html">Blockchainer: Blockchain-Vorteile für diejenigen, die nicht für Kryptowährungen geeignet sind</a></li>
<li><a href="../de400519/index.html">Modularer 3D-Start 3D-Drucker als Quelle von Interesse für eine 3D-Katze</a></li>
<li><a href="../de400521/index.html">Apple hat den Fehler behoben und Consumer Reports falsche Testmethoden vorgeworfen</a></li>
<li><a href="../de400525/index.html">Entwicklung eines Systems zur mnemonischen Speicherung von Zahlen</a></li>
<li><a href="../de400527/index.html">Resampling II. Vergleich der Funktionsweise von digitalen und analogen Filtern höherer Ordnung im Schallweg und Beantwortung von Fragen</a></li>
<li><a href="../de400529/index.html">OP-Ausstattung zur Sehkorrektur</a></li>
<li><a href="../de400531/index.html">Das State Duma Committee genehmigte einen Gesetzentwurf zur Regulierung audiovisueller Dienste</a></li>
<li><a href="../de400533/index.html">Das Hauptparadox des Bewusstseins. Warum das Kopieren des Gehirns oder der Persönlichkeit keinen Sinn macht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>