<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíµ üïõ ‚åõÔ∏è Warum Physiker Fortran immer noch benutzen üë¥üèª üíÉüèº üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wei√ü nicht, wie die Programmiersprache im Jahr 2000 aussehen wird, aber ich wei√ü, dass sie FORTRAN hei√üen wird. 
 - Charles Anthony Richard Hoar, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Physiker Fortran immer noch benutzen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400523/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü nicht, wie die Programmiersprache im Jahr 2000 aussehen wird, aber ich wei√ü, dass sie FORTRAN hei√üen wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Anthony Richard Hoar, ca. </font><font style="vertical-align: inherit;">1982</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Branche wird Fortran heute nur noch selten verwendet - in einer der Listen der popul√§ren Sprachen belegte es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den 28. Platz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fortran ist jedoch nach wie vor die Hauptsprache f√ºr gro√ü angelegte Simulationen physikalischer Systeme - beispielsweise f√ºr astrophysikalische </font><font style="vertical-align: inherit;">Modelle </font><font style="vertical-align: inherit;">von Sternen und Galaxien (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), gro√ür√§umige Molekulardynamik, elektronische Strukturz√§hlcodes ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIESTA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), Klimamodelle usw. Auf dem Gebiet des Hochleistungsrechnens, von dem eine Teilmenge numerische Simulationen in gro√üem Ma√üstab sind, werden heute nur zwei Sprachen verwendet - C / C ++ und ‚Äûmodernes Fortran‚Äú (Fortran 90/95/03/08). Beliebte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">offene MPI-</font></a><font style="vertical-align: inherit;"> Bibliotheken</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr diese beiden Sprachen wurden Tools zur Code-Parallelisierung entwickelt. Wenn Sie schnellen Code ben√∂tigen, der auf mehreren Prozessoren ausgef√ºhrt wird, haben Sie im Allgemeinen nur zwei Optionen. Im modernen Fortran gibt es eine Funktion wie " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coarray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", mit der direkt mit der Sprache in paralleler Programmierung gearbeitet werden kann. Coarray erschien in der Fortran 95-Erweiterung und wurde sp√§ter in Fortran 2008 aufgenommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die aktive Nutzung von Fortran durch Physiker verwirrt h√§ufig Informatiker und andere Personen, die nicht mit diesem Gebiet verwandt sind und Fortran f√ºr einen historischen Anachronismus halten.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte erkl√§ren, warum Fortran immer noch n√ºtzlich ist. Ich ermutige Studenten, die Physik studieren, nicht, Fortran zu unterrichten - da die meisten von ihnen forschen werden, sollten sie C / C ++ lernen (oder bei Matlab / Octave / Python anhalten). Ich m√∂chte erkl√§ren, warum Fortran immer noch verwendet wird, und beweisen, dass dies nicht nur darauf zur√ºckzuf√ºhren ist, dass Physiker ‚Äûhinter der Zeit‚Äú sind (obwohl dies manchmal so ist - letztes Jahr habe ich einen Physikstudenten gesehen, der mit Code gearbeitet hat Fortran 77, w√§hrend weder er noch sein Manager etwas √ºber Fortran 90 h√∂rten). Informatiker sollten Fortrans Dominanz im numerischen Rechnen als Herausforderung betrachten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor ich mich mit dem Thema befasse, m√∂chte ich die Geschichte diskutieren, denn wenn Leute das Wort "Fortran" h√∂ren, stellen sie sich sofort Lochkarten und Code mit nummerierten Zeilen vor. Die erste Fortran-Spezifikation wurde 1954 geschrieben. Das fr√ºhe Fortran (damals wurde sein Name in Gro√übuchstaben FORTRAN geschrieben) war nach modernen Ma√üst√§ben eine h√∂llische Sprache, aber es war ein unglaublicher Fortschritt gegen√ºber fr√ºheren Assembler-Programmen. FORTRAN wurde oft mit Lochkarten programmiert, wie Professor Miriam Forman von der Stony Brook University ohne Vergn√ºgen erinnert. Fortran hatte viele Versionen, von denen die bekanntesten die Standards 66, 77, 90, 95, 03 und 08 sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird oft gesagt, dass Fortran wegen seiner Geschwindigkeit immer noch verwendet wird. Aber ist er der Schnellste? Bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarksgame.alioth.debian.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich von C und Fortran</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in mehreren Tests unter vielen Sprachen. </font><font style="vertical-align: inherit;">In den meisten F√§llen sind Fortran und C / C ++ die schnellsten. </font><font style="vertical-align: inherit;">Lieblings-Python-Programmierer bleiben oft 100-mal in der Geschwindigkeit zur√ºck, aber dies ist in der Reihenfolge der Dinge f√ºr den interpretierten Code. </font><font style="vertical-align: inherit;">Python eignet sich nicht f√ºr komplexe numerische Berechnungen, ist aber f√ºr andere gut geeignet. </font><font style="vertical-align: inherit;">Interessanterweise √ºbertrifft C / C ++ Fortran in allen bis auf zwei Tests, obwohl sie sich im Allgemeinen in den Ergebnissen kaum unterscheiden. </font><font style="vertical-align: inherit;">Die Tests, bei denen Fortran gewinnt, die "physikalischsten", sind die Simulation eines Systems von n K√∂rpern und die Berechnung des Spektrums. </font><font style="vertical-align: inherit;">Die Ergebnisse h√§ngen von der Anzahl der Prozessorkerne ab. Beispielsweise bleibt Fortran auf dem Quad-Core hinter C / C ++ zur√ºck. </font><font style="vertical-align: inherit;">Die Tests, bei denen Fortran weit hinter C / C ++ zur√ºckbleibt, lesen und schreiben die meiste Zeit Daten, und in dieser Hinsicht ist Fortrans Langsamkeit bekannt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ ist also so schnell wie Fortran und manchmal etwas schneller. </font><font style="vertical-align: inherit;">Wir sind interessiert an: "Warum raten Physikprofessoren ihren Studenten weiterhin, Fortran anstelle von C / C ++ zu verwenden?"</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortran hat Legacy-Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank der langen Geschichte von Fortran ist es nicht verwunderlich, dass Berge von Physikcode darauf geschrieben sind. </font><font style="vertical-align: inherit;">Physiker versuchen, die Programmierzeit zu minimieren. Wenn sie also fr√ºheren Code finden, werden sie ihn verwenden. </font><font style="vertical-align: inherit;">Selbst wenn der alte Code nicht lesbar, schlecht dokumentiert und nicht der effizienteste ist, wird der alte bew√§hrte Code eher verwendet als ein neuer. </font><font style="vertical-align: inherit;">Die Aufgabe der Physiker ist es nicht, Code zu schreiben, sondern die Natur der Realit√§t zu verstehen. </font><font style="vertical-align: inherit;">Die Professoren haben immer den geerbten Code zur Hand (oft haben sie diesen Code vor Jahrzehnten geschrieben) und geben ihn an ihre Studenten weiter. </font><font style="vertical-align: inherit;">Dies spart ihnen Zeit und beseitigt Unsicherheiten beim Fehlerkorrekturprozess.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physikstudenten lernen Fortran einfacher als C / C ++</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, Fortran ist leichter zu lernen als C / C ++. Fortran 90 und C sind sich sehr √§hnlich, aber Fortran ist einfacher zu schreiben. C ist eine relativ primitive Sprache, daher besch√§ftigen sich Physiker, die sich f√ºr C / C ++ entscheiden, mit objektorientierter Programmierung. OOP kann n√ºtzlich sein, insbesondere in gro√üen Softwareprojekten, aber studieren Sie es viel l√§nger. Sie m√ºssen Abstraktionen wie Klassen und Vererbung studieren. Das OOP-Paradigma unterscheidet sich stark von dem von Fortran verwendeten prozeduralen. Fortran basiert auf einem einfachen prozeduralen Paradigma, das n√§her an dem liegt, was unter der Haube eines Computers geschieht. Wenn Sie Code optimieren / vektorisieren, um die Geschwindigkeit zu erh√∂hen, ist es einfacher, mit dem prozeduralen Paradigma zu arbeiten. Physiker verstehen normalerweise, wie Computer funktionieren, und denken in physischen Prozessen, z. B. beim √úbertragen von Daten von der Festplatte zum RAM und vom RAM zum Prozessor-Cache.Sie unterscheiden sich von Mathematikern, die es vorziehen, in abstrakten Funktionen und Logik zu denken. Auch dieses Denken unterscheidet sich von objektorientiert. Die Optimierung von OOP-Code ist aus meiner Sicht komplizierter als prozedural. Objekte sind sehr sperrige Strukturen im Vergleich zu den von Physikern bevorzugten Datenstrukturen: Arrays.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leichtigkeit Eins: Fortran Array Arbeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arrays oder, wie Physiker sie nennen, Matrizen bilden das Herzst√ºck aller physischen Berechnungen. </font><font style="vertical-align: inherit;">In Fortran 90+ finden Sie viele M√∂glichkeiten, mit ihnen zu arbeiten, √§hnlich wie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Matlab / Octave. </font><font style="vertical-align: inherit;">Arrays k√∂nnen kopiert, mit einem Skalar multipliziert und auf sehr intuitive Weise untereinander multipliziert werden:</font></font><br>
 <br>
<pre><code class="hljs lisp">A = B<font></font>
A = <span class="hljs-number"><span class="hljs-number">3.24</span></span>*B<font></font>
C = A*B<font></font>
B = exp(<span class="hljs-name"><span class="hljs-name">A</span></span>)<font></font>
norm = sqrt(<span class="hljs-name"><span class="hljs-name">sum</span></span>(<span class="hljs-name"><span class="hljs-name">A**2</span></span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind A, B, C Arrays mit einer bestimmten Dimension (z. B. 10 x 10 x 10). C = A * B gibt uns die elementweise Multiplikation von Matrizen, wenn A und B gleich gro√ü sind. F√ºr die Matrixmultiplikation wird C = matmul (A, B) verwendet. Fast alle internen Funktionen von Fortran (Sin (), Exp (), Abs (), Floor () usw.) verwenden Arrays als Argumente, was zu einfachem und sauberem Code f√ºhrt. Es gibt einfach keinen √§hnlichen Code in C / C ++. In einer grundlegenden C / C ++ - Implementierung erfordert das einfache Kopieren eines Arrays das Ausf√ºhren von for-Schleifen f√ºr alle Elemente oder das Aufrufen einer Bibliotheksfunktion. Wenn Sie in C ein Array mit der falschen Bibliotheksfunktion eingeben, tritt ein Fehler auf. Die Verwendung von Bibliotheken anstelle von internen Funktionen bedeutet, dass der resultierende Code nicht sauber und portabel oder leicht zu erlernen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Fortran funktioniert der Zugriff auf Array-Elemente √ºber die einfache Syntax A [x, y, z], wenn Sie in C / C ++ A [x] [y] [z] schreiben m√ºssen. </font><font style="vertical-align: inherit;">Elemente von Arrays beginnen mit 1, was dem Verst√§ndnis der Physiker f√ºr Matrizen entspricht, und in C / C ++ - Arrays beginnt die Nummerierung bei Null. </font><font style="vertical-align: inherit;">Hier sind einige weitere Funktionen f√ºr die Arbeit mit Arrays in Fortran.</font></font><br>
 <br>
<pre><code class="hljs lisp">A = (<span class="hljs-name"><span class="hljs-name">/</span></span> i , i = <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> /)<font></font>
B = A(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>)<font></font>
C(<span class="hljs-number"><span class="hljs-number">10</span></span>:) = B</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst wird der Vektor A durch eine implizite do-Schleife erzeugt, die auch als Array-Konstruktor bezeichnet wird. </font><font style="vertical-align: inherit;">Dann wird in einem Schritt von 10 ein Vektor B erzeugt, der aus jedem 10. Element von A besteht. Schlie√ülich wird das Array B ausgehend vom 10. Element in das Array C kopiert. </font><font style="vertical-align: inherit;">Fortran unterst√ºtzt das Deklarieren von Arrays mit Null oder negativen Indizes:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, dimension(<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) :: myArray</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein negativer Index sieht zun√§chst albern aus, aber ich habe von ihrer N√ºtzlichkeit geh√∂rt - stellen Sie sich zum Beispiel vor, dass dies ein zus√§tzlicher Bereich f√ºr die Ver√∂ffentlichung von Klarstellungen ist. </font><font style="vertical-align: inherit;">Fortran unterst√ºtzt auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektorindizes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Beispielsweise k√∂nnen Sie die Elemente 1,5 und 7 von einem Array A der Dimension N x 1 in ein Array B der Dimension 3 x 1 √ºbertragen:</font></font><br>
 <br>
<pre><code class="hljs lisp">subscripts = (<span class="hljs-name"><span class="hljs-name">/</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> /)<font></font>
B = A(<span class="hljs-name"><span class="hljs-name">subscripts</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran unterst√ºtzt </font><font style="vertical-align: inherit;">Array- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in allen internen Funktionen. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise den Logarithmus aller Matrixelemente gr√∂√üer als Null berechnen m√ºssen, verwenden wir:</font></font><br>
 <br>
<pre><code class="hljs lisp">log_of_A = log(<span class="hljs-name"><span class="hljs-name">A</span></span>, mask= A .gt. <span class="hljs-number"><span class="hljs-number">0</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder wir k√∂nnen alle negativen Elemente des Arrays in einer Zeile aufheben:</font></font><br>
 <br>
<pre><code class="hljs lisp">where(<span class="hljs-name"><span class="hljs-name">my_array</span></span> .lt. <span class="hljs-number"><span class="hljs-number">0.0</span></span>) my_array = <span class="hljs-number"><span class="hljs-number">0.0</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran macht es einfach, Arrays dynamisch zuzuweisen und freizugeben. </font><font style="vertical-align: inherit;">So platzieren Sie beispielsweise ein zweidimensionales Array:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span>, dimension(:,:), allocatable :: name_of_array<font></font>
allocate(name_of_array(xdim, ydim))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C / C ++ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert dies den folgenden Eintrag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;
<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(nrows * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *));<font></font>
 <font></font>
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
     <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ncolumns * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So geben Sie ein Array in Fortran frei</font></font><br>
 <br>
<pre><code class="hljs lisp">deallocate(<span class="hljs-name"><span class="hljs-name">name_of_array</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In C / C ++ daf√ºr</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
    <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]);<font></font>
}<font></font>
<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>);</code></pre><br>
<h2> :        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Sprachen wie C / C ++ werden alle Variablen als Wert √ºbergeben, mit Ausnahme von Arrays, die als Referenz √ºbergeben werden. In vielen F√§llen ist es jedoch sinnvoller, ein Array als Wert zu √ºbergeben. Lassen Sie die Daten beispielsweise aus Positionen von 100 Molek√ºlen zu verschiedenen Zeitpunkten bestehen. Wir m√ºssen die Bewegung eines Molek√ºls analysieren. Wir nehmen einen Teil des Arrays (Subarray), der den Koordinaten der Atome in diesem Molek√ºl entspricht, und √ºbergeben ihn an die Funktion. Darin werden wir uns mit einer komplexen Analyse des √ºbertragenen Subarrays befassen. Wenn wir es als Referenz √ºbergeben w√ºrden, w√ºrden sich die √ºbertragenen Daten nicht in einer Reihe im Speicher befinden. Aufgrund der Art des Speicherzugriffs w√§re die Arbeit mit einem solchen Array langsam. Wenn wir es als Wert √ºbergeben, erstellen wir im Speicher ein neues Array, das in einer Reihe angeordnet ist. Zur Freude der Physiker √ºbernimmt der Compiler die ganze schmutzige Arbeit der Speicheroptimierung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Fortran werden Variablen normalerweise als Referenz und nicht als Wert √ºbergeben. </font><font style="vertical-align: inherit;">Unter der Haube optimiert der Fortran-Compiler automatisch seine √úbertragung, um die Effizienz zu steigern. </font><font style="vertical-align: inherit;">Aus Sicht des Professors auf dem Gebiet der Optimierung der Speichernutzung sollte dem Compiler mehr vertraut werden als dem Studenten! </font><font style="vertical-align: inherit;">Als Ergebnis verwenden Physiker selten Zeiger, obwohl Fortran-90 + </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige weitere Beispiele f√ºr die Unterschiede zwischen Fortran und C.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran bietet verschiedene Optionen zum Verwalten des Compilers bei der Fehlerbehebung und Optimierung. </font><font style="vertical-align: inherit;">Fehler im Code k√∂nnen in der Kompilierungsphase und nicht w√§hrend der Ausf√ºhrung abgefangen werden. </font><font style="vertical-align: inherit;">Beispielsweise kann jede Variable als Parameter deklariert werden, dh als Konstante.</font></font><br>
<br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, parameter :: hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn sich der Parameter im Code √§ndert, gibt der Compiler einen Fehler zur√ºck. </font><font style="vertical-align: inherit;">In C hei√üt das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const</font></font></a><br>
<br>
<pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass const real sich von simple real unterscheidet. Wenn eine Funktion, die real akzeptiert, const real erh√§lt, wird ein Fehler zur√ºckgegeben. Es ist leicht vorstellbar, wie dies zu Interoperabilit√§tsproblemen im Code f√ºhren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran hat auch eine Absichtsspezifikation, die dem Compiler mitteilt, ob das an die Funktion √ºbergebene Argument eine Eingabe, Ausgabe oder sowohl ein Eingabe- als auch ein Ausgabeparameter ist. Dies hilft dem Compiler, den Code zu optimieren und seine Lesbarkeit und Zuverl√§ssigkeit zu erh√∂hen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran verf√ºgt √ºber weitere Funktionen, die bei unterschiedlichen Frequenzen verwendet werden. </font><font style="vertical-align: inherit;">Zum Beispiel kann Fortran 95 Funktionen mit dem reinen Modifikator deklarieren. </font><font style="vertical-align: inherit;">Eine solche Funktion hat keine Nebenwirkungen - sie √§ndert nur ihre Argumente und keine globalen Variablen. </font><font style="vertical-align: inherit;">Ein Sonderfall einer solchen Funktion ist die Elementfunktion, die Skalare akzeptiert und zur√ºckgibt. </font><font style="vertical-align: inherit;">Es wird verwendet, um Array-Elemente zu verarbeiten. </font><font style="vertical-align: inherit;">Die Information, dass die Funktion rein oder elementar ist, erm√∂glicht es dem Compiler, zus√§tzliche Optimierungen durchzuf√ºhren, insbesondere beim Parallelisieren von Code.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was erwartet Sie in Zukunft?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In wissenschaftlichen Berechnungen bleibt Fortran die Hauptsprache und wird in naher Zukunft nicht verschwinden. </font><font style="vertical-align: inherit;">In der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umfrage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter den Besuchern der Supercomputing Convention-Konferenz 2014, die diese Sprache verwenden, gaben 100% an, dass sie sie in den n√§chsten 5 Jahren verwenden werden. Aus der Umfrage geht auch hervor, dass 90% eine Mischung aus Fortran und C verwendeten. In Erwartung einer zunehmenden Vermischung dieser Sprachen enthalten die Entwickler der Fortran 2015-Spezifikation mehr Funktionen f√ºr die Code-Interoperabilit√§t. Fortran-Code wird zunehmend aus Python-Code aufgerufen. Informatiker, die die Verwendung von Fortran kritisieren, verstehen nicht, dass diese Sprache eindeutig f√ºr das angepasst bleibt, wonach sie benannt wurde - FOrmula-√úBERSETZUNG, √úbersetzung von Formeln, dh die Umwandlung physikalischer Formeln in Code. Vielen von ihnen ist nicht bewusst, dass sich die Sprache weiterentwickelt und st√§ndig neue Funktionen enth√§lt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufrufen des modernen Fortran 90+ alt ist dasselbe wie das Aufrufen des alten C ++, da C 1973 entwickelt wurde. Andererseits ist sogar der neueste Fortran 2008-Standard abw√§rtskompatibel mit Fortran 77 und dem gr√∂√üten Teil von Fortran 66. Daher ist die Entwicklung der Sprache mit gewissen Schwierigkeiten verbunden. </font><font style="vertical-align: inherit;">K√ºrzlich haben Forscher am MIT beschlossen, diese Schwierigkeiten zu √ºberwinden, indem sie eine Sprache f√ºr HPC namens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Julia entwickelt haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die erstmals 2012 ver√∂ffentlicht wurde. </font><font style="vertical-align: inherit;">Ob Julia den Platz von Fortran einnimmt, bleibt abzuwarten. </font><font style="vertical-align: inherit;">Auf jeden Fall vermute ich, dass dies sehr lange dauern wird.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de400523/">https://habr.com/ru/post/de400523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de400511/index.html">√úber die moderne Methode zur Lagerung abgebrannter Brennelemente</a></li>
<li><a href="../de400513/index.html">G√∂dels Unvollst√§ndigkeitssatz in 20 Minuten</a></li>
<li><a href="../de400515/index.html">Blockchainer: Blockchain-Vorteile f√ºr diejenigen, die nicht f√ºr Kryptow√§hrungen geeignet sind</a></li>
<li><a href="../de400519/index.html">Modularer 3D-Start 3D-Drucker als Quelle von Interesse f√ºr eine 3D-Katze</a></li>
<li><a href="../de400521/index.html">Apple hat den Fehler behoben und Consumer Reports falsche Testmethoden vorgeworfen</a></li>
<li><a href="../de400525/index.html">Entwicklung eines Systems zur mnemonischen Speicherung von Zahlen</a></li>
<li><a href="../de400527/index.html">Resampling II. Vergleich der Funktionsweise von digitalen und analogen Filtern h√∂herer Ordnung im Schallweg und Beantwortung von Fragen</a></li>
<li><a href="../de400529/index.html">OP-Ausstattung zur Sehkorrektur</a></li>
<li><a href="../de400531/index.html">Das State Duma Committee genehmigte einen Gesetzentwurf zur Regulierung audiovisueller Dienste</a></li>
<li><a href="../de400533/index.html">Das Hauptparadox des Bewusstseins. Warum das Kopieren des Gehirns oder der Pers√∂nlichkeit keinen Sinn macht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>