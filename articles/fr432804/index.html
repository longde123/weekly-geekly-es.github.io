<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüëß üà¥ üó∫Ô∏è Toute la v√©rit√© sur RTOS. Article # 24. Files d'attente: services auxiliaires et structures de donn√©es ‚òÉÔ∏è üë®üèø‚Äçü§ù‚Äçüë®üèæ üë©üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous continuerons √† consid√©rer les files d'attente. 

 Services de file d'attente secondaire 
 Nucleus RTOS dispose de quatre appels...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la v√©rit√© sur RTOS. Article # 24. Files d'attente: services auxiliaires et structures de donn√©es</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  Dans cet article, nous continuerons √† consid√©rer les files d'attente. <br><br><h2>  Services de file d'attente secondaire </h2><br>  Nucleus RTOS dispose de quatre appels d'API qui fournissent des fonctions auxiliaires li√©es aux files d'attente: r√©initialisation d'une file d'attente, obtention d'informations sur les files d'attente, obtention du nombre de files d'attente dans une application et obtention de pointeurs vers toutes les files d'attente d'une application.  Les trois premi√®res fonctions sont impl√©ment√©es dans Nucleus SE. <br><a name="habracut"></a><br>  Articles pr√©c√©dents de la s√©rie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bo√Ætes aux lettres: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bo√Ætes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©maphores: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©maphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'√©v√©nements: services d'assistance et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'√©v√©nements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de m√©moire: services et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de m√©moire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de donn√©es de t√¢che et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches: configuration et introduction √† l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalit√©s avanc√©es et pr√©servation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: impl√©mentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et d√©ploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps r√©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br><br><h3>  R√©initialisation de la file d'attente </h3><br>  Cet appel d'API r√©initialise la file d'attente √† son √©tat d'origine non utilis√©.  Tous les messages stock√©s dans la file d'attente seront perdus.  Toutes les t√¢ches suspendues dans la file d'attente reprendront avec le code retour <b>NUSE_QUEUE_WAS_RESET</b> . <br><br>  <b><i>Appel de r√©initialisation de file d'attente dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br>  <b>STATUS NU_Reset_Queue (file d'attente NU_QUEUE *);</b> <br><br>  Param√®tres: <br>  <b>queue</b> - un pointeur vers un bloc de contr√¥le de file d'attente fourni par l'utilisateur. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide. <br><br>  <b><i>Appel de r√©initialisation de file d'attente dans Nucleus SE</i></b> <br>  Cet appel d'utilitaire prend en charge la fonctionnalit√© principale de l'API RTOS Nucleus. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NUSE_Queue_Reset (file d'attente NUSE_QUEUE);</b> <br><br>  Param√®tres: <br>  <b>queue</b> - index (ID) de la file d'attente vid√©e. <br><br>  Valeur de retour: <br>  <b>NUSE_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NUSE_INVALID_QUEUE</b> - index de file d'attente non valide. <br><br>  <b><i>Impl√©mentation de la r√©initialisation de file d'attente dans Nucleus SE</i></b> <br>  Le code de la fonction <b>NUSE_Queue_Reset</b> (apr√®s v√©rification des param√®tres) est assez simple.  Les index de la t√™te et de la queue de la file d'attente, ainsi que le compteur de messages dans la file d'attente, se voient attribuer une valeur nulle. <br><br>  Si le verrouillage des t√¢ches est activ√©, un code suppl√©mentaire est responsable de la restauration des t√¢ches suspendues: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Chaque t√¢che en pause dans la file d'attente se voit attribuer un √©tat ¬´pr√™t¬ª avec un code retour <b>NUSE_QUEUE_WAS_RESET</b> .  Une fois ce processus termin√©, si le planificateur de priorit√© est utilis√©, la fonction <b>NUSE_Reschedule ()</b> est <b>appel√©e</b> , car une ou plusieurs t√¢ches avec une priorit√© √©lev√©e peuvent √™tre pr√™tes √† √™tre ex√©cut√©es. <br><br><h3>  Obtention d'informations sur la file d'attente </h3><br>  Cet appel de service fournit des informations sur la file d'attente.  L'impl√©mentation de cet appel dans Nucleus SE diff√®re de Nucleus RTOS en ce qu'il renvoie moins d'informations, car la d√©nomination des objets, la longueur variable des messages et l'ordre de pause des t√¢ches ne sont pas pris en charge et le verrouillage des t√¢ches peut √™tre d√©sactiv√©. <br><br>  <b><i>Appel √† des informations de file d'attente dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br><br>  <b>STATUT NU_Queue_Information (NU_QUEUE * file</b> d' <b>attente, CHAR</b> * nom, start_address ** NUL, UNSIGNED * queue_size, UNSIGNED * disponible, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * tasks_waiting, NU_TASK ** first_task); <br><br>  Param√®tres: <br><br>  <b>file d'attente</b> - un pointeur vers un bloc de contr√¥le de file d'attente fourni par l'utilisateur; <br>  <b>nom</b> - pointeur vers la r√©gion √† 8 caract√®res pour le nom du message dans la file d'attente; <br>  <b>start_address</b> - un pointeur vers un pointeur dans lequel l'adresse du d√©but de la zone de donn√©es de file d'attente sera √©crite; <br>  <b>queue_size</b> - un pointeur vers une variable pour stocker le nombre total d'√©l√©ments <b>UNSIGNED</b> dans la file d'attente; <br>  <b>available</b> - un pointeur sur une variable pour stocker le nombre d'√©l√©ments <b>UNSIGNED</b> disponibles dans la file d'attente; <br>  messages - un pointeur sur une variable pour stocker le nombre actuel de messages dans la file d'attente; <br>  <b>message_type</b> - un pointeur vers une variable pour stocker le type de messages pris en charge par la file d'attente.  Les valeurs valides sont <b>NU_FIXED_SIZE</b> et <b>NU_VARIABLE</b> ; <br>  <b>message_size</b> - un pointeur vers une variable pour stocker le nombre d'√©l√©ments de donn√©es <b>UNSIGNED</b> dans chaque message de la file d'attente.  Si la file d'attente prend en charge les messages de longueur variable, ce nombre indique la longueur maximale des messages; <br>  <b>suspend_type</b> - un pointeur vers une variable pour stocker le type de suspension des t√¢ches.  Les valeurs valides sont <b>NU_FIFO</b> et <b>NU_PRIORITY</b> ; <br>  <b>tasks_waiting</b> - un pointeur sur une variable pour stocker le nombre de t√¢ches suspendues dans cette file d'attente; <br>  <b>first_task</b> - pointeur vers le pointeur de t√¢che, dans lequel le pointeur de la premi√®re t√¢che suspendue est plac√©. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide. <br><br>  <b><i>Appel d'informations sur la file d'attente dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalit√© principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br><br>  <b>STATUS NUSE_Queue_Information (file d'attente NUSE_QUEUE, ADDR * start_address, U8 * queue_size, U8 * available, U8 * messages, U8 * tasks_waiting, NUSE_TASK * first_task);</b> <br><br>  Param√®tres: <br><br>  <b>file d'attente</b> - index de la file d'attente pour laquelle des informations sont demand√©es; <br>  <b>start_address</b> - pointeur vers une variable de type <b>ADDR</b> , qui stockera l'adresse du d√©but de la zone de donn√©es de la file d'attente; <br>  <b>queue_size</b> - un pointeur vers une variable de type <b>U8</b> , qui stockera le nombre total de messages pouvant tenir dans la file d'attente; <br>  <b>disponible</b> - un pointeur sur une variable de type <b>U8</b> , qui stockera le nombre de places libres dans la file d'attente; <br>  <b>messages</b> - un pointeur sur une variable de type <b>U8</b> , qui stockera le nombre actuel de messages dans la file d'attente; <br>  <b>tasks_waiting</b> - un pointeur vers une variable dans laquelle le nombre de t√¢ches suspendues dans cette file d'attente sera stock√© (rien n'est retourn√© si le verrouillage des t√¢ches est d√©sactiv√©); <br>  <b>first_task</b> - un pointeur vers une variable de type <b>NUSE_TASK</b> dans laquelle l'index de la premi√®re t√¢che suspendue sera stock√© (rien n'est retourn√© si le verrouillage de t√¢che est d√©sactiv√©). <br><br>  Valeur de retour: <br><br>  <b>NUSE_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NUSE_INVALID_QUEUE</b> - index de file d'attente non valide; <br>  <b>NUSE_INVALID_POINTER</b> - un ou plusieurs param√®tres de pointeur sont incorrects. <br><br>  <b><i>Impl√©mentation de l'affichage des informations de file d'attente dans Nucleus SE</i></b> <br><br>  L'impl√©mentation de cet appel d'API est assez simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  La fonction renvoie l'√©tat de la file d'attente.  Ensuite, si le verrouillage des t√¢ches est activ√©, le nombre de t√¢ches en attente et l'index de la premi√®re d'entre elles sont renvoy√©s (sinon, les deux param√®tres sont d√©finis sur 0). <br><br><h3>  Obtenir le nombre de files d'attente </h3><br>  Cet appel d'utilitaire renvoie le nombre de files d'attente configur√©es dans l'application.  Dans Nucleus RTOS, leur nombre peut changer au fil du temps et la valeur de retour indiquera le nombre actuel de files d'attente.  Dans Nucleus SE, la valeur de retour est d√©finie pendant la phase de g√©n√©ration et ne peut pas √™tre modifi√©e. <br><br>  <b><i>Appel du compteur de files d'attente dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Established_Queues (VOID);</b> <br><br>  Param√®tres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Le nombre de files d'attente cr√©√©es dans le syst√®me. <br><br>  <b><i>Appel du compteur de file d'attente dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalit√© principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br>  <b>U8 NUSE_Queue_Count (void);</b> <br><br>  Param√®tres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Le nombre de files d'attente configur√©es dans l'application. <br><br>  <b><i>Impl√©mentation du compteur de files d'attente dans Nucleus SE</i></b> <br>  L'impl√©mentation de cet appel API est tr√®s simple: la valeur du symbole <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> est <b>retourn√©e</b> . <br><br><h2>  Structures de donn√©es </h2><br>  Les files d'attente utilisent cinq ou six structures de donn√©es (qui sont soit en RAM ou en ROM), qui sont des ensembles de tables (comme les autres objets Nucleus SE), dont le nombre et la taille correspondent au nombre de files d'attente dans l'application et aux param√®tres s√©lectionn√©s. <br><br><h3>  Donn√©es du noyau dans la RAM </h3><br>  Ces donn√©es ont la structure suivante: <br><br>  <b>NUSE_Queue_Head []</b> est un tableau de pointeurs de type <b>U8</b> , poss√®de une entr√©e pour chaque file d'attente configur√©e et pointe vers la t√™te de la file d'attente de messages.  Utilis√© comme index d'adresse dans <b>NUSE_Queue_Data []</b> (voir ci-dessous); <br>  <b>NUSE_Queue_Tail []</b> est un tableau de type <b>U8</b> , poss√®de une entr√©e pour chaque file d'attente configur√©e dans l'application et pointe vers la fin de la file d'attente de messages.  Utilis√© comme index d'adresse dans <b>NUSE_Queue_Data []</b> (voir ci-dessous); <br>  <b>NUSE_Queue_Items []</b> est un tableau de type <b>U8</b> , a une entr√©e pour chaque file d'attente configur√©e et est un compteur de messages dans la file d'attente.  Ces donn√©es peuvent √™tre consid√©r√©es comme redondantes, car ces valeurs peuvent √™tre obtenues via les index du d√©but et de la fin de la file d'attente, cependant, le stockage du compteur simplifie le code; <br>  <b>NUSE_Queue_Blocking_Count []</b> - ce tableau de type <b>U8</b> contient des compteurs du nombre de t√¢ches suspendues sur chaque file d'attente.  Ce tableau est cr√©√© uniquement si la prise en charge du verrouillage des t√¢ches est activ√©e. <br><br>  Ces structures de donn√©es sont initialis√©es en z√©ros par la fonction <b>NUSE_Init_Queue () au</b> d√©marrage de Nucleus SE.  C'est logique, car toutes les files d'attente sont cr√©√©es vides (non utilis√©es). <br><br>  Voici les d√©finitions de ces structures dans le fichier <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  Donn√©es utilisateur RAM </h3><br>  L'utilisateur est responsable de fournir une zone RAM pour stocker chaque file d'attente.  La taille de cette zone doit contenir un tableau de type <b>ADDR</b> , dans lequel chaque enregistrement correspond √† un message dans la file d'attente <br><br><h3>  Donn√©es ROM </h3><br>  Ces donn√©es ont la structure suivante: <br><br>  <b>NUSE_Queue_Data []</b> - un tableau de type <b>ADDR</b> , a une entr√©e pour chaque file d'attente configur√©e et pointe vers la zone de donn√©es de la file d'attente (voir. Donn√©es RAM utilisateur); <br>  <b>NUSE_Queue_Size []</b> - un tableau de type <b>U8</b> , a une entr√©e pour chaque file d'attente configur√©e et affiche le nombre maximal de messages que chaque file d'attente peut recevoir. <br><br>  Ces structures de donn√©es sont d√©clar√©es et initialis√©es (statiquement) dans le fichier <b>nuse_config.c</b> : <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  La quantit√© de m√©moire pour les files d'attente </h3><br>  Comme tous les objets du noyau Nucleus SE, la quantit√© de m√©moire n√©cessaire pour les files d'attente est facilement pr√©visible. <br><br>  La quantit√© de donn√©es dans la ROM (en octets) pour toutes les files d'attente dans l'application peut √™tre calcul√©e comme suit: <br>  <b>NUSE_QUEUE_NUMBER * (taille de (ADDR) + 1)</b> <br><br>  La quantit√© de donn√©es du noyau dans la RAM (en octets) pour toutes les files d'attente dans l'application avec le verrouillage de t√¢che activ√© est calcul√©e comme suit: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Si le verrouillage est d√©sactiv√©: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  La quantit√© de donn√©es utilisateur en RAM (en octets) pour la file d'attente avec l'index de <b>file d'attente</b> : <br>  <b>NUSE_Queue_Size [queue] * sizeof (ADDR)</b> <br><br><h2>  Appels d'API non r√©alis√©s </h2><br>  Quatre appels d'API qui peuvent √™tre trouv√©s dans Nucleus RTOS ne sont pas impl√©ment√©s dans Nucleus SE: <br><br><h3>  Cr√©ation de file d'attente </h3><br>  Cet appel API cr√©e une file d'attente; dans Nucleus SE, cela n'est pas n√©cessaire, car les files d'attente sont cr√©√©es statiquement. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Create_Queue (file d'attente NU_QUEUE *, nom char *, VOID * start_address, UNSIGNED queue_size, OPTION message_type, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Param√®tres: <br><br>  <b>file d'attente</b> - un pointeur vers une unit√© de contr√¥le fournie par l'utilisateur; il est utilis√© pour g√©rer les files d'attente dans d'autres appels d'API; <br>  <b>nom</b> - un pointeur vers un nom de file d'attente √† 7 caract√®res avec un octet de fin nul; <br>  <b>start_address</b> - adresse du d√©but de la file d'attente; <br>  <b>message_type</b> - type de message pris en charge par la file d'attente.  Il peut prendre les valeurs <b>NU_FIXED_SIZE</b> ou <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> - si la file d'attente prend en charge les messages d'une longueur fixe, ce param√®tre d√©finit la longueur exacte de chaque message, sinon, si la file d'attente prend en charge les messages de longueur variable, cette valeur est la longueur maximale du message; <br>  <b>suspend_type</b> - d√©termine le type de suspension des t√¢ches dans la file d'attente.  Il peut prendre les valeurs <b>NU_FIFO</b> et <b>NU_PRIORITY</b> , qui d√©signent respectivement le principe de FIFO (First-In-First-Out) ou le principe de priorit√© de suspension des t√¢ches. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_QUEUE</b> - pointeur nul vers le bloc de contr√¥le de file d'attente ( <b>NULL</b> ), ou le pointeur est d√©j√† utilis√©; <br>  <b>NU_INVALID_MEMORY</b> - zone de m√©moire non valide sp√©cifi√©e dans <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - param√®tre de type de <b>message</b> non valide; <br>  <b>NU_INVALID_SIZE</b> - la file d'attente ne prend pas en charge les messages de cette longueur, ou la taille de la file d'attente et / ou la longueur des messages est 0; <br>  <b>NU_INVALID_SUSPEND</b> - param√®tre <b>suspend_type</b> non <b>valide</b> . <br><br><h3>  Supprimer la file d'attente </h3><br>  Cet appel d'API supprime la file d'attente cr√©√©e pr√©c√©demment.  Nucleus SE n'en a pas besoin car les files d'attente sont cr√©√©es statiquement et ne peuvent pas √™tre supprim√©es. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Delete_Queue (file d'attente NU_QUEUE *);</b> <br><br>  Param√®tres: <br>  <b>queue</b> - un pointeur vers un bloc de contr√¥le de file d'attente. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide. <br><br><h3>  Pointeurs de file d'attente </h3><br>  Cet appel d'API cr√©e une liste s√©quentielle de pointeurs vers toutes les files d'attente du syst√®me.  Nucleus SE n'en a pas besoin car les files d'attente sont identifi√©es √† l'aide d'un simple index, et non d'un pointeur. <br><br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Queue_Pointers (NU_QUEUE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Param√®tres: <br>  <b>pointer_list</b> - pointeur vers un tableau de pointeurs <b>NU_QUEUE</b> .  Ce tableau sera rempli de pointeurs vers les files d'attente cr√©√©es dans le syst√®me; <br>  <b>maximum_pointers</b> - le nombre maximum de pointeurs dans le tableau. <br><br>  Valeur de retour: <br>  Le nombre de pointeurs <b>NU_QUEUE</b> dans le tableau. <br><br><h3>  Mise en file d'attente (diffusion vers la file d'attente) </h3><br>  Cet appel d'API transmet le message √† toutes les t√¢ches suspendues dans la file d'attente qui attendent des messages de la file d'attente sp√©cifi√©e.  Cette fonctionnalit√© n'est pas impl√©ment√©e dans Nucleus SE car elle ajoute de la redondance. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Broadcast_To_Queue (file d'attente NU_QUEUE *, message VOID *, taille UNSIGNED, suspension UNSIGNED);</b> <br><br>  Param√®tres: <br><br>  <b>queue</b> - un pointeur vers un bloc de contr√¥le de file d'attente; <br>  <b>message</b> - pointeur vers le message transmis; <br>  <b>size</b> - le nombre d'√©l√©ments <b>UNSIGNED</b> dans le message.  Si la file d'attente prend en charge les messages de longueur variable, ce param√®tre doit √™tre √©gal ou inf√©rieur √† la longueur de message prise en charge par la file d'attente.  Si la file d'attente prend en charge les messages d'une longueur fixe, ce param√®tre doit √™tre √©gal √† la longueur du message pris en charge par la file d'attente; <br>  <b>suspen</b> - indique s'il faut suspendre la t√¢che appelante si la file d'attente est d√©j√† pleine.  Il peut s'agir de <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> ou d'une valeur de d√©lai d'expiration. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide; <br>  <b>NU_INVALID_POINTER</b> - pointeur nul vers un message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - la longueur de message sp√©cifi√©e n'est pas compatible avec la longueur sp√©cifi√©e lors de la cr√©ation de la file d'attente; <br>  <b>NU_INVALID_SUSPEND</b> - tente de suspendre une t√¢che √† partir d'un thread non associ√© √† la t√¢che; <br>  <b>NU_QUEUE_FULL</b> - il n'y a pas assez d'espace dans la file d'attente pour le message; <br>  <b>NU_TIMEOUT</b> - la file d'attente est toujours pleine apr√®s l'expiration du d√©lai; <br>  <b>NU_QUEUE_DELETED</b> - la file d'attente a √©t√© supprim√©e alors que la t√¢che a √©t√© suspendue; <br>  <b>NU_QUEUE_RESET</b> - La file d'attente a √©t√© r√©initialis√©e lors de la suspension de la t√¢che. <br><br><h2>  Compatible avec Nucleus RTOS </h2><br>  Comme pour tous les autres objets Nucleus SE, mon objectif √©tait de maximiser la compatibilit√© du code d'application avec Nucleus RTOS.  Les files d'attente ne font pas exception et, du point de vue de l'utilisateur, elles sont impl√©ment√©es de la m√™me mani√®re que dans Nucleus RTOS.  Il y a aussi une certaine incompatibilit√©, que j'ai jug√©e acceptable, √©tant donn√© que le code deviendra ainsi plus compr√©hensible et plus efficace en termes de quantit√© de m√©moire requise.  Sinon, les appels d'API Nucleus RTOS peuvent √™tre port√©s presque directement vers Nucleus SE. <br><br><h3>  Identificateurs d'objet </h3><br>  Dans Nucleus RTOS, tous les objets sont d√©crits par une structure de donn√©es (unit√©s de contr√¥le) qui a un type de donn√©es sp√©cifique.  Un pointeur vers cette unit√© de contr√¥le sert d'identifiant pour la file d'attente.  J'ai d√©cid√© que dans Nucleus SE, une approche diff√©rente est n√©cessaire pour une utilisation efficace de la m√©moire: tous les objets du noyau sont d√©crits par un ensemble de tables en RAM et / ou ROM.  La taille de ces tables est d√©termin√©e par le nombre d'objets configur√©s de chaque type.  L'identifiant d'un objet particulier est l'index dans ce tableau.  J'ai donc d√©fini <b>NUSE_QUEUE</b> comme l'√©quivalent de <b>U8</b> , une variable (pas un pointeur) de ce type sert d'identifiant de file d'attente.  Cette l√©g√®re incompatibilit√© est facile √† g√©rer si le code est port√© de Nucleus SE vers Nucleus RTOS et vice versa.  En r√®gle g√©n√©rale, aucune op√©ration n'est effectu√©e sur les identificateurs d'objet autres que le d√©placement et le stockage. <br><br>  Nucleus RTOS prend √©galement en charge la d√©nomination des files d'attente.  Ces noms sont utilis√©s uniquement pour le d√©bogage.  Je les ai exclus de Nucleus SE pour √©conomiser de la m√©moire. <br><br><h3>  Taille et type du message </h3><br>  Dans Nucleus RTOS, une file d'attente peut √™tre configur√©e pour traiter les messages compos√©s d'un nombre <b>illimit√© d'</b> √©l√©ments <b>non sign√©s</b> .  Dans Nucleus SE, les files d'attente sont simplifi√©es et ne prennent en charge que les messages de type <b>ADDR</b> uniques.  Les canaux de donn√©es de Nucleus SE sont un peu plus flexibles et peuvent √™tre une alternative utile aux files d'attente dans certains cas.  Les cha√Ænes seront couvertes dans les deux prochains articles de cette s√©rie. <br><br>  Nucleus SE prend √©galement en charge les files d'attente de messages de longueur variable, qui sp√©cifient uniquement la longueur maximale des messages lors de la cr√©ation.  Les longueurs de message variables ne sont pas prises en charge par Nucleus SE <br><br><h3>  Taille de la file d'attente </h3><br>  Dans Nucleus SE, le nombre maximal de messages dans une file d'attente est de 256, car toutes les variables et constantes sont de type <b>U8</b> .  Nucleus RTOS n'a pas de telles limitations. <br><br><h3>  Appels d'API non r√©alis√©s </h3><br>  Nucleus RTOS prend en charge dix appels de gestion de file d'attente.  Parmi ceux-ci, quatre ne sont pas impl√©ment√©s dans Nucleus SE.  Les d√©tails de ces appels, ainsi que les raisons d'une telle d√©cision, peuvent √™tre trouv√©s dans cet article ci-dessus, dans la section "Appels d'API non r√©alis√©s". <br><br>  Le prochain article traitera des canaux de transmission de donn√©es. <br><br>  <b>√Ä propos de l'auteur:</b> Colin Walls travaille dans l'industrie √©lectronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.  Il est maintenant ing√©nieur firmware chez Mentor Embedded (une division de Mentor Graphics).  Colin Walls intervient souvent lors de conf√©rences et s√©minaires, auteur de nombreux articles techniques et de deux livres sur le firmware.  Vit au Royaume-Uni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog</a> professionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432804/">https://habr.com/ru/post/fr432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432794/index.html">Bret Victor: Quelques mots sur Douglas Engelbart</a></li>
<li><a href="../fr432796/index.html">Module de calcul, mod√®les 2019</a></li>
<li><a href="../fr432798/index.html">Meilleur syst√®me d'exploitation de s√©curit√©: comparaison Titan</a></li>
<li><a href="../fr432800/index.html">Enqu√™te sur les incidents de s√©curit√© avec StaffCop Enterprise 4.4</a></li>
<li><a href="../fr432802/index.html">Six plates-formes d'apprentissage de programmation automatis√©es gratuites</a></li>
<li><a href="../fr432806/index.html">Superintelligence: une id√©e qui hante les gens intelligents</a></li>
<li><a href="../fr432808/index.html">Salaires en AI: o√π il y a plus d'argent et qui ils cherchent en Russie</a></li>
<li><a href="../fr432810/index.html">Premi√®res amendes pour le GDPR: qui a d√©j√† √©t√© puni</a></li>
<li><a href="../fr432812/index.html">Nous √©crivons des robots de trading en utilisant le cadre graphique StockSharp. Partie 1</a></li>
<li><a href="../fr432814/index.html">Int√©gration de Cake et TeamCity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>