<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 🈴 🗺️ Toute la vérité sur RTOS. Article # 24. Files d'attente: services auxiliaires et structures de données ☃️ 👨🏿‍🤝‍👨🏾 👩🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous continuerons à considérer les files d'attente. 

 Services de file d'attente secondaire 
 Nucleus RTOS dispose de quatre appels...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS. Article # 24. Files d'attente: services auxiliaires et structures de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  Dans cet article, nous continuerons à considérer les files d'attente. <br><br><h2>  Services de file d'attente secondaire </h2><br>  Nucleus RTOS dispose de quatre appels d'API qui fournissent des fonctions auxiliaires liées aux files d'attente: réinitialisation d'une file d'attente, obtention d'informations sur les files d'attente, obtention du nombre de files d'attente dans une application et obtention de pointeurs vers toutes les files d'attente d'une application.  Les trois premières fonctions sont implémentées dans Nucleus SE. <br><a name="habracut"></a><br>  Articles précédents de la série: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'événements: services d'assistance et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'événements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de mémoire: services et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de mémoire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de données de tâche et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches: configuration et introduction à l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalités avancées et préservation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et déploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br><br><h3>  Réinitialisation de la file d'attente </h3><br>  Cet appel d'API réinitialise la file d'attente à son état d'origine non utilisé.  Tous les messages stockés dans la file d'attente seront perdus.  Toutes les tâches suspendues dans la file d'attente reprendront avec le code retour <b>NUSE_QUEUE_WAS_RESET</b> . <br><br>  <b><i>Appel de réinitialisation de file d'attente dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br>  <b>STATUS NU_Reset_Queue (file d'attente NU_QUEUE *);</b> <br><br>  Paramètres: <br>  <b>queue</b> - un pointeur vers un bloc de contrôle de file d'attente fourni par l'utilisateur. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide. <br><br>  <b><i>Appel de réinitialisation de file d'attente dans Nucleus SE</i></b> <br>  Cet appel d'utilitaire prend en charge la fonctionnalité principale de l'API RTOS Nucleus. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NUSE_Queue_Reset (file d'attente NUSE_QUEUE);</b> <br><br>  Paramètres: <br>  <b>queue</b> - index (ID) de la file d'attente vidée. <br><br>  Valeur de retour: <br>  <b>NUSE_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NUSE_INVALID_QUEUE</b> - index de file d'attente non valide. <br><br>  <b><i>Implémentation de la réinitialisation de file d'attente dans Nucleus SE</i></b> <br>  Le code de la fonction <b>NUSE_Queue_Reset</b> (après vérification des paramètres) est assez simple.  Les index de la tête et de la queue de la file d'attente, ainsi que le compteur de messages dans la file d'attente, se voient attribuer une valeur nulle. <br><br>  Si le verrouillage des tâches est activé, un code supplémentaire est responsable de la restauration des tâches suspendues: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Chaque tâche en pause dans la file d'attente se voit attribuer un état «prêt» avec un code retour <b>NUSE_QUEUE_WAS_RESET</b> .  Une fois ce processus terminé, si le planificateur de priorité est utilisé, la fonction <b>NUSE_Reschedule ()</b> est <b>appelée</b> , car une ou plusieurs tâches avec une priorité élevée peuvent être prêtes à être exécutées. <br><br><h3>  Obtention d'informations sur la file d'attente </h3><br>  Cet appel de service fournit des informations sur la file d'attente.  L'implémentation de cet appel dans Nucleus SE diffère de Nucleus RTOS en ce qu'il renvoie moins d'informations, car la dénomination des objets, la longueur variable des messages et l'ordre de pause des tâches ne sont pas pris en charge et le verrouillage des tâches peut être désactivé. <br><br>  <b><i>Appel à des informations de file d'attente dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br><br>  <b>STATUT NU_Queue_Information (NU_QUEUE * file</b> d' <b>attente, CHAR</b> * nom, start_address ** NUL, UNSIGNED * queue_size, UNSIGNED * disponible, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * tasks_waiting, NU_TASK ** first_task); <br><br>  Paramètres: <br><br>  <b>file d'attente</b> - un pointeur vers un bloc de contrôle de file d'attente fourni par l'utilisateur; <br>  <b>nom</b> - pointeur vers la région à 8 caractères pour le nom du message dans la file d'attente; <br>  <b>start_address</b> - un pointeur vers un pointeur dans lequel l'adresse du début de la zone de données de file d'attente sera écrite; <br>  <b>queue_size</b> - un pointeur vers une variable pour stocker le nombre total d'éléments <b>UNSIGNED</b> dans la file d'attente; <br>  <b>available</b> - un pointeur sur une variable pour stocker le nombre d'éléments <b>UNSIGNED</b> disponibles dans la file d'attente; <br>  messages - un pointeur sur une variable pour stocker le nombre actuel de messages dans la file d'attente; <br>  <b>message_type</b> - un pointeur vers une variable pour stocker le type de messages pris en charge par la file d'attente.  Les valeurs valides sont <b>NU_FIXED_SIZE</b> et <b>NU_VARIABLE</b> ; <br>  <b>message_size</b> - un pointeur vers une variable pour stocker le nombre d'éléments de données <b>UNSIGNED</b> dans chaque message de la file d'attente.  Si la file d'attente prend en charge les messages de longueur variable, ce nombre indique la longueur maximale des messages; <br>  <b>suspend_type</b> - un pointeur vers une variable pour stocker le type de suspension des tâches.  Les valeurs valides sont <b>NU_FIFO</b> et <b>NU_PRIORITY</b> ; <br>  <b>tasks_waiting</b> - un pointeur sur une variable pour stocker le nombre de tâches suspendues dans cette file d'attente; <br>  <b>first_task</b> - pointeur vers le pointeur de tâche, dans lequel le pointeur de la première tâche suspendue est placé. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide. <br><br>  <b><i>Appel d'informations sur la file d'attente dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalité principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br><br>  <b>STATUS NUSE_Queue_Information (file d'attente NUSE_QUEUE, ADDR * start_address, U8 * queue_size, U8 * available, U8 * messages, U8 * tasks_waiting, NUSE_TASK * first_task);</b> <br><br>  Paramètres: <br><br>  <b>file d'attente</b> - index de la file d'attente pour laquelle des informations sont demandées; <br>  <b>start_address</b> - pointeur vers une variable de type <b>ADDR</b> , qui stockera l'adresse du début de la zone de données de la file d'attente; <br>  <b>queue_size</b> - un pointeur vers une variable de type <b>U8</b> , qui stockera le nombre total de messages pouvant tenir dans la file d'attente; <br>  <b>disponible</b> - un pointeur sur une variable de type <b>U8</b> , qui stockera le nombre de places libres dans la file d'attente; <br>  <b>messages</b> - un pointeur sur une variable de type <b>U8</b> , qui stockera le nombre actuel de messages dans la file d'attente; <br>  <b>tasks_waiting</b> - un pointeur vers une variable dans laquelle le nombre de tâches suspendues dans cette file d'attente sera stocké (rien n'est retourné si le verrouillage des tâches est désactivé); <br>  <b>first_task</b> - un pointeur vers une variable de type <b>NUSE_TASK</b> dans laquelle l'index de la première tâche suspendue sera stocké (rien n'est retourné si le verrouillage de tâche est désactivé). <br><br>  Valeur de retour: <br><br>  <b>NUSE_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NUSE_INVALID_QUEUE</b> - index de file d'attente non valide; <br>  <b>NUSE_INVALID_POINTER</b> - un ou plusieurs paramètres de pointeur sont incorrects. <br><br>  <b><i>Implémentation de l'affichage des informations de file d'attente dans Nucleus SE</i></b> <br><br>  L'implémentation de cet appel d'API est assez simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  La fonction renvoie l'état de la file d'attente.  Ensuite, si le verrouillage des tâches est activé, le nombre de tâches en attente et l'index de la première d'entre elles sont renvoyés (sinon, les deux paramètres sont définis sur 0). <br><br><h3>  Obtenir le nombre de files d'attente </h3><br>  Cet appel d'utilitaire renvoie le nombre de files d'attente configurées dans l'application.  Dans Nucleus RTOS, leur nombre peut changer au fil du temps et la valeur de retour indiquera le nombre actuel de files d'attente.  Dans Nucleus SE, la valeur de retour est définie pendant la phase de génération et ne peut pas être modifiée. <br><br>  <b><i>Appel du compteur de files d'attente dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Established_Queues (VOID);</b> <br><br>  Paramètres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Le nombre de files d'attente créées dans le système. <br><br>  <b><i>Appel du compteur de file d'attente dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalité principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br>  <b>U8 NUSE_Queue_Count (void);</b> <br><br>  Paramètres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Le nombre de files d'attente configurées dans l'application. <br><br>  <b><i>Implémentation du compteur de files d'attente dans Nucleus SE</i></b> <br>  L'implémentation de cet appel API est très simple: la valeur du symbole <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> est <b>retournée</b> . <br><br><h2>  Structures de données </h2><br>  Les files d'attente utilisent cinq ou six structures de données (qui sont soit en RAM ou en ROM), qui sont des ensembles de tables (comme les autres objets Nucleus SE), dont le nombre et la taille correspondent au nombre de files d'attente dans l'application et aux paramètres sélectionnés. <br><br><h3>  Données du noyau dans la RAM </h3><br>  Ces données ont la structure suivante: <br><br>  <b>NUSE_Queue_Head []</b> est un tableau de pointeurs de type <b>U8</b> , possède une entrée pour chaque file d'attente configurée et pointe vers la tête de la file d'attente de messages.  Utilisé comme index d'adresse dans <b>NUSE_Queue_Data []</b> (voir ci-dessous); <br>  <b>NUSE_Queue_Tail []</b> est un tableau de type <b>U8</b> , possède une entrée pour chaque file d'attente configurée dans l'application et pointe vers la fin de la file d'attente de messages.  Utilisé comme index d'adresse dans <b>NUSE_Queue_Data []</b> (voir ci-dessous); <br>  <b>NUSE_Queue_Items []</b> est un tableau de type <b>U8</b> , a une entrée pour chaque file d'attente configurée et est un compteur de messages dans la file d'attente.  Ces données peuvent être considérées comme redondantes, car ces valeurs peuvent être obtenues via les index du début et de la fin de la file d'attente, cependant, le stockage du compteur simplifie le code; <br>  <b>NUSE_Queue_Blocking_Count []</b> - ce tableau de type <b>U8</b> contient des compteurs du nombre de tâches suspendues sur chaque file d'attente.  Ce tableau est créé uniquement si la prise en charge du verrouillage des tâches est activée. <br><br>  Ces structures de données sont initialisées en zéros par la fonction <b>NUSE_Init_Queue () au</b> démarrage de Nucleus SE.  C'est logique, car toutes les files d'attente sont créées vides (non utilisées). <br><br>  Voici les définitions de ces structures dans le fichier <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  Données utilisateur RAM </h3><br>  L'utilisateur est responsable de fournir une zone RAM pour stocker chaque file d'attente.  La taille de cette zone doit contenir un tableau de type <b>ADDR</b> , dans lequel chaque enregistrement correspond à un message dans la file d'attente <br><br><h3>  Données ROM </h3><br>  Ces données ont la structure suivante: <br><br>  <b>NUSE_Queue_Data []</b> - un tableau de type <b>ADDR</b> , a une entrée pour chaque file d'attente configurée et pointe vers la zone de données de la file d'attente (voir. Données RAM utilisateur); <br>  <b>NUSE_Queue_Size []</b> - un tableau de type <b>U8</b> , a une entrée pour chaque file d'attente configurée et affiche le nombre maximal de messages que chaque file d'attente peut recevoir. <br><br>  Ces structures de données sont déclarées et initialisées (statiquement) dans le fichier <b>nuse_config.c</b> : <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  La quantité de mémoire pour les files d'attente </h3><br>  Comme tous les objets du noyau Nucleus SE, la quantité de mémoire nécessaire pour les files d'attente est facilement prévisible. <br><br>  La quantité de données dans la ROM (en octets) pour toutes les files d'attente dans l'application peut être calculée comme suit: <br>  <b>NUSE_QUEUE_NUMBER * (taille de (ADDR) + 1)</b> <br><br>  La quantité de données du noyau dans la RAM (en octets) pour toutes les files d'attente dans l'application avec le verrouillage de tâche activé est calculée comme suit: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Si le verrouillage est désactivé: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  La quantité de données utilisateur en RAM (en octets) pour la file d'attente avec l'index de <b>file d'attente</b> : <br>  <b>NUSE_Queue_Size [queue] * sizeof (ADDR)</b> <br><br><h2>  Appels d'API non réalisés </h2><br>  Quatre appels d'API qui peuvent être trouvés dans Nucleus RTOS ne sont pas implémentés dans Nucleus SE: <br><br><h3>  Création de file d'attente </h3><br>  Cet appel API crée une file d'attente; dans Nucleus SE, cela n'est pas nécessaire, car les files d'attente sont créées statiquement. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Create_Queue (file d'attente NU_QUEUE *, nom char *, VOID * start_address, UNSIGNED queue_size, OPTION message_type, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Paramètres: <br><br>  <b>file d'attente</b> - un pointeur vers une unité de contrôle fournie par l'utilisateur; il est utilisé pour gérer les files d'attente dans d'autres appels d'API; <br>  <b>nom</b> - un pointeur vers un nom de file d'attente à 7 caractères avec un octet de fin nul; <br>  <b>start_address</b> - adresse du début de la file d'attente; <br>  <b>message_type</b> - type de message pris en charge par la file d'attente.  Il peut prendre les valeurs <b>NU_FIXED_SIZE</b> ou <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> - si la file d'attente prend en charge les messages d'une longueur fixe, ce paramètre définit la longueur exacte de chaque message, sinon, si la file d'attente prend en charge les messages de longueur variable, cette valeur est la longueur maximale du message; <br>  <b>suspend_type</b> - détermine le type de suspension des tâches dans la file d'attente.  Il peut prendre les valeurs <b>NU_FIFO</b> et <b>NU_PRIORITY</b> , qui désignent respectivement le principe de FIFO (First-In-First-Out) ou le principe de priorité de suspension des tâches. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_QUEUE</b> - pointeur nul vers le bloc de contrôle de file d'attente ( <b>NULL</b> ), ou le pointeur est déjà utilisé; <br>  <b>NU_INVALID_MEMORY</b> - zone de mémoire non valide spécifiée dans <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - paramètre de type de <b>message</b> non valide; <br>  <b>NU_INVALID_SIZE</b> - la file d'attente ne prend pas en charge les messages de cette longueur, ou la taille de la file d'attente et / ou la longueur des messages est 0; <br>  <b>NU_INVALID_SUSPEND</b> - paramètre <b>suspend_type</b> non <b>valide</b> . <br><br><h3>  Supprimer la file d'attente </h3><br>  Cet appel d'API supprime la file d'attente créée précédemment.  Nucleus SE n'en a pas besoin car les files d'attente sont créées statiquement et ne peuvent pas être supprimées. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Delete_Queue (file d'attente NU_QUEUE *);</b> <br><br>  Paramètres: <br>  <b>queue</b> - un pointeur vers un bloc de contrôle de file d'attente. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide. <br><br><h3>  Pointeurs de file d'attente </h3><br>  Cet appel d'API crée une liste séquentielle de pointeurs vers toutes les files d'attente du système.  Nucleus SE n'en a pas besoin car les files d'attente sont identifiées à l'aide d'un simple index, et non d'un pointeur. <br><br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Queue_Pointers (NU_QUEUE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Paramètres: <br>  <b>pointer_list</b> - pointeur vers un tableau de pointeurs <b>NU_QUEUE</b> .  Ce tableau sera rempli de pointeurs vers les files d'attente créées dans le système; <br>  <b>maximum_pointers</b> - le nombre maximum de pointeurs dans le tableau. <br><br>  Valeur de retour: <br>  Le nombre de pointeurs <b>NU_QUEUE</b> dans le tableau. <br><br><h3>  Mise en file d'attente (diffusion vers la file d'attente) </h3><br>  Cet appel d'API transmet le message à toutes les tâches suspendues dans la file d'attente qui attendent des messages de la file d'attente spécifiée.  Cette fonctionnalité n'est pas implémentée dans Nucleus SE car elle ajoute de la redondance. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Broadcast_To_Queue (file d'attente NU_QUEUE *, message VOID *, taille UNSIGNED, suspension UNSIGNED);</b> <br><br>  Paramètres: <br><br>  <b>queue</b> - un pointeur vers un bloc de contrôle de file d'attente; <br>  <b>message</b> - pointeur vers le message transmis; <br>  <b>size</b> - le nombre d'éléments <b>UNSIGNED</b> dans le message.  Si la file d'attente prend en charge les messages de longueur variable, ce paramètre doit être égal ou inférieur à la longueur de message prise en charge par la file d'attente.  Si la file d'attente prend en charge les messages d'une longueur fixe, ce paramètre doit être égal à la longueur du message pris en charge par la file d'attente; <br>  <b>suspen</b> - indique s'il faut suspendre la tâche appelante si la file d'attente est déjà pleine.  Il peut s'agir de <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> ou d'une valeur de délai d'expiration. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_QUEUE</b> - pointeur de file d'attente non valide; <br>  <b>NU_INVALID_POINTER</b> - pointeur nul vers un message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - la longueur de message spécifiée n'est pas compatible avec la longueur spécifiée lors de la création de la file d'attente; <br>  <b>NU_INVALID_SUSPEND</b> - tente de suspendre une tâche à partir d'un thread non associé à la tâche; <br>  <b>NU_QUEUE_FULL</b> - il n'y a pas assez d'espace dans la file d'attente pour le message; <br>  <b>NU_TIMEOUT</b> - la file d'attente est toujours pleine après l'expiration du délai; <br>  <b>NU_QUEUE_DELETED</b> - la file d'attente a été supprimée alors que la tâche a été suspendue; <br>  <b>NU_QUEUE_RESET</b> - La file d'attente a été réinitialisée lors de la suspension de la tâche. <br><br><h2>  Compatible avec Nucleus RTOS </h2><br>  Comme pour tous les autres objets Nucleus SE, mon objectif était de maximiser la compatibilité du code d'application avec Nucleus RTOS.  Les files d'attente ne font pas exception et, du point de vue de l'utilisateur, elles sont implémentées de la même manière que dans Nucleus RTOS.  Il y a aussi une certaine incompatibilité, que j'ai jugée acceptable, étant donné que le code deviendra ainsi plus compréhensible et plus efficace en termes de quantité de mémoire requise.  Sinon, les appels d'API Nucleus RTOS peuvent être portés presque directement vers Nucleus SE. <br><br><h3>  Identificateurs d'objet </h3><br>  Dans Nucleus RTOS, tous les objets sont décrits par une structure de données (unités de contrôle) qui a un type de données spécifique.  Un pointeur vers cette unité de contrôle sert d'identifiant pour la file d'attente.  J'ai décidé que dans Nucleus SE, une approche différente est nécessaire pour une utilisation efficace de la mémoire: tous les objets du noyau sont décrits par un ensemble de tables en RAM et / ou ROM.  La taille de ces tables est déterminée par le nombre d'objets configurés de chaque type.  L'identifiant d'un objet particulier est l'index dans ce tableau.  J'ai donc défini <b>NUSE_QUEUE</b> comme l'équivalent de <b>U8</b> , une variable (pas un pointeur) de ce type sert d'identifiant de file d'attente.  Cette légère incompatibilité est facile à gérer si le code est porté de Nucleus SE vers Nucleus RTOS et vice versa.  En règle générale, aucune opération n'est effectuée sur les identificateurs d'objet autres que le déplacement et le stockage. <br><br>  Nucleus RTOS prend également en charge la dénomination des files d'attente.  Ces noms sont utilisés uniquement pour le débogage.  Je les ai exclus de Nucleus SE pour économiser de la mémoire. <br><br><h3>  Taille et type du message </h3><br>  Dans Nucleus RTOS, une file d'attente peut être configurée pour traiter les messages composés d'un nombre <b>illimité d'</b> éléments <b>non signés</b> .  Dans Nucleus SE, les files d'attente sont simplifiées et ne prennent en charge que les messages de type <b>ADDR</b> uniques.  Les canaux de données de Nucleus SE sont un peu plus flexibles et peuvent être une alternative utile aux files d'attente dans certains cas.  Les chaînes seront couvertes dans les deux prochains articles de cette série. <br><br>  Nucleus SE prend également en charge les files d'attente de messages de longueur variable, qui spécifient uniquement la longueur maximale des messages lors de la création.  Les longueurs de message variables ne sont pas prises en charge par Nucleus SE <br><br><h3>  Taille de la file d'attente </h3><br>  Dans Nucleus SE, le nombre maximal de messages dans une file d'attente est de 256, car toutes les variables et constantes sont de type <b>U8</b> .  Nucleus RTOS n'a pas de telles limitations. <br><br><h3>  Appels d'API non réalisés </h3><br>  Nucleus RTOS prend en charge dix appels de gestion de file d'attente.  Parmi ceux-ci, quatre ne sont pas implémentés dans Nucleus SE.  Les détails de ces appels, ainsi que les raisons d'une telle décision, peuvent être trouvés dans cet article ci-dessus, dans la section "Appels d'API non réalisés". <br><br>  Le prochain article traitera des canaux de transmission de données. <br><br>  <b>À propos de l'auteur:</b> Colin Walls travaille dans l'industrie électronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.  Il est maintenant ingénieur firmware chez Mentor Embedded (une division de Mentor Graphics).  Colin Walls intervient souvent lors de conférences et séminaires, auteur de nombreux articles techniques et de deux livres sur le firmware.  Vit au Royaume-Uni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog</a> professionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432804/">https://habr.com/ru/post/fr432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432794/index.html">Bret Victor: Quelques mots sur Douglas Engelbart</a></li>
<li><a href="../fr432796/index.html">Module de calcul, modèles 2019</a></li>
<li><a href="../fr432798/index.html">Meilleur système d'exploitation de sécurité: comparaison Titan</a></li>
<li><a href="../fr432800/index.html">Enquête sur les incidents de sécurité avec StaffCop Enterprise 4.4</a></li>
<li><a href="../fr432802/index.html">Six plates-formes d'apprentissage de programmation automatisées gratuites</a></li>
<li><a href="../fr432806/index.html">Superintelligence: une idée qui hante les gens intelligents</a></li>
<li><a href="../fr432808/index.html">Salaires en AI: où il y a plus d'argent et qui ils cherchent en Russie</a></li>
<li><a href="../fr432810/index.html">Premières amendes pour le GDPR: qui a déjà été puni</a></li>
<li><a href="../fr432812/index.html">Nous écrivons des robots de trading en utilisant le cadre graphique StockSharp. Partie 1</a></li>
<li><a href="../fr432814/index.html">Intégration de Cake et TeamCity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>