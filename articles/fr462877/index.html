<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèø üöÉ üÜì Verrous dans PostgreSQL: 1. Verrous de relation üë©‚Äçüë©‚Äçüëß üßóüèº üòä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les deux pr√©c√©dentes s√©ries d'articles se sont concentr√©es sur l' isolement, le multiversionisme et la journalisation . 

 Dans cette s√©rie, nous parl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verrous dans PostgreSQL: 1. Verrous de relation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/">  Les deux pr√©c√©dentes s√©ries d'articles se sont concentr√©es sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement, le multiversionisme</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journalisation</a> . <br><br>  Dans cette s√©rie, nous parlerons des serrures.  J'adh√©rerai √† ce terme, mais dans la litt√©rature il peut aussi y en avoir un autre: <em>ch√¢teau</em> . <br><br>  Le cycle comprendra quatre parties: <br><br><ol><li>  Verrous de relation (cet article); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Serrures de rang√©es</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Serrures d'autres objets</a> et verrous de pr√©dicat; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Verrous en RAM</a> . </li></ol><br>  Le mat√©riel de tous les articles est bas√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des cours de formation</a> administrative que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pluzanov</a> et moi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">faisons</a> , mais ne les r√©p√®tent pas textuellement et sont destin√©s √† une lecture r√©fl√©chie et √† une exp√©rimentation ind√©pendante. <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1>  Informations g√©n√©rales sur les serrures </h1><br>  PostgreSQL utilise de nombreux m√©canismes diff√©rents qui sont utilis√©s pour bloquer quelque chose (ou du moins sont appel√©s ainsi).  Par cons√©quent, je vais commencer par les mots les plus g√©n√©raux expliquant pourquoi les verrous sont n√©cessaires, ce qu'ils sont et comment ils diff√®rent les uns des autres.  Ensuite, nous verrons ce que l'on trouve de cette vari√©t√© dans PostgreSQL et ce n'est qu'apr√®s que nous commencerons √† traiter en d√©tail les diff√©rents types de verrous. <br><a name="habracut"></a><br>  Les verrous sont utilis√©s pour rationaliser l'acc√®s simultan√© aux ressources partag√©es. <br><br>  L'acc√®s concurrentiel fait r√©f√©rence √† l'acc√®s simultan√© de plusieurs processus.  Les processus eux-m√™mes peuvent √™tre effectu√©s √† la fois en parall√®le (si l'√©quipement le permet) et s√©quentiellement en mode de partage de temps - ce n'est pas important. <br><br>  S'il n'y a pas de concurrence, il n'y a pas besoin de verrous (par exemple, un cache de tampon partag√© n√©cessite des verrous, mais pas un local). <br><br>  Avant d'acc√©der √† une ressource, un processus doit acqu√©rir le verrou associ√© √† cette ressource.  Autrement dit, nous parlons d'une certaine discipline: tout fonctionne tant que tous les processus sont conformes aux r√®gles √©tablies pour acc√©der √† une ressource partag√©e.  Si le SGBD g√®re les verrous, il surveille lui-m√™me la commande;  si le blocage est fix√© par l'application, cette obligation lui incombe. <br><br>  √Ä un niveau bas, un verrou est repr√©sent√© par une section de m√©moire partag√©e, dans laquelle il est not√© d'une certaine mani√®re si le verrou est libre ou captur√© (et, √©ventuellement, des informations suppl√©mentaires sont enregistr√©es: num√©ro de processus, temps de capture, etc.). <br><br><blockquote>  Vous remarquerez peut-√™tre qu'un tel morceau de m√©moire partag√©e est en soi une ressource √† laquelle un acc√®s concurrentiel est possible.  Si nous descendons un niveau plus bas, nous verrons que les primitives accessoires sp√©ciales (telles que les s√©maphores ou les mutex) fournies par le syst√®me d'exploitation sont utilis√©es pour organiser l'acc√®s.  Leur signification est que le code acc√©dant √† la ressource partag√©e doit √™tre ex√©cut√© en un seul processus √† la fois.  Au niveau le plus bas, ces primitives sont impl√©ment√©es sur la base des instructions du processeur atomique (telles que test-and-set ou compare-and-swap). <br></blockquote><br>  Une fois que la ressource n'est plus n√©cessaire au processus, elle <em>lib√®re le</em> verrou pour que d'autres puissent l'utiliser. <br><br>  Bien s√ªr, le verrouillage du verrou n'est pas toujours possible: la ressource peut d√©j√† √™tre prise par quelqu'un d'autre.  Ensuite, le processus entre dans la file d'attente (si le m√©canisme de verrouillage donne cette possibilit√©), ou r√©essaye de capturer le verrou apr√®s un certain temps.  D'une mani√®re ou d'une autre, cela conduit au fait que le processus est oblig√© de rester inactif en pr√©vision de la lib√©ration de la ressource. <br><br><blockquote>  Il est parfois possible d'appliquer d'autres strat√©gies non bloquantes.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le m√©canisme de multi-</a> version permet √† plusieurs processus dans certains cas de fonctionner simultan√©ment avec diff√©rentes versions de donn√©es sans se bloquer les uns les autres. <br></blockquote><br>  En principe, une ressource prot√©g√©e peut √™tre n'importe quoi, si seulement cette ressource pouvait √™tre identifi√©e sans ambigu√Øt√© et mise en correspondance avec une adresse de blocage. <br><br>  Par exemple, la ressource peut √™tre l'objet avec lequel le SGBD travaille, comme une page de donn√©es (identifi√©e par le nom et la position du fichier dans le fichier), une table (oid dans le r√©pertoire syst√®me), une ligne de table (page et d√©calage √† l'int√©rieur de la page).  Une ressource peut √™tre une structure en m√©moire, telle qu'une table de hachage, un tampon, etc. (identifi√©e par un num√©ro pr√©-attribu√©).  Parfois, il est m√™me pratique d'utiliser des ressources abstraites qui n'ont aucune signification physique (elles sont identifi√©es simplement par un num√©ro unique). <br><br>  L'efficacit√© des serrures est influenc√©e par de nombreux facteurs, dont nous distinguons deux. <br><br><ul><li>  <strong>La</strong> granularit√© (granularit√©) est importante si les ressources forment une hi√©rarchie. <br><br>  Par exemple, un tableau se compose de pages contenant des lignes de tableau.  Tous ces objets peuvent agir comme des ressources.  Si les processus ne sont g√©n√©ralement int√©ress√©s que par quelques lignes et que le verrou est d√©fini au niveau de la table, les autres processus ne pourront pas travailler avec diff√©rentes lignes en m√™me temps.  Par cons√©quent, plus la granularit√© est √©lev√©e, meilleure est la possibilit√© de parall√©lisation. <br><br>  Mais cela conduit √† une augmentation du nombre de verrous (dont les informations doivent √™tre stock√©es en m√©moire).  Dans ce cas, une <em>augmentation du niveau</em> (escalade) des verrous peut √™tre appliqu√©e: lorsque le nombre de verrous granulaires de bas niveau d√©passe une certaine limite, ils sont remplac√©s par un verrou de niveau sup√©rieur. <br></li><li>  Les verrous peuvent √™tre captur√©s dans diff√©rents <strong>modes</strong> . <br><br>  Les noms des modes peuvent √™tre absolument arbitraires, seule la matrice de leur compatibilit√© les uns avec les autres est importante.  Un mode incompatible avec n'importe quel mode (y compris avec lui-m√™me) est g√©n√©ralement appel√© <em>exclusif</em> ou exclusif.  Si les modes sont compatibles, le verrou peut √™tre captur√© par plusieurs processus simultan√©ment;  ces modes sont appel√©s partag√©s.  En g√©n√©ral, plus les modes compatibles les uns avec les autres peuvent √™tre distingu√©s, plus les opportunit√©s de parall√©lisme sont cr√©√©es. <br></li></ul><br>  Selon le temps d'utilisation, les serrures peuvent √™tre divis√©es en longues et courtes. <br><br><ul><li>  <strong>Les</strong> verrous √† <strong>long terme</strong> sont captur√©s pendant une p√©riode potentiellement longue (g√©n√©ralement jusqu'√† la fin de la transaction) et concernent le plus souvent des ressources telles que des tables (relations) et des lignes.  PostgreSQL g√®re g√©n√©ralement ces verrous automatiquement, mais l'utilisateur a n√©anmoins un certain contr√¥le sur ce processus. <br><br>  Les verrouillages longs sont caract√©ris√©s par un grand nombre de modes afin que le plus d'actions simultan√©es possible puissent √™tre effectu√©es sur les donn√©es.  En r√®gle g√©n√©rale, pour de tels verrous, il existe une infrastructure d√©velopp√©e (par exemple, la prise en charge des files d'attente et la d√©tection des interblocages) et des outils de surveillance, car les co√ªts de maintenance de toutes ces commodit√©s sont toujours incomparablement inf√©rieurs au co√ªt des op√©rations sur les donn√©es prot√©g√©es. <br></li><li>  <strong>Les</strong> verrous √† <strong>court terme</strong> sont captur√©s pendant une courte p√©riode (de quelques instructions de processeur √† des fractions de seconde) et font g√©n√©ralement r√©f√©rence √† des structures de donn√©es dans la m√©moire partag√©e.  PostgreSQL g√®re ces verrous de mani√®re enti√®rement automatique - il vous suffit de conna√Ætre leur existence. <br><br>  Les serrures courtes se caract√©risent par un minimum de modes (exclusifs et partag√©s) et une infrastructure simple.  Dans certains cas, m√™me les outils de surveillance peuvent ne pas √™tre disponibles. <br></li></ul><br>  PostgreSQL utilise diff√©rents types de verrous. <br><br>  <strong>Les verrous au niveau de l'objet</strong> sont des <strong>verrous √†</strong> long terme ¬´lourds¬ª.  Les ressources ici sont des relations et d'autres objets.  Si le mot blocage appara√Æt dans le texte sans clarification, alors il d√©signe exactement un tel blocage ¬´normal¬ª. <br><br>  Parmi les verrous √† long terme, les verrous de <strong>niveau ligne</strong> se distinguent s√©par√©ment.  Leur impl√©mentation diff√®re des autres verrous √† long terme en raison de leur nombre potentiellement √©norme (imaginez la mise √† jour d'un million de lignes en une seule transaction).  Ces verrous seront discut√©s dans le prochain article. <br><br>  Le troisi√®me article de la s√©rie sera consacr√© aux verrous restants au niveau de l'objet, ainsi qu'aux <strong>verrous de pr√©dicat</strong> (puisque les informations sur tous ces verrous sont stock√©es dans la RAM de la m√™me mani√®re). <br><br>  Les verrous courts comprennent divers <strong>verrous de structures RAM</strong> .  Nous les examinerons dans le dernier article du cycle. <br><br><h1>  Verrous d'objets </h1><br>  Donc, nous commen√ßons avec des verrous au niveau de l'objet.  Ici, un objet est d'abord compris comme des <em>relations</em> , c'est-√†-dire des tableaux, des index, des s√©quences, des repr√©sentations mat√©rialis√©es, mais aussi d'autres entit√©s.  Ces verrous prot√®gent g√©n√©ralement les objets d'√™tre modifi√©s en m√™me temps ou d'√™tre utilis√©s pendant que l'objet change, mais aussi pour d'autres besoins. <br><br>  Libell√© flou?  C'est parce que les verrous de ce groupe sont utilis√©s √† diverses fins.  Ce qui les unit, c'est la fa√ßon dont ils sont organis√©s. <br><br><h2>  P√©riph√©rique </h2><br>  Les verrous d'objets se trouvent dans la m√©moire partag√©e du serveur.  Leur nombre est limit√© par le produit des valeurs de deux param√®tres: <em>max_locks_per_transaction</em> √ó <em>max_connections</em> . <br><br>  Le pool de verrous est commun √† toutes les transactions, c'est-√†-dire qu'une transaction peut capturer plus de verrous que <em>max_locks_per_transaction</em> : il est seulement important que le nombre total de verrous dans le syst√®me ne d√©passe pas la limite d√©finie.  Le pool est cr√©√© au d√©marrage, donc la modification de l'une des deux options indiqu√©es n√©cessite un red√©marrage du serveur. <br><br>  Tous les verrous peuvent √™tre affich√©s dans la vue pg_locks. <br><br>  Si une ressource est d√©j√† verrouill√©e en mode incompatible, une transaction essayant de capturer cette ressource est mise en file d'attente et attend que le verrou soit lib√©r√©.  Les transactions en attente ne consomment pas de ressources processeur: les processus de service correspondants ¬´s'endorment¬ª et se r√©veillent par le syst√®me d'exploitation lorsque la ressource est lib√©r√©e. <br><br>  Une situation de <em>blocage</em> est possible dans laquelle une transaction n√©cessite une ressource occup√©e par la deuxi√®me transaction pour continuer, et la seconde n√©cessite une ressource occup√©e par la premi√®re (dans le cas g√©n√©ral, un blocage et plus de deux transactions peuvent se produire).  Dans ce cas, l'attente se poursuivra ind√©finiment, donc PostgreSQL d√©tecte automatiquement de telles situations et abandonne l'une des transactions afin que d'autres puissent continuer √† fonctionner.  (Nous parlerons plus des blocages dans le prochain article.) <br><br><h2>  Types d'objets </h2><br>  Voici une liste des types de verrous (ou, si vous le souhaitez, les types d'objets) que nous traiterons dans cet article et le suivant.  Les noms sont donn√©s conform√©ment √† la colonne locktype de la vue pg_locks. <br><br><ul><li>  <strong>relation</strong> <br><br>  Verrous de relation. <br></li><li>  <strong>transactionid</strong> et <strong>virtualxid</strong> <br><br>  Blocage d'un num√©ro de transaction (r√©el ou virtuel).  Chaque transaction elle-m√™me d√©tient un verrou exclusif de son propre num√©ro, de sorte que ces verrous sont pratiques √† utiliser lorsque vous devez attendre la fin d'une autre transaction. <br></li><li>  <strong>tuple</strong> <br><br>  Verrou de version de cha√Æne.  Il est utilis√© dans certains cas pour d√©finir la priorit√© parmi plusieurs transactions qui s'attendent √† verrouiller la m√™me ligne. <br></li></ul><br>  Nous reporterons la discussion des types de verrous restants au troisi√®me article du cycle.  Tous sont captur√©s soit uniquement en mode exceptionnel, soit en mode exclusif et partag√©. <br><br><ul><li>  <strong>√©tendre</strong> <br><br>  Utilis√© lors de l'ajout de pages √† un fichier de toute relation. <br></li><li>  <strong>objet</strong> <br><br>  Verrouillage d'objets qui ne sont pas des relations (bases de donn√©es, sch√©mas, abonnements, etc.). <br></li><li>  <strong>page</strong> <br><br>  Le verrouillage de page est utilis√© rarement et uniquement par certains types d'index. <br></li><li>  <strong>conseil</strong> <br><br>  Blocage recommand√©, d√©fini manuellement par l'utilisateur. <br></li></ul><br><h1>  Verrous de relation </h1><br>  Afin de ne pas perdre le contexte, je marquerai sur une telle image les types de verrous qui seront discut√©s plus tard. <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2>  Les modes </h2><br>  Si ce n'est pas le plus important, alors certainement le blocage le plus ¬´ramifi√©¬ª - les relations de blocage.  Pour elle, jusqu'√† 8 modes diff√©rents sont d√©finis.  Une telle quantit√© est n√©cessaire pour que le plus grand nombre possible d'instructions appartenant √† une table puissent √™tre ex√©cut√©es simultan√©ment. <br><br>  Cela n'a aucun sens d'apprendre ces modes par c≈ìur ou d'essayer de comprendre la signification de leurs noms;  l'essentiel est d'avoir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matrice</a> devant vos yeux au bon moment, qui montre quelles serrures entrent en conflit les unes avec les autres.  Pour plus de commodit√©, il est reproduit ici avec des exemples de commandes qui n√©cessitent des niveaux de verrouillage appropri√©s: <br><br><div class="scrollable-table"><table><tbody><tr><th>  mode de verrouillage </th><th>  Comme </th><th>  RS </th><th>  RE </th><th>  SUE </th><th>  S </th><th>  SRE </th><th>  E </th><th>  Ae </th><th>  exemples de <nobr>commandes SQL</nobr> </th></tr><tr><td>  Partage d'acc√®s </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  SELECT </td></tr><tr><td>  Partage de ligne </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  CHOISIR POUR METTRE √Ä JOUR / PARTAGER </td></tr><tr><td>  Exclusivit√© Row </td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  INS√âRER, METTRE √Ä JOUR, SUPPRIMER </td></tr><tr><td>  Partager la mise √† jour exclusive </td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  VIDE, ALTER TABLE <sup>*</sup> , CR√âER INDEX DE MANI√àRE CONCURRENTE </td></tr><tr><td>  Partagez </td><td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  CR√âER UN INDICE </td></tr><tr><td>  Partager Row Exclusive </td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  CR√âER UN D√âCLENCHEUR, ALTER TABLE <sup>*</sup> </td></tr><tr><td>  Exclusif </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  RAFRA√éCHISSEMENT MAT.  VOIR CONCURRENTEMENT </td></tr><tr><td>  Acc√®s exclusif </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  DROP, TRUNCATE, VIDE PLEIN, LOCK TABLE, ALTER TABLE <sup>*</sup> , RAFRA√éCHISSEMENT MAT.  VOIR </td></tr></tbody></table></div><br>  Quelques commentaires: <br><br><ul><li>  Les 4 premiers modes permettent des changements de donn√©es simultan√©s dans le tableau, et les 4 suivants ne le permettent pas. </li><li>  Le premier mode (Access Share) est le plus faible, il est compatible avec tout autre que le dernier (Access Exclusive).  Ce dernier mode est exclusif, il n'est compatible avec aucun mode. </li><li>  La commande ALTER TABLE poss√®de de nombreuses options, dont diff√©rentes n√©cessitent diff√©rents niveaux de verrouillage.  Par cons√©quent, dans la matrice, cette commande appara√Æt sur diff√©rentes lignes et est marqu√©e d'un ast√©risque. </li></ul><br><h2>  Par exemple, par exemple </h2><br>  donnez un exemple.  Que se passe-t-il si j'ex√©cute la commande CREATE INDEX? <br><br>  Nous constatons dans la documentation que cette commande d√©finit le verrou en mode Partage.  Selon la matrice, nous d√©terminons que la commande est compatible avec elle-m√™me (c'est-√†-dire que vous pouvez cr√©er simultan√©ment plusieurs index) et avec les commandes de lecture.  Ainsi, les commandes SELECT continueront de fonctionner, mais les commandes UPDATE, DELETE, INSERT seront bloqu√©es. <br><br>  Et vice versa - les transactions incompl√®tes qui modifient les donn√©es du tableau bloqueront le fonctionnement de la commande CREATE INDEX.  Par cons√©quent, il existe une variante de la commande - CREATE INDEX CONCURRENTLY.  Cela fonctionne plus longtemps (et peut m√™me tomber avec une erreur), mais permet des changements de donn√©es simultan√©s. <br><br>  Cela se voit dans la pratique.  Pour les exp√©rimentations, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> tableau des comptes ¬´bancaires¬ª familiers du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier cycle</a> , dans lequel nous enregistrerons le num√©ro et le montant du compte. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br>  Dans la deuxi√®me session, d√©marrez la transaction.  Nous avons besoin d'un num√©ro de processus de service. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br>  Quels verrous la nouvelle transaction d√©marre-t-elle?  Nous regardons dans pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br>  Comme je l'ai d√©j√† dit, une transaction contient toujours un verrou exclusif (ExclusiveLock) de son propre num√©ro, dans ce cas, virtuel.  Il n'y a pas d'autres verrous sur ce processus. <br><br>  Mettez √† jour la ligne du tableau.  Comment la situation va-t-elle changer? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br>  Il y a maintenant des verrous sur la table et l'index modifiables (cr√©√©s pour la cl√© primaire), qui sont utilis√©s par la commande UPDATE.  Les deux verrous sont pris en mode RowExclusiveLock.  De plus, un blocage exclusif du num√©ro de transaction r√©el a √©t√© ajout√© (qui est apparu d√®s que la transaction a commenc√© √† modifier les donn√©es). <br><br>  Maintenant, dans une autre session, nous allons essayer de cr√©er un index sur une table. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br>  La commande se bloque en pr√©vision de la lib√©ration de la ressource.  Quel genre de verrou essaie-t-elle de capturer?  V√©rifier: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br>  Nous voyons que la transaction tente d'obtenir le verrou de table en mode ShareLock, mais ne peut pas (accord√© = f). <br><br>  Il est pratique de trouver le num√©ro du processus de blocage, et en g√©n√©ral plusieurs num√©ros, en utilisant la fonction qui est apparue dans la version 9.6 (avant cela, je devais tirer des conclusions en regardant attentivement tout le contenu de pg_locks): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br>  Et puis, pour comprendre la situation, vous pouvez obtenir des informations sur les sessions, notamment les nombres trouv√©s: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br>  Une fois la transaction termin√©e, les verrous sont lib√©r√©s et l'index est cr√©√©. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2>  Dans la file d'attente! .. </h2><br>  Afin de mieux imaginer √† quoi conduit l'apparition d'un verrou incompatible, nous verrons ce qui se passe si la commande VACUUM FULL est ex√©cut√©e pendant le fonctionnement du syst√®me. <br><br>  Laissez la commande SELECT s'ex√©cuter en premier sur notre table.  Elle obtient un verrou sur le niveau le plus faible de partage d'acc√®s.  Pour contr√¥ler le temps de lib√©ration du verrou, nous ex√©cutons cette commande dans la transaction - jusqu'√† la fin de la transaction, le verrou ne sera pas lib√©r√©.  En r√©alit√©, plusieurs commandes peuvent lire (et modifier) ‚Äã‚Äãla table, et certaines requ√™tes peuvent prendre un certain temps. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br>  Ensuite, l'administrateur ex√©cute la commande VACUUM FULL, qui n√©cessite un verrou de niveau Access Exclusive, incompatible avec quoi que ce soit, m√™me avec Access Share.  (La commande LOCK TABLE requiert √©galement le m√™me verrou.) Les files d'attente de transactions. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br>  Mais l'application continue d'√©mettre des demandes, et maintenant la commande SELECT appara√Æt dans le syst√®me.  En th√©orie, elle aurait pu ¬´glisser¬ª pendant que VACUUM FULL attend, mais non - elle prend honn√™tement une place dans la file d'attente pour VACUUM FULL. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br>  Une fois la premi√®re transaction avec la commande SELECT termin√©e et lib√©r√©e, la commande VACUUM FULL commence (que nous avons simul√©e avec la commande LOCK TABLE). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br>  Et ce n'est qu'apr√®s que VACUUM FULL aura termin√© son travail et supprim√© le verrou que toutes les commandes accumul√©es dans la file d'attente (SELECT dans notre exemple) pourront capturer les verrous correspondants (Access Share) et s'ex√©cuter. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br>  Ainsi, une commande inexacte peut paralyser le fonctionnement du syst√®me pendant un temps nettement plus long que le temps d'ex√©cution de la commande elle-m√™me. <br><br><h1>  Outils de surveillance </h1><br>  Bien s√ªr, les verrous sont n√©cessaires pour un fonctionnement correct, mais peuvent conduire √† des attentes ind√©sirables.  Ces attentes peuvent √™tre surveill√©es afin de comprendre leur cause et, si possible, de les √©liminer (par exemple, en changeant l'algorithme d'application). <br><br>  Nous connaissions d√©j√† une m√©thode: au moment d'un long verrou, nous pouvons ex√©cuter une requ√™te sur la vue pg_locks, regarder les transactions verrouillables et bloquantes (fonction pg_blocking_pids) et les d√©crypter en utilisant pg_stat_activity. <br><br>  Une autre fa√ßon consiste √† activer le param√®tre <em>log_lock_waits</em> .  Dans ce cas, des informations appara√Ætront dans le journal des messages du serveur si la transaction a attendu plus longtemps que <em>deadlock_timeout</em> (malgr√© le fait que le param√®tre de deadlocks soit utilis√©, nous parlons d'attentes normales). <br><br>  Essayons. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  La valeur par d√©faut du param√®tre <em>deadlock_timeout</em> est d'une seconde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br>  Jouez la serrure. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La deuxi√®me commande UPDATE attend un verrou.  Attendez une seconde et terminez la premi√®re transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br>  Maintenant, la deuxi√®me transaction peut √™tre effectu√©e. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br>  Et toutes les informations importantes sont entr√©es dans le journal: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462877/">https://habr.com/ru/post/fr462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462859/index.html">Comment une compagnie de bus europ√©enne op√®re en Russie: comment les bus et les passagers diff√®rent</a></li>
<li><a href="../fr462863/index.html">21 ao√ªt a diffus√© le Meetup Zabbix Moscou # 5</a></li>
<li><a href="../fr462867/index.html">Choisir un sch√©ma de couleurs pour votre application: comment le rendre simple?</a></li>
<li><a href="../fr462869/index.html">Syst√®me de gestion de projet Agilean</a></li>
<li><a href="../fr462875/index.html">Comment r√©duire les co√ªts et fournir une assistance informatique optimale pour le mod√®le d'entreprise. Nous recherchons la ¬´voie m√©diane du salut¬ª</a></li>
<li><a href="../fr462879/index.html">Slurm DevOps: de Git √† SRE avec tous les arr√™ts</a></li>
<li><a href="../fr462881/index.html">Pourquoi est-il si difficile de choisir le film √† regarder (et ce qui pourrait √™tre fait)</a></li>
<li><a href="../fr462883/index.html">Conception d'une boutique en ligne pour le r√©f√©rencement: (th√©orie + liste de contr√¥le)</a></li>
<li><a href="../fr462885/index.html">R√©seau IPoE tol√©rant aux pannes √† port√©e de main</a></li>
<li><a href="../fr462887/index.html">L'exp√©rience de la personnalisation d'une boutique en ligne √† l'aide de l'exemple d'une recommandation dynamique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>