<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏿 🚃 🆓 Verrous dans PostgreSQL: 1. Verrous de relation 👩‍👩‍👧 🧗🏼 😊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les deux précédentes séries d'articles se sont concentrées sur l' isolement, le multiversionisme et la journalisation . 

 Dans cette série, nous parl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verrous dans PostgreSQL: 1. Verrous de relation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/">  Les deux précédentes séries d'articles se sont concentrées sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement, le multiversionisme</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journalisation</a> . <br><br>  Dans cette série, nous parlerons des serrures.  J'adhérerai à ce terme, mais dans la littérature il peut aussi y en avoir un autre: <em>château</em> . <br><br>  Le cycle comprendra quatre parties: <br><br><ol><li>  Verrous de relation (cet article); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Serrures de rangées</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Serrures d'autres objets</a> et verrous de prédicat; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Verrous en RAM</a> . </li></ol><br>  Le matériel de tous les articles est basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des cours de formation</a> administrative que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pluzanov</a> et moi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">faisons</a> , mais ne les répètent pas textuellement et sont destinés à une lecture réfléchie et à une expérimentation indépendante. <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1>  Informations générales sur les serrures </h1><br>  PostgreSQL utilise de nombreux mécanismes différents qui sont utilisés pour bloquer quelque chose (ou du moins sont appelés ainsi).  Par conséquent, je vais commencer par les mots les plus généraux expliquant pourquoi les verrous sont nécessaires, ce qu'ils sont et comment ils diffèrent les uns des autres.  Ensuite, nous verrons ce que l'on trouve de cette variété dans PostgreSQL et ce n'est qu'après que nous commencerons à traiter en détail les différents types de verrous. <br><a name="habracut"></a><br>  Les verrous sont utilisés pour rationaliser l'accès simultané aux ressources partagées. <br><br>  L'accès concurrentiel fait référence à l'accès simultané de plusieurs processus.  Les processus eux-mêmes peuvent être effectués à la fois en parallèle (si l'équipement le permet) et séquentiellement en mode de partage de temps - ce n'est pas important. <br><br>  S'il n'y a pas de concurrence, il n'y a pas besoin de verrous (par exemple, un cache de tampon partagé nécessite des verrous, mais pas un local). <br><br>  Avant d'accéder à une ressource, un processus doit acquérir le verrou associé à cette ressource.  Autrement dit, nous parlons d'une certaine discipline: tout fonctionne tant que tous les processus sont conformes aux règles établies pour accéder à une ressource partagée.  Si le SGBD gère les verrous, il surveille lui-même la commande;  si le blocage est fixé par l'application, cette obligation lui incombe. <br><br>  À un niveau bas, un verrou est représenté par une section de mémoire partagée, dans laquelle il est noté d'une certaine manière si le verrou est libre ou capturé (et, éventuellement, des informations supplémentaires sont enregistrées: numéro de processus, temps de capture, etc.). <br><br><blockquote>  Vous remarquerez peut-être qu'un tel morceau de mémoire partagée est en soi une ressource à laquelle un accès concurrentiel est possible.  Si nous descendons un niveau plus bas, nous verrons que les primitives accessoires spéciales (telles que les sémaphores ou les mutex) fournies par le système d'exploitation sont utilisées pour organiser l'accès.  Leur signification est que le code accédant à la ressource partagée doit être exécuté en un seul processus à la fois.  Au niveau le plus bas, ces primitives sont implémentées sur la base des instructions du processeur atomique (telles que test-and-set ou compare-and-swap). <br></blockquote><br>  Une fois que la ressource n'est plus nécessaire au processus, elle <em>libère le</em> verrou pour que d'autres puissent l'utiliser. <br><br>  Bien sûr, le verrouillage du verrou n'est pas toujours possible: la ressource peut déjà être prise par quelqu'un d'autre.  Ensuite, le processus entre dans la file d'attente (si le mécanisme de verrouillage donne cette possibilité), ou réessaye de capturer le verrou après un certain temps.  D'une manière ou d'une autre, cela conduit au fait que le processus est obligé de rester inactif en prévision de la libération de la ressource. <br><br><blockquote>  Il est parfois possible d'appliquer d'autres stratégies non bloquantes.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mécanisme de multi-</a> version permet à plusieurs processus dans certains cas de fonctionner simultanément avec différentes versions de données sans se bloquer les uns les autres. <br></blockquote><br>  En principe, une ressource protégée peut être n'importe quoi, si seulement cette ressource pouvait être identifiée sans ambiguïté et mise en correspondance avec une adresse de blocage. <br><br>  Par exemple, la ressource peut être l'objet avec lequel le SGBD travaille, comme une page de données (identifiée par le nom et la position du fichier dans le fichier), une table (oid dans le répertoire système), une ligne de table (page et décalage à l'intérieur de la page).  Une ressource peut être une structure en mémoire, telle qu'une table de hachage, un tampon, etc. (identifiée par un numéro pré-attribué).  Parfois, il est même pratique d'utiliser des ressources abstraites qui n'ont aucune signification physique (elles sont identifiées simplement par un numéro unique). <br><br>  L'efficacité des serrures est influencée par de nombreux facteurs, dont nous distinguons deux. <br><br><ul><li>  <strong>La</strong> granularité (granularité) est importante si les ressources forment une hiérarchie. <br><br>  Par exemple, un tableau se compose de pages contenant des lignes de tableau.  Tous ces objets peuvent agir comme des ressources.  Si les processus ne sont généralement intéressés que par quelques lignes et que le verrou est défini au niveau de la table, les autres processus ne pourront pas travailler avec différentes lignes en même temps.  Par conséquent, plus la granularité est élevée, meilleure est la possibilité de parallélisation. <br><br>  Mais cela conduit à une augmentation du nombre de verrous (dont les informations doivent être stockées en mémoire).  Dans ce cas, une <em>augmentation du niveau</em> (escalade) des verrous peut être appliquée: lorsque le nombre de verrous granulaires de bas niveau dépasse une certaine limite, ils sont remplacés par un verrou de niveau supérieur. <br></li><li>  Les verrous peuvent être capturés dans différents <strong>modes</strong> . <br><br>  Les noms des modes peuvent être absolument arbitraires, seule la matrice de leur compatibilité les uns avec les autres est importante.  Un mode incompatible avec n'importe quel mode (y compris avec lui-même) est généralement appelé <em>exclusif</em> ou exclusif.  Si les modes sont compatibles, le verrou peut être capturé par plusieurs processus simultanément;  ces modes sont appelés partagés.  En général, plus les modes compatibles les uns avec les autres peuvent être distingués, plus les opportunités de parallélisme sont créées. <br></li></ul><br>  Selon le temps d'utilisation, les serrures peuvent être divisées en longues et courtes. <br><br><ul><li>  <strong>Les</strong> verrous à <strong>long terme</strong> sont capturés pendant une période potentiellement longue (généralement jusqu'à la fin de la transaction) et concernent le plus souvent des ressources telles que des tables (relations) et des lignes.  PostgreSQL gère généralement ces verrous automatiquement, mais l'utilisateur a néanmoins un certain contrôle sur ce processus. <br><br>  Les verrouillages longs sont caractérisés par un grand nombre de modes afin que le plus d'actions simultanées possible puissent être effectuées sur les données.  En règle générale, pour de tels verrous, il existe une infrastructure développée (par exemple, la prise en charge des files d'attente et la détection des interblocages) et des outils de surveillance, car les coûts de maintenance de toutes ces commodités sont toujours incomparablement inférieurs au coût des opérations sur les données protégées. <br></li><li>  <strong>Les</strong> verrous à <strong>court terme</strong> sont capturés pendant une courte période (de quelques instructions de processeur à des fractions de seconde) et font généralement référence à des structures de données dans la mémoire partagée.  PostgreSQL gère ces verrous de manière entièrement automatique - il vous suffit de connaître leur existence. <br><br>  Les serrures courtes se caractérisent par un minimum de modes (exclusifs et partagés) et une infrastructure simple.  Dans certains cas, même les outils de surveillance peuvent ne pas être disponibles. <br></li></ul><br>  PostgreSQL utilise différents types de verrous. <br><br>  <strong>Les verrous au niveau de l'objet</strong> sont des <strong>verrous à</strong> long terme «lourds».  Les ressources ici sont des relations et d'autres objets.  Si le mot blocage apparaît dans le texte sans clarification, alors il désigne exactement un tel blocage «normal». <br><br>  Parmi les verrous à long terme, les verrous de <strong>niveau ligne</strong> se distinguent séparément.  Leur implémentation diffère des autres verrous à long terme en raison de leur nombre potentiellement énorme (imaginez la mise à jour d'un million de lignes en une seule transaction).  Ces verrous seront discutés dans le prochain article. <br><br>  Le troisième article de la série sera consacré aux verrous restants au niveau de l'objet, ainsi qu'aux <strong>verrous de prédicat</strong> (puisque les informations sur tous ces verrous sont stockées dans la RAM de la même manière). <br><br>  Les verrous courts comprennent divers <strong>verrous de structures RAM</strong> .  Nous les examinerons dans le dernier article du cycle. <br><br><h1>  Verrous d'objets </h1><br>  Donc, nous commençons avec des verrous au niveau de l'objet.  Ici, un objet est d'abord compris comme des <em>relations</em> , c'est-à-dire des tableaux, des index, des séquences, des représentations matérialisées, mais aussi d'autres entités.  Ces verrous protègent généralement les objets d'être modifiés en même temps ou d'être utilisés pendant que l'objet change, mais aussi pour d'autres besoins. <br><br>  Libellé flou?  C'est parce que les verrous de ce groupe sont utilisés à diverses fins.  Ce qui les unit, c'est la façon dont ils sont organisés. <br><br><h2>  Périphérique </h2><br>  Les verrous d'objets se trouvent dans la mémoire partagée du serveur.  Leur nombre est limité par le produit des valeurs de deux paramètres: <em>max_locks_per_transaction</em> × <em>max_connections</em> . <br><br>  Le pool de verrous est commun à toutes les transactions, c'est-à-dire qu'une transaction peut capturer plus de verrous que <em>max_locks_per_transaction</em> : il est seulement important que le nombre total de verrous dans le système ne dépasse pas la limite définie.  Le pool est créé au démarrage, donc la modification de l'une des deux options indiquées nécessite un redémarrage du serveur. <br><br>  Tous les verrous peuvent être affichés dans la vue pg_locks. <br><br>  Si une ressource est déjà verrouillée en mode incompatible, une transaction essayant de capturer cette ressource est mise en file d'attente et attend que le verrou soit libéré.  Les transactions en attente ne consomment pas de ressources processeur: les processus de service correspondants «s'endorment» et se réveillent par le système d'exploitation lorsque la ressource est libérée. <br><br>  Une situation de <em>blocage</em> est possible dans laquelle une transaction nécessite une ressource occupée par la deuxième transaction pour continuer, et la seconde nécessite une ressource occupée par la première (dans le cas général, un blocage et plus de deux transactions peuvent se produire).  Dans ce cas, l'attente se poursuivra indéfiniment, donc PostgreSQL détecte automatiquement de telles situations et abandonne l'une des transactions afin que d'autres puissent continuer à fonctionner.  (Nous parlerons plus des blocages dans le prochain article.) <br><br><h2>  Types d'objets </h2><br>  Voici une liste des types de verrous (ou, si vous le souhaitez, les types d'objets) que nous traiterons dans cet article et le suivant.  Les noms sont donnés conformément à la colonne locktype de la vue pg_locks. <br><br><ul><li>  <strong>relation</strong> <br><br>  Verrous de relation. <br></li><li>  <strong>transactionid</strong> et <strong>virtualxid</strong> <br><br>  Blocage d'un numéro de transaction (réel ou virtuel).  Chaque transaction elle-même détient un verrou exclusif de son propre numéro, de sorte que ces verrous sont pratiques à utiliser lorsque vous devez attendre la fin d'une autre transaction. <br></li><li>  <strong>tuple</strong> <br><br>  Verrou de version de chaîne.  Il est utilisé dans certains cas pour définir la priorité parmi plusieurs transactions qui s'attendent à verrouiller la même ligne. <br></li></ul><br>  Nous reporterons la discussion des types de verrous restants au troisième article du cycle.  Tous sont capturés soit uniquement en mode exceptionnel, soit en mode exclusif et partagé. <br><br><ul><li>  <strong>étendre</strong> <br><br>  Utilisé lors de l'ajout de pages à un fichier de toute relation. <br></li><li>  <strong>objet</strong> <br><br>  Verrouillage d'objets qui ne sont pas des relations (bases de données, schémas, abonnements, etc.). <br></li><li>  <strong>page</strong> <br><br>  Le verrouillage de page est utilisé rarement et uniquement par certains types d'index. <br></li><li>  <strong>conseil</strong> <br><br>  Blocage recommandé, défini manuellement par l'utilisateur. <br></li></ul><br><h1>  Verrous de relation </h1><br>  Afin de ne pas perdre le contexte, je marquerai sur une telle image les types de verrous qui seront discutés plus tard. <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2>  Les modes </h2><br>  Si ce n'est pas le plus important, alors certainement le blocage le plus «ramifié» - les relations de blocage.  Pour elle, jusqu'à 8 modes différents sont définis.  Une telle quantité est nécessaire pour que le plus grand nombre possible d'instructions appartenant à une table puissent être exécutées simultanément. <br><br>  Cela n'a aucun sens d'apprendre ces modes par cœur ou d'essayer de comprendre la signification de leurs noms;  l'essentiel est d'avoir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matrice</a> devant vos yeux au bon moment, qui montre quelles serrures entrent en conflit les unes avec les autres.  Pour plus de commodité, il est reproduit ici avec des exemples de commandes qui nécessitent des niveaux de verrouillage appropriés: <br><br><div class="scrollable-table"><table><tbody><tr><th>  mode de verrouillage </th><th>  Comme </th><th>  RS </th><th>  RE </th><th>  SUE </th><th>  S </th><th>  SRE </th><th>  E </th><th>  Ae </th><th>  exemples de <nobr>commandes SQL</nobr> </th></tr><tr><td>  Partage d'accès </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  SELECT </td></tr><tr><td>  Partage de ligne </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  CHOISIR POUR METTRE À JOUR / PARTAGER </td></tr><tr><td>  Exclusivité Row </td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  INSÉRER, METTRE À JOUR, SUPPRIMER </td></tr><tr><td>  Partager la mise à jour exclusive </td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  VIDE, ALTER TABLE <sup>*</sup> , CRÉER INDEX DE MANIÈRE CONCURRENTE </td></tr><tr><td>  Partagez </td><td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  CRÉER UN INDICE </td></tr><tr><td>  Partager Row Exclusive </td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  CRÉER UN DÉCLENCHEUR, ALTER TABLE <sup>*</sup> </td></tr><tr><td>  Exclusif </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  RAFRAÎCHISSEMENT MAT.  VOIR CONCURRENTEMENT </td></tr><tr><td>  Accès exclusif </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  DROP, TRUNCATE, VIDE PLEIN, LOCK TABLE, ALTER TABLE <sup>*</sup> , RAFRAÎCHISSEMENT MAT.  VOIR </td></tr></tbody></table></div><br>  Quelques commentaires: <br><br><ul><li>  Les 4 premiers modes permettent des changements de données simultanés dans le tableau, et les 4 suivants ne le permettent pas. </li><li>  Le premier mode (Access Share) est le plus faible, il est compatible avec tout autre que le dernier (Access Exclusive).  Ce dernier mode est exclusif, il n'est compatible avec aucun mode. </li><li>  La commande ALTER TABLE possède de nombreuses options, dont différentes nécessitent différents niveaux de verrouillage.  Par conséquent, dans la matrice, cette commande apparaît sur différentes lignes et est marquée d'un astérisque. </li></ul><br><h2>  Par exemple, par exemple </h2><br>  donnez un exemple.  Que se passe-t-il si j'exécute la commande CREATE INDEX? <br><br>  Nous constatons dans la documentation que cette commande définit le verrou en mode Partage.  Selon la matrice, nous déterminons que la commande est compatible avec elle-même (c'est-à-dire que vous pouvez créer simultanément plusieurs index) et avec les commandes de lecture.  Ainsi, les commandes SELECT continueront de fonctionner, mais les commandes UPDATE, DELETE, INSERT seront bloquées. <br><br>  Et vice versa - les transactions incomplètes qui modifient les données du tableau bloqueront le fonctionnement de la commande CREATE INDEX.  Par conséquent, il existe une variante de la commande - CREATE INDEX CONCURRENTLY.  Cela fonctionne plus longtemps (et peut même tomber avec une erreur), mais permet des changements de données simultanés. <br><br>  Cela se voit dans la pratique.  Pour les expérimentations, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> tableau des comptes «bancaires» familiers du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier cycle</a> , dans lequel nous enregistrerons le numéro et le montant du compte. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br>  Dans la deuxième session, démarrez la transaction.  Nous avons besoin d'un numéro de processus de service. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br>  Quels verrous la nouvelle transaction démarre-t-elle?  Nous regardons dans pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br>  Comme je l'ai déjà dit, une transaction contient toujours un verrou exclusif (ExclusiveLock) de son propre numéro, dans ce cas, virtuel.  Il n'y a pas d'autres verrous sur ce processus. <br><br>  Mettez à jour la ligne du tableau.  Comment la situation va-t-elle changer? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br>  Il y a maintenant des verrous sur la table et l'index modifiables (créés pour la clé primaire), qui sont utilisés par la commande UPDATE.  Les deux verrous sont pris en mode RowExclusiveLock.  De plus, un blocage exclusif du numéro de transaction réel a été ajouté (qui est apparu dès que la transaction a commencé à modifier les données). <br><br>  Maintenant, dans une autre session, nous allons essayer de créer un index sur une table. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br>  La commande se bloque en prévision de la libération de la ressource.  Quel genre de verrou essaie-t-elle de capturer?  Vérifier: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br>  Nous voyons que la transaction tente d'obtenir le verrou de table en mode ShareLock, mais ne peut pas (accordé = f). <br><br>  Il est pratique de trouver le numéro du processus de blocage, et en général plusieurs numéros, en utilisant la fonction qui est apparue dans la version 9.6 (avant cela, je devais tirer des conclusions en regardant attentivement tout le contenu de pg_locks): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br>  Et puis, pour comprendre la situation, vous pouvez obtenir des informations sur les sessions, notamment les nombres trouvés: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br>  Une fois la transaction terminée, les verrous sont libérés et l'index est créé. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2>  Dans la file d'attente! .. </h2><br>  Afin de mieux imaginer à quoi conduit l'apparition d'un verrou incompatible, nous verrons ce qui se passe si la commande VACUUM FULL est exécutée pendant le fonctionnement du système. <br><br>  Laissez la commande SELECT s'exécuter en premier sur notre table.  Elle obtient un verrou sur le niveau le plus faible de partage d'accès.  Pour contrôler le temps de libération du verrou, nous exécutons cette commande dans la transaction - jusqu'à la fin de la transaction, le verrou ne sera pas libéré.  En réalité, plusieurs commandes peuvent lire (et modifier) ​​la table, et certaines requêtes peuvent prendre un certain temps. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br>  Ensuite, l'administrateur exécute la commande VACUUM FULL, qui nécessite un verrou de niveau Access Exclusive, incompatible avec quoi que ce soit, même avec Access Share.  (La commande LOCK TABLE requiert également le même verrou.) Les files d'attente de transactions. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br>  Mais l'application continue d'émettre des demandes, et maintenant la commande SELECT apparaît dans le système.  En théorie, elle aurait pu «glisser» pendant que VACUUM FULL attend, mais non - elle prend honnêtement une place dans la file d'attente pour VACUUM FULL. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br>  Une fois la première transaction avec la commande SELECT terminée et libérée, la commande VACUUM FULL commence (que nous avons simulée avec la commande LOCK TABLE). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br>  Et ce n'est qu'après que VACUUM FULL aura terminé son travail et supprimé le verrou que toutes les commandes accumulées dans la file d'attente (SELECT dans notre exemple) pourront capturer les verrous correspondants (Access Share) et s'exécuter. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br>  Ainsi, une commande inexacte peut paralyser le fonctionnement du système pendant un temps nettement plus long que le temps d'exécution de la commande elle-même. <br><br><h1>  Outils de surveillance </h1><br>  Bien sûr, les verrous sont nécessaires pour un fonctionnement correct, mais peuvent conduire à des attentes indésirables.  Ces attentes peuvent être surveillées afin de comprendre leur cause et, si possible, de les éliminer (par exemple, en changeant l'algorithme d'application). <br><br>  Nous connaissions déjà une méthode: au moment d'un long verrou, nous pouvons exécuter une requête sur la vue pg_locks, regarder les transactions verrouillables et bloquantes (fonction pg_blocking_pids) et les décrypter en utilisant pg_stat_activity. <br><br>  Une autre façon consiste à activer le paramètre <em>log_lock_waits</em> .  Dans ce cas, des informations apparaîtront dans le journal des messages du serveur si la transaction a attendu plus longtemps que <em>deadlock_timeout</em> (malgré le fait que le paramètre de deadlocks soit utilisé, nous parlons d'attentes normales). <br><br>  Essayons. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  La valeur par défaut du paramètre <em>deadlock_timeout</em> est d'une seconde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br>  Jouez la serrure. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La deuxième commande UPDATE attend un verrou.  Attendez une seconde et terminez la première transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br>  Maintenant, la deuxième transaction peut être effectuée. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br>  Et toutes les informations importantes sont entrées dans le journal: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462877/">https://habr.com/ru/post/fr462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462859/index.html">Comment une compagnie de bus européenne opère en Russie: comment les bus et les passagers diffèrent</a></li>
<li><a href="../fr462863/index.html">21 août a diffusé le Meetup Zabbix Moscou # 5</a></li>
<li><a href="../fr462867/index.html">Choisir un schéma de couleurs pour votre application: comment le rendre simple?</a></li>
<li><a href="../fr462869/index.html">Système de gestion de projet Agilean</a></li>
<li><a href="../fr462875/index.html">Comment réduire les coûts et fournir une assistance informatique optimale pour le modèle d'entreprise. Nous recherchons la «voie médiane du salut»</a></li>
<li><a href="../fr462879/index.html">Slurm DevOps: de Git à SRE avec tous les arrêts</a></li>
<li><a href="../fr462881/index.html">Pourquoi est-il si difficile de choisir le film à regarder (et ce qui pourrait être fait)</a></li>
<li><a href="../fr462883/index.html">Conception d'une boutique en ligne pour le référencement: (théorie + liste de contrôle)</a></li>
<li><a href="../fr462885/index.html">Réseau IPoE tolérant aux pannes à portée de main</a></li>
<li><a href="../fr462887/index.html">L'expérience de la personnalisation d'une boutique en ligne à l'aide de l'exemple d'une recommandation dynamique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>