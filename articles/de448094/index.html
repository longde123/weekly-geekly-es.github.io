<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèæ üê™ ü¶à Docker: So stellen Sie eine Full-Stack-Anwendung bereit und werden nicht grau üë®üèº‚Äçü§ù‚Äçüë®üèª üÜë üèáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Wir brauchen DevOps!" 
 (die beliebteste Phrase am Ende eines Hackathons) 

 Zuerst einige Texte. 

 Wenn ein Entwickler ein ausgezeichneter Entwickl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: So stellen Sie eine Full-Stack-Anwendung bereit und werden nicht grau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448094/"> <i>"Wir brauchen DevOps!"</i> <br>  <i>(die beliebteste Phrase am Ende eines Hackathons)</i> <br><img src="https://habrastorage.org/webt/yy/k1/0q/yyk10qsi8ayqzxsnwqua1nwyzrk.jpeg"><br>  Zuerst einige Texte. <br><br>  Wenn ein Entwickler ein ausgezeichneter Entwickler ist, der seine Idee auf jedem Computer unter jedem OK einsetzen kann, ist dies ein Plus.  Wenn er jedoch nichts weiter als seine IDE versteht, ist dies kein Minus - am Ende wird er f√ºr den Code bezahlt und nicht f√ºr die F√§higkeit, ihn bereitzustellen.  Ein enger, tiefer Spezialist auf dem Markt wird h√∂her bewertet als die durchschnittliche F√§higkeit eines "Allesk√∂nners".  F√ºr Leute wie uns, "IDE-Benutzer", haben sich gute Leute Docker ausgedacht. <br><br>  Das Prinzip von Docker lautet wie folgt: "Es funktioniert f√ºr mich - es funktioniert √ºberall."  Das einzige Programm, das zum Bereitstellen einer Kopie Ihrer Anwendung ben√∂tigt wird, ist Docker.  Wenn Sie Ihre Anwendung im Docker auf Ihrem Computer ausf√ºhren, wird sie garantiert mit demselben Erfolg in jedem anderen Docker ausgef√ºhrt.  Und nichts als ein Docker muss installiert werden.  Zum Beispiel habe ich nicht einmal Java auf dem virtuellen Server. <a name="habracut"></a><br><br><h2>  Wie funktioniert Docker? </h2><br>  Docker erstellt ein Image einer virtuellen Maschine mit darin installierten Anwendungen.  Dar√ºber hinaus entfaltet sich dieses Image als vollst√§ndig autonome virtuelle Maschine.  Eine laufende Kopie des Bildes wird als "Container" bezeichnet.  Sie k√∂nnen beliebig viele Images auf dem Server ausf√ºhren. Jedes dieser Images ist eine separate virtuelle Maschine mit einer eigenen Umgebung. <br><br>  Was ist eine virtuelle Maschine?  Dies ist der gekapselte Speicherort auf dem Server mit dem Betriebssystem, auf dem die Anwendungen installiert sind.  In jedem Betriebssystem dreht sich normalerweise eine gro√üe Anzahl von Anwendungen, in unserem gibt es eine. <br><br>  Das Containerbereitstellungsschema kann wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/9p/vq/ya/9pvqyam6ckaxqvihopwdoynhf4y.jpeg"><br><br>  F√ºr jede Anwendung erstellen wir ein eigenes Image und stellen dann jeden Container separat bereit.  Sie k√∂nnen auch alle Anwendungen in einem Image zusammenfassen und als einen Container bereitstellen.  Um nicht jeden Container separat bereitzustellen, k√∂nnen wir au√üerdem ein separates Docker-Compose-Dienstprogramm verwenden, das die Container und die Beziehung zwischen ihnen √ºber eine separate Datei konfiguriert.  Dann kann die Struktur der gesamten Anwendung folgenderma√üen aussehen: <br><br><img src="https://habrastorage.org/webt/ga/ft/fm/gaftfmbyumgesqldxv1pphh6ati.jpeg"><br><br>  Ich habe die Datenbank aus mehreren Gr√ºnden absichtlich nicht zur allgemeinen Docker-Versammlung beigetragen.  Erstens ist die Datenbank v√∂llig unabh√§ngig von den Anwendungen, die damit arbeiten.  Es kann weit von einer Anwendung entfernt sein, es k√∂nnen manuelle Anforderungen von der Konsole sein.  Pers√∂nlich sehe ich keinen Grund, die Datenbank von der Docker-Assembly abh√§ngig zu machen, in der sie sich befindet.  Deshalb habe ich es ertragen.  Es wird jedoch h√§ufig ein Ansatz praktiziert, bei dem die Datenbank in einem separaten Image platziert und in einem separaten Container gestartet wird.  Zweitens m√∂chte ich zeigen, wie der Docker-Container mit Systemen au√üerhalb des Containers interagiert. <br><br>  Lassen Sie uns jedoch den Code schreiben.  Wir werden die einfachste Anwendung im Fr√ºhjahr schreiben und reagieren, wodurch unsere Anrufe nach vorne in die Datenbank aufgenommen werden, und wir werden all dies √ºber Docker aufheben.  Die Struktur unserer Anwendung sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/k4/pp/lg/k4pplgvwba46vygymrasjctmrkm.jpeg"><br><br>  Es gibt viele M√∂glichkeiten, eine solche Struktur zu implementieren.  Wir implementieren eine davon.  Wir werden zwei Images erstellen, zwei Container daraus starten und das Backend wird eine Verbindung zu der Datenbank herstellen, die auf einem bestimmten Server irgendwo im Internet installiert ist (ja, solche Datenbankabfragen werden nicht schnell gehen, aber wir werden nicht vom Durst nach Optimierung getrieben, aber wissenschaftliches Interesse). <br><br>  Der Beitrag wird in Teile geteilt: <br><br>  0. Installieren Sie Docker. <br>  1. Wir schreiben Bewerbungen. <br>  2. Wir sammeln Bilder und starten Container. <br>  3. Sammeln Sie Bilder und starten Sie Container auf einem Remote-Server. <br>  4. L√∂sen Sie Netzwerkprobleme. <br><br><h2>  0. Installieren Sie Docker </h2><br>  Um Docker zu installieren, m√ºssen Sie auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site</a> gehen und den dort beschriebenen Anweisungen folgen.  Beachten Sie bei der Installation von Docker auf einem Remote-Server, dass Docker m√∂glicherweise nicht mit Servern unter OpenVZ funktioniert.  Au√üerdem k√∂nnen Probleme auftreten, wenn Sie iptables nicht aktiviert haben.  Es wird empfohlen, den Server auf KVM mit iptables zu starten.  Aber das sind meine Empfehlungen.  Wenn alles f√ºr Sie funktioniert und ich bin froh, dass Sie nicht viel Zeit damit verbracht haben, herauszufinden, warum es nicht funktioniert, wie ich es tun musste. <br><br><h2>  1. Wir schreiben Bewerbungen </h2><br>  Schreiben wir eine einfache Anwendung mit dem primitivsten Backend f√ºr Spring Boot, einem sehr einfachen Frontend f√ºr ReactJS und einer MySQL-Datenbank.  Die Anwendung verf√ºgt √ºber eine einzelne Seite mit einer einzelnen Schaltfl√§che, die die Zeit aufzeichnet, zu der in der Datenbank darauf geklickt wurde. <br><br>  Ich verlasse mich auf die Tatsache, dass Sie bereits wissen, wie man Anwendungen beim Booten schreibt, aber wenn nicht, k√∂nnen Sie das fertige Projekt klonen.  Alle Links am Ende des Artikels. <br><br><h3>  Backend auf Spring Boot </h3><br>  build.gradle: <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.4.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.2'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'mysql:mysql-connector-java'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Protokollentit√§t: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.annotation.JsonFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Serializable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.LocalDateTime; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Objects; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 21:20 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"request_logs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Log</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime created; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-meta"><span class="hljs-meta">@JsonFormat</span></span>(shape = JsonFormat.Shape.STRING, pattern = <span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> created; } <span class="hljs-meta"><span class="hljs-meta">@PrePersist</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prePersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.created = LocalDateTime.now(); } <span class="hljs-comment"><span class="hljs-comment">//setters, toString, equals, hashcode, constructors</span></span></code> </pre> <br>  LogController, der mit vereinfachter Logik arbeitet und sofort in die Datenbank schreibt.  Wir lassen den Service aus. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.controller; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.core.JsonProcessingException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.databind.ObjectMapper; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.beans.factory.annotation.Autowired; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.http.ResponseEntity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RequestMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.entity.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.repository.LogRepository; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.logging.Logger; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 22:24 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/log"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOG = Logger.getLogger(LogController.class.getName()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LogRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LogRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ResponseEntity&lt;Log&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log log = repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Log()); LOG.info(<span class="hljs-string"><span class="hljs-string">"saved new log: "</span></span> + log.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResponseEntity.ok(log); } }</code> </pre><br>  Alles ist, wie wir sehen, sehr einfach.  Durch eine GET-Anfrage schreiben wir in die Datenbank und geben das Ergebnis zur√ºck. <br><br>  Wir werden die Anwendungseinstellungsdatei separat diskutieren.  Es gibt zwei von ihnen. <br><br>  application.yml: <br><br><pre> <code class="java hljs">spring: profiles: active: remote</code> </pre> <br>  application-remote.yml: <br><br><pre> <code class="java hljs">spring: datasource: driver-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cj</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">database</span></span></span><span class="hljs-class">:3306/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebounder_database</span></span></span><span class="hljs-class">?</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useUnicode</span></span></span></span>=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useJDBCCompliantTimezoneShift=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useLegacyDatetimeCode=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>&amp;serverTimezone=UTC username: admin password: <span class="hljs-number"><span class="hljs-number">12345</span></span> jpa: hibernate: ddl-auto: update show-sql: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> properties: hibernate.dialect: org.hibernate.dialect.MySQL5Dialect server: port: <span class="hljs-number"><span class="hljs-number">8099</span></span></code> </pre> <br>  Wie dies funktioniert, wissen Sie wahrscheinlich, dass Spring zuerst die Datei application.properties oder application.yml scannt - welche gefunden wird.  Darin geben wir eine einzelne Einstellung an - welches Profil wir verwenden werden.  Normalerweise sammle ich w√§hrend der Entwicklung mehrere Profile und es ist sehr praktisch, sie mit dem Standardprofil zu wechseln.  Als N√§chstes findet Spring application.yml mit dem gew√ºnschten Suffix und verwendet es. <br><br>  Wir haben die Datenquelle, die JPA-Einstellungen und vor allem den externen Port unseres Backends angegeben. <br><br><h3>  ReactJS Frontend </h3><br>  Sie k√∂nnen das Frontend auch in einem Projekt auf Git sehen, oder Sie k√∂nnen es sogar nicht ansehen, sondern klonen und ausf√ºhren. <br><br>  Sie k√∂nnen die einzelnen Arbeiten des Frontends √ºberpr√ºfen, indem Sie das Projekt herunterladen, in den Projektstammordner im Terminal (wo sich die Datei package.json befindet) wechseln und zwei Befehle nacheinander ausf√ºhren: <br><br><pre> <code class="bash hljs">npm install //      ,  maven npm start //  </code> </pre> <br>  Dazu ben√∂tigen Sie nat√ºrlich den installierten Node Package Manager (npm), und dies ist der schwierigste Weg, den wir vermeiden, Docker zu verwenden.  Wenn Sie das Projekt noch gestartet haben, wird das folgende Fenster angezeigt: <br><br><img src="https://habrastorage.org/webt/aq/m7/t4/aqm7t4txa2g_rqbuswo3uiibjpq.png"><br><br>  Na ja, es ist Zeit, sich den Code anzusehen.  Ich werde nur den Teil angeben, der sich auf das Backend bezieht. <br><br><pre> <code class="java hljs">export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ _apiPath = <span class="hljs-string"><span class="hljs-string">'http://localhost:8099'</span></span>; _logUrl = <span class="hljs-string"><span class="hljs-string">'/log'</span></span>; getResource = async () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(`${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._apiPath}${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._logUrl}`)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res.ok) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(`Could not fetch ${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._logUrl}` + `, received ${res.status}`) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await res.json(); }; };</code> </pre> <br>  Das Frontend funktioniert vorhersehbar.  Wir folgen dem Link, warten auf die Antwort und zeigen sie auf dem Bildschirm an. <br><br><img src="https://habrastorage.org/webt/xz/vy/qd/xzvyqdrh7akd1c1flu-gnjhcxok.png"><br><br>  Es lohnt sich, sich auf folgende Punkte zu konzentrieren: <br><br><ol><li>  Die Front ist √ºber Port 3000 nach au√üen offen. Dies ist der Standardport f√ºr React. </li><li>  Die R√ºckseite wird an Port 8099 ge√∂ffnet. Wir haben sie in den Anwendungseinstellungen festgelegt. </li><li>  Der R√ºcken klopft √ºber das externe Internet an die Datenbank. </li></ol><br>  Die Anwendung ist fertig. <br><br><h2>  2. Sammeln Sie Bilder und starten Sie Container </h2><br>  Die Struktur unserer Versammlung wird wie folgt sein.  Wir werden zwei Images erstellen - Frontend und Backend, die √ºber externe Ports miteinander kommunizieren.  F√ºr die Basis erstellen wir kein Image, sondern installieren es separat.  Warum so?  Warum erstellen wir kein Bild f√ºr die Basis?  Wir haben zwei Anwendungen, die sich st√§ndig √§ndern und keine Daten in uns selbst speichern.  Die Datenbank speichert Daten in sich selbst. Dies kann das Ergebnis eines mehrmonatigen Anwendungsbetriebs sein.  Dar√ºber hinaus kann auf diese Datenbank nicht nur von unserer Backend-Anwendung, sondern auch von vielen anderen zugegriffen werden - daf√ºr handelt es sich auch um eine Datenbank, und wir werden sie nicht st√§ndig neu zusammenstellen.  Auch dies ist eine Gelegenheit, mit einer externen API zu arbeiten, die nat√ºrlich darin besteht, eine Verbindung zu unserer Datenbank herzustellen. <br><br><h4>  Front-End-Baugruppe </h4><br>  Um jede Anwendung (vorne oder hinten) auszuf√ºhren, ben√∂tigen Sie eine bestimmte Abfolge von Aktionen.  Um die Anwendung unter React auszuf√ºhren, m√ºssen wir Folgendes tun (vorausgesetzt, wir haben bereits Linux): <br><br><ol><li>  Installieren Sie NodeJS. </li><li>  Kopieren Sie die Anwendung in einen bestimmten Ordner. </li><li>  Installieren Sie die erforderlichen Pakete (Befehl npm install). </li><li>  Starten Sie die Anwendung mit dem Befehl npm start. </li></ol><br>  Es ist diese Abfolge von Aktionen, die wir im Docker ausf√ºhren m√ºssen.  Dazu m√ºssen wir im Stammverzeichnis des Projekts (an derselben Stelle wie package.json) die Docker-Datei mit den folgenden Inhalten platzieren: <br><br><pre> <code class="javascript hljs">FROM node:alpine WORKDIR /usr/app/front EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span> COPY ./ ./ RUN npm install CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Mal sehen, was jede Zeile bedeutet. <br><br><pre> <code class="javascript hljs">FROM node:alpine</code> </pre> <br>  Mit dieser Zeile machen wir dem Docker klar, dass Sie beim Starten des Containers zun√§chst Docker aus dem Repository herunterladen und NodeJS installieren m√ºssen, und zwar die leichteste (alle leichtesten Versionen g√§ngiger Frameworks und Bibliotheken im Docker werden normalerweise als alpin bezeichnet). <br><br><pre> <code class="javascript hljs">WORKDIR /usr/app/front</code> </pre> <br>  Im Linux-Container werden dieselben Standardordner erstellt wie in anderen Linux-Ordnern - / opt, / home, / etc, / usr usw.  Wir legen das Arbeitsverzeichnis fest, mit dem wir arbeiten werden - / usr / app / front. <br><br><pre> <code class="javascript hljs">EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span></code> </pre> <br>  Wir √∂ffnen Port 3000. Die weitere Kommunikation mit der im Container ausgef√ºhrten Anwendung erfolgt √ºber diesen Port. <br><br><pre> <code class="javascript hljs">COPY ./ ./</code> </pre> <br>  Kopieren Sie den Inhalt des Quellprojekts in den Arbeitsordner des Containers. <br><br><pre> <code class="javascript hljs">RUN npm install</code> </pre> <br>  Installieren Sie alle Pakete, die zum Ausf√ºhren der Anwendung erforderlich sind. <br><br><pre> <code class="javascript hljs">CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Wir starten die Anwendung mit dem Befehl npm start. <br><br>  Dieses Szenario wird in unserer Anwendung ausgef√ºhrt, wenn der Container gestartet wird. <br><br>  Lassen Sie uns die Front gerade machen.  F√ºhren Sie dazu im Terminal im Stammordner des Projekts (in dem sich die Docker-Datei befindet) den folgenden Befehl aus: <br><br><pre> <code class="java hljs">docker build -t rebounder-chain-frontend .</code> </pre> <br>  Befehlswerte: <br><br>  Docker ist ein Aufruf der Docker-Anwendung. Das wissen Sie. <br>  Bauen - Erstellen Sie ein Bild aus Zielmaterialien. <br>  -t &lt;Name&gt; - In Zukunft wird die Anwendung mit dem hier angegebenen Tag verf√ºgbar sein.  Sie k√∂nnen dies weglassen, dann generiert Docker ein eigenes Tag, aber es ist unm√∂glich, es von anderen zu unterscheiden. <br>  .  - zeigt an, dass Sie das Projekt aus dem aktuellen Ordner abholen m√ºssen. <br><br><img src="https://habrastorage.org/webt/ro/fc/nz/rofcnzucfn0207jnqulzpjrgxw4.jpeg"><br><br>  Daher sollte die Assembly mit dem folgenden Text enden: <br><br><pre> <code class="java hljs">Step <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span> : CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>] ---&gt; Running in ee0e8a9066dc Removing intermediate container ee0e8a9066dc ---&gt; b208c4184766 Successfully built b208c4184766 Successfully tagged rebounder-chain-frontend:latest</code> </pre> <br>  Wenn wir sehen, dass der letzte Schritt abgeschlossen ist und alles erfolgreich ist, haben wir ein Bild.  Wir k√∂nnen dies √ºberpr√ºfen, indem wir es ausf√ºhren: <br><br><pre> <code class="java hljs">docker run -p <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> rebounder-chain-frontend</code> </pre> <br>  Ich denke, die Bedeutung dieses Befehls wird allgemein verstanden, mit Ausnahme des Eintrags -p 8080: 3000. <br>  Docker-Rebounder-Chain-Frontend ausf√ºhren - bedeutet, dass wir ein solches Docker-Image starten, das wir Rebounder-Chain-Frontend genannt haben.  Ein solcher Container hat jedoch keinen Ausgang nach au√üen, sondern muss einen Port festlegen.  Es ist das Team darunter, das es festlegt.  Wir erinnern uns, dass unsere React-Anwendung auf Port 3000 ausgef√ºhrt wird. Der Befehl -p 8080: 3000 weist den Docker an, Port 3000 zu √ºbernehmen und an Port 8080 weiterzuleiten (der ge√∂ffnet sein wird).  Daher wird eine Anwendung, die auf Port 3000 ausgef√ºhrt wird, auf Port 8080 ge√∂ffnet und ist auf dem lokalen Computer an diesem Port verf√ºgbar. <br><br><pre> <code class="bash hljs">,       : Mac-mini-Vaceslav:rebounder-chain-frontend xpendence$ docker run -p 8080:3000 rebounder-chain-frontend &gt; rebounder-chain-frontend@0.1.0 start /usr/app/front &gt; react-scripts start Starting the development server... Compiled successfully! You can now view rebounder-chain-frontend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the browser. Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/ Note that the development build is not optimized. To create a production build, use npm run build.</code> </pre> <br>  Lassen Sie sich von der Aufzeichnung nicht st√∂ren <br><br><pre> <code class="bash hljs"> Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/</code> </pre> <br>  React glaubt es.  Es ist wirklich im Container auf Port 3000 verf√ºgbar, aber wir haben diesen Port an Port 8080 weitergeleitet, und vom Container aus wird die Anwendung auf Port 8080 ausgef√ºhrt. Sie k√∂nnen die Anwendung lokal ausf√ºhren und dies √ºberpr√ºfen. <br><br>  Wir haben also einen vorgefertigten Container mit einer Front-End-Anwendung. Jetzt sammeln wir das Backend. <br><br><h4>  Backend erstellen. </h4><br>  Das Skript zum Starten einer Anwendung in Java unterscheidet sich erheblich von der vorherigen Assembly.  Es besteht aus folgenden Elementen: <br><br><ol><li>  Installieren Sie die JVM. </li><li>  Wir sammeln Glasarchiv. </li><li>  Wir starten es. </li></ol><br>  In Dockerfile sieht dieser Prozess folgenderma√üen aus: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># back #     JVM FROM openjdk:8-jdk-alpine #  . ,    .  . LABEL maintainer="2262288@gmail.com" #         (  ,  ) VOLUME /tmp #  ,        EXPOSE 8099 # ,       ARG JAR_FILE=build/libs/rebounder-chain-backend-0.0.2.jar #       rebounder-chain-backend.jar ADD ${JAR_FILE} rebounder-chain-backend.jar #    ENTRYPOINT ["java","-jar","/rebounder-chain-backend.jar"]</span></span></code> </pre> <br>  Der Prozess des Zusammenstellens eines Bildes unter Einbeziehung eines Dzharnik in einigen Punkten √§hnelt dem f√ºr unsere Front. <br><br>  Das Zusammenstellen und Starten des zweiten Images entspricht im Wesentlichen dem Zusammenstellen und Starten des ersten Images. <br><br><pre> <code class="bash hljs">docker build -t rebounder-chain-backend . docker run -p 8099:8099 rebounder-chain-backend</code> </pre> <br>  Wenn nun beide Container ausgef√ºhrt werden und das Backend mit der Datenbank verbunden ist, funktioniert alles.  Ich erinnere Sie daran, dass Sie die Verbindung zur Datenbank vom Backend selbst registrieren m√ºssen und sie √ºber ein externes Netzwerk funktionieren muss. <br><br><h2>  3. Sammeln Sie Bilder und f√ºhren Sie Container auf einem Remote-Server aus </h2><br>  Damit alles auf einem Remote-Server funktioniert, muss Docker bereits darauf installiert sein. F√ºhren Sie anschlie√üend einfach die Images aus.  Wir werden den richtigen Weg gehen und unsere Bilder in der Docker-Cloud auf unser Konto √ºbertragen. Danach sind sie von √ºberall auf der Welt verf√ºgbar.  Nat√ºrlich gibt es viele Alternativen zu diesem Ansatz sowie alles, was in der Post beschrieben wird, aber lassen Sie uns noch ein bisschen mehr Druck machen und unsere Arbeit gut machen.  Schlecht, wie Andrei Mironov sagte, wir haben immer Zeit daf√ºr. <br><br><h4>  Erstellen eines Kontos auf dem Docker-Hub </h4><br>  Als erstes m√ºssen Sie ein Konto auf dem Docker-Hub einrichten.  Gehen Sie dazu zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hub</a> und registrieren Sie sich.  Es ist nicht schwer. <br><br>  Als n√§chstes m√ºssen wir zum Terminal gehen und uns bei Docker anmelden. <br><br><pre> <code class="bash hljs">docker login</code> </pre> <br>  Sie werden aufgefordert, einen Benutzernamen und ein Passwort einzugeben.  Wenn alles in Ordnung ist, wird im Terminal eine Benachrichtigung angezeigt, dass die Anmeldung erfolgreich war. <br><br><h4>  Festschreiben von Bildern an den Docker Hub </h4><br>  Als n√§chstes m√ºssen wir unsere Bilder markieren und sie an den Hub √ºbergeben.  Dies erfolgt durch das Team nach folgendem Schema: <br><br><pre> <code class="bash hljs">docker tag   /_:</code> </pre> <br>  Daher m√ºssen wir den Namen unseres Images, Login / Repository und das Tag angeben, unter dem unser Image an den Hub √ºbertragen wird. <br><br>  In meinem Fall sah es so aus: <br><br><img src="https://habrastorage.org/webt/wu/pv/fh/wupvfhs3za_nws2wwsicgfgm2z4.jpeg"><br><br>  Mit dem folgenden Befehl k√∂nnen wir √ºberpr√ºfen, ob dieses Image im lokalen Repository vorhanden ist: <br><br><pre> <code class="bash hljs">Mac-mini-Vaceslav:rebounder-chain-backend xpendence$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE xpendence/rebounder-chain-backend 0.0.2 c8f5b99e15a1 About an hour ago 141MB</code> </pre> <br>  Unser Image ist bereit, sich zu engagieren.  Commit: <br><br><pre> <code class="bash hljs">docker push xpendence/rebounder-chain-backend:0.0.2</code> </pre> <br>  Ein erfolgreicher Festschreibungsdatensatz sollte angezeigt werden. <br>  Machen Sie dasselbe mit dem Frontend: <br><br><pre> <code class="bash hljs">docker tag rebounder-chain-frontend xpendence/rebounder-chain-frontend:0.0.1 docker push xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Wenn wir jetzt zu hub.docker.com gehen, sehen wir zwei gesperrte Bilder.  Welche sind von √ºberall verf√ºgbar. <br><br><img src="https://habrastorage.org/webt/ur/zs/hk/urzshkc3j1ivikyhu4cxvcm43yk.png"><br><br><img src="https://habrastorage.org/webt/cr/if/rb/crifrbda12uxdq6habx6nfeablm.png"><br><br>  Gl√ºckwunsch  Wir m√ºssen nur zum letzten Teil unserer Arbeit √ºbergehen - um Bilder auf einem Remote-Server zu starten. <br><br><h4>  F√ºhren Sie Images auf einem Remote-Server aus </h4><br>  Jetzt k√∂nnen wir unser Image auf jedem Computer mit Docker ausf√ºhren, indem wir nur eine Zeile im Terminal vervollst√§ndigen (in unserem Fall m√ºssen wir zwei Zeilen nacheinander in verschiedenen Terminals ausf√ºhren - eine f√ºr jedes Image). <br><br><pre> <code class="bash hljs">docker run -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Dieser Start hat jedoch ein Minus.  Wenn das Terminal geschlossen ist, wird der Prozess beendet und die Anwendung funktioniert nicht mehr.  Um dies zu vermeiden, k√∂nnen wir die Anwendung im "getrennten" Modus ausf√ºhren: <br><br><pre> <code class="bash hljs">docker run -d -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -d -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Jetzt gibt die Anwendung kein Protokoll an das Terminal aus (dies kann wiederum separat konfiguriert werden), aber selbst wenn das Terminal geschlossen ist, funktioniert es nicht mehr. <br><br><h2>  4. Netzwerkprobleme l√∂sen </h2><br>  Wenn Sie alles richtig gemacht haben, k√∂nnen Sie die gr√∂√üte Entt√§uschung auf dem Weg zum Folgen dieses Beitrags erwarten - es kann sich herausstellen, dass nichts funktioniert.  Zum Beispiel funktionierte alles perfekt f√ºr Sie und auf dem lokalen Computer (wie zum Beispiel auf meinem Mac), aber bei der Bereitstellung auf einem Remote-Server sahen sich die Container nicht mehr (wie zum Beispiel auf meinem Remote-Server unter Linux).  Was ist das Problem?  Aber das Problem ist das, und am Anfang habe ich darauf hingewiesen.  Wie bereits erw√§hnt, erstellt Docker beim Starten des Containers eine separate virtuelle Maschine, rollt dort Linux und installiert dann die Anwendung unter diesem Linux.  Dies bedeutet, dass der bedingte lokale Host f√ºr den laufenden Container auf den Container selbst beschr√§nkt ist und die Anwendung nicht √ºber die Existenz anderer Netzwerke informiert ist.  Aber wir m√ºssen: <br><br>  a) Die Container sahen sich. <br>  b) Das Backend hat die Datenbank gesehen. <br><br>  Es gibt zwei L√∂sungen f√ºr das Problem. <br><br>  1. Erstellen eines internen Netzwerks. <br>  2. Container auf Host-Ebene bringen. <br><br>  1. Auf Docker-Ebene k√∂nnen Sie au√üerdem standardm√§√üig drei Netzwerke erstellen - <i>Bridge</i> , <i>None</i> und <i>Host</i> . <br><br>  <i>Bridge</i> ist ein internes Docker-Netzwerk, das vom Host-Netzwerk isoliert ist.  Sie k√∂nnen nur √ºber die Ports auf Container zugreifen, die Sie √∂ffnen, wenn der Container mit dem Befehl <i>-p gestartet wird</i> .  Sie k√∂nnen eine beliebige Anzahl von Netzwerken erstellen, z. B. <i>Bridge</i> . <br><br><img src="https://habrastorage.org/webt/ld/sp/pf/ldsppf06sqnpf6cumhqodzsiiga.jpeg"><br><br>  <i>Keines</i> ist ein separates Netzwerk f√ºr einen bestimmten Container. <br><br>  <i>Host</i> ist das Host-Netzwerk.  Wenn Sie dieses Netzwerk ausw√§hlen, ist Ihr Container √ºber den Host vollst√§ndig zug√§nglich. Der Befehl <i>-p</i> funktioniert hier einfach nicht. Wenn Sie den Container in diesem Netzwerk bereitgestellt haben, m√ºssen Sie keinen externen Port angeben. Auf den Container kann √ºber seinen internen Port zugegriffen werden.  Wenn Dockerfile EXPOSE beispielsweise auf 8090 eingestellt ist, ist die Anwendung √ºber diesen Port verf√ºgbar. <br><br><img src="https://habrastorage.org/webt/ve/6r/rw/ve6rrwnis25uarwrfudc_xlps4o.jpeg"><br><br>  Da wir Zugriff auf die Serverdatenbank ben√∂tigen, verwenden wir die letztere Methode und legen die Container im Remote-Servernetzwerk an. <br><br>  Dies geschieht ganz einfach. Wir entfernen die Erw√§hnung von Ports aus dem Container-Startbefehl und geben das Host-Netzwerk an: <br><br><pre> <code class="bash hljs">docker run --net=host xpendence/rebounder-chain-frontend:0.0.8</code> </pre> <br>  Verbindung zur Basis habe ich angegeben <br><br><pre> <code class="bash hljs">localhost:3306</code> </pre> <br>  Die Verbindung der Vorderseite mit der R√ºckseite musste vollst√§ndig extern festgelegt werden: <br><br><pre> <code class="bash hljs">http://&lt;__:__&gt;</code> </pre> <br>  Wenn Sie den internen Port an den externen Port weiterleiten, was bei Remoteservern h√§ufig der Fall ist, m√ºssen Sie den internen Port f√ºr die Datenbank und den externen Port f√ºr den Container angeben. <br><br>  Wenn Sie mit Verbindungen experimentieren m√∂chten, k√∂nnen Sie ein Projekt herunterladen und erstellen, das ich speziell geschrieben habe, um die Verbindung zwischen Containern zu testen.  Geben Sie einfach die gew√ºnschte Adresse ein, dr√ºcken Sie Senden und sehen Sie im Debug-Modus, was zur√ºckgeflogen ist. <br><br>  Das Projekt liegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Fazit </h2><br>  Es gibt unz√§hlige M√∂glichkeiten, ein Docker-Image zu erstellen und auszuf√ºhren.  F√ºr Interessierte empfehle ich Ihnen, Docker-Compose zu lernen.  Hier haben wir nur eine der M√∂glichkeiten untersucht, mit Docker zu arbeiten.  Nat√ºrlich scheint dieser Ansatz zun√§chst nicht so einfach zu sein.  Aber hier ist ein Beispiel: W√§hrend des Schreibens eines Beitrags hatte ich ausgehende Verbindungen auf einem Remote-Server.  Und w√§hrend des Debugging-Prozesses musste ich die Einstellungen f√ºr die Datenbankverbindung mehrmals √§ndern.  Die gesamte Assembly und Bereitstellung passte in meinen Satz von 4 Zeilen, nachdem ich das Ergebnis auf einem Remote-Server gesehen hatte.  Im extremen Programmiermodus ist Docker unverzichtbar. <br><br>  Wie versprochen poste ich die Bewerbungsquellen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backend</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448094/">https://habr.com/ru/post/de448094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448080/index.html">Robo Fu√üballspieler von Anf√§ngern. Wettbewerbe bei MIPT. Android & Arduino & Bluetooth</a></li>
<li><a href="../de448082/index.html">[Vor Montag] Syndrom des trockenen Auges</a></li>
<li><a href="../de448084/index.html">Foto eines Schwarzen Lochs - wird es von Nutzen sein?</a></li>
<li><a href="../de448088/index.html">Produktion von Plasmamotoren in Russland</a></li>
<li><a href="../de448090/index.html">Frontend Weekly Digest (8. - 14. April 2019)</a></li>
<li><a href="../de448096/index.html">Julia in Latex</a></li>
<li><a href="../de448098/index.html">GHIDRA, ausf√ºhrbare Dateien f√ºr Playstation 1, FLIRT-Signaturen und PsyQ</a></li>
<li><a href="../de448100/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 360 (7. - 14. April 2019)</a></li>
<li><a href="../de448102/index.html">Traumteam aus dem Nichts: Einstellung von IT-Fachleuten</a></li>
<li><a href="../de448106/index.html">Schulung der Entwickler 1C-Bitrix: Teilen Sie unseren Ansatz zum "Wachsen" des Personals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>