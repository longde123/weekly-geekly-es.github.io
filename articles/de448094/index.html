<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏾 🐪 🦈 Docker: So stellen Sie eine Full-Stack-Anwendung bereit und werden nicht grau 👨🏼‍🤝‍👨🏻 🆑 🏇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Wir brauchen DevOps!" 
 (die beliebteste Phrase am Ende eines Hackathons) 

 Zuerst einige Texte. 

 Wenn ein Entwickler ein ausgezeichneter Entwickl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: So stellen Sie eine Full-Stack-Anwendung bereit und werden nicht grau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448094/"> <i>"Wir brauchen DevOps!"</i> <br>  <i>(die beliebteste Phrase am Ende eines Hackathons)</i> <br><img src="https://habrastorage.org/webt/yy/k1/0q/yyk10qsi8ayqzxsnwqua1nwyzrk.jpeg"><br>  Zuerst einige Texte. <br><br>  Wenn ein Entwickler ein ausgezeichneter Entwickler ist, der seine Idee auf jedem Computer unter jedem OK einsetzen kann, ist dies ein Plus.  Wenn er jedoch nichts weiter als seine IDE versteht, ist dies kein Minus - am Ende wird er für den Code bezahlt und nicht für die Fähigkeit, ihn bereitzustellen.  Ein enger, tiefer Spezialist auf dem Markt wird höher bewertet als die durchschnittliche Fähigkeit eines "Alleskönners".  Für Leute wie uns, "IDE-Benutzer", haben sich gute Leute Docker ausgedacht. <br><br>  Das Prinzip von Docker lautet wie folgt: "Es funktioniert für mich - es funktioniert überall."  Das einzige Programm, das zum Bereitstellen einer Kopie Ihrer Anwendung benötigt wird, ist Docker.  Wenn Sie Ihre Anwendung im Docker auf Ihrem Computer ausführen, wird sie garantiert mit demselben Erfolg in jedem anderen Docker ausgeführt.  Und nichts als ein Docker muss installiert werden.  Zum Beispiel habe ich nicht einmal Java auf dem virtuellen Server. <a name="habracut"></a><br><br><h2>  Wie funktioniert Docker? </h2><br>  Docker erstellt ein Image einer virtuellen Maschine mit darin installierten Anwendungen.  Darüber hinaus entfaltet sich dieses Image als vollständig autonome virtuelle Maschine.  Eine laufende Kopie des Bildes wird als "Container" bezeichnet.  Sie können beliebig viele Images auf dem Server ausführen. Jedes dieser Images ist eine separate virtuelle Maschine mit einer eigenen Umgebung. <br><br>  Was ist eine virtuelle Maschine?  Dies ist der gekapselte Speicherort auf dem Server mit dem Betriebssystem, auf dem die Anwendungen installiert sind.  In jedem Betriebssystem dreht sich normalerweise eine große Anzahl von Anwendungen, in unserem gibt es eine. <br><br>  Das Containerbereitstellungsschema kann wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/9p/vq/ya/9pvqyam6ckaxqvihopwdoynhf4y.jpeg"><br><br>  Für jede Anwendung erstellen wir ein eigenes Image und stellen dann jeden Container separat bereit.  Sie können auch alle Anwendungen in einem Image zusammenfassen und als einen Container bereitstellen.  Um nicht jeden Container separat bereitzustellen, können wir außerdem ein separates Docker-Compose-Dienstprogramm verwenden, das die Container und die Beziehung zwischen ihnen über eine separate Datei konfiguriert.  Dann kann die Struktur der gesamten Anwendung folgendermaßen aussehen: <br><br><img src="https://habrastorage.org/webt/ga/ft/fm/gaftfmbyumgesqldxv1pphh6ati.jpeg"><br><br>  Ich habe die Datenbank aus mehreren Gründen absichtlich nicht zur allgemeinen Docker-Versammlung beigetragen.  Erstens ist die Datenbank völlig unabhängig von den Anwendungen, die damit arbeiten.  Es kann weit von einer Anwendung entfernt sein, es können manuelle Anforderungen von der Konsole sein.  Persönlich sehe ich keinen Grund, die Datenbank von der Docker-Assembly abhängig zu machen, in der sie sich befindet.  Deshalb habe ich es ertragen.  Es wird jedoch häufig ein Ansatz praktiziert, bei dem die Datenbank in einem separaten Image platziert und in einem separaten Container gestartet wird.  Zweitens möchte ich zeigen, wie der Docker-Container mit Systemen außerhalb des Containers interagiert. <br><br>  Lassen Sie uns jedoch den Code schreiben.  Wir werden die einfachste Anwendung im Frühjahr schreiben und reagieren, wodurch unsere Anrufe nach vorne in die Datenbank aufgenommen werden, und wir werden all dies über Docker aufheben.  Die Struktur unserer Anwendung sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/k4/pp/lg/k4pplgvwba46vygymrasjctmrkm.jpeg"><br><br>  Es gibt viele Möglichkeiten, eine solche Struktur zu implementieren.  Wir implementieren eine davon.  Wir werden zwei Images erstellen, zwei Container daraus starten und das Backend wird eine Verbindung zu der Datenbank herstellen, die auf einem bestimmten Server irgendwo im Internet installiert ist (ja, solche Datenbankabfragen werden nicht schnell gehen, aber wir werden nicht vom Durst nach Optimierung getrieben, aber wissenschaftliches Interesse). <br><br>  Der Beitrag wird in Teile geteilt: <br><br>  0. Installieren Sie Docker. <br>  1. Wir schreiben Bewerbungen. <br>  2. Wir sammeln Bilder und starten Container. <br>  3. Sammeln Sie Bilder und starten Sie Container auf einem Remote-Server. <br>  4. Lösen Sie Netzwerkprobleme. <br><br><h2>  0. Installieren Sie Docker </h2><br>  Um Docker zu installieren, müssen Sie auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Site</a> gehen und den dort beschriebenen Anweisungen folgen.  Beachten Sie bei der Installation von Docker auf einem Remote-Server, dass Docker möglicherweise nicht mit Servern unter OpenVZ funktioniert.  Außerdem können Probleme auftreten, wenn Sie iptables nicht aktiviert haben.  Es wird empfohlen, den Server auf KVM mit iptables zu starten.  Aber das sind meine Empfehlungen.  Wenn alles für Sie funktioniert und ich bin froh, dass Sie nicht viel Zeit damit verbracht haben, herauszufinden, warum es nicht funktioniert, wie ich es tun musste. <br><br><h2>  1. Wir schreiben Bewerbungen </h2><br>  Schreiben wir eine einfache Anwendung mit dem primitivsten Backend für Spring Boot, einem sehr einfachen Frontend für ReactJS und einer MySQL-Datenbank.  Die Anwendung verfügt über eine einzelne Seite mit einer einzelnen Schaltfläche, die die Zeit aufzeichnet, zu der in der Datenbank darauf geklickt wurde. <br><br>  Ich verlasse mich auf die Tatsache, dass Sie bereits wissen, wie man Anwendungen beim Booten schreibt, aber wenn nicht, können Sie das fertige Projekt klonen.  Alle Links am Ende des Artikels. <br><br><h3>  Backend auf Spring Boot </h3><br>  build.gradle: <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.4.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.2'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'mysql:mysql-connector-java'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Protokollentität: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.annotation.JsonFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Serializable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.LocalDateTime; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Objects; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 21:20 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"request_logs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Log</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime created; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-meta"><span class="hljs-meta">@JsonFormat</span></span>(shape = JsonFormat.Shape.STRING, pattern = <span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> created; } <span class="hljs-meta"><span class="hljs-meta">@PrePersist</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prePersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.created = LocalDateTime.now(); } <span class="hljs-comment"><span class="hljs-comment">//setters, toString, equals, hashcode, constructors</span></span></code> </pre> <br>  LogController, der mit vereinfachter Logik arbeitet und sofort in die Datenbank schreibt.  Wir lassen den Service aus. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.controller; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.core.JsonProcessingException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.databind.ObjectMapper; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.beans.factory.annotation.Autowired; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.http.ResponseEntity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RequestMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.entity.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.repository.LogRepository; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.logging.Logger; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 22:24 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/log"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOG = Logger.getLogger(LogController.class.getName()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LogRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LogRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ResponseEntity&lt;Log&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log log = repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Log()); LOG.info(<span class="hljs-string"><span class="hljs-string">"saved new log: "</span></span> + log.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResponseEntity.ok(log); } }</code> </pre><br>  Alles ist, wie wir sehen, sehr einfach.  Durch eine GET-Anfrage schreiben wir in die Datenbank und geben das Ergebnis zurück. <br><br>  Wir werden die Anwendungseinstellungsdatei separat diskutieren.  Es gibt zwei von ihnen. <br><br>  application.yml: <br><br><pre> <code class="java hljs">spring: profiles: active: remote</code> </pre> <br>  application-remote.yml: <br><br><pre> <code class="java hljs">spring: datasource: driver-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cj</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">database</span></span></span><span class="hljs-class">:3306/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebounder_database</span></span></span><span class="hljs-class">?</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useUnicode</span></span></span></span>=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useJDBCCompliantTimezoneShift=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useLegacyDatetimeCode=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>&amp;serverTimezone=UTC username: admin password: <span class="hljs-number"><span class="hljs-number">12345</span></span> jpa: hibernate: ddl-auto: update show-sql: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> properties: hibernate.dialect: org.hibernate.dialect.MySQL5Dialect server: port: <span class="hljs-number"><span class="hljs-number">8099</span></span></code> </pre> <br>  Wie dies funktioniert, wissen Sie wahrscheinlich, dass Spring zuerst die Datei application.properties oder application.yml scannt - welche gefunden wird.  Darin geben wir eine einzelne Einstellung an - welches Profil wir verwenden werden.  Normalerweise sammle ich während der Entwicklung mehrere Profile und es ist sehr praktisch, sie mit dem Standardprofil zu wechseln.  Als Nächstes findet Spring application.yml mit dem gewünschten Suffix und verwendet es. <br><br>  Wir haben die Datenquelle, die JPA-Einstellungen und vor allem den externen Port unseres Backends angegeben. <br><br><h3>  ReactJS Frontend </h3><br>  Sie können das Frontend auch in einem Projekt auf Git sehen, oder Sie können es sogar nicht ansehen, sondern klonen und ausführen. <br><br>  Sie können die einzelnen Arbeiten des Frontends überprüfen, indem Sie das Projekt herunterladen, in den Projektstammordner im Terminal (wo sich die Datei package.json befindet) wechseln und zwei Befehle nacheinander ausführen: <br><br><pre> <code class="bash hljs">npm install //      ,  maven npm start //  </code> </pre> <br>  Dazu benötigen Sie natürlich den installierten Node Package Manager (npm), und dies ist der schwierigste Weg, den wir vermeiden, Docker zu verwenden.  Wenn Sie das Projekt noch gestartet haben, wird das folgende Fenster angezeigt: <br><br><img src="https://habrastorage.org/webt/aq/m7/t4/aqm7t4txa2g_rqbuswo3uiibjpq.png"><br><br>  Na ja, es ist Zeit, sich den Code anzusehen.  Ich werde nur den Teil angeben, der sich auf das Backend bezieht. <br><br><pre> <code class="java hljs">export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ _apiPath = <span class="hljs-string"><span class="hljs-string">'http://localhost:8099'</span></span>; _logUrl = <span class="hljs-string"><span class="hljs-string">'/log'</span></span>; getResource = async () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(`${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._apiPath}${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._logUrl}`)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res.ok) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(`Could not fetch ${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._logUrl}` + `, received ${res.status}`) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await res.json(); }; };</code> </pre> <br>  Das Frontend funktioniert vorhersehbar.  Wir folgen dem Link, warten auf die Antwort und zeigen sie auf dem Bildschirm an. <br><br><img src="https://habrastorage.org/webt/xz/vy/qd/xzvyqdrh7akd1c1flu-gnjhcxok.png"><br><br>  Es lohnt sich, sich auf folgende Punkte zu konzentrieren: <br><br><ol><li>  Die Front ist über Port 3000 nach außen offen. Dies ist der Standardport für React. </li><li>  Die Rückseite wird an Port 8099 geöffnet. Wir haben sie in den Anwendungseinstellungen festgelegt. </li><li>  Der Rücken klopft über das externe Internet an die Datenbank. </li></ol><br>  Die Anwendung ist fertig. <br><br><h2>  2. Sammeln Sie Bilder und starten Sie Container </h2><br>  Die Struktur unserer Versammlung wird wie folgt sein.  Wir werden zwei Images erstellen - Frontend und Backend, die über externe Ports miteinander kommunizieren.  Für die Basis erstellen wir kein Image, sondern installieren es separat.  Warum so?  Warum erstellen wir kein Bild für die Basis?  Wir haben zwei Anwendungen, die sich ständig ändern und keine Daten in uns selbst speichern.  Die Datenbank speichert Daten in sich selbst. Dies kann das Ergebnis eines mehrmonatigen Anwendungsbetriebs sein.  Darüber hinaus kann auf diese Datenbank nicht nur von unserer Backend-Anwendung, sondern auch von vielen anderen zugegriffen werden - dafür handelt es sich auch um eine Datenbank, und wir werden sie nicht ständig neu zusammenstellen.  Auch dies ist eine Gelegenheit, mit einer externen API zu arbeiten, die natürlich darin besteht, eine Verbindung zu unserer Datenbank herzustellen. <br><br><h4>  Front-End-Baugruppe </h4><br>  Um jede Anwendung (vorne oder hinten) auszuführen, benötigen Sie eine bestimmte Abfolge von Aktionen.  Um die Anwendung unter React auszuführen, müssen wir Folgendes tun (vorausgesetzt, wir haben bereits Linux): <br><br><ol><li>  Installieren Sie NodeJS. </li><li>  Kopieren Sie die Anwendung in einen bestimmten Ordner. </li><li>  Installieren Sie die erforderlichen Pakete (Befehl npm install). </li><li>  Starten Sie die Anwendung mit dem Befehl npm start. </li></ol><br>  Es ist diese Abfolge von Aktionen, die wir im Docker ausführen müssen.  Dazu müssen wir im Stammverzeichnis des Projekts (an derselben Stelle wie package.json) die Docker-Datei mit den folgenden Inhalten platzieren: <br><br><pre> <code class="javascript hljs">FROM node:alpine WORKDIR /usr/app/front EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span> COPY ./ ./ RUN npm install CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Mal sehen, was jede Zeile bedeutet. <br><br><pre> <code class="javascript hljs">FROM node:alpine</code> </pre> <br>  Mit dieser Zeile machen wir dem Docker klar, dass Sie beim Starten des Containers zunächst Docker aus dem Repository herunterladen und NodeJS installieren müssen, und zwar die leichteste (alle leichtesten Versionen gängiger Frameworks und Bibliotheken im Docker werden normalerweise als alpin bezeichnet). <br><br><pre> <code class="javascript hljs">WORKDIR /usr/app/front</code> </pre> <br>  Im Linux-Container werden dieselben Standardordner erstellt wie in anderen Linux-Ordnern - / opt, / home, / etc, / usr usw.  Wir legen das Arbeitsverzeichnis fest, mit dem wir arbeiten werden - / usr / app / front. <br><br><pre> <code class="javascript hljs">EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span></code> </pre> <br>  Wir öffnen Port 3000. Die weitere Kommunikation mit der im Container ausgeführten Anwendung erfolgt über diesen Port. <br><br><pre> <code class="javascript hljs">COPY ./ ./</code> </pre> <br>  Kopieren Sie den Inhalt des Quellprojekts in den Arbeitsordner des Containers. <br><br><pre> <code class="javascript hljs">RUN npm install</code> </pre> <br>  Installieren Sie alle Pakete, die zum Ausführen der Anwendung erforderlich sind. <br><br><pre> <code class="javascript hljs">CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Wir starten die Anwendung mit dem Befehl npm start. <br><br>  Dieses Szenario wird in unserer Anwendung ausgeführt, wenn der Container gestartet wird. <br><br>  Lassen Sie uns die Front gerade machen.  Führen Sie dazu im Terminal im Stammordner des Projekts (in dem sich die Docker-Datei befindet) den folgenden Befehl aus: <br><br><pre> <code class="java hljs">docker build -t rebounder-chain-frontend .</code> </pre> <br>  Befehlswerte: <br><br>  Docker ist ein Aufruf der Docker-Anwendung. Das wissen Sie. <br>  Bauen - Erstellen Sie ein Bild aus Zielmaterialien. <br>  -t &lt;Name&gt; - In Zukunft wird die Anwendung mit dem hier angegebenen Tag verfügbar sein.  Sie können dies weglassen, dann generiert Docker ein eigenes Tag, aber es ist unmöglich, es von anderen zu unterscheiden. <br>  .  - zeigt an, dass Sie das Projekt aus dem aktuellen Ordner abholen müssen. <br><br><img src="https://habrastorage.org/webt/ro/fc/nz/rofcnzucfn0207jnqulzpjrgxw4.jpeg"><br><br>  Daher sollte die Assembly mit dem folgenden Text enden: <br><br><pre> <code class="java hljs">Step <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span> : CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>] ---&gt; Running in ee0e8a9066dc Removing intermediate container ee0e8a9066dc ---&gt; b208c4184766 Successfully built b208c4184766 Successfully tagged rebounder-chain-frontend:latest</code> </pre> <br>  Wenn wir sehen, dass der letzte Schritt abgeschlossen ist und alles erfolgreich ist, haben wir ein Bild.  Wir können dies überprüfen, indem wir es ausführen: <br><br><pre> <code class="java hljs">docker run -p <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> rebounder-chain-frontend</code> </pre> <br>  Ich denke, die Bedeutung dieses Befehls wird allgemein verstanden, mit Ausnahme des Eintrags -p 8080: 3000. <br>  Docker-Rebounder-Chain-Frontend ausführen - bedeutet, dass wir ein solches Docker-Image starten, das wir Rebounder-Chain-Frontend genannt haben.  Ein solcher Container hat jedoch keinen Ausgang nach außen, sondern muss einen Port festlegen.  Es ist das Team darunter, das es festlegt.  Wir erinnern uns, dass unsere React-Anwendung auf Port 3000 ausgeführt wird. Der Befehl -p 8080: 3000 weist den Docker an, Port 3000 zu übernehmen und an Port 8080 weiterzuleiten (der geöffnet sein wird).  Daher wird eine Anwendung, die auf Port 3000 ausgeführt wird, auf Port 8080 geöffnet und ist auf dem lokalen Computer an diesem Port verfügbar. <br><br><pre> <code class="bash hljs">,       : Mac-mini-Vaceslav:rebounder-chain-frontend xpendence$ docker run -p 8080:3000 rebounder-chain-frontend &gt; rebounder-chain-frontend@0.1.0 start /usr/app/front &gt; react-scripts start Starting the development server... Compiled successfully! You can now view rebounder-chain-frontend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the browser. Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/ Note that the development build is not optimized. To create a production build, use npm run build.</code> </pre> <br>  Lassen Sie sich von der Aufzeichnung nicht stören <br><br><pre> <code class="bash hljs"> Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/</code> </pre> <br>  React glaubt es.  Es ist wirklich im Container auf Port 3000 verfügbar, aber wir haben diesen Port an Port 8080 weitergeleitet, und vom Container aus wird die Anwendung auf Port 8080 ausgeführt. Sie können die Anwendung lokal ausführen und dies überprüfen. <br><br>  Wir haben also einen vorgefertigten Container mit einer Front-End-Anwendung. Jetzt sammeln wir das Backend. <br><br><h4>  Backend erstellen. </h4><br>  Das Skript zum Starten einer Anwendung in Java unterscheidet sich erheblich von der vorherigen Assembly.  Es besteht aus folgenden Elementen: <br><br><ol><li>  Installieren Sie die JVM. </li><li>  Wir sammeln Glasarchiv. </li><li>  Wir starten es. </li></ol><br>  In Dockerfile sieht dieser Prozess folgendermaßen aus: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># back #     JVM FROM openjdk:8-jdk-alpine #  . ,    .  . LABEL maintainer="2262288@gmail.com" #         (  ,  ) VOLUME /tmp #  ,        EXPOSE 8099 # ,       ARG JAR_FILE=build/libs/rebounder-chain-backend-0.0.2.jar #       rebounder-chain-backend.jar ADD ${JAR_FILE} rebounder-chain-backend.jar #    ENTRYPOINT ["java","-jar","/rebounder-chain-backend.jar"]</span></span></code> </pre> <br>  Der Prozess des Zusammenstellens eines Bildes unter Einbeziehung eines Dzharnik in einigen Punkten ähnelt dem für unsere Front. <br><br>  Das Zusammenstellen und Starten des zweiten Images entspricht im Wesentlichen dem Zusammenstellen und Starten des ersten Images. <br><br><pre> <code class="bash hljs">docker build -t rebounder-chain-backend . docker run -p 8099:8099 rebounder-chain-backend</code> </pre> <br>  Wenn nun beide Container ausgeführt werden und das Backend mit der Datenbank verbunden ist, funktioniert alles.  Ich erinnere Sie daran, dass Sie die Verbindung zur Datenbank vom Backend selbst registrieren müssen und sie über ein externes Netzwerk funktionieren muss. <br><br><h2>  3. Sammeln Sie Bilder und führen Sie Container auf einem Remote-Server aus </h2><br>  Damit alles auf einem Remote-Server funktioniert, muss Docker bereits darauf installiert sein. Führen Sie anschließend einfach die Images aus.  Wir werden den richtigen Weg gehen und unsere Bilder in der Docker-Cloud auf unser Konto übertragen. Danach sind sie von überall auf der Welt verfügbar.  Natürlich gibt es viele Alternativen zu diesem Ansatz sowie alles, was in der Post beschrieben wird, aber lassen Sie uns noch ein bisschen mehr Druck machen und unsere Arbeit gut machen.  Schlecht, wie Andrei Mironov sagte, wir haben immer Zeit dafür. <br><br><h4>  Erstellen eines Kontos auf dem Docker-Hub </h4><br>  Als erstes müssen Sie ein Konto auf dem Docker-Hub einrichten.  Gehen Sie dazu zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hub</a> und registrieren Sie sich.  Es ist nicht schwer. <br><br>  Als nächstes müssen wir zum Terminal gehen und uns bei Docker anmelden. <br><br><pre> <code class="bash hljs">docker login</code> </pre> <br>  Sie werden aufgefordert, einen Benutzernamen und ein Passwort einzugeben.  Wenn alles in Ordnung ist, wird im Terminal eine Benachrichtigung angezeigt, dass die Anmeldung erfolgreich war. <br><br><h4>  Festschreiben von Bildern an den Docker Hub </h4><br>  Als nächstes müssen wir unsere Bilder markieren und sie an den Hub übergeben.  Dies erfolgt durch das Team nach folgendem Schema: <br><br><pre> <code class="bash hljs">docker tag   /_:</code> </pre> <br>  Daher müssen wir den Namen unseres Images, Login / Repository und das Tag angeben, unter dem unser Image an den Hub übertragen wird. <br><br>  In meinem Fall sah es so aus: <br><br><img src="https://habrastorage.org/webt/wu/pv/fh/wupvfhs3za_nws2wwsicgfgm2z4.jpeg"><br><br>  Mit dem folgenden Befehl können wir überprüfen, ob dieses Image im lokalen Repository vorhanden ist: <br><br><pre> <code class="bash hljs">Mac-mini-Vaceslav:rebounder-chain-backend xpendence$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE xpendence/rebounder-chain-backend 0.0.2 c8f5b99e15a1 About an hour ago 141MB</code> </pre> <br>  Unser Image ist bereit, sich zu engagieren.  Commit: <br><br><pre> <code class="bash hljs">docker push xpendence/rebounder-chain-backend:0.0.2</code> </pre> <br>  Ein erfolgreicher Festschreibungsdatensatz sollte angezeigt werden. <br>  Machen Sie dasselbe mit dem Frontend: <br><br><pre> <code class="bash hljs">docker tag rebounder-chain-frontend xpendence/rebounder-chain-frontend:0.0.1 docker push xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Wenn wir jetzt zu hub.docker.com gehen, sehen wir zwei gesperrte Bilder.  Welche sind von überall verfügbar. <br><br><img src="https://habrastorage.org/webt/ur/zs/hk/urzshkc3j1ivikyhu4cxvcm43yk.png"><br><br><img src="https://habrastorage.org/webt/cr/if/rb/crifrbda12uxdq6habx6nfeablm.png"><br><br>  Glückwunsch  Wir müssen nur zum letzten Teil unserer Arbeit übergehen - um Bilder auf einem Remote-Server zu starten. <br><br><h4>  Führen Sie Images auf einem Remote-Server aus </h4><br>  Jetzt können wir unser Image auf jedem Computer mit Docker ausführen, indem wir nur eine Zeile im Terminal vervollständigen (in unserem Fall müssen wir zwei Zeilen nacheinander in verschiedenen Terminals ausführen - eine für jedes Image). <br><br><pre> <code class="bash hljs">docker run -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Dieser Start hat jedoch ein Minus.  Wenn das Terminal geschlossen ist, wird der Prozess beendet und die Anwendung funktioniert nicht mehr.  Um dies zu vermeiden, können wir die Anwendung im "getrennten" Modus ausführen: <br><br><pre> <code class="bash hljs">docker run -d -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -d -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Jetzt gibt die Anwendung kein Protokoll an das Terminal aus (dies kann wiederum separat konfiguriert werden), aber selbst wenn das Terminal geschlossen ist, funktioniert es nicht mehr. <br><br><h2>  4. Netzwerkprobleme lösen </h2><br>  Wenn Sie alles richtig gemacht haben, können Sie die größte Enttäuschung auf dem Weg zum Folgen dieses Beitrags erwarten - es kann sich herausstellen, dass nichts funktioniert.  Zum Beispiel funktionierte alles perfekt für Sie und auf dem lokalen Computer (wie zum Beispiel auf meinem Mac), aber bei der Bereitstellung auf einem Remote-Server sahen sich die Container nicht mehr (wie zum Beispiel auf meinem Remote-Server unter Linux).  Was ist das Problem?  Aber das Problem ist das, und am Anfang habe ich darauf hingewiesen.  Wie bereits erwähnt, erstellt Docker beim Starten des Containers eine separate virtuelle Maschine, rollt dort Linux und installiert dann die Anwendung unter diesem Linux.  Dies bedeutet, dass der bedingte lokale Host für den laufenden Container auf den Container selbst beschränkt ist und die Anwendung nicht über die Existenz anderer Netzwerke informiert ist.  Aber wir müssen: <br><br>  a) Die Container sahen sich. <br>  b) Das Backend hat die Datenbank gesehen. <br><br>  Es gibt zwei Lösungen für das Problem. <br><br>  1. Erstellen eines internen Netzwerks. <br>  2. Container auf Host-Ebene bringen. <br><br>  1. Auf Docker-Ebene können Sie außerdem standardmäßig drei Netzwerke erstellen - <i>Bridge</i> , <i>None</i> und <i>Host</i> . <br><br>  <i>Bridge</i> ist ein internes Docker-Netzwerk, das vom Host-Netzwerk isoliert ist.  Sie können nur über die Ports auf Container zugreifen, die Sie öffnen, wenn der Container mit dem Befehl <i>-p gestartet wird</i> .  Sie können eine beliebige Anzahl von Netzwerken erstellen, z. B. <i>Bridge</i> . <br><br><img src="https://habrastorage.org/webt/ld/sp/pf/ldsppf06sqnpf6cumhqodzsiiga.jpeg"><br><br>  <i>Keines</i> ist ein separates Netzwerk für einen bestimmten Container. <br><br>  <i>Host</i> ist das Host-Netzwerk.  Wenn Sie dieses Netzwerk auswählen, ist Ihr Container über den Host vollständig zugänglich. Der Befehl <i>-p</i> funktioniert hier einfach nicht. Wenn Sie den Container in diesem Netzwerk bereitgestellt haben, müssen Sie keinen externen Port angeben. Auf den Container kann über seinen internen Port zugegriffen werden.  Wenn Dockerfile EXPOSE beispielsweise auf 8090 eingestellt ist, ist die Anwendung über diesen Port verfügbar. <br><br><img src="https://habrastorage.org/webt/ve/6r/rw/ve6rrwnis25uarwrfudc_xlps4o.jpeg"><br><br>  Da wir Zugriff auf die Serverdatenbank benötigen, verwenden wir die letztere Methode und legen die Container im Remote-Servernetzwerk an. <br><br>  Dies geschieht ganz einfach. Wir entfernen die Erwähnung von Ports aus dem Container-Startbefehl und geben das Host-Netzwerk an: <br><br><pre> <code class="bash hljs">docker run --net=host xpendence/rebounder-chain-frontend:0.0.8</code> </pre> <br>  Verbindung zur Basis habe ich angegeben <br><br><pre> <code class="bash hljs">localhost:3306</code> </pre> <br>  Die Verbindung der Vorderseite mit der Rückseite musste vollständig extern festgelegt werden: <br><br><pre> <code class="bash hljs">http://&lt;__:__&gt;</code> </pre> <br>  Wenn Sie den internen Port an den externen Port weiterleiten, was bei Remoteservern häufig der Fall ist, müssen Sie den internen Port für die Datenbank und den externen Port für den Container angeben. <br><br>  Wenn Sie mit Verbindungen experimentieren möchten, können Sie ein Projekt herunterladen und erstellen, das ich speziell geschrieben habe, um die Verbindung zwischen Containern zu testen.  Geben Sie einfach die gewünschte Adresse ein, drücken Sie Senden und sehen Sie im Debug-Modus, was zurückgeflogen ist. <br><br>  Das Projekt liegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Fazit </h2><br>  Es gibt unzählige Möglichkeiten, ein Docker-Image zu erstellen und auszuführen.  Für Interessierte empfehle ich Ihnen, Docker-Compose zu lernen.  Hier haben wir nur eine der Möglichkeiten untersucht, mit Docker zu arbeiten.  Natürlich scheint dieser Ansatz zunächst nicht so einfach zu sein.  Aber hier ist ein Beispiel: Während des Schreibens eines Beitrags hatte ich ausgehende Verbindungen auf einem Remote-Server.  Und während des Debugging-Prozesses musste ich die Einstellungen für die Datenbankverbindung mehrmals ändern.  Die gesamte Assembly und Bereitstellung passte in meinen Satz von 4 Zeilen, nachdem ich das Ergebnis auf einem Remote-Server gesehen hatte.  Im extremen Programmiermodus ist Docker unverzichtbar. <br><br>  Wie versprochen poste ich die Bewerbungsquellen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backend</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448094/">https://habr.com/ru/post/de448094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448080/index.html">Robo Fußballspieler von Anfängern. Wettbewerbe bei MIPT. Android & Arduino & Bluetooth</a></li>
<li><a href="../de448082/index.html">[Vor Montag] Syndrom des trockenen Auges</a></li>
<li><a href="../de448084/index.html">Foto eines Schwarzen Lochs - wird es von Nutzen sein?</a></li>
<li><a href="../de448088/index.html">Produktion von Plasmamotoren in Russland</a></li>
<li><a href="../de448090/index.html">Frontend Weekly Digest (8. - 14. April 2019)</a></li>
<li><a href="../de448096/index.html">Julia in Latex</a></li>
<li><a href="../de448098/index.html">GHIDRA, ausführbare Dateien für Playstation 1, FLIRT-Signaturen und PsyQ</a></li>
<li><a href="../de448100/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 360 (7. - 14. April 2019)</a></li>
<li><a href="../de448102/index.html">Traumteam aus dem Nichts: Einstellung von IT-Fachleuten</a></li>
<li><a href="../de448106/index.html">Schulung der Entwickler 1C-Bitrix: Teilen Sie unseren Ansatz zum "Wachsen" des Personals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>