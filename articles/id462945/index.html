<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨ â˜ğŸ½ ğŸ™ğŸ» Hasilkan kata sandi satu kali untuk 2FA di JS menggunakan Web Crypto API ğŸ˜Ÿ ğŸ’ªğŸ¿ ğŸ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Otentikasi dua faktor ada di mana-mana saat ini. Berkat dia, untuk mencuri akun, hanya kata sandi saja tidak cukup. Dan meskipun keber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hasilkan kata sandi satu kali untuk 2FA di JS menggunakan Web Crypto API</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462945/"><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Otentikasi dua faktor ada di mana-mana saat ini.  Berkat dia, untuk mencuri akun, hanya kata sandi saja tidak cukup.  Dan meskipun keberadaannya tidak menjamin bahwa akun Anda tidak akan dihapus untuk menyiasatinya, serangan yang lebih kompleks dan multi-level akan diperlukan.  Seperti yang Anda tahu, semakin rumit sesuatu di dunia ini, semakin besar kemungkinan itu tidak akan berhasil. </p><br><p> Saya yakin semua orang yang membaca artikel ini setidaknya pernah menggunakan otentikasi dua faktor (selanjutnya disebut 2FA, frasa yang sangat panjang) dalam kehidupan mereka.  Hari ini saya mengundang Anda untuk mencari tahu bagaimana teknologi ini bekerja, yang melindungi akun yang tak terhitung jumlahnya setiap hari. </p><br><p>  Tetapi sebagai permulaan, Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> dari apa yang akan kita lakukan hari ini. </p><a name="habracut"></a><br><h2 id="osnovy">  Dasar-dasarnya </h2><br><p>  Hal pertama yang perlu disebutkan tentang kata sandi satu kali adalah bahwa mereka terdiri dari dua jenis: <strong>HOTP</strong> dan <strong>TOTP</strong> .  Yakni, <strong>One Time Password berbasis HMAC</strong> dan <strong>OTP berbasis waktu</strong> .  TOTP hanyalah add-on untuk HOTP, jadi mari kita bicara tentang algoritma yang lebih sederhana terlebih dahulu. </p><br><p>  HOTP dijelaskan oleh spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC4226</a> .  Ini kecil, hanya 35 halaman, dan berisi semua yang Anda butuhkan: deskripsi formal, contoh implementasi dan data uji.  Mari kita lihat konsep dasarnya. </p><br><p>  Pertama-tama, apa itu <strong>HMAC</strong> ?  HMAC singkatan <strong>Kode Otentikasi Pesan Berbasis Hash</strong> , atau "kode otentikasi pesan menggunakan fungsi hash" dalam bahasa Rusia.  MAC adalah mekanisme untuk memverifikasi pengirim pesan.  Algoritma <strong>MAC</strong> menghasilkan <strong>tag MAC</strong> menggunakan kunci rahasia yang hanya diketahui oleh pengirim dan penerima.  Setelah menerima pesan, Anda dapat membuat tag MAC sendiri dan membandingkan kedua tag tersebut.  Jika mereka bertepatan - semuanya beres, tidak ada gangguan dalam proses komunikasi.  Sebagai bonus, dengan cara yang sama, Anda dapat memeriksa apakah pesan rusak selama transmisi.  Tentu saja, itu tidak akan berfungsi untuk membedakan gangguan dari kerusakan, tetapi fakta korupsi informasi sudah cukup. </p><br><p><img src="https://habrastorage.org/webt/ug/0m/yf/ug0myfmi3y1iwrq3csxfsp1j6c0.png" alt="Tag MAC"></p><br><p>  Apa itu hash?  Hash adalah hasil dari penerapan fungsi hash ke pesan.  Fungsi hash mengambil data Anda dan menjadikannya string dengan panjang tetap.  Contoh yang baik adalah fungsi <strong>MD5 yang</strong> terkenal, yang telah banyak digunakan untuk memverifikasi integritas file. </p><br><p>  <strong>MAC</strong> sendiri bukan algoritma spesifik, tetapi hanya istilah umum.  <strong>HMAC,</strong> pada gilirannya, sudah merupakan implementasi konkret.  Lebih khusus lagi, HMAC- <em>X</em> , di mana X adalah salah satu fungsi hash kriptografi.  HMAC mengambil dua argumen: kunci rahasia dan pesan, mencampurkannya dengan cara tertentu, menerapkan fungsi hash yang dipilih dua kali, dan mengembalikan tag MAC. </p><br><p>  Jika saat ini Anda berpikir sendiri apa yang harus dilakukan dengan kata sandi satu kali - jangan khawatir, kami hampir mencapai poin utama. </p><br><p>  Menurut spesifikasi, HOTP dihitung berdasarkan pada dua nilai: </p><br><ul><li>  K adalah <strong>kunci rahasia yang</strong> diketahui klien dan server.  Panjangnya harus setidaknya 128 bit, dan lebih disukai 160, dan dibuat ketika Anda mengkonfigurasi 2FA. </li><li>  <strong>C</strong> adalah <strong>penghitungnya</strong> . </li></ul><br><p>  Penghitung adalah nilai 8-byte yang disinkronkan antara klien dan server.  Ini diperbarui saat Anda menghasilkan kata sandi baru.  Dalam skema HOTP, penghitung sisi klien bertambah setiap kali Anda menghasilkan kata sandi baru.  Di sisi server, setiap kali kata sandi berhasil lulus validasi.  Karena dimungkinkan untuk membuat kata sandi, tetapi tidak menggunakannya, server memungkinkan nilai penghitung berjalan sedikit di depan dalam jendela yang ditetapkan.  Namun, jika Anda terlalu banyak bermain dengan pembuat kata sandi dalam skema HOTP, Anda harus menyinkronkannya lagi. </p><br><p>  Jadi  Seperti yang mungkin Anda perhatikan, HMAC juga membutuhkan dua argumen.  RFC4226 mendefinisikan fungsi pembuatan HOTP sebagai berikut: </p><br><pre><code class="plaintext hljs">HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))</code> </pre> <br><p>  Sangat diharapkan, <strong>K</strong> digunakan sebagai kunci rahasia.  Penghitung, pada gilirannya, digunakan sebagai pesan.  Setelah fungsi HMAC menghasilkan tag MAC, fungsi <code>Truncate</code> misterius mengeluarkan kata sandi satu kali yang sudah akrab bagi kami, yang Anda lihat di aplikasi generator Anda atau pada token. </p><br><p>  Mari kita mulai menulis kode dan menangani sisanya saat ini. </p><br><h2 id="plan-realizacii">  Rencana implementasi </h2><br><p>  Untuk mendapatkan kata sandi satu kali, kita harus mengikuti langkah-langkah ini. </p><br><p><img src="https://habrastorage.org/webt/tl/v7/br/tlv7brjdmq9e7s-1rmc2bxpkrfm.png" alt="Implementasi"></p><br><ul><li>  Hasilkan hash HMAC-SHA1 dari parameter <strong>K</strong> dan <strong>C.</strong>  Ini akan menjadi string 20 byte. </li><li>  Tarik 4 byte dari string ini dengan cara tertentu. </li><li>  Konversikan nilai yang ditarik ke angka dan bagi dengan 10 ^ n, di mana n = jumlah digit dalam kata sandi satu kali (biasanya n = 6).  Dan akhirnya, ambil sisa dari divisi ini.  Ini akan menjadi kata sandi kami. </li></ul><br><p>  Itu tidak terdengar terlalu sulit, bukan?  Mari kita mulai dengan generasi hash. </p><br><h2 id="generiruem-hmac-sha1">  Hasilkan HMAC-SHA1 </h2><br><p>  Ini mungkin yang paling mudah dari langkah-langkah yang tercantum di atas.  Kami tidak akan mencoba membuat ulang algoritme sendiri (kami tidak perlu mencoba mengimplementasikan sesuatu dari kriptografi sendiri).  Sebagai gantinya, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Web Crypto API</strong></a> .  Masalah kecilnya adalah bahwa spesifikasi API ini hanya tersedia di bawah Konteks Aman (HTTPS).  Bagi kami, ini penuh dengan fakta bahwa kami tidak dapat menggunakannya tanpa mengatur HTTPS di server pengembangan.  Sedikit sejarah dan diskusi tentang bagaimana ini adalah keputusan yang tepat dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Untungnya, di Firefox Anda <em>dapat</em> menggunakan Web Crypto dalam konteks yang tidak aman, dan Anda tidak perlu menemukan kembali roda atau menyeret pustaka pihak ketiga.  Oleh karena itu, untuk keperluan pengembangan demo, saya sarankan menggunakan FF. </p><br><p>  API Crypto sendiri didefinisikan di <code>window.crypto.subtle</code> .  Jika Anda terkejut dengan namanya, saya kutip dari spesifikasinya: </p><br><blockquote>  API disebut <code>SubtleCrypto</code> sebagai cerminan dari fakta bahwa banyak algoritma memiliki persyaratan penggunaan khusus.  Hanya ketika persyaratan ini dipenuhi mereka mempertahankan daya tahan mereka. </blockquote><p>  Mari kita membahas metode yang kita butuhkan.  Catatan: semua metode yang disebutkan di sini tidak sinkron dan mengembalikan <code>Promise</code> . </p><br><p>  Pertama, kita memerlukan metode <code>importKey</code> , karena kita akan menggunakan kunci pribadi kita, dan tidak menghasilkannya di browser.  <code>importKey</code> membutuhkan 5 argumen: </p><br><pre> <code class="javascript hljs">importKey( format, keyData, algorithm, extractable, usages );</code> </pre> <br><p>  Dalam kasus kami: </p><br><ul><li>  <code>format</code> akan <code>'raw'</code> , mis.  kami akan menyediakan kunci sebagai array byte <code>ArrayBuffer</code> . </li><li>  <code>keyData</code> adalah <code>keyData</code> yang sama.  Kami akan segera berbicara tentang cara membuatnya. </li><li>  <code>algorithm</code> , sesuai dengan spesifikasi, akan menjadi <code>HMAC-SHA1</code> .  Argumen ini harus sesuai dengan format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HmacImportParams</a> . </li><li>  <code>extractable</code> menjadi false, karena kami tidak punya rencana untuk mengekspor kunci rahasia </li><li>  Dan akhirnya, dari semua <code>usages</code> kita hanya perlu <code>'sign'</code> . </li></ul><br><p>  Kunci rahasia kami akan berupa string acak yang panjang.  Di dunia nyata, ini mungkin urutan byte, yang mungkin tidak dapat dicetak, namun, untuk kenyamanan, dalam artikel ini kami akan mempertimbangkan string.  Untuk mengubahnya menjadi <code>ArrayBuffer</code> kita akan menggunakan antarmuka <code>TextEncoder</code> .  Dengan itu, kuncinya disiapkan dalam dua baris kode: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secretBytes = encoder.encode(secret);</code> </pre> <br><p>  Sekarang mari kita kumpulkan semuanya: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Crypto = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.crypto.subtle; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secretBytes = encoder.encode(secret); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Crypto.importKey( <span class="hljs-string"><span class="hljs-string">'raw'</span></span>, secretBytes, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'HMAC'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hash</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'SHA-1'</span></span> } }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, [<span class="hljs-string"><span class="hljs-string">'sign'</span></span>] );</code> </pre> <br><p>  Hebat!  Kriptografi disiapkan.  Sekarang kita akan berurusan dengan konter dan akhirnya menandatangani pesan. </p><br><p>  Menurut spesifikasi, penghitung kami harus sepanjang 8 byte.  Kami akan bekerja dengannya lagi, seperti dengan <code>ArrayBuffer</code> .  Untuk menerjemahkannya ke dalam formulir ini, kami akan menggunakan trik yang biasanya digunakan di JS untuk menyimpan angka nol di angka atas angka.  Setelah itu, kita akan meletakkan setiap byte dalam <code>ArrayBuffer</code> menggunakan <code>DataView</code> .  Perlu diingat bahwa dengan spesifikasi untuk semua data biner formatnya adalah <strong>big endian</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">padCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ArrayBuffer</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DataView</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byteString = <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 8 bytes const bCounter = (byteString + counter.toString(2)).slice(-64); for (let byte = 0; byte &lt; 64; byte += 8) { const byteValue = parseInt(bCounter.slice(byte, byte + 8), 2); bView.setUint8(byte / 8, byteValue); } return buffer; }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/w0/cs/uh/w0csuhhkbyxccigknindlgpf3t0.png" alt="Pad penghitung"></p><br><p>  Akhirnya, setelah menyiapkan kunci dan penghitungnya, Anda dapat menghasilkan hash!  Untuk melakukan ini, kita akan menggunakan fungsi <code>sign</code> dari <code>SubtleCrypto</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterArray = padCounter(counter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HS = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Crypto.sign(<span class="hljs-string"><span class="hljs-string">'HMAC'</span></span>, key, counterArray);</code> </pre> <br><p>  Dan untuk ini kami telah menyelesaikan langkah pertama.  Pada output, kami mendapatkan nilai yang sedikit misterius yang disebut HS.  Dan meskipun ini bukan nama terbaik untuk suatu variabel, itu adalah apa (dan beberapa dari yang berikut) disebut dalam spesifikasi.  Kami akan meninggalkan nama-nama ini untuk memudahkan membandingkan kode dengan itu.  Apa selanjutnya </p><br><blockquote>  Langkah 2: Menghasilkan string 4-byte (Dynamic Truncation) <br>  Biarkan Sbits = DT (HS) // DT, didefinisikan di bawah, <br>  // mengembalikan string 31-bit </blockquote><p>  DT adalah singkatan dari Dynamic Truncation.  Dan inilah cara kerjanya: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DT</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HS</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// First we take the last byte of our generated HS and extract last 4 bits out of it. // This will be our _offset_, a number between 0 and 15. const offset = HS[19] &amp; 0b1111; // Next we take 4 bytes out of the HS, starting at the offset const P = ((HS[offset] &amp; 0x7f) &lt;&lt; 24) | (HS[offset + 1] &lt;&lt; 16) | (HS[offset + 2] &lt;&lt; 8) | HS[offset + 3] // Finally, convert it into a binary string representation const pString = P.toString(2); return pString; }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/80/0n/5x/800n5xjrszlpbiriupg6acom-oq.png" alt="Pemotongan"></p><br><p>  Perhatikan bagaimana kami menerapkan bitwise AND ke byte pertama HS.  <code>0x7f</code> dalam sistem biner adalah <code>0b01111111</code> , jadi pada dasarnya kita hanya membuang bit pertama.  Di JS, di sinilah arti dari ungkapan ini berakhir, tetapi dalam bahasa lain itu juga akan menyediakan untuk memotong bit tanda untuk menghilangkan kebingungan antara angka positif / negatif dan menyajikan nomor ini sebagai tidak ditandatangani. </p><br><p>  Hampir selesai!  Tetap hanya mengubah nilai yang diperoleh dari DT menjadi angka dan meneruskan ke langkah ketiga. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">truncate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Sbits = DT(uKey); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Snum = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(Sbits, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Snum; }</code> </pre> <br><p>  Langkah ketiga juga cukup kecil.  Yang perlu dilakukan adalah membagi jumlah yang dihasilkan dengan <code>10 ** (   )</code> , dan kemudian mengambil sisa dari divisi ini.  Jadi, kami memotong angka N terakhir dari angka ini.  Menurut spesifikasinya, kode kita harus mampu mengeluarkan setidaknya enam digit kata sandi dan berpotensi 7 dan 8 angka.  Secara teoritis, karena ini adalah angka 31-bit, kami dapat mengeluarkan 9 karakter, tetapi dalam kenyataannya, saya pribadi tidak pernah melihat lebih dari 6 karakter.  Bagaimana dengan kamu? </p><br><p>  Kode untuk fungsi terakhir, yang menggabungkan semua yang sebelumnya, dalam hal ini akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateHOTP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">secret, counter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> generateKey(secret, counter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(key); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Snum = truncate(uKey); <span class="hljs-comment"><span class="hljs-comment">// Make sure we keep leading zeroes const padded = ('000000' + (Snum % (10 ** 6))).slice(-6); return padded; }</span></span></code> </pre> <br><p>  Hore!  Tetapi bagaimana cara memeriksa sekarang bahwa kode kita sudah benar? </p><br><h2 id="testirovanie">  Pengujian </h2><br><p>  Untuk menguji implementasi, kami akan menggunakan contoh dari RFC.  Apendiks D mencakup nilai uji untuk kunci rahasia <code>"12345678901234567890"</code> dan nilai penghitung dari 0 hingga 9. Ada juga hash HMAC yang dihitung dan hasil antara dari fungsi Truncate.  Cukup berguna untuk men-debug semua langkah dari algoritma.  Ini adalah contoh kecil dari tabel ini (hanya counter dan HOTP yang tersisa): </p><br><pre> <code class="plaintext hljs"> Count HOTP 0 755224 1 287082 2 359152 3 969429 ...</code> </pre> <br><p>  Jika Anda belum menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> , sekaranglah saatnya.  Anda dapat memasukkan nilai-nilai dari RFC di dalamnya.  Dan kembali karena kami memulai TOTP. </p><br><h2 id="totp">  Totp </h2><br><p>  Jadi kami akhirnya sampai pada bagian 2FA yang lebih modern.  Ketika Anda membuka penghasil kata sandi satu kali dan melihat penghitung waktu kecil menghitung berapa banyak lagi kode yang valid, itu adalah TOTP.  Apa bedanya? </p><br><p>  <strong>Berbasis waktu</strong> berarti bahwa alih-alih nilai statis, waktu saat ini digunakan sebagai penghitung.  Atau, lebih tepatnya, "interval" (langkah waktu).  Atau bahkan jumlah interval saat ini.  Untuk menghitungnya, kami mengambil waktu Unix (jumlah milidetik sejak tengah malam pada 1 Januari 1970 UTC) dan membagi dengan jendela validitas kata sandi (biasanya 30 detik).  Server biasanya mentolerir penyimpangan kecil karena sinkronisasi jam tidak sempurna.  Biasanya 1 interval bolak-balik tergantung konfigurasi. </p><br><p>  Jelas, ini jauh lebih aman daripada skema HOTP.  Dalam skema terikat waktu, kode yang valid berubah setiap 30 detik, meskipun belum digunakan.  Dalam algoritma asli, kata sandi yang valid ditentukan oleh nilai penghitung saat ini pada jendela server + toleransi.  Jika Anda tidak mengautentikasi, kata sandi tidak akan diubah tanpa batas waktu.  Anda dapat membaca lebih lanjut tentang TOTP di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC6238</a> . </p><br><p>  Karena skema berbasis waktu adalah tambahan untuk algoritma asli, kita tidak perlu melakukan perubahan pada implementasi asli.  Kami akan menggunakan <code>requestAnimationFrame</code> dan akan memeriksa setiap frame apakah kami masih dalam interval waktu.  Jika tidak, buat penghitung baru dan hitung lagi HOTP.  Dengan mengabaikan semua kode kontrol, solusinya terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stepWindow = <span class="hljs-number"><span class="hljs-number">30</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 30 seconds in ms let lastTimeStep = 0; const updateTOTPCounter = () =&gt; { const timeSinceStep = Date.now() - lastTimeStep * stepWindow; const timeLeft = Math.ceil(stepWindow - timeSinceStep); if (timeLeft &gt; 0) { return requestAnimationFrame(updateTOTPCounter); } timeStep = getTOTPCounter(); lastTimeStep = timeStep; &lt;...update counter and regenerate...&gt; requestAnimationFrame(updateTOTPCounter); }</span></span></code> </pre> <br><h2 id="poslednie-shtrihi--podderzhka-qr-kodov">  Sentuhan Akhir - Dukungan QR Code </h2><br><p>  Biasanya, ketika kita mengkonfigurasi 2FA, kita memindai parameter awal dengan kode QR.  Ini berisi semua informasi yang diperlukan: skema yang dipilih, kunci rahasia, nama akun, nama penyedia, jumlah digit dalam kata sandi. </p><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya berbicara tentang bagaimana Anda dapat memindai kode QR langsung dari layar menggunakan API <code>getDisplayMedia</code> .  Berdasarkan materi itu, saya membuat perpustakaan kecil, yang akan kita gunakan sekarang.  Pustaka disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stream-display</a> , dan selain itu kami menggunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsQR yang</a> luar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa</a> . </p><br><p>  Tautan yang dikodekan QR memiliki format berikut: </p><br><pre> <code class="plaintext hljs">otpauth://TYPE/LABEL?PARAMETERS</code> </pre> <br><p>  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">otpauth://totp/label?secret=oyu55d4q5kllrwhy4euqh3ouw7hebnhm5qsflfcqggczoafxu75lsagt&amp;algorithm=SHA1&amp;digits=6&amp;period=30</code> </pre> <br><p>  Saya akan menghilangkan kode yang mengatur proses memulai tangkapan layar dan pengenalan, karena semua ini dapat ditemukan dalam dokumentasi.  Alih-alih, inilah cara menguraikan tautan ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setupFromQR = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(data); <span class="hljs-comment"><span class="hljs-comment">// drop the "//" and get TYPE and LABEL const [scheme, label] = url.pathname.slice(2).split('/'); const params = new URLSearchParams(url.search); const secret = params.get('secret'); let counter; if (scheme === 'hotp') { counter = params.get('counter'); } else { stepWindow = parseInt(params.get('period'), 10) * 1000; counter = getTOTPCounter(); } }</span></span></code> </pre> <br><p>  Di dunia nyata, kunci rahasia akan menjadi string yang dikodekan base- <strong>32</strong> (!), Karena beberapa byte mungkin tidak dapat dicetak.  Tetapi untuk kesederhanaan demonstrasi, kami menghilangkan poin ini.  Sayangnya, saya tidak dapat menemukan informasi mengapa base-32 atau hanya format seperti itu.  Tampaknya, tidak ada spesifikasi resmi untuk format URL ini, dan format itu sendiri diciptakan oleh Google.  Anda dapat membaca sedikit tentang dia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><p>  Untuk menghasilkan kode uji QR, saya sarankan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FreeOTP</a> . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Dan itu saja!  Sekali lagi, jangan lupa untuk menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> .  Ada juga tautan ke repositori dengan kode yang ada di balik itu semua. </p><br><p>  Hari ini kami telah membongkar teknologi yang cukup penting yang kami gunakan setiap hari.  Saya harap Anda belajar sesuatu yang baru untuk diri Anda sendiri.  Artikel ini memakan waktu lebih lama dari yang saya kira.  Namun, cukup menarik untuk mengubah spesifikasi kertas menjadi sesuatu yang berfungsi dan sangat familier. </p><br><p>  Sampai ketemu lagi! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462945/">https://habr.com/ru/post/id462945/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462933/index.html">Cara kerja pemblokiran Internet: ulasan metode modern dengan contoh nyata</a></li>
<li><a href="../id462935/index.html">Bagaimana cara tetap fokus saat bekerja di kantor rencana terbuka?</a></li>
<li><a href="../id462937/index.html">Konsep kain persisten untuk mengendalikan infrastruktur TI</a></li>
<li><a href="../id462939/index.html">10 Laporan C ++ Rusia teratas dan daftar putar konferensi akses terbuka</a></li>
<li><a href="../id462943/index.html">Berburu Wumpus atau pengalaman menulis game Android klasik</a></li>
<li><a href="../id462947/index.html">Kisah bagaimana PVS-Studio menemukan kesalahan di perpustakaan yang digunakan di ... PVS-Studio</a></li>
<li><a href="../id462949/index.html">Kisah bagaimana PVS-Studio menemukan kesalahan di perpustakaan yang digunakan di ... PVS-Studio</a></li>
<li><a href="../id462951/index.html">Di mana seseorang melihat bentuk, AI melihat tekstur</a></li>
<li><a href="../id462955/index.html">Transformasi digital pelatihan dan sertifikasi staf lapangan</a></li>
<li><a href="../id462957/index.html">Pro dan kontra: ambang harga untuk .org masih dibatalkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>