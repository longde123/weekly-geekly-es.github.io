<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰 👗 🧑🏿‍🤝‍🧑🏼 以.class文件字节码为例探索二进制格式。 👩🏿‍⚕️ 💛 🤶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果您不怕上面的图片，如果您知道big-endian与little-endian有何不同，如果您始终对二进制文件的“排列方式”感兴趣，那么本文适合您！ 
 引言 


 在Habré上，已经有几篇有关二进制格式的逆向工程以及.class文件的字节码结构研究的文章： 
 常数池 
 Java字节码基础...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>以.class文件字节码为例探索二进制格式。</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481260/"><p><img src="https://habrastorage.org/webt/2-/ht/7w/2-ht7w15prc6owrbxqrljbxmq0g.png" alt="图片"></p><br><p> 如果您不怕上面的图片，如果您知道big-endian与little-endian有何不同，如果您始终对二进制文件的“排列方式”感兴趣，那么本文适合您！ </p><a name="habracut"></a><br><h1 id="vvedenie"> 引言 </h1><br><p> 在Habré上，已经有几篇有关二进制格式的逆向工程以及.class文件的字节码结构研究的文章： <br>  <a href="https://habr.com/ru/post/222519/">常数池</a> <br>  <a href="https://habr.com/ru/post/111456/">Java字节码基础知识</a> ， <br>  <a href="https://habr.com/ru/post/264919/">Java字节码“ Hello world”</a> ， <br>  <a href="https://habr.com/ru/post/480550/">JVM</a>等<a href="https://habr.com/ru/post/480550/">字节码的Hello World</a> <br> 研究人员的任务是要么处理未知的二进制协议，要么挖掘有规范的二进制结构。 </p><br><p> 甚至在我还是学生的时候，我就对二进制格式产生了兴趣，并撰写了有关Linux文件系统驱动程序开发的学期论文。 几年后，我为法医专家讲授了Linux的基础知识-过去，Linux是新技术，大学毕业后年轻的专家可以向成年专家讲很多新知识。 告诉我如何使用dd从磁盘中删除转储，并将映像连接到另一台计算机进行研究后，我意识到磁盘映像包含许多有趣的信息。 如果您知道文件系统格式的规范并拥有适当的工具，则即使不挂载映像也可以提取此信息（呵呵，挂载-o循环...）。 不幸的是，我没有这样的工具。 </p><br><p> 几年后，我需要反编译Java库。 那时没有JD GUI，也没有意识形态反编译器，但有JAD。 对于我的库，JAD混合了Java操作码和错误消息。 此外，JAD不支持注释，在那时出现的Java 6中，它们已被完全使用。 有了Java虚拟机规范，我开始... </p><br><h1 id="ideya"> 主意 </h1><br><p> 我需要一个用于描述二进制结构的通用机制和一个通用加载程序。 加载程序将按照说明将二进制数据读入内存。 通常，您必须处理数字，字符串，数据数组和复合结构。 一切都很简单，用数字即可-它们具有固定的长度-1、2、4或8个字节，可以立即映射到该语言中可用的数据类型。 例如：Java的byte，short，int，long。 对于长于一个字节的数字类型，必须提供字节顺序标记（所谓的BigEndian / LittleEndiang表示形式）。 </p><br><p> 字符串更复杂-它们可以采用不同的编码（ASCII，UNICODE），具有固定或可变的长度。 固定长度的字符串可以视为字节数组。 对于可变长度的字符串，可以使用两个记录选项-在行的开头指示其长度（Pascal或Length前缀的字符串），或在行的末尾添加特殊字符以指示行的末尾。 作为这样的符号，使用值为零的字节（所谓的以空字符结尾的小数）。 这两种选择都有优点和缺点，对此的讨论不在本文讨论范围之内。 如果在开始时指定了大小，那么在开发格式时，您需要确定最大字符串长度：我们必须分配给长度标记的字节数取决于：1个字节2 <sup>8-1，2</sup>个字节2 16-1等。 </p><br><p> 我们将组合数据结构分为不同的类，继续分解为数字和字符串。 </p><br><h1 id="struktura-class-fayla">  .class文件的结构 </h1><br><p> 我们需要以某种方式描述Java .class文件的结构。 结果，我想拥有一组Java类，其中每个类仅包含与正在研究的数据结构相对应的字段，并且可能还包含在调用toString（）方法时以人类可读形式显示对象的辅助方法。 从类别上讲，我不想让内部逻辑负责读取或写入文件。 </p><br><p> 我们采用Java虚拟机的规范， <br>  <a href="https://docs.oracle.com/javase/specs/jvms/se12/jvms12.pdf" rel="nofollow">JVM规范，Java SE 12版</a> 。 <br> 我们将对第4节“类文件格式”感兴趣。 </p><br><p> 为了确定以什么顺序加载哪些字段，我们引入了@FieldOrder批注（index = ...）。 我们需要为加载程序明确指出字段的顺序，因为规范并不能保证我们将它们保存在二进制文件中的顺序。 </p><br><p>  Java .class文件以4个字节的幻数开头，两个字节为Java的次要版本，两个字节为主版本。 我们将魔术数字包装在int变量中，并将次要和主要版本号打包在一起： </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> magic; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> minorVersion; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> majorVersion;</code> </pre> <br><p>  .class文件中还包含常量池（两个字节的变量）和常量池本身的大小。 我们引入@ContainerSize批注以声明数组和列表结构的大小。 大小可以是固定的（我们将通过value属性设置）或具有可变长度，该长度由先前读取的变量确定。 在这种情况下，我们将使用“ fieldName”属性，该属性指示我们将从哪个变量读取容器的大小。 根据规范（第4.1节， <br>  “ ClassFile Structure”），常量池的实际大小与值相差1 <br> 将其写入constant_pool_count： </p><br><pre> <code class="plaintext hljs">u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1];</code> </pre> <br><p> 为了解决此类更正，我们在@ContainerSize批注中引入了一个额外的Corrector属性。 <br> 现在我们可以添加一个关于常量池的描述： </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> constantPoolCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"constantPoolCount"</span></span>, corrector = -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ConstantPoolItem&gt; constantPoolList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">对于更复杂的计算，您只需添加一个get方法即可返回所需的值：</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> containerSize; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(filed=<span class="hljs-string"><span class="hljs-string">"actualContainerSize"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ContainerItem&gt; containerItems; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActualContainerSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> containerSize * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> </div></div><br><h1 id="constant-pool"> 恒定池 </h1><br><p> 常量池中的每个元素要么是对类型为int，long，float，double，String的相应常量的描述，要么是对Java类的组件之一的描述-类字段（字段），方法，方法签名等。 术语“常量”在此处表示代码中使用的未命名值： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intValue &gt; <span class="hljs-number"><span class="hljs-number">100500</span></span>)</code> </pre> <br><p>  100500的值将在常量池中表示为CONSTANT_Integer的实例。  Java 12的JVM规范定义了可以在常量池中的17种类型。 </p><br><div class="spoiler">  <b class="spoiler_title">常量池元素的可能实例</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> 恒定型 </th><th> 标签 </th></tr></thead><tbody><tr><td>  CONSTANT_Class </td><td>  7 </td></tr><tr><td>  CONSTANT_Fieldref </td><td>  9 </td></tr><tr><td>  CONSTANT_Methodref </td><td>  10 </td></tr><tr><td>  CONSTANT_InterfaceMethodref </td><td>  11 </td></tr><tr><td>  CONSTANT_String </td><td>  8 </td></tr><tr><td>  CONSTANT_Integer </td><td>  3 </td></tr><tr><td>  CONSTANT_Float </td><td>  4 </td></tr><tr><td>  CONSTANT_Long </td><td>  5 </td></tr><tr><td>  CONSTANT_Double </td><td>  6 </td></tr><tr><td>  CONSTANT_NameAndType </td><td>  12 </td></tr><tr><td>  CONSTANT_Utf8 </td><td>  1个 </td></tr><tr><td>  CONSTANT_MethodHandle </td><td>  15 </td></tr><tr><td>  CONSTANT_MethodType </td><td>  16 </td></tr><tr><td>  CONSTANT_Dynamic </td><td>  17 </td></tr><tr><td>  CONSTANT_InvokeDynamic </td><td>  18岁 </td></tr><tr><td>  CONSTANT_Module </td><td>  19 </td></tr><tr><td>  CONSTANT_Package </td><td>  20 </td></tr></tbody></table></div></div></div><br><p> 在我们的实现中，我们将创建一个ConstantPoolItem类，其中将有一个单字节字段标记，该标记确定当前正在读取的结构。 对于上表中的每个元素，创建一个Java类，即ConstantPoolItem的后代。 通用二进制文件加载器应能够基于已读取的标签来确定应使用哪个类。 <br>  （通常，标签可以是任何类型的变量）。 为此，请定义HasInheritor接口，并在ConstantPoolItem类中实现此接口： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInheritor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends T&gt; getInheritor() <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InheritorNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;Class&lt;? extends T&gt;&gt; getInheritors(); }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInheritor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map&lt;Byte, Class&lt;? extends ConstantPoolItem&gt;&gt; m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span>, ClassInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">9</span></span>, FieldRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span>, MethodRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">11</span></span>, InterfaceMethodRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">8</span></span>, StringInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>, IntegerInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span>, FloatInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>, LongInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">6</span></span>, DoubleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">12</span></span>, NameAndTypeInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>, Utf8Info.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">15</span></span>, MethodHandleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span>, MethodTypeInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">17</span></span>, DynamicInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">18</span></span>, InvokeDynamicInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">19</span></span>, ModuleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">20</span></span>, PackageInfo.class); } <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> tag; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends ConstantPoolItem&gt; getInheritor() <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InheritorNotFoundException { Class&lt;? extends ConstantPoolItem&gt; clazz = m.get(tag); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InheritorNotFoundException(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().getName(), String.valueOf(tag)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;Class&lt;? extends ConstantPoolItem&gt;&gt; getInheritors() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.values(); } }</code> </pre> <br><p> 通用加载器将实例化所需的类并继续阅读。 唯一的条件：后继类中的索引必须与父类具有端到端编号。 这意味着在所有ConstantPoolItem的FieldOrder派生类中，注释的索引必须大于1，因为在父类中，我们已经读取了数字为“ 1”的标记字段。 </p><br><h1 id="struktura-class-fayla-prodolzhenie">  .class文件的结构（续） </h1><br><p> 在.class文件中的常量池的元素列表之后，有一个两字节的标识符定义了该类的详细信息-该类是否是注释，接口，抽象类，是否具有最终标志等。 其后是定义该类的两字节标识符（对常量池中元素的引用）。 该标识符必须指向ClassInfo类型的元素。 给定类的超类以类似的方式定义（在类定义中单词“ extends”之后指出）。 对于没有显式定义超类的类，此字段包含对Object类的引用。 </p><br><p> 在Java中，任何类都只能有一个超类，但是数量 <br> 此类可以实现几个接口： </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> interfacesCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"interfacesCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Short&gt; interfaceIndexList;</code> </pre> <br><p>  interfaceIndexList中的每个元素代表一个指向常量池中的元素的链接（如指定 <br> 索引应该是ClassInfo类型的元素）。 <br> 类变量（属性，字段）和方法由相应的列表表示： </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> fieldsCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"fieldsCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Field&gt; fieldList; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> methodsCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"methodsCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Method&gt; methodList;</code> </pre> <br><p>  Java .class文件的描述中的最后一个元素是类属性的列表。 可以在此处列出描述与类，嵌套类等相关的源文件的属性。 </p><br><p>  Java字节码以big-endian表示形式处理数字数据，默认情况下将使用此表示形式。 对于带有小尾数的二进制格式，我们将使用<a href="https://habr.com/ru/users/littleendian/" class="user_link">LittleEndian</a>批注。 对于没有预定义长度的字符串，但是 <br> 在终端字符（如C一样的以null终止的字符串）之前读取，我们将使用 <br>  @StringTerminator注释： </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@StringTerminator</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String nullTerminatedString;</code> </pre> <br><p> 有时在基础类中，您需要从更高级别转发信息。  methodList中的Method对象没有有关其所在类的名称的信息；此外，method对象不包含其名称和参数列表。 所有这些信息都以常量池中元素的索引形式显示。 这对于虚拟机来说已经足够了，但是我们想要实现toString（）方法，以便它们以一种人类友好的形式显示有关该方法的信息，而不是以常量池中元素的索引的形式显示。 为此，Method类必须获取对ConstantPoolList和具有thisClassIndex值的变量的引用。 为了能够将链接传递到嵌套的基础层，我们将使用<a href="https://habr.com/ru/users/inject/" class="user_link">Inject</a>注释： </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"methodsCount"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"constantPoolList"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"thisClassIndex"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Method&gt; methodList;</code> </pre> <br><p> 在当前类（ClassFile）中，将为constantPoolList和thisClassIndex变量调用getter方法，而在接收类（在本例中为Method）中，将调用setter方法（如果存在）。 </p><br><h1 id="universalnyy-zagruzchik"> 通用引导程序 </h1><br><p> 因此，我们有一个HasInheritor接口和五个批注@ FieldOrder，@ ContainerSize， <a href="https://habr.com/ru/users/littleendian/" class="user_link">LittleEndian</a> ， <a href="https://habr.com/ru/users/inject/" class="user_link">Inject</a>和@StringTerminator，它们使我们能够以较高的抽象级别描述二进制结构。 有了正式的描述，我们可以将其传递给通用加载器，通用加载器可以实例化所描述的结构，解析二进制文件并将其读入内存。 </p><br><p> 因此，我们应该能够使用以下代码： </p><br><pre> <code class="java hljs"> ClassFile classFile; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(inputFileName)) { Loader loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamLoader(is); classFile = (ClassFile) loader.load(); }</code> </pre> <br><p> 不幸的是，对于池中的八字节值，Java平台开发人员过于复杂。 <br> 为两个单元格提供了常量，第一个单元格必须包含一个值，第二个单元格保持不变 <br> 空的。 这适用于长常量和双常量。 </p><br><div class="spoiler">  <b class="spoiler_title">JVM规范中的描述</b> <div class="spoiler_text"><p> 所有8字节常量在类的constant_pool表中占据两个条目 <br> 文件。 如果CONSTANT_Long_info或CONSTANT_Double_info结构是条目 <br> 在constant_pool表中的索引n处，则表中的下一个可用条目是 <br> 位于索引n + 2处。  constant_pool索引n +1必须有效，但必须考虑 <br> 无法使用。 </p></div></div><br> 显然，Java开发人员希望应用某种低级优化，但后来 <br> 人们认识到这个设计决定 <br><div class="spoiler">  <b class="spoiler_title">不成功</b> <div class="spoiler_text"><p> 回想起来，让8字节常量采用两个常量池条目是一个糟糕的选择。 </p></div></div><br><p> 为了处理这些特定情况，我们将添加@EntrySize批注，我们将使用它， <br> 标记八字节常量： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EntrySize</span></span>(value = <span class="hljs-number"><span class="hljs-number">2</span></span>, index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EightByteNumberInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> highBytes; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lowBytes; }</code> </pre> <br><p>  value属性指示元素将占用的单元格数量，index-元素的索引， <br> 其中包含值。  LongInfo和DoubleInfo类将扩展EightByteNumberInfo类。 <br> 通用引导程序将需要使用支持@EntrySize注释的功能进行扩展。 </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassFileLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String fileName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { File f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(fileName); FileInputStream fis = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(f); loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntrySizeSupportLoader(fis); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } }</code> </pre> <br><p> 用ClassFileLoader加载类后，可以停止调试器并在IDE的变量检查器中检查加载的类。 </p><br><p> 该类文件将如下所示： <br><img src="https://habrastorage.org/webt/s6/jg/p_/s6jgp_an_ouz-lfdtc39d8gxd88.png" alt="图片"></p><br><p> 常量池是这样的： <br><img src="https://habrastorage.org/webt/5f/u4/sk/5fu4skrhx-jxhjjyiju4nc_apj0.png" alt="图片"></p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 可以读到最后的任何人都可能想要用自己的双手挑选Java字节码。 随意转到github并下载Java类文件的描述作为一组Java类： <a href="https://github.com/esavin/annotate4j-classfile" rel="nofollow">https</a> : <a href="https://github.com/esavin/annotate4j-classfile" rel="nofollow">//github.com/esavin/annotate4j-classfile</a> 。 通用加载程序和注释在这里： <a href="https://github.com/esavin/annotate4j-core" rel="nofollow">https</a> : <a href="https://github.com/esavin/annotate4j-core" rel="nofollow">//github.com/esavin/annotate4j-core</a> 。 </p><br><p> 要下载已编译的类文件，请使用annotate4j.classfile.loader.ClassFileLoader加载器。 </p><br><p> 大多数代码是为Java 6编写的，我只将常量池修改为现代版本。 我没有能力和欲望完全实现Java操作码的Java加载器，因此这部分只有很小的发展。 </p><br><p> 使用这个库（核心部分），我设法用Holter监视数据（每日心脏活动的ECG研究）还原了二进制文件。 另一方面，我无法解密用Delphi编写的一个记帐系统的二进制协议。 我不了解日期的传输方式，有时会出现一种情况，即实际数据与先前值建立的结构不符。 </p><br><p> 我试图为ELF格式（在Unix / Linux上可运行的格式）构建类似于Java类文件的模型，但是我无法完全理解该规范-事实证明这对我来说太模糊了。 相同的命运落在JPEG和BMP格式上-一直以来，我在理解规范方面遇到一些困难。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481260/">https://habr.com/ru/post/zh-CN481260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481250/index.html">AI vs测试人员，Brandashmyg，鸭子：Heisenbug 2019莫斯科怎么样</a></li>
<li><a href="../zh-CN481252/index.html">我们以华硕P9X79 WS为例，在旧主板上启用NVMe支持。</a></li>
<li><a href="../zh-CN481254/index.html">狂热的程序员。 内容概要1.为什么你需要变得更糟而不听父母的建议</a></li>
<li><a href="../zh-CN481256/index.html">我明天应该启动哪个创业公司？</a></li>
<li><a href="../zh-CN481258/index.html">我们将大篷车的车架粘上，无需注册和发送短信</a></li>
<li><a href="../zh-CN481264/index.html">在“每日应用”应用中有多少人在App Store中看到您的图标</a></li>
<li><a href="../zh-CN481272/index.html">冷冻或现代化-我们在度假做什么？</a></li>
<li><a href="../zh-CN481276/index.html">我如何为它创建YP和编译器长达12年</a></li>
<li><a href="../zh-CN481280/index.html">我们如何准备CTFZone-2020资格认证阶段</a></li>
<li><a href="../zh-CN481282/index.html">创意的价值是什么，以及如何将其转变为概念：游戏设计师工具</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>