<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❕ 🧑🏼‍🤝‍🧑🏻 🐠 تطبيقات ويندوز الأصلية وأكرونيس استعادة نشطة 👩🏼‍🤝‍👨🏽 🦕 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="نواصل اليوم قصة كيف نقوم ، مع رفاق جامعة Innopolis ، بتطوير تقنية Active Restore للسماح للمستخدم بالبدء في العمل على أجهزته في أقرب وقت ممكن بعد الفشل...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تطبيقات ويندوز الأصلية وأكرونيس استعادة نشطة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/481382/" style=";text-align:right;direction:rtl">  نواصل اليوم قصة كيف نقوم ، مع رفاق جامعة Innopolis ، بتطوير تقنية Active Restore للسماح للمستخدم بالبدء في العمل على أجهزته في أقرب وقت ممكن بعد الفشل.  سنتحدث عن تطبيقات Windows الأصلية ، بما في ذلك ميزات إنشائها وإطلاقها.  تحت القص - قليلا عن مشروعنا ، فضلا عن دليل عملي حول كيفية كتابة التطبيقات الأصلية. <br><br><img src="https://habrastorage.org/webt/rc/bv/yl/rcbvylee_0ylshzywkrdlip0c9o.jpeg"><br><a name="habracut"></a><br>  في المنشورات السابقة ، تحدثنا بالفعل عن ماهية <a href="https://habr.com/ru/company/acronis/blog/477658/">Active Restore</a> وكيف يطور الطلاب من Innopolis <a href="https://habr.com/ru/company/acronis/blog/479524/">الخدمة</a> .  اليوم أريد أن أركز على التطبيقات الأصلية ، التي نريد "دفن" خدمة الاسترداد النشطة الخاصة بها.  إذا نجح كل شيء ، فيمكننا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  قبل ذلك بكثير لبدء الخدمة نفسها </li><li style=";text-align:right;direction:rtl">  قبل ذلك بكثير للاتصال بالسحابة التي يكمن النسخ الاحتياطي </li><li style=";text-align:right;direction:rtl">  من السابق لأوانه فهم الوضع في النظام - التمهيد العادي أو الاسترداد </li><li style=";text-align:right;direction:rtl">  لاستعادة الملفات أقل بكثير مقدما </li><li style=";text-align:right;direction:rtl">  اسمح للمستخدم بالبدء بشكل أسرع. </li></ul><br><h3 style=";text-align:right;direction:rtl">  ما هو التطبيق الأصلي بشكل عام؟ </h3><br>  للإجابة على هذا السؤال ، دعونا نلقي نظرة على سلسلة المكالمات التي يجريها النظام ، على سبيل المثال ، إذا حاول مبرمج في تطبيقه إنشاء ملف. <br><br><img src="https://habrastorage.org/webt/gb/d_/a7/gbd_a7c7l1d-6dlo4zh-fygf5dm.jpeg"><br>  <i>بافل يوسيفوفيتش - برمجة Windows Kernel (2019)</i> <br><br>  يستخدم المبرمج الدالة <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> ، والتي تم التصريح عنها في ملف رأس fileapi.h ويتم تنفيذها في Kernel32.dll.  ومع ذلك ، لا تنشئ هذه الوظيفة نفسها ملفًا ؛ فهي تتحقق فقط من الوسائط عند الإدخال <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">وتستدعي</a> الدالة <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">NtCreateFile</a> (تشير بادئة Nt فقط إلى أن الوظيفة أصلية).  يتم الإعلان عن هذه الوظيفة في ملف الرأس winternl.h ويتم تنفيذها في ntdll.dll.  إنها تستعد للقفز إلى الفضاء النووي ، وبعد ذلك تقوم بإجراء مكالمة نظام لإنشاء ملف.  في هذه الحالة ، اتضح أن Kernel32 مجرد غلاف لـ Ntdll.  أحد الأسباب وراء ذلك ، لدى Microsoft القدرة على تغيير وظائف العالم الأصلي ، ولكن لا تلمس الواجهات القياسية.  لا توصي Microsoft باستدعاء الوظائف الأصلية مباشرةً ولا توثق معظمها.  بالمناسبة ، يمكن العثور على ميزات غير موثقة <a href="http://undocumented.ntinternals.net/">هنا</a> . <br><br>  الميزة الرئيسية للتطبيقات الأصلية هي أن ntdll يتم تحميله في النظام في وقت أبكر بكثير من kernel32.  هذا منطقي ، لأن kernel32 يتطلب Ntdll للعمل.  نتيجة لذلك ، يمكن أن تبدأ التطبيقات التي تستخدم الوظائف الأصلية في العمل قبل ذلك بكثير. <br><br>  وبالتالي ، فإن تطبيقات Windows الأصلية هي برامج يمكن تشغيلها في مرحلة مبكرة من تشغيل Windows.  يستخدمون وظائف فقط من Ntdll.  مثال على مثل هذا التطبيق: <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/autochk">autochk</a> الذي ينفذ <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chkdsk">أداة chkdisk</a> لفحص القرص بحثًا عن الأخطاء قبل بدء الخدمات الرئيسية.  في هذا المستوى نريد أن نرى استعادة نشطة لدينا. <br><br><h3 style=";text-align:right;direction:rtl">  ماذا نحتاج؟ </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (مجموعة تطوير برامج التشغيل) ، المعروفة الآن باسم WDK 7 (مجموعة برامج تشغيل Windows). </li><li style=";text-align:right;direction:rtl">  آلة افتراضية (مثل windows 7 x64) </li><li style=";text-align:right;direction:rtl">  ليس بالضرورة ، ولكن يمكن تنزيل ملفات الرأس <a href="https://github.com/arizvisa/ndk">هنا.</a> </li></ul><br><h3 style=";text-align:right;direction:rtl">  ما هو في الكود؟ </h3><br>  لنمارس بعض الشيء ، وعلى سبيل المثال سنكتب طلبًا صغيرًا: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يعرض رسالة على الشاشة. </li><li style=";text-align:right;direction:rtl">  يخصص القليل من الذاكرة </li><li style=";text-align:right;direction:rtl">  في انتظار إدخال لوحة المفاتيح </li><li style=";text-align:right;direction:rtl">  تحرر ذاكرة مشغول </li></ol><br>  في التطبيقات الأصلية ، ليست نقطة الإدخال هي العنصر الرئيسي أو نظام التشغيل الرئيسي ، ولكن وظيفة NtProcessStartup ، لأننا نبدأ بالفعل العملية الجديدة مباشرة في النظام. <br><br>  لنبدأ بعرض الرسالة على الشاشة.  للقيام بذلك ، لدينا دالة أصلية <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FError%252FNtDisplayString.html">NtDisplayString</a> ، والتي تأخذ كوسيطة مؤشر إلى كائن بنية UNICODE_STRING.  سوف RtlInitUnicodeString مساعدتنا في التهيئة.  نتيجة لذلك ، لعرض النص على الشاشة ، يمكننا كتابة مثل هذه الوظيفة الصغيرة: <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//usage: WriteLn(L"Here is my text\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); }</span></span></code> </pre> <br>  نظرًا لأن وظائف ntdll متاحة فقط لنا ، ولا توجد مكتبات أخرى في الذاكرة بعد ، فبالتأكيد سنواجه مشكلات في كيفية تخصيص الذاكرة.  المشغل الجديد غير موجود حتى الآن (لأنه يأتي من عالم C ++ عالي المستوى) ، كما لا توجد وظيفة malloc (يحتاج إلى مكتبات وقت التشغيل C).  يمكنك بالطبع استخدام فقط المكدس.  ولكن إذا كنا بحاجة إلى تخصيص ذاكرة بشكل حيوي ، فسيتعين علينا القيام بذلك على الكومة (أي الكومة).  لذلك ، دعونا ننشئ حفنة لأنفسنا وسنتخذ منها ذاكرة عندما نحتاج إليها. <br><br>  وظيفة <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcreateheap">RtlCreateHeap</a> مناسبة لهذه المهمة.  علاوة على ذلك ، باستخدام RtlAllocateHeap و RtlFreeHeap ، سنحتل الذاكرة الخالية عندما نحتاج إليها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">PVOID memory = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PVOID buffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ULONG bufferSize = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory);</span></span></code> </pre> <br>  دعنا ننتقل إلى انتظار إدخال لوحة المفاتيح. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //... HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } }</span></span></code> </pre> <br>  كل ما نحتاج إليه هو استخدام <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FFile%252FNtReadFile.html">NtReadFile</a> على جهاز مفتوح ، وانتظر حتى ترجع لوحة المفاتيح إلينا.  في حالة الضغط على مفتاح ESC ، سنواصل العمل.  لفتح الجهاز ، نحتاج إلى استدعاء وظيفة NtCreateFile (ستحتاج إلى فتح \ Device \ KeyboardClass0).  سوف نتصل أيضًا بـ <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FEvent%252FNtCreateEvent.html">NtCreateEvent</a> لتهيئة الكائن للانتظار.  سنعلن بشكل مستقل عن بنية KEYBOARD_INPUT_DATA تمثل بيانات لوحة المفاتيح.  هذا سيسهل عملنا. <br><br>  ينتهي التطبيق الأصلي بدعوة إلى الدالة <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FProcess%252FNtTerminateProcess.html">NtTerminateProcess</a> ، لأننا نقتل عمليتنا فقط. <br><br>  كل رمز تطبيق صغير لدينا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntifs.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// \WinDDK\7600.16385.1\inc\ddk #include "ntdef.h" //------------------------------------ // Following function definitions can be found in native development kit // but I am too lazy to include `em so I declare it here //------------------------------------ NTSYSAPI NTSTATUS NTAPI NtTerminateProcess( IN HANDLE ProcessHandle OPTIONAL, IN NTSTATUS ExitStatus ); NTSYSAPI NTSTATUS NTAPI NtDisplayString( IN PUNICODE_STRING String ); NTSTATUS NtWaitForSingleObject( IN HANDLE Handle, IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout ); NTSYSAPI NTSTATUS NTAPI NtCreateEvent( OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN EVENT_TYPE EventType, IN BOOLEAN InitialState ); // https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //---------------------------------------------------------- // Our code goes here //---------------------------------------------------------- // usage: WriteLn(L"Hello Native World!\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); } void NtProcessStartup(void* StartupArgument) { // it is important to declare all variables at the beginning HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; PVOID memory = NULL; PVOID buffer = NULL; ULONG bufferSize = 42; //use it if debugger connected to break //DbgBreakPoint(); WriteLn(L"Hello Native World!\n"); // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); WriteLn(L"Keyboard ready\n"); // create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); WriteLn(L"Heap ready\n"); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); WriteLn(L"Buffer allocated\n"); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory); WriteLn(L"Heap destroyed\n"); WriteLn(L"Press ESC to continue...\n"); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } } NtTerminateProcess(NtCurrentProcess(), 0); }</span></span></span></span></code> </pre> <br>  <b>PS:</b> يمكننا بسهولة استخدام الدالة DbgBreakPoint () في التعليمات البرمجية لإيقاف في المصحح.  صحيح ، سوف تحتاج إلى توصيل WinDbg إلى الجهاز الظاهري لتصحيح أخطاء kernel.  يمكن العثور على تعليمات حول كيفية القيام بذلك <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">هنا</a> أو فقط استخدام <a href="http://sysprogs.com/legacy/virtualkd/">VirtualKD</a> . <br><br><h3 style=";text-align:right;direction:rtl">  تجميع والتجمع </h3><br>  أسهل طريقة لإنشاء تطبيق أصلي هي استخدام <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (مجموعة تطوير برامج التشغيل).  نحتاج إلى الإصدار السابع القديم تمامًا ، نظرًا لأن الإصدارات الأحدث لها نهج مختلف قليلاً وتعمل عن قرب مع Visual Studio.  إذا استخدمنا DDK ، فإن مشروعنا يحتاج فقط إلى Makefile والمصادر. <br><br>  <i>ماكيفيلي</i> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">!INCLUDE $(NTMAKEENV)\makefile.def</code> </pre> <br>  <i>مصادر:</i> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">TARGETNAME = MyNative TARGETTYPE = PROGRAM UMTYPE = nt BUFFER_OVERFLOW_CHECKS = 0 MINWIN_SDK_LIB_PATH = $(SDK_LIB_PATH) SOURCES = source.c INCLUDES = $(DDK_INC_PATH); \ C:\WinDDK\7600.16385.1\ndk; TARGETLIBS = $(DDK_LIB_PATH)\ntdll.lib \ $(DDK_LIB_PATH)\nt.lib USE_NTDLL = 1</code> </pre> <br>  سيكون Makefile الخاص بك هو نفسه تمامًا ، ولكن دعنا نتعمق في المصادر بمزيد من التفاصيل.  يحتوي هذا الملف على مصادر البرنامج (ملفات .c) وخيارات الإنشاء والمعلمات الأخرى. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  TARGETNAME - اسم الملف القابل للتنفيذ ، والذي يجب أن يكون النتيجة. </li><li style=";text-align:right;direction:rtl">  TARGETTYPE - نوع الملف القابل للتنفيذ ، يمكن أن يكون برنامج تشغيل (.sys) ، ثم يجب أن تكون قيمة الحقل هي DRIVER ، إذا كانت المكتبة (.lib) ، فإن القيمة هي LIBRARY.  في حالتنا ، نحتاج إلى ملف قابل للتنفيذ (.exe) ، لذلك قمنا بتعيين القيمة إلى PROGRAM. </li><li style=";text-align:right;direction:rtl">  UMTYPE - القيم الممكنة لهذا الحقل: وحدة تحكم لتطبيق وحدة التحكم ، نوافذ للعمل في وضع الإطارات.  لكننا نحتاج إلى تحديد الإقليم الشمالي للحصول على التطبيق الأصلي. </li><li style=";text-align:right;direction:rtl">  BUFFER_OVERFLOW_CHECKS - التحقق من تكدس المخزن المؤقت لتجاوز سعة المخزن المؤقت ، وللأسف ليس في حالتنا ، أوقف تشغيله. </li><li style=";text-align:right;direction:rtl">  MINWIN_SDK_LIB_PATH - تشير هذه القيمة إلى المتغير SDK_LIB_PATH ، لا تقلق من أنك لم تعلن عن مثل هذا المتغير في النظام ، وفي اللحظة التي ندير فيها عملية الإنشاء المحددة من DDK ، سيتم الإعلان عن هذا المتغير وسيشير إلى المكتبات اللازمة. </li><li style=";text-align:right;direction:rtl">  المصادر - قائمة المصادر لبرنامجك. </li><li style=";text-align:right;direction:rtl">  يتضمن - ملفات رأس اللازمة للتجميع.  تشير عادةً إلى المسار إلى الملفات المرفقة مع DDK ، ولكن يمكنك تحديد أي ملفات أخرى بشكل اختياري. </li><li style=";text-align:right;direction:rtl">  TARGETLIBS - قائمة المكتبات التي تحتاج إلى ربط. </li><li style=";text-align:right;direction:rtl">  USE_NTDLL هو حقل مطلوب يجب تعيينه على الموضع 1. لأسباب واضحة. </li><li style=";text-align:right;direction:rtl">  USER_C_FLAGS - أي إشارات يمكنك استخدامها في توجيهات المعالج الأولي عند إعداد رمز التطبيق. </li></ul><br>  للبناء ، نحتاج إلى تشغيل الإصدار x86 (أو x64) تم التحقق منه ، وتغيير دليل العمل إلى مجلد المشروع وتنفيذ الأمر Build.  توضح النتيجة في لقطة الشاشة أننا جمعنا ملفًا قابلاً للتنفيذ. <br><br><img src="https://habrastorage.org/webt/9a/aj/hp/9aajhpa858ohtthlkjnenl1nnic.jpeg" alt="بناء"><br><br>  لا يمكن تشغيل هذا الملف بكل بساطة ، حيث يقسم النظام ويرسلنا للتفكير في سلوكه بسبب الخطأ التالي: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/zw/ev/zu/zwevzuxrc6zc8fvgye_msqa0k6y.jpeg" alt="خطأ"></div><br><br><h3 style=";text-align:right;direction:rtl">  كيفية تشغيل تطبيق أصلي؟ </h3><br>  في بداية autochk ، يتم تحديد تسلسل بدء تشغيل البرامج حسب قيمة مفتاح التسجيل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">HKLM\System\CurrentControlSet\Control\Session Manager\BootExecute</code> </pre> <br>  يقوم مدير الجلسة بتنفيذ البرامج من هذه القائمة واحدة تلو الأخرى.  يبحث مدير الجلسة نفسه عن الملفات القابلة للتنفيذ في الدليل system32.  تنسيق قيمة مفتاح التسجيل كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">autocheck autochk *MyNative</code> </pre> <br>  يجب أن تكون القيمة بالتنسيق الست عشري ، وليس بالتنسيق ASCII المعتاد ، لذلك ، سيكون المفتاح المعروض أعلاه بالتنسيق: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  لتحويل الاسم ، يمكنك استخدام خدمة عبر الإنترنت ، على سبيل المثال ، <a href="https://www.rapidtables.com/convert/number/ascii-to-hex.html">هذه الخدمة</a> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ii/ky/sn/iikysns0tim-qpz91mbazv4uepa.jpeg"></div><br>  اتضح أنه لتشغيل التطبيق الأصلي ، نحتاج إلى: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نسخ الملف القابل للتنفيذ إلى مجلد system32 </li><li style=";text-align:right;direction:rtl">  إضافة مفتاح إلى التسجيل </li><li style=";text-align:right;direction:rtl">  إعادة تشغيل الجهاز </li></ol><br>  للراحة ، إليك نص برمجي جاهز لتثبيت تطبيق أصلي: <br><br>  <i>install.bat</i> <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">@<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> off copy MyNative.exe %systemroot%\system32\. regedit /s add.reg <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Native Example Installed pause</code> </pre> <br>  <i>add.reg</i> <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager] <span class="hljs-string"><span class="hljs-string">"BootExecute"</span></span>=hex(7):61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  بعد التثبيت وإعادة التشغيل ، حتى قبل ظهور شاشة اختيار المستخدم ، نحصل على الصورة التالية: <br><br><img src="https://habrastorage.org/webt/yi/5p/7_/yi5p7_4vygq1wttxg_edlw-keqi.jpeg" alt="يؤدي"><br><br><h3 style=";text-align:right;direction:rtl">  يؤدي </h3><br>  باستخدام مثال هذا التطبيق الصغير ، كنا مقتنعين أنه من الممكن تمامًا تشغيل التطبيق على مستوى Windows الأصلي.  علاوة على ذلك ، سيستمر شباب جامعة Innopolis في إنشاء خدمة من شأنها أن تبدأ عملية التفاعل مع السائق في وقت أبكر بكثير من الإصدار السابق من مشروعنا.  ومع ظهور غلاف win32 ، سيكون من المنطقي نقل التحكم إلى خدمة كاملة تم تطويرها بالفعل (المزيد حول هذا <a href="https://habr.com/ru/company/acronis/blog/479524/">هنا</a> ). <br><br>  في المقالة التالية ، سنتطرق إلى مكون آخر من خدمة Active Restore ، وهي برنامج تشغيل UEFI.  اشترك في بلوق لدينا لا تفوت وظيفة المقبل. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar481382/">https://habr.com/ru/post/ar481382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar481370/index.html">غريتا Tunberg هو الصحيح؟ الطائرات VS القطارات</a></li>
<li><a href="../ar481372/index.html">ثنائي شجرة فهرسة</a></li>
<li><a href="../ar481374/index.html">Habr Weekly # 32 / أعطى Rambler الظهر ، والتلاعب في العمل ، وكيفية حماية مشروع الحيوانات الأليفة ، والأدوات تأخذ صور شخصية بهدوء</a></li>
<li><a href="../ar481376/index.html">تحليل الدروس التي تم تدريسها للمجتمع من خلال وضع NGINX</a></li>
<li><a href="../ar481378/index.html">كيفية تحسين تطوير التطبيق</a></li>
<li><a href="../ar481386/index.html">التدرج: إشارة صاخبة لتحسينه</a></li>
<li><a href="../ar481388/index.html">كيف تبني عمليات تبادل العملة المشفرة عقبات تتحدى DeFi</a></li>
<li><a href="../ar481390/index.html">أخبار من خريطة الشارع المفتوح رقم 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../ar481392/index.html">كما كتبت cryptocurrency في PHP. (الجزء الأول - الملخصات الأساسية + البداية السريعة)</a></li>
<li><a href="../ar481394/index.html">إعادة في لعبة جديدة ما أحببنا القديم</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>