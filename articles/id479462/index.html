<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”´ ğŸ‘¨ğŸ¼â€ğŸ”¬ ğŸ¯ Serialisasi dalam C ++ âœŠğŸ¾ ğŸ‘ğŸ» ğŸ§¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan fokus pada mengotomatiskan proses serialisasi di C ++. Pada awalnya, kami akan mempertimbangkan mekanisme dasar yang membuatnya lebih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serialisasi dalam C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479462/">  Artikel ini akan fokus pada mengotomatiskan proses serialisasi di C ++.  Pada awalnya, kami akan mempertimbangkan mekanisme dasar yang membuatnya lebih mudah untuk membaca / menulis data ke input / output stream, setelah itu deskripsi sistem pembuatan kode primitif berbasis libclang akan diberikan.  Tautan ke repositori dengan versi demo perpustakaan terletak di akhir artikel. <br><a name="habracut"></a><br>  Di ruSO, pertanyaan muncul secara berkala mengenai serialisasi data dalam C ++, kadang-kadang pertanyaan ini bersifat umum, ketika TC pada dasarnya tidak tahu harus mulai dari mana, kadang-kadang ini adalah pertanyaan yang menjelaskan masalah tertentu.  Tujuan artikel ini adalah untuk merangkum salah satu cara yang mungkin untuk mengimplementasikan serialisasi dalam C ++, yang akan memungkinkan Anda untuk mengikuti langkah-langkah membangun sistem dari langkah awal hingga beberapa kesimpulan logis, ketika sistem ini sudah dapat digunakan dalam praktik. <br><br><h2>  1. Informasi Awal </h2><br>  Artikel ini akan menggunakan format data biner, struktur yang ditentukan berdasarkan jenis objek serial.  Pendekatan ini menyelamatkan kita dari penggunaan pustaka pihak ketiga, membatasi diri kita hanya pada alat yang disediakan oleh pustaka C ++ standar. <br><br>  Karena proses serialisasi terdiri dalam mengubah keadaan suatu objek menjadi aliran byte, yang jelas harus disertai dengan operasi tulis, yang terakhir akan digunakan sebagai pengganti istilah "serialisasi" ketika menggambarkan detail tingkat rendah.  Demikian pula untuk baca / deserialize. <br><br>  Untuk mengurangi volume artikel, hanya contoh serialisasi objek yang akan diberikan (kecuali dalam kasus di mana deserialisasi mengandung beberapa detail yang layak disebutkan).  Kode lengkap dapat ditemukan di repositori di atas. <br><br><h2>  2. Jenis yang didukung </h2><br>  Pertama-tama, ada baiknya memutuskan jenis yang akan kami dukung - ini secara langsung tergantung pada bagaimana perpustakaan akan dilaksanakan. <br><br>  Misalnya, jika pilihan terbatas pada tipe dasar C ++, maka templat fungsi (yang merupakan kumpulan fungsi untuk bekerja dengan nilai-nilai tipe integer) dan spesialisasi eksplisitnya sudah cukup.  Template primer (digunakan untuk tipe std :: int32_t, std :: uint16_t, dll.): <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, T value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  <b>Catatan</b> : jika data yang diperoleh selama serialisasi direncanakan akan ditransfer antara mesin dengan pesanan byte yang berbeda, maka perlu, misalnya, untuk mengubah nilai dari pesanan byte lokal ke byte jaringan, dan kemudian melakukan operasi terbalik pada mesin jarak jauh, sehingga membuat perubahan akan diperlukan seperti untuk fungsi tulis data ke aliran output, dan untuk fungsi membaca dari aliran input. <br><br>  Spesialisasi untuk bool: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t_value = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'T'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f_value = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">'F'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmp = (value) ? t_value : f_value; os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;tmp), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tmp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Pendekatan ini mendefinisikan aturan berikut: jika nilai tipe T dapat direpresentasikan sebagai urutan byte ukuran panjang (T), definisi templat utama dapat digunakan untuk itu, jika tidak, maka perlu untuk menentukan spesialisasi.  Persyaratan ini dapat ditentukan oleh fitur representasi objek bertipe T dalam memori. <br><br>  Pertimbangkan wadah std :: string: jelas bahwa kita tidak dapat mengambil alamat objek dengan tipe yang ditentukan, melemparkannya ke pointer ke char dan menulisnya ke aliran output - itu artinya kita memerlukan spesialisasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) os.write(value.data(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Dua hal penting yang ingin disampaikan di sini: <br><br><ol><li>  Tidak hanya isi string ditulis ke aliran output, tetapi juga ukurannya. </li><li>  Cast std :: string :: size_type untuk mengetik std :: uint32_t.  Dalam hal ini, perlu memperhatikan bukan pada ukuran jenis target, tetapi pada fakta bahwa itu adalah panjang tetap.  Pengurangan seperti itu akan memungkinkan menghindari masalah dalam kasus ini, misalnya, jika data ditransmisikan melalui jaringan antara mesin dengan ukuran kata mesin yang berbeda. </li></ol><br>  Jadi, kami menemukan bahwa nilai tipe dasar (dan bahkan objek tipe std :: string) dapat ditulis ke aliran output menggunakan templat fungsi <b>tulis</b> .  Sekarang mari kita menganalisis perubahan apa yang perlu kita lakukan jika kita ingin menambahkan kontainer ke daftar jenis yang didukung.  Kami hanya memiliki satu opsi untuk kelebihan beban - gunakan parameter T sebagai jenis elemen wadah.  Dan jika dalam kasus std :: vector ini akan berfungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(value.cbegin(), value.cend(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; e) { size += ::write(os, e); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  , kemudian dengan std: map - no, karena std :: map templat membutuhkan setidaknya dua parameter - tipe kunci dan tipe nilai.  Jadi, pada tahap ini, kita tidak bisa lagi menggunakan templat fungsi - kita membutuhkan solusi yang lebih universal.  Sebelum kita mengetahui cara menambahkan dukungan kontainer, mari kita ingat bahwa kita masih memiliki kelas khusus.  Jelas, bahkan menggunakan solusi saat ini, tidak bijaksana untuk membebani fungsi <b>tulis</b> untuk setiap kelas yang memerlukan serialisasi.  Dalam kasus terbaik, kami ingin memiliki satu spesialisasi pola <b>tulis</b> yang berfungsi dengan tipe data khusus.  Tetapi untuk ini perlu bahwa kelas memiliki kemampuan untuk secara mandiri mengontrol serialisasi, masing-masing, mereka harus memiliki antarmuka yang akan memungkinkan pengguna untuk membuat cerita bersambung dan deserialize objek kelas ini.  Ternyata beberapa saat kemudian, antarmuka ini akan berfungsi sebagai "common denominator" untuk template <b>tulis</b> saat bekerja dengan kelas kustom.  Mari kita definisikan. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISerializable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ~ISerializable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream&amp; is)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialized_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  Setiap kelas yang mewarisi dari <b>ISerializable</b> setuju untuk: <br><br><ol><li>  Override <b>serialize</b> - status penulisan (anggota data) ke aliran output. </li><li>  Override <b>deserialize</b> - Baca status (inisialisasi anggota data) dari input stream. </li><li>  Override <b>serialized_size</b> - menghitung ukuran data serial untuk keadaan objek saat ini. </li></ol><br>  Jadi, kembali ke templat fungsi <b>tulis</b> : secara umum, kita dapat menerapkan spesialisasi untuk kelas <b>ISerializable</b> , tetapi kita tidak dapat menggunakannya, lihat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ISerializable&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value.serialize(os); }</code> </pre> <br>  Setiap kali, kita harus <b>melemparkan</b> tipe pewaris ke <b>ISerializable</b> untuk mengambil keuntungan dari spesialisasi ini.  Biarkan saya mengingatkan Anda bahwa pada awalnya kami menetapkan sebagai tujuan kami untuk menyederhanakan penulisan kode yang terkait dengan serialisasi, dan bukan sebaliknya, untuk menyulitkannya.  Jadi, jika tipe yang didukung oleh perpustakaan kami tidak terbatas pada tipe fundamental, maka kita harus mencari solusi lain. <br><br><h2>  3. stream_writer </h2><br>  Menggunakan templat fungsi untuk mengimplementasikan antarmuka universal untuk menulis data ke stream bukanlah solusi yang sepenuhnya cocok.  Opsi selanjutnya yang harus kita periksa adalah templat kelas.  Kami akan mengikuti metodologi yang sama seperti yang digunakan dengan templat fungsi - templat utama akan digunakan secara default, dan spesialisasi eksplisit akan ditambahkan untuk mendukung jenis yang diperlukan. <br><br>  Selain itu, kita harus memperhitungkan semua hal di atas tentang <b>ISerializable</b> - jelas, kita tidak akan dapat menyelesaikan masalah dengan banyak kelas penerus tanpa beralih ke type_traits: dimulai dengan C ++ 11, template std :: enable_if telah muncul di perpustakaan standar, yang memungkinkan mengabaikan kelas template ketika kondisi tertentu selama kompilasi - dan inilah yang akan kita manfaatkan. <br><br>  <b>Template</b> kelas <b>Stream_writer</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; class stream_writer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; };</code> </pre> <br>  Definisi metode <b>penulisan</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, U&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  Spesialisasi untuk <b>ISerializable</b> adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, only_if_serializable&lt;T&gt;&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> stream_io&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; };</code> </pre> <br>  di mana only_if_serializable adalah tipe pembantu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> only_if_serializable = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of_v&lt;ISerializable, T&gt;&gt;;</code> </pre> <br>  Jadi, jika tipe T adalah kelas yang berasal dari <b>ISerializable</b> , maka spesialisasi ini akan dianggap sebagai kandidat untuk instantiasi, masing-masing, jika tipe T tidak dalam hierarki kelas yang sama dengan <b>ISerializable</b> , maka akan dikeluarkan dari calon yang mungkin. <br><br>  Akan adil untuk mengajukan pertanyaan berikut di sini: bagaimana cara kerjanya?  Setelah semua, templat utama akan memiliki nilai parameter khas yang sama dengan spesialisasi - &lt;T, void&gt;.  Mengapa spesialisasi akan diberikan preferensi, dan apakah itu akan menjadi?  Jawab: akan, karena perilaku tersebut ditentukan oleh standar ( <a href="" rel="nofollow">sumber</a> ): <br><br><blockquote>  (1.1) Jika tepat satu spesialisasi yang cocok ditemukan, instantiasi dihasilkan dari spesialisasi itu </blockquote><br>  Spesialisasi untuk std :: string sekarang akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, only_if_string&lt;T&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, only_if_string&lt;T&gt;&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) os.write(value.data(), len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); }</code> </pre> <br>  di mana only_if_string dinyatakan sebagai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> only_if_string = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;;</code> </pre> <br>  Sudah waktunya untuk kembali ke wadah.  Dalam kasus ini, kita dapat menggunakan tipe wadah parameter dengan beberapa tipe U, atau &lt;U, V&gt;, seperti dalam kasus std :: map, langsung sebagai nilai parameter T dari templat kelas <b>stream_writer</b> .  Dengan demikian, tidak ada perubahan pada antarmuka di antarmuka kami - inilah yang kami tuju.  Namun, muncul pertanyaan, apa yang harus menjadi parameter kedua dari template untuk kelas <b>stream_writer sehingga</b> semuanya berfungsi dengan benar?  Ini ada di bab selanjutnya. <br><br><h2>  4. Konsep </h2><br>  Pertama, saya akan memberikan deskripsi singkat tentang konsep-konsep yang digunakan, dan hanya kemudian saya akan menunjukkan contoh yang diperbarui. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept String = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;;</code> </pre> <br>  Sejujurnya, konsep ini didefinisikan untuk penipuan, yang akan kita lihat pada baris berikutnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept Container = !String&lt;T&gt; &amp;&amp; requires (T a) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::value_type; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::reference; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_reference; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::size_type; { a.begin() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; { a.end() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::iterator; { a.cbegin() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; { a.cend() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::const_iterator; { a.clear() } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre> <br>  <b>Wadah</b> berisi persyaratan yang kami â€œbuatâ€ untuk jenis untuk benar-benar memastikan bahwa itu adalah salah satu jenis wadah.  Ini persis seperangkat persyaratan yang akan kita butuhkan ketika menerapkan <b>stream_writer</b> , standar memiliki lebih banyak persyaratan, tentu saja. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept SequenceContainer = Container&lt;T&gt; &amp;&amp; requires (T a, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::size_type count) { { a.resize(count) } -&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre> <br>  Konsep untuk wadah berurutan: std :: vector, std :: list, dll. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept AssociativeContainer = Container&lt;T&gt; &amp;&amp; requires (T a) { <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::key_type; };</code> </pre> <br>  Konsep untuk wadah asosiatif: std :: map, std :: set, std :: unordered_map, dll. <br><br>  Sekarang, untuk menentukan spesialisasi untuk peti kemas berturut-turut, yang tersisa untuk kita lakukan adalah memberlakukan batasan pada tipe T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires SequenceContainer&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires SequenceContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-comment"><span class="hljs-comment">// to support std::forward_list we have to use std::distance() const auto len = static_cast&lt;std::uint16_t&gt;( std::distance(value.cbegin(), value.cend())); os.write(reinterpret_cast&lt;const char*&gt;(&amp;len), sizeof(len)); auto size = static_cast&lt;std::size_t&gt;(os.tellp() - pos); if (len &gt; 0) { using value_t = typename stream_writer::value_type; std::for_each(value.cbegin(), value.cend(), [&amp;](const auto&amp; item) { size += stream_writer&lt;value_t&gt;::write(os, item); }); } return size; }</span></span></code> </pre> <br>  Kontainer yang didukung: <br><br><ul><li>  std :: vektor </li><li>  std :: deque </li><li>  std :: daftar </li><li>  std :: forward_list </li></ul><br>  Demikian pula untuk wadah asosiatif: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream_writer</span></span></span><span class="hljs-class">&lt;T, void&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> stream_io&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_writer&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::write(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = os.tellp(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_writer::size_type&gt;(value.size()); os.write(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(os.tellp() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_writer::value_type; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(value.cbegin(), value.cend(), [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; item) { size += stream_writer&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt;::write(os, item); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Kontainer yang didukung: <br><br><ul><li>  std :: map </li><li>  std :: unordered_map </li><li>  std :: set </li><li>  std :: unordered_set </li></ul><br>  Dalam hal peta, ada sedikit nuansa, ini menyangkut implementasi <b>stream_reader</b> .  Value_type untuk std :: map &lt;K, T&gt; adalah std :: pair &lt;const K, T&gt;, masing-masing, ketika kita mencoba untuk melemparkan sebuah pointer ke const K ke sebuah pointer ke char saat membaca dari aliran input, kita mendapatkan kesalahan kompilasi.  Kita dapat memecahkan masalah ini sebagai berikut: kita tahu bahwa untuk wadah asosiatif value_type adalah tipe tunggal K atau std :: pair &lt;const K, V&gt;, maka kita dapat menulis kelas pembantu template kecil yang akan di-parameterisasi oleh value_type dan di dalamnya tentukan jenis yang kita butuhkan. <br><br>  Untuk std :: set, semuanya tetap tidak berubah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; struct converter { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = U; };</code> </pre> <br>  Untuk std :: map - hapus const: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">converter</span></span></span><span class="hljs-class">&lt;U, only_if_pair&lt;U&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U::first_type&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U::second_type&gt;; };</code> </pre> <br>  Definisi <b>baca</b> untuk wadah asosiatif: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; requires AssociativeContainer&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_reader&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;::read(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is, T&amp; value) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pos = is.tellg(); <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_reader::size_type len = <span class="hljs-number"><span class="hljs-number">0</span></span>; is.read(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;len), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(len)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(is.tellg() - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0U</span></span>; i &lt; len; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> converter&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> stream_reader::value_type&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> v {}; size += stream_reader&lt;<span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span>&gt;::read(is, v); value.insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(v)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br><br><h2>  5. Fungsi bantu </h2><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISerializable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: User(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view username, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view password) : m_username(username) , m_password(password) {} SERIALIZABLE_INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_username {}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_password {}; };</code> </pre> <br>  Definisi metode serialisasi (std :: ostream &amp;) untuk kelas ini akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> User::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-number"><span class="hljs-number">0U</span></span>; size += stream_writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::write(os, m_username); size += stream_writer&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::write(os, m_password); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Namun, Anda harus mengakui bahwa merepotkan untuk menunjukkan setiap kali jenis objek yang ditulis ke aliran output.  Kami menulis fungsi bantu yang akan secara otomatis menyimpulkan tipe T: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stream_writer&lt;T&gt;::write(os, value); }</code> </pre> <br>  Sekarang definisinya adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> User::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = <span class="hljs-number"><span class="hljs-number">0U</span></span>; size += ::write(os, m_username); size += ::write(os, m_password); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; }</code> </pre> <br>  Bab terakhir akan membutuhkan beberapa fungsi pembantu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ::write(os, value); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp;... values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = write_recursive(os, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size + write_recursive(os, values...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; os, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp;... values)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::size_t </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> write_recursive(os, values...); }</code> </pre> <br>  Fungsi <b>write_all</b> memungkinkan <b>Anda</b> untuk membuat daftar semua objek yang akan diserialisasi sekaligus, sementara <b>write_recursive</b> memastikan urutan penulisan yang benar untuk aliran output.  Jika urutan perhitungan didefinisikan untuk <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">ekspresi lipatan</a> (asalkan kita menggunakan operator biner +), kita bisa menggunakannya.  Secara khusus, dalam fungsi <b>size_of_all</b> (tidak disebutkan sebelumnya, digunakan untuk menghitung ukuran data serial), itu adalah ekspresi-lipat yang digunakan karena tidak adanya operasi input-output. <br><br><h2>  6. Pembuatan Kode </h2><br>  API libclang - C untuk dentang digunakan untuk menghasilkan kode.  Tugas tingkat tinggi ini dapat digambarkan sebagai berikut: kita perlu secara rekursif berkeliling direktori dengan kode sumber, memeriksa semua file header untuk kelas yang ditandai dengan atribut khusus, dan jika ada, periksa anggota data untuk atribut yang sama dan kompilasi serangkaian nama anggota data terdaftar dengan koma.  Yang tersisa untuk kita lakukan adalah menulis templat definisi untuk fungsi-fungsi kelas <b>ISerializable</b> (di mana kita hanya bisa memasukkan penghitungan anggota data yang diperlukan). <br><br>  Contoh kelas di mana kode akan dihasilkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">annotate</span></span></span><span class="hljs-class">("</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serializable</span></span></span><span class="hljs-class">"))) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISerializable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: User(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view username, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view password) : m_username(username) , m_password(password) {} User() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~User() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; SERIALIZABLE_INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: __attribute__((annotate(<span class="hljs-string"><span class="hljs-string">"serializable"</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_username {}; __attribute__((annotate(<span class="hljs-string"><span class="hljs-string">"serializable"</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_password {}; };</code> </pre> <br>  Atribut ditulis dalam gaya GNU karena libclang menolak untuk mengenali format atribut dari C ++ 20, dan atribut itu juga tidak mendukung atribut yang tidak dianotasi.  Sumber Direktori Traversal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; file : fs::recursive_directory_iterator(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.is_regular_file() &amp;&amp; file.path().extension() == <span class="hljs-string"><span class="hljs-string">".hpp"</span></span>) { processTranslationUnit(file, dst); } }</code> </pre> <br>  Definisi fungsi <b>processTranslationUnit</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processTranslationUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; targetDir)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pathname = path.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(); arg::Context context { <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> translationUnit = arg::TranslationUnit::parse(context, pathname.c_str(), CXTranslationUnit_None); arg::ClassExtractor extractor; extractor.extract(translationUnit.cursor()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; classes = extractor.classes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [name, c] : classes) { SerializableDefGenerator::processClass(c, path, targetDir.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()); } }</code> </pre> <br>  Dalam fungsi ini, hanya <b>ClassExtractor</b> yang menarik bagi kami - yang lainnya diperlukan untuk membentuk AST.  Definisi fungsi <b>ekstrak</b> adalah sebagai berikut: <br><br><pre> <code class="cpp hljs">  <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClassExtractor::extract(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CXCursor&amp; cursor) { clang_visitChildren(cursor, [](CXCursor c, CXCursor, CXClientData data) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clang_getCursorKind(c) == CXCursorKind::CXCursor_ClassDecl) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -    - */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CXChildVisit_Continue; } , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Di sini kita sudah melihat langsung fungsi C API untuk dentang.  Kami sengaja meninggalkan hanya kode yang diperlukan untuk memahami bagaimana libclang digunakan.  Segala sesuatu yang tertinggal di belakang layar tidak mengandung informasi penting - itu hanya registrasi nama kelas, anggota data, dll.  Kode yang lebih terperinci dapat ditemukan di repositori. <br><br>  Dan akhirnya, dalam fungsi <b>processClass</b> , keberadaan atribut serialisasi dari setiap kelas yang ditemukan diperiksa, dan jika ada, file dihasilkan dengan definisi fungsi yang diperlukan.  Repositori memberikan contoh spesifik: di mana mendapatkan nama namespace (informasi ini disimpan langsung di kelas <b>Class</b> ) dan path ke file header. <br><br>  <i>Untuk tugas yang disebutkan di atas, perpustakaan Argentum digunakan, yang, sayangnya, saya tidak menyarankan Anda untuk menggunakannya - saya mulai mengembangkannya untuk tujuan lain, tetapi karena untuk tugas ini saya hanya memerlukan fungsionalitas yang diterapkan di sana, dan saya malas, Saya tidak menulis ulang kode, tetapi hanya mempostingnya di Bintray dan menghubungkannya ke file CMake melalui manajer paket Conan.</i>  <i>Semua yang disediakan perpustakaan ini adalah pembungkus sederhana di atas dentang API C untuk kelas dan anggota data.</i> <br><br>  Dan satu lagi komentar kecil - Saya tidak menyediakan perpustakaan yang sudah jadi, saya hanya memberi tahu cara menulisnya. <br><br>  <b>UPD0</b> : cppast dapat digunakan <a href="https://github.com/foonathan/cppast" rel="nofollow">sebagai pengganti libclang</a> .  Terima kasih kepada <a href="https://habr.com/ru/users/masterspline/" class="user_link">masterspline</a> untuk tautan yang disediakan. <br><br>  1. <a href="https://github.com/isnullxbh/dsl" rel="nofollow">github.com/isnullxbh/dsl</a> <br>  2. <a href="https://github.com/isnullxbh/Argentum" rel="nofollow">github.com/isnullxbh/Argentum</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479462/">https://habr.com/ru/post/id479462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479446/index.html">Mobil sudah di depan orang dalam tes membaca; tetapi apakah mereka mengerti apa yang mereka baca?</a></li>
<li><a href="../id479450/index.html">AppCode 2019.3: bekerja lebih cepat, memahami Swift lebih baik, tahu tentang Mac Catalyst, dengan mudah menampilkan pesan perakitan</a></li>
<li><a href="../id479452/index.html">Bagaimana Sistem Nama Domain Dikembangkan: Era ARPANET</a></li>
<li><a href="../id479458/index.html">Keindahan atau kepraktisan di ruang server</a></li>
<li><a href="../id479460/index.html">Panduan untuk Mobil Terbang</a></li>
<li><a href="../id479464/index.html">Pipa & Filter. Contoh aplikasi dan implementasi menggunakan Spring</a></li>
<li><a href="../id479466/index.html">Habraiting 2019: statistik dan peringkat artikel terbaik untuk 2019</a></li>
<li><a href="../id479468/index.html">Edge of Honesty dan John Doe</a></li>
<li><a href="../id479474/index.html">Mengapa self-organisasi tim sangat penting dalam Scrum dan mengapa tidak ada manajer di dalamnya</a></li>
<li><a href="../id479478/index.html">Plug-in Java tanpa rasa sakit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>