<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾 ✋🏻 🧙🏼 Pourquoi JavaScript est-il requis en mode strict? 🕑 🚣🏻 🍓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le mode strict est une partie importante du JavaScript moderne. C'est ce mode qui permet aux développeurs d'utiliser une syntaxe plus limitée que la s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi JavaScript est-il requis en mode strict?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477284/">  Le mode strict est une partie importante du JavaScript moderne.  C'est ce mode qui permet aux développeurs d'utiliser une syntaxe plus limitée que la syntaxe standard. <br><br>  La sémantique du mode strict est différente du mode traditionnel non strict, qui est parfois appelé «mode bâclé».  Dans ce mode, les règles de syntaxe de la langue ne sont pas aussi strictes et lorsque certaines erreurs se produisent, le système n'en informe pas l'utilisateur.  Autrement dit, les erreurs peuvent être ignorées et le code dans lequel elles sont produites peut être exécuté davantage.  Cela peut conduire à des résultats d'exécution de code inattendus. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/477284/"><img src="https://habrastorage.org/webt/cm/tk/0u/cmtk0u9w_n1ifbiykbgvswupxcm.jpeg"></a> <br><br>  Le mode strict introduit quelques changements dans la sémantique de JavaScript.  Il empêche le système de fermer les yeux sur les erreurs en lançant des exceptions appropriées.  Cela provoque l'arrêt du programme. <br><br>  Le mode strict, en outre, aide à écrire des programmes dans lesquels il n'y a pas de défauts qui empêchent les moteurs JS d'optimiser le code.  De plus, dans ce mode, il est interdit d'utiliser des éléments de syntaxe qui pourraient avoir une signification particulière dans les futures versions du langage. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Caractéristiques de l'utilisation du mode strict</font> </h2><br>  Le mode strict peut être appliqué à des fonctions individuelles ou à un script entier.  Il ne peut pas être appliqué uniquement à des instructions individuelles ou à des blocs de code entre accolades.  Afin d'utiliser le mode strict au niveau de l'ensemble du script, au tout début du fichier, avant toute autre commande, vous devez mettre l' <code>"use strict"</code> ou <code>'use strict'</code> construction <code>'use strict'</code> . <br><br>  Si le projet contient des scripts qui n'utilisent pas le mode strict et d'autres qui utilisent ce mode, il peut arriver que ces scripts soient fusionnés. <br><br>  Cela conduira au fait que le code qui n'est pas destiné à être exécuté en mode strict sera dans un tel état lorsque le système essaiera de l'exécuter en mode strict.  L'inverse est également possible - le code écrit pour le mode strict tombera en mode non strict.  Par conséquent, il est préférable de ne pas mélanger les scripts «stricts» et «non stricts». <br><br>  Comme déjà mentionné, le mode strict peut être appliqué aux fonctions individuelles.  Pour ce faire <code>"use strict"</code> ou <code>'use strict'</code> doit être placée en haut du corps de la fonction, avant toute autre commande.  Le mode strict de cette approche s'applique à tout ce qui est placé dans le corps de la fonction, y compris les fonctions imbriquées. <br><br>  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strictFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nestedFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{    <span class="hljs-comment"><span class="hljs-comment">//        } }</span></span></code> </pre> <br>  Dans les modules JavaScript apparus dans la norme ES2015, le mode strict est activé par défaut.  Par conséquent, lorsque vous travaillez avec eux, vous n'avez pas besoin de l'inclure explicitement. <br><br><h2>  <font color="#3AC1EF">Modifications apportées au code JS par mode strict</font> </h2><br>  Le mode strict affecte à la fois la syntaxe du code et la façon dont le code se comporte pendant l'exécution du programme.  Les erreurs dans le code sont converties en exceptions.  Le fait qu'en mode silencieux plante silencieusement en mode strict provoque un message d'erreur.  Ceci est similaire à la façon dont le système répond aux erreurs de syntaxe en mode laxiste.  En mode strict, le travail avec les variables est simplifié, l'utilisation de la fonction <code>eval</code> et l'objet <code>arguments</code> sont strictement réglementés, et le travail avec les constructions qui peuvent être implémentées dans les futures versions du langage est rationalisé. <br><br><h3>  <font color="#3AC1EF">▍ Convertir les erreurs silencieuses en exceptions</font> </h3><br>  Les erreurs silencieuses sont converties en mode strict en exceptions.  En mode laxiste, le système ne répond pas explicitement à de telles erreurs.  En mode strict, la présence de telles erreurs conduit à une inopérabilité du code. <br><br>  Ainsi, grâce à cela, il est difficile de commettre l'erreur de déclarer accidentellement une variable globale, car les variables et les constantes en mode strict ne peuvent pas être déclarées sans utiliser les directives <code>var</code> , <code>let</code> ou <code>const</code> .  Par conséquent, la création de variables sans ces directives entraînera une inopérabilité du programme.  Par exemple, la tentative d'exécution du code suivant lèvera une exception <code>ReferenceError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; badVariable = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Un tel code ne peut pas être exécuté en mode strict, car si le mode strict était désactivé, il créerait une variable globale <code>badVariable</code> .  Le mode strict empêche le programmeur de créer par inadvertance des variables globales. <br><br>  Une tentative d'exécution d'un code qui, en mode normal, ne fonctionne tout simplement pas, lève maintenant une exception.  Les erreurs sont considérées comme des constructions syntaxiques incorrectes qui ont simplement été ignorées en mode laxiste. <br><br>  Ainsi, par exemple, en mode strict, vous ne pouvez pas effectuer d'opérations d'attribution de valeur sur des entités en lecture seule telles que des <code>arguments</code> , <code>NaN</code> ou <code>eval</code> . <br><br>  En mode strict, une exception, par exemple, sera levée dans les cas suivants: <br><br><ul><li>  une tentative d'attribution d'une valeur à une propriété en lecture seule, telle qu'une sorte de propriété globale réinscriptible; </li><li>  une tentative d'écrire une valeur dans une propriété qui n'a qu'un getter; </li><li>  Une tentative d'écrire quelque chose dans une propriété d'un objet non extensible. </li></ul><br>  Voici des exemples de constructions de syntaxe menant à des exceptions de mode strictes: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); obj.foo = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj2 = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>; } }; obj2.foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fixedObj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(fixedObj); fixed.bar= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Tenter d'exécuter de tels fragments de code en mode strict <code>TypeError</code> une exception <code>TypeError</code> .  Par exemple, <code>undefined</code> et <code>Infinity</code> sont des entités globales dont les valeurs ne peuvent pas être écrasées et la propriété <code>foo</code> de l'objet <code>obj</code> ne prend pas en charge la réécriture.  La propriété <code>foo</code> de <code>obj2</code> n'a qu'un getter.  L'objet <code>fixedObj</code> rendu non extensible à l'aide de la méthode <code>Object.preventExtensions</code> . <br><br>  Une tentative de suppression d'une <code>TypeError</code> entraînera également <code>TypeError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype</code> </pre> <br>  Le mode strict interdit d'attribuer des propriétés du même nom à un objet.  Par conséquent, une tentative d'exécution du code suivant entraînera une erreur de syntaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Le mode strict requiert que les noms des paramètres de fonction soient uniques.  En mode non strict, si, par exemple, deux paramètres d'une fonction ont le même nom, alors, lors du passage de la fonction d'argument, la valeur du paramètre sera celle qui est tombée dans l'argument déclaré en dernier. <br><br>  En mode strict, les paramètres des fonctions du même nom sont interdits.  Par conséquent, une tentative d'exécution du code suivant entraînera une erreur de syntaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multiply = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x*x*y;</code> </pre> <br>  En mode strict, vous ne pouvez pas utiliser la notation octale des nombres, précédant le nombre de zéro.  Ce n'est pas dans la spécification, mais cette fonctionnalité est prise en charge par les navigateurs. <br><br>  Cet état de choses confond les développeurs, les obligeant à croire que le 0 précédant le nombre est simplement ignoré, sans grand sens.  En mode strict, essayer d'utiliser un nombre au début duquel est 0 entraînera une erreur de syntaxe. <br><br>  Le mode strict interdit également l'utilisation de constructions qui entravent l'optimisation.  L'interpréteur, avant d'effectuer l'optimisation du code, doit savoir que la variable est stockée exactement où, selon l'interprète, elle est stockée.  En mode strict, les choses qui interfèrent avec les optimisations sont interdites. <br><br>  Un exemple d'une telle interdiction concerne la déclaration <code>with</code> .  Si vous utilisez cette instruction, cela empêche l'interpréteur JS de savoir à quelle variable ou à quelle propriété nous faisons référence, car il est possible qu'une entité du même nom existe à la fois à l'extérieur et à l'intérieur du bloc de l'instruction <code>with</code> . <br><br>  Supposons qu'il existe un code comme celui-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  L'interpréteur ne pourra pas savoir si la variable <code>x</code> située à l'intérieur du bloc <code>with</code> fait référence à la variable externe <code>x</code> ou à la propriété <code>obj.x</code> de l'objet <code>obj</code> . <br><br>  Par conséquent, on ne sait pas exactement où la valeur <code>x</code> sera située en mémoire.  Afin de se débarrasser de telles ambiguïtés, en mode strict, l'utilisation de l'instruction <code>with</code> est interdite.  Voyons ce qui se passe si vous essayez d'exécuter le code suivant en mode strict: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  Le résultat de cette tentative sera une erreur de syntaxe. <br><br>  Même en mode strict, il est interdit de déclarer des variables dans le code passé à la méthode <code>eval</code> . <br><br>  Par exemple, en mode normal, une commande de la forme <code>eval('let x')</code> entraînera la déclaration de la variable <code>x</code> .  Cela permet aux programmeurs de masquer les déclarations de variables dans des chaînes, ce qui peut conduire à écraser les définitions des mêmes variables en dehors de <code>eval</code> . <br><br>  Pour éviter cela, en mode strict, il est interdit de déclarer des variables dans le code passé en chaîne à la méthode <code>eval</code> . <br><br>  Le mode strict interdit également la suppression des variables régulières.  Par conséquent, la tentative d'exécution du code suivant entraînera une erreur de syntaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> x;</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Interdire les constructions de syntaxe incorrectes</font> </h3><br>  En mode strict, l'utilisation incorrecte de <code>eval</code> et des <code>arguments</code> interdite.  Il s'agit d'une interdiction de toutes sortes de manipulations avec eux.  Par exemple, cela revient à leur attribuer de nouvelles valeurs, en utilisant leurs noms comme noms de variable, fonctions, paramètres de fonction. <br><br>  Voici des exemples d'utilisation abusive de l' <code>eval</code> et des <code>arguments</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>++; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>--; ++<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>--; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { set p(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eval</span></span></span><span class="hljs-function">) </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'arguments'</span></span>, <span class="hljs-string"><span class="hljs-string">"'use strict'; return 1;"</span></span>);</code> </pre> <br>  En mode strict, vous ne pouvez pas créer d'alias pour l'objet <code>arguments</code> et définir de nouvelles valeurs d' <code>arguments</code> via ces alias. <br><br>  En mode normal, si le premier paramètre de la fonction est <code>a</code> , la définition de la valeur de <code>a</code> dans le code de fonction entraîne également une modification de la valeur dans les <code>arguments[0]</code> .  En mode strict, les <code>arguments</code> contiendront toujours la liste des arguments avec lesquels la fonction a été appelée. <br><br>  Supposons que vous ayez le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  a = <span class="hljs-number"><span class="hljs-number">2</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [a, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br>  La console obtiendra <code>[2,1]</code> .  En effet, l'écriture d'une valeur de 2 dans <code>a</code> n'écrit pas une valeur de 2 dans les <code>arguments[0]</code> . <br><br><h3>  <font color="#3AC1EF">▍Optimisez les performances</font> </h3><br>  En mode strict, la propriété <code>arguments.callee</code> n'est pas prise en charge.  En mode normal, il retourne le nom de la fonction parent de la fonction dont nous <code>callee</code> propriété <code>callee</code> de l'objet <code>arguments</code> . <br><br>  La prise en charge de cette propriété interfère avec les optimisations, telles que les fonctions en ligne, car l'utilisation d' <code>arguments.callee</code> nécessite la disponibilité d'une référence à une fonction non intégrée lors de l'accès à cette propriété.  En mode strict, l'utilisation d' <code>arguments.callee</code> déclenche une exception <code>TypeError</code> . <br><br>  En mode strict, le <code>this</code> - <code>this</code> ne doit pas toujours être un objet.  Dans des circonstances normales, si <code>this</code> fonction est liée, à l'aide de <code>call</code> , <code>apply</code> ou <code>bind</code> , à quelque chose qui n'est pas un objet, à une valeur de type primitif comme <code>undefined</code> , <code>null</code> , <code>number</code> ou <code>boolean</code> , une telle valeur doit être un objet. <br><br>  Si le contexte de <code>this</code> change en quelque chose qui n'est pas un objet, un objet global prend sa place.  Par exemple, <code>window</code> .  Cela signifie que si vous appelez une fonction en définissant son <code>this</code> sur une valeur qui n'est pas un objet, au lieu de cette valeur, une référence à l'objet global y tombera. <br><br>  Prenons un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn() === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-number"><span class="hljs-number">2</span></span>) === <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) === <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.bind(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)() === <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Toutes les commandes <code>console.log</code> afficheront <code>true</code> , car en mode strict, la valeur de <code>this</code> dans la fonction n'est pas automatiquement remplacée par une référence à l'objet global si <code>this</code> définie sur une valeur qui n'est pas un objet. <br><br><h3>  <font color="#3AC1EF">▍ Modifications liées à la sécurité</font> </h3><br>  En mode strict, vous ne pouvez pas rendre publiques les propriétés de la fonction <code>caller</code> et <code>arguments</code> .  Le fait est que l' <code>caller</code> , par exemple, peut donner accès à la fonction qui a appelé la fonction dont nous accédons à la propriété de l' <code>caller</code> . <br><br>  L'objet <code>arguments</code> stocke les arguments passés à la fonction lors de son appel.  Par exemple, si nous avons une fonction <code>fn</code> , cela signifie que via <code>fn.caller</code> vous pouvez accéder à la fonction qui a appelé la fonction, et en utilisant <code>fn.arguments</code> vous pouvez voir les arguments passés à <code>fn</code> lors de son appel. <br><br>  Ces fonctionnalités présentent un risque potentiel pour la sécurité.  Par conséquent, l'accès à ces propriétés est interdit en mode strict. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secretFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  secretFunction.caller;  secretFunction.arguments; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restrictedRunner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secretFunction(); } restrictedRunner();</code> </pre> <br>  Dans l'exemple précédent, nous ne pouvons pas, en mode strict, accéder à <code>secretFunction.caller</code> et <code>secretFunction.arguments</code> .  Le fait est que ces propriétés peuvent être utilisées pour obtenir une pile d'appels de fonction.  Si vous essayez d'exécuter ce code, une exception <code>TypeError</code> sera <code>TypeError</code> . <br><br>  En mode strict, les identifiants pouvant être utilisés dans les futures versions de JavaScript ne peuvent pas être utilisés pour nommer des variables ou des propriétés d'objets.  Par exemple, nous parlons des identifiants suivants: <code>implements</code> , <code>interface</code> , <code>let</code> , <code>package</code> , <code>private</code> , <code>protected</code> , <code>public</code> , <code>static</code> et <code>yield</code> . <br><br>  Dans ES2015 et dans les versions ultérieures de la norme, ces identifiants sont devenus des mots réservés.  Et ils ne peuvent pas être utilisés pour nommer des variables ou des propriétés en mode strict. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Le mode strict est une norme qui existe depuis de nombreuses années.  Il bénéficie d'un support de navigateur extrêmement large.  Les problèmes avec le code en mode strict ne peuvent se produire que dans les navigateurs plus anciens, comme Internet Explorer. <br><br>  Les navigateurs modernes ne devraient pas avoir de difficulté avec le mode JavaScript strict.  Par conséquent, nous pouvons dire que ce mode doit être utilisé pour éviter les erreurs «silencieuses» et pour augmenter la sécurité des applications.  Les erreurs silencieuses sont converties en exceptions qui gênent l'exécution des programmes et en termes d'amélioration de la sécurité, par exemple, des mécanismes en mode strict qui restreignent l' <code>eval</code> et empêchent l'accès à la pile d'appels de fonction peuvent être notés.  De plus, l'utilisation du mode strict facilite l'optimisation du code du moteur JS et oblige le programmeur à gérer soigneusement les mots réservés qui pourraient être utilisés dans les futures versions de JavaScript. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous le mode strict lors de l'écriture de code JS pour vos projets? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477284/">https://habr.com/ru/post/fr477284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477272/index.html">Première introduction à AssemblyScript</a></li>
<li><a href="../fr477274/index.html">Comment se débarrasser du code CSS inutilisé? Partie 1</a></li>
<li><a href="../fr477276/index.html">Comment se débarrasser du code CSS inutilisé? 2e partie</a></li>
<li><a href="../fr477278/index.html">Tests frontaux</a></li>
<li><a href="../fr477282/index.html">Profiling Go code de projet et résolution des problèmes d'allocation de mémoire</a></li>
<li><a href="../fr477286/index.html">Axios ou Fetch: quoi utiliser en 2019?</a></li>
<li><a href="../fr477288/index.html">John Lewis à la conférence Undoing Aging 2018</a></li>
<li><a href="../fr477290/index.html">Événements numériques à Moscou du 25 novembre au 1er décembre</a></li>
<li><a href="../fr477292/index.html">Événements numériques à Saint-Pétersbourg du 25 novembre au 1er décembre</a></li>
<li><a href="../fr477294/index.html">Python pour l'IA: un match fait au paradis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>