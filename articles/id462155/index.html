<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐺 🙌🏽 🌟 Bekerja dengan Pekerja “sesuka Anda,” bukan “sebanyak mungkin” ☸️ 👨🏽‍🔬 🚄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan menggunakan metode eval KOTOR, tidak aman, "kruk", menakutkan, dll. Pingsan hati tidak membaca! 


 Saya harus mengatakan segera bahw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan Pekerja “sesuka Anda,” bukan “sebanyak mungkin”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/462155/"><p> Artikel ini akan menggunakan metode <code>eval</code> KOTOR, tidak aman, "kruk", menakutkan, dll.  Pingsan hati tidak membaca! </p><br><p>  Saya harus mengatakan segera bahwa itu tidak mungkin untuk memecahkan beberapa masalah kegunaan: Anda tidak dapat menggunakan penutupan dalam kode yang akan diteruskan ke pekerja. <br><img src="https://habrastorage.org/webt/t1/dt/x4/t1dtx4olv1-uzfyxmrltaxi9zyq.jpeg" alt="Bekerja dengan Pekerja &quot;sesuka Anda&quot;, tetapi jangan &quot;sebanyak mungkin&quot;"></p><a name="habracut"></a><br><p>  Kita semua menyukai teknologi baru, dan kami menyukainya ketika nyaman untuk menggunakan teknologi ini.  Tetapi dalam kasus pekerja, ini tidak sepenuhnya benar.  Pekerja bekerja dengan file atau tautan file, tetapi ini tidak nyaman.  Saya ingin dapat melakukan tugas apa pun pada pekerja, dan bukan hanya kode yang direncanakan khusus. </p><br><p>  Apa yang dibutuhkan untuk membuat bekerja dengan pekerja lebih nyaman?  Menurut pendapat saya, berikut ini: </p><br><ul><li>  Kemampuan untuk menjalankan kode arbitrer pada pekerja kapan saja </li><li>  Kemampuan untuk meneruskan data yang kompleks ke pekerja (instance kelas, fungsi) </li><li>  Kemampuan untuk mendapatkan Janji dengan respons dari pekerja. </li></ul><br><p>  Pertama, kita membutuhkan protokol komunikasi antara pekerja dan jendela utama.  Secara umum, protokol hanyalah struktur dan tipe data yang dengannya jendela browser dan pekerja akan berkomunikasi.  Tidak ada yang rumit.  Anda dapat menggunakan sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> atau menulis versi Anda sendiri.  Dalam setiap pesan kami akan memiliki ID, dan data khusus untuk jenis pesan tertentu.  Untuk mulai dengan, kami akan memiliki dua jenis pesan untuk pekerja: </p><br><ul><li>  menambahkan perpustakaan / file ke pekerja </li><li>  peluncuran pekerjaan </li></ul><br><h2 id="fayl-vnutri-worker">  File di dalam pekerja </h2><br><p>  Sebelum Anda mulai membuat pekerja, Anda perlu menjelaskan file yang akan berfungsi pada pekerja dan mendukung protokol yang dijelaskan oleh kami.  Saya suka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OOP</a> , jadi itu akan menjadi kelas yang disebut WorkerBody.  Kelas ini harus berlangganan ke acara dari jendela induk. </p><br><pre> <code class="javascript hljs">self.onmessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessage(message.data); };</code> </pre> <br><p>  Sekarang kita dapat mendengarkan acara dari jendela induk.  Kami memiliki dua jenis peristiwa: peristiwa yang jawabannya tersirat, dan yang lainnya.  Kami memproses acara. <br>  Menambahkan pustaka dan file ke pekerja dilakukan menggunakan API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">importScripts</a> . </p><br><p>  Dan hal terburuk: kita akan menggunakan <em>eval</em> untuk menjalankan fungsi arbitrer. </p><br><pre> <code class="javascript hljs">... onMessage(message) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.ADD_LIBS: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addLibs(message.libs); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.WORK: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doWork(message); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } doWork(message) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processor = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(message.job); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parser.parse(message.params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = processor(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &amp;&amp; result.then &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> result.then === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { result.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: data }); }, (error) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { error = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(error); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: error }); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: result }); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }); } } send(data) { data.body = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._serializer.serialize(data.body); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { self.postMessage(data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toSet = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: data.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }; self.postMessage(toSet); } }</code> </pre><br><p>  Metode <code>onMessage</code> bertanggung jawab untuk menerima pesan dan memilih handler, <code>doWork</code> - memulai fungsi yang diteruskan, dan <code>send</code> mengirimkan respons ke jendela induk. </p><br><h2 id="parser-i-serializator">  Parser dan serializer </h2><br><p>  Sekarang kita memiliki konten pekerja, kita perlu belajar bagaimana membuat cerita bersambung dan menguraikan data apa pun untuk meneruskannya kepada pekerja.  Mari kita mulai dengan serializer.  Kami ingin dapat memberikan data apa pun kepada pekerja, termasuk instance kelas, kelas, dan fungsi.  Tetapi dengan fitur asli pekerja, kami hanya dapat mengirimkan data seperti JSON.  Untuk mengatasi larangan ini, kita perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eval</a> .  Segala sesuatu yang tidak dapat menerima JSON, kami akan membungkus konstruksi string yang sesuai dan berjalan di sisi lain.  Untuk menjaga keabadian, data yang diperoleh dikloning dengan cepat, dan yang tidak dapat diserialisasi dengan metode konvensional digantikan oleh objek layanan, dan mereka, pada gilirannya, diganti kembali oleh parser di sisi lain.  Sekilas, sepertinya tugas ini tidak sulit, tetapi ada banyak jebakan.  Keterbatasan terburuk dari pendekatan ini adalah ketidakmampuan untuk menggunakan penutupan, yang membawa gaya penulisan kode yang sedikit berbeda.  Mari kita mulai dengan yang paling sederhana, dengan fungsi.  Pertama, Anda perlu mempelajari cara membedakan fungsi dari konstruktor kelas. </p><br><p>  Mari kita coba bedakan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isFunction(Factory){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Factory.prototype) { <span class="hljs-comment"><span class="hljs-comment">// Arrow function has no prototype return true; } const prototypePropsLength = Object.getOwnPropertyNames(Factory.prototype) .filter(item =&gt; item !== 'constructor') .length; return prototypePropsLength === 0 &amp;&amp; Serializer.getClassParents(Factory).length === 1; } static getClassParents(Factory) { const result = [Factory]; let tmp = Factory; let item = Object.getPrototypeOf(tmp); while (item.prototype) { result.push(item); tmp = item; item = Object.getPrototypeOf(tmp); } return result.reverse(); }</span></span></code> </pre><br><p>  Pertama, kita akan mengetahui apakah fungsi tersebut memiliki prototipe.  Jika tidak, ini jelas sebuah fungsi.  Kemudian kita melihat jumlah properti dalam prototipe, dan jika dalam prototipe hanya konstruktor dan fungsi bukan pewaris kelas lain, kami menganggap ini sebagai fungsi. </p><br><p>  Setelah menemukan fungsi, kita cukup menggantinya dengan objek layanan dengan bidang <code>__type = "serialized-function"</code> dan <code>template</code> , yang sama dengan templat fungsi ini ( <code>func.toString()</code> ). </p><br><p>  Untuk saat ini, lewati kelas dan parsing instance kelas.  Lebih lanjut dalam data kita perlu membedakan objek biasa dari instance kelas. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isInstance(some) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> = some.<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>; if (!<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !Serializer.isNative(<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); } static isNative(data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/function .*?\(\) \{ \[native code\] \}/</span></span>.test(data.toString()); }</code> </pre><br><p>  Kami menganggap objek sebagai hal biasa jika tidak memiliki konstruktor atau konstruktornya adalah fungsi asli.  Setelah mengidentifikasi instance kelas, kami menggantinya dengan objek layanan dengan bidang: </p><br><ul><li>  <code>__type</code> - 'serialized-instance' </li><li>  <code>data</code> - data yang ada di instance </li><li>  <code>index</code> - <code>index</code> kelas dari instance ini dalam daftar layanan kelas. </li></ul><br><p>  Untuk mentransfer data, kita perlu membuat bidang tambahan: di dalamnya kita akan menyimpan daftar semua kelas unik yang kita lewati.  Bagian yang paling sulit adalah ketika kelas terdeteksi, ambil tidak hanya templatnya, tetapi juga templat semua kelas induk dan simpan sebagai kelas yang terpisah - sehingga setiap "induk" dilewatkan tidak lebih dari sekali - dan simpan centang pada instanceof.  Mendefinisikan kelas itu mudah: ini adalah fungsi yang tidak lulus uji Serializer.isFunction kami.  Saat menambahkan kelas, kami memeriksa keberadaan kelas tersebut dalam daftar data berseri dan hanya menambahkan yang unik.  Kode yang mengumpulkan kelas ke dalam templat cukup besar dan terletak di <a href="">sini</a> . </p><br><p>  Dalam parser, pertama-tama kita berkeliling semua kelas yang dilewati untuk kita dan kompilasi mereka jika mereka belum lulus sebelumnya.  Kemudian kami secara rekursif melintasi setiap bidang data dan mengganti objek layanan dengan data yang dikompilasi.  Hal yang paling menarik adalah pada instance kelas.  Kami memiliki kelas dan ada data yang ada dalam instansinya, tetapi kami tidak dapat hanya membuat instantiate, karena panggilan ke konstruktor mungkin memiliki parameter yang tidak kami miliki.  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Object.create yang</a> hampir terlupakan datang ke bantuan kami, yang mengembalikan objek dengan prototipe yang diberikan.  Jadi kami menghindari memanggil konstruktor dan mendapatkan instance kelas, dan kemudian hanya menulis ulang properti menjadi instance. </p><br><h2 id="sozdanie-worker">  Pekerja penciptaan </h2><br><p>  Agar pekerja dapat bekerja dengan sukses, kita perlu memiliki parser dan serializer di dalam pekerja dan di luar, jadi kami mengambil serializer dan mengubah serializer, parser dan tubuh pekerja menjadi templat.  Kami membuat gumpalan dari template dan membuat tautan unduhan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">URL.createObjectURL</a> (metode ini mungkin tidak berfungsi dengan beberapa "Kebijakan Keamanan Konten").  Metode ini juga cocok untuk menjalankan kode arbitrer dari string. </p><br><pre> <code class="javascript hljs">_createWorker(customWorker) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = <span class="hljs-string"><span class="hljs-string">`var MyWorker = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._createTemplate(customWorker)}</span></span></span><span class="hljs-string">;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([template], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(URL.createObjectURL(blob)); } _createTemplate(WorkerBody) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Name = Serializer.getFnName(WorkerBody); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Name) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unnamed Worker Body class! Please add name to Worker Body class!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'(function () {'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Serializer, <span class="hljs-string"><span class="hljs-string">'Serializer'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Parser, <span class="hljs-string"><span class="hljs-string">'Parser'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(WorkerBody, <span class="hljs-string"><span class="hljs-string">'WorkerBody'</span></span>), <span class="hljs-string"><span class="hljs-string">`return new WorkerBody(Serializer, Parser)})();`</span></span> ].join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); }</code> </pre><br><h2 id="rezultat">  Hasil </h2><br><p>  Dengan demikian, kami telah memperoleh pustaka yang mudah digunakan yang dapat menjalankan kode arbitrer pada pekerja.  Ini mendukung kelas dari TypeScript.  Sebagai contoh: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = workerWrapper.create(); wrapper.process(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This code in worker. Cannot use closure! // do some hard work return 100; // or return Promise.resolve(100) }, params).then((result) =&gt; { // result = 100; }); wrapper.terminate() // terminate for kill worker process</span></span></code> </pre> <br><h2 id="dalneyshie-plany">  Rencana selanjutnya </h2><br><p>  Perpustakaan ini, sayangnya, masih jauh dari ideal.  Penting untuk menambahkan dukungan untuk setter dan getter pada kelas, objek, prototipe, properti statis.  Kami juga ingin menambahkan caching, membuat skrip alternatif berjalan tanpa <code>eval</code> melalui URL.createObjectURL dan menambahkan file dengan konten pekerja ke majelis (jika kreasi tidak tersedia dengan cepat).  Datanglah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462155/">https://habr.com/ru/post/id462155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462145/index.html">Mengapa perlu beberapa hari untuk berhenti berlangganan?</a></li>
<li><a href="../id462147/index.html">Bekerja dengan navigasi saat refactoring warisan proyek di React Native</a></li>
<li><a href="../id462149/index.html">Mode pembatasan akses untuk aksesori di perangkat iOS dan cara memintasnya</a></li>
<li><a href="../id462151/index.html">5 distribusi Kubernet teratas</a></li>
<li><a href="../id462153/index.html">Unity Interactive Map Shaders</a></li>
<li><a href="../id462159/index.html">Membangun sistem pengenalan wajah berdasarkan Golang dan OpenCV</a></li>
<li><a href="../id462161/index.html">Pengalaman menginstal Apache Airflow di Windows 10</a></li>
<li><a href="../id462163/index.html">Teknologi itu akan populer pada 2020</a></li>
<li><a href="../id462165/index.html">Bagaimana 25 orang tertipu untuk bekerja di perusahaan game yang tidak ada</a></li>
<li><a href="../id462167/index.html">Lewati batas pencarian LinkedIn dengan bermain dengan API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>