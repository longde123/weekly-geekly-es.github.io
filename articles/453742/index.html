<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÆ ü•å ‚ÜîÔ∏è Plugin Memcached: NoSQL en MySQL ‚ôæ üßëüèæ‚Äçü§ù‚Äçüßëüèæ ü§µüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Mi nombre es Maxim Matyukhin, soy programador de PHP en Badoo . En nuestro trabajo, utilizamos activamente MySQL. Pero a veces nos falta su rendi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plugin Memcached: NoSQL en MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/453742/"><img src="https://habrastorage.org/webt/1v/q0/h5/1vq0h5tev1qw1ivnheyxg7jfiqm.jpeg"><br><br>  Hola  Mi nombre es Maxim Matyukhin, soy programador de PHP en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo</a> .  En nuestro trabajo, utilizamos activamente MySQL.  Pero a veces nos falta su rendimiento, por lo que constantemente buscamos formas de acelerar su trabajo. <br><br>  En 2010, Yoshinori Matsunobu introdujo el complemento NoSQL MySQL llamado HandlerSocket.  Se afirm√≥ que este complemento le permite realizar m√°s de 750,000 solicitudes por segundo.  Nos volvimos curiosos y casi de inmediato comenzamos a usar esta soluci√≥n.  Nos gust√≥ tanto el resultado que comenzamos a hacer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaciones</a> y escribir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> promocionando HandlerSocket. <br><br>  Aparentemente, fuimos uno de los pocos usuarios de este complemento, ya que MySQL 5.7 dej√≥ de funcionar.  Pero en esta versi√≥n apareci√≥ otro complemento de Oracle: el complemento IncaDB memcached, que promet√≠a una funcionalidad similar. <br><br>  A pesar de que el complemento memcached apareci√≥ de nuevo en MySQL 5.6 en 2013, no hay tantos art√≠culos al respecto y, en su mayor parte, repiten la documentaci√≥n: se crea una etiqueta simple y se realizan solicitudes a trav√©s del cliente memcached. <br><br>  Tenemos una amplia experiencia con Memcached y estamos acostumbrados a la facilidad de interactuar con √©l.  Desde el complemento memcached de InnoDB esper√°bamos la misma simplicidad.  Pero, de hecho, result√≥ que si los patrones para usar el complemento son al menos ligeramente diferentes de los descritos en la documentaci√≥n y los art√≠culos, aparecer√°n muchos matices y limitaciones, que definitivamente vale la pena considerar si va a usar el complemento. <br><a name="habracut"></a><br><h1>  MySQL HandlerSocket </h1><br>  En este art√≠culo, compararemos de una forma u otra el nuevo complemento memcached con el antiguo HandlerSocket.  Por lo tanto, recuerdo que fue lo √∫ltimo. <br><br>  Despu√©s de instalar el complemento HandlerSocket, MySQL comenz√≥ a escuchar dos puertos adicionales: <br><br><ol><li>  El primer puerto recibi√≥ solicitudes de clientes para leer datos. <br></li><li>  El segundo puerto recibi√≥ solicitudes del cliente para la grabaci√≥n de datos. <br></li></ol><br>  El cliente ten√≠a que establecer una conexi√≥n TCP regular en uno de estos puertos (no se admit√≠a autenticaci√≥n), y despu√©s de eso era necesario enviar el comando "abrir √≠ndice" (un comando especial con el que el cliente informaba a qu√© tabla de qu√© √≠ndice a qu√© campos √≠bamos a leer (o escribir)). <br><br>  Si el comando "abrir √≠ndice" funcion√≥ correctamente, puede enviar comandos GET o INSERT / UPDATE / DELETE dependiendo del puerto al que se estableci√≥ la conexi√≥n. <br><br>  HandlerSocket permiti√≥ realizar no solo GET en la clave primaria, sino tambi√©n muestras simples de un √≠ndice no exclusivo, muestras de rango, multigets compatibles y LIMIT.  Al mismo tiempo, fue posible trabajar con la tabla tanto desde SQL ordinario como a trav√©s del complemento.  Esto, por ejemplo, le permiti√≥ hacer algunos cambios en las transacciones a trav√©s de SQL y luego leer estos datos a trav√©s de HandlerSocket. <br><br>  Es importante que HandlerSocket manejara todas las conexiones con un grupo limitado de subprocesos a trav√©s de epoll, por lo que fue f√°cil admitir decenas de miles de conexiones, mientras que en MySQL se cre√≥ un subproceso para cada conexi√≥n y su n√∫mero era muy limitado. <br><br>  Al mismo tiempo, sigue siendo un servidor MySQL ordinario, una tecnolog√≠a que nos es familiar.  Sabemos c√≥mo replicarlo y monitorearlo.  Monitorear HandlerSocket es dif√≠cil porque no proporciona ninguna m√©trica espec√≠fica;  sin embargo, algunas de las m√©tricas est√°ndar de MySQL e InnoDB son √∫tiles. <br><br>  Hubo, por supuesto, inconvenientes, en particular, este complemento no era compatible con el tipo de marca de tiempo.  Bueno, el protocolo HandlerSocket es m√°s dif√≠cil de leer y, por lo tanto, m√°s dif√≠cil de depurar. <br><br>  Lea m√°s sobre HandlerSocket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Tambi√©n puedes ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una de nuestras presentaciones</a> . <br><br><h1>  Complemento memcached de InnoDB </h1><br>  ¬øQu√© nos ofrece el nuevo plugin memcached? <br><br>  Como su nombre lo indica, su idea es usar el cliente memcached para trabajar con MySQL y recibir y guardar datos a trav√©s de comandos memcached. <br><br>  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leer</a> sobre las principales ventajas del complemento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Estamos m√°s interesados ‚Äã‚Äãen lo siguiente: <br><br><ol><li>  Bajo consumo de CPU. <br></li><li>  Los datos se almacenan en InnoDB, lo que brinda ciertas garant√≠as. <br></li><li>  Puede trabajar con datos tanto a trav√©s de Memcached como a trav√©s de SQL;  Se pueden replicar utilizando las herramientas integradas de MySQL. <br></li></ol><br>  Puede agregar m√°s ventajas a esta lista como: <br><br><ol><li>  Conexi√≥n r√°pida y econ√≥mica.  Un subproceso procesa una conexi√≥n MySQL normal, y el n√∫mero de subprocesos es limitado, y en el complemento memcached, un subproceso procesa todas las conexiones en el bucle de eventos. <br></li><li>  La capacidad de solicitar varias claves con una solicitud GET. <br></li><li>  Si se compara con MySQL HandlerSocket, entonces en el plugin memcached no necesita usar el comando "Abrir tabla" y todas las operaciones de lectura y escritura ocurren en el mismo puerto. <br></li></ol><br><br>  Se pueden encontrar m√°s detalles sobre el complemento en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> oficial.  Para nosotros, las p√°ginas m√°s √∫tiles fueron: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura memcached de InnoDB</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">InnoDB Memcached Plugin Internals</a> . <br></li></ol><br>  Despu√©s de instalar el complemento, MySQL comienza a aceptar conexiones en el puerto 11211 (puerto memcached est√°ndar).  Tambi√©n aparece una base de datos especial (esquema) innodb_memcache, en la que configurar√° el acceso a sus tablas. <br><br><h1>  Ejemplo simple </h1><br>  Supongamos que ya tiene una tabla con la que desea trabajar a trav√©s del protocolo memcached: <br><br><pre><code class="plaintext hljs">CREATE TABLE `auth` (  `email` varchar(96) NOT NULL,  `password` varchar(64) NOT NULL,  `type` varchar(32) NOT NULL DEFAULT '',  PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  y desea recibir y modificar datos en la clave primaria. <br><br>  Primero debe describir la correspondencia entre la clave memcached y la tabla SQL en la tabla innodb_memcache.containers.  Esta tabla se parece a esto (elimin√© la descripci√≥n de codificaci√≥n para que sea m√°s f√°cil de leer): <br><br><pre> <code class="plaintext hljs">CREATE TABLE `containers` ( `name` varchar(50) NOT NULL, `db_schema` varchar(250) NOT NULL, `db_table` varchar(250) NOT NULL, `key_columns` varchar(250) NOT NULL, `value_columns` varchar(250) DEFAULT NULL, `flags` varchar(250) NOT NULL DEFAULT '0', `cas_column` varchar(250) DEFAULT NULL, `expire_time_column` varchar(250) DEFAULT NULL, `unique_idx_name_on_key` varchar(250) NOT NULL, PRIMARY KEY (`name`) ) ENGINE=InnoDB DEFAULT</code> </pre> <br>  Los campos m√°s importantes: <br><br><ul><li>  nombre: prefijo de su clave Memcached; <br></li><li>  db_schema - nombre de la base (circuito); <br></li><li>  db_table es tu tabla; <br></li><li>  key_columns: el nombre del campo en la tabla en el que buscaremos (generalmente esta es su clave principal); <br></li><li>  value_columns: una lista de campos de la tabla que estar√° disponible para el complemento memcached; <br></li><li>  unique_idx_name_on_key es el √≠ndice a buscar (aunque ya ha especificado key_columns, pueden estar en diferentes √≠ndices y debe especificar el √≠ndice expl√≠citamente). <br></li></ul><br>  Los campos restantes no son muy importantes para empezar. <br><br>  Agregue una descripci√≥n de nuestra tabla a innodb_memcache.containers: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  En este ejemplo, name = 'auth' es el prefijo de nuestra clave memcached.  En la documentaci√≥n a menudo se llama table_id, y m√°s adelante en el art√≠culo usar√© este t√©rmino. <br><br>  Ahora TELNET se conecta al plugin memcached e intenta guardar y obtener los datos: <br><br><pre> <code class="plaintext hljs">[21:26:22] maxm@localhost: ~&gt; telnet memchached-mysql.dev 11211 Trying 127.0.0.1... Connected to memchached-mysql.dev. Escape character is '^]'. get @@auth.max@example.com END set @@auth.max@example.com 0 0 10 1234567|89 STORED get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  Primero enviamos una solicitud GET, no nos devolvi√≥ nada.  Luego guardamos los datos con una solicitud SET, despu√©s de lo cual los recuperamos con un GET. <br><br>  GET devolvi√≥ la siguiente l√≠nea: 1234567 | 89.  Estos son los valores de los campos "contrase√±a" y "tipo", separados por el s√≠mbolo "|".  Los campos se devuelven en el orden en que se describieron en innodb_memcache.containers.value_columns. <br><br>  Quiz√°s ahora se est√© preguntando: "¬øQu√© suceder√° si se encuentra el s√≠mbolo" | "en la" contrase√±a "?"  Hablar√© de esto a continuaci√≥n. <br><br>  A trav√©s de SQL, estos datos tambi√©n est√°n disponibles: <br><br><pre> <code class="plaintext hljs">MySQL [(none)]&gt; select * from auth where email='max@example.com'; +-----------------+----------+------+ | email      | password | type | +-----------------+----------+------+ | max@example.com | 1234567  | 89 | +-----------------+----------+------+ 1 row in set (0.00 sec)</code> </pre> <br><h2>  Table_id predeterminado </h2><br>  Tambi√©n existe tal modo de operaci√≥n: <br><br><pre> <code class="plaintext hljs">get @@auth VALUE @@auth 0 21 test/auth END get max@example.com VALUE max@example.com 0 10 1234567|99 END set ivan@example.com 0 0 10 qwerty|xxx STORED get ivan@example.com VALUE ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  En este ejemplo, con get @@ auth, hacemos que table_id auth sea el prefijo predeterminado para esta conexi√≥n.  Despu√©s de eso, todas las consultas posteriores se pueden hacer sin especificar table_id. <br><br>  Hasta ahora, todo es simple y l√≥gico.  Pero si comienzas a entender, entonces hay muchos matices.  Te dir√© lo que encontramos. <br><br><h1>  Matices </h1><br><h2>  Almacenamiento en cach√© de la tabla innodb_memcache.containers </h2><br>  El complemento memcached lee la tabla innodb_memcache.containers una vez al inicio.  Adem√°s, si un table_id desconocido llega a trav√©s del protocolo Memcached, el complemento lo busca en la tabla.  Por lo tanto, puede agregar f√°cilmente nuevas claves (table_id), pero si desea cambiar la configuraci√≥n de un table_id existente, debe reiniciar el complemento memcached: <br><br><pre> <code class="plaintext hljs">mysql&gt; UNINSTALL PLUGIN daemon_memcached; mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code> </pre> <br>  Entre estas dos solicitudes, la interfaz Memcached no funcionar√°.  Debido a esto, a menudo es m√°s f√°cil crear un nuevo table_id que cambiar el existente y reiniciar el complemento. <br><br>  Fue una sorpresa para nosotros que se describa un matiz tan importante de la operaci√≥n del complemento en la p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Adaptaci√≥n de una aplicaci√≥n memcached para la</a> p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">InnoDB Plugin memcached</a> , que no es un lugar muy l√≥gico para dicha informaci√≥n. <br><br><h2>  Banderas, cas_column, expire_time_column </h2><br>  Estos campos son necesarios para simular algunas caracter√≠sticas de Memcached.  La documentaci√≥n para ellos es inconsistente.  La mayor√≠a de los ejemplos en √©l ilustran el trabajo con tablas en las que se encuentran estos campos.  Puede haber una preocupaci√≥n de que necesitar√° agregarlos a sus tablas (y estos son al menos tres campos INT).  Pero no  Si no tiene dichos campos en las tablas y no va a utilizar la funcionalidad de Memcached como CAS, caducidad o marcas, entonces no necesita agregar estos campos a las tablas. <br><br>  Al configurar la tabla en innodb_memcache.containers, debe ingresar '0' en estos campos, hacer exactamente la l√≠nea con cero: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Es molesto que cas_column y expire_time_column tengan un valor predeterminado de NULL, y si ejecuta INSERT INTO innodb_memcache.containers sin especificar un valor de '0' para estos campos, NULL se almacenar√° en ellos y este prefijo memcache simplemente no funcionar√°. <br><br><h2>  Tipos de datos </h2><br>  De la documentaci√≥n no est√° muy claro qu√© tipos de datos se pueden usar cuando se trabaja con el complemento.  En varios lugares se dice que el complemento solo puede funcionar con campos de texto (CHAR, VARCHAR, BLOB).  Aqu√≠: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adaptaci√≥n de un esquema MySQL existente para el complemento memcached de InnoDB</a> ofrece almacenar n√∫meros en campos de cadena, y si luego necesita trabajar con estos campos de n√∫meros desde SQL, cree una VISTA en la que los campos VARCHAR con n√∫meros se convertir√°n en campos INTEGER : <br><br><pre> <code class="plaintext hljs">CREATE VIEW numbers AS SELECT c1 KEY, CAST(c2 AS UNSIGNED INTEGER) val FROM demo_test WHERE c2 BETWEEN '0' and '9999999999';</code> </pre> <br>  Sin embargo, en algunos lugares de la documentaci√≥n todav√≠a est√° escrito que puede trabajar con n√∫meros.  Hasta ahora, solo tenemos experiencia de producci√≥n real con campos de texto, pero los resultados experimentales muestran que el complemento tambi√©n funciona con n√∫meros: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `numbers` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `counter` int(10) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=InnoDB INSERT INTO innodb_memcache.containers SET name='numbers', db_schema='test', db_table='numbers', key_columns='id', value_columns='counter', flags='0', cas_column='0',expire_time_column='0',unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Despu√©s de eso, a trav√©s del protocolo Memcached: <br><br><pre> <code class="plaintext hljs">get @@numbers.1 END set @@numbers.1 0 0 2 12 STORED get @@numbers.1 VALUE @@numbers.1 0 2 12 END</code> </pre> <br>  Vemos que el complemento memcached puede devolver cualquier tipo de datos.  Pero los devuelve en la forma en que se encuentran en InnoDB, por lo que, por ejemplo, en el caso de marca de tiempo / fecha / hora / float / decimal / JSON, se devuelve una cadena binaria.  Pero los enteros se devuelven cuando los vemos a trav√©s de SQL. <br><br><h2>  Multiget </h2><br>  El protocolo memcached le permite solicitar varias claves con una sola solicitud: <br><br><pre> <code class="plaintext hljs">get @@numbers.2 @@numbers.1 VALUE @@numbers.2 0 2 12 VALUE @@numbers.1 0 2 13 END</code> </pre> <br>  El hecho de que el multiget funciona ya es bueno.  Pero funciona dentro del marco de un table_id: <br><br><pre> <code class="plaintext hljs">get @@auth.ivan@example.com @@numbers.2 VALUE @@auth.ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  Este punto se describe en la documentaci√≥n aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://dev.mysql.com/doc/refman/8.0/en/innodb-memcached-multiple-get-range-query.html</a> .  Resulta que en multiget puede especificar table_id solo para la primera clave, si todas las dem√°s claves se toman del valor predeterminado table_id (ejemplo de la documentaci√≥n): <br><br><pre> <code class="plaintext hljs">get @@aaa.AA BB VALUE @@aaa.AA 8 12 HELLO, HELLO VALUE BB 10 16 GOODBYE, GOODBYE END</code> </pre> <br>  En este ejemplo, la segunda clave se toma del valor predeterminado table_id.  Podr√≠amos especificar muchas m√°s claves del valor predeterminado table_id, y para la primera clave especificamos un table_id separado, y esto es posible solo en el caso de la primera clave. <br><br>  Podemos decir que multiget funciona dentro del marco de una tabla, porque no tiene ganas de confiar en esa l√≥gica en el c√≥digo de producci√≥n: no es obvio, es f√°cil olvidarse de eso, cometer un error. <br><br>  Si se compara con HandlerSocket, entonces, tambi√©n, multiget funcion√≥ en la misma tabla.  Pero esta restricci√≥n parec√≠a natural: el cliente abre el √≠ndice en la tabla y le solicita uno o m√°s valores.  Pero cuando se trabaja con el plugin multiget memcached en varias teclas con diferentes prefijos, esta es una pr√°ctica normal.  Y espera lo mismo del complemento de MySQL memcached.  Pero no :( <br><br><h2>  INCR, DEL </h2><br>  Ya he dado ejemplos de solicitudes GET / SET.  Las consultas INCR y DEL tienen una funci√≥n.  Se basa en el hecho de que solo funcionan cuando se usa el valor predeterminado table_id: <br><br><pre> <code class="plaintext hljs">DELETE @@numbers.1 ERROR get @@numbers VALUE @@numbers 0 24 test/numbers END delete 1 DELETED</code> </pre> <br><h2>  Limitaciones de protocolo de Memcached </h2><br>  Memcached tiene un protocolo de texto, que impone algunas limitaciones.  Por ejemplo, las teclas memcached no deben contener caracteres de espacio en blanco (espacio, avance de l√≠nea).  Si vuelve a mirar la descripci√≥n de la tabla de nuestro ejemplo: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `auth` ( `email` varchar(96) NOT NULL, `password` varchar(64) NOT NULL, `type` varchar(32) NOT NULL DEFAULT '', PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  Esto significa que en el campo "correo electr√≥nico" no deber√≠a haber tales caracteres. <br><br>  Adem√°s, las claves de memoria cach√© deben tener menos de 250 bytes (bytes, no caracteres).  Si env√≠a m√°s, recibir√° un error: <br><br><pre> <code class="plaintext hljs">"CLIENT_ERROR bad command line format"</code> </pre> <br>  Adem√°s, se debe tener en cuenta el hecho de que el complemento memcached agrega su propia sintaxis al protocolo memcached.  Por ejemplo, usa el car√°cter "|"  como un separador de campo en la respuesta.  Debe asegurarse de que este s√≠mbolo no se use en su tabla.  El separador se puede configurar, pero la configuraci√≥n se aplicar√° a todas las tablas en todo el servidor MySQL. <br><br><h2>  Delimitador de campo value_columns </h2><br>  Si necesita devolver varias columnas a trav√©s del protocolo memcached, como en nuestro primer ejemplo: <br><br><pre> <code class="plaintext hljs">get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  entonces los valores de columna est√°n separados por el separador est√°ndar "|".  Surge la pregunta: "¬øQu√© pasar√° si, por ejemplo, el car√°cter" | "est√° en el primer campo de la l√≠nea?"  El complemento memcached en este caso devolver√° la cadena como est√°, algo como esto: 1234 | 567 | 89.  En el caso general, es imposible entender d√≥nde hay un campo. <br><br>  Por lo tanto, es importante elegir el separador correcto de inmediato.  Y dado que se usar√° para todas las claves de todas las tablas, debe ser un car√°cter universal que no se encontrar√° en ning√∫n campo con el que trabaje a trav√©s del protocolo memcached. <br><br><h1>  Resumen </h1><br>  Esto no quiere decir que el complemento memcached sea malo.  Pero parece que fue escrito para un esquema de trabajo espec√≠fico: un servidor MySQL con una tabla a la que se puede acceder utilizando el protocolo memcached, y este table_id se establece de manera predeterminada.  Los clientes establecen una conexi√≥n persistente con el complemento Memcached y realizan solicitudes al valor predeterminado table_id.  Probablemente, en tal esquema, todo funcionar√° sin problemas.  Si te alejas de √©l, te encuentras con varios inconvenientes. <br><br>  Es posible que haya esperado ver algunos informes de rendimiento del complemento.  Pero a√∫n no hemos decidido usarlo en lugares muy cargados.  Lo usamos solo en algunos sistemas no muy cargados y all√≠ funciona a la misma velocidad que el HandlerSocket, pero no hicimos puntos de referencia honestos.  Sin embargo, el complemento proporciona una interfaz con la que el programador puede cometer f√°cilmente un error: debe tener en cuenta muchos matices.  Por lo tanto, todav√≠a no estamos listos para usar este complemento en forma masiva. <br><br>  Hicimos algunas solicitudes de funciones en el rastreador de errores de MySQL: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bugs.mysql.com/bug.php?id=95091</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bugs.mysql.com/bug.php?id=95092</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bugs.mysql.com/bug.php?id=95093</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bugs.mysql.com/bug.php?id=95094</a> <br><br>  Esperemos que el equipo de desarrollo del complemento memcached mejore su producto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453742/">https://habr.com/ru/post/453742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453722/index.html">Sobre la investigaci√≥n de procesos no estacionarios</a></li>
<li><a href="../453728/index.html">Batalla de las hiperestrellas</a></li>
<li><a href="../453730/index.html">Odontolog√≠a moderna: implantaci√≥n dental simult√°nea y extensi√≥n de la mand√≠bula a trav√©s de los ojos del director t√©cnico</a></li>
<li><a href="../453732/index.html">Soy de Moreinis. ¬øVistas oblicuas o respeto?</a></li>
<li><a href="../453734/index.html">Introduciendo Helm 3</a></li>
<li><a href="../453744/index.html">Estudiamos el principio de la pseudoclase: no () usando el ejemplo de la tarea "Destacar la fila activa de una tabla en CSS puro"</a></li>
<li><a href="../453748/index.html">Creaci√≥n de prototipos de un juego m√≥vil, d√≥nde comenzar y c√≥mo hacerlo. Parte 3 (final)</a></li>
<li><a href="../453750/index.html">Sobre el reciente ciberataque de Baltimore</a></li>
<li><a href="../453756/index.html">Problemas de la metodolog√≠a actual para determinar las amenazas actuales del FSTEC</a></li>
<li><a href="../453760/index.html">Circuito campo de entrenamiento para tanques y procesadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>