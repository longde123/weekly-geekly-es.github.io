<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò† ü§úüèº üåª Kami memecahkan masalah sejuta tab terbuka atau "membantu perangkat keras bertahan" ü§¥üèª üè¢ üë©üèº‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami akan mencoba mencari cara untuk mengurangi beban pada perangkat keras server, sambil memastikan kinerja aplikasi Web maksimum. 


 Dalam pengemba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memecahkan masalah sejuta tab terbuka atau "membantu perangkat keras bertahan"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415401/"><p><img src="https://habrastorage.org/webt/pn/_3/7n/pn_37n_daf8ssnbb8s3qbcrnjv0.jpeg"></p><br><p>  Kami akan mencoba mencari cara untuk mengurangi beban pada perangkat keras server, sambil memastikan kinerja aplikasi Web maksimum. </p><br><p>  Dalam pengembangan proyek-proyek besar, beban tinggi dengan online besar, Anda seringkali harus memikirkan cara mengurangi beban di server, terutama ketika bekerja di webSockets dan antarmuka yang berubah secara dinamis.  <em>100500</em> pengguna datang kepada kami dan kami memiliki <em>100500</em> koneksi soket terbuka.  Dan jika masing-masing membuka 2 tab - ini adalah * 201.000 koneksi.  <strong>Dan jika lima?</strong> </p><a name="habracut"></a><br><p>  Pertimbangkan contoh sepele.  Kami punya, misalnya, <del>  Twitch.tv </del> , yang untuk setiap pengguna menimbulkan koneksi WS.  Proyek semacam itu sangat besar online, jadi setiap detail penting.  Kami tidak dapat membuka koneksi-WS baru pada setiap tab, mendukung yang lama, karena kelenjar perlu diukur untuk ini. </p><br><p>  Idenya lahir - bagaimana jika koneksi WS dibesarkan hanya dalam satu tab dan selalu tetap terbuka, dan di yang baru, jangan menginisialisasi koneksi, tetapi hanya mendengarkan dari tab tetangga?  Ini tentang implementasi ide ini yang ingin saya sampaikan. </p><br><h4 id="logicheskoe-povedenie-vkladok-v-brauzere">  Perilaku Logika Peramban </h4><br><ol><li>  Buka tab pertama, tandai sebagai Utama </li><li>  Jalankan tes - jika tab is_primary, lalu naikkan koneksi-WS </li><li>  Kami sedang bekerja ... </li><li>  Buka tab kedua (duplikat jendela, masukkan alamat secara manual, buka di tab baru, itu tidak masalah) </li><li>  Dari tab baru, lihat apakah ada suatu tempat tab Utama.  Jika ya, maka tandai Secondary saat ini dan tunggu apa yang akan terjadi. </li><li>  Buka 10 tab lainnya.  Dan semua orang menunggu. </li><li>  Pada titik tertentu, tab Utama ditutup.  Sebelum kematiannya, dia berteriak kepada semua orang tentang kematiannya.  Semuanya kaget. </li><li>  Dan kemudian semua tab mencoba untuk secara instan menjadi Pratama.  Reaksi setiap orang berbeda (acak) dan siapa pun yang punya waktu, itu, dan sandal.  Segera setelah salah satu tab berhasil menjadi is_primary, dia berteriak kepada semua orang bahwa tempat itu diambil.  Setelah itu, koneksi WS masuk kembali.  Kami sedang bekerja.  Sisanya sedang menunggu. </li><li>  Dll  Pemulung sedang menunggu kematian tab Pratama untuk jatuh ke tempatnya. </li></ol><br><h4 id="tehnicheskaya-storona-voprosa">  Sisi teknis dari masalah ini </h4><br><p>  Untuk berkomunikasi di antara tab, kami akan menggunakan apa yang menghubungkan mereka dalam domain yang sama - localStorage.  Panggilan untuk itu tidak mahal untuk sumber daya besi pengguna dan respons dari mereka sangat cepat.  Sekitar itu, seluruh ide sedang dibangun. </p><br><p>  Ada <a href="">perpustakaan</a> yang sudah lama tidak didukung oleh pembuatnya, tetapi Anda bisa menjadikannya sebagai garpu lokal, seperti yang saya lakukan.  Dari sana kita mendapatkan file: </p><br><p><code>/intercom.js</code> </p> <br><p>  Inti dari pustaka adalah memungkinkan <em>emit / on events</em> untuk berkomunikasi antar tab menggunakan localStorage untuk ini. </p><br><p>  Setelah itu, kita memerlukan alat yang memungkinkan kita untuk <em>mengunci</em> ( <em>memblokir perubahan</em> ) kunci tertentu di Penyimpanan lokal, tanpa mengizinkan siapa pun untuk mengubahnya tanpa hak yang diperlukan.  Untuk ini, perpustakaan kecil yang <strong>disebut</strong> " <strong>locableStorage</strong> " ditulis, esensi yang terkandung dalam fungsi <em>trySyncLock ()</em> </p><br><div class="spoiler">  <b class="spoiler_title">Kode perpustakaan LocableStorage</b> <div class="spoiler_text"><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">now</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000000000</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myId = now() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + someNumber(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lskey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = localStorage[lskey]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> splitted = value.split(<span class="hljs-regexp"><span class="hljs-regexp">/\|/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(splitted[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt; now()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> splitted[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_mutexTransaction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, callback, synchronous</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xKey = key + <span class="hljs-string"><span class="hljs-string">"__MUTEX_x"</span></span>, yKey = key + <span class="hljs-string"><span class="hljs-string">"__MUTEX_y"</span></span>, getY = getter(yKey); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">criticalSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { callback(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { localStorage.removeItem(yKey); } } localStorage[xKey] = myId; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getY()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!synchronous) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ _mutexTransaction(key, callback); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } localStorage[yKey] = myId + <span class="hljs-string"><span class="hljs-string">"|"</span></span> + (now() + <span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localStorage[xKey] !== myId) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!synchronous) { setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getY() !== myId) { setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ _mutexTransaction(key, callback); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { criticalSection(); } }, <span class="hljs-number"><span class="hljs-number">50</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { criticalSection(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockImpl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, callback, maxDuration, synchronous</span></span></span><span class="hljs-function">) </span></span>{ maxDuration = maxDuration || <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutexKey = key + <span class="hljs-string"><span class="hljs-string">"__MUTEX"</span></span>, getMutex = getter(mutexKey), mutexValue = myId + <span class="hljs-string"><span class="hljs-string">":"</span></span> + someNumber() + <span class="hljs-string"><span class="hljs-string">"|"</span></span> + (now() + maxDuration); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ lockImpl(key, callback, maxDuration); }, <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getMutex()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!synchronous) restart(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aquiredSynchronously = _mutexTransaction(key, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getMutex()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!synchronous) restart(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } localStorage[mutexKey] = mutexValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!synchronous) setTimeout(mutexAquired, <span class="hljs-number"><span class="hljs-number">0</span></span>) }, synchronous); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (synchronous &amp;&amp; aquiredSynchronously) { mutexAquired(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutexAquired</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { callback(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _mutexTransaction(key, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localStorage[mutexKey] !== mutexValue) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> key + <span class="hljs-string"><span class="hljs-string">" was locked by a different process while I held the lock"</span></span> localStorage.removeItem(mutexKey); }); } } } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.LockableStorage = { <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, callback, maxDuration</span></span></span><span class="hljs-function">) </span></span>{ lockImpl(key, callback, maxDuration, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">trySyncLock</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, callback, maxDuration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lockImpl(key, callback, maxDuration, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }; })();</code> </pre> </div></div><br><p>  Sekarang perlu untuk menggabungkan semuanya menjadi satu mekanisme tunggal, yang akan memungkinkan kita untuk mengimplementasikan rencana kita. </p><br><div class="spoiler">  <b class="spoiler_title">Kode implementasi</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Intercom.supported) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intercom = Intercom.getInstance(), <span class="hljs-comment"><span class="hljs-comment">//Intercom singleton period_heart_bit = 1, //LocalStorage update frequency wsId = someNumber() + Date.now(), //Current tab ID primaryStatus = false, //Primary window tab status refreshIntervalId, count = 0, //Counter. Delete this intFast; //Timer window.webSocketInit = webSocketInit; window.semiCloseTab = semiCloseTab; intercom.on('incoming', data =&gt; { document.getElementById('counter').innerHTML = data.data; document.getElementById('socketStatus').innerHTML = primaryStatus.toString(); return false; }); /** * Random number * @returns {number} - number */ function someNumber() { return Math.random() * 1000000000 | 0; } /** * Try do something */ function webSocketInit() { // Check for crash or loss network let forceOpen = false, wsLU = localStorage.wsLU; if (wsLU) { let diff = Date.now() - parseInt(wsLU); forceOpen = diff &gt; period_heart_bit * 5 * 1000; } //Double checked locking if (!localStorage.wsOpen || localStorage.wsOpen !== "true" || forceOpen) { LockableStorage.trySyncLock("wsOpen", function () { if (!localStorage.wsOpen || localStorage.wsOpen !== "true" || forceOpen) { localStorage.wsOpen = true; localStorage.wsId = wsId; localStorage.wsLU = Date.now(); //TODO this app logic that must be SingleTab ---------------------------- primaryStatus = true; intFast = setInterval(() =&gt; { intercom.emit('incoming', {data: count}); count++ }, 1000); //TODO ------------------------------------------------------------------ startHeartBitInterval(); } }); } } /** * Show singleTab app status */ setInterval(() =&gt; { document.getElementById('wsopen').innerHTML = localStorage.wsOpen; }, 200); /** * Update localStorage info */ function startHeartBitInterval() { refreshIntervalId = setInterval(function () { localStorage.wsLU = Date.now(); }, period_heart_bit * 1000); } /** * Close tab action */ intercom.on('TAB_CLOSED', function (data) { if (localStorage.wsId !== wsId) { count = data.count; setTimeout(() =&gt; { webSocketInit() }, parseInt(getRandomArbitary(1, 1000), 10)); //Init after random time. Important! } }); function getRandomArbitary(min, max) { return Math.random() * (max - min) + min; } /** * Action after some tab closed */ window.onbeforeunload = function () { if (primaryStatus) { localStorage.setItem('wsOpen', false); clearInterval(refreshIntervalId); intercom.emit('TAB_CLOSED', {count: count}); } }; /** * Emulate close window */ function semiCloseTab() { if (primaryStatus) { localStorage.setItem('wsOpen', false); clearInterval(refreshIntervalId); clearInterval(intFast); intercom.emit('TAB_CLOSED', {count: count}); } } webSocketInit() //Try do something } else { alert('intercom.js is not supported by your browser.'); }</span></span></code> </pre> </div></div><br><p>  Sekarang dengan jari saya akan menjelaskan apa yang terjadi di sini. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek demo GitHub</a> </p><br><h4 id="shag-1-otkrytie-pervoy-vkladki">  Langkah 1. Membuka tab pertama </h4><br><p>  Contoh ini mengimplementasikan penghitung waktu yang bekerja dalam beberapa kontribusi, tetapi penghitungannya hanya terjadi dalam satu kontribusi.  Kode penghitung waktu dapat diganti dengan apa saja, misalnya, dengan menginisialisasi koneksi WS.  ketika dimulai, <strong>webSocketInit ()</strong> segera dieksekusi, yang pada tab pertama akan mengarahkan kita untuk memulai penghitung ( <em>buka soket</em> ), serta untuk memulai timer <strong>startHeartBitInterval () untuk</strong> memperbarui nilai kunci " <em>wsLU</em> " di localStorage.  Kunci ini bertanggung jawab untuk pembuatan dan pemeliharaan tab Utama.  Ini adalah elemen kunci dari keseluruhan struktur.  Pada saat yang sama, kunci <em>wsOpen</em> dibuat, yang bertanggung jawab untuk status penghitung (atau membuka koneksi WS) dan variabel <em>primaryStatus</em> , yang membuat tab saat ini utama, menjadi benar.  Kwitansi acara apa pun dari konter (koneksi-WS) akan dikeluarkan oleh Intercom, dengan desain: </p><br><pre> <code class="javascript hljs">intercom.emit(<span class="hljs-string"><span class="hljs-string">'incoming'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">data</span></span>: count});</code> </pre> <br><h4 id="shag-2-otkrytie-vtoroy-vkladki">  Langkah 2. Membuka tab kedua </h4><br><p>  Membuka tab kedua, ketiga dan lainnya akan menyebabkan <strong>webSocketInit ()</strong> , setelah itu kunci " <em>wsLU</em> " dan " <em>forceOpen</em> " masuk ke pertempuran.  Jika kodenya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wsLU) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(wsLU); forceOpen = diff &gt; period_heart_bit * <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>; }</code> </pre> <br><p>  ... akan menyebabkan <em>forceOpen</em> menjadi <em>benar</em> , maka penghitung akan berhenti dan mulai lagi, tetapi ini tidak akan terjadi, karena  <em>diff</em> tidak akan lebih besar dari nilai yang ditentukan, karena kunci <em>wsLU</em> didukung oleh tab Utama saat ini.  Semua tab Sekunder akan mendengarkan acara yang diberikan tab Utama kepada mereka melalui Interkom, dengan desain: </p><br><pre> <code class="javascript hljs">intercom.on(<span class="hljs-string"><span class="hljs-string">'incoming'</span></span>, data =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'counter'</span></span>).innerHTML = data.data; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'socketStatus'</span></span>).innerHTML = primaryStatus.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; });</code> </pre> <br><h4 id="shag-3-zakrytie-vkladki">  Langkah 3. Menutup tab </h4><br><p>  Tab penutup memicu acara <strong>onbeforeunload</strong> di browser modern.  Kami memprosesnya sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (primaryStatus) { localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'wsOpen'</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); clearInterval(refreshIntervalId); intercom.emit(<span class="hljs-string"><span class="hljs-string">'TAB_CLOSED'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">count</span></span>: count}); } };</code> </pre> <br><p>  Perlu dicatat bahwa semua metode akan dipanggil hanya di tab Utama.  Saat Anda menutup tab Sekunder apa pun, tidak akan terjadi apa pun pada penghitung.  Anda hanya perlu menghapus penyadapan acara untuk membebaskan memori.  Tetapi jika kita menutup tab Utama, maka kita <em>mengatur wsOpen</em> ke <em>false</em> dan memecat acara TAB_CLOSED.  Semua tab yang terbuka akan segera menanggapinya: </p><br><pre> <code class="javascript hljs">intercom.on(<span class="hljs-string"><span class="hljs-string">'TAB_CLOSED'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localStorage.wsId !== wsId) { count = data.count; setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { webSocketInit() }, <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(getRandomArbitary(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//Init after random time. Important! } });</span></span></code> </pre> <br><p>  Di sinilah keajaiban dimulai.  Berfungsi ... </p><br><div class="spoiler">  <b class="spoiler_title">getRandomArbitary (1, 1000)</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomArbitary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * (max - min) + min; }</code> </pre> </div></div><br><p>  ... memungkinkan Anda untuk memanggil inisialisasi soket (dalam kasus kami, penghitung) pada interval yang berbeda, yang memungkinkan salah satu tab Sekunder untuk menjadi Utama dan menulis info tentang hal itu ke Penyimpanan lokal.  Setelah di-perdukakan dalam angka <em>(1, 1000),</em> Anda dapat mencapai respons tab tercepat.  Tab Sekunder yang tersisa tetap untuk mendengarkan acara dan meresponsnya, menunggu Pratama mati. </p><br><h4 id="itog">  Ringkasan </h4><br><p>  Kami mendapat desain yang memungkinkan Anda hanya menyimpan satu koneksi webSocket untuk seluruh aplikasi, tidak peduli berapa banyak tab yang dimilikinya, yang akan secara signifikan mengurangi beban pada perangkat keras server kami dan, sebagai hasilnya, akan memungkinkan Anda untuk tetap online. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415401/">https://habr.com/ru/post/id415401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415391/index.html">Sertifikasi perangkat WPA3 dimulai: kata sandi yang lemah menjadi lebih aman</a></li>
<li><a href="../id415393/index.html">Kubernetes: kehidupan perapian</a></li>
<li><a href="../id415395/index.html">TV Riak</a></li>
<li><a href="../id415397/index.html">PICASO 3D di Top 3D Expo 2018 - printer 3D baru, bahan baru</a></li>
<li><a href="../id415399/index.html">Mengapa harga DVD Fortnite gratis naik menjadi $ 450</a></li>
<li><a href="../id415403/index.html">epoll dan Windows IO Completion Ports: perbedaan praktis</a></li>
<li><a href="../id415405/index.html">Ulasan dan Uji Server Fujitsu PRIMERGY RX2540 M4</a></li>
<li><a href="../id415407/index.html">Godville - kecuali untuk lelucon</a></li>
<li><a href="../id415409/index.html">Ulasan Printer 3Dtool Raise3D PRO2 3D</a></li>
<li><a href="../id415411/index.html">Dari melayang catatan ke suara dari kotak kardus - 6 gadget menarik untuk vinil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>