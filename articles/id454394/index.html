<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¨ üßùüèø üëå Pemain MIDI Minimalis Empat Bagian üë©üèΩ‚Äç‚úàÔ∏è üë®üèª üíÉüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemain yang diusulkan tidak memerlukan kartu memori; ia menyimpan file MIDI hingga 6.000 byte secara langsung di mikrokontroler ATtiny85 (tidak sepert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemain MIDI Minimalis Empat Bagian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454394/"><img src="https://habrastorage.org/webt/wy/qv/ce/wyqvcexiheyxhiuc2lspo3iz7jm.jpeg"><br><br>  Pemain yang diusulkan tidak memerlukan kartu memori; ia menyimpan file MIDI hingga 6.000 byte secara langsung di mikrokontroler ATtiny85 (tidak seperti desain klasik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , yang memutar file WAV, secara alami membutuhkan kartu memori).  Pemutaran empat arah dengan atenuasi menggunakan PWM diimplementasikan dalam perangkat lunak.  Contoh terdengar di <a href="">sini</a> . <a name="habracut"></a><br><br>  Perangkat ini dibuat sesuai dengan skema: <br><br><img src="https://habrastorage.org/webt/qs/h8/uz/qsh8uzrueecz-x4c-pxv5webr7o.gif"><br><br>  Kapasitor elektrolit antara mikrokontroler dan kepala dinamis tidak akan kehilangan komponen konstan jika unit logis muncul pada output PB4 sebagai akibat dari kegagalan perangkat lunak.  Induktansi head tidak melewati frekuensi PWM.  Jika Anda memutuskan untuk menghubungkan perangkat ke amplifier, untuk menghindari overloading yang terakhir dengan sinyal PWM, Anda perlu menambahkan filter low-pass, seperti di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  File MIDI harus ditempatkan di sumber firmware sebagai larik formulir: <br><br><pre><code class="plaintext hljs">const uint8_t Tune[] PROGMEM = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x03, 0xc0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x0a, 0x7e, 0x00, 0xff, ... 0x50, 0xb0, 0x5b, 0x00, 0x00, 0xff, 0x2f, 0x00 };</code> </pre> <br>  Ada solusi siap pakai untuk mengonversi file ke format ini pada sistem operasi mirip UNIX - utilitas xxd.  Kami mengambil file MIDI dan melewati utilitas ini seperti ini: <br><br><pre> <code class="plaintext hljs">xxd -i musicbox.mid</code> </pre> <br>  Konsol akan menampilkan sesuatu seperti: <br><br><pre> <code class="plaintext hljs">unsigned char musicbox_mid[] = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x03, 0xc0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x0a, 0x7e, 0x00, 0xff, ... 0x50, 0xb0, 0x5b, 0x00, 0x00, 0xff, 0x2f, 0x00 }; unsigned int musicbox_mid_len = 2708;</code> </pre> <br>  2708 adalah panjang dalam byte.  Ternyata kurang dari 6000 - itu berarti cocok.  Urutan angka heksadesimal melalui clipboard ditransfer ke sketsa (ingat saja: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di konsol - tidak ada Ctrl + C</a> ) alih-alih array default.  Atau jangan lakukan semua ini jika kita ingin meninggalkannya. <br><br>  Penghitung waktu 1 akan beroperasi pada frekuensi 64 MHz dari PLL: <br><br><pre> <code class="plaintext hljs"> PLLCSR = 1&lt;&lt;PCKE | 1&lt;&lt;PLLE;</code> </pre> <br>  Kami mentransfer timer ini ke mode PWM untuk bekerja sebagai DAC, siklus tugas akan tergantung pada nilai OCR1B: <br><br><pre> <code class="plaintext hljs"> TIMSK = 0; // Timer interrupts OFF TCCR1 = 1&lt;&lt;CS10; // 1:1 prescale GTCCR = 1&lt;&lt;PWM1B | 2&lt;&lt;COM1B0; // PWM B, clear on match OCR1B = 128; DDRB = 1&lt;&lt;DDB4; // Enable PWM output on pin 4</code> </pre> <br>  Frekuensi pulsa persegi panjang tergantung pada nilai OCR1C, kita biarkan sama dengan 255 (secara default), maka frekuensi 64 MHz akan dibagi dengan 256, dan kami mendapatkan 250 kHz. <br><br>  Penghitung waktu 0 akan menghasilkan interupsi: <br><br><pre> <code class="plaintext hljs"> TCCR0A = 3&lt;&lt;WGM00; // Fast PWM TCCR0B = 1&lt;&lt;WGM02 | 2&lt;&lt;CS00; // 1/8 prescale OCR0A = 19; // Divide by 20 TIMSK = 1&lt;&lt;OCIE0A; // Enable compare match, disable overflow</code> </pre> <br>  Frekuensi clock 16 MHz dibagi dengan pembagi dengan 8, dan kemudian dengan nilai OCR0A 19 + 1, dan 100 kHz diperoleh.  Pemain empat suara, 25 kHz diperoleh untuk setiap suara.  Setelah terputus, rutin pemrosesan ISR disebut (TIMER0_COMPA_vect), yang menghitung dan mengeluarkan suara. <br><br>  Pengawas waktu diatur untuk menghasilkan interupsi setiap 16 ms, yang diperlukan untuk menerima frekuensi catatan: <br><br><pre> <code class="plaintext hljs">WDTCR = 1&lt;&lt;WDIE | 0&lt;&lt;WDP0; // Interrupt every 16ms</code> </pre> <br>  Untuk mendapatkan osilasi dari bentuk yang diberikan, sintesis digital langsung digunakan.  Tidak ada perkalian perangkat keras dalam ATtiny85, jadi kami mengambil pulsa persegi panjang dan mengalikan amplitudo amplop dengan 1 atau -1.  Amplitudo berkurang secara linear, dan untuk menghitungnya pada waktu tertentu, itu cukup untuk secara linear mengurangi pembacaan meter. <br><br>  Tiga variabel disediakan untuk setiap saluran: Frek [] - frekuensi, Acc [] - baterai fase, Amp [], nilai amplitudo amplop.  Nilai-nilai Freq [] dan Acc [] dijumlahkan.  Bit orde tinggi Acc [] digunakan untuk mendapatkan pulsa persegi panjang.  Semakin banyak Frekuensi [], semakin tinggi frekuensinya.  Bentuk gelombang yang sudah selesai dikalikan dengan amplop Amp [].  Keempat saluran multiplexing dan diumpankan ke output analog. <br><br>  Bagian penting dari program ini adalah prosedur untuk memproses interupsi dari penghitung waktu 0, yang mengeluarkan osilasi ke keluaran analog.  Prosedur ini disebut pada frekuensi sekitar 95 kHz.  Untuk saluran saat ini c, itu memperbarui nilai Acc [c] dan Amp [c], dan juga menghitung nilai catatan saat ini.  Hasilnya dikirim ke register perbandingan OCR1B dari penghitung waktu OCR1B untuk mendapatkan sinyal analog pada pin 4: <br><br><pre> <code class="plaintext hljs">ISR(TIMER0_COMPA_vect) { static uint8_t c; signed char Temp, Mask, Env, Note; Acc[c] = Acc[c] + Freq[c]; Amp[c] = Amp[c] - (Amp[c] != 0); Temp = Acc[c] &gt;&gt; 8; Temp = Temp &amp; Temp&lt;&lt;1; Mask = Temp &gt;&gt; 7; Env = Amp[c] &gt;&gt; Volume; Note = (Env ^ Mask) + (Mask &amp; 1); OCR1B = Note + 128; c = (c + 1) &amp; 3; }</code> </pre> <br>  Tali <br><br><pre> <code class="plaintext hljs">Acc[c] = Acc[c] + Freq[c];</code> </pre> <br>  menambahkan frekuensi freq [c] ke baterai Acc [c].  Semakin besar Frekuensi [c], semakin cepat nilai Acc [c] akan berubah.  Kemudian berbaris <br><br><pre> <code class="plaintext hljs">Amp[c] = Amp[c] - (Amp[c] != 0);</code> </pre> <br>  mengurangi nilai amplitudo untuk saluran tertentu.  Fragmen (Amp [c]! = 0) diperlukan sehingga setelah amplitudo mencapai nol, tidak berkurang lebih jauh.  Sekarang berbaris <br><br><pre> <code class="plaintext hljs">Temp = Acc[c] &gt;&gt; 8;</code> </pre> <br>  mentransfer 9 bit Acc [c] tinggi ke Temp.  Dan garis <br><br><pre> <code class="plaintext hljs">Temp = Temp &amp; Temp&lt;&lt;1;</code> </pre> <br>  meninggalkan bit orde tinggi dari variabel ini sama dengan satu jika dua bit orde tinggi sama dengan satu, dan menetapkan bit orde tinggi ke nol jika tidak.  Hasilnya adalah pulsa persegi panjang dengan rasio on / off 25/75.  Dalam salah satu konstruksi sebelumnya, penulis menerapkan berliku-liku, sedangkan dengan metode baru, harmonik diperoleh sedikit lebih banyak.  Tali <br><br><pre> <code class="plaintext hljs">Mask = Temp &gt;&gt; 7;</code> </pre> <br>  mentransfer nilai yang paling signifikan ke bit byte yang tersisa, misalnya, jika bit paling signifikan adalah 0, maka 0x00 akan diperoleh, dan jika 1 - lalu 0xFF.  Tali <br><br><pre> <code class="plaintext hljs">Env = Amp[c] &gt;&gt; Volume;</code> </pre> <br>  mentransfer bit Amp [c] yang ditentukan oleh nilai Volume ke Env, secara default yang senior, karena Volume = 8. String <br><br><pre> <code class="plaintext hljs">Note = (Env ^ Mask) + (Mask &amp; 1);</code> </pre> <br>  Semua ini menyatukan.  Jika Mask = 0x00 maka Note diberikan nilai Env.  Jika Mask = 0xFF, maka Note diberi nilai tambahan untuk Env + 1, yaitu, Env dengan tanda minus.  Catatan sekarang berisi bentuk gelombang saat ini, berubah dari nilai positif ke negatif dari amplitudo saat ini.  Tali <br><br><pre> <code class="plaintext hljs">OCR1B = Note + 128;</code> </pre> <br>  menambahkan 128 ke Note dan menulis hasilnya ke OCR1B.  Tali <br><br><pre> <code class="plaintext hljs">c = (c + 1) &amp; 3;</code> </pre> <br>  output empat saluran sesuai dengan interupsi yang sesuai, multiplexing suara pada output. <br><br>  Dua belas frekuensi note diberikan dalam array: <br><br><pre> <code class="plaintext hljs">unsigned int Scale[] = { 10973, 11626, 12317, 13050, 13826, 14648, 15519, 16442, 17419, 18455, 19552, 20715};</code> </pre> <br>  Frekuensi nada oktaf lain diperoleh dengan membaginya dengan 2 <sup>n</sup> .  Sebagai contoh, kita membagi 10973 dengan 2 <sup>4</sup> dan kita mendapatkan 686. Bit atas [c] akan beralih dengan frekuensi 25000 / (65536/685) = 261,7 Hz. <br><br>  Dua variabel memengaruhi suara: Volume - volume, dari 7 hingga 9 dan Decay - redaman, dari 12 menjadi 14. Semakin tinggi nilai Decay, semakin lambat redamannya. <br><br>  Penerjemah MIDI yang paling sederhana hanya memperhatikan nilai-nilai catatan, tempo dan koefisien pembagian, dan mengabaikan data lainnya.  Rutin readIgnore () melewatkan jumlah byte yang ditentukan dalam array yang diterima dari file: <br><br><pre> <code class="plaintext hljs">void readIgnore (int n) { Ptr = Ptr + n; }</code> </pre> <br>  Rutin readNumber () membaca angka dari jumlah byte tertentu dengan akurasi 4: <br><br><pre> <code class="plaintext hljs">unsigned long readNumber (int n) { long result = 0; for (int i=0; i&lt;n; i++) result = (result&lt;&lt;8) + pgm_read_byte(&amp;Tune[Ptr++]); return result; }</code> </pre> <br>  Rutin readVariable () membaca angka dengan presisi variabel MIDI.  Jumlah byte dalam kasus ini dapat dari satu hingga empat: <br><br><pre> <code class="plaintext hljs">unsigned long readVariable () { long result = 0; uint8_t b; do { b = pgm_read_byte(&amp;Tune[Ptr++]); result = (result&lt;&lt;7) + (b &amp; 0x7F); } while (b &amp; 0x80); return result; }</code> </pre> <br>  Tujuh bit diambil dari setiap byte, dan yang kedelapan sama dengan satu jika Anda perlu membaca byte lain lebih lanjut, atau nol jika tidak. <br><br>  Interpreter memanggil noteOn () rutin untuk memainkan note di saluran yang tersedia berikut ini: <br><br><pre> <code class="plaintext hljs">void noteOn (uint8_t number) { uint8_t octave = number/12; uint8_t note = number%12; unsigned int freq = Scale[note]; uint8_t shift = 9-octave; Freq[Chan] = freq&gt;&gt;shift; Amp[Chan] = 1&lt;&lt;Decay; Chan = (Chan + 1) &amp; 3; }</code> </pre> <br>  Variabel Ptr menunjukkan byte berikutnya untuk dibaca: <br><br><pre> <code class="plaintext hljs">void playMidiData () { Ptr = 0; // Begin at start of file</code> </pre> <br>  Blok pertama dalam file MIDI adalah header yang menunjukkan jumlah trek, tempo, dan rasio pembagian: <br><br><pre> <code class="plaintext hljs">// Read header chunk unsigned long type = readNumber(4); if (type != MThd) error(1); unsigned long len = readNumber(4); unsigned int format = readNumber(2); unsigned int tracks = readNumber(2); unsigned int division = readNumber(2); // Ticks per beat TempoDivisor = (long)division*16000/Tempo;</code> </pre> <br>  Koefisien pembagian biasanya sama dengan 960. Sekarang kita membaca jumlah blok yang diberikan: <br><br><pre> <code class="plaintext hljs"> // Read track chunks for (int t=0; t&lt;tracks; t++) { type = readNumber(4); if (type != MTrk) error(2); len = readNumber(4); EndBlock = Ptr + len;</code> </pre> <br>  Baca peristiwa berurutan sampai akhir blok: <br><br><pre> <code class="plaintext hljs"> // Parse track while (Ptr &lt; EndBlock) { unsigned long delta = readVariable(); uint8_t event = readNumber(1); uint8_t eventType = event &amp; 0xF0; if (delta &gt; 0) Delay(delta/TempoDivisor);</code> </pre> <br>  Dalam setiap peristiwa, delta ditentukan - penundaan dalam satuan waktu yang ditentukan oleh koefisien pembagian, yang harus terjadi sebelum peristiwa ini.  Untuk peristiwa yang seharusnya terjadi di sini, delta adalah nol. <br><br>  Meta-events adalah acara bertipe 0xFF: <br><br><pre> <code class="plaintext hljs"> // Meta event if (event == 0xFF) { uint8_t mtype = readNumber(1); uint8_t mlen = readNumber(1); // Tempo if (mtype == 0x51) { Tempo = readNumber(mlen); TempoDivisor = (long)division*16000/Tempo; // Ignore other meta events } else readIgnore(mlen);</code> </pre> <br>  Satu-satunya jenis meta-event yang menarik minat kami adalah Tempo, nilai tempo dalam mikrodetik.  Secara default, itu adalah 500.000, yaitu, setengah detik, yang setara dengan 120 denyut per menit. <br><br>  Peristiwa yang tersisa adalah peristiwa MIDI yang ditentukan oleh digit heksadesimal pertama dari tipenya.  Kami hanya tertarik pada 0x90 - Note On, memainkan catatan pada saluran yang tersedia berikut: <br><br><pre> <code class="plaintext hljs"> // Note off - ignored } else if (eventType == 0x80) { uint8_t number = readNumber(1); uint8_t velocity = readNumber(1); // Note on } else if (eventType == 0x90) { uint8_t number = readNumber(1); uint8_t velocity = readNumber(1); noteOn(number); // Polyphonic key pressure } else if (eventType == 0xA0) readIgnore(2); // Controller change else if (eventType == 0xB0) readIgnore(2); // Program change else if (eventType == 0xC0) readIgnore(1); // Channel key pressure else if (eventType == 0xD0) readIgnore(1); // Pitch bend else if (eventType == 0xD0) readIgnore(2); else error(3); } } }</code> </pre> <br>  Kami mengabaikan nilai kecepatan, tetapi jika Anda mau, Anda dapat mengatur amplitudo awal not di atasnya.  Kami melewatkan sisa acara, panjangnya bisa berbeda.  Jika kesalahan terjadi pada file MIDI, LED menyala. <br><br>  Mikrokontroler beroperasi pada frekuensi 16 MHz, sehingga kuarsa tidak diperlukan, Anda harus mengkonfigurasi PLL bawaan dengan benar.  Agar mikrokontroler menjadi kompatibel dengan Arduino, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengalaman</a> Spence Konde ini diterapkan.  Di menu Papan, pilih submenu ATtinyCore, dan di sana - ATtiny25 / 45/85.  Dalam menu berikut, pilih: Timer 1 Jam: CPU, BOD Disabled, ATtiny85, 16 MHz (PLL).  Kemudian pilih Burn Bootloader, lalu isi program.  Programmer digunakan seperti Tiny AVR Programmer Board SpinyFun. <br><br>  Firmware untuk CC-BY 4.0, yang sudah memiliki fugue Bach di D minor, ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , file MIDI asli diambil di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454394/">https://habr.com/ru/post/id454394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454378/index.html">Astronot Rusia di bulan pada tahun 2030: Presentasi Rogozin</a></li>
<li><a href="../id454382/index.html">Ivan Uglyansky dan Vladimir Sitnikov di jug.msk.ru</a></li>
<li><a href="../id454384/index.html">Koreksi penglihatan laser - apakah metode Smile benar-benar efektif?</a></li>
<li><a href="../id454386/index.html">MessageBox untuk AvaloniaUI</a></li>
<li><a href="../id454388/index.html">ARA: algoritma untuk menemukan jumlah maksimum poin pada garis lurus</a></li>
<li><a href="../id454396/index.html">Instal sdl2 pada distribusi utama</a></li>
<li><a href="../id454398/index.html">Dari kritik hingga algoritma: bagaimana demokrasi dan teknokrasi datang ke industri musik</a></li>
<li><a href="../id454400/index.html">Laporan Harian Status Mesin Virtual dengan R dan PowerShell</a></li>
<li><a href="../id454402/index.html">Arsitektur Mesin Unity State untuk Mengatur Perilaku Unit</a></li>
<li><a href="../id454404/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 6. Isi bagian yang kosong (DHCP, TCP, "jabat tangan", nomor port umum)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>