<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏬ 🥌 🐞 Sakelar antena otomatis dengan kontrol MK 🍲 🛳️ 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam latihan radio amatir, terkadang ada kebutuhan untuk melakukan sesuatu pada mikrokontroler. Jika Anda tidak melakukan kerajinan seperti ini sepan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sakelar antena otomatis dengan kontrol MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/405581/"><div style="text-align:center;"><img src="https://habrastorage.org/web/263/1bc/d85/2631bcd85f59492fbe35cfccc226fb15.jpg" alt="gambar"></div><br>  Dalam latihan radio amatir, terkadang ada kebutuhan untuk melakukan sesuatu pada mikrokontroler.  Jika Anda tidak melakukan kerajinan seperti ini sepanjang waktu, maka Anda harus mencari solusi sirkuit yang sesuai dan perpustakaan yang cocok untuk MK untuk waktu yang lama, sehingga Anda dapat dengan cepat menyelesaikan masalahnya.  Baru-baru ini saya ingin membuat saklar antena otomatis.  Dalam prosesnya, saya harus menggunakan banyak fitur Atmega MK dalam satu proyek ringkas.  Mereka yang mulai mempelajari AVR, beralih dari Arduino atau kadang-kadang program MK dapat menjadi potongan kode yang berguna yang digunakan oleh saya dalam proyek. <br><a name="habracut"></a><br>  Saya memikirkan saklar antena sebagai perangkat yang secara otomatis menghubungkan antena ke transceiver, yang paling cocok untuk rentang kerja gelombang pendek.  Saya memiliki dua antena: V terbalik dan Ground Plane, mereka terhubung ke tuner antena MFJ, di mana mereka dapat diaktifkan dari jarak jauh.  Ada saklar manual bermerek MFJ, yang ingin saya ganti. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b6e/63f/073/b6e63f07338f40babb1c1cfb06eed94f.gif" alt="gambar"></div><br>  Untuk pengalihan operasional antena, satu tombol terhubung ke MK.  Saya mengadaptasinya untuk mengingat antena yang disukai untuk setiap rentang: ketika Anda menekan tombol selama lebih dari 3 detik, antena yang dipilih diingat dan dipilih dengan benar secara otomatis setelah power-up perangkat berikutnya.  Informasi tentang kisaran saat ini, antena yang dipilih, dan keadaan penyetelannya ditampilkan pada layar LCD satu baris. <br><br>  Anda dapat mengetahui kisaran transceiver yang saat ini bekerja dengan cara yang berbeda: Anda dapat mengukur frekuensi sinyal, Anda dapat menerima data melalui antarmuka CAT, tetapi hal paling sederhana bagi saya adalah menggunakan antarmuka transceiver YAESU untuk menghubungkan amplifier eksternal.  Ini memiliki 4 garis sinyal, dalam kode biner, yang menunjukkan kisaran saat ini.  Mereka memberikan sinyal logis dari 0 hingga 5 volt dan mereka dapat dihubungkan ke kaki-kaki MK melalui sepasang resistor terminating. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/85f/6b9/ebf/85f6b9ebf2aa4fe496fc48501171675e.jpg" alt="gambar"></div><br>  Bukan itu saja.  Dalam mode transmisi, sinyal PTT dan ALC ditransmisikan melalui antarmuka yang sama.  Ini adalah sinyal logis tentang menyalakan pemancar (ditarik ke tanah) dan sinyal analog dari 0 hingga -4V tentang pengoperasian sistem kontrol daya pemancar otomatis.  Saya juga memutuskan untuk mengukurnya dan menampilkannya pada LCD dalam mode transmisi. <br><br>  Selain itu, tuner MFJ dapat mengirimkan sinyal ke remote control yang sedang disetel dan antena disetel.  Untuk melakukan ini, panel kontrol perusahaan MFJ memiliki dua LED kontrol.  Alih-alih LED, saya menghubungkan optocoupler dan mengirim sinyal dari mereka ke MK, sehingga saya bisa melihat semua informasi di satu layar.  Perangkat yang sudah selesai terlihat seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e33/38f/2f8/e3338f2f8fff4187b523c0adbdda2d23.jpg" alt="gambar"></div><br>  Secara singkat tentang buatan sendiri seperti segalanya.  Sekarang tentang bagian perangkat lunak.  Kode ini ditulis dalam Atmel Studio (Unduhan gratis dari situs web Atmel).  Proyek untuk pemula menunjukkan fitur-fitur berikut menggunakan Atmega8 MK yang populer: <br><br><ol><li>  Hubungkan tombol </li><li>  Hubungkan input saluran untuk sinyal digital dari transceiver dan tuner </li><li>  Menghubungkan output kontrol dari saklar antena </li><li>  Menghubungkan satu layar LCD baris </li><li>  Koneksi buzzer dan output suara </li><li>  Koneksi jalur input analog ADC dan pengukuran tegangan </li><li>  Menggunakan interupsi </li><li>  Menggunakan timer untuk menghitung waktu tombol ditekan </li><li>  Menggunakan Watchdog </li><li>  Menggunakan memori non-volatile untuk menyimpan antena yang dipilih </li><li>  Menggunakan UART untuk Pencetakan Debug </li><li>  Menghemat energi dalam idle MK </li></ol><br>  Jadi mari kita mulai.  Dalam perjalanan teks, akan ada segala macam nama register dan karakteristik konstanta dari MK yang diterapkan.  Ini bukan Arduino, sayangnya, Anda harus membaca datasheet di MK.  Jika tidak, Anda tidak mengerti apa arti semua register ini dan bagaimana Anda dapat mengubah nilainya.  Tetapi struktur program secara keseluruhan akan tetap sama. <br><br><h3>  Pertama, hubungkan tombol ke MK </h3><br>  Ini yang paling sederhana.  Kami menghubungkan satu kontak ke kaki MK, kontak tombol kedua ke tanah.  Agar tombol berfungsi, Anda harus mengaktifkan resistor pull-up di MK.  Dia akan menghubungkan tombol melalui perlawanan ke +5V bus.  Untuk melakukan ini cukup sederhana: <br><br><pre><code class="cpp hljs">PORTB |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB2); <span class="hljs-comment"><span class="hljs-comment">// pullup resistor  </span></span></code> </pre> <br>  Demikian pula, semua input digital yang dikendalikan oleh gangguan tanah (optocoupler, jalur sinyal dari transceiver, sinyal PTT) ditarik ke bus + 5V.  Terkadang lebih baik menyolder resistor yang lebih kecil secara fisik (misalnya 10k) antara input MK dan bus + 5V, tetapi pembahasan masalah ini berada di luar cakupan artikel.  Karena semua sinyal input dalam proyek jarang mengubah nilai, mereka didorong ke tanah oleh 10 kapasitor nanofarad untuk melindungi terhadap gangguan. <br><br>  Sekarang kita memiliki 1 logis pada input PB2, dan ketika Anda menekan tombol, itu akan logis 0. Ketika Anda menekan \ tekan, Anda perlu melacak bouncing kontak tombol, memeriksa bahwa tingkat sinyal tidak berubah dari waktu ke waktu, katakanlah 50 milidetik.  Ini dilakukan dalam program seperti ini: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; !timer_on) { <span class="hljs-comment"><span class="hljs-comment">//    _delay_ms(50); if( !(PINB&amp;(1&lt;&lt;PINB2)) ) { //        -   passed_secs = 0; timer_on = 1; } }</span></span></code> </pre><br><h3>  Sekarang hubungkan squeaker </h3><br>  Ini akan memberikan sinyal konfirmasi audio bahwa antena direkam dalam memori MK.  Sebuah tweeter hanyalah elemen piezoelektrik.  Terhubung melalui resistansi kecil ke kaki MK, dan dengan kontak kedua ke + 5V.  Agar buzzer ini berfungsi, Anda harus terlebih dahulu mengkonfigurasi kaki MK untuk menampilkan data. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_buzzer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB0); <span class="hljs-comment"><span class="hljs-comment">// buzzer DDRB |= (1 &lt;&lt; PB0); // output PORTB &amp;= ~(1 &lt;&lt; PB0); }</span></span></code> </pre><br>  Sekarang bisa digunakan.  Untuk melakukan ini, fungsi kecil ditulis yang menggunakan waktu tunda untuk mengganti kaki MK dari 0 ke 1 dan sebaliknya.  Beralih dengan penundaan yang diperlukan memungkinkan untuk menghasilkan sinyal audio 4 kHz dengan durasi sekitar seperempat detik pada output MK, yang merupakan suara elemen piezoelektrik. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buzz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    4 0,25  for(int i=0; i&lt;1000; i++) { wdt_reset(); //    PORTB |= (1 &lt;&lt; PB0); _delay_us(125); PORTB &amp;= ~(1 &lt;&lt; PB0); _delay_us(125); } }</span></span></code> </pre><br>  Agar fungsi penundaan berfungsi, jangan lupa sertakan file header dan tetapkan kecepatan prosesor konstan.  Itu sama dengan frekuensi resonator kuarsa yang terhubung ke MK.  Dalam kasus saya, ada kuarsa 16MHz. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> F_CPU # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000UL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;util/delay.h&gt;</span></span></span></span></code> </pre><br><h3>  Kami terhubung ke antena switching relay MK </h3><br>  Di sini Anda hanya perlu mengkonfigurasi kaki MK untuk bekerja di jalan keluar.  Relai buluh dihubungkan ke kaki ini melalui transistor yang menguatkan dengan cara standar. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_tuner_relay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTB &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PB1); <span class="hljs-comment"><span class="hljs-comment">// relay DDRB |= (1 &lt;&lt; PB1); // output PORTB &amp;= ~(1 &lt;&lt; PB1); }</span></span></code> </pre><br><h3>  Koneksi tampilan </h3><br>  Saya menggunakan layar LCD 160 karakter single-line 1601, diekstraksi dari perangkat keras lama.  Ia menggunakan pengontrol HD44780 yang terkenal, untuk manajemen yang banyak perpustakaan tersedia di jaringan.  Beberapa orang baik menulis perpustakaan kontrol tampilan ringan, yang saya gunakan dalam proyek ini.  Menyiapkan pustaka dikurangi menjadi menunjukkan dalam file header HD44780_Config.h jumlah kaki MK yang terhubung ke pin tampilan yang diinginkan.  Saya menerapkan koneksi tampilan melalui 4 jalur data. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Data_Length 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NumberOfLines 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Font 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_E PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_E 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Strob_Signal_RS PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_Strob_Signal_RS 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_4 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_4 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_5 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_5 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_6 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_6 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_bus_7 PORTC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIN_bus_7 3</span></span></code> </pre><br>  Fitur dari instance tampilan saya adalah bahwa satu baris pada layar ditampilkan sebagai dua baris 8 karakter, sehingga buffer layar perantara dibuat dalam program untuk pekerjaan yang lebih mudah dengan layar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORTC &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PC0); <span class="hljs-comment"><span class="hljs-comment">// display DDRC |= (1 &lt;&lt; PC0); // output PORTC &amp;= ~(1 &lt;&lt; PC0); PORTC &amp;= ~(1 &lt;&lt; PC1); // display DDRC |= (1 &lt;&lt; PC1); // output PORTC &amp;= ~(1 &lt;&lt; PC1); PORTC &amp;= ~(1 &lt;&lt; PC2); // display DDRC |= (1 &lt;&lt; PC2); // output PORTC &amp;= ~(1 &lt;&lt; PC2); PORTC &amp;= ~(1 &lt;&lt; PC3); // display DDRC |= (1 &lt;&lt; PC3); // output PORTC &amp;= ~(1 &lt;&lt; PC3); PORTC &amp;= ~(1 &lt;&lt; PC4); // display DDRC |= (1 &lt;&lt; PC4); // output PORTC &amp;= ~(1 &lt;&lt; PC4); PORTC &amp;= ~(1 &lt;&lt; PC5); // display DDRC |= (1 &lt;&lt; PC5); // output PORTC &amp;= ~(1 &lt;&lt; PC5); LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); } /*   16  0-3   40M     4-8   A:GP  A:IV     9-15    : TUNING=, TUNED==, HI-SWR= */ uchar display_buffer[]={' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '}; // 16    void update_display() { LCD_Init(); LCD_DisplEnable_CursOnOffBlink(1,0,0); //   16      8         LCD for (uchar i=0; i&lt;8; i++){ LCD_Show(display_buffer[i],1,i); LCD_Show(display_buffer[i+8],2,i); } }</span></span></code> </pre><br>  Fungsi update_display () memungkinkan Anda untuk menampilkan konten buffer di layar.  Nilai byte dalam buffer adalah kode ASCII dari karakter output. <br><br><h3>  Debug mencetak output ke port COM </h3><br>  MK memiliki UART dan saya menggunakannya untuk men-debug program.  Saat menghubungkan MK ke komputer, Anda hanya perlu mengingat bahwa level sinyal pada output MK berada dalam standar TTL, dan bukan RS232, sehingga Anda memerlukan adaptor sederhana.  Saya menggunakan adaptor USB-Serial, mirip sepenuhnya pada aliexpress.  Setiap program terminal, misalnya dari Arduino, cocok untuk membaca data.  Kode pengaturan port UART: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BAUD 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;avr/io.h&gt; // UART      RS232 void uart_init( void ) { /* //   UBRRH = 0; UBRRL = 103; //9600   16  */ #include &lt;util/setbaud.h&gt; UBRRH = UBRRH_VALUE; UBRRL = UBRRL_VALUE; #if USE_2X UCSRA |= (1 &lt;&lt; U2X); #else UCSRA &amp;= ~(1 &lt;&lt; U2X); #endif //8  , 1  ,    UCSRC = ( 1 &lt;&lt; URSEL ) | ( 1 &lt;&lt; UCSZ1 ) | ( 1 &lt;&lt; UCSZ0 ); //     // UCSRB = ( 1 &lt;&lt; TXEN ) | ( 1 &lt;&lt;RXEN ); UCSRB = ( 1 &lt;&lt; TXEN ); } int uart_putc( char c, FILE *file ) { //     while( ( UCSRA &amp; ( 1 &lt;&lt; UDRE ) ) == 0 ); UDR = c; wdt_reset(); return 0; } FILE uart_stream = FDEV_SETUP_STREAM( uart_putc, NULL, _FDEV_SETUP_WRITE ); stdout = &amp;uart_stream;</span></span></span></span></code> </pre><br>  Setelah mengatur aliran output, Anda dapat menggunakan printf yang biasa untuk mencetak ke port: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"Start flag after reset = %u\r\n"</span></span>, mcusr_mirror );</code> </pre> <br>  Program ini menggunakan pencetakan bilangan real.  Pustaka biasa tidak mendukung mode keluaran ini, jadi saya harus menghubungkan pustaka lengkap ketika menghubungkan proyek.  Benar, itu benar-benar meningkatkan jumlah kode, tapi saya punya banyak memori, jadi itu tidak kritis.  Dalam opsi tautan Anda perlu menentukan baris: <br><br> <code>-Wl,-u,vfprintf -lprintf_flt</code> <br> <br><h3>  Bekerja dengan penghitung waktu dan interupsi </h3><br>  Untuk menghitung interval waktu dalam suatu program, penting untuk memiliki penghitung waktu.  Diperlukan untuk melacak bahwa tombol ditekan selama lebih dari 3 detik dan, karena itu, Anda perlu mengingat pengaturan baru dalam memori non-volatile.  Untuk mengukur waktu dalam gaya AVR, Anda perlu mengonfigurasi penghitung denyut dari penghasil clock dan interupsi yang akan dieksekusi ketika penghitung mencapai nilai yang ditetapkan.  Saya mengatur timer sehingga menghasilkan interupsi sekitar sekali per detik.  Interrupt handler sendiri menghitung jumlah detik yang berlalu.  Variabel timer_on mengontrol on / off timer.  Penting untuk tidak lupa mendeklarasikan semua variabel yang diperbarui di interrupt handler sebagai volatile, jika tidak kompiler dapat "mengoptimalkan" mereka dan program tidak akan berfungsi. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1    -     void timer1_init( void ) { TCCR1A = 0; //    1 -   /* 16000000 / 1024 = 15625 ,     15625      1  */ //  CTC, ICP1 interrupt sense (falling)(not used) + prescale /1024 +    (not used) TCCR1B = (0 &lt;&lt; WGM13) | (1 &lt;&lt; WGM12) | (0 &lt;&lt; ICES1) | ((1 &lt;&lt; CS12) | (0 &lt;&lt; CS11) | (1 &lt;&lt; CS10)) | (0 &lt;&lt; ICNC1); OCR1A = 15625; //  TIMSK |= (1 &lt;&lt; OCIE1A); } uchar timer_on = 0; volatile uchar passed_secs = 0; //      e ISR(TIMER1_COMPA_vect) { if (timer_on) passed_secs++; }</span></span></code> </pre><br>  Nilai pass_secs diperiksa dalam loop utama program.  Ketika tombol ditekan, timer mulai dan kemudian dalam siklus program utama nilai timer diperiksa saat tombol ditekan.  Jika nilai ini melebihi 3 detik, maka EEPROM ditulis, dan timer berhenti. <br><br>  Terakhir tetapi tidak kalah pentingnya, setelah semua inisialisasi, Anda perlu mengaktifkan interupsi dengan perintah sei (). <br><br><h3>  Pengukuran Level ALC </h3><br>  Itu dibuat menggunakan konverter analog-ke-digital (ADC) bawaan.  Saya mengukur tegangan pada input dari ADC7.  Harus diingat bahwa Anda dapat mengukur nilai dari 0 hingga 2.5V.  dan tegangan input saya dari -4V ke 0V.  Oleh karena itu, saya menghubungkan MK melalui pembagi tegangan paling sederhana pada resistor, sehingga level tegangan pada input MK berada pada level tertentu.  Lebih lanjut, saya tidak membutuhkan akurasi tinggi, jadi saya menerapkan konversi 8-bit (cukup membaca data hanya dari register ADCH).  Sebagai sumber referensi, saya menggunakan ion internal pada 2.56V, ini sedikit menyederhanakan perhitungan.  Agar ADC berfungsi, pastikan untuk menghubungkan kapasitor 0,1 μF ke kaki REF di permukaan tanah. <br><br>  ADC dalam kasus saya berfungsi terus-menerus, melaporkan akhir konversi dengan memanggil interupsi ADC_vect.  Merupakan praktik yang baik untuk meratakan nilai beberapa siklus konversi untuk mengurangi kesalahan.  Dalam kasus saya, saya menyimpulkan rata-rata 2500 transformasi.  Semua kode ADC terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ALC #define SAMPLES 2500 //    #define REFERENCEV 2.56 //       #define DIVIDER 2.0 double realV = 0; //     ALC double current_realV = 0; volatile int sampleCount = 0; volatile unsigned long tempVoltage = 0; //     volatile unsigned long sumVoltage = 0; //         void ADC_init() // ADC7 { //   2,56, 8 bit  -   ADCH ADMUX = (1 &lt;&lt; REFS0) | (1 &lt;&lt; REFS1) | (1 &lt;&lt; ADLAR) | (0 &lt;&lt; MUX3) | (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX1) | (1 &lt;&lt; MUX0); // ADC7 // , free running,   ADCSRA = (1 &lt;&lt; ADEN) | (1 &lt;&lt; ADFR) | (1 &lt;&lt; ADIE) | (1 &lt;&lt; ADPS2) | (1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0); //  128 ADCSRA |= (1 &lt;&lt; ADSC); // Start ADC Conversion } ISR(ADC_vect) //     2500  { if (sampleCount++) //    tempVoltage += ADCH; if (sampleCount &gt;= SAMPLES) { sampleCount = 0; sumVoltage = tempVoltage; tempVoltage = 0; } ADCSRA |=(1 &lt;&lt; ADIF); // Acknowledge the ADC Interrupt Flag } realV = -1.0*(DIVIDER * ((sumVoltage * REFERENCEV) / 256) / SAMPLES - 5.0); //   ALC if (realV &lt; 0.0) realV = 0.0; printf("ALC= -%4.2f\r\n", realV); //     </span></span></code> </pre><br><h3>  Menggunakan EEPROM </h3><br>  Ini adalah memori non-volatile di MK.  Lebih mudah menggunakannya untuk menyimpan segala macam pengaturan, nilai koreksi, dll.  Dalam kasus kami, ini hanya digunakan untuk menyimpan antena yang dipilih untuk rentang yang diinginkan.  Untuk tujuan ini, array 16 byte dialokasikan di EEPROM.  Tetapi Anda dapat mengaksesnya melalui fungsi-fungsi khusus yang ditentukan dalam file header avr / eeprom.h.  Saat startup, MK membaca informasi tentang pengaturan yang disimpan ke dalam RAM dan menyalakan antena yang diinginkan, tergantung pada kisaran saat ini.  Ketika tombol ditekan untuk waktu yang lama, nilai baru dicatat dalam memori, disertai dengan sinyal suara.  Saat menulis ke EEPROM, interupsi dinonaktifkan untuk berjaga-jaga.  Kode Inisialisasi Memori: <br><br><pre> <code class="cpp hljs">EEMEM <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ee_bands[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//         unsigned char avr_bands[16]; void EEPROM_init(void) { for(int i=0; i&lt;16; i++) { avr_bands[i] = eeprom_read_byte(&amp;ee_bands[i]); if (avr_bands[i] &gt; 1) avr_bands[i] = ANT_IV; //    EEPROM   ,     FF } }</span></span></code> </pre><br>  Potongan kode pemrosesan untuk menekan tombol selama 3 detik dan menulis ke memori: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(PINB&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;PINB2)) &amp;&amp; passed_secs &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    3  timer_on = 0; //   read_ant = avr_bands[read_band]; //     cli(); EEPROM_init(); //          sei(); if (read_ant) { avr_bands[read_band] = ANT_GP; } else { avr_bands[read_band] = ANT_IV; } cli(); eeprom_write_byte(&amp;ee_bands[read_band], avr_bands[read_band]); //    EEPROM sei(); buzz(); }</span></span></code> </pre><br><h3>  Menggunakan Watchdog </h3><br>  Bukan rahasia lagi bahwa di bawah kondisi interferensi elektromagnetik yang kuat, MK dapat membeku.  Ketika radio sedang beroperasi, ada gangguan sehingga "setrika mulai berbicara", jadi Anda harus memastikan restart MK dengan hati-hati jika terjadi hang.  Pengawas waktu melayani tujuan ini.  Menggunakannya sangat sederhana.  Pertama, sertakan file header avr / wdt.h dalam proyek.  Di awal program, setelah semua pengaturan selesai, Anda harus memulai timer dengan memanggil fungsi wdt_enable (WDTO_2S), dan kemudian ingat untuk mengatur ulang secara berkala dengan memanggil wdt_reset (), jika tidak maka akan me-restart MK.  Untuk debugging untuk mengetahui mengapa MK itu restart, Anda dapat menggunakan nilai register MCUSR khusus, nilai yang dapat diingat dan kemudian output ke cetak debug. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        //     uint8_t mcusr_mirror __attribute__ ((section (".noinit"))); void get_mcusr(void) \ __attribute__((naked)) \ __attribute__((section(".init3"))); void get_mcusr(void) { mcusr_mirror = MCUSR; MCUSR = 0; wdt_disable(); } printf( "Start flag after reset = %u\r\n", mcusr_mirror );</span></span></code> </pre><br><h3>  Hemat energi untuk pecinta lingkungan </h3><br>  Sementara MK tidak sibuk dengan apa pun, ia bisa tertidur dan menunggu gangguan berikutnya.  Dalam hal ini, sedikit energi listrik dihemat.  Agak, tapi mengapa tidak menggunakannya dalam proyek.  Apalagi itu sangat sederhana.  Sertakan file header avr / sleep.h.  Badan program terdiri dari satu loop tak terbatas di mana Anda perlu memanggil fungsi sleep_cpu (), setelah itu MC tertidur sedikit dan loop utama berhenti sampai gangguan berikutnya terjadi.  Mereka terjadi selama pengoperasian timer dan ADC, sehingga MK tidak akan tidur untuk waktu yang lama.  Mode hibernasi ditentukan ketika MK diinisialisasi dengan memanggil dua fungsi: <br><br><pre> <code class="cpp hljs"> set_sleep_mode(SLEEP_MODE_IDLE); <span class="hljs-comment"><span class="hljs-comment">//     IDLE sleep_enable();</span></span></code> </pre><br>  Itu saja untuk saat ini.  Saya beralih, itu berhasil bekerja di stasiun radio amatir saya tanpa kegagalan.  Saya berharap materi yang diberikan akan bermanfaat bagi pemula. <br><br>  73 de R2AJP </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id405581/">https://habr.com/ru/post/id405581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id405571/index.html">Elemen Sistem Inovasi Nasional AS, Bagian 1: Lingkungan Bisnis dan Pajak, Perdagangan dan Kebijakan Ekonomi</a></li>
<li><a href="../id405573/index.html">Sistem Peringatan Serangan Polisi Otomatis</a></li>
<li><a href="../id405575/index.html">Tinjauan smartphone ASUS ZenFone 4 Max</a></li>
<li><a href="../id405577/index.html">Sistem Inovasi Nasional AS</a></li>
<li><a href="../id405579/index.html">"Selamat pagi Vietnam!": Cara memulai radio Internet Anda</a></li>
<li><a href="../id405583/index.html">Portable Vibro Speaker PartyFon</a></li>
<li><a href="../id405585/index.html">Lockheed Martin membangun modul layak huni prototipe untuk ruang dalam</a></li>
<li><a href="../id405587/index.html">Kami memahami fisika partikel: 4) gelombang, persamaan gerak klasik</a></li>
<li><a href="../id405589/index.html">Google membantu reaktor fusi plasma panas di reaktor menggunakan perangkat lunak khusus</a></li>
<li><a href="../id405591/index.html">Pejabat FAS Memilih Operator Pajak untuk Barang yang Dibeli oleh Rusia di Luar Negeri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>