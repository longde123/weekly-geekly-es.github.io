<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏠 🚱 🦕 كيف سيكون شكل مترو موسكو في عالم ثلاثي الأبعاد 👩🏽‍🤝‍👨🏼 ✏️ 👨🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="محدث: كما هو مطلوب في التعليقات ، أضفت رابطًا إلى مخطط جافا سكريبت الدوار 
 لسوء الحظ ، تعذر إدخال كود javascript في نص المنشور 
 مساء الخير لقد قرأت ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف سيكون شكل مترو موسكو في عالم ثلاثي الأبعاد</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470602/" style=";text-align:right;direction:rtl">  محدث: كما هو مطلوب في التعليقات ، أضفت رابطًا إلى مخطط جافا سكريبت الدوار <br>  لسوء الحظ ، تعذر إدخال كود javascript في نص المنشور <br>  مساء الخير  لقد قرأت مؤخرًا مدونة لأحد سكان المدن كان يناقش الشكل الذي يجب أن يكون عليه مخطط المترو المثالي ، ويمكن رسم مخطط المترو على أساس مبدأين: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يجب أن تكون الدائرة مريحة وسهلة التذكر والتوجيه. </li><li style=";text-align:right;direction:rtl">  يجب أن يتوافق المخطط مع جغرافية المدينة </li></ul><br>  من الواضح أن هذه المبادئ تستبعد بعضها بعضًا ويتطلب المبدأ الأول تشويهًا ملموسًا للواقع الجغرافي. <br><br>  يكفي أن نتذكر كيف يبدو مخطط مترو موسكو بحلقات جميلة وخطوط مستقيمة: <br><a name="habracut"></a><br><img src="http://news.metro.ru/19/mm20190620s.jpg" alt="صورة"><br><br>  والمقارنة مع خطة دقيقة جغرافيا: <br><br><img src="https://kartymetro.ru/wp-content/uploads/2018/07/karta_metro_moskvy_2020-1024x950.jpeg" alt="صورة"><br><br>  توضح الخطة أن الحلقات ليست سلسة ومركبة تمامًا على الإطلاق ، تنحني الخطوط كثيرًا عن المخطط ، وكثافة المحطات في وسط المدينة عالية جدًا لدرجة أنه من المستحيل تقريبًا تحديد الخطة. <br><br>  على الرغم من أن الصورة الثانية تعكس الواقع بشكل أكثر دقة ، فمن الواضح أنه من الأنسب استخدام المخطط الأول للتخطيط لمسار في المترو. <br><br>  ثم فكرت الفكرة التالية: "كيف سيبدو المترو إذا كان المعيار لبناء الدائرة هو الوقت اللازم للانتقال من محطة إلى أخرى؟"  بمعنى أنه إذا استطعت الانتقال من محطة إلى أخرى بسرعة ، فسيكون موقعها قريبًا على الرسم التخطيطي. <br><br>  من الواضح ، في الفضاء ثنائي الأبعاد ، من المستحيل رسم مثل هذا المخطط الذي تكون فيه المسافة بين محطتين مساوية لوقت السفر من محطة إلى أخرى بسبب الطوبولوجيا المعقدة للرسم البياني للمترو. <br><br>  هناك أيضًا حدس بأن هذا ممكن تمامًا عند إنشاء مخطط في مساحة ذات بعد كبير (التقدير العلوي هو n-1 ، حيث n هو عدد المحطات).  بالنسبة لمساحة ذات عدد صغير من الأبعاد ، لا يمكن بناء مثل هذا المخطط إلا تقريبًا. <br><br>  تبدو مهمة إنشاء خريطة مترو بواسطة وقت السفر مهمة تحسين نموذجية. <br>  افترض أن لدينا مجموعة أولية من الإحداثيات لجميع المحطات (X و Y و Z) ومصفوفة مستهدفة من الأوقات الزوجية (المسافات).  من الممكن إنشاء مقياس "عدم صحة" لمجموعة معينة من الإحداثيات ومن ثم تقليلها باستخدام طريقة النسب التدرج لكل من إحداثيات كل محطة.  كمقياس ، يمكننا القيام بوظيفة بسيطة للانحراف المعياري عن المسافات. <br><br>  حسنًا ، الشيء الوحيد المتبقي هو الحصول على بيانات حول مقدار الوقت الذي يجب أن تقضيه في السفر من أي محطة لمترو موسكو إلى أي محطة أخرى. <br><br>  كانت الفكرة الأولى هي التحقق من مؤشر مترو ياندكس والحصول على هذه البيانات من هناك.  لسوء الحظ ، لا يمكن العثور على وصف api.  شاهد الأوقات يدويًا في التطبيق لفترة طويلة (في المترو هناك 268 محطة وحجم المصفوفة الزمنية 268 * 268 = 71824).  لذلك ، قررت أن أفهم البيانات المصدر لمترو ياندكس.  نظرًا لعدم وجود إمكانية الوصول إلى الخادم ، تم تنزيل ملف apk مع التطبيق وتم العثور على البيانات اللازمة.  جميع المعلومات حول المترو مبنية بشكل رائع وتخزينها في تنسيق JSON في مجلد أرشيف الأصول / metrokit / apk.  يتم تخزين جميع البيانات في هياكل ذاتية الشرح.  يحتوي Meta.json على معلومات حول المدن التي توجد مخططاتها في التطبيق ، بالإضافة إلى معرف هذه المخططات. <br><br><pre style=";text-align:right;direction:rtl"><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"sc77792237"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nizhny Novgorod"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nizhny Novgorod"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"uk"</span></span>: <span class="hljs-string"><span class="hljs-string">"і "</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"packed"</span></span>: <span class="hljs-number"><span class="hljs-number">30300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"unpacked"</span></span>: <span class="hljs-number"><span class="hljs-number">145408</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"published"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"aliases"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"nizhny-novgorod"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"logoUrl"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://avatars.mds.yandex.net/get-bunker/135516/f2f0e33d8def90c56c189cfb57a8e6403b5a441c/orig"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2c27fe1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"geoRegion"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"delta"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lat"</span></span>: <span class="hljs-number"><span class="hljs-number">0.168291</span></span>, <span class="hljs-attr"><span class="hljs-attr">"lon"</span></span>: <span class="hljs-number"><span class="hljs-number">0.219727</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"center"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lat"</span></span>: <span class="hljs-number"><span class="hljs-number">56.326635</span></span>, <span class="hljs-attr"><span class="hljs-attr">"lon"</span></span>: <span class="hljs-number"><span class="hljs-number">43.992153</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"countryCode"</span></span>: <span class="hljs-string"><span class="hljs-string">"RU"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"defaultAlias"</span></span>: <span class="hljs-string"><span class="hljs-string">"nizhny-novgorod"</span></span> }</code> </pre> <br>  حسب معرف المخطط ، نجد المجلد مع JSON المتعلق بموسكو. <br><br>  يحتوي ملف data.json على معلومات أساسية حول الرسم البياني للمترو ، بما في ذلك أسماء عقد الرسم البياني ، ومعرفات العقدة ، والإحداثيات الجغرافية للعقد ، ومعلومات حول الانتقال من محطة إلى أخرى (المعرف ، ووقت الانتقال ، ونوع الانتقال - سواء كانت القيادة أو المشي ، في الشارع أم لا ، الوقت نحن مهتمون بالثواني) وأيضًا الكثير من المعلومات الإضافية حول المداخل والمخارج من المحطة.  هذا سهل بما فيه الكفاية لمعرفة.  لنبدأ كتابة التعليمات البرمجية لبناء دائرتنا. <br><br>  نستورد المكتبات اللازمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> codecs <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> networkx <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> nx <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras.backend <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> K <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mpl_toolkits.mplot3d <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Axes3D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mpl_toolkits.mplot3d.proj3d <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> proj_transform <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> matplotlib.text <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Annotation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle</code> </pre><br>  تتوافق بنية القواميس والقوائم بيثون تمامًا مع بنية تنسيق json ، لذلك نقرأ معلومات المترو وننشئ كائنات تتوافق مع كائنات json. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">names = json.loads(codecs.open( <span class="hljs-string"><span class="hljs-string">"l10n.json"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf_8_sig"</span></span> ).read() ) graph = json.loads(codecs.open( <span class="hljs-string"><span class="hljs-string">"data.json"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf_8_sig"</span></span> ).read() )</code> </pre><br>  ننشئ قاموسًا يعين عقد الرسم البياني والمحطة (يعد هذا ضروريًا لأن المحطات مخصصة للأسماء وليس للعقد البياني) <br><br>  أيضا ، فقط في حالة ، سنقوم بحفظ إحداثيات العقد لإمكانية إنشاء خريطة جغرافية (تطبيع إلى مجموعة من 0-1) <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">nodeStdict={} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> stop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph[<span class="hljs-string"><span class="hljs-string">'stops'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: nodeStdict[stop[<span class="hljs-string"><span class="hljs-string">'nodeId'</span></span>]]=stop[<span class="hljs-string"><span class="hljs-string">'stationId'</span></span>] coordDict={} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph[<span class="hljs-string"><span class="hljs-string">'nodes'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: coordDict[node[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]]=(node[<span class="hljs-string"><span class="hljs-string">'attributes'</span></span>][<span class="hljs-string"><span class="hljs-string">'geoPoint'</span></span>][<span class="hljs-string"><span class="hljs-string">'lon'</span></span>],node[<span class="hljs-string"><span class="hljs-string">'attributes'</span></span>][<span class="hljs-string"><span class="hljs-string">'geoPoint'</span></span>][<span class="hljs-string"><span class="hljs-string">'lat'</span></span>]) lats=[] longs=[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> coordDict.values(): lats.append(value[<span class="hljs-number"><span class="hljs-number">1</span></span>]) longs.append(value[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> coordDict.items(): coordDict[k]=((v[<span class="hljs-number"><span class="hljs-number">0</span></span>]-np.min(longs))/(np.max(longs)-np.min(longs)),(v[<span class="hljs-number"><span class="hljs-number">1</span></span>]-np.min(lats))/(np.max(lats)-np.min(lats)))</code> </pre><br>  إنشاء رسم بياني للمترو مع الاتصالات.  وضعنا وزن كل اتصال.  الوزن يتوافق مع وقت السفر.  سنقوم بإزالة العقد التي ليست محطات (في رأيي ، هذه مخارج من المترو وهناك حاجة إلى اتصالات بها لبطاقات Yandex عند حساب الوقت ، لكن لم أفهمها بالضبط) ، قم بإنشاء قاموس معرف العقدة - الاسم الحقيقي باللغة الروسية <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">G=nx.Graph() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph[<span class="hljs-string"><span class="hljs-string">'nodes'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: G.add_node(node[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#graph['links'] for link in graph['links']['items']: #G.add_edges_from([(link['fromNodeId'],link['toNodeId'])]) G.add_edge(link['fromNodeId'], link['toNodeId'], length=link['attributes']['time']) nodestoremove=[] for node in G.nodes(): if len(G.edges(node))&lt;2: nodestoremove.append(node) for node in nodestoremove: G.remove_node(node) labels={} for node in G.nodes(): try: labels[node]=names['keysets']['generated'][nodeStdict[node]+'-name']['ru'] except: labels[node]='error'</span></span></code> </pre><br>  نحدد الفرع (أي رقم الفرع) الذي تنتمي إليه كل عقدة (ستكون هناك حاجة إلى ذلك لاحقًا لتلوين خطوط المترو في المخطط) <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getlines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph, G)</span></span></span><span class="hljs-function">:</span></span> nodetoline={} id_from={} id_to={} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> lk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph[<span class="hljs-string"><span class="hljs-string">'tracks'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: id_from[lk[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]]=lk[<span class="hljs-string"><span class="hljs-string">'fromNodeId'</span></span>] id_to[lk[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]]=lk[<span class="hljs-string"><span class="hljs-string">'toNodeId'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph[<span class="hljs-string"><span class="hljs-string">'linesToTracks'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line[<span class="hljs-string"><span class="hljs-string">'trackId'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> id_from.keys(): nodetoline[id_from[line[<span class="hljs-string"><span class="hljs-string">'trackId'</span></span>]]]=line[<span class="hljs-string"><span class="hljs-string">'lineId'</span></span>] nodetoline[id_to[line[<span class="hljs-string"><span class="hljs-string">'trackId'</span></span>]]]=line[<span class="hljs-string"><span class="hljs-string">'lineId'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodetoline lines=getlines(graph,G)</code> </pre><br>  تتيح لك مكتبة networkx العثور على أقصر طول المسار من عقدة إلى أخرى باستخدام وظيفة nx.shortest_path_length (G، id1، id2، weight = 'length') ، لذلك يمكننا افتراض أننا قد انتهينا من إعداد البيانات.  الشيء التالي الذي يجب القيام به هو إعداد نموذج من شأنه تحسين إحداثيات المحطات. <br><br>  للقيام بذلك ، سنعرف ما الذي سيتم إعطاؤه للمدخلات ، إلى المخرجات ، وكيف سنقوم بتحسين مصفوفة إحداثيات المحطة. <br><br>  لنفترض أن لدينا مصفوفة لجميع الإحداثيات (3x268).  ضرب متجه واحد ساخن (متجه حيث 0 في كل مكان باستثناء وحدة واحدة تحل محل n) من البعد 268 بواسطة هذه المصفوفة الإحداثية سيعطي 3 إحداثيات المقابلة للمحطة ن.  إذا أخذنا زوجًا من المتجهات ذات درجة الحرارة الواحدة وضربناها في المصفوفة اللازمة ، فسنحصل على اثنين من الإحداثيات الثلاثية.  من زوج من الإحداثيات يمكنك حساب المسافة الإقليدية بين المحطات.  وبالتالي ، يمكننا تحديد بنية نموذجنا: <br><br><img src="https://habrastorage.org/webt/ik/sx/aw/iksxawvycguvch8k9apg7bbm6wi.png"><br><br>  عند المدخل نعطي اثنين من المحطات ، في الإخراج نحصل على المسافة بينهما. <br><br>  بعد أن نقرر تنسيق البيانات لتدريب النموذج ، سنقوم بإعداد البيانات باستخدام البحث عن بعد على الرسم البياني: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">myIDs=list(G.nodes()) listofinputs1=[] listofinputs2=[] listofoutputs=[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itertools.product(G.nodes(), repeat=<span class="hljs-number"><span class="hljs-number">2</span></span>): vec1=np.zeros((len(myIDs))) vec2=np.zeros((len(myIDs))) vec1[myIDs.index(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>])]=<span class="hljs-number"><span class="hljs-number">1</span></span> vec2[myIDs.index(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>])]=<span class="hljs-number"><span class="hljs-number">1</span></span> listofinputs1.append(vec1) listofinputs2.append(vec2) <span class="hljs-comment"><span class="hljs-comment">#listofinputs.append([vec1,vec2]) listofoutputs.append(nx.shortest_path_length(G, pair[0], pair[1], weight='length')/3600) #myDistMatrix[myIDs.index(pair[0]),myIDs.index(pair[1])]=nx.shortest_path_length(G, pair[0], pair[1], weight='length')</span></span></code> </pre><br>  نقوم بتحسين مصفوفة إحداثيات المحطة باستخدام طريقة النسب التدرج. <br><br>  إذا استخدمنا إطار عمل keras للتعلم الآلي ، فسنحصل على ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">np.random.seed(<span class="hljs-number"><span class="hljs-number">0</span></span>) initweightmatrix=np.zeros((len(myIDs),<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(myIDs)): initweightmatrix[i,:<span class="hljs-number"><span class="hljs-number">2</span></span>]=coordDict[myIDs[i]] initweightmatrix[i,<span class="hljs-number"><span class="hljs-number">2</span></span>]=np.random.randn()*<span class="hljs-number"><span class="hljs-number">0.001</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">euclidean_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vects)</span></span></span><span class="hljs-function">:</span></span> x, y = vects sum_square = K.sum(K.square(x - y), axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, keepdims=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> K.sqrt(K.maximum(sum_square, K.epsilon())) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eucl_dist_output_shape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shapes)</span></span></span><span class="hljs-function">:</span></span> shape1, shape2 = shapes <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (shape1[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) inp1=keras.layers.Input((len(myIDs),)) inp2=keras.layers.Input((len(myIDs),)) layer1=keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">3</span></span>,use_bias=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, activation=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) x1=layer1(inp1) x2=layer1(inp2) x=keras.layers.Lambda(euclidean_distance, output_shape=eucl_dist_output_shape)([x1, x2]) out=keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>,use_bias=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>,activation=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)(x) model=keras.Model(inputs=[inp1,inp2],outputs=out) model.layers[<span class="hljs-number"><span class="hljs-number">2</span></span>].set_weights([initweightmatrix]) model.layers[<span class="hljs-number"><span class="hljs-number">2</span></span>].trainable=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span> model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number"><span class="hljs-number">0.01</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'mse'</span></span>)</code> </pre><br>  لاحظ أننا نستخدم الإحداثيات الجغرافية الحقيقية باعتبارها الإحداثيات الأولية في layer1 - وهذا ضروري حتى لا نقع في الحد الأدنى المحلي لوظيفة الانحراف المعياري.  نحن نهيئ الإحداثي الثالث بإحداثيات غير صفرية للحصول على تدرج غير صفري (إذا كانت الخريطة في البداية مسطحة تمامًا ، فإن تحول أي محطة لأعلى أو لأسفل سيكون هو نفسه ، وبالتالي فإن التدرج يكون 0 ولن يتم تحسين z).  يؤثر العنصر الأخير من نموذجنا (Dense (1)) في توسيع نطاق المخطط ليناسب الجدول الزمني. <br><br>  سنقوم بقياس المسافة بالساعات ، وليس بالثواني ، نظرًا لأن طلبات المسافات تبلغ حوالي ساعة واحدة ، وللتدريب الأكثر فعالية للنموذج ، من المهم أن تكون جميع القيم (بيانات الإدخال ، والأوزان ، والأهداف) تقريبًا بنفس الترتيب من حيث الحجم.  إذا كانت هذه القيم قريبة من 1 ، فيمكنك استخدام قيم الخطوات القياسية للتحسين (0.001-0.01). <br><br>  يقوم model line.layers [2] .trainable = False بتجميد إحداثيات المحطات وفي المرحلة الأولى يتم تغيير معلمة واحدة - المقياس.  بعد تحديد حجم مخططنا ، نقوم بإلغاء تجميد الإحداثيات وتحسينها بالفعل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">hist=model.fit([listofinputs1,listofinputs2],listofoutputs,batch_size=<span class="hljs-number"><span class="hljs-number">71824</span></span>,epochs=<span class="hljs-number"><span class="hljs-number">200</span></span>) model.layers[<span class="hljs-number"><span class="hljs-number">2</span></span>].trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> model.layers[<span class="hljs-number"><span class="hljs-number">-1</span></span>].trainable=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span> model.compile(optimizer=keras.optimizers.Adam(lr=<span class="hljs-number"><span class="hljs-number">0.01</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'mse'</span></span>) hist2=model.fit([listofinputs1,listofinputs2],listofoutputs,batch_size=<span class="hljs-number"><span class="hljs-number">71824</span></span>,epochs=<span class="hljs-number"><span class="hljs-number">200</span></span>)</code> </pre><br>  نرى أننا نتغذى على جميع أزواج المحطات في وقت واحد ، عند الخروج من جميع المسافات ، والتحسين هو نزول تدرج كامل للدفعات (خطوة واحدة على جميع البيانات).  وظيفة الخسارة في هذه الحالة هي الانحراف المعياري ، ويمكنك أن ترى أنه كان 0.015 في نهاية التدريب ، مما يعني أن الانحراف المعياري أقل من دقيقة واحدة لأي زوج من المحطات.  بمعنى آخر ، يتيح لك المخطط الناتج معرفة المسافة المطلوبة للانتقال من محطة إلى أخرى بدقة من خلال المسافة في خط مستقيم بين المحطات بدقة + -1 دقيقة! <br><br>  ولكن دعونا نرى كيف تبدو دائرتنا! <br><br>  احصل على إحداثيات المحطات ، خذ الترميز اللوني للخطوط وقم بإنشاء صورة ثلاثية الأبعاد بتوقيعات (يتم أخذ رمز العرض الجميل للتوقيعات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">من هنا</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Annotation3D</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Annotation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''Annotate the point xyz with text s'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, s, xyz, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> Annotation.__init__(self,s, xy=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), *args, **kwargs) self._verts3d = xyz <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, renderer)</span></span></span><span class="hljs-function">:</span></span> xs3d, ys3d, zs3d = self._verts3d xs, ys, zs = proj_transform(xs3d, ys3d, zs3d, renderer.M) self.xy=(xs,ys) Annotation.draw(self, renderer) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate3D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ax, s, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'''add anotation text s to to Axes3d ax'''</span></span> tag = Annotation3D(s, *args, **kwargs) ax.add_artist(tag) fincoords=model.layers[<span class="hljs-number"><span class="hljs-number">2</span></span>].get_weights() ccode={} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph[<span class="hljs-string"><span class="hljs-string">'services'</span></span>][<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: ccode[obj[<span class="hljs-string"><span class="hljs-string">'id'</span></span>]]=(<span class="hljs-string"><span class="hljs-string">'\#'</span></span>+obj[<span class="hljs-string"><span class="hljs-string">'attributes'</span></span>][<span class="hljs-string"><span class="hljs-string">'color'</span></span>])[<span class="hljs-number"><span class="hljs-number">1</span></span>:] xn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">0</span></span>] yn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">1</span></span>] zn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">2</span></span>] l=[labels[idi] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myIDs] colors=[ccode[lines[idi]] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myIDs] xyzn = zip(xn, yn, zn) fig = plt.figure() ax = fig.gca(projection=<span class="hljs-string"><span class="hljs-string">'3d'</span></span>) ax.scatter(xn,yn,zn, c=colors, marker=<span class="hljs-string"><span class="hljs-string">'o'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j, xyz_ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(xyzn): annotate3D(ax, s=labels[myIDs[j]], xyz=xyz_, fontsize=<span class="hljs-number"><span class="hljs-number">9</span></span>, xytext=(<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), textcoords=<span class="hljs-string"><span class="hljs-string">'offset points'</span></span>, ha=<span class="hljs-string"><span class="hljs-string">'right'</span></span>,va=<span class="hljs-string"><span class="hljs-string">'bottom'</span></span>) plt.show()</code> </pre><br>  نظرًا لوجود صعوبات في التحويل إلى تنسيق ثلاثي الأبعاد تفاعلي للمتصفح ، أقوم بنشر ملفات gif: <br><br><img src="https://habrastorage.org/webt/ts/h8/-n/tsh8-niklcayz5gixfk5vkbrczq.gif"><br><br>  الإصدار بدون نص يبدو أكثر جمالا ويمكن التعرف عليه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">xn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">0</span></span>] yn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">1</span></span>] zn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">2</span></span>] l=[labels[idi] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myIDs] colors=[ccode[lines[idi]] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myIDs] xyzn = zip(xn, yn, zn) fig = plt.figure() ax = fig.gca(projection=<span class="hljs-string"><span class="hljs-string">'3d'</span></span>) ax.scatter(xn,yn,zn, c=colors, marker=<span class="hljs-string"><span class="hljs-string">'o'</span></span>) plt.show()</code> </pre><br><img src="https://habrastorage.org/webt/kk/oi/ay/kkoiaydx47oun6-enod5azcsotq.gif"><br><br>  UPD: إضافة خطوط المترو من اللون المطلوب وإنشاء GIF.  خطوط سوداء - التحولات بين المحطات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">myedges=[(myIDs.index(edge[<span class="hljs-number"><span class="hljs-number">0</span></span>]),myIDs.index(edge[<span class="hljs-number"><span class="hljs-number">1</span></span>]))<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> edge <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> G.edges] xn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">0</span></span>] yn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">1</span></span>] zn = fincoords[<span class="hljs-number"><span class="hljs-number">0</span></span>][:,<span class="hljs-number"><span class="hljs-number">2</span></span>] l=[labels[idi] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myIDs] c=[ccode[lines[idi]] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idi <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myIDs] fig = plt.figure() ax = fig.gca(projection=<span class="hljs-string"><span class="hljs-string">'3d'</span></span>) ax.scatter(x,y,z, c=c, marker=<span class="hljs-string"><span class="hljs-string">'o'</span></span>,s=<span class="hljs-number"><span class="hljs-number">25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> edge <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myedges: col=<span class="hljs-string"><span class="hljs-string">'black'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c[edge[<span class="hljs-number"><span class="hljs-number">0</span></span>]]==c[edge[<span class="hljs-number"><span class="hljs-number">1</span></span>]]: col=c[edge[<span class="hljs-number"><span class="hljs-number">0</span></span>]] ax.plot3D([x[edge[<span class="hljs-number"><span class="hljs-number">0</span></span>]], x[edge[<span class="hljs-number"><span class="hljs-number">1</span></span>]]], [y[edge[<span class="hljs-number"><span class="hljs-number">0</span></span>]], y[edge[<span class="hljs-number"><span class="hljs-number">1</span></span>]]], [z[edge[<span class="hljs-number"><span class="hljs-number">0</span></span>]], z[edge[<span class="hljs-number"><span class="hljs-number">1</span></span>]]], col) ims = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle)</span></span></span><span class="hljs-function">:</span></span> ax.view_init(azim=angle) rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">362</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), interval=<span class="hljs-number"><span class="hljs-number">70</span></span>) rot_animation.save(<span class="hljs-string"><span class="hljs-string">'rotation2.gif'</span></span>, dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>, writer=matplotlib.animation.PillowWriter(<span class="hljs-number"><span class="hljs-number">80</span></span>))</code> </pre><br><img src="https://habrastorage.org/webt/0w/y9/r6/0wy9r6wx7k882e530jad51o8pc0.gif"><br><br>  من هذا المخطط ، يمكن استخلاص بعض الاستنتاجات المثيرة للاهتمام التي ليست واضحة من المخططات الأخرى.  بالنسبة إلى بعض الفروع ، على سبيل المثال ، الأخضر أو ​​الأزرق أو الأرجواني ، فإن MCC (الحلقة الوردية) تكون عديمة الفائدة تقريبًا بسبب عمليات الزرع غير المريحة ، والتي تظهر في مسافة الحلقة من هذه الفروع.  أطول الطرق - من شقة مشتركة إلى طريق سريع أو يوم الجمعة (خيول حمراء وزهرية / زرقاء) ، والطرق الطويلة هي أيضًا رواية قصة ألما-آتا وبونين ألي-نيكراسوفكا.  بناءً على الخطة ، يوجد في شمال موسكو ازدواج جزئي للفروع الرمادية والخضراء الفاتحة - فهي قريبة من المخطط.  سيكون من المثير للاهتمام أن نرى كيف الخطوط الجديدة (WDC ، BKL) والذين سوف تستخدمها في كثير من الأحيان.  على أي حال ، آمل أن تكون مثل هذه المخططات أدوات مهمة للتحليل والإلهام وتخطيط السفر. <br><br>  PS 3D ليس ضروريًا ، بالنسبة للإصدار الثنائي الأبعاد يكفي لتصحيح الكود قليلاً.  ولكن في حالة المخطط ثنائي الأبعاد ، من المستحيل تحقيق هذه الدقة للمسافات. <br><br><img src="https://habrastorage.org/webt/bk/bt/cp/bkbtcppvnxoxqzxtg_ijzzb0woy.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar470602/">https://habr.com/ru/post/ar470602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar470592/index.html">استعراض Plesk - استضافة ومراقبة لوحات الموقع</a></li>
<li><a href="../ar470594/index.html">تقرير من المعرض الضوئي "دائرة الضوء" 2019 في موسكو</a></li>
<li><a href="../ar470596/index.html">ميزات Q و KDB + على مثال خدمة في الوقت الحقيقي</a></li>
<li><a href="../ar470598/index.html">كتاب "جافا الحديثة. تعبيرات Lambda ، والجداول ، والبرمجة الوظيفية "</a></li>
<li><a href="../ar470600/index.html">حول لوحات التحكم الآمنة في noVNC ، إجراء الفحص الذاتي في Kubernetes ، Haproxy في Ostrovka وعمل المشرفين مع المبرمجين</a></li>
<li><a href="../ar470604/index.html">سرعة تحميل المواقع في التجارة الإلكترونية: تحليل 48 متجرا على الإنترنت في روسيا</a></li>
<li><a href="../ar470608/index.html">الوحدة UI الأمثل</a></li>
<li><a href="../ar470610/index.html">يوم واحد في حياة المطور</a></li>
<li><a href="../ar470612/index.html">ما يظهر الفولتميتر ، أو مآخذ الرياضيات</a></li>
<li><a href="../ar470614/index.html">كيف تم ترتيب الرسومات NES؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>