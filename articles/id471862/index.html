<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ”§ âœ… ğŸ• Implementasi parser PEG ğŸŸ ğŸ‘©ğŸ½â€ğŸ¨ ğŸ“†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terinspirasi hanya oleh pemahaman parsial tentang PEG, saya memutuskan untuk mencoba mengimplementasikannya. Hasilnya mungkin bukan yang terbaik di an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi parser PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471862/"><p>  Terinspirasi hanya oleh pemahaman parsial tentang PEG, saya memutuskan untuk mencoba mengimplementasikannya.  Hasilnya mungkin bukan yang terbaik di antara parser PEG tujuan umum - sudah ada banyak dari mereka (misalnya, TatSu ditulis dalam Python dan menghasilkan kode Python) - tetapi ini adalah cara yang baik untuk memahami PEG.  Di masa depan, saya ingin menggantinya dengan implementasi parser saat ini di CPython. </p><br><div class="spoiler">  <b class="spoiler_title">Konten Seri Parser Python PEG</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengurai pasak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualisasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata Bahasa PEG Rekursif Kiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambahkan Tindakan ke Tata Bahasa PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata bahasa meta untuk pengurai PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerapkan fitur PEG yang tersisa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEG pada Core Developer Sprint</a> </li></ul></div></div><br><p>  Pada bagian ini, saya meletakkan dasar untuk memahami pekerjaan parser, menggunakan contoh implementasi tata bahasa mainan sederhana yang ditulis sendiri dari artikel sebelumnya. </p><a name="habracut"></a><br><p>  (Ngomong-ngomong, sebagai percobaan, saya tidak menempatkan tautan di teks saya. Jika Anda tidak memahami sesuatu, Anda dapat mencarinya di google. :-) </p><br><p> Biasanya, PEG menggunakan parser keturunan rekursif dengan buffer tak terbatas untuk kembali.  Berikut ini adalah tata bahasa mainan dari artikel sebelumnya: </p><br><pre><code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  Pengurai super-abstrak dari keturunan rekursif untuk bahasa ini akan menentukan fungsinya untuk setiap aturan di mana alternatif akan dipahami.  Misalnya, untuk <code>statement</code> , kita akan memiliki fungsi ini: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Tentu saja, ini adalah contoh yang terlalu sederhana: ia menghilangkan detail penting, misalnya, apa yang dimasukkan ke input fungsi ini dan apa yang akan menjadi hasil dari pelaksanaannya. </p><br><p>  Mari kita mulai dengan argumen.  Parser klasik menggunakan tokenizer terpisah, yang membagi input (file teks atau baris) menjadi serangkaian token, seperti kata kunci, pengidentifikasi (nama), angka, dan operator.  Parser PEG (seperti parser modern lainnya seperti ANTLR) sering menggabungkan tokenization dan parsing, tetapi untuk proyek saya, saya memutuskan untuk meninggalkan tokenizer terpisah. </p><br><p>  Tokenisasi python cukup rumit, jadi saya tidak ingin menerapkannya pada aturan PEG.  Misalnya, Anda harus melacak lekukan (ini membutuhkan tumpukan di dalam tokenizer);  Pemrosesan baris baru dalam Python juga menarik (mereka signifikan, kecuali yang terlampir dalam kurung yang sesuai).  Banyak jenis string juga menyebabkan beberapa kompleksitas.  Singkatnya, saya tidak punya keluhan tentang tokenizer Python yang ada, jadi saya ingin membiarkannya apa adanya.  Omong-omong, CPython memiliki dua tokenizers: yang internal, yang digunakan oleh parser, ditulis dalam C, dan satu library standar, yang merupakan salinan tepat yang diimplementasikan dalam Python murni.  Ini akan berguna dalam proyek saya. </p><br><p>  Tokenizer klasik biasanya memiliki antarmuka sederhana yang terdiri dari fungsi <code>get_token()</code> tunggal.  Setiap kali, itu mengembalikan token berikutnya dalam urutan input, menganalisis sekelompok karakter.  Modul <code>tokenize</code> CPython tidak terkecuali: API intinya adalah generator yang mengeluarkan satu token pada satu waktu.  Setiap token adalah objek bertipe <code>TypeInfo</code> , yang memiliki beberapa bidang, yang paling penting adalah jenis token (misalnya, <code>NAME</code> , <code>NUMBER</code> , <code>STRING</code> ) dan nilai stringnya adalah himpunan karakter yang terdiri dari (misalnya, <code>abc</code> , <code>42</code> atau <code>"Hello, world"</code> ).  Ada juga bidang tambahan.  Misalnya, untuk indeks token dalam aliran input, yang berguna dalam pesan kesalahan. </p><br><p>  Jenis token khusus adalah <code>ENDMARKER</code> , yang menunjukkan bahwa akhir file input telah tercapai.  Generator akan jatuh jika Anda mengabaikannya dan mencoba untuk mendapatkan token berikutnya. </p><br><p>  Tapi saya terganggu.  Bagaimana kita mewujudkan pengembalian tanpa batas?  Mengembalikan daftar token mengharuskan Anda untuk mengingat posisi dalam kode sumber dan menganalisis kembali dari titik itu.  API tokenizer tidak memungkinkan kami untuk memindahkan penunjuknya, tetapi Anda dapat menangkap aliran token ke dalam array dan memutarnya dari sana, yang akan kami lakukan.  Anda juga dapat mengulangi ini dengan <code>itertools.tee()</code> , tetapi ini mungkin kurang efektif dalam kasus kami, jika Anda melihat peringatan dalam dokumentasi. </p><br><p>  Saya kira Anda bisa tokenize semua input ke daftar terlebih dahulu, dan kemudian menggunakannya sebagai input ke parser.  Tetapi jika ada token yang tidak valid di akhir file (misalnya, sebuah baris dengan kutipan penutup yang hilang) dan ada juga kesalahan sintaksis dalam file, maka Anda akan terlebih dahulu menerima pesan kesalahan dari tokenizer.  Saya percaya ini buruk bagi pengguna, karena kesalahan sintaksis dapat menjadi penyebab utama dari garis yang tidak valid.  Jadi saya memiliki persyaratan yang sedikit berbeda untuk tokenizer, khususnya, itu harus diimplementasikan sebagai daftar malas. </p><br><p>  API inti sangat sederhana.  Objek <code>Tokenizer</code> merangkum array token dan posisi dalam array ini.  Dia memiliki tiga metode utama: </p><br><ul><li>  <code>get_token()</code> mengembalikan token berikutnya, menggerakkan pointer (atau membaca token berikutnya dari sumber, jika kita berada di akhir buffer token); </li><li>  <code>mark()</code> mengembalikan posisi saat ini di buffer; </li><li>  <code>reset(pos)</code> mengatur posisi dalam buffer (argumen harus diperoleh dari <code>mark()</code> ). </li></ul><br><p>  Kami menambahkan satu fungsi helper <code>peek_token()</code> , yang mengembalikan token berikutnya tanpa menggeser posisi di buffer. </p><br><p>  Beginilah dasar dari kelas <code>Tokenizer</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tokenizer</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokengen)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Call with tokenize.generate_tokens(...)."""</span></span> self.tokengen = tokengen self.tokens = [] self.pos = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.pos = pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> token = self.peek_token() self.pos += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.pos == len(self.tokens): self.tokens.append(next(self.tokengen)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokens[self.pos]</code> </pre> <br><p>  Di sini, sesuatu dihilangkan karena kesederhanaan (misalnya, nama metode dan variabel instan harus dimulai dengan garis bawah), tetapi ini hanyalah prototipe API <code>Tokenizer</code> . </p><br><p>  Parser juga harus menjadi kelas sehingga <code>statement()</code> , <code>expr()</code> , dll.  dapat diimplementasikan sebagai metode.  Tokenizer akan menjadi variabel instan, tetapi saya tidak ingin metode parser untuk langsung memanggil <code>get_token()</code> - sebagai gantinya, kami menerapkan metode <code>wait()</code> di kelas <code>Parser</code> , yang dapat berhasil atau gagal seperti metode parser.  Argumen ke fungsi <code>wait()</code> adalah token yang diharapkan: baik string (misalnya, <code>+</code> ) atau jenis token (misalnya, <code>NAME</code> ).  Jenis nilai kembalian belum penting, saya akan kembali ke sana setelah membahas hasil pekerjaan parser. </p><br><p>  Biarkan fungsi aturan tata bahasa hanya mengembalikan <code>True</code> atau <code>False</code> .  Ini bagus untuk ilmu komputer teoretis (ada pengurai menjawab pertanyaan "Apakah <em>ini</em> string yang valid dalam bahasa?"), Tapi tidak untuk kita.  Tugas kita adalah membuat AST.  Jadi, mari kita menulis ulang kode ini sehingga setiap metode analisis mengembalikan objek <code>Node</code> berhasil atau tidak <code>None</code> yang gagal. </p><br><p>  Kelas <code>Node</code> bisa sangat sederhana: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, children)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.children = children</code> </pre> <br><p>  Di sini, <code>type</code> menentukan jenis simpul AST (misalnya, <code>add</code> atau <code>if</code> ), dan turunannya adalah daftar simpul dan token (contoh <code>TokenInfo</code> ).  Ini cukup bagi kompiler untuk menghasilkan kode atau melakukan analisis lain, seperti pemeriksaan linting atau statis.  Meskipun di masa depan saya ingin mengubah cara AST disajikan. </p><br><p>  Agar sesuai dengan skema ini, metode <code>expect()</code> harus mengembalikan objek <code>TokenInfo</code> pada kesuksesan dan <code>None</code> pada kegagalan.  Untuk dapat memutar kembali ke token sebelumnya, saya membungkus panggilan ke metode <code>mark()</code> dan <code>reset()</code> dari tokenizer (di sini API tidak berubah).  Inilah yang terjadi: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokenizer)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer = tokenizer <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.mark() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer.reset(pos) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, arg)</span></span></span><span class="hljs-function">:</span></span> token = self.tokenizer.peek_token() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token.type == arg <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> token.string == arg: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.get_token() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Sekali lagi: Saya menghilangkan beberapa detail, tetapi ini sudah kode yang berfungsi. </p><br><p>  Sekarang saya perlu memperkenalkan persyaratan penting untuk metode parser.  Setiap orang harus mengembalikan <code>Node</code> , menempatkan tokenizer setelah token terakhir dari aturan tata bahasa yang mereka kenali;  baik <code>None</code> dan biarkan posisi tokenizer tidak berubah.  Jika metode parser membaca beberapa token dan kemudian jatuh, itu harus mengembalikan posisi tokenizer.  Untuk melakukan ini, <code>mark()</code> dan <code>reset()</code> dimaksudkan.  Perhatikan bahwa <code>expect()</code> juga mematuhi aturan ini. </p><br><p>  Jadi, inilah sketsa parser yang sebenarnya.  Di sini saya menggunakan operator walrus dari Python 3.8 ( <code>:=</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a := self.assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i := self.if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t := self.term(): pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"+"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"-"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"sub"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Very similar... def atom(self): if token := self.expect(NAME): return token if token := self.expect(NUMBER): return token pos = self.mark() if self.expect("("): if e := self.expr(): if self.expect(")"): return e self.reset(pos) return None</span></span></code> </pre> <br><p>  Saya menghilangkan penerapan beberapa metode sehingga pembaca memiliki kesempatan untuk berlatih sendiri.  Ini benar-benar lebih baik daripada hanya membaca tentang bagaimana parser diimplementasikan.  Pada akhirnya, kami akan menghasilkan kode seperti itu secara otomatis dari tata bahasa.  Konstanta seperti <code>NAME</code> dan <code>NUMBER</code> diimpor dari modul <code>token</code> pustaka standar.  Ini lebih lanjut mengikat kita dengan implementasi tokenizer Python saat ini.  Jika kita ingin membuat parser PEG umum, maka kita harus menemukan cara untuk menghindari ini. </p><br><p>  Perhatikan juga bahwa saya sedikit tertipu.  Metode <code>expr</code> harus dibiarkan rekursif, tapi saya membuat parser benar rekursif karena parser keturunan rekursif tidak bekerja dengan aturan tata bahasa rekursif kiri.  Ini dapat diperbaiki, tetapi masih menjadi topik penelitian ilmiah, dan saya ingin membicarakannya secara terpisah.  Perlu diingat bahwa implementasi ini tidak 100% konsisten dengan tata bahasa kami yang disederhanakan. </p><br><p>  Hal-hal kunci yang saya ingin Anda mengerti sejauh ini: </p><br><ul><li>  Aturan tata bahasa berhubungan dengan metode parser, dan ketika aturan tata bahasa merujuk ke yang lain, itu akan memanggil metode aturan lain. </li><li>  Ketika urutan token dapat diartikan berbeda, metode parser yang sesuai dipanggil satu demi satu. </li><li>  Ketika aturan tata bahasa merujuk ke token, metode ini memanggil fungsi <code>expect()</code> . </li><li>  Jika parser berhasil mengenali aturan tata bahasanya pada posisi saat ini, ia mengembalikan node AST yang sesuai;  jika dia tidak bisa mengenali aturan tata bahasanya, dia mengembalikan <code>None</code> . </li><li>  Metode Parser harus secara eksplisit mengatur ulang posisi tokenizer ketika mereka berhenti melakukan parsing setelah menggunakan satu atau lebih token (secara langsung atau tidak langsung, menggunakan metode parsing lain yang berhasil).  Ini berlaku tidak hanya ketika salah satu opsi ditolak untuk melanjutkan ke yang berikutnya, tetapi juga ketika analisis ditolak secara keseluruhan. </li></ul><br><p>  Jika semua metode penguraian mematuhi aturan ini, maka tidak perlu membungkus masing-masing <code>mark()</code> dan <code>reset()</code> panggilan.  Ini bisa dibuktikan dengan induksi. </p><br><p>  Selain itu, tergoda untuk mencoba menyingkirkan panggilan eksplisit untuk <code>mark()</code> dan <code>reset()</code> menggunakan manajer konteks dan pernyataan <code>with</code> , tetapi itu tidak akan berfungsi: Anda tidak boleh memanggil <code>reset()</code> jika berhasil!  Sebagai perbaikan lebih lanjut, Anda dapat mencoba menggunakan pengecualian untuk aliran kontrol sehingga manajer konteks tahu apakah tokenizer harus diatur ulang (saya pikir TatSu melakukan hal yang serupa).  Misalnya, sesuatu seperti ini: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.assignment() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.expr() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.if_statement() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ParsingFailure</code> </pre> <br><p>  Secara khusus, tangga kecil <code>if</code> dalam <code>atom()</code> untuk mengenali ekspresi dalam tanda kurung dapat ditulis sebagai: </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): self.expect(<span class="hljs-string"><span class="hljs-string">"("</span></span>) e = self.expr() self.expect(<span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e</code> </pre> <br><p>  Tapi menurut saya terlalu "ajaib" - ketika membaca kode seperti itu, Anda harus ingat bahwa setiap metode parsing (termasuk <code>wait()</code> ) dapat memberikan pengecualian.  Dan bahwa pengecualian ini ditangkap dan diabaikan oleh manajer konteks dalam pernyataan <code>with</code> .  Ini agak tidak biasa, meskipun dapat diwujudkan (dengan mengembalikan <code>True</code> dari <code>__exit__</code> ).  Namun, tujuan akhir saya adalah untuk menghasilkan kode dalam C, bukan Python, dan dalam C tidak ada pernyataan untuk mengubah aliran kontrol. </p><br><p>  Bagaimanapun, berikut adalah beberapa topik untuk bagian-bagian berikut: </p><br><ul><li>  generasi metode parser dari tata bahasa; </li><li>  packrat-parsing (memoization); </li><li>  Fitur EBNF seperti <code>(x | y)</code> , <code>[xy ...]</code> , <code>x*</code> , <code>x+</code> ; </li><li>  tracing (untuk men-debug parser atau tata bahasa); </li><li>  Fitur PEG seperti lookahead and cut; </li><li>  bagaimana menangani aturan rekursif kiri; </li><li>  Pembuatan kode C </li></ul><br><p>  Lisensi untuk artikel ini dan kode yang dikutip: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471862/">https://habr.com/ru/post/id471862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471852/index.html">Berita dari dunia OpenStreetMap No. 481 (10/01/2019 - 07/10/2019)</a></li>
<li><a href="../id471854/index.html">Heat Death 5G</a></li>
<li><a href="../id471856/index.html">Kami memecahkan semua 42 versi dari teka-teki ramuan Harry Potter</a></li>
<li><a href="../id471858/index.html">RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi di Cluster</a></li>
<li><a href="../id471860/index.html">Pengurai pasak</a></li>
<li><a href="../id471864/index.html">Generasi parser PEG</a></li>
<li><a href="../id471866/index.html">Visualisasi parser PEG</a></li>
<li><a href="../id471868/index.html">Genetika cinta: konflik antar gender sebagai dasar kerja sama dalam pasangan burung monogami</a></li>
<li><a href="../id471870/index.html">Penggunaan libdispatch yang efektif</a></li>
<li><a href="../id471872/index.html">Antarmuka dalam C # 8: Asumsi Berbahaya dalam Implementasi Default</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>