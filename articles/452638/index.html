<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐌 🧙🏽 😻 Cómo lanzamos 2GIS en CarPlay y todavía desenredamos ⏺️ 🐧 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Mi nombre es Vanya, estoy escribiendo una aplicación móvil 2GIS para iOS. Hoy habrá una historia sobre cómo apareció nuestro navegador en CarPlay...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo lanzamos 2GIS en CarPlay y todavía desenredamos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/452638/"><p><img src="https://habrastorage.org/webt/tt/jg/a3/ttjga3qmefdwknrbj1i351exs3m.jpeg"></p><br><p>  Hola  Mi nombre es Vanya, estoy escribiendo una aplicación móvil 2GIS para iOS.  Hoy habrá una historia sobre cómo apareció nuestro navegador en CarPlay.  Le diré cómo con dicha documentación y herramientas inacabadas creamos un producto que funciona y lo colocamos en la AppStore. </p><a name="habracut"></a><br><h2 id="para-slov-o-carplay">  Algunas palabras sobre CarPlay </h2><br><p><img src="https://habrastorage.org/webt/hq/vu/xw/hqvuxwo3ms1ivfppuaojrfscvh0.jpeg"></p><br><p>  Primero, un pequeño material para comprender algunos aspectos de CarPlay y las razones por las que tomamos ciertas decisiones. </p><br><p>  CarPlay no es un sistema operativo dentro de otro sistema operativo, ya que muchos artículos escriben sobre él.  En términos generales, CarPlay es un protocolo para trabajar con una pantalla externa de la pantalla de la unidad principal;  sonido de los altavoces del automóvil;  pantallas táctiles, paneles táctiles, arandelas y otros dispositivos de entrada. </p><br><p>  Es decir, todo el código ejecutable se encuentra directamente en la aplicación principal (¡ni siquiera en una extensión separada!) Esto es muy bueno: para obtener nuevas funciones, no necesita actualizar la radio o incluso la máquina, solo necesita actualizar iOS. </p><br><p> En WWDC 2018 Keynote, se nos presentó la oportunidad de crear aplicaciones de navegación para CarPlay, lo que nos hizo muy felices.  Inmediatamente después de la presentación, enviamos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitud</a> de permiso para desarrollar para CarPlay.  En la solicitud, fue necesario demostrar que nuestra aplicación es capaz de navegar. </p><br><p>  Mientras esperábamos una respuesta de Apple, hubo una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia</a> en la que, utilizando la aplicación de ejemplo CountryRoads, hablamos sobre trabajar con CarPlay.framework.  La conferencia no habló sobre las trampas y sutilezas al trabajar con CarPlay, pero mencionó que después de conectarse a la radio CarPlay, la aplicación funcionará en modo de fondo. </p><br><h2 id="pervaya-palka-v-kolyosa">  Primer palo en las ruedas </h2><br><p>  La aplicación en el fondo nos decepcionó.  Había dos razones para esto: </p><br><ol><li>  No trabajamos en segundo plano.  Una vez abandonada esta limitación por razones técnicas y para la conservación de energía. </li><li>  Nuestro mapa está escrito en OpenGL (sí, en desuso, sí, no en Metal, todos lo sabemos), y OpenGL en segundo plano no funciona.  En el mejor de los casos, se obtiene una vista en negro y, en el peor, se bloquea. </li></ol><br><p>  Todavía era posible hacer frente al trabajo en segundo plano, pero la tarjeta definitivamente necesitaba ser resuelta.  Entonces surgió la idea de pasar por el estándar MKMapView.  Hasta que comenzaste a arrojarnos piedras por la idea de usar tarjetas Apple estándar, explicaré: íbamos a usar MKMapView, pero no las tarjetas Apple. </p><br><p>  El hecho es que MKMapView puede cargar mosaicos de terceros.  Las baldosas son contenedores rectangulares especiales para texturas.  Acabamos de ser un servochka que sabe dar azulejos.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código de</a> implementación en GitHub. </p><br><h2 id="otvet-ot-apple">  Respuesta de Apple </h2><br><p> Recibimos una respuesta de Apple, en la que, además del permiso para desarrollar, también recibimos documentación "para la élite", el código de la aplicación de ejemplo CountryRoads (se mostró en la conferencia WWDC) y, lo más importante, la clave de capacidad privada <code>com.apple.developer.carplay-maps</code> .  Esta clave está escrita en el archivo de derechos con el valor YES, para que el sistema comprenda que puede procesar eventos desde CarPlay cuando se inicia su aplicación. </p><br><p>  Sin esperar el sprint con las historias seleccionadas para el desarrollo, subí para descargar Xcode Beta.  El primer intento de recolectar 2GIS fue un fracaso.  Pero el proyecto de aplicación de muestra CoutryRoads pudo ensamblarse para el simulador. </p><br><p>  Antes de cada apertura de la ventana del simulador CarPlay, esta última tenía que personalizarse a través de dicha ventana: </p><br><p><img src="https://habrastorage.org/webt/3p/xn/rf/3pxnrf5dlvtq7n8qkuovquqgbbi.png"></p><br><p>  Para hacer esto, tenía que escribir una línea en la terminal: por <code>defaults write com.apple.iphonesimulator CarPlayExtraOptions -bool YES</code> </p><br><p>  Por alguna razón, esto no funcionó: tuve que ejecutarlo en casi el simulador más pequeño con una resolución de 800 × 480 puntos y una escala × 2.  Por el momento, esta configuración funciona y ayuda mucho. </p><br><p>  Habiendo creado mi proyecto de muestra y armado con documentación, comencé a entender lo que estaba sucediendo. <br>  Lo primero que me di cuenta: las aplicaciones de navegación para CarPlay consisten en vista base y capas de plantillas. </p><br><p><img src="https://habrastorage.org/webt/hf/t2/rw/hft2rwp8m2d71popp3tus4dif20.jpeg"></p><br><p>  La vista base es tu mapa.  En esta capa solo debe haber un mapa, no otras vistas y controles. </p><br><p>  Las plantillas son un conjunto obligatorio casi no personalizable de elementos de la interfaz de usuario para mostrar rutas, maniobras, todo tipo de listas, etc. </p><br><h2 id="razrabotka-bety">  Desarrollo beta </h2><br><p>  Pasemos a escribir código.  Lo primero que debe hacer es implementar un par de métodos CPApplicationDelegate necesarios en el archivo ApplicationDelegate. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didConnectCarInterfaceController controller: CPInterfaceController, to window: CPWindow )</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didDisconnectCarInterfaceController controller: CPInterfaceController, from window: CPWindow )</span></span></span></span> {}</code> </pre> <br><p>  Veamos la firma: </p><br><p>  Con UIApplication, todo está claro. <br>  CPWindow es el sucesor de UIWindow, una ventana para la pantalla externa de la unidad principal de la radio. <br>  CPInterfaceController: algo así como un análogo de UINavigationController, solo de CarPlay.framework. </p><br><p>  Ahora procedemos directamente a la implementación del método. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didConnectCarInterfaceController controller: CPInterfaceController, to window: CPWindow )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> carMapViewController = <span class="hljs-type"><span class="hljs-type">CarMapViewController</span></span>( interfaceController: controller ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigationController = <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>( rootViewController: carMapViewController ) window.rootViewController = navigationController }</code> </pre> <br><p>  En didConnect, debe escribir un código similar al que solíamos ver en didFinishLaunching.  CarMapViewController es una vista base (el controlador es en realidad, pero está bien), según la documentación. </p><br><p>  Aquí está la foto que finalmente obtuve: </p><br><p><img src="https://habrastorage.org/webt/vv/l1/xx/vvl1xxebjbdb9ahiuucw1db_rzg.png"></p><br><p>  En algún momento en este momento, me di cuenta de que el nuevo sistema de compilación Xcode está habilitado de manera predeterminada y, muy probablemente, debido a esto, 2GIS no lo hará. </p><br><p>  Abrí Xcode, instalé el sistema de construcción heredado (o más bien estable, llamémoslo por su nombre), y mi teoría fue confirmada: se ensambló 2GIS. </p><br><p>  Después de configurar la misma clave de capacidad, inicié 2GIS en CarPlay y no vi ningún registro sobre el cambio de la aplicación al modo de fondo.  Se volvió aún más incomprensible, porque los ingenieros de Apple de la escena dijeron sobre el modo de fondo, pero, por otro lado, nos prometieron un contentView de UIAlertView, y como resultado, UIAlertView quedó en desuso. </p><br><p>  Habiendo decidido que debería ser así, no me molesté con MKMapView.  Nos privaría de la conexión y nos haría reescribir la representación de las rutas. </p><br><h2 id="problema-odnoy-karty">  Problema de tarjeta individual </h2><br><p>  No tuve tiempo de alegrarme por la noticia de que CarPlay tendrá nuestro mapa, ya que el siguiente problema me enfrentó: debido a las características técnicas, solo puede haber un mapa. <br>  Una solución rápida a este problema fue, aunque no muy elegante. </p><br><p>  Por lo general, cuando usa 2GIS en CarPlay, el teléfono está bloqueado y se encuentra en algún lugar del estante.  Por lo tanto, el mapa en este momento en el teléfono no es realmente necesario (no hará daño buscar, por supuesto).  Por lo tanto, cuando conectamos el teléfono a CarPlay, decidimos tomar la tarjeta de la aplicación principal y mostrarla en la pantalla CarPlay de la radio.  Y cuando esté desconectado, respectivamente, regrese a la aplicación en el teléfono. </p><br><p>  Sí, es una solución en sí misma, pero es rápida, todavía funciona y no tuvo que patear un par de otros comandos para remachar MVP. </p><br><h2 id="kontroly-na-karte">  Controles en el mapa </h2><br><p>  Entonces, tenemos nuestro mapa en la pantalla de la radio.  Ahora era necesario hacer lo primero y obvio para cualquier mapa: controles de zoom, ubicación actual y movimiento del mapa. </p><br><p><img src="https://habrastorage.org/webt/c2/ql/u8/c2qlu8wi-sbkh5zizb7mjab-n7w.png"></p><br><p>  Comencemos con el zoom y la ubicación actual, porque estos controles están ubicados en el mapa y no son UIControl ordinarios.  Como escribí anteriormente, solo el mapa está en la vista base. </p><br><p>  Para colocar estos controles en la tarjeta, tuve que volver a la documentación y la aplicación de muestra nuevamente.  Allí leí sobre la primera plantilla: CPMapTemplate. </p><br><p><img src="https://habrastorage.org/webt/5d/xn/26/5dxn263mlspdif8eqhxgc8wjgmc.png"></p><br><p>  CPMapTemplate: una plantilla transparente para mostrar algunos controles en el mapa y análogos de la barra de navegación.  Se crea y configura de esta manera: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapTemplate = <span class="hljs-type"><span class="hljs-type">CPMapTemplate</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.setRootTemplate(mapTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  A continuación, debe crear estos controles y colocarlos en la tarjeta. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomInButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomOutButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myLocationButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.mapButtons = [ zoomInButton, zoomOutButton, myLocationButton ]</code> </pre> <br><p>  Pero la matriz mapButtons resultó ser divertida, porque no importa cuántos elementos coloque en ella, solo tomará los primeros tres elementos y los mostrará en la pantalla.  No recibirá ningún error en el registro o aserciones. </p><br><p>  Luego pude ver cómo puedo hacer que el mapa se mueva, y encontré esto en la documentación: </p><br><pre> <code class="plaintext hljs">Navigation apps are designed to work with a variety of car input devices, and CarPlay does not support direct user interaction in the base view (apps do not directly receive tap or drag events).</code> </pre> <br><p>  Extraño, pensé, y pude ver cómo se hace esto en la aplicación de ejemplo CountryRoads.  La respuesta es a través de esta interfaz: </p><br><p><img src="https://habrastorage.org/webt/o0/wa/v6/o0wav6ogb8ofbx7-xqxsamjd6g4.png"></p><br><p>  No es muy conveniente, pero de otra manera, la documentación no mentirá, ¿verdad? </p><br><p>  Como el lugar para los controles en el mapa se había agotado, era necesario hacer un botón para poner el mapa en el modo "arrastrar" en este análogo de la barra de navegación. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> panButton = <span class="hljs-type"><span class="hljs-type">CPBarButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.leadingNavigationBarButtons = [panButton] <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.trailingNavigationBarButtons = []</code> </pre> <br><p>  Pero las matrices de LeadingNavigationBarButtons y trailingNavigationBarButtons, también, no estuvieron exentas de una broma: cuántos elementos empujan, tomarán solo los dos primeros.  También sin errores en el registro y aserciones. </p><br><p>  Y para activar y desactivar el modo de arrastrar y soltar de la tarjeta, debe escribir: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.showPanningInterface(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.dismissPanningInterface(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><h2 id="postroenie-i-otobrazhenie-marshrutov-na-karte">  Crear y mostrar rutas en un mapa </h2><br><p>  Luego, comencé a reutilizar nuestra API existente para construir rutas. </p><br><p>  Solo para una demostración y entender qué y cómo hacer, decidí tomar dos puntos y construir una ruta entre ellos.  El punto A era la ubicación del usuario, y el punto B era nuestra oficina principal en Novosibirsk. </p><br><div class="spoiler">  <b class="spoiler_title">Código</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> choice0 = <span class="hljs-type"><span class="hljs-type">CPRouteChoice</span></span>( summaryVariants: [<span class="hljs-string"><span class="hljs-string">"46 "</span></span>], additionalInformationVariants: [<span class="hljs-string"><span class="hljs-string">"  "</span></span>], selectionSummaryVariants: [<span class="hljs-string"><span class="hljs-string">"1  7 "</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> choice1 = <span class="hljs-type"><span class="hljs-type">CPRouteChoice</span></span>( summaryVariants: [<span class="hljs-string"><span class="hljs-string">"46 "</span></span>], additionalInformationVariants: [<span class="hljs-string"><span class="hljs-string">"  "</span></span>], selectionSummaryVariants: [“<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-string"><span class="hljs-string">"] ) let startItem = MKMapItem(…) let endItem = MKMapItem(…) endItem.name = "</span></span>,  ” <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> trip = <span class="hljs-type"><span class="hljs-type">CPTrip</span></span>( origin: startItem, destination: endItem, routeChoices: [choice0, choice1] ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tripPreviewTextConfiguration = <span class="hljs-type"><span class="hljs-type">CPTripPreviewTextConfiguration</span></span>( startButtonTitle: <span class="hljs-string"><span class="hljs-string">" ”, additionalRoutesButtonTitle: “”, overviewButtonTitle: "</span></span><span class="hljs-string"><span class="hljs-string">" ) self.mapTemplate.showTripPreviews( [trip], textConfiguration: tripPreviewTextConfiguration )</span></span></code> </pre> </div></div><br><p>  En la pantalla tenemos un control con una descripción de la ruta: </p><br><p><img src="https://habrastorage.org/webt/wi/on/5r/wion5rbc8wx75tqwxzn-x72zsqw.png"></p><br><h2 id="rezhim-navigacii">  Modo de navegación </h2><br><p>  Las rutas son buenas, pero la característica principal del navegador es la navegación.  Para que aparezca, debe escribir lo siguiente: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mapTemplate: CPMapTemplate, startedTrip trip: CPTrip, using routeChoice: CPRouteChoice )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.startNavigationSession(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: trip) }</code> </pre> <br><p>  CPNavigationSession: una clase con la que puede mostrar algunos elementos de la interfaz de usuario que solo son necesarios en el modo de navegación. </p><br><p>  Para mostrar la maniobra, debe: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maneuver = <span class="hljs-type"><span class="hljs-type">CPManeuver</span></span>() maneuver.symbolSet = <span class="hljs-type"><span class="hljs-type">CPImageSet</span></span>( lightContentImage: icon, darkContentImage: darkIcon ) maneuver.instructionVariants = [<span class="hljs-string"><span class="hljs-string">". "</span></span>] maneuver.initialTravelEstimates = <span class="hljs-type"><span class="hljs-type">CPTravelEstimates</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession?.upcomingManeuvers = [maneuver]</code> </pre> <br><p>  Luego en la pantalla de la radio obtenemos esto: </p><br><p><img src="https://habrastorage.org/webt/30/uj/tp/30ujtpqhaaqkgx1oon7mjxpxiq8.png"></p><br><p>  Para actualizar las imágenes a maniobrar, debe: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> estimates = <span class="hljs-type"><span class="hljs-type">CPTravelEstimates</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession?.updateEstimates(estimates, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: maneuver)</code> </pre> <br><h2 id="it-just-works">  ¡Simplemente funciona! </h2><br><p>  Cuando la funcionalidad básica para el navegador estaba lista, decidí mostrar este arte en una presentación interna.  La presentación fue un éxito: todos tuvieron la idea de completar, probar y lanzar el navegador lo antes posible. </p><br><p>  En primer lugar, pedimos una unidad principal real con soporte CarPlay.  Y luego, como dicen, comenzó el calor. </p><br><p><img src="https://habrastorage.org/webt/wz/2-/cj/wz2-cjj1rusmnd270gkr5h8tdj0.jpeg" alt="PIONEER AVH-Z500BT"></p><br><h3 id="provision-profiles">  Perfiles de provisión </h3><br><p>  Debido a la adición de una nueva clave de capacidad, los perfiles deben regenerarse.  En el desarrollo normal, no pensamos en ello, porque Xcode hará todo por sí mismo.  Pero no en el caso de una clave privada. </p><br><pre> <code class="plaintext hljs">Code Signing Error: Automatic signing is unable to resolve an issue with the "v4ios" target's entitlements. Automatic signing can't add the com.apple.developer.carplay-maps entitlement to your provisioning profile. Switch to manual signing and resolve the issue by downloading a matching provisioning profile from the developer website.</code> </pre> <br><p>  También rompió nuestro CI, porque para la distribución local de versiones de aplicaciones usamos una cuenta empresarial, en la que no solicitamos permiso para desarrollar la aplicación para CarPlay.  Pero esta es una historia completamente diferente. </p><br><h3 id="debugging">  Depuración </h3><br><p>  Puede conectarse a CarPlay a través de Bluetooth o Lightning.  La práctica muestra que el segundo método es mucho más popular.  Nuestra radio en Bluetooth no sabía cómo, así que durante el desarrollo tuve que usar la depuración de Wi-Fi.  Si lo probaste en proyectos más difíciles que hello world, entonces sabes qué demonios es. </p><br><div class="spoiler">  <b class="spoiler_title">Y para aquellos que no lo han intentado, les digo:</b> <div class="spoiler_text"><p>  Recogí la aplicación por cable al teléfono, y solo entonces, conectando el teléfono a CarPlay, a través de Wi-Fi, lo cargué al teléfono y lo ejecuté durante varios minutos. <br>  Copiar la aplicación al teléfono fue de aproximadamente 3 minutos, iniciar la aplicación durante aproximadamente un minuto, y solo después de comenzar la parada en los puntos de interrupción fue solo 15 segundos después. </p></div></div><br><p>  Y luego me resultó muy interesante por qué Apple no hizo ningún DevKit (por lo que, a la manera de Apple, simplemente funciona y eso es todo).  No era muy conveniente armar un banco de pruebas sin él.  Hasta ahora, una vez cada dos semanas, algo se cae; hay que recordar de las fotos en qué quedarse.  Es bueno que el administrador, al armar este stand, dijera qué y por qué. </p><br><h2 id="the-best-framework-we-ever-made">  El mejor marco que hemos hecho </h2><br><p>  Al final, cuando todo se ensambló en un dispositivo real, quedó claro que la característica "2GIS for CarPlay" definitivamente sería.  Es hora de hacer belleza. </p><br><h3 id="problemy-s-vyuportom">  Problemas de ventana gráfica </h3><br><p>  Era necesario configurar la ventana gráfica del mapa para dibujar rutas en el área sin controles innecesarios, y no solo en el medio.  En resumen, para que se vea diferente: </p><br><p><img src="https://habrastorage.org/webt/ns/-k/gw/ns-kgwhubcu9cdqybc4nierpkqe.png"></p><br><p>  Y entonces: </p><br><p><img src="https://habrastorage.org/webt/tl/sg/i3/tlsgi347mdeagljpg7i8ojxcjxc.png"></p><br><p>  Esperaba obtener algún tipo de layoutGuide con el área visible actual.  Para que tenga en cuenta la barra de navegación, la vista con la ruta y los controles en el mapa.  De hecho, no obtuve nada.  Todavía no está claro cómo configurar la ventana gráfica, por lo que tenemos un código duro como: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> routeControlsWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.width * <span class="hljs-number"><span class="hljs-number">0.48</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomControlWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.width * <span class="hljs-number"><span class="hljs-number">0.15</span></span></code> </pre> <br><h3 id="postroenie-proezda-ne-tolko-mezhdu-dvumya-tochkami">  Construcción del pasaje no solo entre dos puntos </h3><br><p>  En la primera versión, decidimos tomar nuestro rubricator hecho a través de CPGridTemplate: </p><br><p><img src="https://habrastorage.org/webt/co/ri/ec/coriec6zvpz0pg5uy72kontsmc8.png"></p><br><p>  Favoritos y Casa / Trabajo a través de CPListTemplate. </p><br><p><img src="https://habrastorage.org/webt/mh/iu/le/mhiulexz-l0j4snzfhdx8pvx8pa.png"></p><br><p>  Y búsqueda de teclado a través de CPSearchTemplate: </p><br><p><img src="https://habrastorage.org/webt/gj/jp/co/gjjpcobjxxf3q_u3gdcoscfclda.png"></p><br><p>  No mostraré el código sobre las plantillas, ya que es simple y la documentación está bien escrita (al menos sobre algo). </p><br><div class="spoiler">  <b class="spoiler_title">Sin embargo, vale la pena mencionar qué problemas se descubrieron al trabajar con ellos.</b> <div class="spoiler_text"><p>  CPInterfaceController puede en navegación similar a UIKit.  es decir </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.pushTemplate(listTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.presentTemplate(alertTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  Pero si intenta ejecutar, por ejemplo, CPAlertTemplate, recibirá una afirmación en los registros de que CPAlertTemplate solo puede representarse modalmente. </p><br><p>  No está claro por qué Apple no ocultó la lógica de los tramos bajo el capó sin haber creado una interfaz como: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.showTemplate(listTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  También rompió la capacidad de usar los herederos de CPTemplate, como los controladores en UIKit. </p><br><p>  Cuando intenta, por ejemplo, poner a su heredero en la pila de plantillas, obtiene esto: </p><br><pre> <code class="plaintext hljs">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Unsupported object &lt;YourAwesomeGridTemplate: 0x60000060dce0&gt; &lt;identifier: 6CAC7E3B-FE70-43FC-A8B1-8FC39334A61D, userInfo: (null)&gt; passed to pushTemplate:animated:. Allowed classes: {( CPListTemplate, CPGridTemplate, CPSearchTemplate, CPMapTemplate )}'</code> </pre> </div></div><br><h3 id="testirovanie-i-bagi">  Pruebas y errores </h3><br><p>  Probado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">artemenko-aa</a> .  Uno de los primeros errores que encontró, todavía no podemos solucionarlo. </p><br><p>  El hecho es que cuando desconecta el teléfono de la radio CarPlay, Watchdog nos atrapa esporádicamente, sin explicar la razón.  Incluso syslogs abiertos, nada está claro.  Entonces, si tiene una idea de cómo solucionar o entender la razón, no dude en comentar. </p><br><p>  El siguiente error estaba en el mismo lugar, pero con un comportamiento especial.  Escribí anteriormente que se llama al método didDisconnect de CPApplicationDelegate cuando se desconecta el teléfono de CarPlay.  Y en este método, devolvemos la tarjeta de la pantalla de radio a la aplicación principal.  Imagine cuántos problemas podríamos detectar si este método no se llamara al menos una vez de cada cinco. </p><br><p>  Quedó claro que este es un problema de iOS, y no específicamente de nuestra aplicación, ya que todo el sistema creía que estaba conectado a CarPlay. </p><br><p><img src="https://habrastorage.org/webt/nh/3v/tc/nh3vtc2h-zlu5jutajc6-oyoca4.jpeg"></p><br><p>  Incluso lo informé como radar (como todos los demás errores).  Me pidieron que soltara registros con ese perfil, pero no pude responder al soporte durante algún tiempo, por lo que cerraron el radar. </p><br><p>  Como Apple no planeaba hacer nada, el problema tuvo que ser evitado por sí solo, ya que se reproducía con bastante frecuencia. </p><br><p>  Y luego recordé que la mayor parte de las conexiones con CarPlay pasa por Lightning.  Esto significa que el teléfono se está cargando en el momento de la conexión, y en el momento de la desconexión, la carga cesa.  Y si es así, puede suscribirse al estado de la batería y averiguar exactamente cuándo el teléfono dejó de cargarse y se desconectó de CarPlay. </p><br><p>  El esquema es frágil, pero no teníamos otra opción.  Fuimos por este camino, y funcionó! </p><br><p><img src="https://habrastorage.org/webt/ql/1h/j0/ql1hj02fnqottbo5fstubt65pss.jpeg"></p><br><p>  Afortunadamente, esta muleta se ha eliminado por mucho tiempo del código: los desarrolladores de Apple arreglaron todo en una de las versiones de iOS. </p><br><h2 id="istoriya-dvuh-redzhektov">  La historia de dos editores. </h2><br><p>  <strong>La primera redirección</strong> estaba relacionada con los metadatos.  El texto del editorial dice que nuestra descripción (no las notas de la versión) no dice que admitamos CarPlay.  Como puede adivinar, ni la guía de revisión, ni el mismo Google Maps tenían esto.  No discutimos (porque generalmente es más largo que editar los metadatos), copiamos la línea de las Notas de la versión a la Descripción y comenzamos a esperar una nueva revisión. </p><br><p>  <strong>El segundo proyecto</strong> ocurrió debido a la lista de ciudades.  2GIS tiene una característica muy interesante: modo de operación fuera de línea completo.  Esta característica nos disparó en la pierna. </p><br><p>  Al conectar una aplicación sin una ciudad establecida a CarPlay, no mostramos el mapa, porque no hay nada que mostrar.  Y para esto estábamos programados.  La solución fue simple: una alerta sin botones, que dice que necesitas descargar la ciudad. </p><br><p><img src="https://habrastorage.org/webt/uf/t7/rx/uft7rxuuaqu7ape9ehifdi6r6ki.png"></p><br><h2 id="to-o-chyom-nelzya-govorit">  De qué no puedes hablar </h2><br><h3 id="peremeschenie-karty-zhestami">  Movimiento de mapa de gestos </h3><br><p>  Casi al mismo tiempo, salió el navegador bajo CarPlay de Google Maps, y allí puedes mover el mapa con gestos por la pantalla.  API privadas, pensé, ¡esto es obvio!  Los chicos de Google acaban de llegar de un edificio cercano y dijeron lo que necesitaban.  Después de todo, la documentación dice: </p><br><pre> <code class="plaintext hljs">Navigation apps are designed to work with a variety of car input devices, and CarPlay does not support direct user interaction in the base view (apps do not directly receive tap or drag events).</code> </pre> <br><p>  Sin embargo, todavía decidí asegurarme y busqué en Google, aunque era casi inútil, porque no había artículos técnicos sobre CarPlay Navigation Apps.  Sin embargo, logré encontrar algo útil y, DE repente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web de Apple</a> . </p><br><p>  En las pautas encontré un video que dice que la documentación está mintiendo descaradamente.  El video muestra cómo aún puede arrastrar el mapa con gestos.  Me di cuenta de que no entendía nada, y lo único que me quedaba era abrir CarPlay.framework y revisar todos los archivos .h. </p><br><p>  ¡Y he aquí!  Encuentro en CPMapTemplate su delegado CPMapTemplateDelegate, en el que hay 3 métodos que parecen gritar que si los implementa, puede obtener el control de los gestos del mapa. </p><br><div class="spoiler">  <b class="spoiler_title">3 métodos</b> <div class="spoiler_text"><p>  / * Se <em>llama cuando comienza un gesto panorámico.</em>  <em>No se puede llamar cuando está conectado a algunos sistemas CarPlay.</em> <em><br></em>  / / <br>  función pública opcional mapTemplateDidBeginPanGesture (_ mapTemplate: CPMapTemplate) </p><br><p>  / * Se <em>llama cuando cambia un gesto de desplazamiento.</em>  <em>No se puede llamar cuando está conectado a algunos sistemas CarPlay.</em> <em><br></em>  / / <br>  función pública opcional mapTemplate (_ mapTemplate: CPMapTemplate, didUpdatePanGestureWith Traducción de traducción: CGPoint, velocidad: CGPoint) </p><br><p>  / * Se <em>llama cuando finaliza un gesto de desplazamiento.</em>  <em>No se puede llamar cuando está conectado a algunos sistemas CarPlay.</em> <em><br></em>  / / <br>  función pública opcional mapTemplate (_ mapTemplate: CPMapTemplate, didEndPanGestureWithVelocity velocidad: CGPoint <br>  ) </p></div></div><br><p>  Los implementé y ejecuté la aplicación en un simulador, nada funcionó.  Al no tener tiempo para estar molesto, me di cuenta de que el simulador puede ser de la misma calidad que la documentación y lo puse en el dispositivo.  ¡Todo comenzó, la felicidad no conocía límites! </p><br><p>  Dato curioso: una radio CarPlay necesita una cuarta parte de la pantalla para comprender que ha comenzado un gesto panorámico.  Quiero señalar que UIPanGestureRecognizer solo necesita 10 puntos. </p><br><h3 id="neodinakovost-ui-na-raznyh-magnitolah">  Uniformidad de IU en diferentes grabadoras de radio </h3><br><p>  Recibimos una apelación de soporte: el usuario solo tiene un rastreo más seguro en la búsqueda, aunque podría haber habido más.  Pensé que es extraño, porque en todas las pantallas solo cabe una línea.  Han solicitado una captura de pantalla: </p><br><p><img src="https://habrastorage.org/webt/_t/k7/u6/_tk7u6wbcv55zig2n-b1dlbm9hu.png"></p><br><p>  Y esto es completamente diferente de la interfaz de usuario de CPSearchTemplate que mostré arriba.  Y esto debe tenerse en cuenta durante el desarrollo, aunque todavía es imposible entender cuántas células en la placa de abajo pueden caber en la pantalla. </p><br><h3 id="kontrol-ogranicheniya-skorosti">  Control de límite de velocidad </h3><br><p>  Observamos las estadísticas y nos dimos cuenta de que usan el navegador para CarPlay y necesitamos llevarlo al menos al nivel del navegador en la aplicación principal.  En primer lugar, decidimos agregar control de límite de velocidad.  Por supuesto, hubo algunos problemas. </p><br><p>  Pregunta número uno: ¿dónde colocar? </p><br><p>  Revolviendo los archivos .h en CPWindow nuevamente, encontré un curioso diseño: <br>  var mapButtonSafeAreaLayoutGuide: UILayoutGuide </p><br><p>  Y eso resultó ser lo que necesitábamos.  Nuestro control encaja perfectamente: </p><br><p><img src="https://habrastorage.org/webt/vo/m7/qw/vom7qwpkpnxqf9a7wk6arc8-gtm.png"></p><br><p><img src="https://habrastorage.org/webt/q7/kq/fh/q7kqfhk7rrtwdzmergpd9yobbz0.png"></p><br><p>  Pregunta número dos: ¿esto es generalmente legal? </p><br><p>  El hecho es que técnicamente el control está en la vista base.  Y la vista base de acuerdo con la documentación no puede contener nada excepto un mapa: </p><br><pre> <code class="plaintext hljs">The base view is where the map is drawn. The base view must be used exclusively to draw a map, and may not be used to display other UI elements. Instead, navigation apps overlay UI elements such as the navigation bar and map buttons using the provided templates.</code> </pre> <br><p>  Pero los revisores nos extrañaron en la AppStore, lo que significa que los controles relacionados con la navegación aún pueden integrarse. </p><br><h3 id="golosovoy-poisk">  Búsqueda por voz </h3><br><p><img src="https://habrastorage.org/webt/di/tt/ov/dittovwssqwrbku8rfd7fxpqlqo.png"></p><br><p><img src="https://habrastorage.org/webt/td/co/z-/tdcoz-1fk1-x880os0muqc_2iso.png"></p><br><p>  En el buen sentido, esta función tenía que hacerse antes que nada, pero hemos acumulado varias tareas de la deuda técnica que impidieron la implementación de la búsqueda por voz de CarPlay.  Y esta tarea no fue tan simple como parecía. </p><br><p>  <strong>El primer problema: animaciones.</strong>  El hecho es que en CPVoiceControlTemplate no hay forma de hacer animaciones estándar.  La animación para el reconocimiento de voz y la búsqueda se tuvo que recopilar cuadro por cuadro de las imágenes e indicar cuánto tiempo pasaron. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">12</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"carplay_searching_\(i)"</span></span>) { images.append(image) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>.animatedImage(with: images, duration: <span class="hljs-number"><span class="hljs-number">0.96</span></span>)</code> </pre> <br><p>  Parece, como puede suponer, no realmente, pero no quiero inflar el tamaño de la aplicación. </p><br><p>  <strong>El segundo problema: accesos.</strong>  Las alertas para el acceso al micrófono y el reconocimiento de voz aparecen en la pantalla del teléfono.  Tuve que escribir en la pantalla de la radio que el usuario necesita levantar el teléfono, dar permiso y solo luego usar el navegador en la radio.  Muy comodo! </p><br><h3 id="pravorulnye-avtomobili">  Coches con volante a la derecha. </h3><br><p>  ¡Nos enviaron una captura de pantalla en la que la interfaz de usuario de toda la aplicación estaba al revés! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e5c/b97/dc2/e5cb97dc248ebb9ffa0ff46147c290d7.jpg"></p><br><p>  Y, por supuesto, la ventana gráfica del mapa siguió siendo la forma en que la codificamos, porque nadie esperaba que hubiera una configuración separada para los automóviles con volante a la derecha.  No encontré cómo solucionar esto "correctamente", pero noté que, dado que nuestro control de límite de velocidad se encuentra en la Guía de diseño para los controles de mapa, se movió hacia el lado izquierdo. </p><br><p>  Ultrafix no tardó en llegar.  Lo hicieron groseramente, pero funciona. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isLeftWheelCar = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.speedControlViewController.view.frame.origin.x &gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.size.width / <span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Realmente espero que haya una solución correcta, y simplemente no la leí. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso es todo para mí. </font><font style="vertical-align: inherit;">Si de repente planea crear su propio navegador en CarPlay, tenga en cuenta que la documentación y el marco son imperfectos. </font><font style="vertical-align: inherit;">La plataforma es completamente nueva, nadie sabe nada y Apple no tiene prisa por compartir conocimientos.</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452638/">https://habr.com/ru/post/452638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452620/index.html">Derivar un tipo de acción usando el mecanografiado</a></li>
<li><a href="../452622/index.html">Introducción a la genómica para programadores</a></li>
<li><a href="../452624/index.html">Introducción al actuador Spring Boot</a></li>
<li><a href="../452628/index.html">Hoja inferior personalizada: cómo debería funcionar</a></li>
<li><a href="../452630/index.html">Copia de seguridad, Parte 2: Descripción general y prueba de herramientas de copia de seguridad basadas en rsync</a></li>
<li><a href="../452642/index.html">La fuerza de la multitud. Cómo Chicago desarrolló un robot de basura: un limpiador de ríos</a></li>
<li><a href="../452644/index.html">Conferencia de desarrolladores web DevConf X - 21 de junio</a></li>
<li><a href="../452646/index.html">Lo que vio la red neuronal en la primera fotografía de un agujero negro</a></li>
<li><a href="../452648/index.html">PHP: cómo analizar un archivo XML complejo y no ahogarse en código nativo</a></li>
<li><a href="../452652/index.html">Semana de la seguridad 21: un agujero en Whatsapp, una nueva vulnerabilidad en los procesadores Intel, Zero-Day en Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>