<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’† ğŸ‘¨ğŸ»â€ğŸ­ ğŸ‘§ğŸ¾ Ruang Rapat LÌ¶iÌ¶tÌ¶tÌ¶lÌ¶eÌ¶ Helper v 2 ğŸ‘ğŸ¼ ğŸ˜± ğŸ¤ŸğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan secara terperinci tahapan pengembangan aplikasi mobile Meeting Room Helper: dari awal ide hingga rilis. Aplikasi ini ditulis d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ruang Rapat LÌ¶iÌ¶tÌ¶tÌ¶lÌ¶eÌ¶ Helper v 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/457960/">  Artikel ini menjelaskan secara terperinci tahapan pengembangan aplikasi mobile Meeting Room Helper: dari awal ide hingga rilis.  Aplikasi ini ditulis dalam Kotlin dan dibangun di atas arsitektur MVVM yang disederhanakan, tanpa menggunakan pengikatan data.  Bagian UI diperbarui menggunakan objek LiveData.  Alasan penolakan pengikatan data dirinci dan dijelaskan.  Arsitektur menggunakan sejumlah solusi menarik yang memungkinkan untuk secara logis membagi program menjadi file-file kecil, yang pada akhirnya menyederhanakan dukungan kode. <br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><img src="https://habrastorage.org/webt/ii/at/pf/iiatpf_m3syq_8mzu08bkaqiy4u.jpeg"><br><a name="habracut"></a><br><h2>  Deskripsi Proyek </h2><br>  3 tahun yang lalu, perusahaan kami datang dengan ide untuk mengembangkan proyek kecil untuk pemesanan instan ruang pertemuan.  Sebagian besar manajer SDM dan Arcadia lebih suka menggunakan kalender Outlook untuk tujuan seperti itu, tetapi bagaimana dengan yang lain? <br><br>  Saya akan memberikan 2 contoh dari kehidupan pengembang <br><br><ol><li>  <i>Setiap tim secara berkala memiliki keinginan spontan untuk mengadakan reli cepat selama 5-10 menit.</i>  <i>Keinginan ini dapat menyalip pengembang di sudut kantor mana pun, dan agar tidak mengganggu kolega di sekitar mereka, mereka (pengembang dan bukan hanya) mulai mencari percakapan gratis.</i>  <i>Bermigrasi dari kamar ke kamar (di kantor kami, ruang pertemuan diatur secara berurutan), kolega â€œmemeriksa dengan cermatâ€ kamar mana yang saat ini gratis.</i>  <i>Akibatnya, mereka mengalihkan perhatian rekan kerja di dalam.</i>  <i>Orang-orang seperti itu selalu dan akan selalu ada, bahkan jika eksekusi harus ditembak dalam piagam perusahaan untuk gangguan reli.</i>  <i>Siapa yang mengerti, dia akan mengerti.</i> </li><li>  <i>Dan di sini ada kasus lain.</i>  <i>Anda baru saja meninggalkan ruang makan dan menuju ke diri Anda sendiri, tetapi di sini kolega Anda (atau manajer) dari departemen lain mencegat Anda.</i>  <i>Dia ingin memberi tahu Anda sesuatu yang mendesak, dan untuk keperluan ini Anda perlu ruang rapat.</i>  <i>Menurut peraturan, pertama-tama Anda harus memesan kamar (dari ponsel atau komputer) dan baru kemudian menempatinya.</i>  <i>Baik jika Anda memiliki ponsel dengan Outlook seluler.</i>  <i>Dan jika tidak?</i>  <i>Kembali ke komputer, lalu kembali ke ruang rapat?</i>  <i>Untuk memaksa setiap karyawan meletakkan Outlook Express di telepon dan memastikan semua orang membawa telepon?</i>  <i>Ini bukan metode kami.</i> </li></ol><br>  Itulah sebabnya 2,5 tahun yang lalu masing-masing ruang pertemuan dilengkapi dengan tabletnya sendiri: <br><br><img src="https://habrastorage.org/webt/kp/2i/ao/kp2iao0nromcb1wa-iewgzxurw0.png"><br><br>  Untuk proyek ini, kolega saya mengembangkan versi pertama aplikasi: Ruang Rapat Pembantu Kecil (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini Anda dapat membacanya</a> ).  MRLH diizinkan memesan reservasi, membatalkan, dan memperbarui reservasi, menunjukkan status percakapan yang tersisa.  Mengenali identitas karyawan (menggunakan layanan cloud Microsoft Face API dan analis internal kami) telah menjadi â€œtrikâ€ inovatif.  Aplikasi itu ternyata solid dan melayani perusahaan dengan setia selama 2,5 tahun. <br><br>  Tetapi waktu berlalu ... Gagasan baru muncul.  Saya ingin sesuatu yang baru, jadi kami memutuskan untuk menulis ulang aplikasi. <br><br><h3>  Kerangka Acuan </h3><br>  Seperti yang sering terjadi - tetapi, sayangnya, tidak selalu - pengembangan dimulai dengan persiapan spesifikasi teknis.  Pertama-tama, kami memanggil orang-orang yang paling sering menggunakan tablet untuk pemesanan.  Kebetulan bahwa sebagian besar dari mereka kecanduan SDM dan manajer yang sebelumnya menggunakan Outlook secara eksklusif.  Dari mereka, kami menerima umpan balik berikut (dari persyaratan segera jelas apa yang diminta SDM dan apa yang diminta manajer): <br><br><ul><li>  Anda harus menambahkan kemampuan untuk memesan ruang rapat apa pun dari tablet apa pun (sebelumnya, setiap tablet hanya mengizinkan Anda memesan kamar); </li><li>  alangkah baiknya untuk melihat jadwal rapat umum untuk pertemuan sepanjang hari (idealnya, untuk hari apa pun); </li><li>  seluruh siklus pengembangan harus dilakukan dalam waktu singkat (selama 6-7 minggu). </li></ul><br>  Semuanya jelas dengan keinginan pelanggan, tetapi bagaimana dengan persyaratan teknis dan masa depan?  Tambahkan beberapa persyaratan untuk proyek dari guild pengembang: <br><br><ul><li>  Sistem harus bekerja baik dengan tablet yang ada, dan dengan yang baru; </li><li>  skalabilitas sistem - dari 50 percakapan ke atas (ini harus cukup dengan margin bagi sebagian besar pelanggan jika sistem mulai mereplikasi); </li><li>  mempertahankan fungsionalitas sebelumnya (versi pertama aplikasi menggunakan Java API untuk berkomunikasi dengan layanan Outlook, dan kami berencana untuk menggantinya dengan Microsoft Graph API khusus, jadi penting untuk tidak kehilangan fungsionalitas); </li><li>  meminimalkan konsumsi energi (tablet didukung oleh baterai eksternal, karena pusat bisnis tidak mengizinkan pengeboran dindingnya untuk memasang kabel kami); </li><li>  desain UX / UI baru, yang secara ergonomis mencerminkan semua inovasi. </li></ul><br>  Total 8 poin.  Persyaratannya cukup adil.  Selain itu, kami menetapkan aturan pengembangan umum: <br><br><ul><li>  gunakan hanya teknologi canggih (ini akan memungkinkan tim untuk berkembang sebagai spesialis dan tidak mandek di satu tempat, sementara menyederhanakan dukungan proyek di masa mendatang); </li><li>  ikuti praktik terbaik, tetapi jangan membabi buta menerima begitu saja, seperti  aturan utama dari setiap profesional (dan pengembang yang berjuang untuk ini) adalah untuk mengevaluasi semuanya secara kritis; </li><li>  Menulis kode yang bersih dan rapi (mungkin ini yang paling sulit ketika Anda mencoba menggabungkan inovasi dan waktu pengembangan yang ketat). </li></ul><br>  Sebuah awal telah dibuat.  Itu, seperti biasa, antusias!  Mari kita lihat apa yang terjadi selanjutnya. <br><br><h3>  Desain </h3><br>  Desain aplikasi yang dikembangkan oleh desainer UX: <br><br><img src="https://habrastorage.org/webt/gm/n9/eo/gmn9eox4exzhczkq0zdbkiwrgt8.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Ini adalah layar utama.  Ini akan ditampilkan sebagian besar waktu.  Semua informasi yang diperlukan berlokasi secara ergonomis di sini: <br><br><ul><li>  nama kamar dan nomornya; </li><li>  status saat ini; </li><li>  waktu sampai pertemuan berikutnya (atau sampai akhir); </li><li>  status kamar yang tersisa di bagian bawah layar. </li></ul><br>  Harap dicatat: dial hanya menampilkan 12 jam, seperti  sistem dikonfigurasikan sesuai dengan kebutuhan perusahaan (tablet Arcadia bekerja dari jam 8 pagi sampai jam 8 malam, nyalakan dan matikan secara otomatis) <br><br><img src="https://habrastorage.org/webt/cg/r_/92/cgr_9220jaeqzpjtu4godm1vojw.gif"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Untuk memesan kamar, cukup hubungi jendela pemesanan dan tentukan durasi rapat umum.  Langkah-langkah untuk memesan kamar yang tersisa serupa, mereka hanya mulai dengan mengklik ikon kamar. <br><br><img src="https://habrastorage.org/webt/d7/qr/wm/d7qrwmogkdzvjtdea0y80vjlti4.jpeg"><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Jika Anda ingin menjadwalkan rapat untuk waktu tertentu, buka tab berikutnya, ke daftar rapat yang akan berlangsung hari ini di ruang rapat, dan klik waktu luang.  Selanjutnya, semuanya seperti dalam kasus pertama. <br><br>  Pohon transisi yang lengkap harus terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/p8/ex/lb/p8exlbbiuflfbasflet3vsepzdu.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Mari kita coba implementasikan secara kompeten. <br><br><h3>  Tumpukan teknologi </h3><br>  Teknik pengembangan berkembang agak cepat dan berubah.  Selama 2 tahun berikutnya, Java adalah bahasa pengembangan Android resmi.  Semua orang menulis di Java dan menggunakan data binding.  Sekarang, menurut saya, kami bergerak menuju pemrograman reaktif dan Kotlin.  Java adalah bahasa yang hebat, tetapi memiliki beberapa ketidaksempurnaan dibandingkan dengan apa yang ditawarkan Kotlin dan AndroidX.  Kotlin dan AndroidX dapat mengurangi penggunaan data yang mengikat hingga minimum, jika tidak sepenuhnya mengecualikannya.  Di bawah ini saya akan mencoba menjelaskan sudut pandang saya. <br><br><h4>  Kotlin </h4><br>  Saya pikir banyak pengembang Android telah beralih ke Kotlin, dan karena itu setuju dengan saya bahwa menulis proyek Android baru pada 2019 dalam bahasa apa pun selain Kotlin seperti berperang di laut.  Tentu saja Anda bisa berdebat, tetapi bagaimana dengan Flutter dan Dart?  Bagaimana dengan C ++, C #, dan bahkan Cordova?  Yang akan saya jawab: pilihan selalu ada di tangan Anda. <br><br>  Pada 480 SM  raja Persia Xerxes memerintahkan tentaranya untuk menyeberangi laut sebagai hukuman karena menghancurkan sebagian pasukannya selama badai, dan lima abad kemudian, kaisar Romawi Caligula menyatakan perang terhadap Poseidon.  Masalah selera.  Untuk 9 dari 10, Kotlin baik, tetapi 10 mungkin buruk.  Itu semua tergantung pada Anda, pada keinginan dan aspirasi Anda. <br><br>  Kotlin adalah pilihanku.  Bahasanya sederhana dan indah.  Menulisnya mudah dan menyenangkan, dan yang paling penting, tidak perlu menulis terlalu banyak: kelas data, objek, setter dan pengambil opsional, ekspresi lambda sederhana dan fungsi ekstensi.  Ini hanya sebagian kecil dari apa yang ditawarkan bahasa ini.  Jika Anda belum beralih ke Kotlin - silakan pergi!  Di bagian latihan, saya akan menunjukkan beberapa kelebihan bahasa (ini bukan tawaran iklan). <br><br><h4>  Model-View-ViewModel </h4><br>  MVVM saat ini adalah arsitektur aplikasi yang direkomendasikan dari Google.  Selama pengembangan, kami akan mematuhi pola khusus ini, namun, kami tidak akan mengamatinya sepenuhnya, karena MVVM merekomendasikan untuk menggunakan pengikatan data, tetapi kami menolaknya. <br><br>  <i><b>Pro dari MVVM</b></i> <br><br><ul><li>  <i>Diferensiasi logika bisnis dan UI.</i>  Dalam implementasi MVVM yang benar, seharusnya tidak ada satu pun impor android di ViewModel, kecuali objek LiveData dari paket AndroidX atau Jetpack.  Penggunaan yang benar secara otomatis meninggalkan semua pekerjaan UI di dalam fragmen dan aktivitas.  Bukankah itu hebat? </li><li>  <i>Tingkat enkapsulasi dipompa.</i>  Akan lebih mudah untuk bekerja sebagai tim: sekarang Anda dapat bekerja bersama di satu layar dan tidak saling mengganggu.  Sementara satu pengembang bekerja dengan layar, yang lain dapat membangun ViewModel, dan yang ketiga dapat menulis kueri di Repositori. </li><li>  <i>MVVM memiliki efek positif pada penulisan unit test.</i>  Item ini mengikuti dari yang sebelumnya.  Jika semua kelas dan metode dirangkum dari bekerja dengan UI, mereka dapat dengan mudah diuji. </li><li>  <i>Solusi alami dengan rotasi layar.</i>  Tidak peduli seberapa aneh kedengarannya, tetapi fitur ini diperoleh secara otomatis, dengan transisi ke MVVM (karena data disimpan dalam ViewModel).  Jika Anda memeriksa aplikasi yang cukup populer (VK, Telegram, Sberbank-Online dan Aviasales), ternyata separuh dari mereka tidak dapat memutar layar.  Yang menyebabkan saya terkejut dan salah paham sebagai pengguna aplikasi ini. </li></ul><br>  <i><b>Mengapa MVVM berbahaya?</b></i> <br><br><ul><li>  <i>Kebocoran memori.</i>  Kesalahan berbahaya ini terjadi jika Anda melanggar hukum menggunakan LiveData dan pengamat.  Kami akan memeriksa kesalahan ini secara rinci di bagian latihan. </li><li>  <i>ViewModel yang luas.</i>  Jika Anda mencoba memasukkan semua logika bisnis ke dalam ViewModel, Anda akan mendapatkan kode yang tidak dapat dibaca.  Jalan keluar dari situasi ini mungkin memecah ViewModel menjadi hierarki, atau menggunakan Penyaji.  Itulah tepatnya yang saya lakukan. </li></ul><br>  <i><b>Aturan untuk bekerja dengan MVVM</b></i> <br><br>  Mari kita mulai dengan kesalahan yang paling banyak dan pergi ke kesalahan yang kurang: <br><br><ul><li>  badan permintaan tidak boleh dalam ViewModel (hanya di Repositori); </li><li>  Objek LiveData didefinisikan dalam ViewModel, karena mereka tidak melemparkan diri ke dalam Repositori, karena  permintaan di Repositori diproses menggunakan Rx-Java (atau coroutines); </li><li>  semua fungsi pemrosesan harus dipindahkan ke kelas dan file pihak ketiga ("Penyaji"), agar tidak mengacaukan ViewModel dan tidak mengalihkan perhatian dari esensi. </li></ul><br><h4>  Livedata </h4><br><blockquote>  LiveData adalah kelas pemegang data yang dapat diamati.  Tidak seperti yang biasa diamati, LiveData sadar akan siklus hidup, yang berarti ia menghormati siklus hidup komponen aplikasi lain, seperti aktivitas, fragmen, atau layanan.  Kesadaran ini memastikan LiveData hanya memperbarui pengamat komponen aplikasi yang dalam keadaan siklus hidup aktif. </blockquote>  <i>Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">developer.android.com/topic/libraries/architecture/livedata</a></i> <br><br>  Kesimpulan sederhana dapat diambil dari definisi: LiveData adalah alat pemrograman reaktif yang andal.  Kami akan menggunakannya untuk memperbarui bagian UI tanpa ikatan data.  Kenapa begitu <br><br>  Struktur file XML tidak memungkinkan distribusi data secara ringkas yang diperoleh dari &lt;data&gt; ... &lt;/data&gt;.  Jika semuanya jelas dengan file kecil, lalu bagaimana dengan file besar?  Apa yang harus dilakukan dengan layar yang kompleks, beberapa termasuk dan melewati beberapa bidang?  Gunakan model di mana-mana?  Dapatkan ikatan bidang yang kaku?  Dan jika bidang tersebut harus diformat, panggil metode dari paket Java?  Ini membuat kode tanpa harapan dan sepenuhnya spageti.  Sama sekali tidak seperti yang dijanjikan MVVM. <br><br>  Menolak pengikatan data akan membuat perubahan pada bagian UI transparan.  Semua pembaruan akan terjadi langsung di dalam pengamat.  Karena  Karena kode Kolin ringkas dan jelas, kami tidak akan mendapatkan masalah dengan pengamat yang membengkak.  Menulis dan memelihara kode akan menjadi lebih mudah.  File XML hanya akan digunakan untuk desain - tidak ada properti di dalamnya. <br><br>  Pengikatan data adalah alat yang ampuh.  Ini bagus untuk menyelesaikan beberapa masalah, dan selaras dengan Java, tetapi dengan Kotlin ... Dengan Kotlin, dalam kebanyakan kasus, pengikatan data hanya bersifat rudimenter.  Pengikatan data hanya memperumit kode dan tidak memberikan keunggulan kompetitif. <br><br>  Di Jawa, Anda punya pilihan: menggunakan pengikatan data, atau menulis banyak kode jelek.  Di Kotlin, Anda dapat mengakses elemen tampilan secara langsung, mem-bypass findViewById (), serta propertinya.  Sebagai contoh: <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Instead of TextView textView = findViewById&lt;TextView&gt;(R.id.textView) textView.text = "Hello, world!" textView.visibility = View.VISIBLE</span></span></code> </pre> <br>  Sebuah pertanyaan logis muncul: mengapa repot-repot dengan model berkebun di dalam file XML, menggunakan metode Java dalam file XML, membebani logika bagian XML jika semua ini bisa dihindari? <br><br><h4>  Coroutines bukannya Thread () dan Rx-Java </h4><br>  Coroutine sangat ringan dan mudah digunakan.  Mereka ideal untuk tugas asinkron yang paling sederhana: memproses hasil permintaan, memperbarui UI, dll. <br><br>  Coroutine dapat secara efektif mengganti Thread () dan Rx-Java dalam kasus di mana kinerja tinggi tidak diperlukan, karena  mereka membayar ringan dengan kecepatan.  Rx-Java, tidak diragukan lagi, lebih fungsional, namun untuk tugas-tugas sederhana semua asetnya tidak diperlukan. <br><br><h4>  Microsoft dan yang lainnya </h4><br>  Untuk bekerja dengan layanan Outlook, Microsoft Graph API akan digunakan.  Dengan izin yang sesuai, Anda dapat memperoleh semua informasi yang diperlukan tentang karyawan, ruang, dan acara (rapat).  Untuk pengenalan wajah, layanan cloud Microsoft Face API akan digunakan. <br><br>  Melihat sedikit ke depan, saya akan mengatakan bahwa untuk memecahkan masalah skalabilitas, Firebase cloud storage digunakan.  Ini akan dibahas di bawah. <br><br><h2>  Arsitektur </h2><br><h3>  Masalah skalabilitas </h3><br>  Sangat sulit untuk membuat sistem terukur sepenuhnya atau sebagian.  Ini sangat sulit dilakukan jika versi pertama aplikasi tidak dapat diskalakan, dan yang kedua harus menjadi.  Aplikasi v1 mengirim permintaan ke semua kamar sekaligus.  Masing-masing tablet secara teratur mengirim permintaan ke server untuk memperbarui semua data.  Pada saat yang sama, perangkat tidak melakukan sinkronisasi satu sama lain, karena  proyek tidak memiliki server sendiri. <br><br>  Tentu saja, jika kita mengikuti jalur yang sama dan mengirim permintaan N dari masing-masing tablet N, maka pada titik tertentu kita akan membatalkan Microsoft Graph API atau mendapatkan pembekuan sistem kami. <br><br>  Adalah logis untuk menggunakan solusi client-server di mana server polling grafik, mengumpulkan data dan, berdasarkan permintaan, memberikan informasi ke tablet, tetapi di sini kita bertemu dengan kenyataan.  Tim proyek terdiri dari 2 orang (pengembang dan perancang Android).  Mereka harus memenuhi tenggat waktu 7 minggu dan backend tidak disediakan, karena  penskalaan adalah persyaratan dari pengembang.  Tetapi ini tidak berarti bahwa ide itu harus ditinggalkan? <br><br>  Mungkin satu-satunya solusi yang tepat dalam situasi ini adalah penggunaan penyimpanan cloud.  Firebase akan mengganti server dan bertindak sebagai penyangga.  Kemudian ternyata yang berikut ini: <i>setiap tablet hanya menyurvei alamatnya dari Microsoft Graph API, dan, jika perlu, menyinkronkan data dalam penyimpanan cloud, dari tempat itu dapat dibaca oleh perangkat lain.</i> <br><br>  Keuntungan dari implementasi ini akan menjadi respons yang cepat, karena  Firebase bekerja dalam mode real-time.  Kami akan mengurangi jumlah permintaan yang dikirim ke server N kali, yang berarti perangkat akan bekerja dengan baterai sedikit lebih lama.  Dari sudut pandang keuangan, proyek tidak naik harga, karena  Untuk proyek ini, versi gratis Firebase sudah cukup dengan beberapa cadangan: penyimpanan 1 GB, 10 ribu otorisasi per bulan dan 100 koneksi sekaligus.  Kerugiannya bisa termasuk ketergantungan pada kerangka kerja pihak ketiga, tetapi Firebase menginspirasi kepercayaan pada kami, karena  Ini adalah produk stabil yang dikelola dan dikembangkan oleh Google. <br><br>  Gagasan umum sistem baru adalah sebagai berikut: N tablet dan platform cloud untuk sinkronisasi data waktu-nyata.  Mari kita mulai merancang aplikasi itu sendiri. <br><br><h4>  LiveData di Repositori </h4><br>  Tampaknya saya baru-baru ini menetapkan aturan bentuk yang baik dan segera melanggar salah satunya.  Tidak seperti penggunaan LiveData yang direkomendasikan di dalam ViewModel, dalam proyek ini objek LiveData diinisialisasi ke repositori, dan semua repositori dinyatakan sebagai singleton.  Kenapa begitu <br><br>  Solusi serupa dikaitkan dengan mode aplikasi.  Tablet buka dari jam 8 pagi sampai 8 malam.  Selama ini, hanya Helper Ruang Rapat yang diluncurkan pada mereka.  Akibatnya, banyak objek dapat dan harus berumur panjang (itulah sebabnya semua repositori dirancang sebagai singleton). <br><br>  Selama bekerja, konten UI secara teratur beralih, yang pada gilirannya memerlukan pembuatan dan rekreasi objek ViewModel.  Ternyata jika Anda menggunakan LiveData di dalam ViewModel, maka untuk setiap fragmen yang dibuat, ViewModel sendiri akan dibuat dengan sekumpulan objek LiveData yang ditentukan.  Jika 2 fragmen serupa ditampilkan secara bersamaan di layar, dengan ViewModel dan Base-ViewModel yang sama, maka selama inisialisasi akan ada duplikasi objek LiveData dari Base-ViewModel.  Di masa depan, duplikat ini akan memakan ruang memori sampai mereka dihancurkan oleh "pengumpul sampah."  Karena  Jika kita sudah memiliki repositori dalam bentuk singleton dan kami ingin meminimalkan biaya pembuatan kembali layar, akan lebih bijaksana untuk mentransfer objek LiveData di dalam repositori singleton, sehingga memfasilitasi objek ViewModel dan mempercepat aplikasi. <br><br>  Tentu saja, ini tidak berarti bahwa Anda perlu mentransfer semua LiveData dari ViewModel ke repositori, tetapi Anda harus lebih serius mendekati masalah ini dan membuat pilihan Anda secara sadar.  Kerugian dari pendekatan ini adalah peningkatan jumlah objek berumur panjang, karena  semua repositori didefinisikan sebagai singleton dan masing-masing menyimpan objek LiveData.  Tetapi dalam kasus tertentu, Pembantu Ruang Rapat bukan minus, karena  aplikasi berjalan tanpa henti sepanjang hari, tanpa mengalihkan konteks ke aplikasi lain. <br><br><h4>  Arsitektur yang dihasilkan </h4><br><img src="https://habrastorage.org/webt/yf/db/uo/yfdbuo8--ygtmrgxsybvuiuyeme.png"><br><br><ul><li>  Semua permintaan dieksekusi dalam repositori.  Semua repositori (di Helper Ruang Pertemuan ada 11) yang dirancang sebagai singleton.  Mereka dibagi berdasarkan jenis objek yang dikembalikan dan disembunyikan di balik fasad. </li><li>  Logika bisnis berada di ViewModel.  Berkat penggunaan "Penyaji", ukuran total semua ViewModel (ada 6 dalam proyek) ternyata kurang dari 120 baris. </li><li>  Aktivitas dan fragmen hanya terlibat dalam mengubah bagian UI, menggunakan pengamat dan LiveData yang dikembalikan dari ViewModel. </li><li>  Fungsi untuk memproses dan menghasilkan data disimpan di "presenter".  Fungsi izin yang digunakan secara aktif dari Kotlin untuk pemrosesan data. </li></ul><br>  Logika latar belakang telah dipindahkan ke Intent-Service: <br><br><ul><li>  Event-Update-Service.  Layanan yang bertanggung jawab untuk menyinkronkan data kamar saat ini di Firebase dan Graph API. </li><li>  Layanan Pengguna-Mengenali.  Hanya berjalan di master tablet.  Bertanggung jawab untuk menambah staf baru ke sistem.  Memeriksa daftar orang yang sudah terlatih dengan daftar dari Active Directory.  Jika orang baru muncul, layanan menambahkan mereka ke Face API dan melatih kembali jaringan saraf.  Setelah operasi selesai, dimatikan.  Itu dimulai ketika aplikasi dimulai. </li><li>  Layanan Notifikasi-Online memberi tahu tablet lain bahwa tablet ini berfungsi, mis.  Baterai eksternal tidak habis.  Ia bekerja melalui Firebase. </li></ul><br>  Hasilnya adalah arsitektur yang agak fleksibel dan benar dari sudut pandang distribusi tanggung jawab yang memenuhi semua persyaratan pembangunan modern.  Jika di masa depan kita meninggalkan Microsoft Graph API, Firebase, atau modul lainnya, mereka dapat dengan mudah diganti dengan yang baru tanpa mengganggu aplikasi lainnya.  Kehadiran sistem "presenter" yang luas memungkinkan untuk mengambil semua fungsi pemrosesan data di luar inti.  Akibatnya, arsitekturnya menjadi sangat jernih, yang merupakan nilai tambah besar.  Masalah ViewModel yang terlalu besar telah sepenuhnya hilang. <br><br>  Di bawah ini saya akan memberikan contoh bundel yang biasa digunakan dalam aplikasi yang dikembangkan. <br><br><h3>  Berlatih.  Tonton Pembaruan </h3><br>  Bergantung pada kondisi ruang pertemuan, dial menunjukkan salah satu kondisi berikut: <br><br><img src="https://habrastorage.org/webt/sa/o2/to/sao2towzwxh0qqlp1gvxd_s2qjg.png"><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br>  Selain itu, lengkungan sementara unjuk rasa terletak di sepanjang garis dial, dan pusat menghitung mundur sampai akhir pertemuan atau sampai awal reli berikutnya.  Semua ini dilakukan oleh perpustakaan kanvas yang kami kembangkan.  Jika kisi pertemuan telah berubah, kita harus memperbarui data di perpustakaan. <br><br>  Karena LiveData diumumkan dalam Repositori, paling logis untuk memulainya. <br><br><h4>  Repositori </h4><br>  <i>FirebaseRoomRepository</i> - kelas yang bertanggung jawab untuk mengirim dan memproses permintaan di Firebase terkait dengan model Room. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. object FirebaseRoomRepository { private val database = FirebaseFactory.database val rooms: MutableList&lt;Room&gt; = ArrayList() // 2. var currentRoom: MutableLiveData&lt;Room?&gt; = MutableLiveData() val onlineStatus: MediatorLiveData&lt;HashMap&lt;String, Boolean&gt;&gt; = MediatorLiveData() var otherRooms: MutableLiveData&lt;List&lt;Room&gt;&gt; = MutableLiveData() var ownRoom: MutableLiveData&lt;Room&gt; = MutableLiveData() // 3. private val roomsListener = object : ValueEventListener { override fun onDataChange(dataSnapshot: DataSnapshot) { updateRooms(dataSnapshot) } override fun onCancelled(error: DatabaseError) {} } init { // 4. database.getReference(ROOMS_CURRENT_STATES) .addValueEventListener(roomsListener) } // 5. private fun updateRooms(dataSnapshot: DataSnapshot) { rooms.updateRooms(dataSnapshot) otherRooms.updateOtherRooms(rooms) ownRoom.updateOwnRoom(rooms) currentRoom.updateCurrentRoom(rooms, ownRoom) } }</span></span></code> </pre><br>  Untuk menunjukkan, kode inisialisasi firebase pendengar sedikit disederhanakan (fungsi menyambung kembali dihapus).  Mari kita lihat poin dari apa yang terjadi di sini: <br><br><ol><li>  repositori dirancang sebagai singleton (di Kotlin, cukup untuk mengganti kata kunci kelas dengan objek); </li><li>  inisialisasi objek LiveData; </li><li>  ValueEventListener dideklarasikan sebagai variabel untuk menghindari penciptaan kembali kelas anonim jika terjadi penyambungan kembali (ingat, saya menyederhanakan inisialisasi dengan menghapus penyambungan kembali jika terputus); </li><li>  inisialisasi ValueEventListener (jika data dalam Firebase berubah, pendengar akan segera menjalankan dan memperbarui data dalam objek LiveData); </li><li>  Pembaruan untuk objek LiveData. </li></ol><br>  Fungsi itu sendiri dipindahkan ke file FirebaseRoomRepositoryPresenter yang terpisah dan didekorasi sebagai fungsi ekstensi. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> MutableLiveData</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;List&lt;Room&gt;</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOtherRooms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rooms: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MutableList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Room</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.postValue(rooms.filter { !it.isOwnRoom() }) }</code> </pre><br>  <i>Contoh fungsi ekstensi dari FirebaseRoomRepositoryPresenter</i> <br><br>  Juga, untuk pemahaman umum tentang gambar, saya akan memberikan daftar objek Room. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. data class Room(var number: String = "", var nickName: String = "", var email: String? = null, var imgSmall: String? = null, var imgOffline: String? = null, var imgFree: String? = null, var imgWait: String? = null, var imgBusy: String? = null, var events: List&lt;Event.Short&gt; = emptyList()) // 2.</span></span></code> </pre><br><ol><li>  Kelas data.  Pengubah ini secara otomatis menghasilkan dan mengganti metode toString (), HashCode (), dan equal ().  Tidak perlu lagi mendefinisikan ulang sendiri. </li><li>  Daftar Acara dari objek Kamar.  Daftar inilah yang diperlukan untuk memperbarui data di perpustakaan dial. </li></ol><br>  Semua kelas Repositori disembunyikan di belakang kelas fasad. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Repository { <span class="hljs-comment"><span class="hljs-comment">// 1. private val firebaseRoomRepository = FirebaseRoomRepository // ......... /** * Rooms queries */ fun getOtherRooms() = firebaseRoomRepository.otherRooms fun getOwnRoom() = firebaseRoomRepository.ownRoom fun getAllRooms() = firebaseRoomRepository.rooms // 2. fun getCurrentRoom() = firebaseRoomRepository.currentRoom //   // ....... }</span></span></code> </pre><br><ol><li>  Di atas Anda dapat melihat daftar semua kelas repositori bekas dan fasad tingkat kedua.  Ini menyederhanakan pemahaman umum kode dan menunjukkan daftar semua kelas repositori yang terhubung. </li><li>  Daftar metode yang mengembalikan referensi ke objek LiveData dari FirebaseRoomRepository.  Setter dan getter Kotlin adalah opsional, jadi Anda tidak perlu menuliskannya secara tidak perlu. </li></ol><br>  Organisasi semacam itu memungkinkan Anda untuk memenuhi 20 hingga 30 permintaan dalam satu repositori root.  Jika aplikasi Anda memiliki lebih banyak permintaan, Anda harus membagi fasad root menjadi 2 atau lebih. <br><br><h4>  ViewModel </h4><br>  BaseViewModel adalah ViewModel dasar dari mana semua ViewModels diwarisi.  Ini termasuk satu objek currentRoom tunggal, digunakan secara universal. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. open class BaseViewModel : ViewModel() { // 2. fun getCurrentRoom() = Repository.getCurrentRoom() }</span></span></code> </pre><br><ol><li>  Marker terbuka berarti bahwa Anda dapat mewarisi dari kelas.  Secara default di Kotlin, semua kelas dan metode adalah final, mis.  kelas tidak dapat diwarisi, dan metode tidak dapat didefinisikan ulang.  Ini untuk melindungi dari perubahan versi yang tidak kompatibel yang tidak disengaja.  Saya akan memberi contoh. <br><br>  <i>Anda sedang mengembangkan versi baru perpustakaan.</i>  <i>Pada titik tertentu, karena satu dan lain alasan, Anda memutuskan untuk mengubah nama kelas atau mengubah tanda tangan beberapa metode.</i>  <i>Dengan mengubahnya, Anda secara tidak sengaja membuat ketidakcocokan versi.</i>  <i>Ups ... Jika Anda mungkin tahu bahwa metode ini dapat ditimpa oleh seseorang, dan kelasnya diwarisi, Anda mungkin akan lebih akurat dan tidak akan menembak kaki Anda.</i>  <i>Untuk melakukan ini, di Kotlin, secara default, semuanya dinyatakan final, dan untuk pembatalan ada pengubah "terbuka".</i> <br></li><li>  Metode getCurrentRoom () mengembalikan tautan ke objek LiveData dari ruang saat ini dari Repositori, yang, pada gilirannya, diambil dari FirebaseRoomRepository.  Ketika metode ini dipanggil, objek Kamar akan kembali berisi semua informasi tentang ruangan, termasuk daftar acara. </li></ol><br>  Untuk mengonversi data dari satu format ke format lainnya, kami akan menggunakan transformasi.  Untuk melakukan ini, buat <i>MainFragmentViewModel</i> dan mewarisinya dari <i>BaseViewModel</i> . <br><br>  <i>MainFragmentViewModel</i> adalah kelas <i>turunan</i> dari BaseViewModel.  ViewModel ini hanya digunakan di MainFragment. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// 1. class MainFragmentViewModel: BaseViewModel () { // 2. var currentRoomEvents = Transformations.switchMap(getCurrentRoom()) { val events: MutableLiveData&lt;List&lt;Event.Short&gt;&gt; = MutableLiveData() // some business logic events.postValue(it?.eventsList) events } // 3. val currentRoomEvents2 = MediatorLiveData&lt;List&lt;Event.Short&gt;&gt;().apply { addSource(getCurrentRoom()) { room -&gt; // some business logic postValue(room?.eventsList) } } }</span></span></code> </pre><br><ol><li>  Perhatikan kurangnya pengubah terbuka.  Ini berarti tidak ada yang mewarisi dari kelas. </li><li>  currentRoomEvents - objek yang diperoleh menggunakan transformasi.  Segera setelah objek perubahan ruang saat ini, transformasi dilakukan dan objek currentRoomEvents diperbarui. </li><li>  MediatorLiveData.  Hasilnya identik dengan transformasi (ditunjukkan untuk referensi). </li></ol><br>  Opsi pertama digunakan untuk mengonversi data dari satu jenis ke jenis lainnya, yang kami butuhkan, dan opsi kedua diperlukan untuk menjalankan beberapa logika bisnis.  Namun, konversi data tidak terjadi.  Ingat bahwa impor android di ViewModel tidak valid.  Karenanya, saya memulai permintaan tambahan dari sini atau memulai kembali layanan sebagaimana diperlukan. <br><br>  <b>Pemberitahuan penting!</b>  Agar transformasi atau mediator berfungsi, seseorang harus berlangganan dari fragmen atau aktivitas.  Kalau tidak, kode tidak akan dieksekusi, karena  tidak ada yang akan mengharapkan hasil (ini adalah objek pengamat). <br><br><h4>  Mainfragment </h4><br>  Langkah terakhir dalam mengonversi data menjadi hasil.  MainFragment mencakup pustaka panggil dan Lihat-Pager di bagian bawah layar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseFragment</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// 1. private lateinit var viewModel: MainFragmentViewModel // 2. private val currentRoomObserver = Observer&lt;List&lt;Event.Short&gt;&gt; { clockView.updateArcs(it) } override fun onAttach(context: Context?) { super.onAttach(context) // 3. viewModel = ViewModelProviders.of(this).get(MainFragmentViewModel::class.java) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { return inflater.inflate(R.layout.fragment_main, container, false) } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 4. viewModel.currentRoomEvents.observe(viewLifecycleOwner, currentRoomObserver) } }</span></span></code> </pre><br><ol><li>  Inisialisasi dari MainFragmentViewModel.  Pengubah lateinit menunjukkan bahwa kami berjanji untuk menginisialisasi objek ini nanti, sebelum kami menggunakannya.  Kotlin mencoba melindungi pemrogram dari penulisan kode yang salah, jadi kita harus segera mengatakan bahwa objek tersebut bisa nol, atau menaruh lateinit.  Dalam hal ini, ViewModel harus diinisialisasi oleh objek. </li><li>  Pengamat-pendengar untuk memperbarui nomor. </li><li>  Menginisialisasi ViewModel.  Harap dicatat bahwa ini terjadi segera setelah fragmen melekat pada aktivitas. </li><li>  Setelah aktivitas dibuat, kami berlangganan perubahan ke objek currentRoomEvents.  Harap dicatat bahwa saya tidak berlangganan ke siklus hidup fragmen (ini), tetapi ke objek viewLifecycleOwner.  Faktanya adalah bahwa di perpustakaan dukungan 28.0.0 dan AndroidX 1.0.0 bug terdeteksi ketika pengamat "berhenti berlangganan".  Untuk mengatasi masalah ini, tambalan dalam bentuk viewLifecycleOwner dirilis, dan Google menyarankan untuk berlangganan.  Ini memperbaiki masalah pengamat zombie ketika fragmen itu mati dan pengamat terus bekerja.  Jika Anda masih menggunakan ini, pastikan untuk menggantinya dengan viewLifecycleOwner. </li></ol><br>  Jadi, saya ingin menunjukkan kesederhanaan dan keindahan MVVM dan LiveData tanpa menggunakan data binding.  Harap dicatat bahwa dalam proyek ini saya melanggar aturan yang diterima secara umum dengan menempatkan LiveData di Repositori karena kekhasan proyek.  Namun, jika kami memindahkannya ke ViewModel, keseluruhan gambar akan tetap tidak berubah. <br><br>  Sebagai ceri pada kue, saya telah menyiapkan untuk Anda sebuah video pendek dengan demonstrasi (nama-nama dioleskan sesuai dengan persyaratan keamanan, saya minta maaf): <br><br><img src="https://habrastorage.org/webt/uk/fd/wc/ukfdwcj2495fl6bcdt0eplxu9x8.png"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E9zUc0vaGck" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Ringkasan </h3><br>  Sebagai hasil dari aplikasi bekerja di bulan pertama, beberapa bug terungkap pada tampilan cross rallies (Outlook memungkinkan Anda untuk membuat beberapa acara pada saat yang bersamaan, sementara sistem kami tidak).  Sekarang sistem telah bekerja selama 3 bulan.  Kesalahan atau kegagalan tidak diamati. <br><br>  PS Terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">jericho_code</a> untuk komentarnya.  Di Kotlin, Anda dapat dan harus menginisialisasi Daftar &lt;&gt; dalam model menggunakan blankList (), maka objek tambahan tidak dibuat. <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events: List&lt;Event.<span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>&gt; = emptyList() <span class="hljs-comment"><span class="hljs-comment">//      EmptyList var events: List&lt;Event.Short&gt; = ArrayList() //   </span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457960/">https://habr.com/ru/post/id457960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457948/index.html">Permainan papan di mana Anda harus menghancurkan kepala Anda</a></li>
<li><a href="../id457952/index.html">Bagaimana prosesor dirancang dan diproduksi: pembuatan chip</a></li>
<li><a href="../id457954/index.html">Mengapa Swift Dapat Menjadi Acara Besar dalam Pembelajaran Jauh</a></li>
<li><a href="../id457956/index.html">Bagaimana memilih penyimpanan tanpa memotret diri Anda sendiri</a></li>
<li><a href="../id457958/index.html">Kehidupan sehari-hari MT_FREE: beberapa cerita tentang pengaruh layanan pihak ketiga pada pekerjaan Wi-Fi publik</a></li>
<li><a href="../id457962/index.html">Seperti dalam arsitektur thrash dan kurangnya keterampilan dalam Scrum, kami menciptakan tim lintas komponen</a></li>
<li><a href="../id457964/index.html">Virtualitas Nyata: Workstation ++</a></li>
<li><a href="../id457966/index.html">"Saya akan membuka zona IT khusus di selatan Rusia" - 10 pertanyaan kepada programmer # 11. Musim baru</a></li>
<li><a href="../id457968/index.html">Paralel yang bersilangan - Kementerian Komunikasi dalam semalam membakar miliaran anggaran</a></li>
<li><a href="../id457970/index.html">Linter in Go. Cara memasaknya. Denis Isaev</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>