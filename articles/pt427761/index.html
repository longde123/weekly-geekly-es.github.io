<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåè üè≥Ô∏è ‚ùå Implementa√ß√£o do algoritmo k-means (k-means) usando o exemplo de trabalho com pixels üï¶ ü§£ üëø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Recentemente, foi necess√°rio escrever um c√≥digo para implementar a segmenta√ß√£o de imagens usando o m√©todo k-means (ingl√™s k-means). Bem, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementa√ß√£o do algoritmo k-means (k-means) usando o exemplo de trabalho com pixels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427761/">  Ol√° pessoal!  Recentemente, foi necess√°rio escrever um c√≥digo para implementar a segmenta√ß√£o de imagens usando o m√©todo k-means (ingl√™s k-means).  Bem, a primeira coisa que o Google faz √© ajudar.  Encontrei muitas informa√ß√µes, como do ponto de vista matem√°tico (todos os tipos de rabiscos matem√°ticos complexos l√°, voc√™ entender√° o que diabos est√° escrito l√°), bem como algumas implementa√ß√µes de software que est√£o na Internet em ingl√™s.  Esses c√≥digos s√£o certamente bonitos - sem d√∫vida, mas a ess√™ncia da id√©ia √© dif√≠cil de entender.  De alguma forma, √© tudo complicado l√°, confuso e, no entanto, manualmente, manualmente, voc√™ n√£o escreve o c√≥digo, n√£o entende nada.  Neste artigo, quero mostrar uma implementa√ß√£o simples, n√£o produtiva, mas, espero, compreens√≠vel desse maravilhoso algoritmo.  Ok, vamos l√°! <br><a name="habracut"></a><br>  Ent√£o, o que √© agrupar em termos de nossas percep√ß√µes?  Deixe-me dar um exemplo, digamos que h√° uma bela foto com flores do chal√© da sua av√≥. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  A quest√£o √©: determinar quantas √°reas nesta foto s√£o preenchidas aproximadamente com a mesma cor.  Bem, n√£o √© nada dif√≠cil: p√©talas brancas - uma, centros amarelos - duas (n√£o sou bi√≥loga, n√£o sei como se chamam), tr√™s verdes.  Essas se√ß√µes s√£o chamadas de clusters.  Um cluster √© uma combina√ß√£o de dados com recursos comuns (cor, posi√ß√£o etc.).  O processo de determinar e colocar cada componente de qualquer dado em tais clusters - se√ß√µes √© chamado de cluster. <br><br>  Existem muitos algoritmos de agrupamento, mas o mais simples deles √© o k - m√©dio, que ser√° discutido mais adiante.  O K-means √© um algoritmo simples e eficiente, f√°cil de implementar usando um m√©todo de software.  Os dados que iremos distribuir em clusters s√£o pixels.  Como voc√™ sabe, um pixel colorido possui tr√™s componentes - vermelho, verde e azul.  A imposi√ß√£o desses componentes e cria uma paleta de cores existentes. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  Na mem√≥ria do computador, cada componente de cor √© caracterizado por um n√∫mero de 0 a 255. Ou seja, combinando diferentes valores de vermelho, verde e azul, obtemos uma paleta de cores na tela. <br><br>  Usando pixels como exemplo, implementamos nosso algoritmo.  K-means √© um algoritmo iterativo, ou seja, fornecer√° o resultado correto ap√≥s um certo n√∫mero de repeti√ß√µes de alguns c√°lculos matem√°ticos. <br><br><h3>  Algoritmo </h3><br><ol><li>  Voc√™ precisa saber com anteced√™ncia quantos clusters precisa distribuir os dados.  Essa √© uma desvantagem significativa desse m√©todo, mas esse problema √© resolvido por implementa√ß√µes aprimoradas do algoritmo, mas isso, como se costuma dizer, √© uma hist√≥ria completamente diferente. </li><li>  Precisamos escolher os centros iniciais de nossos clusters.  Como  Sim aleatoriamente.  Porque  Para que voc√™ possa encaixar cada pixel no centro do cluster.  O centro √© como o rei, em torno do qual seus s√∫ditos est√£o reunidos - pixels.  √â a ‚Äúdist√¢ncia‚Äù do centro ao pixel que determina a quem cada pixel obedecer√°. </li><li>  Calculamos a dist√¢ncia de cada centro a cada pixel.  Essa dist√¢ncia √© considerada como a dist√¢ncia euclidiana entre pontos no espa√ßo e, no nosso caso, como a dist√¢ncia entre os tr√™s componentes de cores: <p><math> </math> $$ display $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} . $$ display $$ </p>  Calculamos a dist√¢ncia do primeiro pixel a cada centro e determinamos a menor dist√¢ncia entre esse pixel e os centros.  Para o centro, a dist√¢ncia para a menor, recalculamos as coordenadas como a m√©dia aritm√©tica entre cada componente do pixel - o rei e o pixel - o sujeito.  Nosso centro muda no espa√ßo de acordo com os c√°lculos. </li><li>  Depois de contar todos os centros, distribu√≠mos os pixels em grupos, comparando a dist√¢ncia de cada pixel aos centros.  Um pixel √© colocado em um cluster, ao centro do qual est√° mais pr√≥ximo do que aos outros centros. </li><li>  Tudo come√ßa novamente, desde que os pixels permane√ßam nos mesmos clusters.  Frequentemente, isso pode n√£o acontecer, uma vez que, com uma grande quantidade de dados, os centros se movem em um pequeno raio e os pixels ao longo das bordas dos clusters saltam para um ou outro cluster.  Para fazer isso, determine o n√∫mero m√°ximo de itera√ß√µes. </li></ol><br><h3>  Implementa√ß√£o </h3><br>  Vou implementar este projeto em C ++.  O primeiro arquivo √© "k_means.h", nele eu defini os principais tipos de dados, constantes e a classe principal para trabalhar - "K_means". <br>  Para caracterizar cada pixel, crie uma estrutura que consiste em tr√™s componentes de pixel, para os quais escolhi o tipo duplo para c√°lculos mais precisos e tamb√©m determinei algumas constantes para o programa funcionar: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  A pr√≥pria classe K_means: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Vamos examinar os componentes da classe: <br><br>  vectorpixcel - um vetor para pixels; <br>  q_klaster - n√∫mero de clusters; <br>  k_pixcel - n√∫mero de pixels; <br>  vectorcentr - um vetor para centros de agrupamento, o n√∫mero de elementos nele √© determinado por q_klaster; <br>  identity_centers () - um m√©todo para selecionar aleatoriamente os centros iniciais entre os pixels de entrada; <br>  compute () e compute_s () s√£o m√©todos internos para calcular a dist√¢ncia entre pixels e centros de rec√°lculo, respectivamente; <br>  tr√™s construtores: o primeiro √© por padr√£o, o segundo √© para inicializar pixels de uma matriz, o terceiro √© para inicializar pixels de um arquivo de texto (na minha implementa√ß√£o, o arquivo √© acidentalmente preenchido com dados no in√≠cio e, em seguida, os pixels s√£o lidos nesse arquivo para o programa funcionar, por que n√£o diretamente no vetor - apenas necess√°rio no meu caso); <br>  clustering (std :: ostream &amp; os) - m√©todo de clustering; <br>  m√©todo e sobrecarga da instru√ß√£o de sa√≠da para publicar os resultados. <br><br>  Implementa√ß√£o do m√©todo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  Este √© um m√©todo para selecionar os centros de armazenamento em cluster inicial e adicion√°-los ao vetor central.  √â realizada uma verifica√ß√£o para repetir os centros e substitu√≠-los nesses casos. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Uma implementa√ß√£o de construtor para inicializar pixels de uma matriz. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  Passamos um objeto de entrada para esse construtor para poder inserir dados do arquivo e do console. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  ‚Ññ"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         ‚Äì  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  O principal m√©todo de agrupamento. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - ‚Ññ"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  A sa√≠da dos dados iniciais. <br><br><h4>  Exemplo de sa√≠da </h4><br><div class="spoiler">  <b class="spoiler_title">Exemplo de sa√≠da</b> <div class="spoiler_text">  <em>Pixels iniciais:</em> <em><br></em>  <em>255 140 50 - N¬∫ 0</em> <em><br></em>  <em>100 70 1 - N¬∫ 1</em> <em><br></em>  <em>150 20 200 - N¬∫ 2</em> <em><br></em>  <em>251 141 51 - No.3</em> <em><br></em>  <em>104 69 3 - N¬∫ 4</em> <em><br></em>  <em>153 22 210 - N¬∫ 5</em> <em><br></em>  <em>252 138 54 - N¬∫ 6</em> <em><br></em>  <em>101 74 4 - N¬∫ 7</em> <em><br><br></em>  <em>Centros de agrupamento inicial aleat√≥rios:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>N√∫mero de Clusters: 3</em> <em><br></em>  <em>N√∫mero de pixels: 8</em> <em><br><br></em>  <em>In√≠cio do cluster:</em> <em><br><br></em>  <em>N√∫mero de itera√ß√£o 0</em> <em><br><br></em>  <em>Dist√¢ncia do pixel 0 ao centro # 0: 218.918</em> <em><br></em>  <em>Dist√¢ncia do pixel 0 ao centro # 1: 173.352</em> <em><br></em>  <em>Dist√¢ncia do pixel 0 ao centro # 2: 176.992</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 1</em> <em><br></em>  <em>Recalculando o centro # 1: 179,5 104,5 26,5</em> <em><br></em>  <em>Dist√¢ncia do pixel 1 ao centro # 0: 211.189</em> <em><br></em>  <em>Dist√¢ncia do pixel 1 ao centro # 1: 90.3369</em> <em><br></em>  <em>Dist√¢ncia do pixel 1 ao centro # 2: 0</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 2</em> <em><br></em>  <em>Recalculando o centro # 2: 100 70 1</em> <em><br></em>  <em>Dist√¢ncia do pixel 2 ao centro # 0: 0</em> <em><br></em>  <em>Dist√¢ncia do pixel 2 ao centro # 1: 195.225</em> <em><br></em>  <em>Dist√¢ncia do pixel 2 ao centro # 2: 211.189</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 0</em> <em><br></em>  <em>Contando o centro # 0: 150 20 200</em> <em><br></em>  <em>Dist√¢ncia do pixel 3 ao centro # 0: 216.894</em> <em><br></em>  <em>Dist√¢ncia do pixel 3 ao centro # 1: 83.933</em> <em><br></em>  <em>Dist√¢ncia do pixel 3 ao centro # 2: 174.19</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 1</em> <em><br></em>  <em>Contando o centro # 1: 215,25 122,75 38,75</em> <em><br></em>  <em>Dist√¢ncia do pixel 4 ao centro # 0: 208.149</em> <em><br></em>  <em>Dist√¢ncia do pixel 4 ao centro # 1: 128,622</em> <em><br></em>  <em>Dist√¢ncia do pixel 4 ao centro # 2: 4.58258</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 2</em> <em><br></em>  <em>Contando o centro # 2: 102 69,5 2</em> <em><br></em>  <em>Dist√¢ncia do pixel 5 ao centro # 0: 10.6301</em> <em><br></em>  <em>Dist√¢ncia do pixel 5 ao centro # 1: 208,212</em> <em><br></em>  <em>Dist√¢ncia do pixel 5 ao centro # 2: 219.366</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 0</em> <em><br></em>  <em>Recalculando o centro # 0: 151.5 21 205</em> <em><br></em>  <em>Dist√¢ncia do pixel 6 ao centro # 0: 215.848</em> <em><br></em>  <em>Dist√¢ncia do pixel 6 ao centro # 1: 42.6109</em> <em><br></em>  <em>Dist√¢ncia do pixel 6 ao centro # 2: 172.905</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 1</em> <em><br></em>  <em>Recalculando o centro # 1: 233.625 130.375 46.375</em> <em><br></em>  <em>Dist√¢ncia do pixel 7 ao centro # 0: 213.916</em> <em><br></em>  <em>Dist√¢ncia do pixel 7 ao centro # 1: 150.21</em> <em><br></em>  <em>Dist√¢ncia do pixel 7 ao centro # 2: 5,02494</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 2</em> <em><br></em>  <em>Recalculando o centro # 2: 101,5 71,75 3</em> <em><br><br></em>  <em>Vamos classificar os pixels:</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 0 ao centro # 0: 221.129</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 0 ao centro # 1: 23.7207</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 0 ao centro # 2: 174.44</em> <em><br></em>  <em>Pixel # 0 mais pr√≥ximo do centro # 1</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 1 ao centro # 0: 216.031</em> <em><br></em>  <em>A dist√¢ncia do pixel n¬∫ 1 ao centro n¬∫ 1: 153,492</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 1 ao centro # 2: 3.05164</em> <em><br></em>  <em>Pixel # 1 mais pr√≥ximo do centro # 2</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 2 ao centro # 0: 5.31507</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 2 ao centro # 1: 206.825</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 2 ao centro # 2: 209.378</em> <em><br></em>  <em>Pixel # 2 mais pr√≥ximo do centro # 0</em> <em><br></em>  <em>A dist√¢ncia do pixel n√∫mero 3 ao centro # 0: 219.126</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 3 ao centro # 1: 20.8847</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 3 ao centro # 2: 171.609</em> <em><br></em>  <em>Pixel n¬∫ 3 mais pr√≥ximo do centro n¬∫ 1</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 4 ao centro # 0: 212.989</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 4 ao centro # 1: 149.836</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 4 ao centro # 2: 3.71652</em> <em><br></em>  <em>Pixel # 4 mais pr√≥ximo do centro # 2</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 5 ao centro # 0: 5.31507</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 5 ao centro # 1: 212.176</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 5 ao centro # 2: 219.035</em> <em><br></em>  <em>Pixel # 5 mais pr√≥ximo do centro # 0</em> <em><br></em>  <em>A dist√¢ncia do n√∫mero de pixels 6 ao centro # 0: 215.848</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 6 ao centro # 1: 21.3054</em> <em><br></em>  <em>A dist√¢ncia do pixel n√∫mero 6 ao centro # 2: 172.164</em> <em><br></em>  <em>Pixel # 6 mais pr√≥ximo do centro # 1</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 7 ao centro # 0: 213.916</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 7 ao centro # 1: 150.21</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 7 ao centro # 2: 2.51247</em> <em><br></em>  <em>Pixel # 7 mais pr√≥ximo do centro # 2</em> <em><br><br></em>  <em>Uma matriz de pixels e centros correspondentes:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Resultado do cluster:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Novos centros:</em> <em><br></em>  <em>151,5 21 205 - # 0</em> <em><br></em>  <em>233.625 130.375 46.375 - # 1</em> <em><br></em>  <em>101,5 71,75 3 - # 2</em> <em><br><br></em>  <em>Itera√ß√£o n√∫mero 1</em> <em><br><br></em>  <em>Dist√¢ncia do pixel 0 ao centro # 0: 221.129</em> <em><br></em>  <em>Dist√¢ncia do pixel 0 ao centro # 1: 23.7207</em> <em><br></em>  <em>Dist√¢ncia do pixel 0 ao centro # 2: 174,44</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 1</em> <em><br></em>  <em>Contando o centro # 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Dist√¢ncia do pixel 1 ao centro # 0: 216.031</em> <em><br></em>  <em>Dist√¢ncia do pixel 1 ao centro # 1: 165.234</em> <em><br></em>  <em>Dist√¢ncia do pixel 1 ao centro # 2: 3.05164</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 2</em> <em><br></em>  <em>Recalculando o centro # 2: 100,75 70,875 2</em> <em><br></em>  <em>Dist√¢ncia do pixel 2 ao centro # 0: 5.31507</em> <em><br></em>  <em>Dist√¢ncia do pixel 2 ao centro # 1: 212.627</em> <em><br></em>  <em>Dist√¢ncia do pixel 2 ao centro # 2: 210,28</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 0</em> <em><br></em>  <em>Recalculando o centro # 0: 150,75 20,5 202,5</em> <em><br></em>  <em>Dist√¢ncia do pixel 3 ao centro # 0: 217.997</em> <em><br></em>  <em>Dist√¢ncia do pixel 3 ao centro # 1: 9.29613</em> <em><br></em>  <em>Dist√¢ncia do pixel 3 ao centro # 2: 172.898</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 1</em> <em><br></em>  <em>Contando o centro # 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>Dist√¢ncia do pixel 4 ao centro # 0: 210.566</em> <em><br></em>  <em>Dist√¢ncia do pixel 4 ao centro # 1: 166.078</em> <em><br></em>  <em>Dist√¢ncia do pixel 4 ao centro # 2: 3,88306</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 2</em> <em><br></em>  <em>Contando o centro # 2: 102.375 69,9375 2,5</em> <em><br></em>  <em>Dist√¢ncia do pixel 5 ao centro # 0: 7.97261</em> <em><br></em>  <em>Dist√¢ncia do pixel 5 ao centro # 1: 219.471</em> <em><br></em>  <em>Dist√¢ncia do pixel 5 ao centro # 2: 218.9</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 0</em> <em><br></em>  <em>Contando o centro # 0: 151.875 21,25 206,25</em> <em><br></em>  <em>Dist√¢ncia do pixel 6 ao centro # 0: 216.415</em> <em><br></em>  <em>Dist√¢ncia do pixel 6 ao centro # 1: 6.18805</em> <em><br></em>  <em>Dist√¢ncia do pixel 6 ao centro # 2: 172.257</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 1</em> <em><br></em>  <em>Recalculando o centro # 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Dist√¢ncia do pixel 7 ao centro # 0: 215.118</em> <em><br></em>  <em>Dist√¢ncia do pixel 7 ao centro # 1: 168.927</em> <em><br></em>  <em>Dist√¢ncia do pixel 7 ao centro # 2: 4.54363</em> <em><br></em>  <em>Dist√¢ncia m√≠nima do centro # 2</em> <em><br></em>  <em>Recalculando o centro # 2: 101.688 71.9688 3,25</em> <em><br><br></em>  <em>Vamos classificar os pixels:</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 0 ao centro # 0: 221.699</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 0 ao centro # 1: 5.81307</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 0 ao centro # 2: 174.122</em> <em><br></em>  <em>Pixel # 0 mais pr√≥ximo do centro # 1</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 1 ao centro # 0: 217.244</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 1 ao centro # 1: 172.218</em> <em><br></em>  <em>A dist√¢ncia do pixel n¬∫ 1 ao centro n¬∫ 2: 3,43309</em> <em><br></em>  <em>Pixel # 1 mais pr√≥ximo do centro # 2</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 2 ao centro # 0: 6.64384</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 2 ao centro # 1: 214.161</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 2 ao centro # 2: 209.154</em> <em><br></em>  <em>Pixel # 2 mais pr√≥ximo do centro # 0</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 3 ao centro # 0: 219.701</em> <em><br></em>  <em>Dist√¢ncia do pixel n¬∫ 3 ao centro n¬∫ 1: 3,27555</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 3 ao centro # 2: 171.288</em> <em><br></em>  <em>Pixel n¬∫ 3 mais pr√≥ximo do centro n¬∫ 1</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 4 ao centro # 0: 214.202</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 4 ao centro # 1: 168.566</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 4 ao centro # 2: 3.77142</em> <em><br></em>  <em>Pixel # 4 mais pr√≥ximo do centro # 2</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 5 ao centro # 0: 3,9863</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 5 ao centro # 1: 218.794</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 5 ao centro # 2: 218.805</em> <em><br></em>  <em>Pixel # 5 mais pr√≥ximo do centro # 0</em> <em><br></em>  <em>A dist√¢ncia do n√∫mero de pixels 6 ao centro # 0: 216.415</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 6 ao centro # 1: 3.09403</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 6 ao centro # 2: 171.842</em> <em><br></em>  <em>Pixel # 6 mais pr√≥ximo do centro # 1</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 7 ao centro # 0: 215.118</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 7 ao centro # 1: 168.927</em> <em><br></em>  <em>A dist√¢ncia do pixel n ¬∞ 7 ao centro # 2: 2.27181</em> <em><br></em>  <em>Pixel # 7 mais pr√≥ximo do centro # 2</em> <em><br><br></em>  <em>Uma matriz de pixels e centros correspondentes:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Resultado do cluster:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Novos centros:</em> <em><br></em>  <em>151,875 21,25 206,25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101.688 71.9688 3,25 - # 2</em> <em><br><br></em>  <em>O fim do armazenamento em cluster.</em> <br></div></div><br>  Este exemplo √© planejado com anteced√™ncia, os pixels s√£o selecionados especificamente para demonstra√ß√£o.  Duas itera√ß√µes s√£o suficientes para o programa agrupar os dados em tr√™s clusters.  Observando os centros das duas √∫ltimas itera√ß√µes, √© poss√≠vel ver que elas praticamente permaneceram no lugar. <br><br>  Mais interessantes s√£o os casos de pixels gerados aleatoriamente.  Tendo gerado 50 pontos que precisam ser divididos em 10 grupos, obtive 5 itera√ß√µes.  Tendo gerado 50 pontos que precisam ser divididos em 3 grupos, obtive todas as 100 itera√ß√µes m√°ximas permitidas.  Voc√™ pode perceber que quanto mais clusters, mais f√°cil √© para o programa encontrar os pixels mais semelhantes e combin√°-los em grupos menores, e vice-versa - se houver poucos clusters e muitos pontos, o algoritmo geralmente termina apenas quando o n√∫mero m√°ximo de itera√ß√µes √© excedido, pois alguns pixels saltam constantemente de um cluster para outro.  No entanto, o volume ainda √© determinado em seus clusters completamente. <br><br>  Bem, agora vamos verificar o resultado do armazenamento em cluster.  Tomando o resultado de alguns clusters do exemplo de 50 pontos por 10 clusters, direcionei o resultado desses dados para o Illustrator e foi o que aconteceu: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  Pode-se observar que em cada cluster prevalece qualquer tom de cor, e aqui voc√™ precisa entender que os pixels foram selecionados aleatoriamente, o an√°logo dessa imagem na vida real √© algum tipo de imagem na qual todas as cores foram acidentalmente pulverizadas e √© dif√≠cil selecionar √°reas de cores semelhantes. <br><br>  Digamos que temos uma foto assim.  Podemos definir uma ilha como um aglomerado, mas, com um aumento, vemos que ela consiste em diferentes tons de verde. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  E este √© o cluster 8, mas em uma vers√£o menor, o resultado √© semelhante: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  A vers√£o completa do programa pode ser visualizada no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427761/">https://habr.com/ru/post/pt427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427749/index.html">Apple e Samsung s√£o multadas pela primeira vez por desacelerar telefones antigos</a></li>
<li><a href="../pt427751/index.html">CudaText Sublime Ideas</a></li>
<li><a href="../pt427755/index.html">Nova vers√£o do GitLab 11.4 com revis√£o por pares de solicita√ß√µes de mesclagem e sinalizadores de recursos</a></li>
<li><a href="../pt427757/index.html">Backdoors de microc√≥digo montados no processador X86</a></li>
<li><a href="../pt427759/index.html">Sobre a resolubilidade de problemas na via em tempo polinomial</a></li>
<li><a href="../pt427763/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 13: Protocolos de Rede, Parte 1</a></li>
<li><a href="../pt427767/index.html">Situa√ß√£o: no Canad√°, eles propuseram a introdu√ß√£o de um imposto sobre streaming - estamos discutindo qual √© o problema.</a></li>
<li><a href="../pt427771/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 13: Protocolos de Rede, Parte 2</a></li>
<li><a href="../pt427773/index.html">Eu escrevi uma extens√£o entre navegadores para guias, mas voc√™ n√£o faz isso</a></li>
<li><a href="../pt427775/index.html">Um bot disfar√ßado de programador corrige erros no c√≥digo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>