<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘†ğŸ½ ğŸš„ ğŸˆ¹ Deteksi Serangan Web Menggunakan Seq2Seq Auto Encoder ğŸ¥Š ğŸš´ğŸ» ğŸ‘¨ğŸ¾â€ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mendeteksi serangan telah menjadi tugas penting dalam keamanan informasi selama beberapa dekade. Contoh-contoh implementasi IDS yang pertama diketahui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deteksi Serangan Web Menggunakan Seq2Seq Auto Encoder</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/439202/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="gambar"></a> <br><br>  Mendeteksi serangan telah menjadi tugas penting dalam keamanan informasi selama beberapa dekade.  Contoh-contoh implementasi IDS yang pertama diketahui berasal dari awal 1980-an. <br><br>  Setelah beberapa dekade, seluruh industri alat deteksi serangan terbentuk.  Saat ini, ada berbagai jenis produk, seperti IDS, IPS, WAF, firewall, yang sebagian besar menawarkan deteksi serangan berbasis aturan.  Gagasan untuk menggunakan teknik pendeteksian anomali untuk mendeteksi serangan berdasarkan statistik produksi tampaknya tidak realistis seperti di masa lalu.  Atau sama saja? <a name="habracut"></a><br><br><h2>  Deteksi Anomali dalam Aplikasi Web </h2><br>  Firewall pertama yang dirancang khusus untuk mendeteksi serangan pada aplikasi web mulai muncul di pasaran pada awal 1990-an.  Sejak itu, baik metode serangan dan mekanisme pertahanan telah berubah secara signifikan, dan penyerang bisa selangkah lebih maju setiap saat. <br><br>  Saat ini, sebagian besar WAF berusaha mendeteksi serangan sebagai berikut: ada beberapa mekanisme berbasis aturan yang dibangun ke dalam server proxy terbalik.  Contoh yang paling mencolok adalah mod_security, modul WAF untuk server web Apache, yang dikembangkan pada tahun 2002.  Mengidentifikasi serangan menggunakan aturan memiliki beberapa kelemahan;  misalnya, aturan tidak dapat mendeteksi serangan zero-day, sedangkan serangan yang sama dapat dengan mudah dideteksi oleh seorang ahli, dan ini tidak mengejutkan, karena otak manusia tidak bekerja seperti serangkaian ekspresi reguler. <br><br>  Dari sudut pandang WAF, serangan dapat dibagi menjadi serangan yang dapat kami deteksi berdasarkan urutan permintaan, dan serangan yang satu permintaan HTTP (respons) cukup untuk dipecahkan.  Penelitian kami berfokus pada mendeteksi tipe serangan yang terakhir - SQL Injection, Cross Site Scripting, XML External Entities Injection, Path Traversal, OS Commanding, Object Injection, dll. <br><br>  Tapi pertama-tama, mari kita menguji diri kita sendiri. <br><br><h2>  Apa yang akan dipikirkan oleh ahli ketika dia melihat pertanyaan berikut? </h2><br>  Lihatlah contoh permintaan HTTP untuk aplikasi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="gambar"><br><br>  Jika Anda diberi tugas untuk mendeteksi permintaan berbahaya ke suatu aplikasi, kemungkinan besar Anda ingin mengamati perilaku pengguna yang biasa selama beberapa waktu.  Dengan memeriksa kueri untuk beberapa titik akhir aplikasi, Anda bisa mendapatkan gambaran umum tentang struktur dan fungsi kueri yang tidak berbahaya. <br><br>  Sekarang Anda mendapatkan permintaan untuk analisis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="gambar"><br><br>  Segera terbukti bahwa ada sesuatu yang salah di sini.  Butuh beberapa waktu untuk memahami seperti apa sebenarnya di sini, dan begitu Anda mengidentifikasi bagian dari permintaan yang tampaknya tidak normal, Anda dapat mulai memikirkan jenis serangan apa itu.  Intinya, tujuan kami adalah membuat "kecerdasan buatan untuk mendeteksi serangan" bekerja dengan cara yang sama - menyerupai pemikiran manusia. <br><br>  Yang jelas adalah bahwa beberapa lalu lintas, yang sekilas tampak berbahaya, mungkin normal untuk situs web tertentu. <br><br>  Misalnya, mari pertimbangkan pertanyaan berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="gambar"><br><br>  Apakah kueri ini tidak normal? <br><br>  Bahkan, permintaan ini adalah publikasi bug di pelacak Jira dan merupakan khas dari layanan ini, yang berarti bahwa permintaan tersebut diharapkan dan normal. <br><br>  Sekarang perhatikan contoh berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="gambar"><br><br>  Sekilas, permintaan tersebut tampak seperti pendaftaran pengguna normal pada situs web berdasarkan Joomla CMS.  Namun, operasi yang diminta adalah user.register bukan registrasi.register yang biasa.  Opsi pertama sudah usang dan mengandung kerentanan yang memungkinkan siapa pun untuk mendaftar sebagai administrator.  Eksploitasi untuk kerentanan ini dikenal sebagai Joomla &lt;3.6.4 Pembuatan Akun / Peningkatan Privilege (CVE-2016-8869, CVE-2016-8870). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="gambar"><br><br><h2>  Di mana kita mulai </h2><br>  Tentu saja, pertama kami memeriksa solusi yang ada untuk masalah tersebut.  Berbagai upaya untuk membuat algoritma deteksi serangan berdasarkan statistik atau pembelajaran mesin telah dilakukan selama beberapa dekade.  Salah satu pendekatan yang paling populer adalah untuk memecahkan masalah klasifikasi, ketika kelas adalah sesuatu seperti "query yang diharapkan", "injeksi SQL", XSS, CSRF, dll. Dengan cara ini, Anda dapat mencapai beberapa akurasi yang baik untuk kumpulan data menggunakan classifier. Namun, pendekatan ini tidak menyelesaikan masalah yang sangat penting dari sudut pandang kami: <br><br><ol><li>  <b>Seleksi kelas terbatas dan ditentukan sebelumnya</b> .  Bagaimana jika model Anda dalam proses pembelajaran diwakili oleh tiga kelas, katakan â€œqueries normalâ€, SQLi dan XSS, dan selama operasi sistem ia menghadapi CSRF atau serangan zero-day? </li><li>  <b>Arti dari kelas-kelas ini</b> .  Misalkan Anda perlu melindungi sepuluh klien, yang masing-masing menjalankan aplikasi web yang sangat berbeda.  Untuk sebagian besar dari mereka, Anda tidak tahu seperti apa sebenarnya injeksi SQL untuk aplikasi mereka.  Ini berarti Anda harus membuat set data pelatihan secara artifisial.  Pendekatan ini tidak optimal, karena pada akhirnya Anda akan belajar dari data yang berbeda dalam distribusi dari data nyata. </li><li>  <b>Interpretabilitas hasil model</b> .  Nah, model menghasilkan hasil SQL Injection, dan sekarang apa?  Anda dan, yang lebih penting, klien Anda, yang pertama kali melihat peringatan dan biasanya bukan pakar serangan web, harus menebak bagian mana dari permintaan yang dianggap berbahaya oleh model Anda. </li></ol><br>  Dengan mengingat semua masalah ini, kami memutuskan untuk mencoba melatih model pengklasifikasi. <br><br>  Karena protokol HTTP adalah protokol teks, jelas bahwa kami perlu melihat pada pengklasifikasi teks modern.  Salah satu contoh yang terkenal adalah analisis sentimen dalam dataset ulasan film IMDB.  Beberapa solusi menggunakan RNN untuk mengklasifikasikan ulasan.  Kami memutuskan untuk mencoba model serupa dengan arsitektur RNN dengan beberapa perbedaan kecil.  Misalnya, arsitektur bahasa alami RNN menggunakan representasi vektor kata-kata, tetapi tidak jelas kata-kata mana yang muncul dalam bahasa yang tidak alami seperti HTTP.  Oleh karena itu, kami memutuskan untuk menggunakan representasi vektor simbol untuk tugas kami. <br><br>  Representasi siap pakai tidak menyelesaikan masalah kami, jadi kami menggunakan pemetaan karakter sederhana ke dalam kode numerik dengan beberapa penanda internal, seperti <code>GO</code> dan <code>EOS</code> . <br><br>  Setelah pengembangan dan pengujian model selesai, semua masalah yang diprediksi sebelumnya menjadi jelas, tetapi setidaknya tim kami beralih dari asumsi yang tidak berguna ke beberapa hasil. <br><br><h2>  Apa selanjutnya </h2><br>  Selanjutnya, kami memutuskan untuk mengambil beberapa langkah menuju interpretabilitas hasil model.  Pada titik tertentu, kami menemukan mekanisme perhatian "Perhatian" dan mulai menerapkannya dalam model kami.  Dan itu memberikan hasil yang menjanjikan.  Sekarang model kami mulai menampilkan tidak hanya label kelas, tetapi juga faktor perhatian untuk setiap karakter yang kami berikan kepada model. <br><br>  Sekarang kita bisa memvisualisasikan dan menunjukkan di antarmuka web tempat yang tepat di mana serangan injeksi SQL terdeteksi.  Ini adalah hasil yang baik, tetapi masalah lain dari daftar masih belum terselesaikan. <br><br>  Jelas bahwa kita harus terus bergerak ke arah manfaat dari mekanisme perhatian dan menjauh dari tugas klasifikasi.  Setelah membaca sejumlah besar studi terkait pada model urutan (pada mekanisme perhatian [2], [3], [4], pada representasi vektor, pada arsitektur autoencoder) dan percobaan dengan data kami, kami dapat membuat model pendeteksian anomali yang pada akhirnya akan bekerja kurang lebih seperti yang dilakukan seorang ahli. <br><br><h2>  Pengkode Otomatis </h2><br>  Pada titik tertentu, menjadi jelas bahwa arsitektur Seq2Seq [5] paling cocok untuk tugas kita. <br><br>  Model Seq2Seq [7] terdiri dari dua LSTM multilayer - sebuah encoder dan sebuah decoder.  Encoder memetakan urutan input ke vektor dengan panjang tetap.  Dekoder menerjemahkan vektor target menggunakan output encoder.  Dalam pelatihan, pembuat enkode otomatis adalah model yang nilai targetnya ditetapkan sama dengan nilai input. <br><br>  Idenya adalah untuk mengajarkan jaringan untuk memecahkan kode hal-hal yang dilihatnya, atau, dengan kata lain, mendekatkan identitas.  Jika autoencoder terlatih diberi pola abnormal, itu mungkin membuatnya kembali dengan tingkat kesalahan yang tinggi, hanya karena tidak pernah terlihat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="gambar"><br><br><h2>  Solusi </h2><br>  Solusi kami terdiri dari beberapa bagian: inisialisasi model, pelatihan, perkiraan dan verifikasi.  Sebagian besar kode yang terletak di repositori, kami harap, tidak memerlukan penjelasan, jadi kami hanya akan fokus pada bagian-bagian penting. <br><br>  Model ini dibuat sebagai turunan dari kelas Seq2Seq, yang memiliki argumen konstruktor berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="gambar"><br><br>  Selanjutnya, lapisan auto-encoder diinisialisasi.  Encoder pertama: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="gambar"><br><br>  Kemudian dekoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="gambar"><br><br>  Karena masalah yang kami selesaikan adalah mendeteksi anomali, nilai target dan inputnya sama.  Jadi feed_dict kami terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="gambar"><br><br>  Setelah setiap era, model terbaik disimpan sebagai titik referensi, yang kemudian dapat diunduh.  Untuk tujuan pengujian, aplikasi web dibuat yang kami pertahankan dengan model untuk memeriksa apakah serangan nyata berhasil. <br><br>  Terinspirasi oleh mekanisme perhatian, kami mencoba menerapkannya pada model auto-encoder untuk menandai bagian abnormal dari permintaan ini, tetapi memperhatikan bahwa probabilitas yang berasal dari lapisan terakhir bekerja lebih baik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="gambar"><br><br>  Pada tahap pengujian pada sampel kami yang tertunda, kami mendapatkan hasil yang sangat baik: presisi dan daya ingat mendekati 0,99.  Dan kurva ROC cenderung ke 1. Kelihatannya luar biasa, bukan? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="gambar"><br><br><h2>  Hasil </h2><br>  Model yang diusulkan dari auto-encoder Seq2Seq mampu mendeteksi anomali dalam permintaan HTTP dengan akurasi yang sangat tinggi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="gambar"><br><br>  Model ini bertindak seperti orang: hanya mempelajari permintaan pengguna "normal" untuk aplikasi web.  Dan ketika mendeteksi anomali dalam permintaan, ia memilih lokasi yang tepat dari permintaan, yang dianggap anomali. <br><br>  Kami menguji model ini pada beberapa serangan pada aplikasi uji dan hasilnya menjanjikan.  Misalnya, gambar di atas menunjukkan bagaimana model kami mendeteksi injeksi SQL dibagi menjadi dua parameter dalam formulir web.  Suntikan SQL semacam itu disebut terfragmentasi: bagian dari muatan serangan dikirim dalam beberapa parameter HTTP, yang membuatnya sulit dideteksi untuk WAF berbasis aturan, karena mereka biasanya menguji setiap parameter secara individual. <br><br>  Kode model dan data pelatihan dan pengujian diterbitkan sebagai laptop Jupyter sehingga semua orang dapat mereproduksi hasil kami dan menyarankan perbaikan. <br><br><h2>  Kesimpulannya </h2><br>  Kami percaya bahwa tugas kami agak tidak penting.  Kami ingin, dengan upaya minimal (pertama-tama, untuk menghindari kesalahan karena kompleksitas solusi), untuk menemukan cara untuk mendeteksi serangan yang, seolah-olah dengan sihir, telah belajar untuk memutuskan apa yang baik dan apa yang buruk.  Kedua, saya ingin menghindari masalah dengan faktor manusia, ketika tepatnya seorang ahli memutuskan apa tanda serangan dan apa yang bukan.  Kesimpulannya, saya ingin mencatat bahwa auto-encoder dengan arsitektur Seq2Seq untuk masalah mencari anomali, menurut pendapat kami dan untuk masalah kami, melakukan pekerjaan yang sangat baik. <br><br>  Kami juga ingin menyelesaikan masalah dengan interpretabilitas data.  Menggunakan arsitektur jaringan saraf yang kompleks biasanya sangat sulit.  Dalam serangkaian transformasi, pada akhirnya sudah sulit untuk mengatakan apa sebenarnya bagian data yang paling mempengaruhi keputusan.  Namun, setelah memikirkan kembali pendekatan interpretasi data oleh model, ternyata cukup bagi kita untuk mendapatkan probabilitas untuk setiap simbol dari lapisan terakhir. <br><br>  Perlu dicatat bahwa ini bukan versi produksi.  Kami tidak dapat mengungkapkan rincian penerapan pendekatan ini dalam produk nyata, dan kami ingin memperingatkan bahwa hanya dengan mengambil dan menyematkan solusi ini di beberapa produk tidak akan berfungsi. <br><br>  Repositori GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">goo.gl/aNwq9U</a> <br><br>  <b>Penulis</b> : Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ), Fedor Sakharov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ), Arseniy Reutov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Referensi: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Jaringan LSTM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatian dan Augmented Neural Networks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatian adalah yang Anda butuhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatian Yang Anda Butuhkan (beranotasi)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Terjemahan Mesin Saraf (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder</a> </li><li>  <a href="">Sequence to Sequence Learning dengan Neural Networks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun Autoencoder di Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439202/">https://habr.com/ru/post/id439202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439192/index.html">Speaker PC Ke Sebelas</a></li>
<li><a href="../id439194/index.html">Manajemen Karakter dengan SharedEvents</a></li>
<li><a href="../id439196/index.html">Analis JPMorgan: Apple harus membeli Blizzard, Netflix atau Sonos untuk meyakinkan investor</a></li>
<li><a href="../id439198/index.html">Generasi Pulau Barrier</a></li>
<li><a href="../id439200/index.html">Komposer untuk anak kecil</a></li>
<li><a href="../id439204/index.html">Meningkatkan efisiensi fotosintesis dengan modifikasi genetik tanaman</a></li>
<li><a href="../id439206/index.html">Bagaimana kami memecahkan masalah melanjutkan daftar putar di RecSys Challenge dan mengambil tempat ke-3</a></li>
<li><a href="../id439208/index.html">Oh, Kode Saya: Cara Kerja MAPS.ME</a></li>
<li><a href="../id439210/index.html">Jawa setelah letusan gunung berapi</a></li>
<li><a href="../id439216/index.html">pudge 500 row embeddable database di golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>