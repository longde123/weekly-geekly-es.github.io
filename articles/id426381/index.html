<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏽 🏨 🏇🏽 Cara membuat fungsi Python lebih baik 🌀 🥞 👂🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebenarnya, judul artikel yang luar biasa ini oleh Jeff Knapp, penulis buku " Writing Idiomatic Python " sepenuhnya mencerminkan esensinya. Baca denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat fungsi Python lebih baik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426381/">  Sebenarnya, judul artikel yang luar biasa ini oleh Jeff Knapp, penulis buku " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Writing Idiomatic Python</a> " sepenuhnya mencerminkan esensinya.  Baca dengan cermat dan jangan ragu untuk berkomentar. <br><br>  Karena kami benar-benar tidak ingin meninggalkan istilah penting dalam huruf Latin dalam teks, kami mengizinkan diri untuk menerjemahkan kata "docstring" sebagai "docstring", setelah menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">istilah</a> ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbahasa Rusia</a> . <br><a name="habracut"></a><br>  Dalam Python, seperti dalam kebanyakan bahasa pemrograman modern, fungsi adalah metode utama abstrak dan enkapsulasi.  Anda, sebagai pengembang, mungkin sudah menulis ratusan fungsi.  Tetapi fungsi ke fungsi - perselisihan.  Selain itu, jika Anda menulis fungsi "buruk", ini akan segera mempengaruhi keterbacaan dan dukungan kode Anda.  Jadi, apa fungsi "buruk", dan yang lebih penting - bagaimana menjadikannya fungsi "baik"? <br><br><h3>  Perbarui topik </h3><br>  Matematika penuh dengan fungsi, namun sulit untuk mengingatnya.  Jadi mari kita kembali ke disiplin favorit kita: analisis.  Anda mungkin telah melihat rumus seperti <code>f(x) = 2x + 3</code> .  Ini adalah fungsi yang disebut <code>f</code> yang mengambil argumen <code>x</code> dan kemudian "mengembalikan" dua kali <code>x + 3</code> .  Meskipun tidak terlalu mirip dengan fungsi yang biasa kita gunakan di Python, ini benar-benar mirip dengan kode berikut: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>*x + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Fungsinya telah lama ada dalam matematika, tetapi dalam ilmu komputer mereka sepenuhnya berubah.  Namun, kekuatan ini tidak diberikan dengan sia-sia: Anda harus melewati berbagai perangkap.  Mari kita bahas apa fungsi "baik" seharusnya dan apa "lonceng dan peluit" khas untuk fungsi yang mungkin memerlukan refactoring. <br><br><h3>  Rahasia Fungsi yang Baik </h3><br>  Apa yang membedakan fungsi Python "baik" dari yang biasa-biasa saja?  Anda akan terkejut betapa banyak interpretasi kata "baik" memungkinkan.  Sebagai bagian dari artikel ini, saya akan menganggap fungsi Python “baik” jika memenuhi <i>sebagian besar</i> item dalam daftar berikut (kadang-kadang tidak mungkin untuk menyelesaikan semua item untuk fungsi tertentu): <br><br><ul><li>  Itu jelas namanya </li><li>  Sesuai dengan prinsip kewajiban tunggal </li><li>  Berisi Dock </li><li>  Nilai pengembalian </li><li>  Terdiri dari tidak lebih dari 50 baris </li><li>  Dia idempoten dan, jika mungkin, murni </li></ul><br>  Bagi banyak dari Anda, persyaratan ini mungkin tampak terlalu keras.  Namun, saya berjanji: jika fungsi Anda mematuhi aturan-aturan ini, mereka akan menjadi sangat indah sehingga mereka bahkan akan menusuk unicorn dengan air mata.  Di bawah ini saya akan mencurahkan bagian untuk masing-masing elemen dari daftar di atas, dan kemudian saya akan menyelesaikan cerita dengan menceritakan bagaimana mereka selaras satu sama lain dan membantu menciptakan fungsi yang baik. <br><br>  <b>Penamaan</b> <br><br>  Berikut adalah kutipan favorit saya tentang hal ini, sering dikaitkan secara keliru dengan Donald, tetapi sebenarnya dimiliki oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phil Carleton</a> : <br><blockquote>  Ada dua tantangan untuk ilmu komputer: pembatalan dan penamaan cache. </blockquote>  Tidak peduli seberapa konyol kedengarannya, memberi nama adalah hal yang sulit.  Berikut adalah contoh nama fungsi "buruk": <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_knn_from_df</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Sekarang, nama-nama buruk menjumpai saya hampir di mana-mana, tetapi contoh ini diambil dari bidang Ilmu Data (lebih tepatnya, pembelajaran mesin), di mana para praktisi biasanya menulis kode dalam buku catatan Jupyter, dan kemudian mencoba menyusun program yang dapat dicerna dari sel-sel ini. <br><br>  Masalah pertama dengan nama fungsi ini adalah ia menggunakan singkatan.  <b>Lebih baik menggunakan kata-kata bahasa Inggris penuh, daripada singkatan dan bukan singkatan terkenal</b> .  Satu-satunya alasan saya ingin mempersingkat kata-kata adalah tidak membuang waktu mengetik terlalu banyak teks, tetapi <i>setiap editor modern memiliki fungsi pelengkapan otomatis</i> , jadi Anda harus mengetikkan nama lengkap fungsi hanya sekali.  Singkatan adalah masalah, karena sering khusus untuk bidang subjek.  Dalam kode di atas, <code>knn</code> berarti "tetangga terdekat K," dan <code>df</code> berarti "DataFrame," struktur data yang biasa digunakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panda</a> library.  Jika seorang programmer yang tidak mengetahui singkatan-singkatan ini membaca kode, maka ia hampir tidak akan mengerti apa-apa dalam nama fungsinya. <br><br>  Ada dua kelemahan kecil lagi dalam nama fungsi ini.  Pertama, kata <code>"get"</code> berlebihan.  Dalam fungsi yang paling kompeten namanya, segera jelas bahwa fungsi ini mengembalikan sesuatu, yang secara khusus tercermin dalam namanya.  <code>from_d</code> f juga tidak diperlukan.  Baik di dock fungsi, atau (jika berada di pinggiran) dalam anotasi tipe, tipe parameter akan dijelaskan jika informasi <i>ini belum jelas dari nama parameter</i> . <br><br>  Jadi bagaimana kita mengganti nama fitur ini?  Hanya: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k_nearest_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dataframe)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Sekarang bahkan orang awam mengerti apa yang sedang dihitung dalam fungsi ini, dan nama parameter <code>(dataframe)</code> tidak menyisakan argumen mana yang harus diteruskan ke sana. <br><br><h3>  Tanggung jawab tunggal </h3><br>  Mengembangkan gagasan Bob Martin, saya akan mengatakan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip tanggung jawab tunggal</a> berlaku untuk fungsi tidak kurang dari kelas dan modul (tentang apa yang awalnya ditulis Mr. Martin).  Menurut prinsip ini (dalam kasus kami), suatu fungsi harus memiliki satu tanggung jawab.  Artinya, dia harus melakukan satu dan hanya satu hal.  Salah satu alasan yang paling meyakinkan untuk ini: jika suatu fungsi hanya melakukan satu hal, maka harus ditulis ulang dalam satu-satunya kasus: jika hal ini harus dilakukan dengan cara yang baru.  Ini juga menjadi jelas ketika suatu fungsi dapat dihapus;  jika, membuat perubahan di tempat lain, kami memahami bahwa tugas satu-satunya fungsi tidak lagi relevan, maka kami hanya akan menyingkirkannya. <br><br>  Lebih baik memberi contoh.  Berikut adalah fungsi yang melakukan lebih dari satu "hal": <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list_of_numbers)</span></span></span><span class="hljs-function">:</span></span> sum = sum(list_of_numbers) mean = statistics.mean(list_of_numbers) median = statistics.median(list_of_numbers) mode = statistics.mode(list_of_numbers) print(<span class="hljs-string"><span class="hljs-string">'-----------------Stats-----------------'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'SUM: {}'</span></span>.format(sum) print(<span class="hljs-string"><span class="hljs-string">'MEAN: {}'</span></span>.format(mean) print(<span class="hljs-string"><span class="hljs-string">'MEDIAN: {}'</span></span>.format(median) print(<span class="hljs-string"><span class="hljs-string">'MODE: {}'</span></span>.format(mode)</code> </pre> <br>  Yaitu, dua: menghitung satu set statistik pada daftar angka dan menampilkannya dalam <code>STDOUT</code> .  Suatu fungsi melanggar aturan: harus ada satu alasan spesifik mengapa itu perlu diubah.  Dalam hal ini, ada dua alasan yang jelas mengapa ini diperlukan: apakah Anda perlu menghitung statistik baru atau berbeda, atau Anda perlu mengubah format output.  Oleh karena itu, lebih baik menulis ulang fungsi ini dalam bentuk dua fungsi terpisah: satu akan melakukan perhitungan dan mengembalikan hasilnya, dan yang lain akan menerima hasil ini dan menampilkannya di konsol.  <i>Suatu fungsi (atau lebih tepatnya, ia memiliki dua tanggung jawab) dengan jeroan ayam itik memberi kata <b>dan</b> dalam namanya</i> . <br><br>  Pemisahan ini juga sangat menyederhanakan pengujian fungsi, dan juga memungkinkan Anda untuk tidak hanya membaginya menjadi dua fungsi dalam modul yang sama, tetapi bahkan untuk memisahkan kedua fungsi ini menjadi modul yang sama sekali berbeda, jika sesuai.  Ini selanjutnya berkontribusi pada pengujian yang lebih bersih dan menyederhanakan dukungan kode. <br><br>  Bahkan, fungsi yang melakukan tepat dua hal jarang terjadi.  Lebih sering, Anda menemukan fungsi yang melakukan lebih banyak, lebih banyak operasi.  Sekali lagi, untuk alasan keterbacaan dan pengujian, fungsi "multi-stasiun" tersebut harus dibagi menjadi satu-tugas, yang masing-masing berisi satu aspek pekerjaan. <br><br><h3>  Docstrings </h3><br>  Tampaknya semua orang sadar bahwa ada dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP-8</a> yang memberikan rekomendasi tentang gaya kode Python, tetapi ada jauh lebih sedikit orang di antara kita yang tahu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP-257</a> , di mana rekomendasi yang sama diberikan mengenai dockstrings.  Agar tidak menceritakan kembali isi PEP-257, saya mengirim Anda sendiri ke dokumen ini - baca di waktu luang Anda.  Namun, ide utamanya adalah sebagai berikut: <br><br><ul><li>  Setiap fungsi membutuhkan string doc. </li><li>  Harus memperhatikan tata bahasa dan tanda baca;  tulis kalimat lengkap </li><li>  Docstring dimulai dengan deskripsi singkat (dalam satu kalimat) tentang apa fungsi tidak. </li><li>  Docstring diformulasikan dalam gaya preskriptif dan bukan deskriptif </li></ul><br>  Semua poin ini mudah diikuti ketika menulis fitur.  Hanya menulis dokumen harus menjadi kebiasaan, dan mencoba menulisnya sebelum melanjutkan dengan kode fungsi itu sendiri.  Jika Anda tidak dapat menulis string dokumen yang jelas menjelaskan fungsi, ini adalah alasan yang baik untuk memikirkan mengapa Anda menulis fungsi ini. <br><br><h3>  Nilai pengembalian </h3><br>  Fungsi dapat (dan <i>harus</i> ) diartikan sebagai program mandiri kecil.  Mereka mengambil beberapa input dalam bentuk parameter dan mengembalikan hasilnya.  Parameter, tentu saja, adalah opsional.  <i>Tetapi nilai kembali diperlukan dari sudut pandang struktur internal Python</i> .  Jika Anda bahkan mencoba untuk menulis fungsi yang tidak mengembalikan nilai, Anda tidak bisa.  Jika fungsi tersebut bahkan tidak mengembalikan nilai, maka juru bahasa Python akan "memaksa" untuk mengembalikan <code>None</code> .  Tidak percaya  Coba sendiri: <br><br><pre> <code class="python hljs">❯ python3 Python <span class="hljs-number"><span class="hljs-number">3.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (default, Jul <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">55</span></span>) [Clang <span class="hljs-number"><span class="hljs-number">9.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (clang<span class="hljs-number"><span class="hljs-number">-902.0</span></span><span class="hljs-number"><span class="hljs-number">.39</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>)] on darwin Type <span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-string"><span class="hljs-string">"copyright"</span></span>, <span class="hljs-string"><span class="hljs-string">"credits"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"license"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> ... print(a + b) ... &gt;&gt;&gt; b = add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; b &gt;&gt;&gt; b <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Seperti yang Anda lihat, nilai <code>b</code> pada dasarnya <code>None</code> .  Jadi, bahkan jika Anda menulis fungsi tanpa pernyataan kembali, itu masih akan mengembalikan sesuatu.  Dan itu seharusnya.  Bagaimanapun, ini adalah program kecil, bukan?  Seberapa bermanfaatkah program yang tidak memiliki kesimpulan - dan karena itu tidak mungkin menilai apakah program ini dijalankan dengan benar?  Tetapi yang paling penting, bagaimana Anda akan <i>menguji</i> program semacam itu? <br><br>  Saya bahkan tidak takut untuk mengatakan yang berikut: setiap fungsi harus mengembalikan nilai yang bermanfaat, setidaknya untuk kepentingan pengujian.  Kode yang saya tulis harus diuji (ini tidak dibahas).  Bayangkan saja bagaimana pengujian kikuk dari fungsi <code>add</code> atas dapat berubah (petunjuk: Anda harus mengarahkan input / output, setelah itu semuanya akan serba salah segera).  Selain itu, dengan mengembalikan nilai, kita dapat mengaitkan metode dan karenanya menulis kode seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'foo.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.strip().lower().endswith(<span class="hljs-string"><span class="hljs-string">'cat'</span></span>): <span class="hljs-comment"><span class="hljs-comment"># ...     - </span></span></code> </pre> <br>  String <code>if line.strip().lower().endswith('cat'):</code> berfungsi karena masing-masing metode string ( <code>strip()</code> , <code>lower()</code> , <code>endswith()</code> ) mengembalikan string sebagai akibat dari memanggil fungsi. <br><br>  Berikut adalah beberapa alasan umum yang dapat diberikan oleh seorang programmer ketika menjelaskan mengapa fungsi yang ia tulis tidak mengembalikan nilai: <br><blockquote>  “Itu hanya [semacam operasi yang terkait dengan input / output, misalnya, menyimpan nilai dalam database].  Di sini saya tidak dapat mengembalikan sesuatu yang bermanfaat. " </blockquote>  Saya tidak setuju.  Fungsi dapat mengembalikan True jika operasi selesai dengan sukses. <br><blockquote>  "Di sini kita mengubah salah satu parameter yang tersedia, menggunakannya sebagai parameter referensi." "" </blockquote>  Inilah dua poin.  Pertama, lakukan yang terbaik untuk tidak melakukan ini.  Kedua, menyediakan fungsi dengan semacam argumen hanya untuk mengetahui bahwa itu telah berubah sangat mengejutkan, dan hanya berbahaya paling buruk.  Sebagai gantinya, seperti halnya metode string, cobalah untuk mengembalikan instance baru dari parameter yang sudah mencerminkan perubahan yang diterapkan padanya.  Bahkan jika ini tidak dapat dilakukan, karena membuat salinan dari beberapa parameter penuh dengan biaya yang berlebihan, Anda masih dapat memutar kembali ke opsi "Return <code>True</code> jika operasi selesai dengan sukses" yang diusulkan di atas. <br><blockquote>  “Saya perlu mengembalikan beberapa nilai.  Tidak ada nilai tunggal yang dalam hal ini disarankan untuk dikembalikan. " </blockquote>  Argumen ini agak dibuat-buat, tetapi saya sudah mendengarnya.  Jawabannya, tentu saja, persis apa yang ingin dilakukan penulis - tetapi tidak tahu caranya: <i>menggunakan tuple untuk mengembalikan beberapa nilai</i> . <br><br>  Akhirnya, argumen terkuat bahwa lebih baik mengembalikan nilai yang berguna dalam hal apa pun adalah bahwa pemanggil selalu dapat dibenarkan mengabaikan nilai-nilai ini.  Singkatnya, mengembalikan nilai dari suatu fungsi hampir pasti merupakan ide yang bagus, dan sangat tidak mungkin bahwa kita akan merusak apa pun dengan cara ini, bahkan dalam basis kode yang ada. <br><br><h3>  Panjang fungsi </h3><br>  Saya mengakui lebih dari sekali bahwa saya cukup bodoh.  Saya dapat menyimpan sekitar tiga hal di kepala saya secara bersamaan.  Jika Anda membiarkan saya membaca fungsi 200-line dan bertanya apa fungsinya, saya mungkin akan menatapnya setidaknya selama 10 detik.  <b>Panjang fungsi secara langsung memengaruhi keterbacaannya dan karenanya mendukungnya</b> .  Karena itu, cobalah untuk membuat fungsi Anda singkat.  50 baris - nilai yang diambil sepenuhnya dari langit-langit, tetapi tampaknya masuk akal bagi saya.  (Saya harap) bahwa sebagian besar fungsi yang Anda tulis akan jauh lebih pendek. <br><br>  Jika suatu fungsi mematuhi Prinsip Tanggung Jawab Tunggal, maka itu kemungkinan akan cukup singkat.  Jika sedang membaca atau idempoten (kami akan membicarakan ini) di bawah - maka, mungkin, itu juga akan menjadi singkat.  Semua ide ini dikombinasikan secara harmonis satu sama lain dan membantu menulis kode yang baik dan bersih. <br><br>  Jadi apa yang harus dilakukan jika fungsi Anda terlalu lama?  <b>REFACTOR!</b>  Anda mungkin harus melakukan refactoring sepanjang waktu, bahkan jika Anda tidak tahu istilahnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Refactoring</a> hanya mengubah struktur program, tanpa mengubah perilakunya.  Oleh karena itu, mengekstraksi beberapa baris kode dari fungsi panjang dan mengubahnya menjadi fungsi independen adalah salah satu jenis refactoring.  Ternyata ini juga merupakan cara paling umum dan tercepat untuk secara singkat mempersingkat fungsi yang panjang.  Karena Anda memberi fungsi baru ini nama yang sesuai, kode yang dihasilkan jauh lebih mudah dibaca.  Saya menulis seluruh buku tentang refactoring (pada kenyataannya, saya melakukannya sepanjang waktu), jadi saya tidak akan memerinci di sini.  Ketahuilah bahwa jika Anda memiliki fungsi yang terlalu panjang, Anda harus mengubahnya. <br><br><h3>  Idempotensi dan Kebersihan Fungsional </h3><br>  Judul bagian ini mungkin tampak sedikit menakutkan, tetapi secara konseptual bagian ini sederhana.  Fungsi idempoten dengan set argumen yang sama selalu mengembalikan nilai yang sama, terlepas dari berapa kali dipanggil.  Hasilnya tidak bergantung pada variabel non-lokal, variabilitas argumen, atau pada data apa pun yang berasal dari aliran input / output.  Fungsi <code>add_three(number)</code> ini idempoten: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Terlepas dari berapa kali kita memanggil <code>add_three(7)</code> , jawabannya akan selalu 10. Tapi kasus lain adalah fungsi yang tidak idempoten: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" 3 + ,  ."""</span></span> number = int(input(<span class="hljs-string"><span class="hljs-string">'Enter a number: '</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Fungsi ini terus terang dibuat bukan idempoten, karena nilai kembali fungsi tergantung pada input / output, yaitu, pada nomor yang dimasukkan oleh pengguna.  Tentu saja, dengan panggilan berbeda untuk <code>add_three()</code> kembali akan berbeda.  Jika kita memanggil fungsi ini dua kali, maka pengguna dalam kasus pertama dapat memasukkan 3, dan pada yang kedua - 7, dan kemudian dua panggilan ke <code>add_three()</code> akan mengembalikan masing-masing 6 dan 10. <br><br>  Di luar pemrograman, ada juga contoh idempotensi - misalnya, tombol naik lift dirancang sesuai dengan prinsip ini.  Dengan menekannya untuk pertama kali, kami "memberi tahu" lift yang ingin kami naiki.  Karena tombolnya idempoten, tidak peduli berapa banyak Anda menekannya nanti, tidak ada hal buruk yang akan terjadi.  Hasilnya akan selalu sama. <br><br><h3>  Mengapa idempotensi begitu penting </h3><br>  Dukungan testability dan usability.  Fungsi idempoten mudah diuji, karena dijamin akan mengembalikan hasil yang sama jika Anda memanggilnya dengan argumen yang sama.  Pengujian turun untuk memverifikasi bahwa dengan berbagai panggilan, fungsi selalu mengembalikan nilai yang diharapkan.  Selain itu, tes ini akan cepat: kecepatan tes adalah masalah penting yang sering diabaikan dalam pengujian unit.  Dan refactoring ketika bekerja dengan fungsi idempoten umumnya mudah.  Tidak masalah bagaimana Anda mengubah kode di luar fungsi - hasil memanggilnya dengan argumen yang sama akan selalu sama. <br><br><h3>  Apa fungsi "murni"? </h3><br>  Dalam pemrograman fungsional, fungsi dianggap murni jika, <i>pertama</i> , idempoten, dan <i>kedua</i> , tidak menyebabkan <b>efek samping yang</b> diamati.  Jangan lupa: suatu fungsi idempoten jika selalu mengembalikan hasil yang sama dengan serangkaian argumen tertentu.  Namun, ini tidak berarti bahwa fungsi tersebut tidak dapat mempengaruhi komponen lain - misalnya, variabel non-lokal atau aliran input / output.  Misalnya, jika versi idempoten dari fungsi <code>add_three(number)</code> atas mengeluarkan hasil ke konsol, dan hanya mengembalikannya, itu akan tetap dianggap idempoten, karena ketika mengakses aliran input / output, operasi akses ini tidak mempengaruhi nilai yang dikembalikan. dari fungsi.  Panggilan <code>print()</code> hanyalah <i>efek samping</i> : interaksi dengan seluruh program atau sistem, yang terjadi bersamaan dengan nilai pengembalian. <br><br>  Mari kita kembangkan contoh kita sedikit dengan <code>add_three(number)</code> .  Anda dapat menulis kode berikut untuk menentukan berapa kali <code>add_three(number)</code> telah dipanggil: <br><br><pre> <code class="python hljs">add_three_calls = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ** + 3."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> add_three_calls print(<span class="hljs-string"><span class="hljs-string">f'Returning </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{number + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">'</span></span>) add_three_calls += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""",     *add_three*."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add_three_calls</code> </pre> <br>  Sekarang kita menjalankan output ke konsol (ini adalah efek samping) dan mengubah variabel non-lokal (efek samping lain), tetapi karena tak satu pun dari ini mempengaruhi nilai yang dikembalikan oleh fungsi, itu tetap idempoten. <br><br>  Fungsi murni tidak memiliki efek samping.  Itu tidak hanya tidak menggunakan "data eksternal" ketika menghitung nilai, tetapi tidak berinteraksi dengan sisa program / sistem, hanya menghitung dan mengembalikan nilai yang ditentukan.  Oleh karena itu, walaupun definisi baru kita tentang <code>add_three(number)</code> tetap idempoten, fungsi ini tidak lagi murni. <br><br>  Dalam fungsi murni tidak ada instruksi logging atau <code>print()</code> panggilan.  Saat bekerja, mereka tidak mengakses database dan tidak menggunakan koneksi internet.  Jangan mengakses atau memodifikasi variabel non-lokal.  <b>Dan jangan panggil fungsi non-murni lainnya</b> . <br><br>  Singkatnya, mereka tidak memiliki "tindakan jangka panjang yang mengerikan", seperti yang diungkapkan oleh kata-kata Einstein (tetapi dalam konteks ilmu komputer, bukan fisika).  Mereka tidak mengubah dengan cara apa pun sisa program atau sistem.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman imperatif</a> (yang adalah apa yang Anda lakukan saat menulis kode dengan Python), fungsi-fungsi tersebut adalah yang paling aman.  Mereka dikenal karena kemampuannya untuk diuji dan kemudahan dukungan;  selain itu, karena mereka idempoten, pengujian fungsi-fungsi tersebut dijamin akan secepat mengeksekusi.  Tes itu sendiri juga sederhana: Anda tidak perlu terhubung ke database atau mensimulasikan sumber daya eksternal, menyiapkan konfigurasi awal kode, dan di akhir pekerjaan Anda tidak perlu membersihkan apa pun. <br><br>  Jujur, idempotensi dan kebersihan sangat diinginkan, tetapi tidak diperlukan.  ,         ,     ,     . , ,  ,    ,         .  ,        ,           . <br><br><h3>  Kesimpulan </h3><br>  Itu saja. ,     –   .          . ,   .    –    !          . ,  ,   ,       « ».     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426381/">https://habr.com/ru/post/id426381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426371/index.html">Audio digest: 17 bahan dan panduan praktis tentang topik akustik profesional</a></li>
<li><a href="../id426373/index.html">Membangun fungsi di konsol. Bagian 1</a></li>
<li><a href="../id426375/index.html">Analisis teknologi: tempat mulai bekerja pada lanskap paten</a></li>
<li><a href="../id426377/index.html">Game menggunakan grafik matematika, bukan grafik</a></li>
<li><a href="../id426379/index.html">Singkirkan ilusi</a></li>
<li><a href="../id426385/index.html">Mengapa Anda tidak belajar bahasa Inggris akademik</a></li>
<li><a href="../id426387/index.html">Grafik dalam Julia. Pola aneh, pantulan segitiga dari garis lurus dan konstruksi normals kucing bundar di ruang hampa</a></li>
<li><a href="../id426389/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 334 (7-14 Oktober, 2018)</a></li>
<li><a href="../id426391/index.html">PHP Digest No. 141 (1 - 15 Oktober 2018)</a></li>
<li><a href="../id426395/index.html">Biaya untuk barang-barang dari toko online asing akan dikenakan pada saat pembelian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>