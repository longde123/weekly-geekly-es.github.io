<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏿 🏼 💛 JavaScript引擎基础知识：常规形式和内联缓存。 第一部分 📌 👨🏽‍🎓 🗣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="朋友你好 4月底，我们将开设一门新课程“信息系统安全” 。 现在，我们想与您分享文章的翻译，这无疑对本课程非常有用。 原始文章可以在这里找到 。 

 本文介绍了关键基础，这些基础对所有JavaScript引擎都是通用的，而不仅仅是V8 （引擎的作者（ 本尼迪克特和Matias ）正在研究的V8）通...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript引擎基础知识：常规形式和内联缓存。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/"> 朋友你好  4月底，我们将开设一门新课程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“信息系统安全”</a> 。 现在，我们想与您分享文章的翻译，这无疑对本课程非常有用。 原始文章可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里找到</a> 。 <br><br> 本文介绍了关键基础，这些基础对所有JavaScript引擎都是通用的，而不仅仅是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V8</a> （引擎的作者（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本尼迪克特</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Matias</a> ）正在研究的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V8）</a>通用。 作为JavaScript开发人员，我可以说，对JavaScript引擎如何工作的更深入的了解将帮助您弄清楚如何编写有效的代码。 <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>注意</b> ：如果您喜欢观看演示文稿而不是阅读文章，请观看此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a> 。 如果不是，则跳过它并继续阅读。 </blockquote>  <b>管道（管道）JavaScript引擎</b> <br><br> 这一切都始于您编写JavaScript代码的事实。 之后，JavaScript引擎将处理源代码，并将其呈现为抽象语法树（AST）。 基于构造的AST，解释器最终可以开始工作并开始生成字节码。 太好了！ 这是引擎执行JavaScript代码的时刻。 <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br> 为了使其运行更快，您可以将字节码与分析数据一起发送到优化编译器。 优化编译器基于概要分析数据进行某些假设，然后生成高度优化的机器代码。 <br><br> 如果在某些时候这些假设不正确，则优化编译器将对代码进行非优化，然后返回到解释器阶段。 <br><br>  <b>JavaScript引擎中的解释器管道/编译器</b> <br><br> 现在，让我们仔细看一下执行JavaScript代码的管道部分，即解释和优化代码的地方，并看一下主要JavaScript引擎之间的一些区别。 <br><br> 一切的核心是包含解释器和优化编译器的管道。 解释器快速生成未优化的字节码，优化的编译器反过来工作时间更长，但是输出具有高度优化的机器代码。 <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br> 接下来是一个管道，显示了V8的工作原理，这是Chrome和Node.js使用的JavaScript引擎。 <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  V8中的解释器称为Ignition，它负责生成和执行字节码。 它收集性能分析数据，这些数据可在处理字节码时加快下一步的执行速度。 例如，当某个函数变<i>热时</i> （如果它频繁启动），则将生成的字节码和配置文件数据传输到TurboFan，即传输到优化编译器，以根据配置文件数据生成高度优化的机器代码。 <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br> 例如，在Firefox和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpiderNode中</a>使用的Mozilla的SpiderMonkey JavaScript引擎的工作方式略有不同。 它没有一个，但是有两个优化的编译器。 解释器被优化为一个基本的编译器（Baseline编译器），该编译器生成一些优化的代码。  IonMonkey编译器与代码执行期间收集的性能分析数据一起可以生成经过高度优化的代码。 如果推测优化失败，则IonMonkey将返回到基准代码。 <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra-Edge和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node-ChakraCore中</a>使用的Microsoft JavaScript引擎具有非常相似的结构，并使用了两个优化的编译器。 解释器在SimpleJIT中进行了优化（JIT代表“即时编译器”，Just-In-Time编译器会生成经过某种程度优化的代码。FullJIT与配置文件数据一起可以创建更高优化的代码。 <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  Safari和React Native使用的Apple JavaScript引擎JavaScriptCore（缩写为JSC）通常具有三种不同的优化编译器。  LLInt是针对基础编译器进行了优化的低层解释器，而基础编译器又针对DFG（数据流图）编译器进行了优化，并且已经针对FTL（Fast Than Light）编译器进行了优化。 <br><br> 为什么某些引擎比其他引擎具有更多的优化编译器？ 这完全是妥协。 解释器可以快速处理字节码，但是仅字节码并不是特别有效。 另一方面，优化的编译器的工作时间会更长一些，但是会产生更有效的机器代码。 这是在快速获取代码（解释器）或以最大性能（优化编译器）等待并运行代码之间的折衷方案。 某些引擎选择添加具有不同时间和效率特性的多个优化编译器，这使您可以对该折衷解决方案提供最佳控制，并了解内部设备额外复杂性的成本。 另一个权衡是内存使用情况；请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>以获得更好的理解。 <br><br> 我们刚刚研究了各种JavaScript引擎的解释器和优化器编译器管道之间的主要区别。 尽管存在这些高级差异，但是所有JavaScript引擎都具有相同的体系结构：它们都具有解析器和某种解释器/编译器管道。 <br><br>  <b>JavaScript对象模型</b> <br><br> 让我们看看JavaScript引擎还有哪些共同点，以及它们使用了哪些技巧来加快对JavaScript对象属性的访问？ 事实证明，所有主引擎都以类似的方式执行此操作。 <br><br>  ECMAScript规范将所有对象定义为具有与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">属性</a>属性匹配的字符串键的字典。 <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br> 除了<code>[[Value]]</code> ，该规范还定义了以下属性： <br><br><ul><li>  <code>[[Writable]]</code>确定是否可以重新分配属性； </li><li>  <code>[[Enumerable]]</code>确定属性是否在for-in循环中显示； </li><li>  <code>[[Configurable]]</code>确定是否可以删除属性。 </li></ul><br> 符号<code>[[  ]]</code>看起来很奇怪，但这是规范如何描述JavaScript中的属性。 您仍然可以使用<code>Object.getOwnPropertyDescriptor</code> API获得JavaScript中任何给定对象和属性的以下属性属性： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br> 好的，所以JavaScript定义了对象。 数组呢？ <br><br> 您可以将数组想象为特殊对象。 唯一的区别是数组具有特殊的索引处理。 在这里，数组索引是ECMAScript规范中的一个特殊术语。  JavaScript对数组中元素的数量有限制-最多2³²− 1。 数组索引是该范围内的任何可用索引，即0到2³²− 2之间的任何整数值。 <br><br> 另一个区别是数组具有<code>length</code>的神奇特性。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// → 2 array[2] = 'c'; array.length; // → 3</span></span></code> </pre> <br> 在此示例中，数组在创建时的长度为2。 然后，我们为索引2分配另一个元素，长度自动增加。 <br><br>  JavaScript定义数组以及对象。 例如，所有键（包括数组索引）都明确表示为字符串。 数组的第一个元素存储在键“ 0”下。 <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  <code>length</code>属性只是另一个无法枚举和不可配置的属性。 <br><br> 将元素添加到数组后，JavaScript会自动更新<code>length</code>属性的<code>[[Value]]</code>属性的属性。 <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br> 通常，我们可以说数组的行为类似于对象。 <br><br>  <b>优化属性访问</b> <br><br> 现在我们知道了如何在JavaScript中定义对象，让我们看一下JavaScript引擎如何使您有效地使用对象。 <br><br> 在日常生活中，获得财产是最常见的操作。 对于发动机而言，快速执行此操作非常重要。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>表格</b> <br><br> 在JavaScript程序中，很常见的做法是将相同的属性键分配给许多对象。 他们说这些物体具有相同的<i>形状</i> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br> 同样常见的机制是访问具有相同形式的对象的属性： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br> 知道了这一点，JavaScript引擎可以根据对象的形状优化对对象属性的访问。 看看它是如何工作的。 <br><br> 假设我们有一个具有属性x和y的对象，它使用前面讨论的字典数据结构； 它包含指向它们各自属性的键字符串。 <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br> 如果您访问诸如<code>object.y,</code>类的属性，则JavaScript引擎将使用键<code>'y'</code>搜索JSObject，然后加载与该查询匹配的属性，最后返回<code>[[Value]]</code> 。 <br><br> 但是这些属性在哪里存储在内存中？ 我们应该将它们存储为JSObject的一部分吗？ 如果这样做，以后我们将看到更多这种形式的对象，在这种情况下，由于在相同形式的所有对象中都重复了属性名称，因此在JSObject本身中存储包含属性和属性名称的完整字典是浪费空间。 这将导致大量重复并导致内存分配错误。 为了优化，引擎分别存储对象的形状。 <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br> 此<code>Shape</code>包含<code>[[Value]]</code>之外的所有属性名称和属性。 相反，该表单包含JSObject内部的偏移值，因此JavaScript引擎知道在哪里寻找这些值。 每个具有通用表单的JSObject都指示该表单的特定实例。 现在，每个JSObject只需要存储对象唯一的值。 <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br> 只要有很多对象，优势就会变得显而易见。 它们的数量无关紧要，因为如果它们只有一种形式，那么我们只保存一次有关该形式和属性的信息。 <br><br> 所有JavaScript引擎都使用表单作为优化手段，但它们并不直接将其命名为<code>shapes</code> ： <br><br><ol><li> 学术文档将它们称为“隐藏类”（类似于JavaScript类）； </li><li>  V8称为地图； </li><li> 查克拉称它们为类型； </li><li>  JavaScriptCore称它们为Structures； </li><li>  SpiderMonkey称它们为Shapes。 </li></ol><br> 在本文中，我们继续称它们为<code>shapes</code> 。 <br><br>  <b>过渡链和树木</b> <br><br> 如果您有一个特定形状的对象，但是您向其中添加了一个新属性，会发生什么？  JavaScript引擎如何定义新表格？ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> 表单在JavaScript引擎中创建所谓的过渡链。 这是一个例子： <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br> 对象最初没有属性；它对应于一个空表格。 以下表达式将值为5的属性<code>'x'</code>添加到该对象，然后引擎转到包含属性<code>'x'</code>的形式，并将值5添加到JSObject的第一个偏移量0。下一行添加属性<code>'y'</code> ，然后引擎转到下一个一个既包含<code>'x'</code>又包含<code>'y'</code>的表单，并且还向偏移量1的JSObject添加值6。 <br><blockquote>  <b>注意</b> ：添加属性的顺序会影响表单。 例如，{x：4，y：5}的格式将不同于{y：5，x：4}。 <br></blockquote> 我们甚至不需要为每个表单存储整个属性表。 而是，每个表单都只需要知道他们要包括在其中的新属性。 例如，在这种情况下，我们无需以后一种形式存储有关“ x”的信息，因为可以在链中的较早位置找到它。 为此，该表格将与其先前的表格合并。 <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br> 如果您在JavaScript代码中编写<code>ox</code> ，则JavaScript会在过渡链中查找<code>'x'</code>属性，直到它检测到已经具有<code>'x'</code>属性的表单为止。 <br><br> 但是，如果不可能创建过渡链会怎样？ 例如，如果您有两个空对象并向它们添加不同的属性，会发生什么？ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> 在这种情况下，会出现一个分支，而不是过渡链，而是获得过渡树： <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br> 我们创建一个空对象<code>a</code>并向其中添加属性<code>'x'</code> 。 结果，我们有了一个包含单个值和两种形式的<code>JSObject</code> ：空和具有单个<code>'x'</code>属性的形式。 <br><br> 第二个示例从以下事实开始：我们有一个空对象<code>b</code> ，但随后添加了另一个属性<code>'y'</code> 。 结果，这里我们得到两个形式的链，但是最后我们得到了三个链。 <br><br> 这是否意味着我们总是以空表格开头？ 不一定。 引擎使用一些对象文字优化，这些文字已经包含属性。 假设我们添加x，从一个空的对象常量开始，或者我们有一个已经包含<code>x</code>的对象常量： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br> 在第一个示例中，我们以一个空的形式开始，然后转到一个也包含<code>x</code>的链，就像我们之前看到的那样。 <br><br> 对于<code>object2</code>有意义的是直接创建从一开始就已经具有x的对象，而不是从一个空对象和一个过渡开始。 <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br> 包含属性<code>'x'</code>的对象的文字从一开始就以包含<code>'x'</code>的形式开头，并且有效地跳过了空形式。 这（至少）是V8和SpiderMonkey所做的。 优化缩短了转换链，使从文字中组装对象更加方便。 <br><br> 本尼迪克特（Benedict）在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React</a>上惊人的应用程序多态性博客文章中谈到了这些细微差别如何影响性能。 <br><br> 进一步，您将看到具有属性<code>'x'</code> ， <code>'y'</code> ， <code>'z'</code>的三维对象的点的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> 正如您之前所了解的，我们创建一个在内存中具有三种形式的对象（不计算空形式）。 为了访问该对象的<code>'x'</code>属性，例如，如果您在程序中编写了<code>point.x</code> ，则JavaScript引擎必须遵循一个链表：从最底部的表单开始，然后逐渐向上移动至具有<code>'x'</code>的表单在最顶端。 <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br> 结果非常缓慢，尤其是如果您经常这样做并且具有对象的许多属性时。 属性的停留时间为<code>O(n)</code> ，即它是与对象的属性数量相关的线性函数。 为了加快属性搜索的速度，JavaScript引擎添加了ShapeTable数据结构。  ShapeTable是一个字典，其中的键以某种方式与表格进行映射，并产生所需的属性。 <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br> 稍等片刻，现在我们返回字典搜索...这正是我们将表单放在首位时的开始！ 那么，为什么我们还要关心表格呢？ <br> 事实是表单有助于另一种称为“ <i>内联缓存”的</i>优化<i>。</i> <br><br> 我们将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>文章的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分中</a>讨论内联缓存或IC的概念，现在我们想邀请您参加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">免费的开放式网络研讨会</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研讨会</a>将于4月9日由著名的病毒分析师和兼职老师<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexander Kolesnikov</a>举行。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446446/">https://habr.com/ru/post/zh-CN446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446434/index.html">Zimbra协作套件扩展</a></li>
<li><a href="../zh-CN446436/index.html">如何生成有关您未来产品潜在消费者需求的假设</a></li>
<li><a href="../zh-CN446438/index.html">我们的Gateway API创建经验</a></li>
<li><a href="../zh-CN446440/index.html">《快速反应》一书。 React，JSX，Redux和GraphQL中的Web应用程序»</a></li>
<li><a href="../zh-CN446444/index.html">从Skype到WebRTC：我们如何组织网络视频通信</a></li>
<li><a href="../zh-CN446448/index.html">进行问题访谈以识别消费者需求的5条基本规则</a></li>
<li><a href="../zh-CN446452/index.html">月球飞行任务“ Bereshit”-2019年4月4日，完成向月球轨道的过渡，提前7天飞行，进行了6次机动和1次着陆</a></li>
<li><a href="../zh-CN446454/index.html">Golang Web服务器开发-从简单到复杂</a></li>
<li><a href="../zh-CN446458/index.html">基于Arduino Nano的通用DRO-shDRO。 第二部分</a></li>
<li><a href="../zh-CN446460/index.html">食品设计文摘2019年3月</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>