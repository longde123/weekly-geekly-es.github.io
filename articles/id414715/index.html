<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☄️ 🚓 😿 Kompilasi anotasi waktu menggunakan @Implement sebagai contoh 📀 🕴🏿 👝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita semua senang menangkap kesalahan pada tahap kompilasi, alih-alih pengecualian runtime. Cara termudah untuk memperbaikinya adalah bahwa kompiler i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilasi anotasi waktu menggunakan @Implement sebagai contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Kita semua senang menangkap kesalahan pada tahap kompilasi, alih-alih pengecualian runtime.  Cara termudah untuk memperbaikinya adalah bahwa kompiler itu sendiri menunjukkan semua tempat yang perlu diperbaiki.  Meskipun sebagian besar masalah hanya dapat dideteksi ketika program dimulai, kami masih berusaha melakukan ini sesegera mungkin. <a name="habracut"></a>  Dalam blok inisialisasi kelas, dalam konstruktor objek, pada panggilan pertama metode, dll.  Dan kadang-kadang kita beruntung, dan bahkan pada tahap kompilasi kita cukup tahu untuk memeriksa program untuk kesalahan tertentu. <br><br>  Pada artikel ini saya ingin berbagi pengalaman menulis satu tes tersebut.  Lebih tepatnya, membuat anotasi yang dapat membuang kesalahan, seperti yang dilakukan kompiler.  Menilai oleh kenyataan bahwa tidak ada begitu banyak informasi tentang topik ini di RuNet, situasi bahagia yang dijelaskan di atas tidak sering. <br><br>  Saya akan menjelaskan algoritma verifikasi umum, serta semua langkah dan nuansa yang saya habiskan waktu dan sel saraf. <br><br><h3>  Pernyataan masalah </h3><br>  Di bagian ini, saya akan memberikan contoh menggunakan anotasi ini.  Jika Anda sudah tahu apa yang ingin Anda lakukan, Anda dapat melewatinya dengan aman.  Saya yakin ini tidak akan mempengaruhi kelengkapan presentasi. <br><br>  Sekarang kita akan berbicara lebih banyak tentang meningkatkan keterbacaan kode daripada memperbaiki bug.  Sebuah contoh, bisa dikatakan, dari kehidupan, atau lebih tepatnya dari proyek hobi saya. <br><br>  Misalkan ada kelas UnitManager, yang, pada kenyataannya, adalah kumpulan unit.  Ini memiliki metode untuk menambah, menghapus, mendapatkan unit, dll.  Saat menambahkan unit baru, manajer memberinya id.  Generasi id didelegasikan ke kelas RotateCounter, yang mengembalikan angka dalam rentang yang diberikan.  Dan ada masalah kecil, RotateCounter tidak bisa tahu apakah id yang dipilih gratis.  Menurut prinsip inversi dependensi, Anda dapat membuat antarmuka, dalam kasus saya ini adalah RotateCounter.IClient, yang memiliki metode tunggal isValueFree (), yang menerima id dan mengembalikan true jika id gratis.  Dan UnitManager mengimplementasikan antarmuka ini, membuat instance dari RotateCounter dan meneruskannya sendiri sebagai klien. <br><br>  Saya melakukan hal itu.  Tetapi, setelah membuka sumber UnitManager beberapa hari setelah menulis, saya menjadi orang yang mudah bodoh setelah melihat metode isValueFree (), yang tidak benar-benar cocok dengan logika untuk UnitManager.  Akan lebih sederhana jika memungkinkan untuk menentukan antarmuka mana yang mengimplementasikan metode ini.  Sebagai contoh, dalam C #, dari mana saya datang ke Jawa, implementasi antarmuka eksplisit membantu untuk mengatasi masalah ini.  Dalam hal ini, pertama, Anda dapat memanggil metode hanya dengan gips eksplisit ke antarmuka.  Kedua, dan yang lebih penting dalam hal ini, nama antarmuka (dan tanpa pengubah akses) secara eksplisit ditunjukkan dalam tanda tangan metode, misalnya: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Salah satu solusinya adalah menambahkan anotasi dengan nama antarmuka yang mengimplementasikan metode ini.  Sesuatu seperti <code>@Override</code> , hanya dengan antarmuka.  Saya setuju, Anda dapat menggunakan kelas batin anonim.  Dalam kasus ini, sama seperti di C #, metode tidak bisa dipanggil pada objek, dan Anda dapat langsung melihat antarmuka mana yang diimplementasikan.  Tetapi, ini akan meningkatkan jumlah kode, oleh karena itu, menurunkan keterbacaan.  Ya, dan Anda perlu mendapatkannya dari kelas - buat getter atau bidang publik (toh, tidak ada overload pernyataan cor di Jawa juga).  Bukan pilihan yang buruk, tapi saya tidak suka itu. <br><br>  Pada awalnya, saya berpikir bahwa di Jawa, seperti dalam C #, anotasi adalah kelas lengkap dan dapat diwarisi darinya.  Dalam hal ini, Anda hanya perlu membuat anotasi yang diwarisi dari <code>@Override</code> .  Tetapi ini tidak benar, dan saya harus terjun ke dunia cek yang menakjubkan dan menakutkan pada tahap kompilasi. <br><br><div class="spoiler">  <b class="spoiler_title">Kode sampel UnitManager</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Sedikit teori </h3><br>  Saya akan segera melakukan reservasi, semua metode di atas adalah turunan, oleh karena itu, untuk singkatnya, saya akan menunjukkan nama metode dengan nama jenis dan tanpa parameter: <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  Pemrosesan elemen pada tahap kompilasi melibatkan kelas prosesor khusus.  Ini adalah kelas-kelas yang mewarisi dari <code>javax.annotation.processing.AbstractProcessor</code> (Anda hanya dapat mengimplementasikan antarmuka <code>javax.annotation.processing.Processor</code> ).  Anda dapat membaca lebih lanjut tentang prosesor di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Metode yang paling penting di dalamnya adalah proses.  Di mana kita bisa mendapatkan daftar semua elemen beranotasi dan melakukan pemeriksaan yang diperlukan. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Pada awalnya, sungguh naif, saya berpikir bahwa bekerja dengan tipe pada tahap kompilasi dilakukan dalam hal refleksi, tapi ... tidak.  Semuanya berdasarkan elemen di sana. <br><br>  <b>Elemen</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.lang.model.element.Element</a> ) - antarmuka utama untuk bekerja dengan sebagian besar elemen struktural bahasa.  Suatu elemen memiliki turunan yang lebih tepat menentukan sifat-sifat elemen tertentu (untuk detail, lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.lang.model.type.TypeMirror</a> ) adalah sesuatu seperti Kelas &lt;?&gt; Dikembalikan oleh metode getClass ().  Misalnya, mereka dapat dibandingkan untuk mengetahui apakah jenis elemen cocok.  Anda bisa mendapatkannya menggunakan metode <code>Element.asType()</code> .  Tipe ini juga mengembalikan beberapa jenis operasi, seperti <code>TypeElement.getSuperclass()</code> atau <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Jenis</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.lang.model.util.Types</a> ) - Saya menyarankan Anda untuk melihat lebih dekat pada kelas ini.  Anda dapat menemukan banyak hal menarik di sana.  Intinya, ini adalah seperangkat utilitas untuk bekerja dengan tipe.  Misalnya, ini memungkinkan Anda untuk mendapatkan kembali TypeElement dari TypeMirror. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.lang.model.type.TypeKind</a> ) - sebuah enumerasi yang memungkinkan Anda untuk mengklarifikasi informasi jenis, periksa apakah jenisnya adalah array (ARRAY), tipe khusus (DEKLAR), jenis variabel (TYPEVAR), dll.  Anda bisa mendapatkannya melalui <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.lang.model.element.ElementKind</a> ) - enumerasi, memungkinkan Anda untuk mengklarifikasi informasi tentang elemen, memeriksa apakah elemen tersebut adalah paket (PAKET), kelas (KELAS), metode (METHOD), metode (METHOD), antarmuka (ANTARMUKA), dll. <br><br>  <b>Nama</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javax.lang.model.element.Name</a> ) - antarmuka untuk bekerja dengan nama elemen, dapat diperoleh melalui <code>Element.getSimpleName()</code> . <br><br>  Pada dasarnya, jenis ini cukup bagi saya untuk menulis algoritma verifikasi. <br><br>  Saya ingin mencatat fitur menarik lainnya.  Implementasi antarmuka Elemen di Eclipse ada di paket org.eclipse, misalnya, elemen yang mewakili metode bertipe <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Ini memberi saya ide bahwa antarmuka ini diimplementasikan oleh setiap IDE secara mandiri. <br><br><h3>  Algoritma validasi </h3><br>  Pertama, Anda perlu membuat anotasi itu sendiri.  Sudah banyak yang ditulis tentang itu (misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ), jadi saya tidak akan membahasnya secara rinci.  Saya hanya bisa mengatakan bahwa untuk contoh kita, kita perlu menambahkan dua anotasi <code>@Target</code> dan <code>@Retention</code> .  Yang pertama menunjukkan bahwa anotasi kami hanya dapat diterapkan pada metode, dan yang kedua bahwa anotasi hanya akan ada dalam kode sumber. <br><br>  Anotasi harus ditentukan antarmuka mana yang mengimplementasikan metode beranotasi (metode di mana anotasi diterapkan).  Ini dapat dilakukan dengan dua cara: tentukan nama lengkap antarmuka dengan string, misalnya <code>@Implement("com.ds.IInterface")</code> , atau lulus langsung kelas antarmuka: <code>@Implement(IInterface.class)</code> .  Cara kedua jelas lebih baik.  Dalam hal ini, kompiler akan memantau nama antarmuka yang benar.  Omong-omong, jika Anda memanggil <b>nilai</b> anggota ini <b>(),</b> maka saat menambahkan anotasi ke metode, Anda tidak perlu menentukan nama parameter ini secara eksplisit. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Kemudian kesenangan dimulai - penciptaan prosesor.  Dalam metode proses, kami mendapatkan daftar semua elemen beranotasi.  Kemudian kita mendapatkan anotasi itu sendiri dan artinya - antarmuka yang ditentukan.  Secara umum, kerangka kerja kelas prosesor terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Saya ingin mencatat bahwa Anda tidak bisa hanya mendapatkan dan mendapatkan nilai anotasi.  Saat Anda mencoba memanggil <code>annotation.value()</code> , <b>MirroredTypeException</b> akan dilempar, tetapi dari sana Anda bisa mendapatkan TypeMirror.  Metode curang ini, serta penerimaan nilai yang benar, saya temukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Pemeriksaan itu sendiri terdiri dari tiga bagian, jika setidaknya salah satu dari mereka gagal, maka Anda perlu menampilkan pesan kesalahan dan melanjutkan ke anotasi berikutnya.  Omong-omong, Anda dapat menampilkan pesan kesalahan menggunakan metode berikut: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  Langkah pertama adalah memeriksa apakah anotasi nilai adalah antarmuka.  Semuanya sederhana di sini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Selanjutnya, Anda perlu memeriksa apakah kelas tempat metode beranotasi benar-benar mengimplementasikan antarmuka yang ditentukan.  Awalnya saya dengan bodoh menerapkan tes ini dengan tangan saya.  Tetapi kemudian, dengan menggunakan saran yang bagus, saya melihat <b>Type</b> dan menemukan metode <code>Types.isSubtype()</code> sana, yang akan memeriksa seluruh pohon warisan dan mengembalikan true jika antarmuka yang ditentukan ada.  Yang penting, ini dapat bekerja dengan tipe generik, tidak seperti opsi pertama. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Terakhir, Anda perlu memastikan bahwa antarmuka memiliki metode dengan tanda tangan yang sama dengan yang dianotasi.  Saya ingin menggunakan metode <code>Types.isSubsignature()</code> , tetapi, sayangnya, itu tidak berfungsi dengan benar jika metode memiliki parameter tipe.  Jadi kami menyingsingkan lengan baju kami dan menulis semua cek dengan tangan kami.  Dan kami memiliki tiga dari mereka lagi.  Nah, lebih tepatnya, tanda tangan metode terdiri dari tiga bagian: nama metode, jenis nilai balik, dan daftar parameter.  Anda harus melalui semua metode antarmuka dan menemukan satu yang melewati ketiga pemeriksaan.  Akan menyenangkan untuk tidak lupa bahwa metode ini dapat diwarisi dari antarmuka lain dan secara rekursif melakukan pemeriksaan yang sama untuk antarmuka yang mendasarinya. <br><br>  Panggilan harus ditempatkan di akhir loop dalam metode proses, seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Dan metode haveMethod () sendiri terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  Lihat masalahnya?  Tidak  Dan dia ada di sana.  Faktanya adalah bahwa saya tidak dapat menemukan cara untuk mendapatkan parameter tipe aktual untuk antarmuka umum.  Sebagai contoh, saya memiliki kelas yang mengimplementasikan antarmuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Predicate</a> : <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Saat menganalisis metode di kelas, tipe parameternya adalah <code>String</code> , dan di antarmuka itu adalah <code>T</code> , dan semua upaya untuk mendapatkan <code>String</code> bukannya mengarah ke apa pun.  Pada akhirnya, saya datang dengan tidak ada yang lebih baik daripada hanya mengabaikan parameter tipe.  Pemeriksaan akan diteruskan dengan parameter tipe aktual apa pun, meskipun tidak cocok.  Untungnya, kompiler akan melempar kesalahan jika metode tidak memiliki implementasi standar dan tidak diimplementasikan di kelas dasar.  Tapi tetap saja, jika ada yang tahu bagaimana menyiasati ini, saya akan sangat berterima kasih atas petunjuknya. <br><br><h3>  Terhubung ke Eclipse </h3><br>  Secara pribadi, saya suka Eclipce dan dalam latihan saya hanya menggunakannya.  Oleh karena itu, saya akan menjelaskan cara menghubungkan prosesor ke IDE ini.  Agar Eclipse dapat melihat prosesor, Anda harus memasukkannya ke dalam. JAR yang terpisah, di mana anotasi itu sendiri juga akan.  Dalam hal ini, Anda perlu membuat folder <b>META-INF / services</b> di proyek dan membuat file <b>javax.annotation.processing.Processor di sana</b> dan menunjukkan nama lengkap kelas prosesor: <code>ds.magic.annotations.compileTime.ImplementProcessor</code> , dalam kasus saya.  Untuk berjaga-jaga, saya akan memberikan tangkapan layar, tetapi ketika tidak ada yang berhasil untuk saya, saya hampir mulai berbuat dosa pada struktur proyek. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="gambar"><br><br>  Selanjutnya, kumpulkan .JAR dan hubungkan ke proyek Anda, pertama sebagai pustaka biasa, sehingga anotasi terlihat di kode.  Lalu kami menghubungkan prosesor (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> lebih rinci).  Untuk melakukan ini, buka <b>properti proyek</b> dan pilih: <br><br><ol><li>  Java Compiler -&gt; Annotation Processing dan centang kotak "Enable annotation processing". </li><li>  Kompiler Java -&gt; Pemrosesan Anotasi -&gt; Jalur Pabrik centang kotak centang "Aktifkan pengaturan spesifik proyek".  Kemudian klik Tambah JAR ... dan pilih file JAR yang dibuat sebelumnya. </li><li>  Setuju untuk membangun kembali proyek. </li></ol><br><h3>  Ringkasan </h3><br>  Semua bersama dan dalam proyek Eclipse dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Pada saat penulisan, hanya ada dua kelas, jika anotasi dapat disebut sebagai: Implement.java dan ImplementProcessor.java.  Saya pikir Anda sudah menebak tujuan mereka. <br><br>  Mungkin penjelasan ini tampaknya tidak berguna bagi sebagian orang.  Mungkin itu.  Tetapi secara pribadi, saya sendiri menggunakannya sebagai ganti <code>@Override</code> , ketika nama metode tidak cocok dengan tujuan kelas.  Dan sejauh ini, saya tidak punya keinginan untuk menyingkirkannya.  Secara umum, saya membuat anotasi untuk diri saya sendiri, dan tujuan artikel itu adalah untuk menunjukkan apa yang saya serang.  Saya harap saya berhasil.  Terima kasih atas perhatian anda <br><br>  PS.  Terima kasih kepada pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ohotNik_alex</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Comdiv</a> untuk bantuan mereka dalam memperbaiki bug. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414715/">https://habr.com/ru/post/id414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414705/index.html">Mahakarya konstruksi speaker global: Monitor jalur inovatif Audio dari kain ke bahan logam dan komposit</a></li>
<li><a href="../id414707/index.html">Analisis blockchain, atau mengapa mixer pecah?</a></li>
<li><a href="../id414709/index.html">Gurun Singa dan Introspeksi</a></li>
<li><a href="../id414711/index.html">Aplikasi sepakbola Spanyol, La Liga, telah membuat penggunanya melakukan scammer tanpa disengaja</a></li>
<li><a href="../id414713/index.html">Umpan Balik Crossover Week</a></li>
<li><a href="../id414717/index.html">2018 4K TV: rekomendasi untuk pilihan terbaik</a></li>
<li><a href="../id414719/index.html">Empat roda bagus, dua lebih baik</a></li>
<li><a href="../id414723/index.html">Kontes Pemrograman: Perdagangan</a></li>
<li><a href="../id414725/index.html">Perubahan depan: mengapa memukul aliran proton ke dinding beton setebal lima meter</a></li>
<li><a href="../id414727/index.html">Hukum Cryptocurrency akan segera diluncurkan di Rusia: apa yang akan berubah bagi pelaku pasar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>