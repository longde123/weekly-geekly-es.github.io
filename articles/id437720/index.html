<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ ğŸ‘¦ ğŸ‘©â€ğŸ³ Perjuangan untuk solusi berkualitas di Erlang / Elixir ğŸš‹ â–«ï¸ ğŸ§’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@ jcutrer 


 Hari ini kita akan berbicara tentang log peristiwa, metrik kuantitatif, dan memantau semua ini untuk meningkatkan tingkat respons tim te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perjuangan untuk solusi berkualitas di Erlang / Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437720/"><p><img src="https://habrastorage.org/webt/s8/mq/lh/s8mqlhd99fmiu32vwgxnk4x-8yu.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ jcutrer</a> </p><br><p>  Hari ini kita akan berbicara tentang log peristiwa, metrik kuantitatif, dan memantau semua ini untuk meningkatkan tingkat respons tim terhadap insiden dan mengurangi waktu henti sistem target. </p><br><p> Erlang / OTP sebagai kerangka kerja dan ideologi membangun sistem terdistribusi memberi kita pendekatan yang diatur untuk pengembangan, alat dan implementasi komponen standar.  Katakanlah kita menggunakan potensi OTP dan beralih dari prototipe ke produksi.  Proyek Erlang kami terasa hebat di server pertempuran, basis kode terus berkembang, persyaratan dan fungsi baru muncul, orang-orang baru datang ke tim, dan semuanya tampak baik-baik saja.  Namun terkadang ada yang salah dan masalah teknis, dikalikan dengan faktor manusia, dapat menyebabkan kecelakaan. </p><br><p>  Karena tidak mungkin meletakkan sedotan untuk semua kasus kegagalan dan masalah yang mungkin terjadi, atau tidak layak secara ekonomi, maka perlu untuk mengurangi waktu henti sistem jika terjadi kegagalan oleh solusi manajemen dan perangkat lunak. </p><a name="habracut"></a><br><p>  Dalam sistem informasi akan selalu ada kemungkinan terjadinya kegagalan berbagai sifat: </p><br><ul><li>  Kegagalan Perangkat Keras dan Kegagalan Daya </li><li>  Kegagalan jaringan: kesalahan konfigurasi, kurva firmware </li><li>  Kesalahan logis: dari kesalahan pengkodean algoritma hingga masalah arsitektur yang muncul pada batas subsistem dan sistem. </li><li>  Masalah keamanan dan serangan serta peretasan terkait, termasuk penipuan internal. </li></ul><br><p>  Kami segera membedakan tanggung jawab: pemantauan infrastruktur, misalnya, yang diselenggarakan oleh zabbix, akan bertanggung jawab atas pengoperasian peralatan komputasi dan jaringan transmisi data.  Banyak yang telah ditulis tentang menginstal dan mengkonfigurasi pemantauan tersebut, kami tidak akan mengulanginya. </p><br><p>  Dari sudut pandang pengembang, masalah aksesibilitas dan kualitas terletak pada bidang deteksi dini kesalahan dan masalah kinerja dan respons cepat terhadapnya.  Ini membutuhkan pendekatan dan cara penilaian.  Jadi, mari kita coba untuk mendapatkan metrik kuantitatif, menganalisis yang pada berbagai tahap pengembangan dan operasi proyek, kita dapat secara signifikan meningkatkan kualitas. </p><br><h3 id="sistemy-sborki">  Sistem perakitan </h3><br><p>  Biarkan saya mengingatkan Anda sekali lagi tentang pentingnya pendekatan teknik dan pengujian dalam pengembangan perangkat lunak.  Erlang / OTP menawarkan dua kerangka uji sekaligus: eunit dan uji umum. </p><br><p>  Sebagai metrik untuk penilaian awal tentang keadaan basis kode dan dinamika, Anda dapat menggunakan jumlah tes yang berhasil dan bermasalah, waktu pelaksanaannya, dan persentase cakupan kode dengan tes.  Kedua kerangka kerja memungkinkan menyimpan hasil tes dalam format Junit. <br>  Misalnya, untuk rebar3 dan ct, tambahkan baris berikut ke rebar.config: </p><br><pre><code class="erlang hljs">{cover_enabled, true}. {cover_export_enabled, true}. {ct_opts,[ {ct_hooks, [{cth_surefire, [{path, <span class="hljs-string"><span class="hljs-string">"report.xml"</span></span>}]}]} ]}.</code> </pre> <br><p>  Jumlah tes yang berhasil dan tidak berhasil memungkinkan Anda untuk membuat grafik tren: <br><img src="https://habrastorage.org/webt/mw/lc/mw/mwlcmw24mj6f9wz5ctxshc4baf4.png"><br>  melihat yang mana, Anda dapat mengevaluasi dinamika tim dan regresi tes.  Misalnya, dalam Jenkins grafik ini dapat diperoleh dengan menggunakan Plugin Test Results Analyzer. </p><br><p>  Jika tes berubah merah atau mulai berjalan untuk waktu yang lama, metrik akan memungkinkan rilis untuk diselesaikan bahkan pada tahap perakitan dan pengujian otomatis. </p><br><h3 id="metriki-prilozheniy">  Metrik aplikasi </h3><br><p>  Selain metrik sistem operasi, pemantauan harus mencakup metrik aplikasi, seperti jumlah tampilan per detik, jumlah pembayaran, dan indikator penting lainnya. </p><br><p>  Dalam proyek saya, saya menggunakan templat seperti <code>${application}.${metrics_type}.${name}</code> untuk memberi nama metrik.  Penamaan ini memungkinkan Anda untuk mendapatkan daftar metrik formulir </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3</code> </pre> <br><p>  Mungkin semakin banyak metrik, semakin mudah untuk memahami apa yang terjadi dalam sistem yang kompleks. </p><br><h3 id="metriki-erlang-vm">  Metrik VM Erlang </h3><br><p>  Perhatian khusus harus diberikan untuk memantau Erlang VM.  Ideologi membiarkannya crash itu indah, dan penggunaan OTP yang tepat tentu akan membantu mengangkat bagian aplikasi yang jatuh di dalam Erlang VM.  Tetapi jangan lupa tentang Erlang VM itu sendiri, karena sulit untuk menjatuhkannya, tetapi itu mungkin.  Semua opsi didasarkan pada habisnya sumber daya.  Kami daftar yang utama: </p><br><ul><li><p>  Tabel atom meluap. <br>  Atom adalah pengidentifikasi yang tujuan utamanya adalah untuk meningkatkan keterbacaan kode.  Atom yang dibuat sekali tetap selamanya dalam ingatan instance Erlang VM, karena mereka tidak dibersihkan oleh pengumpul sampah.  Mengapa ini terjadi?  Pengumpul sampah bekerja secara terpisah di setiap proses dengan data dari proses ini, sementara atom dapat didistribusikan di seluruh struktur data dari banyak proses. <br>  Secara default, 1.048.576 atom dapat dibuat.  Dalam artikel tentang membunuh Erlang VM, Anda biasanya dapat menemukan sesuatu seperti ini. </p><br><pre> <code class="erlang hljs">[list_to_atom(integer_to_list(I)) || I &lt;- lists:seq(erlang:system_info(atom_count), erlang:system_info(atom_limit))]</code> </pre> <br><p>  sebagai ilustrasi efek ini.  Tampaknya masalah buatan juga tidak dapat dicapai dalam sistem nyata, tetapi ada beberapa kasus ... Misalnya, dalam penangan API eksternal, ketika <code>binary_to_atom/2</code> parsing permintaan, <code>binary_to_atom/2</code> sebagai ganti <code>binary_to_existing_atom/2</code> atau <code>list_to_atom/1</code> alih-alih <code>list_to_existing_atom/1</code> . <br>  Parameter berikut harus digunakan untuk memantau keadaan atom: </p><br><ol><li>  <code>erlang:memory(atom_used)</code> - jumlah memori yang digunakan untuk atom </li><li>  <code>erlang:system_info(atom_count)</code> - jumlah atom yang dibuat dalam sistem.  Bersama dengan <code>erlang:system_info(atom_limit)</code> , pemanfaatan atom dapat dihitung. </li></ol><br></li><li><p>  Proses kebocoran. <br>  Saya ingin segera mengatakan bahwa ketika process_limit (+ P tercapai, erl) erlang vm argumen tidak jatuh, tetapi masuk ke keadaan darurat, misalnya, kemungkinan besar tidak mungkin untuk terhubung ke sana.  Pada akhirnya, kehabisan memori yang tersedia saat mengalokasikan ke proses yang bocor akan menyebabkan erlang vm crash. </p><br><ol><li>  <code>erlang:system_info(process_count)</code> - jumlah proses aktif saat ini.  Bersama dengan <code>erlang:system_info(process_limit)</code> , pemanfaatan proses dapat dihitung. </li><li>  <code>erlang:memory(processes)</code> - memori yang dialokasikan untuk proses </li><li>  <code>erlang:memory(processes_used)</code> - memori yang digunakan untuk proses. </li></ol><br></li><li><p>  Proses kotak surat meluap. <br>  Contoh khas dari masalah seperti itu adalah proses pengirim mengirim pesan ke proses penerima tanpa menunggu konfirmasi, sementara <code>receive</code> dalam proses penerima mengabaikan semua pesan ini karena pola yang hilang atau salah.  Akibatnya, pesan terakumulasi di kotak surat.  Meskipun erlang memiliki mekanisme untuk memperlambat pengirim jika penangan tidak dapat menangani pemrosesan, lagi pula, setelah kehabisan memori yang tersedia, vm crash. <br>  Untuk memahami jika ada masalah dengan kotak surat meluap, etop akan membantu. </p><br><pre> <code class="bash hljs">$ erl -name etop@host -hidden -s etop -s erlang halt -output text -node dest@host -setcookie some_cookie -tracing off -sort msg_q -interval 1 -lines 25</code> </pre> <br><p><img src="https://habrastorage.org/webt/k3/rc/xu/k3rcxuudnptazhjl0pxql1vmfji.png"><br>  Sebagai metrik untuk pemantauan berkelanjutan, Anda dapat mengambil sejumlah proses masalah.  Untuk mengidentifikasi mereka, Anda dapat menggunakan fungsi berikut: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_msq_q</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">-&gt;</span></span> [{P, RN, L, IC, ST} || P &lt;- processes(), { _, L } &lt;- [ process_info(P, message_queue_len) ], L &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>, [{_, RN}, {_, IC}, {_, ST}] &lt;- [process_info(P, [registered_name, initial_call, current_stacktrace]) ] ].</code> </pre> <br><p>  Selain itu, daftar ini dapat dicatat, kemudian ketika menerima pemberitahuan dari pemantauan, analisis masalahnya disederhanakan. </p><br></li><li><p>  Binari yang bocor. <br>  Memori untuk binari besar (lebih dari 64 byte) dialokasikan di heap umum.  Blok yang dialokasikan memiliki penghitung referensi yang menunjukkan jumlah proses yang memiliki akses ke sana.  Setelah mengatur ulang penghitung, pembersihan terjadi.  Sistem yang paling sederhana, tetapi, seperti yang mereka katakan, ada nuansa.  Pada prinsipnya, ada kemungkinan proses menghasilkan begitu banyak sampah di heap sehingga sistem tidak memiliki cukup memori untuk melakukan pembersihan. <br>  <code>erlang:memory(binary)</code> bertindak sebagai metrik untuk pemantauan, menunjukkan memori yang dialokasikan untuk binari. </p><br></li></ul><br><p>  Jadi, case yang menyebabkan jatuhnya vm disortir, namun, selain itu, ada baiknya untuk memantau parameter yang tidak kalah pentingnya yang secara langsung atau tidak langsung mempengaruhi berfungsinya aplikasi Anda dengan benar: </p><br><ul><li>  Memori yang digunakan oleh <code>erlang:memory(ets)</code> ETS: <code>erlang:memory(ets)</code> . </li><li>  Memori untuk modul yang dikompilasi: <code>erlang:memory(code)</code> . <br>  Jika solusi Anda tidak menggunakan kompilasi kode dinamis, maka opsi ini dapat dikecualikan. <br>  Saya juga ingin menyebutkan erlydtl.  Jika Anda mengkompilasi template secara dinamis, maka kompilasi membuat berkas yang dimuat ke memori vm.  Ini juga dapat menyebabkan kebocoran memori. </li><li>  Memori sistem: <code>erlang:memory(system)</code> .  Menunjukkan konsumsi memori erlang runtime. </li><li>  Total memori yang digunakan: <code>erlang:memory(total)</code> .  Ini adalah jumlah memori yang dikonsumsi oleh proses dan runtime. </li><li>  Informasi tentang reduksi: <code>erlang:statistics(reductions)</code> . </li><li>  Jumlah proses dan port yang siap dieksekusi: <code>erlang:statistics(run_queue)</code> . </li><li>  Uptime dari instance vm: <code>erlang:statistics(runtime)</code> memungkinkan Anda untuk memahami apakah ada restart tanpa analisis log. </li><li>  Aktivitas jaringan: <code>erlang:statistics(io)</code> . </li></ul><br><h3 id="otpravka-metrik-v-zabbix">  Mengirim metrik ke zabbix </h3><br><p>  Kami akan membuat file yang berisi metrik aplikasi dan metrik erlang vm, yang akan kami perbarui setiap N detik.  Untuk setiap node erlang, file metrik harus berisi metrik aplikasi yang berjalan di atasnya dan metrik instance erlang vm.  Hasilnya harus seperti ini: </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3 â€¦. erlang.io.input = 2205723664 erlang.io.output = 1665529234 erlang.memory.binary = 1911136 erlang.memory.ets = 1642416 erlang.memory.processes = 23596432 erlang.memory.processes_used = 23598864 erlang.memory.system = 50883752 erlang.memory.total = 74446048 erlang.processes.count = 402 erlang.processes.run_queue = 0 erlang.reductions = 148412771 ....</code> </pre> <br><p>  Menggunakan <code>zabbix_sender</code> kami akan mengirimkan file ini ke zabbix, di mana representasi grafis dan kemampuan untuk membuat otomatisasi dan pemicu pemberitahuan sudah tersedia. </p><br><p>  Sekarang kami memiliki metrik dalam sistem pemantauan dan pemicu otomasi dan acara pemberitahuan yang dibuat atas dasar mereka, kami memiliki kesempatan untuk menghindari kecelakaan dengan bereaksi terlebih dahulu terhadap semua penyimpangan berbahaya dari keadaan berfungsi penuh. </p><br><h3 id="centralnyy-sbor-logov">  Pertemuan pusat kayu bulat </h3><br><p>  Ketika ada 1-2 server dalam suatu proyek, Anda mungkin masih dapat hidup tanpa pengumpulan log pusat, tetapi begitu sistem terdistribusi dengan banyak server, cluster, lingkungan muncul, menjadi perlu untuk menyelesaikan masalah pengumpulan dan kenyamanan melihat log. </p><br><p>  Untuk menulis log di proyek saya, saya menggunakan lager.  Seringkali, dalam perjalanan dari prototipe ke produksi, proyek melewati tahap pengumpulan log berikut: </p><br><ul><li>  Logging sederhana dengan output ke file lokal atau bahkan ke stdout (lager_file_backend) </li><li>  Pengumpulan log terpusat menggunakan, misalnya, syslogd dan pengiriman log otomatis ke kolektor.  Untuk skema seperti itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lager_syslog</a> cocok. <br>  Kerugian utama dari skema ini adalah Anda harus pergi ke server pengumpulan log, mencari file dengan log yang diperlukan dan entah bagaimana menyaring peristiwa untuk mencari yang diperlukan untuk debugging. </li><li>  Kumpulan log terpusat dengan penyimpanan di repositori dengan kemampuan untuk memfilter dan mencari berdasarkan catatan. </li></ul><br><p>  Tentang minus, plus, dan metrik kuantitatif yang dapat diterapkan menggunakan yang terakhir, dan kami akan berbicara dalam prisma implementasi spesifik - <code>lager_clickhouse</code> , yang saya gunakan di sebagian besar proyek yang dikembangkan.  Beberapa kata tentang <code>lager_clickhouse</code> .  Ini adalah lager backend untuk menyimpan acara ke clickhouse.  Saat ini, ini adalah proyek internal, tetapi ada rencana untuk membuatnya terbuka.  Ketika mengembangkan lager_clickhouse, saya harus mem-bypass beberapa fitur clickhouse, misalnya, menggunakan event buffering untuk menghindari membuat permintaan yang sering di clickhouse.  Upaya yang telah dilakukan terbayar dengan operasi yang stabil dan kinerja yang baik. </p><br><p>  Minus utama dari pendekatan untuk menyimpan ke repositori adalah entitas tambahan - clickhouse dan kebutuhan untuk mengembangkan kode untuk menyimpan acara ke dalamnya dan antarmuka pengguna untuk menganalisis dan mencari acara.  Juga, untuk beberapa proyek, mungkin penting untuk menggunakan tcp untuk mengirim log. </p><br><p>  Tetapi menurut saya, kelebihannya lebih besar daripada semua kerugian yang mungkin terjadi. </p><br><ul><li><p>  Pencarian acara mudah dan cepat: </p><br><ul><li>  Memfilter berdasarkan tanggal tanpa harus mencari file / file di server pusat yang berisi berbagai acara. </li><li>  Penyaringan berdasarkan lingkungan.  Log dari subsistem yang berbeda dan sering dari kelompok yang berbeda ditulis ke satu repositori.  Saat ini, pemisahan terjadi sesuai dengan label yang ditetapkan pada setiap node cluster. </li><li>  Saring berdasarkan nama host </li><li>  Memfilter berdasarkan nama modul yang mengirim acara </li><li>  Penyaringan Acara </li><li>  Pencarian teks </li></ul><br><p>  Contoh tampilan antarmuka tampilan log ditunjukkan pada tangkapan layar: <br><img src="https://habrastorage.org/webt/tz/6s/qy/tz6sqy5ofprtonxlxkhywfr7gmy.png"></p><br></li><li><p>  Kemampuan otomatisasi. <br>  Dengan diperkenalkannya penyimpanan log, menjadi mungkin secara real time untuk menerima informasi tentang jumlah kesalahan, terjadinya kegagalan kritis, dan aktivitas sistem.  Dengan memperkenalkan batas-batas tertentu, kami dapat menghasilkan peristiwa darurat ketika sistem keluar dari keadaan fungsional, yang penangannya akan melakukan tindakan otomatisasi untuk menghilangkan keadaan ini dan mengirimkan pemberitahuan kepada anggota tim yang bertanggung jawab untuk fungsi: </p><br><ul><li>  Ketika kesalahan kritis terjadi. </li><li>  Dalam kasus kesalahan massa (turunan waktu meningkat lebih cepat dari batas tertentu). </li><li>  Metrik terpisah adalah tingkat pembuatan acara, yaitu berapa banyak acara baru yang muncul di log peristiwa.  Anda hampir selalu dapat mengetahui perkiraan jumlah log yang dihasilkan oleh suatu proyek per unit waktu.  Jika melebihi beberapa kali, kemungkinan besar ada sesuatu yang salah. </li></ul><br></li></ul><br><p>  Pengembangan lebih lanjut dari topik otomatisasi penanganan peristiwa darurat adalah penggunaan skrip lua.  Pengembang atau administrator apa pun dapat menulis skrip untuk memproses log dan metrik.  Skrip menghadirkan fleksibilitas dan memungkinkan Anda membuat skrip dan pemberitahuan otomatisasi yang dipersonalisasi. </p><br><h3 id="itogi">  Ringkasan </h3><br><p>  Untuk memahami proses yang terjadi dalam sistem dan untuk menyelidiki insiden, sangat penting untuk memiliki indikator kuantitatif dan log peristiwa, serta alat yang mudah untuk menganalisisnya.  Semakin banyak informasi yang kami kumpulkan tentang sistem, semakin mudah untuk menganalisis perilakunya dan memperbaiki masalah bahkan pada tahap kemunculannya.  Jika tindakan kami tidak berhasil, kami selalu memiliki jadwal dan catatan terperinci tentang kejadian yang kami miliki. </p><br><p>  Dan bagaimana Anda mengoperasikan solusi pada Erlang / Elixir dan kasus menarik apa yang Anda temui dalam produksi? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437720/">https://habr.com/ru/post/id437720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437706/index.html">Tahun dengan Tesla</a></li>
<li><a href="../id437710/index.html">Membatasi hak pengguna lokal di Linux seminimal mungkin</a></li>
<li><a href="../id437712/index.html">Stasiun Luar Angkasa Roskomnadzor</a></li>
<li><a href="../id437714/index.html">Kami menggambar ledakan kartun untuk 180 garis telanjang C ++</a></li>
<li><a href="../id437716/index.html">Tiga cara yang relatif jujur â€‹â€‹untuk membuat proyek Flutter</a></li>
<li><a href="../id437722/index.html">Konsekuensi Kosmik Shatdown Amerika</a></li>
<li><a href="../id437724/index.html">OpenSceneGraph: Animasi prosedural dari atribut geometri dan status</a></li>
<li><a href="../id437726/index.html">Serializing Kotlin dengan Kotlinx. Serialisasi</a></li>
<li><a href="../id437730/index.html">Bagaimana kami memecahkan masalah memori di PostgreSQL tanpa menambahkan byte</a></li>
<li><a href="../id437732/index.html">Tinjauan Umum tentang Printer DLP MakeX M-One Pro 70</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>