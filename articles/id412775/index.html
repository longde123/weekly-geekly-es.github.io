<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”™ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸš± Pengalaman pribadi: beralih dari pengembangan C tingkat rendah ke pemrograman Java ğŸ‘§ğŸ¿ ğŸ•µğŸ¼ ğŸš</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel tersebut mencerminkan pengalaman pribadi penulis, seorang programmer mikrokontroler yang keranjingan, yang, setelah bertahun-tahun pengalaman ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman pribadi: beralih dari pengembangan C tingkat rendah ke pemrograman Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  Artikel tersebut mencerminkan pengalaman pribadi penulis, seorang programmer mikrokontroler yang keranjingan, yang, setelah bertahun-tahun pengalaman dalam pengembangan mikrokontroler di C (dan sedikit dalam C ++), berkesempatan untuk berpartisipasi dalam proyek besar di Jawa untuk mengembangkan perangkat lunak untuk set-top box TV yang menjalankan Android.  Selama proyek ini, saya dapat mengumpulkan catatan tentang perbedaan menarik antara bahasa Java dan C / C ++, mengevaluasi berbagai pendekatan untuk program penulisan.  Artikel ini tidak berpura-pura menjadi referensi, tetapi tidak memeriksa efisiensi dan produktivitas program-program Java.  Ini lebih merupakan kumpulan pengamatan pribadi.  Kecuali ditentukan lain, ini adalah rilis Java SE 7. <br><a name="habracut"></a><br><h2>  Perbedaan sintaks dan konstruk kontrol </h2><br>  Singkatnya - perbedaannya minimal, sintaksisnya sangat mirip.  Blok kode juga dibentuk oleh sepasang kurung kurawal {}.  Aturan untuk mengkompilasi pengidentifikasi sama dengan untuk C / C ++.  Daftar kata kunci hampir sama dengan di C / C ++.  Tipe data bawaan - mirip dengan yang ada di C / C ++.  Array - semua juga dideklarasikan menggunakan tanda kurung siku. <br><br>  Kontrol membangun if-else, sementara, do-while, for, switch juga hampir sepenuhnya identik.  Perlu dicatat bahwa di Jawa ada label yang akrab bagi programmer-C (label yang digunakan dengan kata kunci goto dan yang penggunaannya sangat tidak disarankan).  Namun, Java mengecualikan kemungkinan beralih ke label menggunakan goto.  Label hanya boleh digunakan untuk keluar dari loop bersarang: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Untuk meningkatkan keterbacaan program di Jawa, sebuah peluang menarik telah ditambahkan untuk memisahkan bit angka panjang dengan garis bawah: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  Secara eksternal, program Java tidak jauh berbeda dari program C. Famili. Perbedaan visual utama adalah bahwa Java tidak memungkinkan fungsi, variabel, definisi jenis baru (struktur), konstanta, dan sebagainya, yang "bebas" terletak di file sumber.  Java adalah bahasa berorientasi objek, jadi semua entitas program harus milik kelas tertentu.  Perbedaan signifikan lainnya adalah kurangnya preprosesor.  Kedua perbedaan ini dijelaskan secara lebih rinci di bawah ini. <br><br><h2>  Pendekatan objek dalam bahasa C. </h2><br>  Ketika kita menulis program besar dalam C, kita pada dasarnya harus bekerja dengan objek.  Peran objek di sini dilakukan oleh struktur yang menggambarkan esensi tertentu dari "dunia nyata": <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   â€“ Â«Â» struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Juga di C ada metode untuk memproses "objek" -struktur - fungsi.  Namun, fungsi pada dasarnya tidak digabungkan dengan data.  Ya, mereka biasanya ditempatkan dalam satu file, tetapi setiap kali perlu untuk melewatkan pointer ke objek untuk diproses menjadi fungsi "khas": <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Anda dapat menggunakan "objek" hanya setelah mengalokasikan memori untuk menyimpannya: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  Dalam program C, fungsi biasanya didefinisikan yang bertanggung jawab untuk inisialisasi "objek" sebelum digunakan pertama kali: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Maka siklus hidup "objek" dalam C biasanya seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Sekarang kita daftar kemungkinan runtime error yang dapat dibuat oleh programmer dalam siklus hidup "objek": <br><br><ol><li>  Lupa mengalokasikan memori untuk "objek" </li><li>  Tentukan jumlah memori yang dialokasikan yang salah </li><li>  Lupa menginisialisasi "objek" </li><li>  Lupa membebaskan memori setelah menggunakan objek </li></ol><br>  Mungkin sangat sulit untuk mendeteksi kesalahan seperti itu, karena mereka tidak terdeteksi oleh kompiler dan muncul selama operasi program.  Selain itu, efeknya bisa sangat beragam dan mempengaruhi variabel dan "objek" program lainnya. <br><br><h2>  Pendekatan Objek Java </h2><br>  Menghadapi OOP - pemrograman berorientasi objek, Anda mungkin pernah mendengar tentang salah satu paus OOP - enkapsulasi.  Di Jawa, tidak seperti C, data dan metode untuk memprosesnya digabungkan bersama dan merupakan objek "benar".  Dalam hal OOP, ini disebut enkapsulasi.  Kelas adalah deskripsi objek, analog terdekat dari kelas di C adalah untuk mendefinisikan tipe baru menggunakan typedef struct.  Dalam istilah Java, fungsi-fungsi yang dimiliki kelas disebut metode. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  Ideologi bahasa Jawa didasarkan pada pernyataan "semuanya adalah objek."  Oleh karena itu, tidak mengherankan bahwa Java melarang pembuatan kedua metode (fungsi) dan bidang data (variabel) secara terpisah dari kelas.  Bahkan metode main () yang familier, dari mana program dimulai, harus menjadi milik salah satu kelas. <br><br>  Definisi kelas di Jawa analog dengan deklarasi struktur dalam C. Dengan menjelaskan kelas, Anda tidak membuat apa pun di memori.  Objek kelas ini muncul pada saat pembuatannya oleh operator baru.  Membuat objek di Jawa adalah analog dari mengalokasikan memori dalam bahasa C, tetapi, tidak seperti yang terakhir, metode khusus secara otomatis dipanggil selama pembuatan objek - pembangun objek.  Konstruktor mengambil peran inisialisasi awal objek - analog dari fungsi init () yang dibahas sebelumnya.  Nama konstruktor harus sesuai dengan nama kelas.  Konstruktor tidak dapat mengembalikan nilai. <br><br>  Siklus hidup suatu objek dalam program Java adalah sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Perhatikan bahwa jumlah kesalahan yang mungkin dalam program Java jauh lebih kecil daripada di program C. Ya, Anda masih bisa lupa untuk membuat objek sebelum penggunaan pertama (yang, bagaimanapun, akan menyebabkan NullPointerException mudah ditukar), tetapi untuk kesalahan lain yang melekat Program C, situasinya berubah secara mendasar: <br><br><ol><li>  Tidak ada sizeof () operator di Jawa.  Kompiler Java sendiri menghitung jumlah memori untuk menyimpan objek.  Oleh karena itu, tidak mungkin untuk menentukan ukuran pemilihan yang salah. </li><li>  Inisialisasi objek terjadi pada saat penciptaan.  Mustahil untuk melupakan inisialisasi. </li><li>  Memori yang ditempati oleh objek tidak perlu dibebaskan, pengumpul sampah melakukan pekerjaan ini.  Tidak mungkin untuk menghapus objek setelah digunakan - ada kemungkinan efek "kehabisan memori" yang lebih kecil. </li></ol><br>  Jadi, segala sesuatu di Jawa adalah objek dari satu kelas atau yang lain.  Pengecualian adalah primitif yang telah ditambahkan ke bahasa untuk meningkatkan kinerja dan konsumsi memori.  Lebih banyak tentang primitif di bawah ini. <br><br><h2>  Pengumpul memori dan sampah </h2><br>  Java mempertahankan konsep heap dan stack untuk C / C ++, seorang programmer.  Saat membuat objek dengan operator baru, memori untuk menyimpan objek dipinjam dari heap.  Namun, tautan ke objek (tautan adalah analog dari penunjuk), jika objek yang dibuat bukan bagian dari objek lain, ditempatkan di tumpukan.  Di heap disimpan "tubuh" objek, dan pada stack adalah variabel lokal: referensi ke objek dan tipe primitif.  Jika tumpukan ada selama pelaksanaan program dan tersedia untuk semua utas program, maka tumpukan milik metode dan hanya ada selama pelaksanaannya, dan juga tidak dapat diakses oleh utas lain dari program. <br><br>  Java tidak perlu dan bahkan lebih lagi - Anda tidak dapat secara manual membebaskan memori yang ditempati oleh suatu objek.  Pekerjaan ini dilakukan oleh pengumpul sampah dalam mode otomatis.  Runtime memonitor apakah mungkin untuk mencapai setiap objek di heap dari lokasi saat ini dari program dengan mengikuti tautan dari objek ke objek.  Jika tidak, maka objek tersebut diakui sebagai "sampah" dan menjadi kandidat untuk dihapus. <br><br>  Penting untuk dicatat bahwa penghapusan itu sendiri tidak terjadi pada saat objek "tidak lagi diperlukan" - pengumpul sampah memutuskan penghapusan, dan penghapusan dapat ditunda sebanyak yang diperlukan sampai program berakhir. <br><br>  Tentu saja, pekerjaan pengumpul sampah membutuhkan overhead prosesor.  Tetapi sebagai imbalannya, ia meringankan programmer dari sakit kepala besar yang terkait dengan kebutuhan untuk membebaskan memori setelah akhir penggunaan "objek".  Bahkan, kita "mengambil" ingatan ketika kita membutuhkannya dan menggunakannya, tidak berpikir bahwa kita perlu membebaskannya setelah diri kita sendiri. <br><br>  Berbicara tentang variabel lokal, kita harus memanggil kembali pendekatan Java ke inisialisasi mereka.  Jika dalam C / C ++ variabel lokal yang tidak diinisialisasi berisi nilai acak, maka kompiler Java tidak akan membiarkannya tidak diinisialisasi: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Tautan - Pointer Pengganti </h2><br>  Java tidak memiliki pointer, oleh karena itu, seorang programmer Java tidak memiliki kemampuan untuk membuat salah satu dari banyak kesalahan yang terjadi ketika bekerja dengan pointer.  Saat Anda membuat objek, Anda mendapatkan tautan ke objek ini: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity â€“  . Entity entity = new Entity();</span></span></code> </pre><br>  Di C, programmer punya pilihan: bagaimana mengoper, katakanlah, struktur ke suatu fungsi.  Anda bisa melewati nilai: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    â€“   : //    . void process(Data *data);</span></span></code> </pre> <br>  Lewat nilai dijamin bahwa fungsi tidak akan mengubah data dalam struktur, tetapi tidak efektif dalam hal kinerja - pada saat fungsi dipanggil, salinan struktur dibuat.  Melewati sebuah pointer jauh lebih efisien: pada kenyataannya, alamat di memori tempat struktur berada dilewatkan ke fungsi. <br><br>  Di Jawa, hanya ada satu cara untuk melewatkan objek ke metode - dengan referensi.  Melewati dengan referensi di Jawa analog dengan melewati pointer di C: <br><ul><li>  menyalin (kloning) memori tidak terjadi, </li><li>  sebenarnya, alamat lokasi objek ini ditransmisikan. </li></ul><br>  Namun, tidak seperti penunjuk bahasa C, tautan Java tidak dapat ditambah / dikurangi.  "Menjalankan" melalui elemen-elemen array menggunakan tautan ke dalamnya di Java tidak akan berfungsi.  Semua yang bisa dilakukan dengan tautan adalah memberikan nilai yang berbeda. <br><br>  Tentu saja, tidak adanya pointer seperti itu mengurangi jumlah kesalahan yang mungkin, namun, analog dari pointer nol tetap dalam bahasa - referensi nol dilambangkan dengan kata kunci nol. <br><br>  Referensi nol adalah sakit kepala untuk programmer Java, seperti  memaksa referensi objek untuk diperiksa nol sebelum menggunakannya atau untuk menangani pengecualian NullPointerException.  Jika ini tidak dilakukan, maka program akan macet. <br><br>  Jadi, semua objek di Jawa dilewatkan melalui tautan.  Tipe data primitif (int, long, char ...) diteruskan oleh nilai (lebih lanjut tentang primitif diberikan di bawah). <br><br><h2>  Fitur Java Link </h2><br>  Akses ke objek apa pun dalam program ini adalah melalui tautan - ini jelas memiliki efek positif pada kinerja, tetapi mungkin mengejutkan seorang pemula: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Argumen metode dan nilai pengembalian - semuanya dilewatkan melalui tautan.  Selain keuntungan, ada kelemahan dibandingkan dengan bahasa C / C ++, di mana kita dapat secara eksplisit melarang fungsi dari mengubah nilai melewati pointer menggunakan kualifikasi const: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Yaitu, bahasa C memungkinkan Anda untuk melacak kesalahan ini pada tahap kompilasi.  Java juga memiliki kata kunci const, tetapi dicadangkan untuk versi yang akan datang dan saat ini tidak digunakan sama sekali.  Hingga taraf tertentu, kata kunci terakhir dipanggil untuk memenuhi perannya.  Namun, itu tidak melindungi objek yang diteruskan ke metode dari perubahan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  Masalahnya adalah bahwa kata kunci terakhir dalam hal ini diterapkan ke tautan, dan bukan ke objek yang ditunjuk tautan.  Jika final diterapkan pada primitif, maka kompiler berperilaku seperti yang diharapkan: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Tautan Java sangat mirip dengan tautan bahasa C ++. <br><br><h2>  Primitif Jawa </h2><br>  Setiap objek Java, selain bidang data, berisi informasi pendukung.  Jika kita ingin mengoperasikan, misalnya, dalam byte terpisah dan setiap byte diwakili oleh suatu objek, maka dalam kasus array byte, overhead memori dapat berkali-kali melebihi ukuran yang dapat digunakan. <br>  Agar Jawa tetap cukup efisien dalam kasus yang dijelaskan di atas, dukungan untuk tipe primitif - primitif - ditambahkan ke bahasa. <br><table><tbody><tr><th>  Primitif </th><th>  Lihat </th><th>  Kedalaman bit </th><th>  Kemungkinan analog dalam C </th></tr><tr><td>  byte </td><td rowspan="5">  Integer </td><td>  8 </td><td>  char </td></tr><tr><td>  pendek </td><td>  16 </td><td>  pendek </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32 </td><td>  int (panjang) </td></tr><tr><td>  panjang </td><td>  64 </td><td>  panjang </td></tr><tr><td>  mengapung </td><td>  Angka titik mengambang </td><td>  32 </td><td>  mengapung </td></tr><tr><td>  dobel </td><td></td><td>  64 </td><td>  dobel </td></tr><tr><td>  boolean </td><td>  Logis </td><td>  - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Semua primitif memiliki analog mereka dalam bahasa C. Namun, standar C tidak menentukan ukuran yang tepat dari tipe integer, melainkan rentang nilai yang dapat disimpan oleh tipe ini tetap.  Seringkali, programmer ingin memastikan kedalaman bit yang sama untuk mesin yang berbeda, yang mengarah pada penampilan tipe seperti uint32_t dalam program, meskipun semua fungsi pustaka memerlukan argumen dari tipe int. <br>  Fakta ini tidak dapat dikaitkan dengan keunggulan bahasa. <br><br>  Primitif Java integer, tidak seperti C, memiliki kedalaman bit tetap.  Dengan demikian, Anda tidak perlu khawatir tentang kedalaman bit sebenarnya dari mesin yang menjalankan program Java, serta tentang urutan byte ("jaringan" atau "Intel").  Fakta ini membantu mewujudkan prinsip â€œitu ditulis sekali - itu dipenuhi di mana-manaâ€. <br><br>  Selain itu, di Jawa semua bilangan bulat primitif ditandatangani (bahasa tidak memiliki kata kunci yang tidak ditandatangani).  Ini menghilangkan kesulitan menggunakan variabel yang ditandatangani dan tidak ditandatangani dalam satu ekspresi yang melekat dalam C. <br><br>  Sebagai kesimpulan, urutan byte dalam primitif multi-byte di Jawa diperbaiki (byte rendah pada alamat rendah, Little-endian, urutan terbalik). <br><br>  Kerugian dari implementasi operasi dengan primitif di Jawa termasuk fakta bahwa di sini, seperti dalam program C / C ++, overflow dari grid bit dapat terjadi, tanpa ada pengecualian yang dilemparkan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Jadi, data di Jawa diwakili oleh dua jenis entitas: objek dan primitif.  Primitif melanggar konsep "semuanya adalah objek", tetapi dalam beberapa situasi mereka terlalu efektif untuk tidak menggunakannya. <br><br><h2>  Warisan </h2><br>  Warisan adalah paus OOP lain yang mungkin pernah Anda dengar.  Jika Anda menjawab dengan singkat pertanyaan "mengapa warisan diperlukan", maka jawabannya adalah "penggunaan kembali kode". <br><br>  Misalkan Anda memprogram dalam C, dan Anda memiliki "kelas" yang ditulis dengan baik dan di-debug - struktur dan fungsi untuk memprosesnya.  Selanjutnya, muncul kebutuhan untuk membuat "kelas" yang serupa, tetapi dengan fungsionalitas yang ditingkatkan, dan "kelas" dasar masih diperlukan.  Dalam hal bahasa C, Anda hanya memiliki satu cara untuk menyelesaikan masalah ini - komposisi.  Ini adalah tentang membuat struktur baru yang diperluas - "class", yang harus berisi pointer ke struktur "class" dasar: <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Java sebagai bahasa berorientasi objek memungkinkan Anda untuk memperluas fungsionalitas kelas yang ada menggunakan mekanisme pewarisan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Perlu dicatat bahwa Java sama sekali tidak melarang penggunaan komposisi sebagai cara untuk memperluas fungsionalitas kelas yang sudah ditulis.  Selain itu, dalam banyak situasi, komposisi lebih disukai daripada warisan. <br><br>  Berkat warisan, kelas-kelas di Jawa diatur dalam struktur hierarkis, setiap kelas tentu memiliki satu dan hanya satu "orang tua" dan dapat memiliki sejumlah "anak".  Tidak seperti C ++, kelas di Java tidak dapat mewarisi dari lebih dari satu orang tua (ini memecahkan masalah "warisan berlian"). <br><br>  Selama pewarisan, kelas turunan mendapatkan ke lokasi semua bidang publik dan terlindungi dan metode dari kelas dasarnya, serta kelas dasar dari kelas dasarnya, dan seterusnya naik hierarki warisan. <br><br>  Di bagian atas hierarki warisan adalah nenek moyang yang sama dari semua kelas Java - kelas Object, satu-satunya yang tidak memiliki orangtua. <br><br><h2>  Identifikasi tipe dinamis </h2><br>  Salah satu poin utama dari bahasa Jawa adalah dukungan untuk identifikasi tipe dinamis (RTTI).  Dengan kata sederhana, RTTI memungkinkan Anda untuk mengganti objek dari kelas turunan di mana referensi ke pangkalan diperlukan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Memiliki tautan saat runtime, Anda dapat menentukan tipe sebenarnya dari objek yang dirujuk oleh tautan - menggunakan instanceof dari operator: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  Metode Override </h2><br>  Mendefinisikan ulang suatu metode atau fungsi berarti mengganti tubuhnya pada tahap pelaksanaan program.  Pemrogram C menyadari kemampuan suatu bahasa untuk mengubah perilaku suatu fungsi selama eksekusi program.  Ini tentang menggunakan pointer fungsi.  Misalnya, Anda bisa menyertakan pointer ke fungsi dalam struktur struktur dan menetapkan berbagai fungsi ke pointer untuk mengubah algoritma pemrosesan data dari struktur ini: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  Di Jawa, seperti dalam bahasa OOP lainnya, metode utama terkait erat dengan warisan.  Kelas turunan mendapatkan akses ke metode kelas dasar yang dilindungi dan publik.  Selain fakta bahwa ia dapat memanggil mereka, Anda dapat mengubah perilaku salah satu metode dari kelas dasar tanpa mengubah tanda tangannya.  Untuk melakukan ini, cukup mendefinisikan metode dengan tanda tangan yang persis sama di kelas turunan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  Sangat penting bahwa tanda tangan (nama metode, nilai balik, argumen) sama persis.  Jika nama metode cocok, dan argumen berbeda, maka metode kelebihan beban, lebih lanjut tentang yang di bawah ini. <br><br><h2>  Polimorfisme </h2><br>  Seperti enkapsulasi dan pewarisan, paus OOP ketiga - polimorfisme - juga memiliki beberapa jenis analog dalam bahasa C yang berorientasi prosedural. <br><br>  Misalkan kita memiliki beberapa "kelas" struktur yang dengannya Anda ingin melakukan jenis tindakan yang sama, dan fungsi yang melakukan tindakan ini harus bersifat universal - harus "dapat" bekerja dengan "kelas" apa pun sebagai argumen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solusi yang mungkin adalah sebagai berikut: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusinya terlihat rumit, tetapi tujuannya tercapai - fungsi universal commonFunc () menerima "objek" dari setiap "kelas" sebagai argumen. </font><font style="vertical-align: inherit;">Prasyarat adalah struktur "kelas" di bidang pertama harus berisi pengidentifikasi yang menentukan "kelas" objek tersebut. </font><font style="vertical-align: inherit;">Solusi semacam itu dimungkinkan karena penggunaan argumen dengan tipe "void *". </font><font style="vertical-align: inherit;">Namun, pointer dari jenis apa pun dapat dilewatkan ke fungsi seperti itu, misalnya, "int *". </font><font style="vertical-align: inherit;">Ini tidak akan menyebabkan kesalahan kompilasi, tetapi pada saat dijalankan program akan berperilaku tidak terduga.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita lihat bagaimana polimorfisme terlihat di Jawa (namun, seperti dalam bahasa OOP lainnya). </font><font style="vertical-align: inherit;">Misalkan kita memiliki banyak kelas yang harus diproses dengan cara yang sama dengan beberapa metode. </font><font style="vertical-align: inherit;">Berbeda dengan solusi untuk bahasa C yang disajikan di atas, metode polimorfik ini HARUS dimasukkan dalam semua kelas himpunan yang diberikan, dan semua versinya HARUS memiliki tanda tangan yang sama.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selanjutnya, Anda perlu memaksa kompiler untuk memanggil versi metode yang dimiliki kelas yang sesuai. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yaitu, metode executor (), yang dapat berada di mana saja dalam program, harus dapat bekerja dengan kelas apa pun dari set (A, B atau C). </font><font style="vertical-align: inherit;">Kita harus entah bagaimana â€œmemberi tahuâ€ kompiler bahwa _set_of_class_ menunjukkan banyak kelas kita. </font><font style="vertical-align: inherit;">Di sini pewarisan sangat berguna - perlu untuk membuat semua kelas dari turunan yang ditetapkan dari beberapa kelas dasar, yang akan berisi metode polimorfik:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang setiap kelas yang merupakan pewaris Basis (berkat identifikasi tipe dinamis) dapat diteruskan sebagai argumen: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bergantung pada objek kelas mana yang dilewatkan sebagai argumen, metode milik kelas ini akan dipanggil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata kunci abstrak memungkinkan Anda untuk mengecualikan badan metode (buat abstrak, dalam hal OOP). </font><font style="vertical-align: inherit;">Bahkan, kami memberi tahu kompiler bahwa metode ini harus diganti dalam kelas-kelas yang diturunkan darinya. </font><font style="vertical-align: inherit;">Jika ini bukan masalahnya, kesalahan kompilasi terjadi. </font><font style="vertical-align: inherit;">Kelas yang mengandung setidaknya satu metode abstrak juga disebut abstrak. </font><font style="vertical-align: inherit;">Kompiler memerlukan penandaan kelas-kelas tersebut juga dengan kata kunci abstrak.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur proyek Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Jawa, semua file sumber memiliki ekstensi * .java. </font><font style="vertical-align: inherit;">File header * .h dan prototipe fungsi atau kelas tidak ada. </font><font style="vertical-align: inherit;">Setiap file sumber Java harus mengandung setidaknya satu kelas. </font><font style="vertical-align: inherit;">Nama kelas adalah kebiasaan untuk menulis, dimulai dengan huruf kapital. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa file dengan kode sumber dapat digabungkan menjadi satu paket. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kondisi berikut harus dipenuhi:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> File dengan kode sumber harus berada di direktori yang sama di sistem file. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nama direktori ini harus sesuai dengan nama paket. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di awal setiap file sumber, paket yang dimiliki file ini harus ditunjukkan, misalnya: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan keunikan nama-nama paket di dunia, diusulkan untuk menggunakan nama domain "terbalik" perusahaan. </font><font style="vertical-align: inherit;">Namun, ini bukan persyaratan dan nama apa pun dapat digunakan dalam proyek lokal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga disarankan untuk menentukan nama paket huruf kecil. </font><font style="vertical-align: inherit;">Sehingga mereka dapat dengan mudah dibedakan dari nama kelas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penyembunyian implementasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aspek lain dari enkapsulasi adalah pemisahan antarmuka dan implementasi. Jika antarmuka dapat diakses ke bagian luar program (eksternal ke modul atau kelas), maka implementasinya tersembunyi. Dalam literatur, analogi kotak hitam sering digambarkan ketika implementasi internal "tidak terlihat" dari luar, tetapi apa yang dimasukkan ke dalam input kotak dan apa yang diberikannya adalah "terlihat". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di C, implementasi tersembunyi dilakukan di dalam modul, menandai fungsi yang seharusnya tidak terlihat dari luar dengan kata kunci statis. Prototipe fungsi yang membentuk antarmuka modul ditempatkan di file header. Modul dalam C berarti pasangan: file sumber dengan ekstensi * .c dan header dengan ekstensi * .h.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java juga memiliki kata kunci statis, tetapi tidak memengaruhi â€œvisibilitasâ€ metode atau bidang dari luar. </font><font style="vertical-align: inherit;">Untuk mengontrol "visibilitas" ada 3 pengubah akses: pribadi, dilindungi, publik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang dan metode kelas yang ditandai sebagai pribadi hanya tersedia di dalamnya. </font><font style="vertical-align: inherit;">Bidang dan metode yang dilindungi juga dapat diakses oleh keturunan kelas. </font><font style="vertical-align: inherit;">Pengubah publik berarti bahwa elemen yang ditandai dapat diakses dari luar kelas, yaitu, itu adalah bagian dari antarmuka. </font><font style="vertical-align: inherit;">Mungkin juga tidak ada pengubah, dalam hal ini akses ke elemen kelas dibatasi oleh paket di mana kelas berada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disarankan bahwa ketika menulis kelas, tandai semua bidang kelas sebagai pribadi dan memperpanjang hak akses yang diperlukan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Metode kelebihan beban </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu fitur menjengkelkan dari pustaka standar C adalah keberadaan seluruh kebun binatang fungsi yang pada dasarnya melakukan hal yang sama, tetapi berbeda dalam jenis argumen, misalnya: fabs (), fabsf (), fabsl (), berfungsi untuk mendapatkan nilai absolut untuk double, float dan long jenis ganda masing-masing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (dan juga C ++) mendukung mekanisme kelebihan metode - mungkin ada beberapa metode di dalam kelas dengan nama yang sama persis, tetapi berbeda dalam jenis dan jumlah argumen. </font><font style="vertical-align: inherit;">Dengan jumlah argumen dan jenisnya, kompiler akan memilih versi yang diperlukan dari metode itu sendiri - sangat nyaman dan meningkatkan keterbacaan program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Jawa, tidak seperti C ++, operator tidak dapat kelebihan beban. </font><font style="vertical-align: inherit;">Pengecualian adalah operator "+" dan "+ =", yang pada awalnya kelebihan beban untuk string String.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karakter dan String di Jawa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di C, Anda harus bekerja dengan string terminal-nol yang diwakili oleh pointer ke karakter pertama: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baris seperti itu harus diakhiri dengan karakter nol. </font><font style="vertical-align: inherit;">Jika tidak sengaja "dihapus", maka sebuah string akan dianggap sebagai urutan byte dalam memori hingga karakter nol pertama. </font><font style="vertical-align: inherit;">Yaitu, jika variabel program lain ditempatkan di memori setelah baris, maka setelah memodifikasi garis yang rusak, nilainya dapat (dan kemungkinan besar akan) terdistorsi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, seorang programmer-C tidak berkewajiban untuk menggunakan string null-terminal klasik, tetapi menerapkan implementasi pihak ketiga, tetapi di sini harus diingat bahwa semua fungsi dari perpustakaan standar memerlukan string null-terminal sebagai argumen mereka. </font><font style="vertical-align: inherit;">Selain itu, standar C tidak mendefinisikan pengkodean yang digunakan, titik ini juga harus dikontrol oleh programmer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Jawa, tipe char primitif (serta pembungkus Karakter, tentang pembungkus di bawah) mewakili karakter tunggal sesuai dengan standar Unicode. Encoding UTF-16 digunakan, masing-masing, satu karakter menempati 2 byte dalam memori, yang memungkinkan Anda untuk menyandikan hampir semua karakter bahasa yang saat ini digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakter dapat ditentukan oleh Unicode mereka:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Unicode karakter melebihi 216 maksimum untuk char, maka karakter seperti itu harus diwakili oleh int. Dalam string, itu akan menempati 2 karakter 16 bit, tetapi sekali lagi, karakter dengan kode melebihi 216 jarang digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String Java diimplementasikan oleh kelas String bawaan dan menyimpan karakter char 16-bit. Kelas String berisi semua atau hampir semua yang mungkin diperlukan untuk bekerja dengan string. Tidak perlu memikirkan fakta bahwa garis harus diakhiri dengan nol, di sini tidak mungkin untuk secara tak terlihat "menghapus" karakter penghentian nol ini atau mengakses memori di luar garis. Secara umum, ketika bekerja dengan string di Jawa, programmer tidak memikirkan bagaimana string disimpan dalam memori.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang disebutkan di atas, Java tidak mengizinkan overloading operator (seperti pada C ++), namun kelas String merupakan pengecualian - hanya untuk itu operator penggabung baris "+" dan "+ =" pada awalnya kelebihan beban. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patut dicatat bahwa string di Jawa tidak dapat diubah - setelah dibuat, mereka tidak mengizinkan perubahannya. </font><font style="vertical-align: inherit;">Ketika kami mencoba mengubah garis, misalnya, seperti ini:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi string asli tidak benar-benar berubah. </font><font style="vertical-align: inherit;">Alih-alih, salinan yang dimodifikasi dari string asli dibuat, yang pada gilirannya juga tidak berubah:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, setiap perubahan string pada kenyataannya menghasilkan penciptaan objek baru (pada kenyataannya, dalam kasus penggabungan string, kompiler dapat mengoptimalkan kode dan menggunakan kelas StringBuilder, yang akan dibahas nanti). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebetulan program itu sering perlu mengubah jalur yang sama. </font><font style="vertical-align: inherit;">Dalam kasus seperti itu, untuk mengoptimalkan kecepatan program dan konsumsi memori, Anda dapat mencegah pembuatan objek baris baru. </font><font style="vertical-align: inherit;">Untuk tujuan ini, kelas StringBuilder harus digunakan:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara terpisah, perlu disebutkan perbandingan string. </font><font style="vertical-align: inherit;">Kesalahan khas programmer Java pemula adalah membandingkan string menggunakan operator "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode tersebut tidak secara resmi mengandung kesalahan pada tahap kompilasi atau kesalahan runtime, tetapi ia bekerja secara berbeda dari yang diharapkan. </font><font style="vertical-align: inherit;">Karena semua objek dan string, termasuk di Jawa, diwakili oleh tautan, perbandingan dengan operator "==" memberikan perbandingan tautan, bukan nilai objek. </font><font style="vertical-align: inherit;">Artinya, hasilnya hanya akan benar jika 2 tautan benar-benar merujuk ke baris yang sama. </font><font style="vertical-align: inherit;">Jika string adalah objek yang berbeda dalam memori, dan Anda perlu membandingkan kontennya, maka Anda perlu menggunakan metode equals ():</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yang paling mengejutkan adalah bahwa dalam beberapa kasus, perbandingan menggunakan operator â€œ==â€ berfungsi dengan benar: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini karena, pada kenyataannya, someString dan anotherString merujuk ke objek yang sama dalam memori. </font><font style="vertical-align: inherit;">Compiler menempatkan string string yang sama dalam kumpulan string - yang disebut internment terjadi. </font><font style="vertical-align: inherit;">Lalu setiap kali string string yang sama muncul dalam program, tautan ke string dari kumpulan digunakan. </font><font style="vertical-align: inherit;">Pemintalan string mungkin dilakukan karena sifat kekekalan string. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun membandingkan konten string hanya diperbolehkan dengan metode equals (), di Jawa dimungkinkan untuk menggunakan string dengan benar dalam konstruksi case-switch (dimulai dengan Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anehnya, objek Java apa pun dapat dikonversi menjadi string. </font><font style="vertical-align: inherit;">Metode toString () yang sesuai didefinisikan dalam kelas dasar untuk semua kelas kelas Objek.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendekatan Penanganan Kesalahan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat memprogram dalam C, Anda mungkin menemukan pendekatan penanganan kesalahan berikut. Setiap fungsi perpustakaan mengembalikan tipe int. Jika fungsi berhasil, maka hasil ini adalah 0. Jika hasilnya bukan nol, ini menunjukkan kesalahan. Paling sering, kode kesalahan dilewatkan melalui nilai yang dikembalikan oleh fungsi. Karena fungsi hanya dapat mengembalikan satu nilai, dan sudah ditempati oleh kode kesalahan, hasil sebenarnya dari fungsi harus dikembalikan melalui argumen sebagai penunjuk, misalnya, seperti ini:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, ini adalah salah satu kasus ketika dalam program C menjadi perlu untuk menggunakan pointer ke pointer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terkadang mereka menggunakan pendekatan yang berbeda. Fungsi tidak mengembalikan kode kesalahan, tetapi langsung hasil eksekusi, biasanya dalam bentuk pointer. Situasi kesalahan ditunjukkan dengan pointer nol. Kemudian pustaka biasanya berisi fungsi terpisah yang mengembalikan kode kesalahan terakhir:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu cara atau yang lain, ketika pemrograman dalam C, kode yang berfungsi "berguna" dan kode yang bertanggung jawab untuk menangani kesalahan saling berhubungan, yang jelas tidak membuat program mudah dibaca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Java, jika Anda mau, Anda bisa menggunakan pendekatan yang dijelaskan di atas, tetapi di sini Anda bisa menerapkan cara yang sama sekali berbeda untuk menangani kesalahan - penanganan pengecualian (namun, seperti dalam C ++). Keuntungan penanganan pengecualian adalah dalam hal ini kode "berguna" dan kode yang bertanggung jawab untuk menangani kesalahan dan kontinjensi dipisahkan secara logis dari satu sama lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dicapai dengan menggunakan konstruksi try-catch: kode "berguna" ditempatkan di bagian percobaan, dan kode penanganan kesalahan ditempatkan di bagian tangkapan.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada situasi di mana tidak mungkin untuk memproses kesalahan dengan benar di tempat kejadiannya. </font><font style="vertical-align: inherit;">Dalam kasus seperti itu, indikasi ditempatkan dalam tanda tangan metode bahwa metode ini dapat menyebabkan jenis pengecualian ini:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang panggilan ke metode ini harus dibingkai dalam blok coba-tangkap, atau metode panggilan juga harus ditandai yang dapat membuang pengecualian ini. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurangnya preprosesor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak peduli betapa nyamannya preprosesor yang akrab dengan programmer C / C ++, ia tidak ada dalam bahasa Java. </font><font style="vertical-align: inherit;">Pengembang Java mungkin memutuskan bahwa itu hanya digunakan untuk memastikan portabilitas program, dan karena Java berjalan di mana-mana (hampir), preprocessor tidak diperlukan di dalamnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengkompensasi kurangnya preprosesor menggunakan bidang bendera statis dan memeriksa nilainya dalam program, jika perlu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita berbicara tentang organisasi pengujian, maka dimungkinkan untuk menggunakan anotasi dalam hubungannya dengan refleksi (refleksi).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array juga merupakan objek. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika bekerja dengan array di C, indeks keluar di luar batas array adalah kesalahan yang sangat berbahaya. </font><font style="vertical-align: inherit;">Kompiler tidak akan melaporkannya dengan cara apa pun, dan selama eksekusi program tidak akan dihentikan dengan pesan yang sesuai:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan besar, program akan melanjutkan eksekusi, tetapi nilai variabel yang ditemukan setelah array array dalam contoh di atas akan terdistorsi. Mendebug kesalahan seperti ini mungkin tidak mudah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Jawa, programmer dilindungi dari kesalahan yang sulit didiagnosis. Saat Anda mencoba melampaui batasan array, sebuah ArrayIndexOutOfBoundsException dilempar. Jika tangkapan pengecualian tidak diprogram menggunakan konstruk coba-coba, program macet dan pesan yang sesuai dikirim ke aliran kesalahan standar yang menunjukkan file dengan kode sumber dan nomor baris tempat array terlampaui. Artinya, diagnosis kesalahan tersebut menjadi masalah sepele.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku program Java ini dimungkinkan karena array di Jawa diwakili oleh suatu objek. </font><font style="vertical-align: inherit;">Array Java tidak dapat diubah ukurannya, ukurannya adalah kode-keras pada saat memori dialokasikan. </font><font style="vertical-align: inherit;">Saat run time, mendapatkan ukuran array sesederhana itu:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita berbicara tentang array multidimensi, maka, dibandingkan dengan bahasa C, Java menawarkan peluang menarik untuk mengatur array "ladder". </font><font style="vertical-align: inherit;">Untuk kasus array dua dimensi, ukuran setiap baris individu mungkin berbeda dari yang lain:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti dalam C, elemen-elemen array terletak di memori satu per satu, sehingga akses ke array dianggap paling efisien. </font><font style="vertical-align: inherit;">Jika Anda perlu melakukan operasi penyisipan / penghapusan elemen, atau membuat struktur data yang lebih kompleks, maka Anda perlu menggunakan koleksi, seperti kumpulan (Set), daftar (Daftar), peta (Peta). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kurangnya pointer dan ketidakmampuan untuk menambah tautan, akses ke elemen array dimungkinkan menggunakan indeks.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koleksi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seringkali fungsi array tidak cukup - maka Anda perlu menggunakan struktur data dinamis. Karena pustaka C standar tidak mengandung implementasi struktur data dinamis yang siap pakai, Anda harus menggunakan implementasi dalam kode sumber atau dalam bentuk pustaka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak seperti C, pustaka Java standar berisi sekumpulan implementasi struktur atau koleksi data dinamis, yang dinyatakan dalam Java. Semua koleksi dibagi menjadi 3 kelas besar: daftar, set, dan peta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar - array dinamis - memungkinkan Anda untuk menambah / menghapus item. Banyak yang tidak memastikan urutan elemen yang ditambahkan, tetapi menjamin bahwa tidak ada elemen duplikat. Kartu atau array asosiatif beroperasi dengan pasangan nilai kunci, dan nilai kuncinya unik - tidak boleh ada 2 pasangan dengan kunci yang sama di dalam kartu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk daftar, set, dan peta, ada banyak implementasi, yang masing-masing dioptimalkan untuk operasi tertentu. Sebagai contoh, daftar diimplementasikan oleh kelas ArrayList dan LinkedList, dengan ArrayList memberikan kinerja yang lebih baik ketika mengakses elemen arbitrer, dan LinkedList lebih efisien ketika menyisipkan / menghapus elemen di tengah daftar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya objek Java lengkap yang dapat disimpan dalam koleksi (pada kenyataannya, referensi ke objek), oleh karena itu tidak mungkin untuk membuat kumpulan primitif secara langsung (int, char, byte, dll.). </font><font style="vertical-align: inherit;">Dalam hal ini, kelas pembungkus yang tepat harus digunakan:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitif </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas pembungkus </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendek </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendek </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karakter </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integer </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> panjang </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panjang </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengapung </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengapung </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dobel </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dobel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> boolean </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolean </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, ketika pemrograman di Jawa, tidak perlu mengikuti kebetulan yang tepat dari tipe primitif dan "pembungkusnya". </font><font style="vertical-align: inherit;">Jika metode menerima argumen, misalnya, dari tipe Integer, maka itu dapat melewati tipe int. </font><font style="vertical-align: inherit;">Dan sebaliknya, di mana tipe int diperlukan, Anda dapat menggunakan Integer dengan aman. </font><font style="vertical-align: inherit;">Ini dimungkinkan berkat mekanisme bawaan Java untuk pengemasan / pembongkaran primitif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari saat-saat yang tidak menyenangkan, harus disebutkan bahwa perpustakaan Java standar berisi kelas koleksi lama yang tidak berhasil diimplementasikan dalam versi pertama Java dan yang tidak boleh digunakan dalam program baru. </font><font style="vertical-align: inherit;">Ini adalah kelas Enumeration, Vector, Stack, Dictionary, Hashtable, Properties.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generalisasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koleksi umumnya digunakan sebagai tipe data generik. </font><font style="vertical-align: inherit;">Inti dari generalisasi dalam kasus ini adalah bahwa kami menentukan jenis utama koleksi, misalnya, ArrayList, dan dalam kurung sudut menentukan jenis parameter, yang dalam hal ini menentukan jenis elemen yang disimpan dalam daftar:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini memungkinkan kompiler untuk melacak upaya untuk menambahkan objek tipe selain parameter tipe yang ditentukan: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sangat penting bahwa tipe-parameter dihapus selama eksekusi program, dan tidak ada perbedaan antara, misalnya, objek kelas </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan objek kelas </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;String&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akibatnya, tidak ada cara untuk mengetahui jenis elemen koleksi selama eksekusi program: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solusi parsial dapat berupa pendekatan berikut: ambil elemen pertama dari koleksi dan tentukan jenisnya: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi pendekatan ini tidak akan berfungsi jika daftar kosong. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, generalisasi Java secara signifikan lebih rendah daripada generalisasi C ++. </font><font style="vertical-align: inherit;">Generalisasi Java sebenarnya berfungsi untuk "memotong" beberapa kesalahan potensial pada tahap kompilasi.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ulangi semua elemen array atau koleksi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat memprogram dalam C, Anda sering harus mengulangi semua elemen array: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat kesalahan di sini lebih sederhana, cukup tentukan ukuran yang salah dari array SIZE atau letakkan "&lt;=" bukannya "&lt;". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Jawa, selain bentuk "biasa" dari pernyataan for, ada bentuk untuk mengulangi semua elemen array atau koleksi (sering disebut foreach dalam bahasa lain):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini kita dijamin untuk beralih ke semua elemen daftar, kesalahan yang melekat dalam bentuk "biasa" dari pernyataan for dihilangkan. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koleksi Lain-lain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena semua objek diwarisi dari Objek root, Java memiliki peluang menarik untuk membuat daftar dengan berbagai jenis elemen aktual: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membandingkan C / C ++ dan Java, tidak mungkin untuk tidak memperhatikan berapa banyak enumerasi fungsional diimplementasikan di Jawa. </font><font style="vertical-align: inherit;">Di sini enumerasi adalah kelas penuh, dan elemen enumerasi adalah objek dari kelas ini. </font><font style="vertical-align: inherit;">Ini memungkinkan satu elemen enumerasi untuk mengatur beberapa bidang jenis apa pun menjadi korespondensi:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai kelas lengkap, enumerasi dapat memiliki metode, dan menggunakan konstruktor pribadi, Anda dapat mengatur nilai bidang elemen enumerasi individu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada peluang reguler untuk mendapatkan representasi string dari elemen enumerasi, nomor seri, dan juga array semua elemen:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sebaliknya - dengan representasi string, Anda bisa mendapatkan elemen enumerasi, dan juga memanggil metode-metodenya: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara alami, enumerasi dapat digunakan dalam konstruksi kasus sakelar. </font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, bahasa C dan Java dirancang untuk menyelesaikan masalah yang sama sekali berbeda. Tetapi, jika kita tetap membandingkan proses pengembangan perangkat lunak dalam dua bahasa ini, maka, menurut kesan subjektif penulis, bahasa Jawa secara signifikan melampaui C dalam kenyamanan dan kecepatan penulisan program. Lingkungan pengembangan (IDE) memainkan peran penting dalam memberikan kenyamanan. Penulis bekerja dengan IDE IntelliJ IDEA. Saat memprogram di Jawa, Anda tidak harus selalu "takut" untuk melakukan kesalahan - seringkali lingkungan pengembangan akan memberi tahu Anda apa yang perlu diperbaiki, dan kadang-kadang itu akan melakukannya untuk Anda. Jika kesalahan runtime terjadi, maka jenis kesalahan dan tempat kemunculannya dalam kode sumber selalu ditunjukkan dalam log - perjuangan melawan kesalahan tersebut menjadi masalah sepele. Seorang programmer C tidak perlu melakukan upaya yang tidak manusiawi untuk beralih ke Java, dan semua karena sintaks bahasa telah sedikit berubah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pengalaman ini akan menarik bagi pembaca, pada artikel selanjutnya kita akan berbicara tentang pengalaman menggunakan mekanisme JNI (menjalankan kode C / C ++ asli dari aplikasi Java). </font><font style="vertical-align: inherit;">Mekanisme JNI sangat diperlukan ketika Anda ingin mengontrol resolusi layar, modul Bluetooth, dan dalam kasus lain ketika kemampuan layanan dan manajer Android tidak cukup.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412775/">https://habr.com/ru/post/id412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412763/index.html">Menggunakan Papan Reload Firefly-RK3288 dengan RockChip RK3288 SoC Microchip Digital I2C Thermal Sensor - MCP9808</a></li>
<li><a href="../id412765/index.html">Pengantar sistem kartu ubin Unity baru</a></li>
<li><a href="../id412767/index.html">CMG dampak ulasan konferensi 2016</a></li>
<li><a href="../id412769/index.html">Saya melakukan PWA dan meletakkannya di tiga app store. Dan inilah yang saya temukan</a></li>
<li><a href="../id412773/index.html">Minsk astro-aerospace</a></li>
<li><a href="../id412777/index.html">Mahakarya konstruksi kolom dunia: QUAD 11L - "rak" terbaik dari yang kedua ribu</a></li>
<li><a href="../id412779/index.html">SSLH: Sembunyikan SSH / HTTPS / OpenVPN / Telegram di belakang satu port 443</a></li>
<li><a href="../id412781/index.html">Penggemar NES telah memungkinkan untuk meluncurkan game SNES di konsol</a></li>
<li><a href="../id412783/index.html">Menginstal proksi MTProto Telegram dari sumber pada Centos 7</a></li>
<li><a href="../id412785/index.html">Magister Manajemen dan Freelancer. Kisahnya dalam tiga bagian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>