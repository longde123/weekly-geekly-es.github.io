<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé® üôÖüèΩ üëÇüèº Erfahrung in der Implementierung von Automatisierung im Prozess des manuellen Testens am Beispiel einer Android-Anwendung üë®üèΩ‚ÄçüöÄ üè£ ‚ùé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein guter Tester mit F√§higkeiten zum kritischen Denken kann nicht vollst√§ndig durch Automatisierung ersetzt werden. Es ist einfach, es effizienter zu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erfahrung in der Implementierung von Automatisierung im Prozess des manuellen Testens am Beispiel einer Android-Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434252/">  <i>Ein guter Tester mit F√§higkeiten zum kritischen Denken kann nicht vollst√§ndig durch Automatisierung ersetzt werden.</i>  <i>Es ist einfach, es effizienter zu machen.</i>  <i>Mit dieser √úberzeugung ging ich mit einer neuen Aufgabe zu unserer Testabteilung, wo wir zusammen mit Pavel die Implementierung aufnahmen.</i>  <i>Mal sehen, was daraus wurde.</i> <br><br>  Gemeinsam mit unseren Partnern entwickeln, testen und unterst√ºtzen wir aktiv eine Reihe von Anwendungen f√ºr verschiedene Plattformen: Android, iOS, Windows.  Es entwickeln sich aktiv Anwendungen, mit denen das Testvolumen zunimmt, vor allem die Regression. <br><br>  Wir haben uns entschlossen, das Testen durch Automatisierung der meisten Testszenarien zu vereinfachen und zu beschleunigen.  Gleichzeitig wollten wir den Prozess des manuellen Testens nicht vollst√§ndig aufgeben, sondern modifizieren. <br><br>  Die Implementierung dieses Ansatzes begann mit einer der Android-Anwendungen, √ºber die ich sprechen werde.  Der Artikel ist f√ºr Anf√§nger von UI-Tests, vor allem f√ºr mobile Anwendungen, sowie f√ºr diejenigen von Interesse, die den manuellen Testprozess in gewissem Ma√üe automatisieren m√∂chten. <br><br>  Lass uns gehen! <a name="habracut"></a><br><br><h2>  Ausgangspunkt </h2><br>  F√ºr jede Plattform gibt es mehrere √§hnliche Plattformen, die denselben Hauptgesch√§ftsprozess von Anwendungen ausf√ºhren.  Sie unterscheiden sich jedoch in einer Reihe kleiner Zusatzfunktionen, werden je nach Kunde unter verschiedenen Marken hergestellt (aufgrund derer sich die Benutzeroberfl√§che von Anwendung zu Anwendung √§ndert), und der Gesch√§ftsprozess kann durch Hinzuf√ºgen zus√§tzlicher Schritte angepasst werden. <br><br>  Wir stehen vor bestimmten Problemen, die angegangen werden m√ºssen.  √Ñhnliche Schwierigkeiten k√∂nnen in einer anderen Situation als unserer auftreten.  Wenn Sie beispielsweise eine umfangreiche Anwendung mit schwieriger Gesch√§ftslogik haben, die mit vielen Tests √ºberwachsen ist. <br><br><h4>  Problem Nr. 1: viele Regressionstests </h4><br>  Die Testszenarien f√ºr jede Anwendung sind gleichzeitig √§hnlich und voneinander verschieden, was zu einer Erh√∂hung der Regression beitr√§gt und sie noch langweiliger macht.  Sie m√ºssen jedoch alle Anwendungen einzeln testen. <br><br>  In Anbetracht der Tatsache, dass bereits ausgef√ºhrte Anwendungen regelm√§√üig aktualisiert werden und es in Zukunft nur noch mehr geben wird, wird die Gesamtzahl der Tests unaufhaltsam zunehmen. <br><br><h4>  Problem Nummer 2: Sie m√ºssen auf allen Versionen des mobilen Betriebssystems testen </h4><br>  Eine wichtige Voraussetzung ist die Verf√ºgbarkeit unserer mobilen Anwendungen auf einer Vielzahl von Betriebssystemversionen.  Im Fall von Android zum Zeitpunkt des Schreibens sind dies beispielsweise API-Ebenen von 17 bis 28. <br><br>  Idealerweise sollten wir auf jeder Android-Version testen, was unsere Regression weiter erschwert.  Der Prozess des direkten Testens der Anwendung erh√§lt eine zus√§tzliche Routine multipliziert mit der Anzahl der Ger√§te: Installieren und Ausf√ºhren der Anwendung, Versetzen in den urspr√ºnglichen Zustand nach jedem einzelnen Test, Entfernen.  Gleichzeitig ist die Pflege Ihrer eigenen Ger√§tefarm sehr arbeitsintensiv. <br><br><h4>  L√∂sung: Integrieren Sie die Automatisierung in den manuellen Testprozess </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/gc/pf/tsgcpf5ughy1cerkbpdpkkuqxww.jpeg"></div><br>  Eine typische Aufgabe der Testautomatisierung ist die Automatisierung von Regressionstests.  Deshalb wollen wir die Effizienz des Testprozesses heute verbessern und die m√∂glichen Folgen des Wachstums von morgen verhindern. <br><br>  Gleichzeitig sind wir uns bewusst, dass es unm√∂glich und unn√∂tig ist, manuelle Tests durch Automatisierung vollst√§ndig zu beseitigen.  Kritisches Denken und das menschliche Auge sind schwer durch etwas zu ersetzen.  Es gibt einen guten Artikel zu diesem Thema in Michael Boltons Blog The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End of Manual Testing</a> (oder einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> von Anna Rodionova). <br><br>  Wir dachten, es w√§re n√ºtzlich, eine Reihe automatisierter Tests zu haben, die die stabilen Teile der Anwendung abdecken, und in Zukunft Tests f√ºr gefundene Fehler und neue Funktionen zu schreiben.  Gleichzeitig m√∂chten wir Autotests mit vorhandenen Testsuiten in unserem Testmanagementsystem verkn√ºpfen (wir verwenden TestRail) und Testern die einfache Ausf√ºhrung von Autotests auf physischen Cloud-Ger√§ten erm√∂glichen (wir haben Firebase Test Lab als Cloud-Infrastruktur ausgew√§hlt). <br><br>  Zu Beginn haben wir eine unserer Android-Anwendungen verwendet.  Es war wichtig zu ber√ºcksichtigen, dass bei Erfolg der L√∂sung die Best Practices auf unsere anderen Anwendungen angewendet werden k√∂nnen, auch auf anderen Plattformen. <br><br>  Was wir als Ergebnis bekommen wollen: <br><br><ol><li>  Automatisierung von Regressionstests. </li><li>  Integration in das Testmanagementsystem. </li><li>  M√∂glichkeit des parametrisierten manuellen Starts von Autotests auf Cloud-Ger√§ten. </li><li>  Die M√∂glichkeit, die L√∂sung in Zukunft wiederzuverwenden. </li></ol><br>  Als n√§chstes werde ich separat √ºber die Implementierung jedes dieser Punkte mit einem kleinen Eintauchen in die technische Komponente sprechen. <br><br><h2>  Allgemeines L√∂sungsimplementierungsschema </h2><br>  Aber zuerst ein allgemeiner √úberblick dar√ºber, was wir bekommen haben: <br><br><img src="https://habrastorage.org/webt/k3/dc/yf/k3dcyf4d-az9yt4ce0dqgseko6m.png" alt="Bild"><br><br>  Automatische Tests werden auf zwei Arten ausgef√ºhrt: <br><br><ol><li>  Von CI nach dem Zusammenf√ºhren oder Ziehen der Anforderung an den Master. </li><li>  Testen Sie manuell √ºber die Jenkins Job-Weboberfl√§che. </li></ol><br>  Bei einem manuellen Start muss der Tester entweder die Nummer des entsprechenden Builds angeben oder 2 APKs vom Computer herunterladen: mit der Anwendung und mit den Tests.  Diese Methode wird ben√∂tigt, damit Sie die erforderlichen Tests jederzeit auf allen verf√ºgbaren Ger√§ten ausf√ºhren k√∂nnen. <br><br>  W√§hrend der Tests werden ihre Ergebnisse an TestRail gesendet.  Dies geschieht auf die gleiche Weise, als ob der Tester den Test manuell durchgef√ºhrt und die Ergebnisse auf eine ihm vertraute Weise eingegeben h√§tte. <br><br>  Daher haben wir den etablierten Prozess des manuellen Testens verlassen, aber die Automatisierung hinzugef√ºgt, die eine bestimmte Reihe von Tests durchf√ºhrt.  Der Tester "nimmt" auf, was automatisch gemacht wurde, und: <br><br><ul><li>  sieht das Ergebnis von Testf√§llen auf jedem ausgew√§hlten Ger√§t; </li><li>  kann jeden Testfall manuell √ºberpr√ºfen; </li><li>  f√ºhrt Testf√§lle durch, die noch nicht automatisiert sind oder aus irgendeinem Grund nicht optimiert werden k√∂nnen; </li><li>  trifft die endg√ºltige Entscheidung √ºber den aktuellen Testlauf. </li></ul><br>  Fahren wir nun mit der versprochenen Beschreibung der Implementierung fort. <br><br><h2>  1. Automatische Tests </h2><br><h4>  Die Werkzeuge </h4><br>  Wir haben 3 Tools verwendet, um mit der Benutzeroberfl√§che zu interagieren: <br><br><ul><li>  Espresso </li><li>  Barista. </li><li>  UI Automator. </li></ul><br>  Das Hauptwerkzeug und das, mit dem wir begonnen haben, ist Espresso.  Das Hauptargument f√ºr seine Wahl war die Tatsache, dass Sie mit Espresso Tests mit der White-Box-Methode durchf√ºhren k√∂nnen, um Zugriff auf Android Instrumentation zu erhalten.  Der Testcode befindet sich im selben Projekt wie der Anwendungscode. <br><br>  Der Zugriff auf den Android-Anwendungscode ist erforderlich, um seine Methoden in Tests aufrufen zu k√∂nnen.  Wir k√∂nnen unsere Anwendung im Voraus auf einen bestimmten Test vorbereiten, indem wir sie im richtigen Zustand ausf√ºhren.  Andernfalls m√ºssen wir diesen Zustand √ºber die Schnittstelle erreichen, die Atomizit√§tstests entzieht, sie voneinander abh√§ngig macht und einfach viel Zeit in Anspruch nimmt. <br><br>  W√§hrend der Implementierung wurde Espresso ein weiteres Tool hinzugef√ºgt - UI Automator.  Beide Frameworks sind Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android Testing Support Library</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google</a> .  Mit dem UI Automator k√∂nnen wir mit verschiedenen Systemdialogen oder beispielsweise mit Notification Drawer interagieren. <br><br>  Und das letzte in unserem Arsenal war das Barista-Framework.  Es ist ein Wrapper um Espresso, der Ihnen den Boilerplate-Code erspart, wenn Sie allgemeine Benutzeraktionen implementieren. <br><br>  Unter Ber√ºcksichtigung des Wunsches, die L√∂sung in anderen Anwendungen wiederverwenden zu k√∂nnen, ist zu beachten, dass die aufgef√ºhrten Tools ausschlie√ülich f√ºr Android-Anwendungen bestimmt sind.  Wenn Sie keinen Zugriff auf den Code der zu testenden Anwendung ben√∂tigen, bevorzugen Sie wahrscheinlich die Verwendung eines anderen Frameworks.  Zum Beispiel das heute sehr beliebte Appium.  Sie k√∂nnen aber auch versuchen, mit Hilfe von Backdoors zum Anwendungscode zu gelangen, was ein guter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> im Badoo-Blog ist.  Sie haben die Wahl. <br><br><h4>  Implementierung </h4><br>  Als Entwurfsmuster haben wir Testroboter ausgew√§hlt, die Jake Wharton im gleichnamigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht vorgeschlagen hat</a> .  Die Idee dieses Ansatzes √§hnelt dem allgemeinen Seitenobjekt-Entwurfsmuster, das beim Testen von Websystemen verwendet wird.  Die Programmiersprache ist Java. <br><br>  F√ºr jedes unabh√§ngige Fragment der Anwendung wird eine spezielle Roboterklasse erstellt, in der die Gesch√§ftslogik implementiert ist.  Die Wechselwirkung mit jedem Element des Fragments wird in einem separaten Verfahren beschrieben.  Dar√ºber hinaus werden hier auch alle in diesem Fragment durchgef√ºhrten Behauptungen beschrieben. <br><br>  Betrachten Sie ein einfaches Beispiel.  Das beschriebene Fragment enth√§lt mehrere Felder zur Dateneingabe und eine Aktionsschaltfl√§che: <br><br><img src="https://habrastorage.org/webt/po/-a/il/po-ail1n2mqlusukvegg9ry1tdm.png" alt="Bild"><br><br>  Der Code des Anmeldefunktionstests selbst: <br><br><img src="https://habrastorage.org/webt/s2/ot/sd/s2otsd2q-li_26a9vkx_-s_9__g.png" alt="Bild"><br><br>  Hier √ºberpr√ºfen wir das positive Szenario, wenn die eingegebenen Authentifizierungsdaten korrekt sind.  Die Daten selbst werden den Eingabetests unterzogen oder die Standardwerte werden verwendet.  Somit hat der Tester die M√∂glichkeit, hinsichtlich der Testdaten zu parametrisieren. <br><br>  Diese Struktur bietet den Tests zun√§chst eine hervorragende Lesbarkeit, wenn das gesamte Skript in die Hauptschritte der Ausf√ºhrung unterteilt ist.  Die Idee, Aussagen auf die einzelnen Methoden des entsprechenden Roboters zu √ºbertragen, hat uns auch sehr gut gefallen.  Assert wird zum gleichen Schritt, ohne die allgemeine Kette zu durchbrechen, und Ihre Tests wissen immer noch nichts √ºber die Anwendung. <br><br>  In dem oben genannten Bericht gibt Jake Wharton eine Implementierung in Kotlin, wo sie endlich ist.  Wir haben es bereits bei einem anderen Projekt versucht und es hat uns sehr gut gefallen. <br><br><h2>  2. Integration mit dem Testmanagementsystem </h2><br>  Vor der Einf√ºhrung der Automatisierung haben wir alle unsere Tests im TestRail-Testmanagementsystem durchgef√ºhrt.  Die gute Nachricht war, dass es eine ziemlich gute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TestRail-API gibt</a> , mit der wir bereits im System etablierte Testf√§lle mit Autotests verbinden konnten. <br><br>  W√§hrend des Testlaufs mit JUnit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RunListener</a> werden verschiedene Ereignisse abgefangen, z. B. <code>testRunStarted</code> , <code>testFailure</code> , <code>testFinished</code> , in denen wir die Ergebnisse an TestRail senden.  Wenn Sie AndroidJUnitRunner verwenden, muss er auf bestimmte Weise √ºber Ihren RunListener informieren, wie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation beschrieben.</a> <br><br>  Sie m√ºssen auch mit verschiedenen TestRail-Entit√§ten √ºber deren ID kommunizieren.  <code>@CaseId</code> den Test mit dem entsprechenden Testfall zu verbinden, haben wir eine einfache Annotation <code>@CaseId</code> , deren Verwendung im obigen Beispiel f√ºr die <code>@CaseId</code> gezeigt wird. <br><br>  Code zur Implementierung der Anmerkung selbst: <br><br><img src="https://habrastorage.org/webt/oq/pz/2m/oqpz2mc9f_lfnujvzaj2ohpuicc.png" alt="Bild"><br><br>  Es bleibt nur, um seinen Wert an der richtigen Stelle aus der Beschreibung zu erhalten: <br><br><img src="https://habrastorage.org/webt/4h/bb/wa/4hbbwa2srlfwol2yies25mm07a8.png" alt="Bild"><br><br><h2>  3. Manueller Start von Autotests auf Cloud-Ger√§ten </h2><br><h4>  Startparametrierung in Jenkins Job </h4><br>  Um den manuellen Start von Autotests zu organisieren, verwenden wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Free-Style Jenkins Job</a> .  Diese Option wurde gew√§hlt, weil das Unternehmen bereits Erfahrung mit √§hnlichen Arbeiten mit Jenkins Job in anderen Bereichen hatte, insbesondere mit DevOps-Ingenieuren, die sie gerne teilten. <br><br>  Jenkins Job f√ºhrt ein Skript aus, das auf Daten basiert, die von der Weboberfl√§che √ºbertragen wurden.  Somit ist die Parametrisierung von Testl√§ufen implementiert.  In unserem Fall initiiert das Bash-Skript den Start von Tests auf den Firebase-Cloud-Ger√§ten. <br><br>  Die Parametrierung umfasst: <br><br><ul><li>  Auswahl der gew√ºnschten APK durch Angabe der Nummer des entsprechenden Builds oder manuelles Herunterladen. </li><li>  Geben Sie alle Arten von Testdaten ein. </li><li>  Eingabe zus√§tzlicher benutzerdefinierter Daten f√ºr TestRail. </li><li>  W√§hlen Sie aus der im Firebase Test Lab verf√ºgbaren Liste Cloud-basierte physische Ger√§te aus, auf denen Tests ausgef√ºhrt werden sollen. </li><li>  Die Auswahl der durchzuf√ºhrenden Testkits. </li></ul><br>  Schauen wir uns einen Teil der Webseite unseres Jenkins-Jobs anhand eines Beispiels f√ºr eine Ger√§teauswahloberfl√§che und Testsuiten an: <br><br><img src="https://habrastorage.org/webt/lm/d9/_p/lmd9_pih-p4lu5i_7gd6d2rcazc.png" alt="Bild"><br><br>  Jedes Element, in das Sie Daten eingeben oder ausw√§hlen k√∂nnen, wird von speziellen Jenkins-Plugins implementiert.  Beispielsweise wird die Ger√§teauswahloberfl√§che √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Active Choices Plugin erstellt</a> .  Mit einem groovigen Skript von Firebase wird eine Liste der verf√ºgbaren Ger√§te abgerufen, die dann in der gew√ºnschten Form auf der Webseite angezeigt wird. <br><br>  Nachdem alle erforderlichen Daten eingegeben wurden, wird das entsprechende Skript gestartet, dessen Fortschritt wir im Abschnitt Konsolenausgabe beobachten k√∂nnen: <br><br><img src="https://habrastorage.org/webt/vo/ie/ul/voieulwwrlhexdhsxpw2wwg-qga.png" alt="Bild"><br><br>  Von hier aus kann der Tester, der den Testlauf initiiert hat, unter Verwendung der empfangenen URLs zu TestRail oder zur Firebase-Konsole wechseln, die viele n√ºtzliche Informationen zum Ausf√ºhren von Tests auf jedem der ausgew√§hlten Ger√§te enth√§lt. <br><br><h4>  Endg√ºltige Testmatrix im Firebase-Testlabor </h4><br>  Die Ger√§tematrix in Firebase enth√§lt die Verteilung der Tests nach den Ger√§ten, auf denen sie ausgef√ºhrt wurden: <br><br><img src="https://habrastorage.org/webt/um/bs/5w/umbs5w2ehvo69ih127ep8i6ulvo.png" alt="Bild"><br><br>  F√ºr jedes Ger√§t k√∂nnen Sie das vollst√§ndige Protokoll, das Video des Testlaufs und verschiedene Leistungsindikatoren anzeigen.  Dar√ºber hinaus k√∂nnen Sie auf alle Dateien zugreifen, die m√∂glicherweise w√§hrend der Ausf√ºhrung der Tests erstellt wurden.  Wir verwenden dies, um Testabdeckungsindikatoren vom Ger√§t herunterzuladen. <br><br>  Wir haben uns f√ºr Firebase entschieden, da wir diesen Service bereits zur L√∂sung anderer Probleme genutzt haben und mit der Preispolitik zufrieden sind.  Wenn Sie 30 Minuten reine Zeit zum Testen pro Tag haben, m√ºssen Sie √ºberhaupt nicht bezahlen.  Dies kann ein weiterer Grund sein, warum es wichtig ist, nur bestimmte Tests ausf√ºhren zu k√∂nnen. <br><br>  M√∂glicherweise bevorzugen Sie eine andere Cloud-Infrastruktur, die auch gut zu Ihrem Testprozess passt. <br><br><h2>  4. Wiederverwenden </h2><br>  Wie kann all dies in Zukunft genutzt werden?  Aus Sicht der Codebasis ist diese L√∂sung nur f√ºr Android-Anwendungen anwendbar.  W√§hrend der Implementierung haben wir beispielsweise die <code>UiAutomatorExtensions</code> <code>EspressoExtensions</code> und <code>UiAutomatorExtensions</code> , in denen wir verschiedene Optionen f√ºr die Interaktion mit der Schnittstelle kapseln und warten, bis die Elemente bereit sind.  Dies schlie√üt auch die RunListener-Klasse ein, die f√ºr die Integration in TestRail verantwortlich ist.  Wir haben sie bereits in separaten Modulen platziert und verwenden sie zur Automatisierung anderer Anwendungen. <br><br>  Wenn wir √ºber andere Plattformen sprechen, k√∂nnen die gesammelten Erfahrungen sehr n√ºtzlich sein, um √§hnliche Prozesse aufzubauen und zu implementieren.  Wir tun dies aktiv im iOS-Bereich und denken √ºber Windows nach. <br><br><h2>  Fazit </h2><br>  Es gibt viele Optionen f√ºr die Implementierung und Verwendung der Testautomatisierung.  Wir sind der Meinung, dass Automatisierung in erster Linie ein Werkzeug ist, das den traditionellen Prozess des "menschlichen" Testens erleichtern und nicht ausl√∂schen soll. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434252/">https://habr.com/ru/post/de434252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434236/index.html">Das neuronale Netz mit einer Am√∂be l√∂ste das Problem der Handlungsreisenden f√ºr 8 St√§dte</a></li>
<li><a href="../de434238/index.html">Intel OpenVINO auf Raspberry Pi: Ernte 2018</a></li>
<li><a href="../de434244/index.html">Ich bin Mamas Algo-H√§ndler: Ich suche nach kostenlosen Frameworks zum Testen von Hypothesen und zum Starten im Kampfmodus (Python).</a></li>
<li><a href="../de434246/index.html">Apple best√§tigt, dass einige iPad-Profis leicht gebogen sind, sagt aber, dass es in Ordnung ist</a></li>
<li><a href="../de434250/index.html">2019 Netzwerksicherheitstrends</a></li>
<li><a href="../de434254/index.html">Das Beste jagen</a></li>
<li><a href="../de434258/index.html">Winterpraktikum f√ºr mobile Entwickler bei Redmadrobot</a></li>
<li><a href="../de434260/index.html">Microsoft veranstaltet einen AI Agent-Wettbewerb f√ºr Minecraft</a></li>
<li><a href="../de434262/index.html">Schreiben und Kompilieren eines Albums f√ºr Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
<li><a href="../de434264/index.html">Intel ‚ùÑ 2018. Ergebnisse des Jahres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>