<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎨 🙅🏽 👂🏼 Erfahrung in der Implementierung von Automatisierung im Prozess des manuellen Testens am Beispiel einer Android-Anwendung 👨🏽‍🚀 🏣 ❎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein guter Tester mit Fähigkeiten zum kritischen Denken kann nicht vollständig durch Automatisierung ersetzt werden. Es ist einfach, es effizienter zu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erfahrung in der Implementierung von Automatisierung im Prozess des manuellen Testens am Beispiel einer Android-Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434252/">  <i>Ein guter Tester mit Fähigkeiten zum kritischen Denken kann nicht vollständig durch Automatisierung ersetzt werden.</i>  <i>Es ist einfach, es effizienter zu machen.</i>  <i>Mit dieser Überzeugung ging ich mit einer neuen Aufgabe zu unserer Testabteilung, wo wir zusammen mit Pavel die Implementierung aufnahmen.</i>  <i>Mal sehen, was daraus wurde.</i> <br><br>  Gemeinsam mit unseren Partnern entwickeln, testen und unterstützen wir aktiv eine Reihe von Anwendungen für verschiedene Plattformen: Android, iOS, Windows.  Es entwickeln sich aktiv Anwendungen, mit denen das Testvolumen zunimmt, vor allem die Regression. <br><br>  Wir haben uns entschlossen, das Testen durch Automatisierung der meisten Testszenarien zu vereinfachen und zu beschleunigen.  Gleichzeitig wollten wir den Prozess des manuellen Testens nicht vollständig aufgeben, sondern modifizieren. <br><br>  Die Implementierung dieses Ansatzes begann mit einer der Android-Anwendungen, über die ich sprechen werde.  Der Artikel ist für Anfänger von UI-Tests, vor allem für mobile Anwendungen, sowie für diejenigen von Interesse, die den manuellen Testprozess in gewissem Maße automatisieren möchten. <br><br>  Lass uns gehen! <a name="habracut"></a><br><br><h2>  Ausgangspunkt </h2><br>  Für jede Plattform gibt es mehrere ähnliche Plattformen, die denselben Hauptgeschäftsprozess von Anwendungen ausführen.  Sie unterscheiden sich jedoch in einer Reihe kleiner Zusatzfunktionen, werden je nach Kunde unter verschiedenen Marken hergestellt (aufgrund derer sich die Benutzeroberfläche von Anwendung zu Anwendung ändert), und der Geschäftsprozess kann durch Hinzufügen zusätzlicher Schritte angepasst werden. <br><br>  Wir stehen vor bestimmten Problemen, die angegangen werden müssen.  Ähnliche Schwierigkeiten können in einer anderen Situation als unserer auftreten.  Wenn Sie beispielsweise eine umfangreiche Anwendung mit schwieriger Geschäftslogik haben, die mit vielen Tests überwachsen ist. <br><br><h4>  Problem Nr. 1: viele Regressionstests </h4><br>  Die Testszenarien für jede Anwendung sind gleichzeitig ähnlich und voneinander verschieden, was zu einer Erhöhung der Regression beiträgt und sie noch langweiliger macht.  Sie müssen jedoch alle Anwendungen einzeln testen. <br><br>  In Anbetracht der Tatsache, dass bereits ausgeführte Anwendungen regelmäßig aktualisiert werden und es in Zukunft nur noch mehr geben wird, wird die Gesamtzahl der Tests unaufhaltsam zunehmen. <br><br><h4>  Problem Nummer 2: Sie müssen auf allen Versionen des mobilen Betriebssystems testen </h4><br>  Eine wichtige Voraussetzung ist die Verfügbarkeit unserer mobilen Anwendungen auf einer Vielzahl von Betriebssystemversionen.  Im Fall von Android zum Zeitpunkt des Schreibens sind dies beispielsweise API-Ebenen von 17 bis 28. <br><br>  Idealerweise sollten wir auf jeder Android-Version testen, was unsere Regression weiter erschwert.  Der Prozess des direkten Testens der Anwendung erhält eine zusätzliche Routine multipliziert mit der Anzahl der Geräte: Installieren und Ausführen der Anwendung, Versetzen in den ursprünglichen Zustand nach jedem einzelnen Test, Entfernen.  Gleichzeitig ist die Pflege Ihrer eigenen Gerätefarm sehr arbeitsintensiv. <br><br><h4>  Lösung: Integrieren Sie die Automatisierung in den manuellen Testprozess </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/gc/pf/tsgcpf5ughy1cerkbpdpkkuqxww.jpeg"></div><br>  Eine typische Aufgabe der Testautomatisierung ist die Automatisierung von Regressionstests.  Deshalb wollen wir die Effizienz des Testprozesses heute verbessern und die möglichen Folgen des Wachstums von morgen verhindern. <br><br>  Gleichzeitig sind wir uns bewusst, dass es unmöglich und unnötig ist, manuelle Tests durch Automatisierung vollständig zu beseitigen.  Kritisches Denken und das menschliche Auge sind schwer durch etwas zu ersetzen.  Es gibt einen guten Artikel zu diesem Thema in Michael Boltons Blog The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End of Manual Testing</a> (oder einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> von Anna Rodionova). <br><br>  Wir dachten, es wäre nützlich, eine Reihe automatisierter Tests zu haben, die die stabilen Teile der Anwendung abdecken, und in Zukunft Tests für gefundene Fehler und neue Funktionen zu schreiben.  Gleichzeitig möchten wir Autotests mit vorhandenen Testsuiten in unserem Testmanagementsystem verknüpfen (wir verwenden TestRail) und Testern die einfache Ausführung von Autotests auf physischen Cloud-Geräten ermöglichen (wir haben Firebase Test Lab als Cloud-Infrastruktur ausgewählt). <br><br>  Zu Beginn haben wir eine unserer Android-Anwendungen verwendet.  Es war wichtig zu berücksichtigen, dass bei Erfolg der Lösung die Best Practices auf unsere anderen Anwendungen angewendet werden können, auch auf anderen Plattformen. <br><br>  Was wir als Ergebnis bekommen wollen: <br><br><ol><li>  Automatisierung von Regressionstests. </li><li>  Integration in das Testmanagementsystem. </li><li>  Möglichkeit des parametrisierten manuellen Starts von Autotests auf Cloud-Geräten. </li><li>  Die Möglichkeit, die Lösung in Zukunft wiederzuverwenden. </li></ol><br>  Als nächstes werde ich separat über die Implementierung jedes dieser Punkte mit einem kleinen Eintauchen in die technische Komponente sprechen. <br><br><h2>  Allgemeines Lösungsimplementierungsschema </h2><br>  Aber zuerst ein allgemeiner Überblick darüber, was wir bekommen haben: <br><br><img src="https://habrastorage.org/webt/k3/dc/yf/k3dcyf4d-az9yt4ce0dqgseko6m.png" alt="Bild"><br><br>  Automatische Tests werden auf zwei Arten ausgeführt: <br><br><ol><li>  Von CI nach dem Zusammenführen oder Ziehen der Anforderung an den Master. </li><li>  Testen Sie manuell über die Jenkins Job-Weboberfläche. </li></ol><br>  Bei einem manuellen Start muss der Tester entweder die Nummer des entsprechenden Builds angeben oder 2 APKs vom Computer herunterladen: mit der Anwendung und mit den Tests.  Diese Methode wird benötigt, damit Sie die erforderlichen Tests jederzeit auf allen verfügbaren Geräten ausführen können. <br><br>  Während der Tests werden ihre Ergebnisse an TestRail gesendet.  Dies geschieht auf die gleiche Weise, als ob der Tester den Test manuell durchgeführt und die Ergebnisse auf eine ihm vertraute Weise eingegeben hätte. <br><br>  Daher haben wir den etablierten Prozess des manuellen Testens verlassen, aber die Automatisierung hinzugefügt, die eine bestimmte Reihe von Tests durchführt.  Der Tester "nimmt" auf, was automatisch gemacht wurde, und: <br><br><ul><li>  sieht das Ergebnis von Testfällen auf jedem ausgewählten Gerät; </li><li>  kann jeden Testfall manuell überprüfen; </li><li>  führt Testfälle durch, die noch nicht automatisiert sind oder aus irgendeinem Grund nicht optimiert werden können; </li><li>  trifft die endgültige Entscheidung über den aktuellen Testlauf. </li></ul><br>  Fahren wir nun mit der versprochenen Beschreibung der Implementierung fort. <br><br><h2>  1. Automatische Tests </h2><br><h4>  Die Werkzeuge </h4><br>  Wir haben 3 Tools verwendet, um mit der Benutzeroberfläche zu interagieren: <br><br><ul><li>  Espresso </li><li>  Barista. </li><li>  UI Automator. </li></ul><br>  Das Hauptwerkzeug und das, mit dem wir begonnen haben, ist Espresso.  Das Hauptargument für seine Wahl war die Tatsache, dass Sie mit Espresso Tests mit der White-Box-Methode durchführen können, um Zugriff auf Android Instrumentation zu erhalten.  Der Testcode befindet sich im selben Projekt wie der Anwendungscode. <br><br>  Der Zugriff auf den Android-Anwendungscode ist erforderlich, um seine Methoden in Tests aufrufen zu können.  Wir können unsere Anwendung im Voraus auf einen bestimmten Test vorbereiten, indem wir sie im richtigen Zustand ausführen.  Andernfalls müssen wir diesen Zustand über die Schnittstelle erreichen, die Atomizitätstests entzieht, sie voneinander abhängig macht und einfach viel Zeit in Anspruch nimmt. <br><br>  Während der Implementierung wurde Espresso ein weiteres Tool hinzugefügt - UI Automator.  Beide Frameworks sind Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android Testing Support Library</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google</a> .  Mit dem UI Automator können wir mit verschiedenen Systemdialogen oder beispielsweise mit Notification Drawer interagieren. <br><br>  Und das letzte in unserem Arsenal war das Barista-Framework.  Es ist ein Wrapper um Espresso, der Ihnen den Boilerplate-Code erspart, wenn Sie allgemeine Benutzeraktionen implementieren. <br><br>  Unter Berücksichtigung des Wunsches, die Lösung in anderen Anwendungen wiederverwenden zu können, ist zu beachten, dass die aufgeführten Tools ausschließlich für Android-Anwendungen bestimmt sind.  Wenn Sie keinen Zugriff auf den Code der zu testenden Anwendung benötigen, bevorzugen Sie wahrscheinlich die Verwendung eines anderen Frameworks.  Zum Beispiel das heute sehr beliebte Appium.  Sie können aber auch versuchen, mit Hilfe von Backdoors zum Anwendungscode zu gelangen, was ein guter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> im Badoo-Blog ist.  Sie haben die Wahl. <br><br><h4>  Implementierung </h4><br>  Als Entwurfsmuster haben wir Testroboter ausgewählt, die Jake Wharton im gleichnamigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht vorgeschlagen hat</a> .  Die Idee dieses Ansatzes ähnelt dem allgemeinen Seitenobjekt-Entwurfsmuster, das beim Testen von Websystemen verwendet wird.  Die Programmiersprache ist Java. <br><br>  Für jedes unabhängige Fragment der Anwendung wird eine spezielle Roboterklasse erstellt, in der die Geschäftslogik implementiert ist.  Die Wechselwirkung mit jedem Element des Fragments wird in einem separaten Verfahren beschrieben.  Darüber hinaus werden hier auch alle in diesem Fragment durchgeführten Behauptungen beschrieben. <br><br>  Betrachten Sie ein einfaches Beispiel.  Das beschriebene Fragment enthält mehrere Felder zur Dateneingabe und eine Aktionsschaltfläche: <br><br><img src="https://habrastorage.org/webt/po/-a/il/po-ail1n2mqlusukvegg9ry1tdm.png" alt="Bild"><br><br>  Der Code des Anmeldefunktionstests selbst: <br><br><img src="https://habrastorage.org/webt/s2/ot/sd/s2otsd2q-li_26a9vkx_-s_9__g.png" alt="Bild"><br><br>  Hier überprüfen wir das positive Szenario, wenn die eingegebenen Authentifizierungsdaten korrekt sind.  Die Daten selbst werden den Eingabetests unterzogen oder die Standardwerte werden verwendet.  Somit hat der Tester die Möglichkeit, hinsichtlich der Testdaten zu parametrisieren. <br><br>  Diese Struktur bietet den Tests zunächst eine hervorragende Lesbarkeit, wenn das gesamte Skript in die Hauptschritte der Ausführung unterteilt ist.  Die Idee, Aussagen auf die einzelnen Methoden des entsprechenden Roboters zu übertragen, hat uns auch sehr gut gefallen.  Assert wird zum gleichen Schritt, ohne die allgemeine Kette zu durchbrechen, und Ihre Tests wissen immer noch nichts über die Anwendung. <br><br>  In dem oben genannten Bericht gibt Jake Wharton eine Implementierung in Kotlin, wo sie endlich ist.  Wir haben es bereits bei einem anderen Projekt versucht und es hat uns sehr gut gefallen. <br><br><h2>  2. Integration mit dem Testmanagementsystem </h2><br>  Vor der Einführung der Automatisierung haben wir alle unsere Tests im TestRail-Testmanagementsystem durchgeführt.  Die gute Nachricht war, dass es eine ziemlich gute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TestRail-API gibt</a> , mit der wir bereits im System etablierte Testfälle mit Autotests verbinden konnten. <br><br>  Während des Testlaufs mit JUnit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RunListener</a> werden verschiedene Ereignisse abgefangen, z. B. <code>testRunStarted</code> , <code>testFailure</code> , <code>testFinished</code> , in denen wir die Ergebnisse an TestRail senden.  Wenn Sie AndroidJUnitRunner verwenden, muss er auf bestimmte Weise über Ihren RunListener informieren, wie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation beschrieben.</a> <br><br>  Sie müssen auch mit verschiedenen TestRail-Entitäten über deren ID kommunizieren.  <code>@CaseId</code> den Test mit dem entsprechenden Testfall zu verbinden, haben wir eine einfache Annotation <code>@CaseId</code> , deren Verwendung im obigen Beispiel für die <code>@CaseId</code> gezeigt wird. <br><br>  Code zur Implementierung der Anmerkung selbst: <br><br><img src="https://habrastorage.org/webt/oq/pz/2m/oqpz2mc9f_lfnujvzaj2ohpuicc.png" alt="Bild"><br><br>  Es bleibt nur, um seinen Wert an der richtigen Stelle aus der Beschreibung zu erhalten: <br><br><img src="https://habrastorage.org/webt/4h/bb/wa/4hbbwa2srlfwol2yies25mm07a8.png" alt="Bild"><br><br><h2>  3. Manueller Start von Autotests auf Cloud-Geräten </h2><br><h4>  Startparametrierung in Jenkins Job </h4><br>  Um den manuellen Start von Autotests zu organisieren, verwenden wir den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Free-Style Jenkins Job</a> .  Diese Option wurde gewählt, weil das Unternehmen bereits Erfahrung mit ähnlichen Arbeiten mit Jenkins Job in anderen Bereichen hatte, insbesondere mit DevOps-Ingenieuren, die sie gerne teilten. <br><br>  Jenkins Job führt ein Skript aus, das auf Daten basiert, die von der Weboberfläche übertragen wurden.  Somit ist die Parametrisierung von Testläufen implementiert.  In unserem Fall initiiert das Bash-Skript den Start von Tests auf den Firebase-Cloud-Geräten. <br><br>  Die Parametrierung umfasst: <br><br><ul><li>  Auswahl der gewünschten APK durch Angabe der Nummer des entsprechenden Builds oder manuelles Herunterladen. </li><li>  Geben Sie alle Arten von Testdaten ein. </li><li>  Eingabe zusätzlicher benutzerdefinierter Daten für TestRail. </li><li>  Wählen Sie aus der im Firebase Test Lab verfügbaren Liste Cloud-basierte physische Geräte aus, auf denen Tests ausgeführt werden sollen. </li><li>  Die Auswahl der durchzuführenden Testkits. </li></ul><br>  Schauen wir uns einen Teil der Webseite unseres Jenkins-Jobs anhand eines Beispiels für eine Geräteauswahloberfläche und Testsuiten an: <br><br><img src="https://habrastorage.org/webt/lm/d9/_p/lmd9_pih-p4lu5i_7gd6d2rcazc.png" alt="Bild"><br><br>  Jedes Element, in das Sie Daten eingeben oder auswählen können, wird von speziellen Jenkins-Plugins implementiert.  Beispielsweise wird die Geräteauswahloberfläche über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Active Choices Plugin erstellt</a> .  Mit einem groovigen Skript von Firebase wird eine Liste der verfügbaren Geräte abgerufen, die dann in der gewünschten Form auf der Webseite angezeigt wird. <br><br>  Nachdem alle erforderlichen Daten eingegeben wurden, wird das entsprechende Skript gestartet, dessen Fortschritt wir im Abschnitt Konsolenausgabe beobachten können: <br><br><img src="https://habrastorage.org/webt/vo/ie/ul/voieulwwrlhexdhsxpw2wwg-qga.png" alt="Bild"><br><br>  Von hier aus kann der Tester, der den Testlauf initiiert hat, unter Verwendung der empfangenen URLs zu TestRail oder zur Firebase-Konsole wechseln, die viele nützliche Informationen zum Ausführen von Tests auf jedem der ausgewählten Geräte enthält. <br><br><h4>  Endgültige Testmatrix im Firebase-Testlabor </h4><br>  Die Gerätematrix in Firebase enthält die Verteilung der Tests nach den Geräten, auf denen sie ausgeführt wurden: <br><br><img src="https://habrastorage.org/webt/um/bs/5w/umbs5w2ehvo69ih127ep8i6ulvo.png" alt="Bild"><br><br>  Für jedes Gerät können Sie das vollständige Protokoll, das Video des Testlaufs und verschiedene Leistungsindikatoren anzeigen.  Darüber hinaus können Sie auf alle Dateien zugreifen, die möglicherweise während der Ausführung der Tests erstellt wurden.  Wir verwenden dies, um Testabdeckungsindikatoren vom Gerät herunterzuladen. <br><br>  Wir haben uns für Firebase entschieden, da wir diesen Service bereits zur Lösung anderer Probleme genutzt haben und mit der Preispolitik zufrieden sind.  Wenn Sie 30 Minuten reine Zeit zum Testen pro Tag haben, müssen Sie überhaupt nicht bezahlen.  Dies kann ein weiterer Grund sein, warum es wichtig ist, nur bestimmte Tests ausführen zu können. <br><br>  Möglicherweise bevorzugen Sie eine andere Cloud-Infrastruktur, die auch gut zu Ihrem Testprozess passt. <br><br><h2>  4. Wiederverwenden </h2><br>  Wie kann all dies in Zukunft genutzt werden?  Aus Sicht der Codebasis ist diese Lösung nur für Android-Anwendungen anwendbar.  Während der Implementierung haben wir beispielsweise die <code>UiAutomatorExtensions</code> <code>EspressoExtensions</code> und <code>UiAutomatorExtensions</code> , in denen wir verschiedene Optionen für die Interaktion mit der Schnittstelle kapseln und warten, bis die Elemente bereit sind.  Dies schließt auch die RunListener-Klasse ein, die für die Integration in TestRail verantwortlich ist.  Wir haben sie bereits in separaten Modulen platziert und verwenden sie zur Automatisierung anderer Anwendungen. <br><br>  Wenn wir über andere Plattformen sprechen, können die gesammelten Erfahrungen sehr nützlich sein, um ähnliche Prozesse aufzubauen und zu implementieren.  Wir tun dies aktiv im iOS-Bereich und denken über Windows nach. <br><br><h2>  Fazit </h2><br>  Es gibt viele Optionen für die Implementierung und Verwendung der Testautomatisierung.  Wir sind der Meinung, dass Automatisierung in erster Linie ein Werkzeug ist, das den traditionellen Prozess des "menschlichen" Testens erleichtern und nicht auslöschen soll. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434252/">https://habr.com/ru/post/de434252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434236/index.html">Das neuronale Netz mit einer Amöbe löste das Problem der Handlungsreisenden für 8 Städte</a></li>
<li><a href="../de434238/index.html">Intel OpenVINO auf Raspberry Pi: Ernte 2018</a></li>
<li><a href="../de434244/index.html">Ich bin Mamas Algo-Händler: Ich suche nach kostenlosen Frameworks zum Testen von Hypothesen und zum Starten im Kampfmodus (Python).</a></li>
<li><a href="../de434246/index.html">Apple bestätigt, dass einige iPad-Profis leicht gebogen sind, sagt aber, dass es in Ordnung ist</a></li>
<li><a href="../de434250/index.html">2019 Netzwerksicherheitstrends</a></li>
<li><a href="../de434254/index.html">Das Beste jagen</a></li>
<li><a href="../de434258/index.html">Winterpraktikum für mobile Entwickler bei Redmadrobot</a></li>
<li><a href="../de434260/index.html">Microsoft veranstaltet einen AI Agent-Wettbewerb für Minecraft</a></li>
<li><a href="../de434262/index.html">Schreiben und Kompilieren eines Albums für Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
<li><a href="../de434264/index.html">Intel ❄ 2018. Ergebnisse des Jahres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>