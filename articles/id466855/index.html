<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏼 🔊 🌿 Menciptakan Tower Defense in Unity: Skenario dan Waves of Enemies 🚡 💿 👐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Bagian pertama , kedua , ketiga dan keempat tutorial] 



- Mendukung musuh ukuran kecil, sedang dan besar. 
- Buat skenario game dengan berbagai ge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menciptakan Tower Defense in Unity: Skenario dan Waves of Enemies</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466855/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketiga</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keempat</a> tutorial] <br><br><ul><li>  Mendukung musuh ukuran kecil, sedang dan besar. </li><li>  Buat skenario game dengan berbagai gelombang musuh. </li><li>  Pemisahan konfigurasi aset dan status permainan. </li><li>  Mulai, jeda, menang, kalahkan, dan percepat permainan. </li><li>  Buat skenario berulang tanpa henti. </li></ul><br>  Ini adalah bagian kelima dari serangkaian tutorial tentang cara membuat gim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertahanan menara</a> sederhana.  Di dalamnya, kita akan belajar cara membuat skenario gameplay yang menghasilkan gelombang berbagai musuh. <br><br>  Tutorial ini dibuat di Unity 2018.4.6f1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/6aa/945/b126aa94582cc44651853c3ee69be82b.jpg" width="512" height="256"></div><br>  <i>Sudah cukup nyaman.</i> <br><a name="habracut"></a><br><h2>  Lebih banyak musuh </h2><br>  Tidak terlalu menarik untuk membuat kubus biru yang sama setiap saat.  Langkah pertama untuk mendukung skenario gameplay yang lebih menarik adalah mendukung beberapa jenis musuh. <br><br><h3>  Konfigurasi musuh </h3><br>  Ada banyak cara untuk membuat musuh unik, tetapi kami tidak akan mempersulitnya: kami mengklasifikasikan mereka sebagai kecil, sedang dan besar.  Untuk menandai mereka, buat enumerasi <code>EnemyType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnemyType { Small, Medium, Large }</code> </pre> <br>  Ubah <code>EnemyFactory</code> sehingga mendukung ketiga jenis musuh, bukan satu.  Untuk ketiga musuh, bidang konfigurasi yang sama diperlukan, jadi kami menambahkan kelas <code>EnemyConfig</code> bersarang yang berisi semuanya, dan kemudian menambahkan tiga bidang konfigurasi jenis ini ke pabrik.  Karena kelas ini hanya digunakan untuk konfigurasi dan kami tidak akan menggunakannya di tempat lain, Anda dapat dengan mudah mempublikasikan bidangnya sehingga pabrik dapat mengaksesnya.  <code>EnemyConfig</code> sendiri tidak harus bersifat publik. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">5f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); } [SerializeField] EnemyConfig small = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, medium = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, large = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … }</code> </pre> <br>  Mari kita juga membuat kesehatan dapat disesuaikan untuk setiap musuh, karena itu logis bahwa musuh besar memiliki lebih dari yang kecil. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">FloatRangeSlider(10f, 1000f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange health = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre> <br>  Tambahkan parameter tipe untuk <code>Get</code> sehingga Anda bisa mendapatkan tipe musuh tertentu, dan tipe standarnya adalah sedang.  Kami akan menggunakan tipe untuk mendapatkan konfigurasi yang benar, yang mana metode terpisah berguna, dan kemudian membuat dan menginisialisasi musuh seperti sebelumnya, hanya dengan argumen kesehatan yang ditambahkan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">EnemyConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConfig</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Small: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> small; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Medium: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> medium; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Large: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> large; } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported enemy type!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type = EnemyType.Medium</span></span></span><span class="hljs-function">)</span></span> { EnemyConfig config = GetConfig(type); Enemy instance = CreateGameObjectInstance(config.prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( config.scale.RandomValueInRange, config.speed.RandomValueInRange, config.pathOffset.RandomValueInRange, config.health.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br>  Tambahkan parameter kesehatan yang diperlukan untuk <code>Enemy.Initialize</code> dan gunakan untuk mengatur kesehatan alih-alih menentukan ukuran musuh. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health </span></span></span><span class="hljs-function">)</span></span> { … Health = health; }</code> </pre> <br><h3>  Kami menciptakan desain musuh yang berbeda </h3><br>  Anda dapat memilih apa desain dari ketiga musuh itu, tetapi dalam tutorial saya akan berusaha untuk kesederhanaan maksimum.  Saya menggandakan cetakan asli musuh dan menggunakannya untuk ketiga ukuran, hanya mengubah bahan: kuning untuk kecil, biru untuk sedang dan merah untuk besar.  Saya tidak mengubah skala pabrikan kubus, tetapi menggunakan konfigurasi skala pabrik untuk mengatur dimensi.  Juga, tergantung pada ukurannya, saya meningkatkan kesehatan mereka dan mengurangi kecepatan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/070/231/bd707023151022e921c5b6956bb20c02.png" width="320" height="348"></div><br>  <i>Pabrik untuk kubus musuh dengan tiga ukuran.</i> <br><br>  Cara tercepat adalah membuat ketiga jenis muncul dalam permainan dengan mengubah <code>Game.SpawnEnemy</code> sehingga ia mendapatkan tipe musuh acak daripada yang tengah. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get((EnemyType)(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); enemy.SpawnOn(spawnPoint); enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/73b/b92/53773bb9299a8ec9c56b485718049e5b.png" width="230" height="230"></div><br>  <i>Musuh dari berbagai jenis.</i> <br><br><h3>  Beberapa pabrik </h3><br>  Sekarang pabrik musuh menetapkan banyak tiga musuh.  Pabrik yang ada menciptakan kubus dengan tiga ukuran, tetapi tidak ada yang mencegah kami membuat pabrik lain yang menciptakan sesuatu yang lain, misalnya, bola dengan tiga ukuran.  Kami dapat mengubah musuh yang dibuat dengan menunjuk pabrik lain di game, sehingga beralih ke topik yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65f/7e5/330/65f7e5330945ea654f1caef579fe567f.png" width="230" height="230"></div><br>  <i>Musuh bulat.</i> <br><br><h2>  Gelombang musuh </h2><br>  Langkah kedua dalam membuat skenario gameplay akan menjadi penolakan pemijahan musuh dengan frekuensi konstan.  Musuh harus dibuat dalam gelombang yang berurutan sampai skrip berakhir atau pemain kalah. <br><br><h3>  Urutan penciptaan </h3><br>  Satu gelombang musuh terdiri dari sekelompok musuh yang dibuat satu demi satu hingga gelombang selesai.  Gelombang dapat berisi berbagai jenis musuh, dan keterlambatan antara kreasi mereka dapat bervariasi.  Agar tidak menyulitkan implementasi, kita akan mulai dengan urutan pemijahan sederhana yang menciptakan tipe musuh yang sama dengan frekuensi konstan.  Maka gelombang akan menjadi daftar sekuens semacam itu. <br><br>  Untuk mengkonfigurasi setiap urutan, buat kelas <code>EnemySpawnSequence</code> .  Karena cukup rumit, letakkan di file terpisah.  Urutan harus tahu pabrik mana yang digunakan, jenis musuh apa yang harus dibuat, jumlah dan frekuensinya.  Untuk menyederhanakan konfigurasi, kita akan membuat parameter terakhir menjadi jeda, yang menentukan berapa banyak waktu yang harus dilewati sebelum membuat musuh berikutnya.  Perhatikan bahwa pendekatan ini memungkinkan Anda untuk menggunakan beberapa pabrik musuh dalam gelombang. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { [SerializeField] EnemyFactory factory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] EnemyType type = EnemyType.Medium; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown = <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><h3>  Ombaknya </h3><br>  Gelombang adalah array sederhana dari urutan penciptaan musuh.  Buat jenis <code>EnemyWave</code> EnemyWave untuk itu yang dimulai dengan satu urutan standar. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; }</code> </pre> <br>  Sekarang kita bisa membuat gelombang musuh.  Sebagai contoh, saya membuat gelombang yang menghasilkan sekelompok musuh kubik, mulai dengan sepuluh yang kecil, dengan frekuensi dua per detik.  Mereka diikuti oleh lima rata-rata, dibuat sekali per detik, dan, akhirnya, satu musuh besar dengan jeda lima detik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/af3/47f/b16af347f057760db35703515642db89.png" width="320" height="376"></div><br>  <i>Gelombang kubus yang meningkat.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Bisakah saya menambahkan jeda antar urutan?</b> <div class="spoiler_text">  Anda dapat menerapkannya secara tidak langsung.  Misalnya, masukkan jeda empat detik antara kubus kecil dan menengah, kurangi jumlah kubus kecil menjadi satu, dan masukkan urutan satu kubus kecil dengan jeda empat detik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59b/ff4/3f9/59bff43f9a71002c0bd562f270b755ea.png" width="320" height="272"></div><br>  <i>Delay empat detik antara kubus kecil dan menengah.</i> </div></div><br><h3>  Skenario </h3><br>  Skenario gameplay dibuat dari urutan gelombang.  Untuk ini, buat <code>GameScenario</code> aset <code>GameScenario</code> dengan satu larik gelombang, lalu gunakan untuk membuat skenario. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; }</code> </pre> <br>  Sebagai contoh, saya membuat skenario dengan dua gelombang musuh kecil-menengah-besar (MSC), pertama dengan kubus, kemudian dengan bola. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/df0/73b/796df073b24d092d35093b6e56b8be79.png" width="320" height="142"></div><br>  <i>Skenario dengan dua gelombang MSC.</i> <br><br><h3>  Gerakan urutan </h3><br>  Jenis aset digunakan untuk membuat skrip, tetapi karena ini adalah aset, mereka harus berisi data yang tidak berubah selama permainan.  Namun, untuk memajukan skenario, kita perlu melacak status mereka.  Salah satu caranya adalah menduplikasi aset yang digunakan dalam gim sehingga duplikat melacak kondisinya.  Tetapi kita tidak perlu menduplikasi seluruh aset, cukup nyatakan saja dan tautan ke aset itu sudah cukup.  Jadi mari kita buat kelas <code>State</code> terpisah, pertama untuk <code>EnemySpawnSequence</code> .  Karena ini hanya berlaku untuk urutan, kami membuatnya bersarang.  Ini valid hanya jika memiliki referensi ke urutan, jadi kami akan memberikannya metode konstruktor dengan parameter urutan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18c/752/4fd/18c7524fdac87c062a6c683bbdee1866.png" width="315" height="50"></div><br>  <i>Tipe status bertingkat yang mengacu pada urutannya.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { EnemySpawnSequence sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; } } }</code> </pre> <br>  Ketika kita ingin mulai bergerak maju secara berurutan, kita memerlukan instance baru untuk ini.  Tambahkan urutan ke metode <code>Begin</code> , yang membangun dan mengembalikan negara.  Berkat ini, semua orang yang memanggil <code>Begin</code> akan bertanggung jawab untuk mencocokkan keadaan, dan urutan itu sendiri akan tetap tanpa kewarganegaraan.  Bahkan mungkin untuk maju secara paralel beberapa kali dalam urutan yang sama. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { … } }</code> </pre> <br>  Agar negara dapat bertahan setelah reboot panas, Anda harus membuatnya serializable. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { … }</code> </pre> <br>  Kelemahan dari pendekatan ini adalah bahwa setiap kali kita menjalankan urutan, kita perlu membuat objek keadaan baru.  Kita dapat menghindari alokasi memori dengan menjadikannya struktur alih-alih kelas.  Ini normal asalkan kondisinya tetap kecil.  Perlu diingat bahwa status adalah tipe nilai.  Ketika ditransfer, itu disalin, jadi lacak di satu tempat. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { … }</code> </pre> <br>  Keadaan urutan hanya terdiri dari dua aspek: jumlah musuh yang dihasilkan dan kemajuan waktu jeda.  Kami menambahkan metode <code>Progress</code> , yang meningkatkan nilai jeda per delta waktu, dan kemudian menyetel ulang ketika nilai yang dikonfigurasi tercapai, mirip dengan apa yang terjadi dengan waktu pembuatan di <code>Game.Update</code> .  Kami akan menambah jumlah musuh setiap kali ini terjadi.  Selain itu, nilai jeda harus dimulai dengan nilai maksimum sehingga urutan menciptakan musuh tanpa jeda di awal. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; count = <span class="hljs-number"><span class="hljs-number">0</span></span>; cooldown = sequence.cooldown; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cooldown += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/aba/5e5/50caba5e50d89e05a6cb9a631feb1c6d.png" width="315" height="74"></div><br>  <i>Negara hanya berisi data yang diperlukan.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Bisakah saya mengakses EnemySpawnSequence.cooldown dari State?</b> <div class="spoiler_text">  Ya, karena <code>State</code> diatur dalam cakupan yang sama.  Oleh karena itu, tipe bersarang tahu tentang anggota pribadi dari tipe yang mengandungnya. </div></div><br>  Kemajuan harus berlanjut sampai jumlah musuh yang diinginkan dibuat dan jeda berakhir.  Pada titik ini, <code>Progress</code> harus melaporkan penyelesaian, tetapi kemungkinan besar kita akan sedikit melompati nilainya.  Oleh karena itu, pada saat ini kita harus mengembalikan waktu ekstra untuk menggunakannya dalam kemajuan dalam urutan berikut.  Agar ini berfungsi, Anda perlu mengubah delta waktu menjadi parameter.  Kita juga perlu menunjukkan bahwa kita belum selesai, dan ini dapat diwujudkan dengan mengembalikan nilai negatif. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt;= sequence.amount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cooldown; } count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Buat musuh di mana saja </h3><br>  Agar urutan untuk menelurkan musuh, kita perlu mengkonversi <code>Game.SpawnEnemy</code> ke metode statis publik lainnya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyFactory factory, EnemyType type</span></span></span><span class="hljs-function">)</span></span> { GameTile spawnPoint = instance.board.GetSpawnPoint( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, instance.board.SpawnPointCount) ); Enemy enemy = factory.Get(type); enemy.SpawnOn(spawnPoint); instance.enemies.Add(enemy); }</code> </pre> <br>  Karena <code>Game</code> itu sendiri tidak akan lagi menghasilkan musuh, kita dapat menghapus pabrik musuh, kecepatan pembuatan, proses promosi pembuatan dan kode pembuatan musuh dari <code>Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Kami akan memanggil <code>Game.SpawnEnemy</code> di <code>EnemySpawnSequence.State.Progress</code> setelah meningkatkan jumlah musuh. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { … count += <span class="hljs-number"><span class="hljs-number">1</span></span>; Game.SpawnEnemy(sequence.factory, sequence.type); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Kemajuan gelombang </h3><br>  Mari kita mengambil pendekatan yang sama untuk bergerak sepanjang urutan seperti ketika bergerak sepanjang gelombang.  Mari kita berikan <code>EnemyWave</code> metode <code>Begin</code> sendiri, yang mengembalikan contoh baru dari struktur <code>State</code> bersarang.  Dalam kasus ini, negara berisi indeks gelombang dan keadaan urutan aktif, yang kami inisialisasi dengan awal urutan pertama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/9f8/bc7/9eb9f8bc7769dd0c65624802ac2a97b8.png" width="315" height="128"></div><br>  <i>Keadaan gelombang yang berisi kondisi urutan.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { EnemyWave wave; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemySpawnSequence.State sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyWave wave</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wave = wave; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(wave.spawnSequences.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty wave!"</span></span>); sequence = wave.spawnSequences[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Kami juga menambahkan metode <code>Progress</code> metode <code>EnemyWave.State</code> , yang menggunakan pendekatan yang sama seperti sebelumnya, dengan perubahan kecil.  Kami mulai dengan bergerak di sepanjang urutan aktif dan mengganti delta waktu dengan hasil panggilan ini.  Sementara ada waktu yang tersisa, kami pindah ke urutan berikutnya, jika diakses, dan melakukan kemajuan di atasnya.  Jika tidak ada urutan yang tersisa, maka kami mengembalikan sisa waktu;  jika tidak kembalikan nilai negatif. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { deltaTime = sequence.Progress(deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= wave.spawnSequences.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deltaTime; } sequence = wave.spawnSequences[index].Begin(); deltaTime = sequence.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Promosi skrip </h3><br>  Tambahkan <code>GameScenario</code> proses yang sama.  Dalam hal ini, negara berisi indeks gelombang dan keadaan gelombang aktif. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { GameScenario scenario; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(scenario.waves.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty scenario!"</span></span>); wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Karena kita berada di tingkat atas, metode <code>Progress</code> tidak memerlukan parameter dan Anda dapat menggunakan <code>Time.deltaTime</code> secara langsung.  Kami tidak perlu mengembalikan waktu yang tersisa, tetapi kami perlu menunjukkan apakah skrip selesai.  Kami akan mengembalikan <code>false</code> setelah akhir dari gelombang terakhir dan <code>true</code> untuk menunjukkan bahwa skrip masih aktif. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Jalankan skrip </h3><br>  Untuk memainkan skrip <code>Game</code> , Anda memerlukan bidang konfigurasi skrip dan pelacakan statusnya.  Kami hanya akan menjalankan skrip di Sedar dan menjalankan <code>Update</code> di atasnya sampai status dari sisa permainan diperbarui. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameScenario scenario = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; GameScenario.State activeScenario; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; activeScenario = scenario.Begin(); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … activeScenario.Progress(); enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); nonEnemies.GameUpdate(); }</code> </pre> <br>  Sekarang skrip yang dikonfigurasi akan diluncurkan pada awal permainan.  Promosi di atasnya akan dilakukan sampai selesai, dan setelah itu tidak ada yang terjadi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/x0/uf/mkx0ufxshpgvy29wjr_nxdmneu4.gif"></div><br>  <i>Dua gelombang dipercepat 10 kali.</i> <br><br><h2>  Mulai dan akhiri permainan </h2><br>  Kami dapat mereproduksi satu skenario, tetapi setelah selesai, musuh baru tidak akan muncul.  Agar permainan dapat terus berlanjut, kami harus memungkinkan untuk memulai skenario baru, baik secara manual, atau karena pemain kalah / menang.  Anda juga dapat menerapkan pilihan beberapa skenario, tetapi dalam tutorial ini kami tidak akan mempertimbangkannya. <br><br><h3>  Awal dari sebuah game baru </h3><br>  Idealnya, kita membutuhkan kesempatan untuk memulai permainan baru pada waktu tertentu.  Untuk melakukan ini, Anda perlu mengatur ulang keadaan saat ini dari seluruh permainan, yaitu, kita harus mengatur ulang banyak objek.  Pertama, tambahkan metode <code>Clear</code> ke <code>GameBehaviorCollection</code> yang memanfaatkan semua perilakunya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; behaviors.Count; i++) { behaviors[i].Recycle(); } behaviors.Clear(); }</code> </pre> <br>  Ini menunjukkan bahwa semua perilaku dapat dihilangkan, tetapi sejauh ini tidak demikian.  Untuk membuatnya berfungsi, tambahkan metode <code>Recycle</code> abstrak ke <code>GameBehavior</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  Metode <code>Recycle</code> kelas <code>WarEntity</code> harus secara eksplisit <code>WarEntity</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>Enemy</code> belum memiliki metode <code>Recycle</code> , jadi tambahkan saja.  Yang harus dia lakukan adalah memaksa pabrik untuk mengembalikannya.  Lalu kami memanggil <code>Recycle</code> mana pun kami langsung mengakses pabrik. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>GameBoard</code> juga perlu disetel ulang, jadi mari kita berikan metode <code>Clear</code> , yang mengosongkan semua ubin, mengatur ulang semua titik pembuatan dan memperbarui konten, dan kemudian menetapkan titik awal dan akhir standar.  Kemudian, alih-alih mengulangi kode, kita dapat memanggil <code>Clear</code> di akhir <code>Initialize</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … } } Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } spawnPoints.Clear(); updatingContent.Clear(); ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Sekarang kita bisa menambahkan metode <code>BeginNewGame</code> ke <code>Game</code> , membuang musuh, objek lain dan bidang, dan kemudian memulai skrip baru. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enemies.Clear(); nonEnemies.Clear(); board.Clear(); activeScenario = scenario.Begin(); }</code> </pre> <br>  Kami akan memanggil metode ini dalam <code>Update</code> jika Anda menekan B sebelum beralih ke skrip. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } activeScenario.Progress(); … }</code> </pre> <br><h3>  Kehilangan </h3><br>  Tujuan permainan ini adalah untuk mengalahkan semua musuh sebelum sejumlah dari mereka mencapai titik akhir.  Jumlah musuh yang diperlukan untuk memicu kondisi kekalahan tergantung pada kesehatan awal pemain, untuk itu kami akan menambahkan bidang konfigurasi ke <code>Game</code> .  Karena kita menghitung musuh, kita akan menggunakan integer, bukan float. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startingPlayerHealth = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/9c5/11a/4f39c511ab9d362b1cc7e55610a317aa.png" width="320" height="38"></div><br>  <i>Awalnya, seorang pemain memiliki 10 kesehatan.</i> <br><br>  Dalam kasus Sedar atau dimulainya permainan baru, kami menetapkan nilai awal untuk kesehatan pemain saat ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHealth; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; … }</code> </pre> <br>  Tambahkan metode <code>EnemyReachedDestination</code> statis publik <code>EnemyReachedDestination</code> musuh dapat memberi tahu <code>Game</code> bahwa mereka telah mencapai titik akhir.  Ketika ini terjadi, kurangi kesehatan pemain. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyReachedDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.playerHealth -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Panggil metode ini di <code>Enemy.GameUpdate</code> pada waktu yang tepat. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Game.EnemyReachedDestination(); Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Sekarang kita dapat memeriksa kondisi kekalahan di <code>Game.Update</code> .  Jika kesehatan pemain sama dengan atau kurang dari nol, kondisi kekalahan dipicu.  Kami cukup mencatat informasi ini dan segera memulai permainan baru sebelum bergerak maju.  Tetapi kami akan melakukan ini hanya dengan kesehatan awal yang positif.  Ini memungkinkan kami untuk menggunakan 0 sebagai kesehatan awal, sehingga tidak mungkin hilang.  Jadi akan nyaman bagi kita untuk menguji skrip. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startingPlayerHealth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } activeScenario.Progress();</code> </pre> <br><h3>  Kemenangan </h3><br>  Alternatif untuk mengalahkan adalah kemenangan, yang dicapai pada akhir skenario, jika pemain masih hidup.  Yaitu, ketika hasil <code>GameScenario.Progess</code> <code>false</code> , kami menampilkan pesan kemenangan di log, memulai permainan baru, dan segera melanjutkannya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Namun, kemenangan akan datang setelah akhir jeda terakhir, bahkan jika masih ada musuh di lapangan.  Kita perlu menunda kemenangan sampai semua musuh menghilang, yang dapat diwujudkan dengan memeriksa apakah kumpulan musuh kosong.  Kami berasumsi bahwa ia memiliki properti <code>IsEmpty</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress() &amp;&amp; enemies.IsEmpty) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Tambahkan properti yang diinginkan ke <code>GameBehaviorCollection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; behaviors.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h3>  Kontrol waktu </h3><br>  Mari kita juga mengimplementasikan fitur manajemen waktu, ini akan membantu dalam pengujian dan seringkali merupakan fungsi gameplay.  Untuk memulai, biarkan <code>Game.Update</code> memeriksa <code>Game.Update</code> spasi, dan gunakan acara ini untuk mengaktifkan / menonaktifkan jeda dalam game.  Ini dapat dilakukan dengan beralih nilai <code>Time.timeScale</code> antara nol dan satu.  Ini tidak akan mengubah logika permainan, tetapi akan membuat semua objek membeku di tempatnya.  Atau Anda dapat menggunakan nilai yang sangat kecil alih-alih 0, misalnya 0,01, untuk membuat gerakan yang sangat lambat. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pausedTimeScale = <span class="hljs-number"><span class="hljs-number">0f</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, kami akan menambahkan </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecepatan game </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">slider sehingga Anda dapat mempercepat waktu.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 10f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> playSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/641/4e9/b5d6414e9cd53d7ac89c5c1b3699b806.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kecepatan game. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika jeda tidak diaktifkan dan nilai jeda tidak ditetapkan untuk skala waktu, kami membuatnya sama dengan kecepatan permainan. </font><font style="vertical-align: inherit;">Juga, saat menghapus jeda, kami menggunakan kecepatan gim alih-alih persatuan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : playSpeed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.timeScale &gt; pausedTimeScale) { Time.timeScale = playSpeed; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Skenario loop </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam beberapa skenario, mungkin perlu melewati semua gelombang beberapa kali. </font><font style="vertical-align: inherit;">Dimungkinkan untuk mengimplementasikan dukungan untuk fungsi seperti itu dengan memungkinkan untuk mengulang skenario dengan mengulang semua gelombang beberapa kali. </font><font style="vertical-align: inherit;">Anda dapat lebih meningkatkan fungsi ini, misalnya, dengan mengaktifkan pengulangan hanya gelombang terakhir, tetapi dalam tutorial ini kami hanya akan mengulangi keseluruhan skrip.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemajuan siklus pada gelombang </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penggeser konfigurasi untuk mengatur jumlah siklus, secara default, berikan nilai 1. Minimal, buat nol, dan skrip akan diulang tanpa henti. </font><font style="vertical-align: inherit;">Jadi kita akan membuat skenario bertahan hidup yang tidak bisa dikalahkan, dan intinya adalah untuk memeriksa seberapa banyak pemain bisa bertahan.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/5d0/9df/d0c5d09dfd50e0e088c1848aaa32d531.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario dua siklus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus melacak nomor siklus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle, index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di </font></font><code>Progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami akan mengeksekusi setelah selesainya penambahan siklus, dan kembali </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya jika jumlah siklus yang cukup telah berlalu. </font><font style="vertical-align: inherit;">Jika tidak, kami mereset indeks gelombang ke nol dan terus bergerak.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akselerasi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pemain berhasil mengalahkan siklus sekali, maka ia akan dapat mengalahkannya lagi tanpa masalah. Untuk menjaga skenario tetap kompleks, kita perlu meningkatkan kompleksitas. Cara termudah untuk melakukan ini, mengurangi siklus berikutnya semua jeda antara penciptaan musuh. Maka musuh akan muncul lebih cepat dan pasti akan mengalahkan pemain dalam skenario bertahan hidup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bilah konfigurasi untuk mengontrol akselerasi per siklus. Nilai ini ditambahkan ke skala waktu setelah setiap siklus hanya untuk mengurangi jeda. Misalnya, dengan akselerasi 0,5, siklus pertama memiliki kecepatan jeda × 1, siklus kedua memiliki kecepatan × 1,5, yang ketiga × 2, yang keempat × 2,5, dan seterusnya.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cycleSpeedUp = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda perlu menambahkan skala waktu dan </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Awalnya selalu sama dengan 1 dan meningkat dengan nilai percepatan setelah setiap siklus. </font><font style="vertical-align: inherit;">Gunakan untuk mengukur </font></font><code>Time.deltaTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum bergerak di sepanjang gelombang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeScale; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale = <span class="hljs-number"><span class="hljs-number">1f</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(timeScale * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale += scenario.cycleSpeedUp; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/-d/3s/qv-d3srpikyuiorxx9vjk06wir8.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga siklus dengan peningkatan kecepatan penciptaan musuh; </font><font style="vertical-align: inherit;">dipercepat sepuluh kali. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Anda ingin menerima informasi tentang rilis tutorial baru? </font><font style="vertical-align: inherit;">Ikuti halaman saya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Artikel PDF </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466855/">https://habr.com/ru/post/id466855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466839/index.html">Kisah penciptaan Norton Commander. Bagian 1/3</a></li>
<li><a href="../id466841/index.html">Mengapa bantal pemanas, jika ada laptop: studi tentang resistensi termal di tingkat atom</a></li>
<li><a href="../id466845/index.html">Wawancara terbalik: pertanyaan apa yang harus ditanyakan perusahaan?</a></li>
<li><a href="../id466849/index.html">noexcept-ctcheck atau beberapa macro sederhana untuk membantu kompiler menulis kode noexcept</a></li>
<li><a href="../id466851/index.html">Agilex line - 10nm Intel FPGA</a></li>
<li><a href="../id466857/index.html">Eksekusi aplikasi latar belakang di iOS 13</a></li>
<li><a href="../id466859/index.html">Menggunakan Layanan Federasi AD untuk Memberi Otorisasi Pengguna AWS dengan Distribusi Hak</a></li>
<li><a href="../id466861/index.html">Cara melarikan diri dari kenyataan menggunakan hackathon</a></li>
<li><a href="../id466863/index.html">Menyiapkan Asymptote</a></li>
<li><a href="../id466865/index.html">Menunggu tanggal 1 November: larangan atau legalisasi cryptocurrency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>