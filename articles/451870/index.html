<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüîß üëû üö≥ Funciones modernas de C ++ que todos los programadores deben conocer üê™ üë∞üèª ‚úã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del material, cuya traducci√≥n publicamos hoy, dice que C ++, en su forma moderna, en comparaci√≥n con lo que era este lenguaje hace varios a√±o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funciones modernas de C ++ que todos los programadores deben conocer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  El autor del material, cuya traducci√≥n publicamos hoy, dice que C ++, en su forma moderna, en comparaci√≥n con lo que era este lenguaje hace varios a√±os, ha cambiado significativamente para mejor.  Por supuesto, estos cambios no ocurrieron de inmediato.  Por ejemplo, en los viejos tiempos, C ++ carec√≠a de dinamismo.  No fue f√°cil encontrar una persona que pudiera decir que tiene sentimientos tiernos por este idioma.  Todo cambi√≥ cuando los responsables de estandarizar el lenguaje decidieron dar paso a las innovaciones.  En 2011, C ++ se convirti√≥ en un lenguaje din√°mico, un lenguaje que evoluciona constantemente y causa a los programadores emociones mucho m√°s positivas. <br><br>  No pienses que el idioma se ha vuelto m√°s f√°cil.  Todav√≠a puede llamarse uno de los lenguajes de programaci√≥n m√°s complejos y ampliamente utilizados, si no el m√°s complejo.  Pero el C ++ moderno se ha vuelto mucho m√°s amigable que antes. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Hoy hablaremos sobre algunas de las nuevas caracter√≠sticas del lenguaje (comenzando con C ++ 11, que, por cierto, ya tiene 8 a√±os), que cualquier programador sabr√°. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Palabra clave autom√°tica</font> </h2><br>  Desde que la palabra clave <code>auto</code> apareci√≥ en C ++ 11, la vida de los programadores se ha vuelto m√°s f√°cil.  Gracias a esta palabra clave, el compilador puede generar tipos de variables en tiempo de compilaci√≥n, lo que nos evita tener que especificar siempre los tipos nosotros mismos.  Esto result√≥ ser muy conveniente, por ejemplo, en casos en los que tiene que trabajar con tipos de datos como <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Al usar la palabra clave <code>auto</code> , hay algunas cosas a tener en cuenta.  Considere un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Preste atenci√≥n a la √∫ltima l√≠nea en este ejemplo, cuyo comentario est√° marcado como <code>#1</code> (en adelante, de manera similar marcaremos las l√≠neas que analizaremos despu√©s de los ejemplos).  No hay inicializador en esta l√≠nea, no puede hacer esto.  El c√≥digo ubicado en esta l√≠nea evita que el compilador sepa cu√°l deber√≠a ser el tipo de la variable correspondiente. <br><br>  Inicialmente, la palabra clave <code>auto</code> en C ++ era bastante limitada.  Luego, en las versiones m√°s recientes del idioma, se agregaron funciones <code>auto</code> .  Aqu√≠ hay otro ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  Las l√≠neas n. <code>#1</code> y n <code>#2</code> aplican la inicializaci√≥n variable mediante llaves (otra caracter√≠stica nueva en C ++ 11). <br><br>  Recuerde que cuando usa la palabra clave <code>auto</code> , el compilador debe tener alguna forma de inferir el tipo de la variable. <br><br>  Ahora, una pregunta interesante.  ¬øQu√© sucede si usa un dise√±o como <code>auto a = {1, 2, 3}</code> ?  Que es esto  ¬øVector o causa de error de compilaci√≥n? <br><br>  De hecho, una construcci√≥n de la forma <code>std::initializer_list&lt;type&gt;</code> apareci√≥ en C ++ 11.  La lista de valores de inicializaci√≥n entre par√©ntesis se tratar√° como un contenedor con la palabra clave <code>auto</code> . <br><br>  Y finalmente, como ya se mencion√≥, la inferencia de tipos por parte del compilador puede ser extremadamente √∫til si tiene que trabajar con estructuras de datos complejas.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Echa un vistazo a la l√≠nea <code>#1</code> .  La expresi√≥n <code>auto [v1,v2] = itr.second</code> representa una nueva caracter√≠stica de C ++ 17. Esta es la llamada descomposici√≥n al declarar variables.  En versiones anteriores del lenguaje, cada valor ten√≠a que extraerse individualmente.  Gracias a este mecanismo, realizar tales operaciones se ha vuelto mucho m√°s conveniente. <br><br>  Adem√°s, si necesita trabajar con datos usando enlaces, es suficiente agregar solo un car√°cter a esta construcci√≥n, convirti√©ndolo a la siguiente forma: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Expresiones lambda</font> </h2><br>  C ++ 11 introduce soporte para expresiones lambda.  Se asemejan a funciones an√≥nimas en JavaScript, se pueden comparar con objetos funcionales sin nombres.  Capturan variables en varios √°mbitos seg√∫n su descripci√≥n, para lo cual se utilizan construcciones sint√°cticas compactas.  Adem√°s, se pueden asignar a variables. <br><br>  Las expresiones lambda son una herramienta muy √∫til para aquellos casos en los que necesita realizar una peque√±a operaci√≥n en el c√≥digo, pero no desea escribir una funci√≥n separada para esto.  Otro ejemplo com√∫n de su uso es la creaci√≥n de funciones utilizadas en la comparaci√≥n de valores.  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  Puedes encontrar muchas cosas interesantes en este breve ejemplo. <br><br>  Primero, preste atenci√≥n a lo conveniente que es usar la inicializaci√≥n variable usando llaves.  A continuaci√≥n, podemos ver las construcciones est√°ndar <code>begin()</code> y <code>end()</code> , que tambi√©n aparecieron en C ++ 11. Luego viene la funci√≥n lambda, que se utiliza como mecanismo para comparar datos.  Los par√°metros de esta funci√≥n se declaran usando la palabra clave <code>auto</code> , esta caracter√≠stica apareci√≥ en C ++ 14. Anteriormente, esta palabra clave no se pod√≠a usar para describir los par√°metros de las funciones. <br><br>  Ahora observe que la expresi√≥n lambda comienza con corchetes - <code>[]</code> .  Esta es la llamada m√°scara de variables.  Determina el alcance de la expresi√≥n, es decir, le permite controlar la relaci√≥n de la expresi√≥n lambda con variables y objetos locales. <br><br>  Aqu√≠ hay un extracto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> repositorio dedicado a las caracter√≠sticas modernas de C ++: <br><br><ul><li>  <code>[]</code> - la expresi√≥n no captura nada.  Esto significa que en una expresi√≥n lambda es imposible usar variables locales del √°mbito externo.  Solo se pueden usar par√°metros en la expresi√≥n. </li><li>  <code>[=]</code> - la expresi√≥n captura los valores de los objetos locales (es decir, variables locales, par√°metros).  Esto significa que se pueden usar, pero no modificar. </li><li>  <code>[&amp;]</code> - la expresi√≥n captura referencias a objetos locales.  Se pueden modificar, como se muestra en el siguiente ejemplo. </li><li>  <code>[this]</code> : la expresi√≥n captura el valor del puntero <code>this</code> . </li><li>  <code>[a, &amp;b]</code> : la expresi√≥n captura el valor del objeto <code>b</code> una referencia al objeto <code>b</code> . </li></ul><br>  Como resultado, si dentro de la funci√≥n lambda necesita convertir los datos a otro formato, puede usar los mecanismos anteriores.  Considere un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Aqu√≠, si el valor accediera a la variable del <code>[factor]</code> (entonces la m√°scara variable <code>[factor]</code> se usar√≠a para describir la expresi√≥n lambda), entonces en la l√≠nea <code>#1</code> el valor del <code>factor</code> no podr√≠a cambiarse, simplemente porque no tendr√≠amos derechos para realizando tal operaci√≥n.  En este ejemplo, tenemos derecho a tales acciones.  En tales situaciones, es importante no abusar de las capacidades que las variables de acceso proporcionan por referencia. <br><br>  Adem√°s, tenga en cuenta que <code>val</code> tambi√©n se accede por referencia.  Esto asegura que los cambios de datos que ocurren en la funci√≥n lambda afectan al <code>vector</code> . <br><br><h2>  <font color="#3AC1EF">Expresiones de inicializaci√≥n variable dentro de construcciones if y switch</font> </h2><br>  Realmente me gust√≥ esta innovaci√≥n de C ++ 17 justo despu√©s de descubrirlo.  Considere un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Resulta que ahora puede inicializar las variables y compararlas con su uso en un bloque <code>if</code> o <code>switch</code> .  Esto ayuda a escribir c√≥digo preciso.  Aqu√≠ hay una descripci√≥n esquem√°tica de la estructura en consideraci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Realizaci√≥n de c√°lculos en tiempo de compilaci√≥n utilizando constexpr</font> </h2><br>  La <code>constexpr</code> nos brinda grandes oportunidades.  Supongamos que tenemos alg√∫n tipo de expresi√≥n que necesita ser calculada, mientras que su valor, despu√©s de inicializarlo con la variable correspondiente, no cambiar√°.  Tal expresi√≥n puede calcularse de antemano y usarse como una macro.  O, lo que se hizo posible en C ++ 11, use la <code>constexpr</code> . <br><br>  Los programadores se esfuerzan por minimizar la cantidad de c√≥mputo realizado durante la ejecuci√≥n del programa.  Como resultado, si se pueden realizar ciertas operaciones durante el proceso de compilaci√≥n y, por lo tanto, eliminar la carga del sistema durante la ejecuci√≥n del programa, esto tendr√° un buen efecto en el comportamiento del programa durante la ejecuci√≥n.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Este es un ejemplo muy com√∫n del uso de <code>constexpr</code> . <br><br>  Como <code>constexpr</code> la funci√≥n para calcular el factorial como <code>constexpr</code> , el compilador puede calcular previamente el valor <code>fact(20)</code> en el momento de la compilaci√≥n del programa.  Como resultado, despu√©s de la compilaci√≥n, la cadena <code>const long long bigval = fact(20);</code>  puede ser reemplazado por <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Tenga en cuenta que el argumento pasado a la funci√≥n est√° representado por una constante.  Esta es una caracter√≠stica importante de usar funciones declaradas usando la <code>constexpr</code> .  Los argumentos que se les pasan tambi√©n deben declararse con la <code>constexpr</code> o con la palabra clave <code>const</code> .  De lo contrario, dichas funciones se comportar√°n como funciones ordinarias, es decir, durante la compilaci√≥n, sus valores no se calcular√°n de antemano. <br><br>  Las variables tambi√©n se pueden declarar utilizando la <code>constexpr</code> .  En este caso, como puede suponer, los valores de estas variables deben calcularse en tiempo de compilaci√≥n.  Si esto no se puede hacer, se mostrar√° un mensaje de error de compilaci√≥n. <br><br>  Es interesante observar que m√°s tarde, en C ++ 17, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aparecieron</a> las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">construcciones constexpr-if</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constexpr-lambda</a> . <br><br><h2>  <font color="#3AC1EF">Estructuras de datos de tupla</font> </h2><br>  Al igual que la estructura de datos de <code>pair</code> , la estructura de datos de <code>tuple</code> (tupla) es una colecci√≥n de valores de diferentes tipos de un tama√±o fijo.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  A veces, en lugar de una estructura de datos de <code>tuple</code> , es m√°s conveniente usar <code>std::array</code> .  Esta estructura de datos es similar a las matrices simples utilizadas en el lenguaje C, equipadas con caracter√≠sticas adicionales de la biblioteca est√°ndar de C ++.  Esta estructura de datos apareci√≥ en C ++ 11. <br><br><h2>  <font color="#3AC1EF">Inferir autom√°ticamente el tipo de argumento de plantilla de clase</font> </h2><br>  El nombre de esta caracter√≠stica parece bastante largo y complejo, pero de hecho no hay nada complicado aqu√≠.  La idea principal aqu√≠ es que en C ++ 17, la salida de tipos de argumentos de plantilla tambi√©n se realiza para plantillas de clase est√°ndar.  Anteriormente, esto solo era compatible con plantillas funcionales.  Como resultado, resulta que sol√≠an escribir as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Con el lanzamiento de C ++ 17, esta construcci√≥n ahora se puede reemplazar con esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  La inferencia de tipos se realiza impl√≠citamente.  Este mecanismo es a√∫n m√°s conveniente de usar cuando se trata de tuplas.  Es decir, antes ten√≠a que escribir lo siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Ahora lo mismo se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Vale la pena se√±alar que estas caracter√≠sticas no parecer√°n algo digno de atenci√≥n para aquellos que no est√°n particularmente familiarizados con las plantillas de C ++. <br><br><h2>  <font color="#3AC1EF">Punteros inteligentes</font> </h2><br>  Trabajar con punteros en C ++ puede ser una verdadera pesadilla.  Gracias a la libertad que el lenguaje le da al programador, a veces es muy dif√≠cil para √©l, como dicen, "no dispararse en el pie".  En muchos casos, los punteros est√°n presionando para que ese "disparo" del programador. <br><br>  Afortunadamente, C ++ 11 introdujo punteros inteligentes que son mucho m√°s convenientes que los punteros regulares.  Ayudan al programador a evitar p√©rdidas de memoria al liberar recursos cuando sea posible.  Adem√°s, proporcionan una garant√≠a de seguridad para excepciones. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ hay un</a> buen repositorio, que, creemos, ser√° interesante para aquellos que siguen las innovaciones de C ++.  Algo nuevo aparece constantemente en este idioma.  Aqu√≠ tocamos solo algunas caracter√≠sticas modernas del lenguaje.  De hecho, hay muchos de ellos.  Es posible que a√∫n hablemos de ellos. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© caracter√≠sticas modernas de C ++ encuentra m√°s interesantes y √∫tiles? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451870/">https://habr.com/ru/post/451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451858/index.html">Hacer un disyuntor basado en cach√© simple en primavera</a></li>
<li><a href="../451860/index.html">Los matem√°ticos han descubierto la forma perfecta de multiplicar n√∫meros.</a></li>
<li><a href="../451862/index.html">Rayo musical de Joe Diprim: un ingeniero autodidacta hace bobinas de Tesla para entretenimiento y ganancias</a></li>
<li><a href="../451864/index.html">Vulnerabilidad cr√≠tica de RCE del nivel EternalBlue detectado en el sistema operativo Windows</a></li>
<li><a href="../451866/index.html">Elija los nodos m√°s cercanos en la red</a></li>
<li><a href="../451872/index.html">Python es un asistente para encontrar vuelos baratos para quienes les gusta viajar</a></li>
<li><a href="../451874/index.html">Principales tendencias de SEO en Google</a></li>
<li><a href="../451876/index.html">Centro de datos de Frankfurt: centro de datos de Telehouse</a></li>
<li><a href="../451878/index.html">Transmisi√≥n en vivo de video est√©reo a gafas VR (Oculus Go)</a></li>
<li><a href="../451880/index.html">DevPRO'19: vista desde el stand de Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>