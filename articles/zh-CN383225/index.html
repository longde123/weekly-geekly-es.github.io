<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏽 🧑🏽‍🤝‍🧑🏻 🤴🏾 硬盘制造商的一些荒谬想法 🚛 👩🏾‍⚕️ 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="硬盘驱动器最近在与SSD的对抗中失去了基础，因为固态硬盘具有速度和对振动的恐慌恐惧，仅由于放置千兆字节数据的廉价成本和更多的重写周期而节省了自身。让我们考虑以下几个想法是否将有助于为HDD抢先一步。
 
 硬盘由一个或几个薄磁盘组成，这些薄磁盘具有安装在主轴上的铁磁表面，并由引擎以每分钟几千转的速度...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>硬盘制造商的一些荒谬想法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/383225/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬盘驱动器最近在与SSD的对抗中失去了基础，因为固态硬盘具有速度和对振动的恐慌恐惧，仅由于放置千兆字节数据的廉价成本和更多的重写周期而节省了自身。</font><font style="vertical-align: inherit;">让我们考虑以下几个想法是否将有助于为HDD抢先一步。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
硬盘由一个或几个薄磁盘组成，这些薄磁盘具有安装在主轴上的铁磁表面，并由引擎以每分钟几千转的速度旋转。一个单独的部分是一个沿着磁盘半径移动的磁头块。如果使用较早的系统以直线移动磁头块（例如CD / DVD中使用的系统），那么现在通常使用摇杆。头部固定在横梁的一端，而移动系统位于另一侧。起初，伺服器负责所有运动，但在他们学会了如何“大量而廉价地”制造强磁体之后，便开始使用磁体的磁场与提供电流的线圈的电磁场的相互作用机制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为存储，硬盘驱动器提供三个维度：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ililinder-距磁盘中心一定距离，沿该距离进行读，写操作，并且在开始操作之前，需要将磁头块移动到一个或另一个圆柱体上；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磁头-磁盘的每一侧，可以在其上放置数据的表面，磁头分别放置在其上，还有一个“磁道”的概念，它定义了放置在给定圆柱体上特定表面上的数据；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分段-放置在一个工作面上的轨道的一部分，数据实际上沿着该圆周定位。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了读取数据段，硬盘必须将磁头块移至所需的磁柱，从所需的磁头中选择数据流，然后等待磁盘变成磁头块下的所需段，然后才可以读取或写入数据。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据的访问时间取决于您的幸运程度，并且有几种情况。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况1：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您很幸运，并且在收到读取命令后，硬盘驱动器看到磁头块位于所需的圆柱体上，开始读取数据，并且您需要的是第一个读取的段。</font><font style="vertical-align: inherit;">为了计算您的幸运程度，让我们尝试计算该操作将花费多长时间：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定义变量：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t1是命令发送到硬盘的时间；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t2：硬盘命令处理时间；</font></font></li>
<li>t3-  ;</li>
<li>t4-     ;</li>
<li>t5-   ;</li>
<li>t6-       </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于上述情况，t3和t4趋于零，我们将忽略它们，以及t1命令的传输时间（对于命令的10-12字节，这将是数据的1/100部分）和t2命令的处理时间（取决于计算的复杂性和速度）处理器，但我们假设它足够快，可以忽略此时间段）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剩下的t5和t6用来计算这些值，我们采用接口的特性以及从磁盘读取的流（从一个轨道连续读取一定数量的段的速度）。为了简化计算，我们定义了一个1000字节的段（实际上是512或4096字节的数据加上一定数量的服务数据），流读取为50 Mb / s（更多，更少）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
t5-1000字节*（1 / 50,000,000字节/ s）=每段读/写</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
20μst6-取决于数据传输速度，让我们为不同的接口进行计算：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDE</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA33-33 Mb / s = 1000 *（1/33000000）= 30μs（比读取所花费的时间还多）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA66-66 Mb / s = 1000 *（1/66 000 000）= 15μs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMA100-100 Mb / s = 1000 *（1/100000000）= 10微秒</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SATA硬盘</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA I -1500 Gbit / s = 150 Mb / s = 1000 *（1/150000000）= 6.6微秒</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA II / SAS -3000 Gbit / s = 300 Mb / s = 1000 *（1/300000000）= 3.3微秒</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SATA III / SAS 2-6000 Gbit / s = 600 Mb / s = 1000 *（1/600000000）= 1.6μs</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么即使字节是8位，我也将SATA速度除以10？事实是，传输是在串行模式下进行的，并且为了可靠地传输数据，可以使用同步信号（开始和停止位，您好，</font></font><abbr title="你认真的吗？ 通讯端口-通讯端口，有时翻译为：通过调制解调器连接-通过调制解调器连接"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COM端口</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），或者对数据进行编码以使输出处不出现</font></font><abbr title="在相同位的背景下，丢失具有不同值的单个位"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">饱和通道</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管如此通过原始字节流的值（全为0或255），结果我们得到了具有相等数量的零和一的组合，由于信号的代码转换，信号频率也降低了（是的，频率较低，速度较高）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，如果幸运的话，我们将在21.6-50μs内收到数据，并且通过这种情况的计算，您可以了解制造商为何创建新的高速接口，尽管从磁盘读取的速度要慢得多（通信接口越快，更快，您的数据就可以在发送者和接收者之间立即准备好传输。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况2：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不太幸运，需要将磁头块移动到另一个圆柱体，找到所需的圆柱体后，必须等待磁盘旋转180度才能访问所需的段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，我不知道移动和定位磁头的时间，但是您可以计算将段移动一圈所需的时间，并将定位时间等于磁盘旋转时间的一半，并且该值是已知的，因此，我们考虑磁盘旋转时间（一半用于定位） ，将读取磁盘旋转半圈）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进行计算，您需要找出每秒发生多少转，然后通过将1除以转数来找出周期：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5400 rpm-1（5400/60）= 11ms </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5900 rpm-T = 10 ms </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7200 </font><font style="vertical-align: inherit;">rpm- </font><font style="vertical-align: inherit;">T = 8毫秒</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10,000 rpm-T = 6毫秒</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
15,000 rpm-T = 4毫秒</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您发现任何熟悉的含义吗？对！磁盘的平均数据访问时间大约等于或等于磁盘旋转周期，为什么要取平均值？因为存在：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况3：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不走运，磁头块在第一个圆柱体上，而该段在最后一个圆柱体上，磁头块的移动时间几乎等于磁头块定位在所需圆柱体上后磁盘旋转的时间，然后开始读取数据，结果是我们得到了所需片段之后的下一个片段，为了读取它，您需要等到磁盘再旋转一圈，而我对</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况4却</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一无所知</font><b><font style="vertical-align: inherit;">：</font></b><font style="vertical-align: inherit;">当数据不是来自第一次（可能是随后的）时间时是公关阅读（计算轻松所需的时间，Minium * T 2卷）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这个阶段可以得出什么结论？ “尤里卡：您需要将主轴旋转最多100500转！”。但是并不是所有的事情都那么简单，如果您在旋转木马上旋转，则应该知道，如果旋转木马的旋转速度不是太快，那么就很容易在任何地方停留，如果旋转木马的旋转太快，唯一的停留方法就是靠近中心并保持紧紧。如果大力拧开磁盘会发生什么：首先，由于离心力，磁盘的边缘将开始朝不同的方向分散，并且磁盘将首先开始朝不同的方向扩展，并且由于旋转速度没有降低，并且磁盘的大小增加了，离心的磁盘也增加了力，这导致分子键的破坏，我们从盘上得到“ bigbadabum”和几块。这是由于离心力的作用，高速光盘的直径较小，因此不会撕裂。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里出现了</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个荒谬的主意</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：为什么不可能使两个相对的磁头块而不是一个相对（并且，如果对两个磁头进行计算，则尝试3、4甚至5、6）。这给我们带来了什么：</font></font><br>
<img src="https://habrastorage.org/files/ea7/0b7/1f6/ea70b71f66814d99ac0e55c794277291.JPG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）随着零件数量的增加，系统的“可靠性”“下降”，但是由于我们获得了备用系统，因此“增加了可靠性”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）磁头块同步移动（在数据读取/写入期间磁头移动所引起的脉冲不起作用），如果该段刚刚跳过，则第二个磁头块将有机会通过T rev / 2进行读取（为此，在传统情况下，我们需要它将使主轴旋转两倍快）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）磁头块执行单独的任务（磁头块的移动脉冲的影响对于读/写操作不是必不可少的），知道该段或该段的位置的控制器可以移动位置最有利的磁头块，以减少在主轴旋转和数量上浪费的时间输入/输出操作将加倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4）在两种情况下，我们需要一次处理大量数据：- </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
复制/移动大文件（Hi Blu-ray）；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-read-modify-写入一个文件（数据库的hello）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在经典版本的硬盘驱动器中，复制时，我们将数据块读入缓冲区，将磁头块移至另一部分，写入数据，并返回新的数据块，而缓冲区数量少，我们在移动包含大量数据的磁头块时会浪费大量时间。在修改一个文件的情况下，我们填充缓冲区，对其进行修改（可以在读取所需配置中的第一个数据后立即与读取并行进行），然后在修改之后进行写入。在修改后的方案中，我们可以以最大速度复制文件，从一个磁头块读取数据，并以尽可能最高的速度写入第二个磁块，这主要取决于文件碎片，现在对于硬盘驱动器，如果使用两个驱动器，则可以，一次阅读，写另一个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
硬盘操作的第二个方面是可靠性，特别是典型的故障，我们忽略了程序逻辑故障，需要在其他地方进行维修，我只宣布取决于硬盘设计特征的故障：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动期间主轴卡死（嗯，有机会通过外部动作滚动主轴，启动磁盘，读取数据并将其发送至静止状态）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在运行过程中主轴被卡住（后果取决于您的运气）；</font></font></li>
<li>      ,    ,         ,           ()       (           ,        );</li>
<li>           ,        ,         ,   ,            ,                ;</li>
<li>     ,        ,            ,    ,                  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个人都知道，最大的价值不是硬盘驱动器的成本（hi $ -y），而是精心收集的“千兆字节”“有用信息”。为了保存数据，使用了不同级别的RAID系统，为此必须使用多个硬盘驱动器。这是</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个荒谬的想法</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现的</font><i><b><font style="vertical-align: inherit;">地方</font></b></i><font style="vertical-align: inherit;">：在单个驱动器中使用RAID技术。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果发生磁盘完全故障，当然它不会保存，但是如果丢失了1-2段数据，它将完全有助于纠正这种情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一种方法很容易通过软件实现，它是使用RAID 5技术放置整个表面或仅放置关键或重要数据（0段，分区表，系统配置文件）：A + B =总和，将三分之二我们可以轻松地恢复第三个，镜像或复制已被广泛使用，例如，在NTFS中复制了多个主文件表条目，但这在严重失败的情况下并不能节省太多，此外，“镜像”在双倍的情况下损失了一半的容量，而在收集统计信息的情况下对于不可读的段，有可能意识到将数据放置在“ A + B + C + D + E + E + F + G = I”上的可能性，我们将丢失1/9的卷，但是如果丢失一个数据段，则会增加数据恢复的机会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与修改控制器工作逻辑有关的第二种方法是使用带有校验和的数据将数据放置在磁盘的不同表面上，而不是将数据放在一个磁道上，这种实现方式可以节省工作磁头之一完全停止响应的情况，我们总是读来自其他表面的值将接收初始数据，但是通过保存数据我们可以郑重地使患者平静下来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，</font></font><i><s><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三个荒谬的想法</font></font></b></s></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（尽管它已经将外部驱动器视为一个类）将是：将对文件分配的支持和对磁盘控制器的文件系统支持委派给代理。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢谢：owniumo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
已经拥有：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于可扩展对象存储的动态硬盘</font></font></a><br>
</blockquote> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它将如何帮助：中央处理器将仅传输文件描述符及其所需的片段，例如，不再因与构建FAT链相关的中断而分心，并且控制器将计算指定片段的存储位置，并仅将所需的文件片段提供给控制器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以实现：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发和更换工厂固件（可能在当前硬件上，但是在后续修改和磁盘选件数量方面昂贵，对移动应用程序开发人员来说是好消息）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发支持磁盘制造商固件的文件系统；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在固件中开发和实现编程语言并借助它可以描述文件系统的工作</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这实际上是三个荒谬的想法，难以考验自己，但它们并不能使您睡个好觉。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS：注册商标或专利的随机使用是随机的。</font><font style="vertical-align: inherit;">根据</font></font><abbr title="这是一个单独的问题需要讨论"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蚂蚁山许可协议，</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有原始想法都可以使用</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN383225/">https://habr.com/ru/post/zh-CN383225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN383213/index.html">一个论坛隐私权纠纷的后果</a></li>
<li><a href="../zh-CN383215/index.html">智能手机的热像仪将帮助窃取银行卡密码</a></li>
<li><a href="../zh-CN383219/index.html">项目“眼睛”第10部分</a></li>
<li><a href="../zh-CN383221/index.html">我们害怕吗？现在哪个更危险-AI还是IoT？</a></li>
<li><a href="../zh-CN383223/index.html">生命科学公司是第一家在字母表控股中创建的公司</a></li>
<li><a href="../zh-CN383227/index.html">科学家通过添加金属纳米粒子使石墨烯成为催化剂</a></li>
<li><a href="../zh-CN383229/index.html">治疗双击综合征</a></li>
<li><a href="../zh-CN383231/index.html">TS-7063：记住80年代</a></li>
<li><a href="../zh-CN383233/index.html">关于Atlas基因测试：如何，为什么根本不昂贵以及我们为什么更好23andMe</a></li>
<li><a href="../zh-CN383235/index.html">卡西尼站传输土星Dione的高质量卫星图像</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>