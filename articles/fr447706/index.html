<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗞️ 👨🏿‍🤝‍👨🏻 🙇🏼 Pas un seul ORM 🍾 🈁 🔡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pas un seul ORM 


 Bonjour à tous! Je suis en charge du département Développement Partenaires du service de réservation d'hôtel Ostrovok.ru . Dans ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pas un seul ORM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/447706/"><h1 id="ne-ormom-edinym">  Pas un seul ORM </h1><br><p>  Bonjour à tous!  Je suis en charge du département Développement Partenaires du service de réservation d'hôtel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ostrovok.ru</a> .  Dans cet article, je voudrais parler de la façon dont nous avons utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Django ORM</a> sur un projet. </p><br><p>  En fait, je trompais, le nom aurait dû être " <del>  Pas </del>  ORM single ". Si vous vous demandez pourquoi j'ai écrit ceci, ainsi que si: </p><br><ul><li> Vous avez Django sur la pile, et vous voulez extraire le maximum d'ORM, pas seulement <code>Model.objects.all()</code> , </li><li>  Vous souhaitez transférer une partie de la logique métier au niveau de la base de données, </li><li>  Ou voulez-vous savoir pourquoi l'excuse la plus fréquente pour les développeurs de B2B.Ostrovok.ru est <em>"si historiquement"</em> , </li></ul><br><p>  ... bienvenue au chat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66b/308/b1c/66b308b1cd5afefead46ef7bffdbbddf.jpg" alt="cdpv"></p><a name="habracut"></a><br><p>  En 2014, nous avons lancé B2B.Ostrovok.ru - un service de réservation en ligne d'hôtels, de transferts, de voitures et d'autres services de voyage pour les professionnels du marché du tourisme (agents de voyages, opérateurs et entreprises). </p><br><p>  En B2B, nous avons conçu et utilisé avec succès un modèle d'ordre abstrait basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>GenericForeignKey</code></a> - meta order - <code>MetaOrder</code> . </p><br><p>  Une méta-commande est une entité abstraite qui peut être utilisée quel que soit le type de commande auquel elle appartient: un hôtel ( <code>Hotel</code> ), un service supplémentaire ( <code>Upsell</code> ) ou une voiture ( <code>Car</code> ).  À l'avenir, d'autres types peuvent apparaître. </p><br><p>  Cela n'a pas toujours été le cas.  Lorsque le service B2B a été lancé, seuls les hôtels pouvaient être réservés via celui-ci et toute la logique commerciale était concentrée sur eux.  De nombreux champs ont été créés, par exemple, pour afficher les taux de change du montant des ventes et du montant du remboursement de la réservation.  Au fil du temps, nous avons réalisé la meilleure façon de stocker et de réutiliser ces données, compte tenu des méta-commandes.  Mais le code entier n'a pas pu être réécrit, et une partie de cet héritage est entrée dans la nouvelle architecture.  En fait, cela a conduit à des difficultés dans les calculs, qui utilisent plusieurs types de commandes.  Que faire - donc <em>historiquement</em> ... </p><br><p>  Mon objectif est de montrer la puissance de Django ORM dans notre exemple. </p><br><h2 id="predystoriya">  Contexte </h2><br><p>  Pour planifier leurs dépenses, nos clients B2B manquaient vraiment d'informations sur le montant qu'ils doivent payer maintenant / demain / plus tard, s'ils ont des dettes sur les commandes et quelle est sa taille, ainsi que combien ils peuvent dépenser davantage dans leurs limites.  Nous avons décidé d'afficher ces informations sous la forme d'un tableau de bord - une telle prise simple avec un diagramme clair. </p><br><p><img src="https://habrastorage.org/webt/2a/rj/yo/2arjyoaa9_xfe8ddcaz5qn4w5mu.gif" alt="dash1"><br>  <em>(toutes les valeurs sont testées et ne s'appliquent pas à un partenaire spécifique)</em> </p><br><p>  À première vue, tout est assez simple - nous filtrons toutes les commandes du partenaire, les résumons et les affichons. </p><br><h2 id="varianty-resheniya">  Options de solution </h2><br><p>  Une petite explication sur la façon dont nous faisons les calculs.  Nous sommes une entreprise internationale, nos partenaires de différents pays effectuent des opérations - achat et revente de réservations - dans différentes devises.  De plus, ils doivent recevoir les états financiers dans la devise choisie (généralement locale).  Il serait stupide et peu pratique de stocker toutes les données possibles sur les taux de toutes les devises, vous devez donc choisir une devise de référence, par exemple le rouble.  Ainsi, vous pouvez enregistrer les taux de toutes les devises uniquement sur le rouble.  Ainsi, lorsqu'un partenaire souhaite recevoir un récapitulatif, nous convertissons les montants au taux fixé au moment de la vente. </p><br><h3 id="v-lob">  "Dans le front" </h3><br><p>  En fait, c'est <code>Model.objects.all()</code> et la boucle de conditions: </p><br><div class="spoiler">  <b class="spoiler_title">Model.objects.all () avec conditions</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() <span class="hljs-comment"><span class="hljs-comment"># query_get_one -    partner = query_get_one(Partner.objects.filter(id=partner_id)) #    -  query = MetaOrder.objects.filter(partner=partner) result = defaultdict(Decimal) for morder in query: #  ,     #     payment_pending = morder.get_payment_pending() payment_due = morder.get_payment_due() #        # (     ) payable = morder.get_payable_in_cur() #       if payment_pending &gt; today: result['payment_pending'] += payable # ,     if payment_pending &lt; today and payment_due &gt; today: result['payment_due'] += payable return result</span></span></code> </pre> </div></div><br><p>  Cette requête renvoie un générateur qui contient potentiellement plusieurs centaines de réservations.  Une demande à la base de données sera faite pour chacune de ces réservations, et donc le cycle se déroulera très longtemps. </p><br><p>  Vous pouvez accélérer un peu les choses en ajoutant la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>prefetch_related</code></a> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># object -      GenericForeignKey. query = query.prefetch_related('object')</span></span></code> </pre> <br><p>  Ensuite, il y aura un peu moins de requêtes vers la base de données ( <code>GenericForeignKey</code> sur <code>GenericForeignKey</code> ), mais à la fin nous nous arrêterons à leur nombre, car la requête vers la base de données sera toujours effectuée à chaque itération de la boucle. </p><br><p>  La méthode de <code>output</code> peut (et devrait) être mise en cache, mais le premier appel remplit toujours l'ordre d'une minute, ce qui est totalement inacceptable. </p><br><p>  Voici les résultats de cette approche: </p><br><p><img src="https://habrastorage.org/webt/yz/ur/wq/yzurwquhxoeqczgncqi66je8570.png" alt="timing_before"></p><br><p>  Le temps de réponse moyen est de 4 secondes et les pics atteignent 21 secondes.  Assez longtemps. </p><br><p>  Nous n'avons pas déployé le tableau de bord pour tous les partenaires, et donc nous n'avons pas eu beaucoup de demandes pour cela, mais il suffit quand même de comprendre que cette approche n'est pas efficace. </p><br><p><img src="https://habrastorage.org/webt/f0/rz/yn/f0rzynfsqypr3z0mh1cnwoi6ee0.png" alt="count_before"><br>  <em>Les nombres en bas à droite sont le nombre de requêtes: minimum, maximum, moyenne, total.</em> </p><br><h3 id="s-umom">  Sagement </h3><br><p>  Le prototype du front était bon pour comprendre la complexité de la tâche, mais pas optimal pour une utilisation.  Nous avons décidé qu'il serait beaucoup plus rapide et moins gourmand en ressources de faire plusieurs requêtes complexes dans la base de données que de nombreuses requêtes simples. </p><br><h4 id="plan-zaprosa">  Plan de demande </h4><br><p>  Les traits larges du plan de requête peuvent être décrits comme suit: </p><br><ul><li>  collecter les commandes selon les conditions initiales, </li><li>  préparer les champs pour le calcul par <code>annotate</code> , </li><li>  calculer les valeurs des champs </li><li>  faire des <code>aggregate</code> par le montant et la quantité </li></ul><br><h4 id="nachalnye-usloviya">  Conditions initiales </h4><br><p>  Les partenaires qui visitent le site ne peuvent voir des informations que sur leur contrat. </p><br><pre> <code class="python hljs">partner = query_get_one(Partner.objects.filter(id=partner_id))</code> </pre> <br><p>  Dans le cas où nous ne voulons pas afficher de nouveaux types de commandes / réservations, nous avons seulement besoin de filtrer celles prises en charge: </p><br><pre> <code class="python hljs">query = MetaOrder.objects.filter( partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ] )</code> </pre> <br><p>  Le statut de la commande est important (en savoir plus sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Q</code></a> ): </p><br><pre> <code class="python hljs">query = query.filter( Q(hotel__status__in=[<span class="hljs-string"><span class="hljs-string">'completed'</span></span>, <span class="hljs-string"><span class="hljs-string">'cancelled'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#     ,    # | Q(car__status__in=[...]) )</span></span></code> </pre> <br><p>  Nous utilisons également souvent des demandes prédéfinies, par exemple, pour exclure toutes les commandes qui ne peuvent pas être payées.  Il y a beaucoup de logique métier, ce qui n'est pas très intéressant pour nous dans le cadre de cet article, mais en substance ce ne sont que des filtres supplémentaires.  Une méthode qui renvoie une requête préparée pourrait ressembler à ceci: </p><br><pre> <code class="python hljs">query = MetaOrder.exclude_non_payable_metaorders(query)</code> </pre> <br><p>  Comme vous pouvez le voir, il s'agit d'une méthode de classe qui retournera également un <code>QuerySet</code> . </p><br><p>  Nous préparerons également quelques variables pour les constructions conditionnelles et pour stocker les résultats des calculs: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing.decimal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Decimal today = dt.date.today() result = defaultdict(Decimal)</code> </pre> <br><h4 id="podgotovka-poley-annotatehttpsdocsdjangoprojectcomen21refmodelsquerysetsannotate">  Préparation du terrain ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>annotate</code></a> ) </h4><br><p>  Étant donné que nous devons nous référer aux champs en fonction du type de commande, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Coalesce</code></a> .  Ainsi, nous pouvons résumer n'importe quel nombre de nouveaux types de commandes dans un seul champ. </p><br><p>  Voici la première partie du bloc d' <code>annotate</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Annoter d'abord</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     , #      from app.helpers.numbers import ZERO, ONE query_annoted = query.annotate( _payment_pending=Coalesce( 'hotel__payment_pending', 'car__payment_pending', 'upsell__payment_pending', ), _payment_due=Coalesce( 'hotel__payment_due', 'car__payment_due', 'upsell__payment_due', ), _refund=Coalesce( 'hotel__refund', Value(ZERO) ), _refund_currency_rate=Coalesce( 'hotel__refund_currency_rate', Value(ONE) ), _sell=Coalesce( 'hotel__sell', Value(ZERO) ), _sell_currency_rate=Coalesce( 'hotel__sell_currency_rate', Value(ONE) ), )</span></span></code> </pre> </div></div><br><p>  <code>Coalesce</code> travaille ici avec fracas, car les commandes d'hôtel ont plusieurs propriétés spéciales, et dans tous les autres cas (services supplémentaires et voitures), ces propriétés ne sont pas importantes pour nous.  C'est ainsi que la <code>Value(ZERO)</code> pour les montants et la <code>Value(ONE)</code> pour les taux de change apparaissent.  <code>ZERO</code> et <code>ONE</code> sont <code>Decimal('0')</code> et <code>Decimal(1)</code> , uniquement sous forme de constantes.  Une approche amateur, mais dans notre projet c'est accepté comme ça. </p><br><p>  Vous pourriez avoir une question, pourquoi ne pas mettre certains champs d'un niveau dans une méta-commande?  Par exemple, <code>payment_pending</code> , qui est partout.  En effet, au fil du temps, nous transférons ces champs dans une méta-commande, mais maintenant le code fonctionne bien, de telles tâches ne sont pas notre priorité. </p><br><h4 id="esche-odna-podgotovka-i-raschety">  Une autre préparation et calculs </h4><br><p>  Maintenant, nous devons faire quelques calculs avec les montants que nous avons reçus dans le dernier bloc d' <code>annotate</code> .  Notez qu'ici, vous n'avez plus besoin d'être lié au type de commande (sauf une exception). </p><br><div class="spoiler">  <b class="spoiler_title">Deuxième annoter</b> <div class="spoiler_text"><pre> <code class="python hljs">.annotate( <span class="hljs-comment"><span class="hljs-comment">#  _base     _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), )</span></span></code> </pre> </div></div><br><p>  La partie la plus intéressante de ce bloc est le champ <code>_reporting_currency_rate</code> , ou le taux de change vers la devise de référence au moment de la vente.  Les données sur les taux de change de toutes les devises vers la devise de référence pour une commande d'hôtel sont stockées dans <code>currency_data</code> .  C'est juste JSON.  Pourquoi gardons-nous cela?  <em>C'est historiquement le cas</em> . </p><br><p>  Et ici, il semblerait, pourquoi ne pas utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>F</code></a> et remplacer la valeur de la devise du contrat?  Autrement dit, ce serait cool si vous pouviez faire ceci: </p><br><pre> <code class="python hljs">F(<span class="hljs-string"><span class="hljs-string">f'currency_data__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{partner.reporting_currency}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><p>  Mais les <code>f-strings</code> ne <code>f-strings</code> pas prises en charge en <code>F</code>  Bien que le fait que Django ORM ait déjà la capacité d'accéder aux champs json imbriqués est très agréable - <code>F('currency_data__USD')</code> . </p><br><p>  Et le dernier bloc <code>annotate</code> est le calcul <code>_payable_in_cur</code> , qui sera résumé pour toutes les commandes.  Cette valeur doit être dans la devise du contrat. </p><br><p><img src="https://habrastorage.org/webt/3g/hi/rd/3ghirdq4rnexrp2vnhwucju7rkw.png" alt="dash2"></p><br><pre> <code class="python hljs">.annotate( _payable_in_cur=( F(<span class="hljs-string"><span class="hljs-string">'_payable_base'</span></span>) / F(<span class="hljs-string"><span class="hljs-string">'_reporting_currency_rate'</span></span>) ) )</code> </pre> <br><p>  La particularité de la méthode <code>annotate</code> est qu'elle génère beaucoup de constructions <code>SELECT something AS something_else</code> qui ne sont pas directement impliquées dans la requête.  Cela peut être vu en déchargeant la requête SQL - <code>query.__str__()</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici à quoi ressemble le</a> code SQL généré par Django ORM pour <code>base_query_annotated</code> .  Vous devez le lire assez souvent pour comprendre où vous pouvez optimiser votre requête. </p><br><h4 id="zaklyuchitelnye-podschety">  Calculs finaux </h4><br><p>  Il y aura un petit wrapper pour l' <code>aggregate</code> , de sorte qu'à l'avenir, si le partenaire a besoin d'une autre métrique, il puisse être facilement ajouté. </p><br><p><img src="https://habrastorage.org/webt/ky/qm/pi/kyqmpiht-jwpwuripuf6wlfiqv0.png" alt="dash3"></p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; Decimal:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO</code> </pre> <br><p>  Et encore une chose - c'est le dernier filtrage par condition commerciale, par exemple, nous avons besoin de toutes les commandes qui devront être payées bientôt. </p><br><p><img src="https://habrastorage.org/webt/xz/rj/ss/xzrjssl1barwnpvtegjkg1tkvs0.png" alt="dash4"></p><br><pre> <code class="python hljs">before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) )</code> </pre> <br><h4 id="otladka-i-proverka">  Débogage et vérification </h4><br><p>  Un moyen très pratique de vérifier l'exactitude de la demande créée est de la comparer avec une version plus lisible des calculs. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> morder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query: payable = morder.get_payable_in_cur() payment_pending = morder.get_payment_pending() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> payment_pending &gt; today: result[<span class="hljs-string"><span class="hljs-string">'payment_pending'</span></span>] += payable</code> </pre> <br><p>  Connaissez-vous la méthode du "front"? </p><br><h3 id="finalnyy-kod">  Code final </h3><br><p>  En conséquence, nous avons obtenu quelque chose comme ceci: </p><br><div class="spoiler">  <b class="spoiler_title">Code final</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_get_data_from_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query: QuerySet)</span></span></span><span class="hljs-function"> -&gt; tuple:</span></span> result = query.aggregate( _sum_payable=Sum(F(<span class="hljs-string"><span class="hljs-string">'_payable_in_cur'</span></span>)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'_sum_payable'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ZERO <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(partner_id: int)</span></span></span><span class="hljs-function">:</span></span> today = dt.date.today() partner = query_get_one(Partner.objects.filter(id=partner_id)) query = MetaOrder.objects.filter(partner=partner, content_type__in=[ Hotel.get_content_type(), Car.get_content_type(), Upsell.get_content_type(), ]) result = defaultdict(Decimal) query_annoted = query.annotate( _payment_pending=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_pending'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_pending'</span></span>, ), _payment_due=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'car__payment_due'</span></span>, <span class="hljs-string"><span class="hljs-string">'upsell__payment_due'</span></span>, ), _refund=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund'</span></span>, Value(ZERO) ), _refund_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__refund_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), _sell=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell'</span></span>, Value(ZERO) ), _sell_currency_rate=Coalesce( <span class="hljs-string"><span class="hljs-string">'hotel__sell_currency_rate'</span></span>, Value(Decimal(<span class="hljs-string"><span class="hljs-string">'1'</span></span>)) ), ).annotate( <span class="hljs-comment"><span class="hljs-comment"># Calculated fields _sell_base=( F('_sell') * F('_sell_currency_rate') ), _refund_base=( F('_refund') * F('_refund_currency_rate') ), _payable_base=( F('_sell_base') - F('_refund_base') ), _reporting_currency_rate=Case( # Only hotels have currency_data, therefore we need a # check and default value When( content_type=Hotel.get_content_type(), then=RawSQL( '(hotel.currency_data-&gt;&gt;%s)::numeric', (partner.reporting_currency,), ), ), output_field=DecimalField(), default=Decimal('1'), ), ) .annotate( _payable_in_cur=( F('_payable_base') / F('_reporting_currency_rate') ) ) before_payment_pending_query = _get_data_from_query( base_query_annotated.filter(_payment_pending__gt=today) ) after_payment_pending_before_payment_due_query = _get_data_from_query( base_query_annotated.filter( Q(_payment_pending__lte=today) &amp; Q(_payment_due__gt=today) ) )</span></span></code> </pre></div></div><br><p>  Voici comment cela fonctionne maintenant: </p><br><p><img src="https://habrastorage.org/webt/xg/1i/rf/xg1irfnazuk-rqk14wdlxn32nhi.png" alt="timing_after"></p><br><p><img src="https://habrastorage.org/webt/mt/k7/cq/mtk7cqefuzlx96roihjpgvpeaz8.png" alt="count_after"></p><br><h2 id="vyvody">  Conclusions </h2><br><p>  Après avoir réécrit et optimisé la logique, nous avons réussi à gérer assez rapidement les mesures d'affiliation et à réduire considérablement le nombre de requêtes dans la base de données.  La solution s'est avérée bonne et nous réutiliserons cette logique dans d'autres parties du projet.  ORM est notre tout. </p><br><p>  Écrivez des commentaires, posez des questions - nous essaierons de répondre!  Je vous remercie! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447706/">https://habr.com/ru/post/fr447706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447696/index.html">Pourquoi les villes s'opposent à Amazon Go, les premiers magasins non cash</a></li>
<li><a href="../fr447698/index.html">Poudlard rouge: académicien sans diplôme</a></li>
<li><a href="../fr447700/index.html">La flexibilité émotionnelle est la clé de la croissance personnelle.</a></li>
<li><a href="../fr447702/index.html">Le cercle mathématique idéal n'existe pas</a></li>
<li><a href="../fr447704/index.html">Escalade d'Elbrus - Reconnaissance au combat. Partie technique 1. Registres, piles et autres détails techniques</a></li>
<li><a href="../fr447708/index.html">Yandex a remis aux jeunes scientifiques et leaders scientifiques les premiers prix Ilya Segalovich</a></li>
<li><a href="../fr447712/index.html">Salut, SaaS | Russian SaaS 2018 - résultats</a></li>
<li><a href="../fr447714/index.html">Sur l'application de la théorie des processus ARMA dans la pratique de l'ingénierie</a></li>
<li><a href="../fr447716/index.html">Unité: dessinez plusieurs barres de vie en un seul appel</a></li>
<li><a href="../fr447718/index.html">Tout se passera comme prévu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>