<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ü©Ô∏è üôÜüèª ü§¥üèΩ Rechargement des textures OpenGLESv2 via DMABUF üòü üë©‚Äçüëß‚Äçüë¶ ‚ù£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je veux parler de la facilit√© de mise √† jour des textures OpenGLES via DMABUF. J'ai regard√© dans Habr et, √† ma grande surprise, je n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rechargement des textures OpenGLESv2 via DMABUF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dans cet article, je veux parler de la facilit√© de mise √† jour des textures OpenGLES via DMABUF.  J'ai regard√© dans Habr et, √† ma grande surprise, je n'ai trouv√© aucun article sur ce sujet.  Dans Habr Q&amp;A n'a √©galement rien trouv√© de tout cela.  Et c'est un peu √©trange pour moi.  La technologie est apparue il y a un certain temps, bien qu'il n'y ait vraiment pas beaucoup d'informations √† ce sujet sur le r√©seau, toutes sont vagues et contradictoires. <br><br>  J'ai collect√© toutes ces informations petit √† petit aupr√®s de diff√©rentes sources avant de pouvoir √©crire un tel lecteur vid√©o comme sur la d√©mo ci-dessus.  Ici, sur la d√©mo, mon lecteur vid√©o self-made bas√© sur la biblioth√®que gstreamer charge les images vid√©o dans la texture OpenGLESv2 √† chaque fois avant le rendu.  Propuls√© par Raspberry Pi4.  Les images sont simplement copi√©es dans une m√©moire sp√©cialement allou√©e - et DMA les transf√®re vers la m√©moire GPU, vers la texture.  Ensuite, je vais vous dire comment je l'ai fait. <br><a name="habracut"></a><br>  En r√®gle g√©n√©rale, un programmeur utilisant OpenGLESv2 cr√©e une texture une seule fois, puis la restitue simplement aux objets de la sc√®ne.  Cela se produit, car les costumes des personnages changent rarement et recharger parfois la texture avec glTexSubImage2D () n'est pas difficile.  Cependant, les vrais probl√®mes commencent lorsque la texture est dynamique, lorsque vous devez la mettre √† jour presque chaque image pendant le rendu.  La fonction glTexSubImage2D () est tr√®s lente.  Eh bien, c'est lent - bien s√ªr, tout d√©pend de l'ordinateur et de la carte graphique.  Je voulais trouver une solution qui fonctionnait m√™me sur des cartes √† carte unique faibles comme Raspberry. <br><br>  L'architecture de nombreux ordinateurs modernes, y compris ceux √† carte unique SoC, est telle que la m√©moire du processeur est distincte de la m√©moire du GPU.  Habituellement, les programmes utilisateur n'ont pas d'acc√®s direct √† la m√©moire du GPU et vous devez utiliser diverses fonctions API comme le m√™me glTexSubImage2D ().  De plus, j'ai lu quelque part que la repr√©sentation interne de la texture peut diff√©rer de la repr√©sentation traditionnelle des images comme une s√©quence de pixels.  Je ne sais pas √† quel point c'est vrai.  C'est possible. <br><br>  Alors qu'est-ce que la technologie DMABUF me donne?  La m√©moire est sp√©cialement allou√©e et un processus de n'importe quel thread peut simplement y √©crire des pixels quand il le souhaite.  Le DMA lui-m√™me transf√©rera toutes les modifications apport√©es √† la texture dans la m√©moire du GPU.  N'est-ce pas joli? <br><br>  Je dois dire tout de suite que je connais PBO - Pixel Buffer Object, g√©n√©ralement avec l'aide de la mise √† jour de texture dynamique PBO, DMA semble √™tre utilis√© l√† aussi, mais PBO est apparu uniquement dans OpenGLESv3 et pas dans toutes les impl√©mentations.  Donc non - h√©las, ce n'est pas mon chemin. <br><br>  L'article peut int√©resser √† la fois les programmeurs de framboises et les d√©veloppeurs de jeux, et probablement m√™me les programmeurs Android, car OpenGLES y est √©galement utilis√© et je suis s√ªr que cette technologie DMABUF y est √©galement pr√©sente (au moins, je suis s√ªr que vous pouvez l'utiliser √† partir d'Android NDK). <br><br>  J'√©crirai un programme utilisant DMABUF sur un Raspberry Pi4.  Le programme devrait √©galement (et fonctionnera) sur des ordinateurs Intel x86 / x86_64 ordinaires, par exemple sous ubuntu. <br><br>  Dans cet article, je suppose que vous savez d√©j√† programmer des graphiques avec l'API OpenGLESv2.  Cependant, il n'y aura pas beaucoup de ces d√©fis.  Surtout, nous aurons la magie ioctl. <br><br>  Donc, la premi√®re chose √† faire est de s'assurer que l'API disponible sur la plate-forme doit prendre en charge DMABUF.  Pour ce faire, consultez la liste des extensions EGL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* EglExtString = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( EglExtString, <span class="hljs-string"><span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span></span>) ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span></span>; }</code> </pre> <br>  Nous comprendrons donc imm√©diatement s'il y a un espoir d'utiliser DMABUF ou s'il n'y a aucun espoir.  Par exemple, sur Raspberry Pi3 et toutes les cartes pr√©c√©dentes, il n'y a aucun espoir.  L√†, en g√©n√©ral, m√™me OpenGLESv2 est en quelque sorte d√©pouill√©, via des biblioth√®ques sp√©ciales avec la broche BRCM.  Et maintenant sur Raspberry Pi4 il y a un vrai OpenGLES, l'extension EGL_EXT_image_dma_buf_import est, hourra. <br><br>  Je noterai tout de suite le syst√®me d'exploitation que j'ai sur un Pi4 √† carte unique, sinon il peut y avoir aussi des probl√®mes avec ceci: <br><br><pre> <code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a No LSB modules are available. Distributor ID: Raspbian Description: Raspbian GNU/Linux 10 (buster) Release: 10 Codename: buster pi@raspberrypi:~ $ uname -a Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux</code> </pre><br>  Je note √©galement que l'extension EGL_EXT_image_dma_buf_import est sur le PC Orange Pi (Mali-400) / PC2 (Mali-450), √† moins bien s√ªr que vous puissiez ex√©cuter le GPU Mali sur ces cartes (dans les assembl√©es officielles, il n'est pas l√†, je l'ai install√© sur Armbian, plus je l'ai fait moi-m√™me assemblage du pilote du noyau).  Autrement dit, DMABUF est presque partout.  Il est seulement n√©cessaire de prendre et d'utiliser. <br><br>  Ensuite, vous devez ouvrir le fichier / dev / dri / card0 ou / dev / dri / card1 - l'un d'eux, cela d√©pend de la plate-forme, cela se produit diff√©remment, vous devez rechercher le fichier qui prend en charge DRM_CAP_DUMB_BUFFER: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenDrm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/dri/card0"</span></span>, O_RDWR | O_CLOEXEC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot open /dev/dri/card0\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> hasDumb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { close( fd ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//maybe Raspberry Pi4 or other platform fd = open("/dev/dri/card1", O_RDWR | O_CLOEXEC); if( fd &lt; 0 ) { cout &lt;&lt; "cannot open /dev/dri/card1\n"; return -1; } hasDumb = 0; if( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; 0 ) { close( fd ); cout &lt;&lt; "/dev/dri/card1 has no support for DUMB_BUFFER\n"; return -1; } } if( !hasDumb ) { close( fd ); cout &lt;&lt; "no support for DUMB_BUFFER\n"; return -1; } //Get DRM authorization drm_magic_t magic; if( drmGetMagic(fd, &amp;magic) ) { cout &lt;&lt; "no DRM magic\n"; close( fd ); return -1; } Window root = DefaultRootWindow( x_display ); if( !DRI2Authenticate( x_display, root, magic ) ) { close( fd ); cout &lt;&lt; "Failed DRI2Authenticate\n"; return -1; } cout &lt;&lt; "DRM fd "&lt;&lt; fd &lt;&lt;"\n"; return fd; }</span></span></code> </pre><br>  Ici, au fait, il y a une subtilit√© inexplicable pour moi.  Certaines plates-formes ne disposent pas de biblioth√®ques fournissant la fonction DRI2Authenticate ().  Par exemple, il n'est pas au rendez-vous et dans la version 32 bits pour Orange Pi PC.  Tout cela est √©trange.  Mais j'ai trouv√© un tel r√©f√©rentiel sur GITHUB: <a href="https://github.com/robclark/libdri2">github.com/robclark/libdri2</a> il peut √™tre pris, assembl√© et install√©, alors tout va bien.  Il est √©trange que dans mon Ubuntu 18 (64 bits) sur un ordinateur portable, il n'y ait pas de probl√®me. <br><br>  Si vous pouviez trouver et ouvrir / dev / dri / cardX, vous pouvez continuer.  Vous devez acc√©der aux trois fonctions tr√®s n√©cessaires de KHR (Khronos): <br><br><pre> <code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC funcEglCreateImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ... funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglCreateImageKHR"</span></span>); funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglDestroyImageKHR"</span></span>); funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"glEGLImageTargetTexture2DOES"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature supported!!!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CloseDrm(); }</code> </pre><br>  Maintenant, nous avons besoin d'une fonction qui cr√©e une zone m√©moire pour DMABUF.  La fonction prend des param√®tres comme largeur, hauteur de bitmap, ainsi que des pointeurs vers lesquels le gestionnaire de descripteur de fichier DmaFd et un pointeur vers la m√©moire bitmap du plan seront renvoy√©s. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = *DmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pplane = *Plane = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create dumb buffer drm_mode_create_dumb buffer = { 0 }; buffer.width = Width; buffer.height = Height; buffer.handle = 0; buffer.bpp = 32; //Bits per pixel buffer.flags = 0; int ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer); cout &lt;&lt; "DRM_IOCTL_MODE_CREATE_DUMB " &lt;&lt; buffer.handle &lt;&lt; " " &lt;&lt; ret &lt;&lt; "\n"; if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"; return -1; } // Get the dmabuf for the buffer drm_prime_handle prime; memset(&amp;prime, 0, sizeof prime); prime.handle = buffer.handle; prime.flags = /*DRM_CLOEXEC |*/ DRM_RDWR; ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime); if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD " &lt;&lt; errno &lt;&lt; " " &lt;&lt; ret &lt;&lt;"\n"; return -1; } dmaFd = prime.fd; // Map the buffer to userspace int Bpp = 32; pplane = mmap(NULL, Width*Height*Bpp/8, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0); if( pplane == MAP_FAILED ) { cout &lt;&lt; "Error cannot mmap\n"; return -1; } //return valid values *DmaFd = dmaFd; *Plane = pplane; cout &lt;&lt; "DMABUF created "&lt;&lt; dmaFd &lt;&lt; " " &lt;&lt; (void*)Plane &lt;&lt;"\n"; return 0; }</span></span></code> </pre><br>  Maintenant, nous devons cr√©er une image EGL associ√©e au gestionnaire DmaFd: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBufferImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane, EGLImageKHR* Image )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* planePtr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bpp = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ret0&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; EGLint img_attrs[] = { EGL_WIDTH, Width, EGL_HEIGHT, Height, EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888, EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd, EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number"><span class="hljs-number">8</span></span>, EGL_NONE }; EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;img_attrs[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); *Plane = planePtr; *DmaFd = dmaFd; *Image = image; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF pointer "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)planePtr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF fd "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dmaFd &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EGLImageKHR "</span></span> &lt;&lt; image &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Et enfin, nos √©preuves sont presque termin√©es, et nous devons lier l'image EGL et l'image OpenGLESv2.  La fonction renvoie un pointeur vers la m√©moire dans l'espace d'adressage du processus.  L√†, vous pouvez simplement √©crire √† partir de n'importe quel thread de processeur et toutes les modifications au fil du temps apparaissent automatiquement dans la texture GPU via DMABUF. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideoTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height )</span></span></span><span class="hljs-function"> </span></span>{ CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR ); GLuint texId; glGenTextures ( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texId ); glBindTexture ( GL_TEXTURE_2D, texId ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR ); checkGlError( __LINE__ ); UserData *userData = (UserData*)esContext-&gt;userData; userData-&gt;textureV = texId; userData-&gt;textureV_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> esContext-&gt;Plane; }</code> </pre><br>  La fonction GlEGLImageTargetTexture2DOES (..) ne fait que cette liaison.  Il utilise la cr√©ation d'ID de texture normale glGenTextures (..) et l'associe √† l'image esContext-&gt; ImageKHR EGL pr√©c√©demment cr√©√©e.  Apr√®s cela, la texture userData-&gt; textureV peut √™tre utilis√©e dans des shaders r√©guliers.  Et le pointeur esContext-&gt; Plane est un pointeur sur la zone en m√©moire o√π vous devez √©crire pour mettre √† jour la texture. <br><br>  Voici un extrait de code qui copie une image vid√©o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GstFlowReturn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span></span></span><span class="hljs-function"> </span></span>{ GstFlowReturn ret = GST_FLOW_OK; GstSample *Sample = gst_app_sink_pull_sample(pAppsink); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Sample ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( VideoWidth==<span class="hljs-number"><span class="hljs-number">0</span></span> || VideoHeight==<span class="hljs-number"><span class="hljs-number">0</span></span> ) { GstCaps* caps = gst_sample_get_caps( Sample ); GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number"><span class="hljs-number">0</span></span>); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"width"</span></span>, &amp;VideoWidth); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"height"</span></span>, &amp;VideoHeight); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stream Resolution "</span></span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } GstBuffer *Buffer = gst_sample_get_buffer( Sample ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Buffer ) { GstMapInfo MapInfo; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;MapInfo, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MapInfo)); gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Mapped ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dmabuf_ptr ) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( dmabuf_ptr, MapInfo.data, MapInfo.size ); gst_buffer_unmap( Buffer, &amp;MapInfo); frame_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; update_cv.notify_one(); } } gst_sample_unref( Sample ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Cette fonction est appel√©e par gstreamer lui-m√™me chaque fois qu'une nouvelle image vid√©o appara√Æt.  Nous le r√©cup√©rons en utilisant gst_app_sink_pull_sample ().  Cette fonction a memcpy (), qui copie la trame dans la m√©moire DMABUF.  Ensuite, l'indicateur frame_ready est d√©fini et via std :: condition_variable update_cv.notify_one (), le flux qui s'affiche est r√©veill√©. <br><br>  C'est probablement tout ... <br><br>  Bien que non, je mens.  Il y a encore des probl√®mes de synchronisation. <br><br>  La premi√®re est que le processeur √©crit en m√©moire, mais ces enregistrements peuvent se retrouver dans le cache du processeur et y √™tre conserv√©s, vous devez cr√©er un cache cache apr√®s l'enregistrement.  La seconde - il ne serait pas mauvais de savoir exactement quand le DMA a d√©j√† fonctionn√© et vous pouvez commencer le rendu.  Honn√™tement, si le premier j'imagine encore comment faire, alors le second - non.  Si vous avez des id√©es, √©crivez dans les commentaires. <br><br>  Et encore une chose.  J'utilise gstreamer, qui lit un fichier vid√©o.  J'ai ajout√© un appsink g√©n√©rique au pipeline, qui re√ßoit des images vid√©o.  Je prends les pixels des images vid√©o et je les copie simplement memcpy () dans la zone m√©moire DMABUF.  Le rendu est dans un thread s√©par√©, main ().  Mais je voudrais me d√©barrasser de cette copie.  Chaque copie est mauvaise.  Il existe m√™me un tel terme z√©ro-copie.  Et √† en juger par la documentation, il semble que gstreamer lui-m√™me puisse rendre les images imm√©diatement dans DMABUF.  Malheureusement, je n'ai trouv√© aucun exemple r√©el.  J'ai regard√© les sources de gstreamer - il y a quelque chose √† ce sujet, mais comment l'utiliser exactement n'est pas clair.  Si vous savez comment cr√©er de v√©ritables cadres sans copie avec gstreamer dans la texture OpenGLESv2 - √©crivez. <br><br>  Peut-√™tre le dernier point: dans mon projet, j'utilise des bitmaps 32 bits, ce qui n'est pas bon dans mon cas.  Il serait beaucoup plus raisonnable de prendre YUV de gstreamer, alors la taille de l'image vid√©o est beaucoup plus petite, mais la logique est compliqu√©e - je devrais faire 3 DMABUF pour trois textures s√©par√©ment Y, U, V.Eh bien, le shader est √©galement compliqu√©, vous devez convertir YUV en ARGB en plein shader. <br><br>  Vous pouvez visualiser l'ensemble du projet <a href="https://github.com/random-prj/video-cube">sur github</a> .  Cependant, je m'excuse √† l'avance aupr√®s des amateurs de code / style propre et correct.  J'avoue qu'il a √©t√© √©crit n√©gligemment avec l'aide de Google-mine-paste. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481540/">https://habr.com/ru/post/fr481540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481530/index.html">Nevanger: Nourrir pour la vitesse</a></li>
<li><a href="../fr481532/index.html">Forensics de la m√©moire, Rubber Duck et mots de passe GPO. R√©solution de probl√®mes avec r0ot-mi. 2e partie</a></li>
<li><a href="../fr481534/index.html">Delphi est-il en train de mourir - Faux</a></li>
<li><a href="../fr481536/index.html">L'histoire du syst√®me des noms de domaine: les protocoles de ¬´guerre¬ª</a></li>
<li><a href="../fr481538/index.html">20 mythes SEO √† mourir en 2020</a></li>
<li><a href="../fr481542/index.html">V√©rification des circuits num√©riques. Revue</a></li>
<li><a href="../fr481544/index.html">Utilisation d'un r√©seau de neurones convolutionnels pour jouer √† Life (sur Keras)</a></li>
<li><a href="../fr481546/index.html">L'histoire du microprocesseur et de l'ordinateur personnel: 1947-1974</a></li>
<li><a href="../fr481548/index.html">Symbol.iterator en Javascript</a></li>
<li><a href="../fr481550/index.html">Inmarsat: recevoir et d√©coder un signal satellite √† domicile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>