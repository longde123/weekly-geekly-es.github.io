<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>〰️ 👴🏾 🗓️ Perlindungan tanpa rasa takut. Keamanan Thread dalam Karat 🤞🏻 🐊 🐴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari seri artikel Perlindungan Fearless. Yang pertama kita berbicara tentang keamanan memori 

 Aplikasi modern bersifat multi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perlindungan tanpa rasa takut. Keamanan Thread dalam Karat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441370/">  <font color="gray"><i>Ini adalah bagian kedua dari seri artikel Perlindungan Fearless.</i></font>  <font color="gray"><i>Yang pertama kita berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan memori</a></i></font> <br><br>  Aplikasi modern bersifat multi-utas: alih-alih menjalankan tugas secara berurutan, program menggunakan utas untuk secara bersamaan melakukan beberapa tugas.  Kita semua mengamati <i>kerja simultan</i> dan <i>konkurensi</i> setiap hari: <br><br><ul><li>  Situs web dilayani oleh beberapa pengguna secara bersamaan. <br></li><li> UI melakukan pekerjaan latar belakang yang tidak mengganggu pengguna (bayangkan bahwa setiap kali Anda mengetik karakter, aplikasi membeku untuk memeriksa ejaan). <br></li><li>  Komputer dapat menjalankan beberapa aplikasi sekaligus. </li></ul><br>  Aliran paralel mempercepat pekerjaan, tetapi memperkenalkan serangkaian masalah sinkronisasi, yaitu kebuntuan dan kondisi balapan.  Dari sudut pandang keamanan, mengapa kita peduli dengan keselamatan benang?  Karena keamanan memori dan utas memiliki satu dan masalah utama yang sama: penggunaan sumber daya yang tidak tepat.  Serangan di sini memiliki efek yang sama dengan serangan memori, termasuk eskalasi hak istimewa, eksekusi kode arbitrer (ACE), dan memintas pemeriksaan keamanan. <br><a name="habracut"></a><br>  Kesalahan konkurensi, seperti kesalahan implementasi, terkait erat dengan kebenaran program.  Sementara kerentanan memori hampir selalu berbahaya, kesalahan implementasi / logika tidak selalu menunjukkan masalah keamanan jika tidak terjadi di bagian kode yang terkait dengan kepatuhan dengan kontrak keamanan (misalnya, izin untuk memintas pemeriksaan keamanan).  Tetapi bug konkurensi memiliki kekhasan.  Jika masalah keamanan karena kesalahan logis sering muncul di sebelah kode yang sesuai, maka kesalahan konkurensi sering terjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada fungsi lain, dan bukan pada fungsi yang kesalahannya langsung dibuat</a> , yang membuatnya sulit untuk melacak dan menghilangkannya.  Kesulitan lain adalah tumpang tindih tertentu antara pemrosesan memori yang tidak tepat dan kesalahan konkurensi, yang kita lihat dalam balapan data. <br><br>  Bahasa pemrograman telah mengembangkan berbagai strategi konkurensi untuk membantu pengembang mengelola masalah kinerja dan keamanan aplikasi multi-utas. <br><br><h1>  Masalah konkurensi </h1><br>  Secara umum diterima bahwa pemrograman paralel lebih sulit dari biasanya: otak kita lebih baik beradaptasi dengan penalaran berurutan.  Kode paralel dapat memiliki interaksi tak terduga dan tidak diinginkan antara utas, termasuk deadlock, pertikaian, dan ras data. <br><br>  <i>Kebuntuan</i> terjadi ketika beberapa utas berharap satu sama lain untuk melakukan tindakan tertentu untuk terus bekerja.  Meskipun perilaku yang tidak diinginkan ini dapat menyebabkan penolakan serangan layanan, itu tidak akan menyebabkan kerentanan seperti ACE. <br><br>  <i>Kondisi lomba</i> adalah situasi di mana waktu atau urutan tugas dapat memengaruhi kebenaran suatu program.  Perlombaan data terjadi ketika beberapa aliran mencoba untuk secara bersamaan mengakses lokasi memori yang sama dengan setidaknya satu upaya penulisan.  Kebetulan bahwa kondisi balapan dan perlombaan data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjadi secara terpisah satu</a> sama lain.  Tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">data balapan selalu berbahaya</a> . <br><br><h3>  Konsekuensi Potensi Kesalahan Konkurensi </h3><br><ol><li>  Jalan buntu <br></li><li>  Kehilangan informasi: utas lain menimpa informasi <br></li><li>  Kehilangan integritas: informasi dari beberapa aliran terjalin <br></li><li>  Kehilangan viabilitas: masalah kinerja karena akses yang tidak merata ke sumber daya bersama </li></ol><br>  Jenis serangan konkurensi yang paling terkenal disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TOCTOU</a> (waktu pemeriksaan hingga waktu penggunaan): pada dasarnya, keadaan suatu ras adalah antara kondisi pemeriksaan (misalnya, kredensial keamanan) dan menggunakan hasilnya.  Serangan TOCTOU mengakibatkan hilangnya integritas. <br><br>  Penguncian bersama dan hilangnya kemampuan bertahan dianggap sebagai masalah kinerja, bukan masalah keamanan, sementara hilangnya informasi dan hilangnya integritas kemungkinan terkait dengan keamanan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Keamanan Balon Merah</a> membahas beberapa kemungkinan eksploitasi.  Salah satu contohnya adalah korupsi pointer yang diikuti oleh peningkatan hak akses atau eksekusi kode jarak jauh.  Dalam exploit, fungsi yang memuat pustaka bersama ELF (Executable and Linkable Format) dengan benar memulai semaphore hanya pada panggilan pertama, dan kemudian secara tidak benar membatasi jumlah utas, yang menyebabkan kerusakan memori kernel.  Serangan ini adalah contoh kehilangan informasi. <br><br>  Bagian tersulit dari pemrograman konkuren adalah pengujian dan debugging, karena kesalahan konkurensi sulit untuk direproduksi.  Waktu kejadian, keputusan sistem operasi, lalu lintas jaringan dan faktor-faktor lain ... semua ini mengubah perilaku program pada setiap permulaan. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa1/702/1b2/aa17021b2f9cb3eb726ea37995ed4e2e.png"></a> </div><br>  <i><font color="gray">Terkadang lebih mudah untuk menghapus seluruh program daripada mencari bug.</font></i>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heisenbugs</a></font></i> <br><br>  Perilaku tidak hanya berubah setiap kali dimulai, tetapi bahkan menyisipkan output atau pernyataan debug dapat mengubah perilaku, menghasilkan “bug Heisenberg” (kesalahan non-deterministik, sulit untuk mereproduksi khas pemrograman paralel) yang muncul dan menghilang secara misterius. <br><br>  Pemrograman paralel sulit.  Sulit untuk memprediksi bagaimana kode paralel akan berinteraksi dengan kode paralel lainnya.  Ketika kesalahan muncul, mereka sulit ditemukan dan diperbaiki.  Alih-alih mengandalkan penguji, mari kita melihat cara untuk mengembangkan program dan penggunaan bahasa yang membuat penulisan kode paralel lebih mudah. <br><br>  Pertama, kami merumuskan konsep "keamanan benang": <br><br><blockquote>  "Tipe data atau metode statis dianggap sebagai thread aman jika berperilaku dengan benar ketika dipanggil dari beberapa utas, terlepas dari bagaimana utas ini dijalankan, dan tidak memerlukan koordinasi tambahan dari kode panggilan."  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MIT</a> </blockquote><br><h1>  Bagaimana bahasa pemrograman bekerja dengan paralelisme </h1><br>  Dalam bahasa tanpa keamanan ulir statis, programmer harus terus-menerus memonitor memori yang dibagi dengan utas lain dan dapat berubah kapan saja.  Dalam pemrograman berurutan, kita diajarkan untuk menghindari variabel global jika bagian lain dari kode diam-diam mengubahnya.  Tidak mungkin untuk meminta programmer untuk menjamin perubahan aman dalam data bersama, serta manajemen memori manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/3e3/5d2/e3e3e35d2775715a1f337d7c58aad7f7.gif"></div><br>  <i><font color="gray">"Kewaspadaan Konstan!"</font></i> <br><br>  Biasanya, bahasa pemrograman dibatasi pada dua pendekatan: <br><br><ol><li>  Batasan mutabilitas atau pembatasan berbagi <br></li><li>  Keamanan utas manual (mis. Kunci, semafor) </li></ol><br>  Bahasa dengan batasan utas baik menetapkan batas 1 utas untuk variabel yang dapat berubah, atau mengharuskan semua variabel umum tidak berubah.  Kedua pendekatan mengatasi masalah dasar perlombaan data - data bersama yang dimodifikasi secara salah - tetapi batasannya terlalu berat.  Untuk mengatasi masalah tersebut, bahasa membuat primitif sinkronisasi tingkat rendah, seperti mutex.  Mereka dapat digunakan untuk membangun struktur data yang aman. <br><br><h3>  Python dan penguncian global oleh juru bahasa </h3><br>  Implementasi referensi dalam Python dan Cpython memiliki mutex aneh yang disebut Global Interpreter Lock (GIL), yang memblokir semua utas lainnya ketika satu utas mengakses suatu objek.  Multithreaded Python terkenal karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inefisiensi</a> karena latensi GIL.  Oleh karena itu, sebagian besar program Python bersamaan bekerja dalam beberapa proses sehingga masing-masing memiliki GIL sendiri. <br><br><h3>  Pengecualian Java dan runtime </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> mendukung pemrograman bersamaan melalui model memori bersama.  Setiap utas memiliki jalur eksekusi sendiri, tetapi ia dapat mengakses objek apa pun dalam program: pemrogram harus menyinkronkan akses antara utas menggunakan primitif Java bawaan. <br><br>  Meskipun Java memiliki blok penyusun untuk membuat program-program thread aman, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan thread</a> <b>tidak dijamin oleh</b> kompiler (sebagai lawan dari keamanan memori).  Jika akses memori yang tidak disinkronkan terjadi (mis. Ras data), maka Java akan melempar pengecualian run-time, tetapi programmer harus menggunakan primitif concurrency yang tepat. <br><br><h3>  C ++ dan otak programmer </h3><br>  Sementara Python menghindari kondisi balapan dengan GIL dan Java melempar pengecualian pada saat run time, C ++ mengharapkan programmer untuk secara manual menyinkronkan akses memori.  Sebelum C ++ 11, perpustakaan standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak menyertakan primitif konkurensi</a> . <br><br>  Sebagian besar bahasa menyediakan alat untuk menulis kode aman, dan ada metode khusus untuk mendeteksi ras data dan status ras;  tetapi tidak memberikan jaminan keamanan utas dan tidak melindungi terhadap perlombaan data. <br><br><h1>  Bagaimana cara mengatasi masalah Rust? </h1><br>  Rust mengambil pendekatan multi-sisi untuk menghilangkan kondisi balapan menggunakan aturan tenurial dan tipe aman untuk sepenuhnya melindungi terhadap kondisi balapan pada waktu kompilasi. <br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama,</a> kami memperkenalkan konsep kepemilikan, ini adalah salah satu konsep dasar Rust.  Setiap variabel memiliki pemilik yang unik, dan kepemilikan dapat ditransfer atau dipinjam.  Jika utas lain ingin mengubah sumber daya, maka kami mentransfer kepemilikan dengan memindahkan variabel ke utas baru. <br><br>  Memindahkan melempar pengecualian: beberapa utas dapat menulis ke memori yang sama, tetapi tidak pernah secara bersamaan.  Karena pemilik selalu sendirian, apa yang terjadi jika utas lain meminjam variabel? <br><br>  Di Rust, Anda memiliki satu pinjaman yang bisa berubah, atau beberapa yang tidak berubah.  Tidak mungkin untuk secara bersamaan memperkenalkan pinjaman yang dapat berubah dan tidak dapat diubah (atau beberapa pinjaman yang bisa berubah).  Dalam keamanan memori, penting agar sumber daya dibebaskan dengan benar, dan dalam keselamatan utas penting bahwa hanya satu utas yang berhak mengubah variabel pada waktu tertentu.  Selain itu, dalam situasi seperti itu, tidak ada aliran lain akan merujuk pada pinjaman usang: baik pencatatan atau berbagi dimungkinkan untuk itu, tetapi tidak keduanya. <br><br>  Konsep kepemilikan dirancang untuk mengatasi kerentanan memori.  Ternyata itu juga mencegah balap data. <br><br>  Meskipun banyak bahasa memiliki metode keamanan memori (seperti penghitungan tautan dan pengumpulan sampah), mereka biasanya mengandalkan sinkronisasi manual atau larangan berbagi bersama untuk mencegah perlombaan data.  Pendekatan Rust membahas kedua jenis keamanan, mencoba memecahkan masalah utama dalam menentukan penggunaan sumber daya yang dapat diterima dan memastikan validitas ini pada waktu kompilasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/88b/4d9/97288b4d9796a35d8cce9400c2dbfd73.png"></div><br><br><h3>  Tapi tunggu!  Bukan itu saja! </h3><br>  Aturan kepemilikan mencegah beberapa utas dari menulis data ke lokasi memori yang sama dan melarang pertukaran data secara simultan antara utas dan mutabilitas, tetapi ini tidak serta merta menyediakan struktur data yang aman untuk thread.  Setiap struktur data di Rust aman atau tidak.  Ini diteruskan ke kompiler menggunakan sistem tipe. <br><br><blockquote>  "Program yang diketik dengan baik tidak bisa membuat kesalahan."  - Robin Milner, 1978 </blockquote><br>  Dalam bahasa pemrograman, ketik sistem menggambarkan perilaku yang dapat diterima.  Dengan kata lain, program yang diketik dengan baik didefinisikan dengan baik.  Selama tipe kami cukup ekspresif untuk menangkap makna yang dimaksud, program yang diketik dengan baik akan berperilaku sebagaimana dimaksud. <br><br>  Karat adalah bahasa jenis-aman, di sini kompiler memeriksa konsistensi semua jenis.  Misalnya, kode berikut ini tidak dikompilasi: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-string"><span class="hljs-string">"I am a string"</span></span>; x = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br><pre> <code class="rust hljs"> error[E0308]: mismatched types --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | x = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">// | ^ expected &amp;str, found integral variable | = note: expected type `&amp;str` found type `{integer}`</span></span></code> </pre> <br>  Semua variabel di Rust sering bertipe implisit.  Kita juga dapat mendefinisikan tipe baru dan mendeskripsikan kemampuan masing-masing tipe menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem sifat</a> .  Ciri memberikan abstraksi antarmuka.  Dua sifat bawaan yang penting adalah <code>Send</code> dan <code>Sync</code> , yang disediakan secara default oleh kompiler untuk setiap jenis: <br><br><ul><li>  <code>Send</code> menunjukkan bahwa struktur dapat ditransfer dengan aman di antara utas (diperlukan untuk mentransfer kepemilikan) <br></li><li>  <code>Sync</code> menunjukkan bahwa utas dapat menggunakan struktur dengan aman. </li></ul><br>  Contoh di bawah ini adalah versi <a href="">kode yang</a> disederhanakan dari <a href="">pustaka standar</a> yang menumbuhkan utas: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;Closure: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(closure: Closure){ ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = std::rc::Rc::new(<span class="hljs-number"><span class="hljs-number">6</span></span>); spawn(|| { x; });</code> </pre> <br>  Fungsi <code>spawn</code> mengambil argumen tunggal, <code>closure</code> dan membutuhkan tipe untuk yang terakhir yang mengimplementasikan sifat-sifat <code>Send</code> dan <code>Fn</code> .  Saat mencoba membuat aliran dan meneruskan nilai <code>closure</code> dengan variabel <code>x</code> kompiler melempar kesalahan: <br><br><pre>  kesalahan [E0277]: `std :: rc :: Rc &lt;i32&gt;` tidak dapat dikirim di antara utas dengan aman
      -&gt; src / main.rs: 8: 1
       |
     8 |  spawn (move || {x;});
       |  ^^^^^ `std :: rc :: Rc &lt;i32&gt;` tidak dapat dikirim di antara utas dengan aman
       |
       = help: dalam `[closure@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`, sifat `std :: marker :: marker :: Send` tidak diterapkan untuk `std :: rc :: Rc &lt;i32&gt;`
       = note: diperlukan karena muncul di dalam tipe `[closure@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`
     Catatan: dibutuhkan oleh `spawn` </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Karakter</a> <code>Send</code> dan <code>Sync</code> memungkinkan sistem tipe Rust untuk memahami data apa yang dapat dibagikan.  Dengan memasukkan informasi ini dalam sistem tipe, keselamatan ulir menjadi bagian dari keamanan tipe.  Alih-alih dokumentasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan utas diterapkan oleh hukum kompiler</a> . <br><br>  Pemrogram dengan jelas melihat objek umum di antara utas, dan kompiler menjamin keandalan instalasi ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/af5/27e/35caf527e18989b41893e6fd37239dab.gif"></div><br><br>  Meskipun alat pemrograman paralel tersedia dalam banyak bahasa, mencegah kondisi lomba tidak mudah.  Jika Anda membutuhkan programmer untuk instruksi alternatif yang rumit dan berinteraksi di antara utas, maka kesalahan tidak bisa dihindari.  Meskipun pelanggaran keamanan benang dan memori menyebabkan konsekuensi yang serupa, perlindungan memori tradisional, seperti penghitungan tautan dan pengumpulan sampah, tidak mencegah kondisi balapan.  Selain jaminan statis keamanan memori, model kepemilikan Rust juga mencegah perubahan data yang tidak aman dan pembagian objek yang tidak benar di antara thread, sementara sistem tipe memberikan keamanan thread pada waktu kompilasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/429/fb9/92d429fb9c3812ddfdf115d71a3695ed.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441370/">https://habr.com/ru/post/id441370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441360/index.html">Openshift - kerajinan topi merah</a></li>
<li><a href="../id441362/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 3</a></li>
<li><a href="../id441364/index.html">Program konferensi Lua di Moskow 2019</a></li>
<li><a href="../id441366/index.html">Apakah toko memerlukan Stylish Crossell: Pengalaman Retail Rocket dalam analisis gambar untuk membentuk rekomendasi</a></li>
<li><a href="../id441368/index.html">Seperti apa bentuk bulan Neptunus yang sebelumnya tidak terlihat</a></li>
<li><a href="../id441372/index.html">[Jumat] Cara menggoreng ayam dalam hal fisika</a></li>
<li><a href="../id441376/index.html">Melampaui kemurnian: apa yang bisa dan apa yang tidak bisa membalikkan membran osmosis</a></li>
<li><a href="../id441378/index.html">Peneliti dari Google: untuk melindungi dari Specter memerlukan perubahan dalam arsitektur prosesor, tambalan perangkat lunak tidak akan membantu</a></li>
<li><a href="../id441380/index.html">7 poin pertumbuhan konversi atau cara meningkatkan clickability tombol</a></li>
<li><a href="../id441382/index.html">Ilmuwan Cina telah mengembangkan generator piezoelektrik untuk alat pacu jantung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>