<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💻 🏙️ 🐹 Wie Quantencomputer die Softwareentwicklung beeinflussen können 🈸 🈺 🚣🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Seit etwa sechs Monaten beschäftigt sich der Verlag aktiv mit dem Thema Quantencomputer und dessen praktische Anwendbarkeit. Lang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Quantencomputer die Softwareentwicklung beeinflussen können</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/450480/">  Hallo allerseits! <br><br>  Seit etwa sechs Monaten beschäftigt sich der Verlag aktiv mit dem Thema Quantencomputer und dessen praktische Anwendbarkeit.  Lange Zeit war es nicht möglich, einen würdigen Artikel zur Übersetzung zu diesem interessanten Thema zu finden, bis ein solcher Artikel im Oracle-Blog erschien.  Die Veröffentlichung bietet eine hervorragende Einführung in die Software-, Hardware- und rein naturwissenschaftlichen Probleme dieses neuen Paradigmas. Lesen ist daher ein Muss. <br><br><img src="https://habrastorage.org/webt/it/bt/rt/itbtrtg_wcsimf8fhliumzzyigu.jpeg"><br><a name="habracut"></a><br>  In den letzten Monaten und Jahren hat das Interesse an Quantencomputern erheblich zugenommen.  Es erscheinen ständig neue Materialien von Forschungsinstituten, Unternehmen oder Regierungsorganisationen, die über bahnbrechende Erfolge in diesem Bereich berichten.  Gleichzeitig diskutieren Artikel mit einer schwächeren technischen Basis die möglichen Konsequenzen des Quantencomputers. Prognosen reichen vom Hacken modernster Verschlüsselungstechniken bis hin zu Versprechungen, alle Krankheiten zu heilen und die Arbeit an der Schaffung einer vollwertigen KI abzuschließen.  Allerdings sind nicht alle diese Erwartungen gleichermaßen realistisch. <br><br>  Wenn Sie ein praktizierender nüchterner Programmierer sind, fragen Sie sich möglicherweise, wo die Grenze zwischen Fakten und Fiktion in diesen Berechnungen liegt und wie sich Quantencomputer in Zukunft auf die Softwareentwicklung auswirken werden. <br><br>  Natürlich bleiben noch viele Jahre bis zur Schaffung funktionierender Hardware für das Quantencomputing.  Die allgemeinen Prinzipien dieses Paradigmas sind jedoch bereits heute bekannt. Es gibt Abstraktionen, mit denen Entwickler Anwendungen erstellen können, in denen die Möglichkeiten des Quantencomputers mithilfe von Simulatoren realisiert werden. <br><br><h4>  Wird Quantencomputer auf einen anderen CPU-Gewinn reduziert? </h4><br>  Bei der herkömmlichen Softwareentwicklung mit klassischen Computern wird eine Programmiersprache auf hoher Ebene (z. B. Java) in Operationen übersetzt, die auf einer großen Anzahl von (Hardware-) Transistoren ausgeführt werden. <br><br>  In Abbildung 1 ist dieser Prozess in seiner einfachsten Form schematisch dargestellt: Java-Quellcode wird in plattformunabhängigen Bytecode kompiliert, der wiederum in plattformspezifischen Maschinencode übersetzt wird.  Der Maschinencode verwendet eine Reihe einfacher Operationen (Gates), die im Speicher ausgeführt werden.  Die für diesen Zweck verwendete Haupthardwarekomponente ist der bekannte Transistor. <br><br><img src="https://habrastorage.org/webt/8c/-6/go/8c-6goi59u27wzyytc0zvgv3ero.png"><br><br>  <i>Abb.</i>  <i>1. Übersetzung einer Programmiersprache auf hoher Ebene in Operationen, die an Transistoren ausgeführt werden</i> . <br><br>  Die in den letzten Jahren erzielte Produktivitätssteigerung wurde hauptsächlich durch die Verbesserung der Hardwaretechnologien erreicht.  Die Größe eines einzelnen Transistors hat sich drastisch verringert. Je mehr Transistoren Sie auf jeden Quadratmillimeter setzen können, desto mehr Speicher und Rechenleistung verfügt der Computer. <br><br>  Quantum Computing ist eine disruptive Technologie, da hier die einfachsten Recheneinheiten keine klassischen Transistoren sind, sondern Qubits, über die wir weiter unten sprechen werden. <br><br>  Der Punkt liegt nicht nur in den Unterschieden dieser Hauptelemente, sondern auch in einer anderen Vorrichtung von Ventilen.  Somit ist der Stapel mit Abb.  1 im Quantencomputer ist nicht anwendbar. <br><br><h4>  Wird Quantencomputer den gesamten Stapel bis auf die Java-Ebene aufteilen? </h4><br>  Kurz gesagt - "nicht wirklich".  Wissenschaftler sind sich allmählich einig, dass Quantencomputer besonders gut zur Lösung spezifischer Probleme geeignet sind, während andere Probleme mit herkömmlichen Computern rationaler gelöst werden können.  Klingt vertraut, oder?  Eine ähnliche Situation wird beim Vergleich von GPU und CPU beobachtet.  Transistoren werden zwar auch in der GPU verwendet, unterscheiden sich jedoch im Prinzip von der CPU. Viele Anwendungen, die in einer Hochsprache geschrieben sind, nutzen jedoch die Funktionen der CPU und der GPU unter der Haube.  GPUs eignen sich sehr gut für die Vektorverarbeitung, und in vielen Anwendungen und Bibliotheken unterscheidet sich die Arbeit von CPU und GPU. <br><br>  Dies ist beispielsweise genau der Fall, wenn Sie JavaFX oder Deeplearning4j verwenden.  Wenn Sie eine Benutzeroberflächenanwendung mit JavaFX schreiben, arbeiten Sie nur mit Java-Code (möglicherweise auch mit FXML, um eine Benutzeroberfläche zu deklarieren).  Wenn eine JavaFX-Szene auf dem Bildschirm angezeigt werden muss, verwenden interne JavaFX-Implementierungen Shader und Texturen, um die GPU-Treiber auf niedriger Ebene direkt zu kontaktieren (siehe Abbildung 2). Daher müssen Sie sich keine Gedanken darüber machen, welcher Teil des Codes besser für die Arbeit mit der CPU geeignet ist und welcher mit GPU. <br><br><img src="https://habrastorage.org/webt/lo/ni/um/loniumkhuuzidq5syb6z_pimfqe.png"><br><br>  <i>Abb.</i>  <i>2. JavaFX delegiert die Arbeit der GPU und der CPU.</i> <br><br>  Wie in Abb.  2, JavaFX-Implementierungscode delegiert die Arbeit, indem er an die GPU und die CPU übergeben wird.  Obwohl diese Vorgänge dem Entwickler verborgen bleiben (nicht über die API bereitgestellt), sind bestimmte Kenntnisse der GPU häufig hilfreich, wenn Sie leistungsfähigere JavaFX-Anwendungen entwickeln müssen. <br><br>  Bei Verwendung von Deeplearning4j entwickelt sich eine ähnliche Situation.  Deeplearning4j verfügt über eine Reihe von Implementierungen zum Ausführen der erforderlichen Vektor- und Matrixoperationen, von denen einige GPUs verwenden.  Für Sie als Endentwickler spielt es jedoch keine Rolle, welche Kapazitäten Ihr Code verwenden wird - CPU oder GPU. <br><br>  Es scheint, dass Quantencomputer Probleme hervorragend lösen können, die in der Regel exponentiell zunehmen, wenn das Volumen des Problems zunimmt, und daher mit klassischen Computern kaum gelöst oder fast unlösbar sind.  Experten sprechen insbesondere von einer hybriden Ausführungsform: Eine typische End-to-End-Anwendung enthält klassischen Code, der auf der CPU ausgeführt wird, kann aber auch Quantencode enthalten. <br><br><h4>  Wie kann ein System Quantencode ausführen? </h4><br>  Hardware für Quantencomputer ist heute noch äußerst experimentell.  Während große Unternehmen und vermutlich einige Staaten an der Entwicklung von Prototypen beteiligt sind, ist diese Technologie nicht allgemein verfügbar.  Aber wenn es erscheint, kann seine Form anders sein: <br><br><ul><li>  Ein Quantencoprozessor kann in die CPU im System integriert werden. </li><li>  Quantenprobleme können an Quantenwolkensysteme delegiert werden. </li></ul><br>  Obwohl nach wie vor enorme Unsicherheit über den praktischen Hintergrund solcher Entscheidungen besteht, sind wir uns zunehmend einig, wie ein Quantencode aussehen soll.  Auf der untersten Ebene sollten sich die folgenden Bausteine ​​befinden: <i>Qubits</i> und <i>Quantentore</i> .  Basierend darauf können Sie <i>Quantensimulatoren</i> erstellen, die das erwartete Verhalten implementieren. <br><br>  Ein Quantensimulator ist daher ein ideales Werkzeug für eine solche Entwicklung. <br>  Die Ergebnisse, die sie liefern, sollten fast die gleichen sein, die sie mit realen Geräten eines Quantencomputers erzielen würden - aber der Simulator arbeitet viel langsamer, da Quanteneffekte, die Quantengeräte beschleunigen, mit herkömmlicher Software simuliert werden müssen. <br><br><h4>  Was sind die Grundbausteine ​​des Quantencomputers? </h4><br>  Es ist oft wichtig, klassische Berechnungen mit Quantenberechnungen zu vergleichen.  Im klassischen Rechnen haben wir Bits und Gates. <br><br>  Ein Bit enthält ein einzelnes Informationsbit und sein Wert kann 0 oder 1 sein. <br>  Ein Ventil wirkt auf ein oder mehrere Bits und kann auf diese einwirken.  Zum Beispiel kehrt das in Abbildung 3 gezeigte NOT-Ventil den Wert eines Bits um.  Wenn der Eingang 0 ist, ist der Ausgang des NOT-Gatters 1 und umgekehrt. <br><br><img src="https://habrastorage.org/webt/si/3q/o9/si3qo9r_ri2pwgthjqdboizvbni.png"><br><br>  <i>Abb.</i>  <i>3. NICHT Ventil</i> <br><br>  Beim Quantencomputing haben wir äquivalente Bits und Gates.  Das Quantenäquivalent eines Bits ist Qubit.  Der Wert eines Qubits kann wie bei einem klassischen Bit gleich 0 oder 1 sein, er kann sich jedoch auch in der sogenannten Überlagerung befinden.  Dies ist ein komplexes Konzept, nach dem ein Qubit gleichzeitig in beiden Zuständen sein kann: 0 und 1. <br><br>  Wenn sich ein Qubit überlagert, ist sein Wert eine lineare Kombination der Zustände 0 und 1. Dies kann wie in Fig. 1 gezeigt geschrieben werden.  4: <br><br><img src="https://habrastorage.org/webt/gw/oy/o1/gwoyo19gwbizhzgmnxcix5z7kja.jpeg"><br><br>  <i>Abb.</i>  <i>4. Gleichheit, wenn sich das Qubit überlagert.</i> <br><br>  Hinweis: Qubits werden häufig in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klammern geschrieben</a> , wobei der Variablenname zwischen den Zeichen "|" steht.  und "&gt;". <br><br>  Der Ausdruck in Fig.  4 berichtet, dass sich Qubit x in einer Überlagerung der Zustände | 0&gt; und | 1&gt; befindet.  Dies bedeutet nicht, dass es sich im Zustand | 0&gt; ODER im Zustand | 1&gt; befindet;  Dies bedeutet, dass sein aktueller Zustand uns nicht bekannt ist. <br><br>  Tatsächlich befindet es sich in beiden Zuständen gleichzeitig und kann in dieser Form manipuliert werden.  Wenn wir jedoch das Qubit messen, befindet es sich in einem Zustand, entweder | 0&gt; oder | 1&gt;.  Der obige Ausdruck enthält eine weitere Einschränkung: a ^ 2 + b ^ 2 = 1. <br>  Die Werte von a und b sind probabilistisch: Es gibt eine Wahrscheinlichkeit a ^ 2, dass, wenn wir das Qubit | x&gt; messen, es den Wert | 0&gt; enthält, und die Wahrscheinlichkeit b ^ 2, dass das gemessene Qubit den Wert | 1&gt; enthält. <br><br>  Es gibt einen wichtigen begrenzenden Faktor, der die Freuden des Quantencomputers abbricht: Nachdem ein Qubit gemessen wurde, gehen alle Informationen über die mögliche Überlagerung verloren, in der es sich befand.  Der Qubit-Wert kann 0 oder 1 sein. <br><br>  In Berechnungen kann ein Qubit in Überlagerung gleichzeitig 0 und 1 entsprechen (mit unterschiedlichen Wahrscheinlichkeiten).  Wenn wir zwei Qubits haben, können sie verwendet werden, um wiederum vier Zustände (00, 01, 10 und 11) mit unterschiedlichen Wahrscheinlichkeiten darzustellen.  Hier kommen wir zum Kern der Kraft von Quantencomputern.  Mit acht klassischen Bits können Sie genau eine Zahl im Bereich von 0 bis 255 darstellen. Die Werte für jedes der acht Bits sind 0 oder 1. Mit acht Qubits können Sie alle Zahlen von 0 bis 255 gleichzeitig darstellen. <br><br><h4>  Was nützt Überlagerung, wenn Sie nur einen Zustand messen können? </h4><br>  Oft ist das Ergebnis des Algorithmus einfach (ja oder nein), aber um zu diesem Ergebnis zu gelangen, ist viel paralleles Rechnen erforderlich.  Wenn Sie Qubits während der Berechnungen überlagern, können Sie sofort viele verschiedene Optionen berücksichtigen.  Ohne Entscheidungen für jede einzelne Kombination zu treffen, kann ein Quantencomputer alle Optionen in einem Schritt berechnen. <br>  Dann beginnt in vielen Quantenalgorithmen die nächste wichtige Stufe: das Ergebnis des Algorithmus mit einer Messung zu verbinden, die ein aussagekräftiges Ergebnis liefert.  Oft wird Interferenz berücksichtigt: Interessante Ergebnisse überlagern sich strukturell, während sich uninteressante gegenseitig aufheben (destruktive Interferenz). <br><br><h4>  Wie kann man ein Qubit in einen Überlagerungszustand „umwandeln“? </h4><br>  So wie klassische Gatter Bits manipulieren, manipulieren Quantengatter Qubits.  Einige Quantentore ähneln klassischen;  Beispielsweise überträgt das Pauli-X-Gatter das Qubit vom Zustand a | 0&gt; + b | 1&gt; in den Zustand b | 0 |  + a | 1&gt;, ähnlich dem Prinzip des klassischen NOT-Gatters.  In der Tat befand sich das Qubit bei a = 1 und b = 0 zunächst im Zustand | 0&gt;.  Nach der Wirkung des Pauli-X-Ventils geht dieses Qubit in den Zustand | 1&gt; über, wie in Abb.  5. <br><br><img src="https://habrastorage.org/webt/vi/jd/np/vijdnpok8ttp8wrxzxlzkrpfv3y.png"><br><br>  <i>Abb.</i>  <i>5. Das Ergebnis der Verwendung des Pauli-X-Ventils.</i> <br><br>  In diesem Zusammenhang ist das Hadamard-Ventil sehr interessant.  Es versetzt das Qubit in den Zustand | 0&gt;: 1 / sqrt (2) * (| 0&gt; + | 1&gt;) in eine Überlagerung, wie in Abb.  6. <br><br><img src="https://habrastorage.org/webt/ms/oe/rs/msoers9oh3on6umailvyiwom8lg.png"><br><br>  <i>Abb.</i>  <i>6. Das Ergebnis der Anwendung des Hadamard-Ventils.</i> <br><br>  Nachdem wir das Hadamard-Ventil auf ein Qubit angewendet und das Qubit gemessen haben, besteht eine 50% ige Wahrscheinlichkeit, dass der Qubit-Wert 0 ist, und eine 50% ige Wahrscheinlichkeit, dass der Qubit-Wert 1 beträgt. Bis das Qubit gemessen wird, bleibt es in einem Überlagerungszustand . <br><br><h4>  Wie ist das alles möglich? </h4><br>  Wenn Sie wirklich an der Antwort auf diese Frage interessiert sind, müssen Sie die Quantenphysik im Detail studieren.  Glücklicherweise muss jedoch nicht die gesamte theoretische Grundlage dieser Phänomene verstanden werden.  Während das Phänomen der Überlagerung unverständlich erscheint, ist es wichtig zu betonen, dass es diese Eigenschaften sind, die für Elementarteilchen in der Natur charakteristisch sind.  Daher ist Quantencomputing den Grundlagen der physikalischen Realität viel näher, als es auf den ersten Blick scheint. <br><br><h4>  Soll ich ein paar Jahre warten und mir dann das Quantencomputing genauer ansehen? </h4><br>  Nein.  In diesem Fall kommen Sie zu spät.  Es ist theoretisch möglich, zuerst die Hardware zu entwickeln und dann mit dem Studium der Software-Ebene fortzufahren und zu sehen, was damit erreicht werden kann.  Alle Konzepte sind jedoch bereits mehr oder weniger klar, und es ist bereits möglich, Quantensimulatoren in gängigen Sprachen wie Java, C #, Python und anderen zu schreiben. <br>  Dann können diese Simulatoren verwendet werden, um an Quantenalgorithmen zu arbeiten.  Obwohl diese Algorithmen keine solche Leistungssteigerung bewirken, die mit ihrer Hilfe bei der Arbeit an realen Quantengeräten erreichbar ist, sollten sie funktional vollständig sein. <br><br>  Wenn Sie derzeit einen Quantenalgorithmus entwickeln, haben Sie Zeit, ihn zu verbessern, und Sie können ihn starten, wenn Quantenausrüstung im Zugriff erscheint. <br><br>  Quantenalgorithmen erfordern einen anderen intellektuellen Ansatz als klassische.  Prominente Wissenschaftler haben bereits im letzten Jahrhundert mit der Entwicklung von Quantenalgorithmen begonnen, und jetzt werden immer mehr Artikel veröffentlicht, die solche Algorithmen beschreiben, einschließlich solcher für die Ganzzahlmultiplikation, Listensuche, Pfadoptimierungsarbeit und vieles mehr. <br><br>  Es gibt andere Gründe, warum es sich heute lohnen könnte, Quantencomputer zu betreiben.  Das Refactoring eines Softwaresystems in einem modernen großen Unternehmen ist nicht eines der Dinge, die über Nacht erledigt werden können.  Einer der Bereiche, in denen Quantencomputer eine echte Revolution darstellen werden, ist die Verschlüsselung.  Schließlich basiert alles auf der Theorie, dass es auf einem klassischen Computer praktisch unmöglich ist, eine große ganze Zahl in Primfaktoren zu zerlegen. <br><br>  Obwohl es viele Jahre dauern kann, bis Quantencomputer groß genug sind, um das Problem der ganzzahligen Faktorisierung leicht zu lösen, wissen Entwickler, dass es viele Jahre dauert, Systeme zu ändern und neue, sicherere Technologien in sie einzuführen. <br><br><h4>  Wie kann ich lernen, mit Quantenalgorithmen in Java zu arbeiten? </h4><br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Strange</a> , den Open-Source-Quantencomputersimulator in Java, herunterladen und beherrschen.  Mit Strange können Sie einen Quantenalgorithmus simulieren, indem Sie eine Reihe von Qubits erstellen und mehrere Quantengatter auf sie anwenden. <br><br>  Als einfaches Beispiel erstellen wir zwei Qubits, q [0] und q [1], so dass sich anfangs beide im Zustand 0 befinden. Dann wenden wir zwei einfache Gates auf jedes der Qubits an, so dass diese Operation grafisch der Abbildung entspricht.  7. <br><br>  Das erste Qubit geht zuerst zum Pauli-X-Ventil und dann zum Hadamard-Ventil.  Das Pauli-X-Ventil überträgt es vom Zustand | 0 &amp; gt auf | 1 &amp; gt, und das Hadamard-Ventil übersetzt es in eine Überlagerung mit gleichen Wahrscheinlichkeiten | 0 &amp; gt und | 1 &amp; gt.  Wenn wir also die gesamte Sequenz 1000 Mal abschließen und das erste Qubit 1000 Mal am Ende dieses Zyklus messen, können wir im Durchschnitt erwarten, dass es in 500 Fällen einen Wert von 0 und in 500 Fällen einen Wert von 1 hat. <br><br>  Das zweite Qubit ist noch einfacher.  Wir beginnen mit dem Identitätsgatter, das das Verhalten des Qubits nicht ändert, und übergeben es dann an das Pauli-X-Gatter, wobei sein Wert von 0 auf 1 geändert wird. <br><br><img src="https://habrastorage.org/webt/wk/5t/ok/wk5tokshympqnwkvw8bj6ia6jys.png"><br><br>  <i>Abb.</i>  <i>7. Ein Beispiel für einen Quantenalgorithmus, der mit Strange simuliert werden kann.</i> <br><br>  Um sicherzustellen, dass unsere Argumentation korrekt ist, können Sie mit Strange ein einfaches Quantenprogramm erstellen. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(<span class="hljs-number"><span class="hljs-number">2</span></span>); Step s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); s.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">0</span></span>)); p.addStep(s); Step t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hadamard(<span class="hljs-number"><span class="hljs-number">0</span></span>)); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">1</span></span>)); p.addStep(t); SimpleQuantumExecutionEnvironment sqee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleQuantumExecutionEnvironment(); Result res = sqee.runProgram(p); Qubit[] qubits = res.getQubits(); Arrays.asList(qubits).forEach(q -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"qubit with probability on 1 = "</span></span>+q.getProbability()+<span class="hljs-string"><span class="hljs-string">", measured it gives "</span></span>+ q.measure())); }</code> </pre> <br>  In dieser Anwendung wird ein Quantenprogramm mit zwei Qubits erstellt: <br><br><pre> <code class="java hljs"> Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Im Rahmen dieses Programms durchlaufen wir zwei Phasen.  Wenden Sie im ersten Schritt das Pauli-X-Ventil an q [0] an.  Wir wenden das Ventil nicht auf q [1] an und implizieren daher, dass es mit dem Identitätsventil funktioniert.  Fügen Sie diesen Schritt dem Programm hinzu: <br><br><pre> <code class="java hljs"> Step s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); s.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">0</span></span>)); p.addStep(s);</code> </pre> <br>  Dann gehen wir zur zweiten Stufe, wo wir das Hadamard-Ventil auf q [0] und das Pauli-X-Ventil auf q [1] anwenden;  Fügen Sie diesen Schritt dem Programm hinzu: <br><br><pre> <code class="java hljs"> Step t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hadamard(<span class="hljs-number"><span class="hljs-number">0</span></span>)); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">1</span></span>)); p.addStep(t);</code> </pre> <br>  Unser Programm ist also fertig.  Jetzt lass es uns tun.  In Strange ist ein Quantensimulator integriert. Strange kann jedoch auch einen Cloud-Dienst verwenden, um Programme in einer Art Cloud auszuführen, z. B. in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oracle Cloud</a> . <br><br>  Im folgenden Beispiel verwenden wir einen einfachen integrierten Simulator, führen das Programm aus und erhalten die resultierenden Qubits: <br><br><pre> <code class="java hljs"> SimpleQuantumExecutionEnvironment sqee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleQuantumExecutionEnvironment(); Result res = sqee.runProgram(p); Qubit[] qubits = res.getQubits();</code> </pre> <br>  Bevor wir die Qubits messen (und alle Informationen verlieren), zeigen wir die Wahrscheinlichkeiten an.  Messen Sie nun die Qubits und sehen Sie sich die Werte an: <br><br><pre> <code class="java hljs">Arrays.asList(qubits).forEach(q -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"qubit with probability on 1 = "</span></span>+q.getProbability()+<span class="hljs-string"><span class="hljs-string">", measured it gives "</span></span>+ q.measure()));</code> </pre> <br>  Wenn Sie diese Anwendung ausführen, erhalten Sie die folgende Ausgabe: <br><br> <code>qubit with probability on 1 = 0.50, measured it gives 1 <br> qubit with probability on 1 = 1, measured it gives 1</code> <br>  Bitte beachten Sie: Für das erste Qubit kann erwartungsgemäß auch der Wert 0 gemessen werden. <br>  Wenn Sie dieses Programm mehrmals ausführen, beträgt der Wert des ersten Qubits im Durchschnitt 0 in der Hälfte der Fälle und 1 in der Hälfte der Fälle. <br><br><h4>  Ist das alles, was Sie über Quantencomputer wissen müssen? </h4><br>  Natürlich nicht.  Hier haben wir einige wichtige Konzepte nicht <i>angesprochen</i> , insbesondere die <i>Feinheiten</i> , die die Interaktion zwischen zwei Qubits sicherstellen, auch wenn sie physisch sehr weit voneinander entfernt sind, nicht erörtert.  Wir haben nicht über die bekanntesten Quantenalgorithmen gesprochen, darunter den Shore-Algorithmus, mit dem ganze Zahlen in Primfaktoren zerlegt werden können.  Wir haben auch eine Reihe von mathematischen und physikalischen Fakten ignoriert, insbesondere nicht berücksichtigt, dass in der Überlagerung | x&gt; = a | 0&gt; + b | 1&gt; beide Zahlen a und b komplex sein können. <br><br>  Der Hauptzweck dieses Artikels war es jedoch, Ihnen den Eindruck von Quantencomputern zu vermitteln und zu verstehen, wie sie in die Zukunft der Softwareentwicklung passen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450480/">https://habr.com/ru/post/de450480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450468/index.html">Spiele zu machen ist [nicht] schwer. Rückblick auf ein kleines mobiles Projekt auf Unity3D</a></li>
<li><a href="../de450472/index.html">Wie erstelle ich eine perfekte Roadmap?</a></li>
<li><a href="../de450474/index.html">Python-Einführung</a></li>
<li><a href="../de450476/index.html">Wie wir ein Unternehmen in der EU registriert haben</a></li>
<li><a href="../de450478/index.html">Heutzutage funktionieren viele beliebte Add-Ons für Firefox aufgrund von Zertifikatsproblemen nicht mehr.</a></li>
<li><a href="../de450484/index.html">Website-Animationsleistung</a></li>
<li><a href="../de450486/index.html">9. Check Point Erste Schritte R80.20. Anwendungssteuerung und URL-Filterung</a></li>
<li><a href="../de450488/index.html">Chock Norris Fakten Android App auf Kotlin</a></li>
<li><a href="../de450490/index.html">6,9-Milliarden-Dollar-Deal: Warum kauft ein GPU-Entwickler einen Netzwerkgerätehersteller?</a></li>
<li><a href="../de450492/index.html">Sozialarbeit und offenes Design. Einführung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>