<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ ğŸ—» ğŸ›€ğŸ½ Pengalaman pertama saya memulihkan database Postgres setelah kerusakan (halaman tidak valid di blok 4123007 dari relatton base / 16490) ğŸ§˜ğŸ» ğŸ•Ÿ ğŸ‘©ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin berbagi dengan Anda pengalaman sukses pertama saya dalam memulihkan fungsionalitas penuh dari database Postgres. Saya bertemu Postgres DBMS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman pertama saya memulihkan database Postgres setelah kerusakan (halaman tidak valid di blok 4123007 dari relatton base / 16490)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477248/"> Saya ingin berbagi dengan Anda pengalaman sukses pertama saya dalam memulihkan fungsionalitas penuh dari database Postgres.  Saya bertemu Postgres DBMS setengah tahun yang lalu, sebelum itu saya tidak punya pengalaman administrasi database sama sekali. <br><br><img src="https://habrastorage.org/webt/zf/35/tb/zf35tb0kz_lvnsdbyagxaueaffy.jpeg"><br><br>  Saya bekerja sebagai insinyur semi-DevOps di sebuah perusahaan IT besar.  Perusahaan kami mengembangkan perangkat lunak untuk layanan yang sangat dimuat, tetapi saya bertanggung jawab atas kinerja, pemeliharaan, dan penyebaran.  Mereka menetapkan tugas standar untuk saya: memperbarui aplikasi pada satu server.  Aplikasi ini ditulis dalam Django, selama upgrade, migrasi dilakukan (mengubah struktur basis data), dan sebelum proses ini kami menghapus dump basis data lengkap melalui program pg_dump standar untuk berjaga-jaga. <br><br>  Terjadi kesalahan tak terduga saat menghapus dump (versi Postgres 9.5): <br><br><pre><code class="plaintext hljs">pg_dump: Oumping the contents of table â€œws_log_smevlogâ€ failed: PQgetResult() failed. pg_dump: Error message from server: ERROR: invalid page in block 4123007 of relatton base/16490/21396989 pg_dump: The command was: COPY public.ws_log_smevlog [...] pg_dunp: [parallel archtver] a worker process dled unexpectedly</code> </pre> <br>  Kesalahan <i>"halaman tidak sah di blok"</i> menunjukkan masalah pada tingkat sistem file, yang sangat buruk.  Di berbagai forum, mereka menyarankan membuat <i>FULL</i> <i>VACUUM</i> dengan opsi <i>zero_damaged_pages</i> untuk menyelesaikan masalah ini.  Baiklah, popprobeum ... <br><a name="habracut"></a><br><h4>  Persiapan Pemulihan </h4><br>  <b>PERHATIAN!</b>  Pastikan untuk mencadangkan Postgres sebelum upaya memulihkan database.  Jika Anda memiliki mesin virtual, hentikan basis data dan ambil snapshot.  Jika tidak dimungkinkan untuk mengambil snapshot, hentikan database dan salin isi direktori Postgres (termasuk file wal) ke tempat yang aman.  Hal utama dalam bisnis kami bukanlah untuk memperburuk keadaan.  Baca <a href="https://wiki.postgresql.org/wiki/Corruption">ini</a> . <br><br>  Karena database bekerja untuk saya secara keseluruhan, saya membatasi diri pada dump database biasa, tetapi mengecualikan tabel dengan data yang rusak (opsi <i>-T, --exclude-table = TABLE</i> di pg_dump). <br><br>  Server bersifat fisik, tidak mungkin untuk mengambil snapshot.  Cadangan dihapus, lanjutkan. <br><br><h4>  Pemeriksaan sistem file </h4><br>  Sebelum mencoba mengembalikan database, Anda perlu memastikan bahwa semuanya sesuai dengan sistem file itu sendiri.  Dan jika terjadi kesalahan, perbaiki, karena jika tidak, Anda hanya dapat memperburuknya. <br><br>  Dalam kasus saya, sistem file dengan database dipasang di <i>"/ srv"</i> dan jenisnya adalah ext4. <br><br>  Kami menghentikan basis data: <i>systemctl menghentikan postgresql@9.5-main.service</i> dan memeriksa apakah sistem file tidak digunakan oleh siapa pun dan dapat dilepas menggunakan <i>perintah lsof</i> : <br>  <i>lsof + D / srv</i> <br><br>  Saya masih harus menghentikan database redis, karena juga menggunakan <i>"/ srv"</i> .  Selanjutnya, saya melepas <i>/ srv</i> (umount). <br><br>  Memeriksa sistem file dilakukan menggunakan utilitas <i>e2fsck</i> dengan opsi -f ( <i>Paksa memeriksa bahkan jika sistem file ditandai bersih</i> ): <br><br><img src="https://habrastorage.org/webt/8_/zj/d_/8_zjd_jjdoiq_kg_qgndbq3mjpm.png"><br><br>  Selanjutnya, dengan menggunakan utilitas <i>dumpe2fs</i> ( <i>sudo dumpe2fs / dev / mapper / gu2 - sys-srv | grep dicentang</i> ), Anda dapat memverifikasi bahwa pemeriksaan memang dilakukan: <br><br><img src="https://habrastorage.org/webt/i7/on/oe/i7onoelytrz8ihbjndgqrmkn37i.png"><br><br>  <i>e2fsck</i> mengatakan bahwa tidak ada masalah yang ditemukan pada tingkat sistem file ext4, yang berarti bahwa Anda dapat terus mencoba mengembalikan database, atau lebih tepatnya kembali ke <i>vakum penuh</i> (tentu saja, Anda perlu me-mount sistem file kembali dan memulai database). <br><br>  Jika server Anda fisik, pastikan untuk memeriksa status disk (via <i>smartctl -a / dev / XXX</i> ) atau pengontrol RAID untuk memastikan bahwa masalahnya bukan pada tingkat perangkat keras.  Dalam kasus saya, RAID ternyata "besi", jadi saya meminta administrator lokal untuk memeriksa status RAID (server beberapa ratus kilometer dari saya).  Dia mengatakan bahwa tidak ada kesalahan, yang berarti bahwa kita pasti dapat memulai pemulihan. <br><br><h4>  Percobaan 1: zero_damaged_pages </h4><br>  Kami terhubung ke database melalui akun psql dengan hak pengguna super.  Kami membutuhkan superuser, karena  hanya dia yang bisa mengubah opsi <i>zero_damaged_pages</i> .  Dalam kasus saya, ini postgres: <br><br>  <i>psql -h 127.0.0.1 -U postgres -s [database_name]</i> <br><br>  Opsi <i>zero_damaged_pages</i> diperlukan untuk mengabaikan kesalahan baca (dari situs postgrespro): <br><blockquote>  Ketika judul halaman yang rusak terdeteksi, Postgres Pro biasanya melaporkan kesalahan dan membatalkan transaksi saat ini.  Jika parameter zero_damaged_pages diaktifkan, sebagai gantinya, sistem mengeluarkan peringatan, membersihkan halaman yang rusak dalam memori, dan melanjutkan pemrosesan.  Perilaku ini menghancurkan data, yaitu semua baris di halaman yang rusak. </blockquote>  Aktifkan opsi dan coba buat tabel vakum penuh: <br><br><pre> <code class="plaintext hljs">VACUUM FULL VERBOSE</code> </pre> <br><img src="https://habrastorage.org/webt/ft/ym/m1/ftymm1cwyqwpdunlfmecfa1seas.png"><br>  Sayangnya, kegagalan. <br><br>  Kami mengalami kesalahan serupa: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "â€œpublic.ws_log_smevlogâ€ WARNING: invalid page in block 4123007 of relation base/16400/21396989; zeroing out page ERROR: unexpected chunk number 573 (expected 565) for toast value 21648541 in pg_toast_106070</code> </pre> <br>  <i><a href="https://postgrespro.ru/docs/postgrespro/9.5/storage-toast">pg_toast</a></i> - mekanisme untuk menyimpan "data panjang" di Postgres, jika tidak cocok di halaman yang sama (8kb secara default). <br><br><h4>  Percobaan 2: indeks ulang </h4><br>  Kiat google pertama tidak membantu.  Setelah beberapa menit mencari, saya menemukan tip kedua - untuk membuat <i>reindex menjadi</i> tabel yang rusak.  Saya bertemu saran ini di banyak tempat, tetapi itu tidak menginspirasi kepercayaan.  Buat pengindeksan ulang: <br><br><pre> <code class="plaintext hljs">reindex table ws_log_smevlog</code> </pre> <br><img src="https://habrastorage.org/webt/km/kx/ny/kmkxnywf16bm7hywt5wu-zchofq.png"><br><br>  <i>Reindex</i> selesai tanpa masalah. <br><br>  Namun, ini tidak membantu, <i>VACUUM FULL</i> jatuh dengan kesalahan yang sama.  Karena saya terbiasa dengan kegagalan, saya mulai mencari saran di Internet lebih jauh dan menemukan <a href="https://newbiedba.wordpress.com/2015/07/07/postgresql-missing-chunk-0-for-toast-value-in-pg_toast/">artikel yang</a> agak menarik. <br><br><h4>  Percobaan 3: PILIH, BATAS, OFFSET </h4><br>  Artikel di atas menyarankan melihat baris demi baris tabel dan menghapus data yang bermasalah.  Untuk memulai, perlu untuk melihat semua baris: <br><br><pre> <code class="plaintext hljs">for ((i=0; i&lt;"Number_of_rows_in_nodes"; i++ )); do psql -U "Username" "Database Name" -c "SELECT * FROM nodes LIMIT 1 offset $i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Dalam kasus saya, tabel tersebut berisi <i>1.628.991</i> baris!  Dalam cara yang baik, perlu untuk <a href="https://postgrespro.ru/docs/postgresql/10/ddl-partitioning">mempartisi data</a> , tetapi ini adalah topik untuk diskusi terpisah.  Saat itu hari Sabtu, saya menjalankan perintah ini dalam tmux dan pergi tidur: <br><br><pre> <code class="plaintext hljs">for ((i=0; i&lt;1628991; i++ )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog LIMIT 1 offset $i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Pada pagi hari, saya memutuskan untuk memeriksa keadaan.  Yang mengejutkan saya, saya menemukan bahwa dalam 2 jam hanya 2% dari data yang dipindai!  Saya tidak ingin menunggu 50 hari.  Kegagalan total lainnya. <br><br>  Tapi saya tidak menyerah.  Saya bertanya-tanya mengapa pemindaian begitu lama.  Dari dokumentasi (lagi di postgrespro) saya menemukan: <br><blockquote>  OFFSET menunjukkan untuk melewati jumlah baris yang ditentukan sebelum mulai menghasilkan garis. <br>  Jika kedua OFFSET dan LIMIT ditentukan, sistem pertama-tama akan melompati garis OFFSET dan kemudian mulai menghitung garis untuk membatasi LIMIT. <br><br>  Saat menggunakan LIMIT, juga penting untuk menggunakan klausa ORDER BY sehingga garis hasil dikembalikan dalam urutan tertentu.  Jika tidak, himpunan bagian string yang tidak dapat diprediksi akan dikembalikan. </blockquote>  Jelas, perintah di atas salah: pertama, tidak ada <i>perintah</i> , hasilnya bisa salah.  Kedua, Postgres pertama harus memindai dan melewati garis OFFSET, dan dengan peningkatan <i>OFFSET,</i> kinerja akan semakin berkurang. <br><br><h4>  Percobaan 4: hapus dump dalam bentuk teks </h4><br>  Selanjutnya, sebuah ide yang tampaknya cemerlang muncul di benak saya: untuk menghapus dump dalam bentuk teks dan menganalisis baris yang terakhir direkam. <br><br>  Tapi pertama-tama, <i>mari kita</i> lihat <i>struktur</i> tabel <i>ws_log_smevlog</i> : <br><br><img src="https://habrastorage.org/webt/hv/_u/qk/hv_uqkxblnoxsivawvjrwepqyz8.png"><br><br>  Dalam kasus kami, kami memiliki kolom <i>"id"</i> , yang berisi pengidentifikasi unik (penghitung) untuk baris.  Rencananya adalah ini: <br><br><ol><li>  Kami mulai menghapus dump dalam bentuk teks (dalam bentuk perintah sql) </li><li>  Pada titik waktu tertentu, dump akan terganggu karena kesalahan, tetapi file teks akan tetap disimpan di disk </li><li>  Kami melihat di akhir file teks, dengan demikian kami menemukan pengidentifikasi (id) dari baris terakhir yang berhasil ditembak </li></ol><br>  Saya mulai menghapus dump dalam bentuk teks: <br><br><pre> <code class="plaintext hljs">pg_dump -U my_user -d my_database -F p -t ws_log_smevlog -f ./my_dump.dump</code> </pre> <br>  Tempat pembuangan sampah, seperti yang diharapkan, terputus dengan kesalahan yang sama: <br><br><pre> <code class="plaintext hljs">pg_dump: Error message from server: ERROR: invalid page in block 4123007 of relatton base/16490/21396989</code> </pre> <br>  Selanjutnya, melalui <i>ekor,</i> saya melihat ujung dump ( <i>tail -5 ./my_dump.dump</i> ) dan menemukan bahwa dump terputus pada baris dengan id <i>186 525</i> .  "Jadi, masalahnya ada di baris dengan id 186 526, rusak, dan perlu dihapus!" Saya pikir.  Tetapi dengan membuat permintaan ke database: <br>  " <i>Pilih * dari ws_log_smevlog di mana id = 186529</i> " ternyata semuanya baik-baik saja dengan baris ini ... Baris dengan indeks 186 530 - 186 540 juga bekerja tanpa masalah.  â€œIde cemerlangâ€ lain gagal.  Kemudian, saya mengerti mengapa ini terjadi: ketika menghapus / mengubah data dari tabel, mereka tidak dihapus secara fisik, tetapi ditandai sebagai "tupel mati", kemudian <i>autovacuum</i> datang dan menandai garis-garis ini sebagai dihapus dan memungkinkan penggunaan garis-garis ini lagi.  Untuk memahami, jika data dalam tabel diubah dan autovacuum dihidupkan, maka mereka tidak disimpan secara berurutan. <br><br><h4>  Percobaan 5: PILIH, DARI, DI MANA id = </h4><br>  Kegagalan membuat kita lebih kuat.  Anda tidak boleh menyerah, Anda harus pergi sampai akhir dan percaya pada diri sendiri dan kemampuan Anda.  Oleh karena itu, saya memutuskan untuk mencoba satu opsi lagi: cukup lihat semua entri dalam database satu per satu.  Mengetahui struktur tabel saya (lihat di atas), kami memiliki bidang id yang unik (kunci utama).  Dalam tabel, kami memiliki 1.628.991 baris dan <i>id</i> berjalan berurutan, yang berarti bahwa kami dapat mengulanginya satu per satu: <br><br><pre> <code class="plaintext hljs">for ((i=1; i&lt;1628991; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Jika seseorang tidak mengerti, perintahnya berfungsi sebagai berikut: ia memindai baris demi baris tabel dan mengirimkan stdout ke <i>/ dev / null</i> , tetapi jika perintah SELECT gagal, teks kesalahan ditampilkan (stderr dikirim ke konsol) dan baris yang mengandung kesalahan adalah output (terima kasih kepada ||, yang berarti bahwa pilih memiliki masalah (kode pengembalian perintah bukan 0)). <br><br>  Saya beruntung, saya membuat indeks di bidang <i>id</i> : <br><br><img src="https://habrastorage.org/webt/k2/yf/tp/k2yftpsxvdq0rtcq_vvrscn0xoq.png"><br><br>  Ini berarti bahwa menemukan garis dengan id yang diinginkan tidak perlu banyak waktu.  Secara teori, itu harus bekerja.  Nah, jalankan perintah di <i>tmux</i> dan pergi tidur. <br><br>  Pada pagi hari, saya menemukan bahwa sekitar 90.000 catatan telah ditonton, yang hanya lebih dari 5%.  Hasil luar biasa bila dibandingkan dengan metode sebelumnya (2%)!  Tapi saya tidak mau menunggu 20 hari ... <br><br><h4>  Percobaan 6: PILIH, DARI, DI MANA id&gt; = dan id &lt; </h4><br>  Server yang sangat baik dialokasikan untuk pelanggan di bawah basis data: prosesor ganda <i>Intel Xeon E5-2697 v2</i> , di lokasi kami ada sebanyak 48 utas!  Server memuat rata-rata, kami dapat mengambil sekitar 20 utas tanpa masalah.  RAM-nya juga cukup: sebanyak 384 gigabyte! <br><br>  Karena itu, perintah perlu diparalelkan: <br><br><pre> <code class="plaintext hljs">for ((i=1; i&lt;1628991; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Di sini dimungkinkan untuk menulis skrip yang indah dan elegan, tetapi saya memilih cara tercepat untuk memparalelkan: memecah secara manual kisaran 0-1628991 ke dalam interval 100.000 catatan dan menjalankan 16 perintah formulir secara terpisah: <br><br><pre> <code class="plaintext hljs">for ((i=N; i&lt;M; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done</code> </pre> <br>  Tapi itu belum semuanya.  Secara teori, menghubungkan ke database juga membutuhkan waktu dan sumber daya sistem.  Menghubungkan 1.628.991 tidak terlalu masuk akal, setuju.  Karena itu, mari kita ekstrak 1000 baris dalam satu koneksi, bukan satu.  Akibatnya, tim berubah menjadi ini: <br><br><pre> <code class="plaintext hljs">for ((i=N; i&lt;M; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done</code> </pre> <br>  Buka 16 jendela di sesi tmux dan jalankan perintah: <br><blockquote><pre> <code class="plaintext hljs">1) for ((i=0; i&lt;100000; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done 2) for ((i=100000; i&lt;200000; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done â€¦ 15) for ((i=1400000; i&lt;1500000; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done 16) for ((i=1500000; i&lt;1628991; i=$((i+1000)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id&gt;=$i and id&lt;$((i+1000))" &gt;/dev/null || echo $i; done</code> </pre> </blockquote>  Sehari kemudian, saya mendapat hasil pertama!  Yaitu (nilai XXX dan ZZZ belum dipertahankan): <br><br><pre> <code class="plaintext hljs">ERROR: missing chunk number 0 for toast value 37837571 in pg_toast_106070 829000 ERROR: missing chunk number 0 for toast value XXX in pg_toast_106070 829000 ERROR: missing chunk number 0 for toast value ZZZ in pg_toast_106070 146000</code> </pre> <br>  Ini berarti bahwa kami memiliki tiga baris yang mengandung kesalahan.  id dari catatan masalah pertama dan kedua adalah antara 829.000 dan 830.000, id yang ketiga adalah antara 146.000 dan 147.000. Selanjutnya, kita hanya harus menemukan nilai id yang tepat dari catatan masalah.  Untuk melakukan ini, lihat rentang kami dengan catatan masalah di langkah 1 dan identifikasi id: <br><blockquote><pre> <code class="plaintext hljs">for ((i=829000; i&lt;830000; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done 829417 ERROR: unexpected chunk number 2 (expected 0) for toast value 37837843 in pg_toast_106070 829449 for ((i=146000; i&lt;147000; i=$((i+1)) )); do psql -U my_user -d my_database -c "SELECT * FROM ws_log_smevlog where id=$i" &gt;/dev/null || echo $i; done 829417 ERROR: unexpected chunk number ZZZ (expected 0) for toast value XXX in pg_toast_106070 146911</code> </pre> </blockquote><h4>  Selamat berakhir </h4><br>  Kami menemukan jalur yang bermasalah.  Kami masuk ke database melalui psql dan mencoba untuk menghapusnya: <br><br><pre> <code class="plaintext hljs">my_database=# delete from ws_log_smevlog where id=829417; DELETE 1 my_database=# delete from ws_log_smevlog where id=829449; DELETE 1 my_database=# delete from ws_log_smevlog where id=146911; DELETE 1</code> </pre> <br>  Yang mengejutkan saya, entri itu dihapus tanpa masalah, bahkan tanpa opsi <i>zero_damaged_pages</i> . <br><br>  Kemudian saya terhubung ke database, membuat <i>VACUUM FULL</i> (saya pikir itu tidak perlu dilakukan), dan akhirnya berhasil menghapus cadangan menggunakan <i>pg_dump</i> .  Tumpukan ini membintangi tanpa kesalahan!  Masalahnya dipecahkan dengan cara yang sangat bodoh.  Tidak ada batas kegembiraan, setelah begitu banyak kegagalan kami berhasil menemukan solusi! <br><br><h4>  Ucapan Terima Kasih dan Kesimpulan </h4><br>  Ini adalah pengalaman pertama saya dalam memulihkan database Postgres nyata.  Saya akan mengingat pengalaman ini untuk waktu yang lama. <br><br>  Dan akhirnya, saya ingin mengucapkan terima kasih kepada PostgresPro untuk dokumentasi yang diterjemahkan ke dalam bahasa Rusia dan untuk <a href="https://postgrespro.ru/education/courses/DBA1">kursus online gratis</a> yang telah banyak membantu selama analisis masalah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477248/">https://habr.com/ru/post/id477248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477234/index.html">Tikus yang mengakhiri saudara kawat</a></li>
<li><a href="../id477236/index.html">Pengadilan A.S. memungkinkan negara untuk mengembalikan netralitas bersih</a></li>
<li><a href="../id477238/index.html">Plus untuk Karma: Apa Stack Overflow Dikritik untuk dan Mengapa Banyak Mengeluh tentang Keracunan Komunitas</a></li>
<li><a href="../id477242/index.html">Bagaimana kami memilih ServiceDesk. Bagian 3</a></li>
<li><a href="../id477244/index.html">Dimengerti RayTracing dalam 256 baris telanjang C ++</a></li>
<li><a href="../id477250/index.html">Jadi Anda ingin menjalankan Windows 10 pada kalkulator? Baiklah</a></li>
<li><a href="../id477252/index.html">Bagaimana Inkubator dan Akselerator Bisnis Berkembang: Dari Laboratorium Thomas Edison ke Y Combinator</a></li>
<li><a href="../id477254/index.html">Otentikasi XSS, CSRF, dan Flash. Pemecahan masalah dengan r0ot-mi Web - Client. Bagian 2</a></li>
<li><a href="../id477256/index.html">Peluncuran OneWeb penuh pertama pada kendaraan peluncuran Soyuz ditunda tahun depan, serta peluncuran kendaraan peluncuran Angara</a></li>
<li><a href="../id477262/index.html">Android dari perusahaan Promobot. Tampak samping</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>