<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§—ğŸ½ ğŸ‘‘ ğŸ‘¼ğŸ¿ Fungsi tanda panah JavaScript: mengapa diperlukan, cara menanganinya, kapan menggunakannya, dan kapan tidak ğŸ¤¶ğŸ» ğŸ¥” ğŸ›Œ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu inovasi paling penting dari JavaScript modern adalah penampilan fungsi panah, yang kadang-kadang disebut fungsi panah "gemuk". Ketika mende...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fungsi tanda panah JavaScript: mengapa diperlukan, cara menanganinya, kapan menggunakannya, dan kapan tidak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428566/"> Salah satu inovasi paling penting dari JavaScript modern adalah penampilan fungsi panah, yang kadang-kadang disebut fungsi panah "gemuk".  Ketika mendeklarasikan fungsi tersebut, mereka menggunakan kombinasi karakter khusus - <code>=&gt;</code> . <br><br>  Fungsi panah memiliki dua keunggulan utama dibandingkan fungsi tradisional.  Yang pertama adalah sintaks yang sangat nyaman dan kompak.  Yang kedua adalah bahwa pendekatan untuk bekerja dengan <code>this</code> dalam fungsi panah terlihat lebih intuitif daripada fungsi biasa. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/b1a/09a/721/b1a09a721fe985d3700f4f74305e68d6.jpg" alt="gambar"></a> </div><br>  Kadang-kadang ini dan keuntungan lainnya mengarah pada fakta bahwa sintaks panah diberikan preferensi tanpa syarat daripada cara lain untuk mendeklarasikan fungsi.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konfigurasi eslint</a> populer dari pasukan Airbnb yang setiap kali fungsi anonim dibuat, fungsi seperti itu akan seperti panah. <br><br>  Namun, seperti konsep dan mekanisme lain yang digunakan dalam pemrograman, fungsi panah memiliki kelebihan dan kelemahannya.  Penggunaannya dapat menyebabkan efek samping negatif.  Untuk menggunakan fungsi panah dengan benar, Anda perlu tahu tentang kemungkinan masalah yang terkait dengannya. <br><br>  Materi, terjemahan yang kami terbitkan hari ini, akan fokus pada bagaimana fungsi panah bekerja.  Di sini kita akan mempertimbangkan situasi di mana penggunaannya dapat meningkatkan kode, dan situasi di mana mereka tidak boleh digunakan. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fitur fungsi panah dalam JavaScript</font> </h2><br>  Fungsi panah dalam JavaScript adalah sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi lambda</a> di Python dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blok</a> di Ruby. <br><br>  Ini adalah fungsi anonim dengan sintaks khusus yang mengambil sejumlah argumen dan bekerja dalam konteks ruang lingkup yang memasukkannya, yaitu, dalam konteks fungsi atau kode lain di mana mereka dideklarasikan. <br><br>  Mari kita bicarakan ini secara lebih rinci. <br><br><h3>  <font color="#3AC1EF">â– Fungsi panah sintaks</font> </h3><br>  Fungsi panah dibangun sesuai dengan skema tunggal, sementara struktur fungsi dapat, dalam kasus khusus, disederhanakan.  Struktur dasar dari fungsi panah terlihat seperti ini: <br><br><pre> <code class="hljs php">(argument1, argument2, ... argumentN) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br>  Daftar argumen fungsi adalah dalam tanda kurung, diikuti oleh panah yang terdiri dari <code>=</code> dan <code>&gt;</code> karakter, dan kemudian muncul tubuh fungsi di kurung kurawal. <br><br>  Ini sangat mirip dengan cara kerja fungsi biasa, perbedaan utamanya adalah bahwa kata kunci <code>function</code> dihilangkan di sini dan panah ditambahkan setelah daftar argumen. <br><br>  Namun, dalam kasus tertentu, fungsi panah sederhana dapat dideklarasikan menggunakan konstruksi yang jauh lebih ringkas. <br><br>  Pertimbangkan sintaks yang digunakan jika tubuh fungsi diwakili oleh satu ekspresi.  Ini memungkinkan Anda melakukan tanpa kurung keriting yang membingkai tubuh fungsi, dan menghilangkan kebutuhan untuk secara eksplisit mengembalikan hasil evaluasi ekspresi, karena hasil ini akan dikembalikan secara otomatis.  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b;</code> </pre> <br>  Berikut ini varian lain dari notasi fungsi yang disingkat, yang digunakan ketika fungsi tersebut hanya memiliki satu argumen. <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFirst = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Seperti yang Anda lihat, tanda kurung di sekitar daftar argumen dihilangkan di sini.  Selain itu, badan fungsi, yang dalam contoh ini diwakili oleh satu perintah, juga ditulis tanpa tanda kurung.  Nanti kita akan berbicara lebih banyak tentang manfaat desain tersebut. <br><br><h3>  <font color="#3AC1EF">â–Kembalikan objek dan fungsi panah rekam pendek</font> </h3><br>  Ketika bekerja dengan fungsi panah, beberapa konstruksi sintaks yang lebih kompleks juga digunakan, yang berguna untuk diperhatikan. <br><br>  Misalnya, coba gunakan ekspresi garis tunggal untuk kembali dari fungsi literal objek.  Tampaknya, mengingat apa yang sudah kita ketahui tentang fungsi panah, deklarasi fungsi akan terlihat seperti ini: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description};</code> </pre> <br>  Masalah dengan kode ini adalah ambiguitasnya.  Yaitu, kurung kurawal yang ingin kita gunakan untuk menggambarkan objek tampak literal seperti kita mencoba untuk melampirkan tubuh fungsi di dalamnya. <br><br>  Untuk menunjukkan ke sistem yang kami maksud objek literal, kita harus melampirkannya dalam tanda kurung: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; ({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description});</code> </pre> <br><h3>  <font color="#3AC1EF">â– Fungsi panah dan konteks pelaksanaannya</font> </h3><br>  Tidak seperti fungsi lainnya, fungsi panah tidak memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konteks eksekusi</a> sendiri. <br><br>  Dalam praktiknya, ini berarti bahwa mereka mewarisi entitas <code>this</code> dan <code>arguments</code> dari fungsi induk. <br><br>  Misalnya, bandingkan dua fungsi yang disajikan dalam kode berikut.  Salah satunya biasa, yang kedua adalah panah. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'test object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">createAnonFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; }, <span class="hljs-attr"><span class="hljs-attr">createArrowFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; } };</code> </pre> <br>  Ada objek <code>test</code> dengan dua metode.  Masing-masing dari mereka adalah fungsi yang membuat dan mengembalikan fungsi anonim.  Perbedaan antara metode-metode ini adalah hanya di pertama mereka ekspresi fungsional tradisional digunakan, dan dalam fungsi panah kedua. <br><br>  Jika kita bereksperimen dengan kode ini di konsol, meneruskan argumen yang sama ke metode objek, maka meskipun metode tersebut terlihat sangat mirip, kita akan mendapatkan hasil yang berbeda: <br><br><pre> <code class="hljs cs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anon = test.createAnonFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrow = test.createArrowFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; anon(); undefined {} &gt; arrow(); test <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'world'</span></span> }</code> </pre> <br>  Fungsi anonim memiliki konteksnya sendiri, jadi ketika dipanggil, saat Anda memanggil <code>test.name</code> , nilai properti <code>name</code> objek tidak akan <code>test.name</code> , dan saat Anda memanggil <code>arguments</code> , daftar argumen untuk fungsi yang digunakan untuk membuat dan mengembalikan fungsi yang sedang diselidiki tidak akan ditampilkan. <br><br>  Dalam kasus fungsi panah, ternyata konteksnya bertepatan dengan konteks fungsi yang membuatnya, yang memberikan akses ke daftar argumen yang dilewati oleh fungsi ini dan properti <code>name</code> objek yang fungsi tersebut merupakan metode. <br><br><h2>  <font color="#3AC1EF">Situasi di mana fungsi panah meningkatkan kode</font> </h2><br><h3>  <font color="#3AC1EF">â–Mengolah daftar nilai</font> </h3><br>  Fungsi lambda tradisional, serta fungsi panah, setelah muncul dalam JavaScript, biasanya digunakan dalam situasi di mana fungsi tertentu diterapkan ke setiap elemen daftar tertentu. <br><br>  Misalnya, jika ada array nilai yang perlu dikonversi menggunakan metode array <code>map</code> , fungsi panah sangat ideal untuk menggambarkan konversi seperti itu: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> words = [<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'WORLD'</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> downcasedWords = words.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function"> =&gt;</span></span> word.toLowerCase());</code> </pre> <br>  Berikut adalah contoh yang sangat umum dari penggunaan fungsi panah yang serupa, yang terdiri dari bekerja dengan properti objek: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = objects.map(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>);</code> </pre> <br>  Demikian pula, jika alih-alih tradisional <code>for</code> loop mereka menggunakan <code>forEach</code> loop modern berbasis iterator, maka fungsi panah menggunakan <code>this</code> entitas induk, membuat penggunaannya intuitif: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.examples.forEach(example =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runExample(example); });</code> </pre> <br><h3>  <font color="#3AC1EF">â– Janji dan rantai janji</font> </h3><br>  Situasi lain di mana fungsi panah memungkinkan Anda untuk menulis kode yang lebih bersih dan lebih mudah dipahami diwakili oleh konstruksi perangkat lunak asinkron. <br><br>  Jadi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">janji</a> sangat menyederhanakan pekerjaan dengan kode asinkron.  Pada saat yang sama, bahkan jika Anda lebih suka menggunakan async / menunggu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruksi,</a> Anda tidak dapat melakukannya tanpa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memahami janji-janji</a> , karena konstruksi ini didasarkan pada mereka. <br><br>  Namun, saat menggunakan janji, Anda harus mendeklarasikan fungsi yang dipanggil setelah penyelesaian kode asinkron atau penyelesaian panggilan asinkron ke API tertentu. <br><br>  Ini adalah tempat yang ideal untuk menggunakan fungsi panah, terutama jika fungsi yang dihasilkan memiliki keadaan tertentu, mengacu pada sesuatu di objek.  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomethingAsync().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storeResult(result); });</code> </pre> <br><h3>  <font color="#3AC1EF">â– Transformasi Objek</font> </h3><br>  Kasus penggunaan umum lainnya untuk fungsi panah adalah untuk mengenkapsulasi transformasi objek. <br><br>  Sebagai contoh, di Vue.js, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola</a> umum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk</a> menyertakan fragmen penyimpanan Vuex secara langsung dalam komponen Vue menggunakan <code>mapState</code> . <br><br>  Operasi ini mencakup deklarasi seperangkat "konverter" yang memilih dengan tepat apa yang diperlukan untuk komponen tertentu dari keadaan penuh awal. <br><br>  Transformasi sederhana ini adalah tempat yang tepat untuk menggunakan fungsi panah.  Sebagai contoh: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">computed</span></span>: {   ...<span class="hljs-built_in"><span class="hljs-built_in">mapState</span></span>({     results: state =&gt; state.results,     users: state =&gt; state.users,   }); } }</code> </pre> <br><h2>  <font color="#3AC1EF">Situasi di mana fungsi panah tidak boleh digunakan</font> </h2><br><h3>  <font color="#3AC1EF">â– Metode objek</font> </h3><br>  Ada beberapa situasi di mana menggunakan fungsi panah bukan ide yang baik.  Fungsi panah, jika digunakan dengan ringan, tidak hanya tidak membantu programmer, tetapi juga menjadi sumber masalah. <br><br>  Situasi seperti pertama adalah menggunakan fungsi panah sebagai metode objek.  Konteks eksekusi dan <code>this</code> , khusus untuk fungsi tradisional, adalah penting di sini. <br><br>  Pada suatu waktu, itu populer untuk menggunakan kombinasi properti kelas dan fungsi panah untuk membuat metode dengan "penjilidan otomatis", yaitu yang dapat digunakan oleh penangan acara, tetapi tetap terikat pada kelas.  Itu terlihat seperti ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre> <br>  Menggunakan konstruksi yang serupa, bahkan jika fungsi <code>handleClick</code> dipanggil oleh event handler, dan tidak dalam konteks instance kelas <code>Counter</code> , fungsi ini memiliki akses ke data instance ini. <br><br>  Namun, pendekatan ini memiliki banyak kekurangan dimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi ini</a> dikhususkan. <br><br>  Meskipun penggunaan fungsi panah di sini, tentu saja, adalah cara yang mudah untuk mengikat fungsi, perilaku fungsi ini dalam banyak aspek jauh dari intuitif, mengganggu pengujian dan menciptakan masalah dalam situasi di mana, misalnya, mereka mencoba menggunakan objek yang sesuai sebagai prototipe. <br><br>  Dalam kasus seperti itu, alih-alih fungsi panah, gunakan fungsi biasa, dan, jika perlu, ikat ke mereka contoh objek di konstruktor: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Counter <span class="hljs-comment"><span class="hljs-comment">{ counter = 0; handleClick() {   this.counter++; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.handleClick = this.handleClick.bind(this); }</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">â–Panggilan panjang</font> </h3><br>  Fungsi panah dapat menjadi sumber masalah jika direncanakan untuk digunakan dalam banyak kombinasi berbeda, khususnya, dalam rangkaian panjang panggilan fungsi. <br><br>  Alasan utama untuk masalah tersebut, seperti ketika menggunakan fungsi anonim, adalah bahwa mereka memberikan hasil jejak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stack stack yang</a> sangat tidak informatif. <br><br>  Ini tidak terlalu buruk jika, misalnya, hanya ada satu tingkat fungsi panggilan bersarang, katakanlah, jika kita berbicara tentang fungsi yang digunakan dalam iterator.  Namun, jika semua fungsi yang digunakan adalah fungsi tanda panah, dan fungsi-fungsi ini saling memanggil satu sama lain, maka jika terjadi kesalahan, tidak akan mudah untuk mengetahui apa yang terjadi.  Pesan kesalahan akan terlihat seperti ini: <br><br><pre> <code class="hljs">{anonymous}() {anonymous}() {anonymous}() {anonymous}() {anonymous}()</code> </pre> <br><h3>  <font color="#3AC1EF">â– Fungsi dengan konteks dinamis</font> </h3><br>  Yang terakhir dari situasi yang kita bahas di mana fungsi panah dapat menjadi sumber masalah adalah menggunakannya di mana Anda membutuhkan dinamika pengikatan <code>this</code> . <br><br>  Jika fungsi panah digunakan dalam situasi seperti itu, maka dinamika ikatan ini tidak akan berfungsi.  Kejutan yang tidak menyenangkan ini dapat menyebabkan orang bingung tentang alasan apa yang terjadi pada mereka yang harus bekerja dengan kode di mana fungsi panah digunakan secara tidak benar. <br><br>  Berikut adalah beberapa hal yang perlu diingat ketika mempertimbangkan menggunakan fungsi panah: <br><br><ul><li>  Penangan acara dipanggil dengan <code>this</code> terikat ke atribut event <code>currentTarget</code> . </li><li>  Jika Anda masih menggunakan jQuery, pertimbangkan bahwa sebagian besar metode jQuery mengikat <code>this</code> ke elemen DOM yang dipilih. </li><li>  Jika Anda menggunakan Vue.js, maka metode dan fungsi yang dihitung biasanya mengikat <code>this</code> ke komponen Vue. </li></ul><br>  Tentu saja, fungsi panah dapat digunakan dengan sengaja untuk mengubah perilaku standar mekanisme perangkat lunak.  Tetapi, terutama dalam kasus dengan jQuery dan Vue, ini sering bertentangan dengan fungsi normal sistem, yang mengarah pada kenyataan bahwa programmer tidak dapat memahami mengapa beberapa kode yang terlihat sangat normal tiba-tiba menolak untuk bekerja. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Fungsi panah adalah fitur JavaScript segar yang luar biasa.  Mereka memungkinkan, dalam banyak situasi, menulis kode yang lebih nyaman daripada sebelumnya.  Tetapi, seperti halnya dengan fitur-fitur lainnya, mereka memiliki kelebihan dan kekurangan.  Oleh karena itu, Anda perlu menggunakan fungsi panah di mana mereka dapat berguna, tanpa menganggapnya sebagai pengganti lengkap untuk fungsi biasa. <br><br>  <b>Pembaca yang budiman!</b>  Pernahkah Anda mengalami situasi di mana penggunaan fungsi panah mengarah ke kesalahan, ketidaknyamanan, atau perilaku yang tidak terduga dari program? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428566/">https://habr.com/ru/post/id428566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428556/index.html">"Lingkungan produksi berada di luar kendali Anda": Rian Lewis menguji proyek-proyek blockchain</a></li>
<li><a href="../id428558/index.html">Bagaimana saya membuat wizard untuk WordPress dari kemalasan saya yang dalam</a></li>
<li><a href="../id428560/index.html">Pengumuman hari Jumat yang tidak dijadwalkan</a></li>
<li><a href="../id428562/index.html">Droidcon London. Bagaimana itu?</a></li>
<li><a href="../id428564/index.html">Pencarian MapKit: Kiat & Trik</a></li>
<li><a href="../id428568/index.html">Bereaksi Panduan Pengembangan Aplikasi Web Asli</a></li>
<li><a href="../id428570/index.html">Fungsi Tingkat Tinggi dalam JavaScript</a></li>
<li><a href="../id428572/index.html">Komponen Orde Tinggi dalam Bereaksi</a></li>
<li><a href="../id428574/index.html">Bawa komunikasi korporat ke tingkat selanjutnya dengan Zextras Chat</a></li>
<li><a href="../id428576/index.html">[bookmark] versi PDF dari tutorial Node.js dan panduan JavaScript baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>