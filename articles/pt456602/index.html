<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏻 👋🏿 🍣 Guia de Implementação de assinaturas renováveis ​​automaticamente em aplicativos iOS 🤰🏼 🤴🏼 🏑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! Meu nome é Denis, estou desenvolvendo o Apphud , um serviço para a análise de assinaturas renováveis ​​automaticamente em aplicativos iOS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia de Implementação de assinaturas renováveis ​​automaticamente em aplicativos iOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/456602/"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="imagem"></p><br><p>  Olá pessoal!  Meu nome é Denis, estou desenvolvendo o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apphud</a> , um serviço para a análise de assinaturas renováveis ​​automaticamente em aplicativos iOS. </p><br><p>  Neste artigo, mostrarei como configurar, implementar e validar assinaturas renováveis ​​automaticamente no iOS 12 e iOS 13. Como bônus, mostrarei sobre pontos sutis e armadilhas que nem todos os desenvolvedores consideram. <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect">  Configurar assinaturas no App Store Connect </h2><br><p>  Se você já possui um ID de pacote configurável e um aplicativo criado, pode pular essas etapas.  Se você estiver criando um aplicativo pela primeira vez, faça o seguinte: </p><br><p>  Você deve criar <em>um ID de pacote explícito (ID do aplicativo)</em> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apple Developer Portal</a> .  Com uma página chamada <em>Certificados, Identificadores e Perfis</em> abertos, vá para a guia <em>Identificadores</em> .  Em junho de 2019, a Apple finalmente atualizou o layout do portal de acordo com o ASC (abreviação de App Store Connect). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="Novo design para o Apple Developer Portal em 2019"><br>  <em>Novo design para o Apple Developer Portal em 2019</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p> O ID do pacote explícito geralmente é especificado no estilo do domínio ( <code>com.apphud.subscriptionstest</code> ).  Na seção <em>Recursos</em> , você notará que a marca de seleção ao lado de <em>Compras no aplicativo</em> já <em>está</em> marcada.  Após criar o <em>ID</em> do <em>pacote</em> ( <em>ID do</em> <em>aplicativo</em> ), acesse o App Store Connect. </p><br><h3 id="testovye-polzovateli-sandbox-users">  Usuários de teste (usuários de sandbox) </h3><br><p>  Para testar compras futuras, você precisará criar um usuário de teste.  Para fazer isso, acesse ASC na guia <em>Usuários e acesso e</em> , em seguida, em <em>Sandbox Testers.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="Formulário de criação de sandbox do usuário"><br>  <em>Formulário de criação de sandbox do usuário</em> </p><br><blockquote>  Ao criar um testador, você pode especificar quaisquer dados inexistentes, o mais importante, não se esqueça do e-mail e da senha! </blockquote><p>  Falarei sobre como testar compras com credenciais de teste no final do artigo. </p><br><p>  Outro passo importante é configurar contratos e dados bancários na seção " <em>Contratos, impostos e operações bancárias</em> ".  Se você não tiver um contrato para aplicativos pagos, não poderá testar assinaturas renováveis ​​automaticamente! </p><br><p>  Depois disso, você pode criar um novo aplicativo na App Store Connect.  Especifique um nome exclusivo e selecione seu <em>ID</em> do pacote como o <em>ID</em> do pacote. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="O ID do pacote é o seu ID do pacote"><br>  <em>O ID do pacote é o seu ID do pacote</em> </p><br><p>  Imediatamente após a criação do aplicativo, vá para a guia <em>Recursos.</em> </p><br><blockquote>  Se você já criou o aplicativo, poderá continuar lendo aqui. </blockquote><p>  O processo de criação de uma assinatura renovável automaticamente consiste em várias etapas: </p><br><p>  <strong>1. Crie um identificador de assinatura e crie um <em>grupo de assinaturas</em> .</strong>  Um grupo de assinaturas é uma coleção de assinaturas com períodos e preços diferentes, mas que abrem a mesma funcionalidade no aplicativo.  Além disso, no grupo de assinaturas, você pode ativar o período de avaliação gratuita apenas uma vez e apenas uma das assinaturas pode estar ativa.  Se você deseja que seu aplicativo tenha duas assinaturas diferentes ao mesmo tempo, será necessário criar dois grupos de assinaturas. </p><br><p>  <strong>2. Preenchendo os dados da assinatura: duração, nome para exibição na App Store (não confundir apenas com o nome) e descrição.</strong>  Se você adicionar a primeira assinatura ao grupo, precisará indicar o nome de exibição do grupo de assinaturas.  Lembre-se de salvar suas alterações com mais frequência, o ASC pode congelar a qualquer momento e parar de responder. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="Página de inscrição"><br>  <em>Tela de inscrição</em> </p><br><p>  <strong>3. Preenchendo o preço da assinatura.</strong>  Existem duas etapas: criar preços e ofertas especiais.  Indique o preço real em qualquer moeda, ele é recalculado automaticamente para todos os outros países.  Ofertas introdutórias: aqui você pode oferecer aos usuários um período de avaliação gratuita ou descontos pré-pagos.  As promoções apareceram na App Store recentemente em 2019: permitem que você ofereça descontos especiais para usuários que cancelaram a inscrição e que você deseja devolver. </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key">  Geração de chave secreta compartilhada </h3><br><p>  Na página com uma lista de todas as suas assinaturas criadas, você verá a <em>chave Compartilhada do</em> botão <em>do aplicativo</em> .  Essa é uma linha especial necessária para validar uma verificação em um aplicativo iOS.  Precisamos validar a verificação para determinar o status da assinatura. </p><br><p>  A chave compartilhada pode ser de dois tipos: uma chave exclusiva para seu aplicativo ou uma chave única para sua conta.  Importante: em nenhum caso, recrie a chave se você já tiver o aplicativo na App Store, caso contrário, os usuários não poderão validar a verificação e seu aplicativo deixará de funcionar conforme o esperado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="Neste exemplo, três grupos de assinaturas e três assinaturas criadas são criadas."><br>  <em>Neste exemplo, três grupos de assinaturas e três assinaturas anuais são criados.</em> </p><br><p>  Copie o ID de todas as suas assinaturas e a chave compartilhada, isso será útil mais adiante no código. </p><br><h2 id="programmnaya-chast">  Parte do software </h2><br><p>  Vamos direto à parte prática.  O que é necessário para criar um gerente de compras completo?  No mínimo, o seguinte deve ser implementado: </p><br><ol><li><p>  Checkout </p><br></li><li><p>  Verificar status da assinatura </p><br></li><li><p>  Verificar atualização </p><br></li><li><p>  Recuperação de transação (não confunda com a atualização de um cheque!) </p><br></li></ol><br><h3 id="oformlenie-pokupok">  Checkout </h3><br><p>  Todo o processo de compra pode ser dividido em 2 etapas: recebimento de produtos (classe <code>SKProduct</code> ) e inicialização do processo de compra (classe <code>SKPayment</code> ).  Primeiro de tudo, devemos especificar o delegado do protocolo <code>SKPaymentTransactionObserver</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  A notificação <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> usada para atualizar a interface do usuário em um aplicativo. </p><br><p>  Em seguida, escrevemos um método para inicializar a compra: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  O delegado <code>SKPaymentTransactionObserver</code> tem a <code>SKPaymentTransactionObserver</code> aparência: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p>  Após a assinatura bem-sucedida, o método delegado é chamado no qual a transação tem o status <code>purchased</code> . </p><br><p>  Mas como determinar a data de validade de uma assinatura?  Para fazer isso, faça uma solicitação separada para a Apple. </p><br><h3 id="proverka-statusa-podpiski">  Verificar status da assinatura </h3><br><p>  A verificação é validada usando a solicitação <code>verifyReceipt</code> POST para a Apple, enviamos a verificação criptografada como uma string codificada em base64 como parâmetro e, na resposta, recebemos a mesma verificação no formato JSON.  Na matriz, a chave <code>latest_receipt_info</code> listará todas as transações de cada período de cada assinatura, incluindo períodos de avaliação.  Só podemos analisar a resposta e obter a data de vencimento atual de cada produto. </p><br><blockquote>  Na WWDC 2017, eles adicionaram a capacidade de receber apenas verificações atuais para cada assinatura usando a chave <code>exclude-old-transactions</code> na solicitação <code>verifyReceipt</code> . </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p>  No início do método, você pode ver que há uma verificação da existência de uma cópia local da verificação.  Uma verificação local pode não existir, por exemplo, se o aplicativo foi instalado via iTunes.  Se não houver verificação, não podemos executar a solicitação <code>verifyReceipt</code> .  Primeiro, precisamos obter a verificação local atual e tentar validá-la novamente.  A atualização da verificação é feita usando a classe <code>SKReceiptRefreshRequest</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>A atualização de verificação é</strong> implementada na função <code>refreshReceipt()</code> .  Se a verificação foi atualizada com êxito, o método delegado <code>requestDidFinish(_ request : SKRequest)</code> é chamado, que chama o método <code>refreshSubscriptionsStatus</code> . </p><br><p>  Como a análise das informações de compra é implementada?  <code>latest_receipt_info</code> um objeto JSON no qual há uma matriz aninhada de transações (pela chave <code>latest_receipt_info</code> ).  Analisamos a matriz, obtemos a data de validade usando a chave <code>expires_date</code> e a salvamos se essa data ainda não chegou. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p>  Dei um exemplo simples de como extrair a data de vencimento atual de uma assinatura.  Não há tratamento de erros e, por exemplo, não há verificação para o retorno de uma compra (a <em>data de cancelamento é</em> adicionada). </p><br><p>  Para determinar se uma assinatura está ativa ou não, basta comparar a data atual com a data em <em>Padrões</em> do <em>usuário</em> por chave do produto.  Se estiver ausente ou for menor que a data atual, a assinatura será considerada inativa. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p>  A recuperação da transação é realizada em uma única linha <code>SKPaymentQueue.default().restoreCompletedTransactions()</code> .  Essa função restaura todas as transações concluídas chamando o método delegado <code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code> . </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy">  Qual é a diferença entre atualizar uma verificação da recuperação de transações? </h3><br><p>  Ambos os métodos ajudam a restaurar seus dados de compra.  Mas quais são as diferenças?  Há uma mesa maravilhosa com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vídeo wwdc</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="Tabela de diferenças de duas maneiras de restaurar compras da WWDC"><br>  <em>Tabela de diferenças de duas maneiras de restaurar compras da WWDC</em> </p><br><p>  Na maioria dos casos, você só precisa usar <code>SKReceiptRefreshRequest()</code> , porque estamos interessados ​​apenas em receber uma verificação para o cálculo subsequente da data de validade. </p><br><p>  No caso de assinaturas renováveis ​​automaticamente, as transações em si não são do nosso interesse, portanto, basta usar apenas a atualização de cheques.  No entanto, há casos em que você precisa usar o método de recuperação de transação: se o seu aplicativo baixa conteúdo na compra (conteúdo hospedado pela Apple) ou se você ainda suporta versões abaixo do iOS 7. </p><br><h3 id="testirovanie-pokupok-sandbox-testing">  Teste de compras (Sandbox Testing) </h3><br><p>  Antes, para testar as compras, era necessário fazer login na App Store nas configurações do seu iPhone.  Isso foi muito inconveniente (por exemplo, toda a Apple Music Library foi apagada).  No entanto, isso não precisa ser feito agora: a conta da sandbox agora existe separadamente da conta principal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p>  O processo de compra é semelhante em comparação com compras reais na App Store, mas existem alguns pontos: </p><br><ul><li><p>  Você sempre precisará inserir a senha de login através da janela do sistema.  Compras usando o Touch ID / Face ID ainda não são suportadas. </p><br></li><li><p>  Se, ao inserir o login e a senha corretamente, o sistema solicitar repetidamente a senha de login, <em>clique em "Cancelar"</em> , minimize o aplicativo e tente novamente.  Parece bobagem, mas funciona para muitos.  Às vezes, porém, após a segunda entrada da senha, o processo continua. </p><br></li><li><p>  Você não poderá testar o processo de cancelamento de inscrição de nenhuma maneira. </p><br></li><li><p>  A duração dos períodos de assinatura é muito menor que a real.  E eles são atualizados não mais que 6 vezes por dia. </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Duração real </th><th>  Duração do teste </th></tr></thead><tbody><tr><td>  1 semana </td><td>  3 minutos </td></tr><tr><td>  1 mês </td><td>  5 minutos </td></tr><tr><td>  2 meses </td><td>  10 minutos </td></tr><tr><td>  3 meses </td><td>  15 minutos </td></tr><tr><td>  6 meses </td><td>  30 minutos </td></tr><tr><td>  1 ano </td><td>  1 hora </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  O que há de novo no StoreKit no iOS 13? </h3><br><p>  Dos novos - apenas a classe <code>SKStorefront</code> , que fornece informações sobre em que país o usuário está registrado na App Store.  Isso pode ser útil para os desenvolvedores que usam assinaturas diferentes para diferentes países.  Anteriormente, todos eram verificados por localização geográfica ou por região do dispositivo, mas isso não dava um resultado preciso.  Agora é muito fácil descobrir o país na App Store: <code>SKPaymentQueue.default().storefront?.countryCode</code> .  Um delegado de método também foi adicionado se o país na App Store mudasse durante o processo de compra.  Nesse caso, você pode continuar ou cancelar o processo de compra. </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami">  Armadilhas ao trabalhar com assinaturas </h2><br><ul><li>  A verificação de um cheque diretamente de um dispositivo não é recomendada pela Apple.  Eles falaram sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isso</a> várias vezes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na WWDC</a> (das 5:50) e isso é indicado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> .  Isso é inseguro porque um invasor pode interceptar dados usando um ataque man-in-the-middle.  A maneira correta de verificar as verificações é a validação local usando o servidor. </li><li>  Há um problema ao verificar a data de validade.  Se você não estiver usando o servidor, a hora do sistema no dispositivo poderá ser alterada para antiga e, em seguida, nosso código fornecerá o resultado errado - a assinatura será considerada ativa.  Se isso não lhe agradar, você poderá usar qualquer serviço que emita um horário mundial preciso. </li><li>  Nem todos os usuários podem ter uma avaliação gratuita.  O usuário pode reinstalar o aplicativo após algum tempo e o aplicativo mostrará que a avaliação está disponível como de costume.  Será correto atualizar a verificação, validá-la e verificar no JSON a disponibilidade da avaliação para este usuário.  Muitos não. </li><li>  Se o usuário solicitou um reembolso, <code>cancellation_date</code> será adicionado à assinatura JSON, mas <code>expires_date</code> permanecerá inalterado.  Portanto, é importante sempre verificar a presença do campo <code>cancellation_date</code> , que é preferível a <code>expires_date</code> . </li><li>  Não vale a pena atualizar a verificação toda vez que o aplicativo for iniciado, porque, em primeiro lugar, isso não faz sentido e, em segundo lugar, provavelmente o usuário receberá uma janela de entrada de senha do Apple ID.  Vale a pena atualizar a verificação, por exemplo, quando o próprio usuário clicou no botão restaurar compras. </li><li>  Como determinar em que pontos vale a pena validar um cheque para obter a data de vencimento atual de uma assinatura?  Você pode validar a verificação em cada início ou apenas no final da assinatura.  No entanto, se você marcar a verificação apenas no final da assinatura, o usuário que emitiu o reembolso poderá usar seu aplicativo gratuitamente até o final do período. </li></ul><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Espero que este artigo seja útil para você.  Tentei adicionar não apenas o código, mas também explicar os pontos sutis no desenvolvimento.  O código completo da turma pode ser baixado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Esta classe será muito útil para familiarizar com desenvolvedores iniciantes e aqueles que desejam aprender mais sobre como tudo funciona.  Para aplicativos ao vivo, é recomendável usar soluções mais sérias, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SwiftyStoreKit</a> . </p><br><blockquote>  Deseja implementar assinaturas no seu aplicativo iOS em 10 minutos?  Integre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apphud</a> e: <br><ul><li>  Faça compras usando apenas um método; </li><li>  rastreia automaticamente o status da assinatura de cada usuário; </li><li>  Integre facilmente as ofertas de assinatura </li><li>  enviar eventos de assinatura para Amplitude, Mixpanel, Slack e Telegram, levando em consideração a moeda local do usuário; </li><li>  diminua a taxa de rotatividade de aplicativos e retorne usuários não inscritos. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456602/">https://habr.com/ru/post/pt456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456588/index.html">Estudo da injeção de dependência</a></li>
<li><a href="../pt456592/index.html">Distorções cognitivas no desenvolvimento dos "tempos" da língua inglesa ou Quem interfere conosco nos ajudarão</a></li>
<li><a href="../pt456594/index.html">2 minutos com tremor de árvores Webpack e reexportação</a></li>
<li><a href="../pt456596/index.html">Microbiota. Como o teste funciona?</a></li>
<li><a href="../pt456600/index.html">Receitas Nginx: autorização LDAP com captcha</a></li>
<li><a href="../pt456604/index.html">Como automatizamos uma grande loja on-line e começamos a combinar produtos automaticamente</a></li>
<li><a href="../pt456606/index.html">Notícias do mundo do OpenStreetMap nº 464 (04/04/2019 - 06/10/2019)</a></li>
<li><a href="../pt456608/index.html">Southbridge em Chelyabinsk e Bitrix em Kubernetes</a></li>
<li><a href="../pt456610/index.html">Não pressione e não aprove</a></li>
<li><a href="../pt456612/index.html">Uma das centenas de maneiras de publicar vários projetos de produção em um servidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>