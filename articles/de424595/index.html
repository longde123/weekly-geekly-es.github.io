<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèæ üêª ‚ôéÔ∏è MVC + Szenario gegen Fat Controller üóÇÔ∏è üòü üôä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MVC + -Szenario vs. Thick Controller 


 Moderne PHP-Frameworks (Symphony, Laravel, im Folgenden √ºberall) zeigen √ºberzeugend, dass die Implementierung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVC + Szenario gegen Fat Controller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424595/"><h1 id="mvc--scenario-protiv-tolstyh-kontrollerov">  MVC + -Szenario vs. Thick Controller </h1><br><p> Moderne PHP-Frameworks (Symphony, Laravel, im Folgenden √ºberall) zeigen √ºberzeugend, dass die Implementierung des Model-View-Controller-Musters nicht so einfach ist.  Aus irgendeinem Grund sind alle Implementierungen anf√§llig f√ºr <code>fat controllers</code> , die von allen, sowohl den Entwicklern als auch den Frameworks selbst, verurteilt werden. </p><br><p>  Warum ist das so?  Und gibt es eine M√∂glichkeit, damit umzugehen?  Lass es uns richtig machen. </p><a name="habracut"></a><br><h2 id="terminologiya">  Terminologie </h2><br><ul><li>  Modell - Modell (Shaper der angeforderten Daten) </li><li>  Ansicht - Ansicht (Modelldatendekorateur) </li><li>  Controller - Controller (Modellansichtskoordinator wie gew√ºnscht) </li><li>  Vorlage - Pr√§sentationsvorlage </li><li>  Rendern - Rendern (Bildung, Gestaltung des Pr√§sentationsbildes) </li><li>  Renderer - Renderer (Shaper, Designer des Pr√§sentationsbildes) </li></ul><br><h2 id="tolstyy-kontroller">  Dicker Controller </h2><br><p>  Hier ist ein typischer Fat Controller: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *   *      ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionUserHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ( ) $user = UserModel::find($userId); //       -   $name = $user-&gt;firstName.' '.$user-&gt;lastName; //         $view = new View('hello', ['name' =&gt; $name]); //  ( )     return $view-&gt;render(); } }</span></span></code> </pre> <br><p>  Was sehen wir?  Wir sehen Vinaigrette!  In der Steuerung ist alles, was m√∂glich ist, gemischt - sowohl das Modell als auch die Pr√§sentation und tats√§chlich die Steuerung selbst! </p><br><p>  Wir sehen die Namen des Modells und der Vorlage fest mit dem Controller verbunden.  Dies ist kein Summen.  Wir sehen Manipulationen mit den Modelldaten in der Steuerung - die Bildung eines vollst√§ndigen Namens aus dem Vor- und Nachnamen.  Und das ist kein Summen. </p><br><p>  Und noch etwas: Wir sehen dieses Beispiel nicht explizit, aber es ist implizit.  N√§mlich: Es gibt nur einen Weg zum Rendern (Bilderzeugung)!  Nur eins: laut Vorlage in der PHP-Datei!  Und wenn ich pdf will?  Und wenn ich nicht in einer Datei, sondern in einer PHP-Zeile will?  Ich hatte Designs mit aufw√§ndigen Designs auf Hunderten von kleinen Vorlagen.  Ich musste den Renderer f√ºr String-Vorlagen selbst herausplatzen lassen.  Ich habe nat√ºrlich nicht √ºberhitzt, aber die Sache ist im Prinzip. </p><br><p>  Kurze Zusammenfassung: </p><br><blockquote>  Moderne Frameworks haben gemeinsame M√§ngel bei der Implementierung von MVC f√ºr alle: <br><ol><li>  Enge Interpretation von MVC-Ansicht (Ansicht) <strong><em>nur</em></strong> als <em>"Ansicht mit einer Vorlage in einer PHP-Datei"</em> anstelle von <em>"Ansicht mit einem beliebigen Renderer".</em> </li><li>  Enge Interpretation des MVC-Modells <strong><em>nur</em></strong> als "Datenbankmodelldom√§ne" anstelle von <em>"Beliebiger Datencompiler zur Pr√§sentation".</em> </li><li>  Sie provozieren die Verwendung der sogenannten <em>"Thick Controller",</em> die alle Logik gleichzeitig enthalten: Gesch√§ft, Pr√§sentation und Interaktion.  Dies zerst√∂rt das Hauptziel von MVC - die Aufteilung der Verantwortlichkeiten zwischen den Komponenten der Triade. </li></ol><br></blockquote><p>  Um diese M√§ngel zu beheben, w√§re es sch√∂n, die Komponenten von MVC genauer zu betrachten. </p><br><h2 id="predstavlenie---eto-renderer">  View ist ein Renderer </h2><br><p>  Schauen Sie sich den ersten Nachteil an: </p><br><blockquote><ol><li>  Enge Interpretation von MVC-Ansicht (Ansicht) <strong><em>nur</em></strong> als <em>"Ansicht mit einer Vorlage in einer PHP-Datei"</em> anstelle von <em>"Ansicht mit einem beliebigen Renderer".</em> </li></ol><br></blockquote><p>  Hier ist alles ganz einfach - die L√∂sung des Problems ist bereits in der Problemstellung selbst angegeben.  Wir m√ºssen nur sagen, dass jeder Renderer die Ansicht verwenden kann.  Um dies zu implementieren, f√ºgen Sie einfach die neue <code>renderer</code> Eigenschaft zur View-Klasse hinzu: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $template, $data, $renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__costruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($template, $data, $renderer = NULL)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br><p>  Daher haben wir eine neue <code>renderer</code> Eigenschaft f√ºr die Ansicht definiert.  Im allgemeinsten Fall kann der Wert dieser Eigenschaft eine beliebige <code>callable</code> Funktion sein, die ein Bild der Daten erstellt, die mithilfe der √ºbertragenen Vorlage an sie √ºbertragen wurden. </p><br><p>  Die meisten Anwendungen verwenden nur einen Renderer, und selbst wenn sie mehrere verwenden, wird einer von ihnen bevorzugt.  Daher wird das <code>renderer</code> Argument als optional definiert, vorausgesetzt, es gibt einen Standard-Renderer. </p><br><p>  Ist es einfach  Einfach.  Eigentlich nicht so einfach.  Tatsache ist, dass die <code>View</code> in MVC nicht genau die <code>View</code> in den Frameworks ist.  Die <code>View</code> im Framework kann nicht ohne Vorlage leben.  Aber die <code>View</code> , die in MVC aus irgendeinem Grund nichts √ºber dieselben Vorlagen wei√ü.  Warum?  Ja, denn f√ºr MVC <code>View</code> ist dies <em>ein Konverter von Modelldaten in ein Bild</em> und nicht nur eine Vorlagen-Engine.  Wenn wir so etwas in den Request-Handler schreiben: </p><br><pre> <code class="php hljs">$name = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello, {$name}!"</span></span>;</code> </pre> <br><p>  oder sogar: </p><br><pre> <code class="php hljs">$return json_encode($name); <span class="hljs-comment"><span class="hljs-comment">// Ajax response</span></span></code> </pre> <br><p>  Dann definieren wir wirklich die <code>View</code> , die sich in MVC befindet, ohne eine <code>View</code> zu ber√ºhren, die sich in den Frameworks befindet! </p><br><p>  Aber jetzt ist alles wirklich einfach: diese <code>View</code> , die in den Frameworks - dies ist eine Teilmenge dieser <code>View</code> , die sich in MVC befinden.  Dar√ºber hinaus ist eine sehr enge Teilmenge, n√§mlich es ist nur eine Template-Engine, die auf PHP-Dateien basiert. </p><br><p>  Zusammenfassung: Es ist der <code></code> , d.h.  Jeder Dekorateur eines Datenbildes ist die <code>View</code> in MVC.  Und diese <code>View</code> , die sich in den Frameworks befindet, ist nur eine Art <code></code> . </p><br><h2 id="model-domena--model-predstavleniya-viewmodel--domainmodel">  Dom√§nenmodell / Ansichtsmodell (ViewModel / DomainModel) </h2><br><p>  Schauen Sie sich nun den zweiten Nachteil an: </p><br><blockquote><ol><li>  Enge Interpretation des MVC-Modells <strong><em>nur</em></strong> als "Datenbankmodelldom√§ne" anstelle von <em>"Beliebiger Datencompiler zur Pr√§sentation".</em> </li></ol><br></blockquote><p>  Es ist f√ºr jeden offensichtlich, dass das MVC-Modell eine komplexe Sache ist, die aus anderen Teilen besteht.  Die Community erkl√§rt sich damit einverstanden, das Modell in zwei Komponenten zu zerlegen: ein Dom√§nenmodell (DomainModel) und ein Pr√§sentationsmodell (ViewModel). </p><br><p>  Ein Dom√§nenmodell ist das, was in Datenbanken gespeichert ist, d.h.  normalisierte Modelldaten.  Geben Sie "Vorname" und "Nachname" in verschiedene Felder ein.  Die Frameworks sind mit diesem bestimmten Teil des Modells besch√§ftigt, einfach weil die Datenspeicherung ein eigenes Universum ist, das gut untersucht wurde. </p><br><p>  Eine Anwendung ben√∂tigt jedoch eher aggregierte als normalisierte Daten.  Domain-Daten m√ºssen zu Bildern wie "Hallo, Ivan!" Oder "Lieber Ivan Petrov!" Oder sogar "F√ºr Ivan <strong>a</strong> Petrov <strong>a</strong> !" Zusammengestellt werden.  Diese konvertierten Daten werden auf ein anderes Modell bezogen - das Pr√§sentationsmodell.  Es ist also dieser Teil des Modells, der von modernen Frameworks immer noch ignoriert wird.  Es wird ignoriert, da es keine Einigung dar√ºber gibt, wie damit umgegangen werden soll.  Und wenn Frameworks keine L√∂sung bieten, gehen Programmierer den einfachsten Weg - sie werfen das Ansichtsmodell in die Steuerung.  Und sie bekommen die verhassten, aber unvermeidlichen Fat Controller! </p><br><p>  Fazit: Um MVC zu implementieren, m√ºssen Sie ein Ansichtsmodell implementieren.  Es gibt keine anderen Optionen.  Da die Darstellungen und ihre Daten beliebig sein k√∂nnen, geben wir an, dass wir ein Problem haben. </p><br><h2 id="scenariy-protiv-tolstyh-kontrollerov">  Szenario vs. Fettkontrolleure </h2><br><p>  Es gibt einen letzten Nachteil der Frameworks: </p><br><blockquote><ol><li>  Sie provozieren die Verwendung der sogenannten <em>"Thick Controller",</em> die alle Logik gleichzeitig enthalten: Gesch√§ft, Pr√§sentation und Interaktion.  Dies zerst√∂rt das Hauptziel von MVC - die Aufteilung der Verantwortlichkeiten zwischen den Komponenten der Triade. </li></ol><br></blockquote><p>  Hier kommen wir zu den Grundlagen von MVC.  Lassen Sie uns klar sein.  Daher √ºbernimmt MVC die folgende Verteilung der Verantwortlichkeiten zwischen den Komponenten der Triade: </p><br><ul><li>  Die Steuerung ist die <em>Interaktionslogik</em> , d.h.  Interaktionen sowohl mit der Au√üenwelt (Anfrage - Antwort) als auch mit der Innenwelt (Modell - Pr√§sentation), </li><li>  Das Modell ist <em>Gesch√§ftslogik</em> , d.h.  Generieren von Daten f√ºr eine bestimmte Anforderung, </li><li>  Repr√§sentation ist die <em>Logik der Repr√§sentation</em> , d.h.  Dekoration der vom Modell generierten Daten. </li></ul><br><p>  Mach weiter.  Zwei Ebenen von Verantwortlichkeiten sind deutlich sichtbar: </p><br><ul><li>  Die Organisationsebene ist der Controller, </li><li>  Die F√ºhrungsebene ist Modell und Repr√§sentation. </li></ul><br><p>  In einfachen Worten, der Controller steuert, Modell und Ansicht Pflug.  Dies ist auf einfache Weise.  Und wenn nicht auf einfache Weise, aber genauer?  Wie genau lenkt der Controller?  Und wie genau pfl√ºgen das Modell und der View? </p><br><p>  Der Controller steuert wie folgt: </p><br><ul><li>  Erh√§lt eine Anfrage von einer Bewerbung, </li><li>  Legt fest, welches Modell und welche Ansicht f√ºr diese Anforderung verwendet werden soll. </li><li>  Ruft das ausgew√§hlte Modell auf und empf√§ngt Daten von ihm. </li><li>  Ruft die ausgew√§hlte Ansicht mit vom Modell empfangenen Daten auf. </li><li>  Gibt die von der Ansicht dekorierten Daten an die Anwendung zur√ºck. </li></ul><br><p>  So etwas in der Art.  Das Wesentliche an diesem Schema ist, dass sich das Modell und die Darstellung als Glieder in der Kette der Abfrageausf√ºhrung herausstellen.  Dar√ºber hinaus durch aufeinanderfolgende Links: Zuerst konvertiert das Modell die Anforderung in einige Daten, dann werden diese Modelldaten von der Ansicht in eine Antwort konvertiert, die nach Bedarf f√ºr eine bestimmte Anforderung dekoriert ist.  Wie eine humanoide Anfrage wird visuell mit Templatizatoren dekoriert, eine Android-Anfrage wird mit JSON-Encodern dekoriert. </p><br><p>  Versuchen wir nun herauszufinden, wie genau die Darsteller pfl√ºgen - Modell und Pr√§sentation.  Wir haben oben gesagt, dass Konsens √ºber die Zerlegung des Modells in zwei Unterkomponenten besteht: Dom√§nenmodell und Pr√§sentationsmodell.  Dies bedeutet, dass es mehr K√ºnstler geben kann - nicht zwei, sondern drei.  Anstelle einer Ausf√ºhrungskette </p><br><blockquote>  <code></code> &gt;&gt; <code></code> </blockquote><p>  Es kann durchaus eine Kette geben </p><br><blockquote>  <code> </code> &gt;&gt; <code> </code> anzeigen &gt;&gt; <code></code> </blockquote><p>  Die Frage stellt sich: Warum nur zwei oder drei?  Und wenn Sie mehr brauchen?  Die nat√ºrliche Antwort ist, um Gottes willen, nimm so viel, wie du brauchst! </p><br><p>  Andere n√ºtzliche K√ºnstler sind sofort sichtbar: Validatoren, Redirectors, verschiedene Renderer und im Allgemeinen alles, was unvorhersehbar, aber erfreulich ist. </p><br><p>  Fassen wir zusammen: </p><br><blockquote><ul><li>  Die MVC ( <code></code> - <code></code> ) auf F√ºhrungsebene kann als Kette von Gliedern implementiert werden, wobei jedes Glied die Ausgabe des vorherigen Links in die Eingabe f√ºr das n√§chste konvertiert. </li><li>  Die Eingabe des ersten Links ist die Anwendungsanforderung. </li><li>  Die Ausgabe des letzten Links ist die Antwort der Anwendung auf die Anforderung. </li></ul><br></blockquote><p>  Ich habe dieses <code>Scenario</code> , aber f√ºr die Glieder der Kette habe ich mich noch nicht f√ºr den Namen entschieden.  Aktuelle Optionen sind eine Szene (als Teil eines Skripts), ein Filter (als Datenkonverter) und eine Skriptaktion.  Im Allgemeinen ist der Name f√ºr den Link nicht so wichtig, es gibt eine wichtigere Sache. </p><br><p>  Die Folgen des Auftretens des Szenarios sind erheblich.  Das Szenario √ºbernahm n√§mlich die Hauptverantwortung des Controllers - das f√ºr die Anforderung erforderliche Modell und die Pr√§sentation zu bestimmen und diese zu starten.  Somit hat der Controller nur zwei Verantwortlichkeiten: Interaktion mit der Au√üenwelt (Anfrage-Antwort) und Ausf√ºhren des Skripts.  Dies ist insofern gut, als alle Komponenten der MVC-Triade nacheinander zerlegt werden und spezifischer und √ºberschaubarer werden.  Und in anderer Hinsicht immer noch gut - der MVCS-Controller wird zu einer rein internen unver√§nderlichen Klasse und kann daher auch im Prinzip nicht fett werden. </p><br><p>  Die Verwendung von Szenarien f√ºhrt zu einer anderen Variation des MVC-Musters. Ich habe diese Variation <strong><code>MVCS</code></strong> - <code>Model-View-Controller-Scenario</code> . </p><br><p>  Und noch ein paar Zeilen zur MVC-Zerlegung.  Moderne Frameworks, in denen alle typischen Funktionen bis an die Grenzen zerlegt werden, haben dem konzeptionellen MVC-Teil der Verantwortung f√ºr die Interaktion mit der Au√üenwelt ganz nat√ºrlich entzogen.  Daher sind speziell geschulte Klassen wie <code>HTTP </code> und <code></code> mit der Verarbeitung von Benutzeranfragen besch√§ftigt.  Infolgedessen empf√§ngt der Controller nicht die anf√§ngliche Benutzeranforderung, sondern eine verfeinerte <code></code> , und dies erm√∂glicht es, den Controller von den Besonderheiten der Anforderung zu isolieren.  In √§hnlicher Weise wird von den Besonderheiten der HTTP-Antwort isoliert, sodass das MVC-Modul seinen eigenen Antworttyp definieren kann.  Dar√ºber hinaus haben die Frameworks die beiden Komponenten von MVC - das Dom√§nenmodell und die Pr√§sentationsvorlage - vollst√§ndig implementiert. Dies haben wir jedoch bereits er√∂rtert.  Ich bin das alles auf die Tatsache zur√ºckzuf√ºhren, dass die Verfeinerung und Konkretisierung von MVC fortlaufend und kontinuierlich ist, und dies ist ein Summen. </p><br><h2 id="primer-ispolzovaniya-mvcs">  MVCS-Beispiel </h2><br><p>  Lassen Sie uns nun sehen, wie das Beispiel des <em>Fat Cortroller</em> am Anfang dieses Artikels in MVCS implementiert werden kann. </p><br><p>  Wir beginnen mit der Erstellung eines MVCS-Controllers: </p><br><pre> <code class="php hljs">$mvcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MvcsController();</code> </pre> <br><p>  Der MVCS-Controller empf√§ngt eine Anforderung von einem externen Router.  Lassen Sie den Router den URI der Form 'user / hello / XXX' in eine solche Aktion konvertieren und Parameter anfordern: </p><br><pre> <code class="php hljs">$requestAction = <span class="hljs-string"><span class="hljs-string">'user/hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   $requestParams = ['XXX']; //   -  </span></span></code> </pre> <br><p>  In Anbetracht der Tatsache, dass der MVCS-Controller Skripts anstelle von URIs akzeptiert, m√ºssen wir der Aktion der Anforderung ein Skript zuordnen.  Dies geschieht am besten im MVCS-Container: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   MVCS  URI  $mvcs-&gt;set('scenarios', [ 'user/hello' =&gt; 'UserModel &gt; UserViewModel &gt; view, hello', ..., ]);</span></span></code> </pre> <br><p>  Schauen wir uns dieses Szenario genauer an.  Dies ist eine Kette von drei Datenkonvertern, die durch ein '&gt;' getrennt sind: </p><br><ul><li>  'UserModel' ist der Name des Dom√§nenmodells 'User', die Eingabe des Modells sind die Anforderungsparameter, die Ausgabe sind die tats√§chlichen Daten des Modells. </li><li>  'UserViewModel' ist der Name des Ansichtsmodells, das Dom√§nendaten in Ansichtsdaten konvertiert. </li><li>  'view, hello' ist die Systemansicht 'template' f√ºr eine PHP-Vorlage namens 'hello'. </li></ul><br><p>  Jetzt m√ºssen wir nur noch zwei am Skript beteiligte Transformatoren als Abschlussfunktion zum MVCS-Container hinzuf√ºgen: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   UserModel $mvcs-&gt;set('UserModel', function($id) { $users = [ 1 =&gt; ['first' =&gt; '', 'last' =&gt; ''], 2 =&gt; ['first' =&gt; '', 'last' =&gt; ''], ]; return isset($users[$id]) ? $users[$id] : NULL; }); //   UserViewModel $mvcs-&gt;set('UserViewModel', function($user) { //    PHP  : 'echo "Hello, $name!"'; return ['name' =&gt; $user['first'].' '.$user['last']]; });</span></span></code> </pre> <br><p>  Und das ist alles!  F√ºr jede Anforderung ist es erforderlich, das entsprechende Skript und alle seine Szenen zu bestimmen (mit Ausnahme von Systemszenen wie "Ansicht").  Und nichts mehr. </p><br><p>  Und jetzt k√∂nnen wir MVCS auf verschiedene Anforderungen testen: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//        $scenarios = $mvcs-&gt;get('scenarios'); $scenario = $scenarios[$requestAction]; //      ... //   'user/hello/1'  ' '   'hello' $requestParams = ['1']; $response = $mvcs-&gt;play($scenario, $requestParams); //   'user/hello/2'  ' '   'hello' $requestParams = ['2']; $response = $mvcs-&gt;play($scenario, $requestParams);</span></span></code> </pre> <br><blockquote>  <em>Die PHP MVCS-Implementierung wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com</a> gehostet.</em> <br>  <em>Dieses Beispiel befindet sich im <code>example</code> MVCS-Verzeichnis.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424595/">https://habr.com/ru/post/de424595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424585/index.html">CryEngine 5.5 von Crytek ver√∂ffentlicht</a></li>
<li><a href="../de424587/index.html">Zusammenfassung des Buches "Verk√§ufe an gro√üe Unternehmen"</a></li>
<li><a href="../de424589/index.html">So melden Sie sich f√ºr ein PhD-Programm f√ºr maschinelles Lernen an</a></li>
<li><a href="../de424591/index.html">Es gibt kein Ideal: wie ich nach einer Programmiersprache f√ºr mich gesucht habe</a></li>
<li><a href="../de424593/index.html">C ++ 11 und Ereignisbehandlung</a></li>
<li><a href="../de424597/index.html">Interview mit dem Sprecher der RubyRussia-Konferenz Marcus Schirp</a></li>
<li><a href="../de424599/index.html">Sie m√ºssen ausw√§hlen, welche Software Sie ben√∂tigen: p√ºnktlich geschrieben oder von hoher Qualit√§t</a></li>
<li><a href="../de424601/index.html">Informationsarchitektur im Internet Teil 1</a></li>
<li><a href="../de424603/index.html">Das Buch ‚ÄûWarum liegen wir falsch? Denkfallen in Aktion. ‚Äú Ausz√ºge Teil 1</a></li>
<li><a href="../de424605/index.html">Zuckerberg-Fonds: Zusammenarbeit + Technologie + Open Science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>