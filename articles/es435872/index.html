<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßê üåª üöì Lenguaje de programaci√≥n Zig üë®‚Äçüåæ üé´ üèïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El primer comentario sobre el notable art√≠culo Visi√≥n subjetiva de un lenguaje de programaci√≥n ideal result√≥ ser una referencia al lenguaje de program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lenguaje de programaci√≥n Zig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435872/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  El primer comentario sobre el notable art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visi√≥n subjetiva de un lenguaje de programaci√≥n ideal</a> result√≥ ser una referencia al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lenguaje de programaci√≥n Zig</a> .  Naturalmente, se volvi√≥ interesante qu√© tipo de lenguaje es el que dice ser un nicho de C ++, D y Rust.  Mir√©, el lenguaje parec√≠a bonito y algo interesante.  Buena sintaxis tipo si, enfoque original para el manejo de errores, corutinas incorporadas.  Este art√≠culo es una breve descripci√≥n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> entremezclada con sus propios pensamientos e impresiones de ejemplos de c√≥digo en ejecuci√≥n. <br><a name="habracut"></a><br><h2>  Empezando </h2><br>  Instalar el compilador es bastante simple, para Windows, simplemente descomprima el paquete de distribuci√≥n en alguna carpeta.  Creamos el archivo de texto hello.zig en la misma carpeta, insertamos el c√≥digo de la documentaci√≥n all√≠ y lo guardamos.  El montaje se realiza mediante el comando <br><br><pre><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  despu√©s de lo cual hello.exe aparece en el mismo directorio. <br><br>  Adem√°s del ensamblaje, el modo de prueba de la unidad est√° disponible, para esto, los bloques de prueba se usan en el c√≥digo, y el ensamblaje y el lanzamiento de las pruebas se llevan a cabo mediante el comando <br><br><pre> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3>  Primeras rarezas </h3><br>  El compilador no admite saltos de l√≠nea de Windows (\ r \ n).  Por supuesto, el hecho de que los saltos de l√≠nea en cada sistema (Win, Nix, Mac) sean algunos de los suyos es lo salvaje y una reliquia del pasado.  Pero no hay nada que hacer, as√≠ que solo seleccione, por ejemplo, en Notepad ++ el formato que desea para el compilador. <br><br>  La segunda rareza que encontr√© por accidente: ¬°las pesta√±as no son compatibles con el c√≥digo!  Solo espacios.  Pero sucede :) <br><br>  Sin embargo, esto est√° escrito honestamente en la documentaci√≥n: la verdad ya est√° al final. <br><br><h3>  Comentarios </h3><br>  Otra rareza es que Zig no admite comentarios de varias l√≠neas.  Recuerdo que todo se hizo correctamente en el antiguo turbo pascal: se admitieron comentarios anidados de varias l√≠neas.  Aparentemente, desde entonces, ning√∫n desarrollador de idiomas ha dominado algo tan simple :) <br><br>  Pero hay comentarios documentales.  Comience con ///.  Debe estar en ciertos lugares, delante de los objetos correspondientes (variables, funciones, clases ...).  Si est√°n en otro lugar, un error de compilaci√≥n.  No esta mal. <br><br><h3>  Declaraci√≥n variable </h3><br>  Hecho en el estilo de moda ahora (e ideol√≥gicamente correcto), cuando la palabra clave (const o var) se escribe primero, luego el nombre, luego opcionalmente el tipo y luego el valor inicial.  Es decir  La inferencia autom√°tica de tipos est√° disponible.  Las variables deben inicializarse: si no especifica un valor inicial, habr√° un error de compilaci√≥n.  Sin embargo, se proporciona un valor indefinido especial, que puede usarse expl√≠citamente para especificar variables no inicializadas. <br><br><pre> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3>  Salida de la consola </h3><br>  Para los experimentos, necesitamos salida a la consola; en todos los ejemplos, este es el m√©todo utilizado.  En el campo de los complementos <br><br><pre> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  y el c√≥digo est√° escrito as√≠: <br><br><pre> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  El compilador tiene algunos errores, que informa honestamente cuando intenta generar un n√∫mero entero o un n√∫mero de coma flotante de esta manera: <br><blockquote>  error: error del compilador: los literales enteros y flotantes en la funci√≥n var args deben ser convertidos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/ziglang/zig/issues/557</a> </blockquote><h2>  Tipos de datos </h2><br><h3>  Tipos primitivos </h3><br>  Los nombres de los tipos aparentemente se toman de Rust (i8, u8, ... i128, u128), tambi√©n hay tipos especiales para compatibilidad binaria C, 4 tipos de tipos de punto flotante (f16, f32, f64, f128).  Hay un tipo bool.  Hay un tipo de vac√≠o de longitud cero y un retorno especial, que discutiremos m√°s adelante. <br><br>  Tambi√©n puede construir tipos enteros de cualquier longitud en bits del 1 al 65535. El nombre del tipo comienza con la letra i o u, y luego se escribe la longitud en bits. <br><br><pre> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  Sin embargo, no pude obtener este valor en la consola: se produjo un error en el LLVM durante el proceso de compilaci√≥n. <br><br>  En general, esta es una soluci√≥n interesante, aunque ambigua (en mi humilde opini√≥n: admitir literales num√©ricos exactamente largos en el nivel del compilador es correcto, pero nombrar los tipos de esta manera no es muy bueno, es mejor hacerlo honestamente a trav√©s de un tipo de plantilla).  ¬øY por qu√© es el l√≠mite 65535?  ¬øLas bibliotecas como GMP no parecen imponer tales restricciones? <br><br><h3>  Literales de cadena </h3><br>  Estas son matrices de caracteres (sin cero al final).  Para literales con un cero final, se usa el prefijo 'c'. <br><br><pre> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  Como la mayor√≠a de los idiomas, Zig admite secuencias de escape est√°ndar e inserta caracteres Unicode a trav√©s de sus c√≥digos (\ uNNNN, \ UNNNNNN donde N es un d√≠gito hexadecimal). <br>  Los literales de varias l√≠neas se forman utilizando dos barras invertidas al comienzo de cada l√≠nea.  No se requieren comillas.  Es decir, algunos intentos de hacer cadenas sin formato, pero en mi humilde opini√≥n no tiene √©xito, la ventaja de las cadenas sin formato es que puede insertar cualquier parte del texto desde cualquier parte del c√≥digo, e idealmente no cambie nada, pero aqu√≠ debe agregar \\ al comienzo de cada l√≠nea. <br><br><pre> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3>  Literales enteros </h3><br>  Todo est√° en lenguajes tipo si.  Estaba muy contento de que para los literales octales, se usa el prefijo 0o, y no solo cero, como en C.  Los literales binarios con el prefijo 0b tambi√©n son compatibles.  Los literales de coma flotante pueden ser hexadecimales (como se hace en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la extensi√≥n GCC</a> ). <br><br><h3>  Operaciones </h3><br>  Por supuesto, hay operaciones C aritm√©ticas, l√≥gicas y bit a bit est√°ndar.  Se admiten operaciones abreviadas (+ = etc.).  En lugar de &amp;&amp; y ||  Las palabras clave y y o se utilizan.  Un punto interesante es que las operaciones con sem√°ntica envolvente garantizada tambi√©n son compatibles.  Se ven as√≠: <br><br><pre> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  En este caso, las operaciones aritm√©ticas ordinarias no garantizan el desbordamiento y sus resultados durante el desbordamiento se consideran indefinidos (y se generan errores de compilaci√≥n para las constantes).  En mi humilde opini√≥n esto es un poco extra√±o, pero aparentemente est√° hecho de algunas consideraciones profundas de compatibilidad con la sem√°ntica del lenguaje C. <br><br><h3>  Matrices </h3><br>  Los literales de matriz se ven as√≠: <br><br><pre> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  Las cadenas son matrices de caracteres, como en C.  Indizaci√≥n cl√°sica con corchetes.  Se proporcionan las operaciones de adici√≥n (concatenaci√≥n) y multiplicaci√≥n de matrices.  Es algo muy interesante, y si todo est√° claro con la concatenaci√≥n, luego la multiplicaci√≥n: segu√≠ esperando hasta que alguien implementara esto, y ahora espero :) En Assembler (!) Existe una operaci√≥n duplicada que le permite generar datos duplicados.  Ahora en Zig: <br><br><pre> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3>  Punteros </h3><br>  La sintaxis es similar a C. <br><br><pre> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  Para desreferenciar (tomar valores por puntero), se utiliza una operaci√≥n inusual de postfix: <br><br><pre> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  El tipo de puntero se establece expl√≠citamente estableciendo un asterisco delante del nombre del tipo <br><br><pre> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3>  Rodajas (rodajas) </h3><br>  Una estructura de datos integrada en el lenguaje que le permite hacer referencia a una matriz o parte de ella.  Contiene un puntero al primer elemento y el n√∫mero de elementos.  Se ve as√≠: <br><br><pre> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  Parece haber sido tomado de Go, no estoy seguro.  Y tampoco estoy seguro de si val√≠a la pena incrustarlo en un lenguaje, mientras que la implementaci√≥n en cualquier lenguaje OOP de tal cosa es muy elemental. <br><br><h3>  Estructuras </h3><br>  Una forma interesante de declarar una estructura: se declara una constante, cuyo tipo se muestra autom√°ticamente como "tipo" (tipo), y es el que se usa como nombre de la estructura.  Y la estructura misma (struct) es "sin nombre". <br><br><pre> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  Es imposible especificar un nombre de la manera habitual en lenguajes tipo C, sin embargo, el compilador muestra el nombre del tipo de acuerdo con ciertas reglas, en particular, en el caso considerado anteriormente, coincidir√° con el nombre de la constante "tipo". <br><br>  En general, el lenguaje no garantiza el orden de los campos y su alineaci√≥n en la memoria.  Si se necesitan garant√≠as, entonces se deben usar estructuras "empaquetadas". <br><br><pre> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  Inicializaci√≥n: al estilo de los designadores de Sishny: <br><br><pre> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  Las estructuras pueden tener m√©todos.  Sin embargo, colocar un m√©todo en una estructura es simplemente usar la estructura como un espacio de nombres;  a diferencia de C ++, no se pasan impl√≠citamente estos par√°metros. <br><br><h3>  Traslados </h3><br>  En general, lo mismo que en C / C ++.  Existen algunos medios integrados convenientes para acceder a la metainformaci√≥n, por ejemplo, el n√∫mero de campos y sus nombres, implementados por macros de sintaxis incorporados en el lenguaje (que se denominan funciones integradas en la documentaci√≥n). <br><br>  Para "compatibilidad binaria con C" se proporcionan algunas enumeraciones externas. <br><br>  Para indicar el tipo que deber√≠a ser la base de la enumeraci√≥n, una construcci√≥n del formulario <br><br><pre> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  donde u8 es el tipo base. <br>  Las enumeraciones pueden tener m√©todos similares a las estructuras (es decir, usar un nombre de enumeraci√≥n como espacio de nombres). <br><br><h3>  Sindicatos </h3><br>  Seg√∫n tengo entendido, la uni√≥n en Zig es una suma de tipo algebraica, es decir  contiene un campo de etiqueta oculto que determina cu√°l de los campos de uni√≥n est√° "activo".  La "activaci√≥n" de otro campo se realiza mediante una reasignaci√≥n completa de toda la asociaci√≥n.  Ejemplo de documentaci√≥n <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  Los sindicatos tambi√©n pueden usar expl√≠citamente enumeraciones para la etiqueta. <br><br><pre> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  Los sindicatos, como las enumeraciones y las estructuras, tambi√©n pueden proporcionar su propio espacio de nombres para los m√©todos. <br><br><h3>  Tipos opcionales </h3><br>  Zig tiene soporte opcional incorporado.  Se agrega un signo de interrogaci√≥n antes del nombre del tipo: <br><br><pre> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  Curiosamente, Zig implementa una cosa sobre la posibilidad que sospechaba, pero no estaba seguro de si era correcta o no.  Los punteros se hacen compatibles con las opciones sin agregar un campo oculto adicional ("etiqueta"), que almacena un signo de la validez del valor;  y nulo se usa como un valor no v√°lido.  Por lo tanto, los tipos de referencia representados en Zig por punteros ni siquiera requieren memoria adicional para "opcionalidad".  Al mismo tiempo, est√° prohibido asignar valores nulos a punteros regulares. <br><br><h3>  Tipos de error </h3><br>  Son similares a los tipos opcionales, pero en lugar de la etiqueta booleana ("realmente inv√°lida"), se utiliza un elemento de enumeraci√≥n correspondiente al c√≥digo de error.  La sintaxis es similar a las opciones, se agrega un signo de exclamaci√≥n en lugar de un signo de interrogaci√≥n.  Por lo tanto, estos tipos se pueden usar, por ejemplo, para regresar de las funciones: se devuelve el resultado del objeto de la operaci√≥n exitosa de la funci√≥n o se devuelve un error con el c√≥digo correspondiente.  Los tipos de error son una parte importante del sistema de manejo de errores del lenguaje Zig; para m√°s detalles, consulte la secci√≥n Manejo de errores. <br><br><h3>  Tipo vac√≠o </h3><br>  Variables como anulaci√≥n y operaciones con ellas son posibles en Zig <br><br><pre> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  no se genera c√≥digo para tales operaciones;  Este tipo es principalmente √∫til para la metaprogramaci√≥n. <br><br>  Tambi√©n hay un tipo c_void para compatibilidad con C. <br><br><h2>  Operadores de control y funciones </h2><br>  Estos incluyen: bloques, cambiar, mientras, para, si, si no, romper, continuar.  Para agrupar el c√≥digo, se utilizan llaves est√°ndar.  Solo los bloques, como en C / C ++, se utilizan para limitar el alcance de las variables.  Los bloques pueden considerarse como expresiones.  No hay goto en el lenguaje, pero hay etiquetas que se pueden usar con las declaraciones break y continue.  Por defecto, estos operadores trabajan con bucles; sin embargo, si un bloque tiene una etiqueta, puede usarlo. <br><br><pre> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  La declaraci√≥n de cambio difiere del operador en que no tiene "ca√≠da", es decir  solo se ejecuta una condici√≥n (caso) y se cierra el conmutador.  La sintaxis es m√°s compacta: en lugar de may√∫sculas, se usa la flecha "=&gt;".  Switch tambi√©n se puede considerar una expresi√≥n. <br><br>  Las declaraciones while y if son generalmente las mismas que en todos los lenguajes tipo C.  La declaraci√≥n for es m√°s como foreach.  Todos ellos pueden considerarse como expresiones.  De las nuevas caracter√≠sticas, while y for, as√≠ como if, pueden tener un bloque else que se ejecuta si no hubo iteraci√≥n de bucle. <br><br>  Y aqu√≠ es el momento de hablar sobre una caracter√≠stica com√∫n para el cambio, mientras que, de alguna manera, est√° prestado del concepto de bucles foreach: variables de "captura".  Se ve as√≠: <br><br><pre> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  Aqu√≠, el argumento while es una cierta "fuente" de datos, que puede ser opcional, por ejemplo, para una matriz o un segmento, y una variable ubicada entre dos l√≠neas verticales contiene un valor "expandido", es decir,  el elemento actual de la matriz o segmento (o un puntero a √©l), el valor interno del tipo opcional (o un puntero a √©l). <br><br><h3>  Diferir y errar declaraciones </h3><br>  La declaraci√≥n de ejecuci√≥n diferida prestada de Go.  Funciona de la misma manera: el argumento de este operador se ejecuta al salir del √°mbito en el que se utiliza el operador.  Adem√°s, se proporciona el operador errdefer, que se activa si la funci√≥n devuelve un tipo de error con un c√≥digo de error activo.  Esto es parte del sistema original de manejo de errores Zig. <br><br><h3>  Operador inalcanzable </h3><br>  El elemento de la programaci√≥n del contrato.  Una palabra clave especial, que se coloca donde la administraci√≥n no debe venir bajo ninguna circunstancia.  Si llega all√≠, entonces en los modos Debug y ReleaseSafe se genera un p√°nico, y en ReleaseFast el optimizador arroja estas ramas por completo. <br><br><h3>  noreturn </h3><br>  T√©cnicamente, es un tipo compatible en expresiones con cualquier otro tipo.  Esto es posible debido a que un objeto de este tipo nunca volver√°.  Dado que los operadores son expresiones en Zig, se necesita un tipo especial para expresiones que nunca se evaluar√°n.  Esto sucede cuando el lado derecho de la expresi√≥n transfiere irrevocablemente el control a un lugar externo.  A tales declaraciones se rompen, contin√∫an, regresan, inalcanzables, bucles infinitos y funciones que nunca devuelven el control.  A modo de comparaci√≥n, una llamada a una funci√≥n regular (control de retorno) no es un operador de retorno, porque aunque el control se transfiere al exterior, tarde o temprano se devolver√° al punto de llamada. <br><br>  Por lo tanto, las siguientes expresiones se vuelven posibles: <br><br><pre> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  La variable a obtiene el valor devuelto por la instrucci√≥n if / else.  Para esto, las partes (tanto if como else) deben devolver una expresi√≥n del mismo tipo.  La parte if devuelve bool, la parte else es del tipo noreturn, que es t√©cnicamente compatible con cualquier tipo, como resultado, el c√≥digo se compila sin errores. <br><br><h3>  Las funciones </h3><br>  La sintaxis es cl√°sica para idiomas de este tipo: <br><br><pre> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  En general, las funciones se ven bastante est√°ndar.  Hasta ahora no he notado signos de funciones de primera clase, pero mi conocimiento del lenguaje es muy superficial, podr√≠a estar equivocado.  Aunque quiz√°s esto a√∫n no se haya hecho. <br><br>  Otra caracter√≠stica interesante es que en Zig, ignorar los valores devueltos solo se puede hacer expl√≠citamente usando el gui√≥n bajo _ <br><br><pre> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  Hay una reflexi√≥n que le permite obtener informaci√≥n variada sobre la funci√≥n. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2>  Ejecuci√≥n de c√≥digo en tiempo de compilaci√≥n </h2><br>  Zig proporciona una caracter√≠stica poderosa: ejecutar c√≥digo escrito en zig en tiempo de compilaci√≥n.  Para que el c√≥digo se ejecute en tiempo de compilaci√≥n, simplemente envu√©lvalo en un bloque con la palabra clave comptime.  La misma funci√≥n se puede llamar tanto en tiempo de compilaci√≥n como en tiempo de ejecuci√≥n, lo que le permite escribir c√≥digo universal.  Por supuesto, hay algunas limitaciones asociadas con diferentes contextos del c√≥digo.  Por ejemplo, en la documentaci√≥n de muchos ejemplos, comptime se usa para verificar el tiempo de compilaci√≥n: <br><br><pre> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  Pero, por supuesto, el poder de este operador est√° lejos de ser completamente revelado aqu√≠.  Entonces, en la descripci√≥n del lenguaje, se da un ejemplo cl√°sico del uso efectivo de macros sint√°cticas: la implementaci√≥n de una funci√≥n similar a printf, pero analizando la cadena de formato y realizando todas las verificaciones de tipo necesarias de los argumentos en la etapa de compilaci√≥n. <br><br>  Adem√°s, la palabra comptime se usa para indicar los par√°metros de las funciones de tiempo de compilaci√≥n, que es similar a las funciones de plantilla de C ++. <br><br><pre> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2>  Manejo de errores </h2><br>  Zig invent√≥ un sistema original de manejo de errores que no era como otros idiomas.  Esto se puede llamar "excepciones expl√≠citas" (en este lenguaje, la explicidad es generalmente uno de los modismos).  Tambi√©n se parece a los c√≥digos de retorno de Go, pero funciona de manera diferente. <br><br>  El sistema de procesamiento de errores Zig se basa en enumeraciones especiales para implementar c√≥digos de error personalizados (error) y se basa en sus "tipos de error" (suma de tipo algebraico, que combina el tipo de funci√≥n devuelto y el c√≥digo de error). <br><br>  Las enumeraciones de error se declaran de la misma manera que las enumeraciones regulares: <br><br><pre> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  Sin embargo, todos los c√≥digos de error reciben valores mayores que cero;  Adem√°s, si declara un c√≥digo con el mismo nombre en dos enumeraciones, recibir√° el mismo valor.  Sin embargo, las conversiones impl√≠citas entre diferentes enumeraciones de errores est√°n prohibidas. <br><br>  La palabra clave anyerror significa una enumeraci√≥n que incluye todos los c√≥digos de error. <br><br>  Al igual que los tipos opcionales, el lenguaje admite la generaci√≥n de tipos de error utilizando una sintaxis especial.  Type! U64 es una forma abreviada de anyerror! U64, que a su vez significa una uni√≥n (opci√≥n), que incluye el tipo u64 y type anyerror (seg√∫n tengo entendido, el c√≥digo 0 est√° reservado para indicar la ausencia de un error y la validez del campo de datos, el resto de los c√≥digos son en realidad c√≥digos de error). <br><br>  La palabra clave catch le permite detectar el error y convertirlo en un valor predeterminado: <br><br><pre> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  Entonces, si ocurre un error en la funci√≥n parseU64 que devuelve el tipo! U64, entonces catch lo "interceptar√°" y devolver√° el valor predeterminado de 13. <br><br>  La palabra clave try le permite "reenviar" el error al nivel superior (es decir, al nivel de la funci√≥n de llamada).  Ver c√≥digo <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  equivalente a esto: <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  Aqu√≠ sucede lo siguiente: se llama a parseU64, si se devuelve un error: se intercepta mediante la instrucci√≥n catch, en la que el c√≥digo de error se extrae utilizando la sintaxis de "captura", colocada en la variable err, que se devuelve mediante! Void a la funci√≥n de llamada. <br><br>  El operador Errdefer descrito anteriormente tambi√©n se refiere al manejo de errores.  El c√≥digo de argumento Errdefer se ejecuta solo si la funci√≥n devuelve un error. <br><br>  Algunas posibilidades m√°s.  Usando el ||  puedes combinar conjuntos de errores <br><br><pre> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  Zig tambi√©n proporciona caracter√≠sticas como el seguimiento de errores.  Esto es algo similar a un seguimiento de pila, pero contiene informaci√≥n detallada sobre qu√© error ocurri√≥ y c√≥mo se propag√≥ a lo largo de la cadena de prueba desde el lugar de ocurrencia hasta la funci√≥n principal del programa. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, el sistema de manejo de errores en Zig es una soluci√≥n muy original, que no parece excepciones en C ++ o c√≥digos de retorno en Go. </font><font style="vertical-align: inherit;">Podemos decir que dicha soluci√≥n tiene un precio determinado: 4 bytes adicionales, que deben devolverse con cada valor devuelto; </font><font style="vertical-align: inherit;">ventajas obvias son visibilidad y transparencia absolutas. </font><font style="vertical-align: inherit;">A diferencia de C ++, aqu√≠ la funci√≥n no puede lanzar una excepci√≥n desconocida desde alg√∫n lugar en la profundidad de la cadena de llamadas. </font><font style="vertical-align: inherit;">Todo lo que devuelve la funci√≥n: regresa expl√≠citamente y solo expl√≠citamente.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corutinas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig tiene corutinas incorporadas. </font><font style="vertical-align: inherit;">Estas son funciones que se crean con la palabra clave asincr√≥nica, con la ayuda de las cuales se transfieren las funciones del asignador y el asignador de negocios (seg√∫n tengo entendido, para una pila adicional).</font></font><br><br><pre> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async devuelve un objeto especial de tipo promise-&gt; T (donde T es el tipo de retorno de la funci√≥n). Con este objeto, puede controlar la rutina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los niveles m√°s bajos incluyen las palabras clave suspender, reanudar y cancelar. Usando suspender, la ejecuci√≥n de rutina se pausa y se pasa al programa de llamada. La sintaxis del bloque de suspensi√≥n es posible; todo lo que est√° dentro del bloque se ejecuta hasta que la rutina se suspende realmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resume toma un argumento de tipo promise-&gt; T y reanuda la ejecuci√≥n de la rutina desde donde se suspendi√≥. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancelar libera memoria de rutina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta imagen muestra la transferencia de control entre el programa principal (en forma de prueba) y la rutina. Todo es bastante simple:</font></font><br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="imagen"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda caracter√≠stica (nivel superior) es el uso de esperar. </font><font style="vertical-align: inherit;">Esto es lo √∫nico que, francamente, no he descubierto (por desgracia, la documentaci√≥n a√∫n es muy escasa). </font><font style="vertical-align: inherit;">Aqu√≠ est√° el diagrama de transferencia de control real de un ejemplo ligeramente modificado de la documentaci√≥n, tal vez esto le explique algo:</font></font><br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="imagen"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funciones incorporadas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciones integradas: un conjunto bastante grande de funciones integradas en el lenguaje y que no requieren la conexi√≥n de ning√∫n m√≥dulo. Quiz√°s sea m√°s correcto llamar a algunos de ellos "macros sint√°cticas incorporadas", porque las capacidades de muchos van mucho m√°s all√° de las funciones. los incorporados proporcionan acceso a herramientas de reflexi√≥n (sizeOf, tagName, TagType, typeInfo, typeName, typeOf), con sus m√≥dulos de ayuda (importaci√≥n) conectados. Otros se parecen m√°s al cl√°sico C / C ++ incorporado: implementan conversiones de tipo de bajo nivel, diversas operaciones como sqrt, popCount, slhExact, etc. Es muy probable que la lista de funciones incorporadas cambie a medida que se desarrolle el lenguaje.</font></font><br><br><h3>  En conclusi√≥n </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es muy agradable que tales proyectos aparezcan y se desarrollen. </font><font style="vertical-align: inherit;">Aunque el lenguaje C es conveniente, conciso y familiar para muchos, todav√≠a est√° desactualizado y por razones arquitect√≥nicas no puede soportar muchos conceptos de programaci√≥n modernos. </font><font style="vertical-align: inherit;">C ++ se est√° desarrollando, pero redise√±ado objetivamente, se est√° volviendo cada vez m√°s dif√≠cil con cada nueva versi√≥n, y por las mismas razones arquitect√≥nicas y debido a la necesidad de compatibilidad con versiones anteriores, no se puede hacer nada al respecto. </font><font style="vertical-align: inherit;">El √≥xido es interesante, pero con un umbral de entrada muy alto, que no siempre est√° justificado. </font><font style="vertical-align: inherit;">D es un buen intento, pero hay algunas fallas menores, parece que inicialmente el lenguaje se cre√≥ m√°s probablemente bajo la influencia de Java, y las caracter√≠sticas posteriores se introdujeron de alguna manera, de alguna manera, no como deber√≠an. </font><font style="vertical-align: inherit;">Obviamente, Zig es otro de esos intentos. </font><font style="vertical-align: inherit;">El lenguaje es interesante, y es interesante ver qu√© sale de √©l.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435872/">https://habr.com/ru/post/es435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435862/index.html">Sal√≥n de la fama de la electr√≥nica de consumo: las historias de los mejores artilugios de los √∫ltimos 50 a√±os, parte 4</a></li>
<li><a href="../es435864/index.html">Solicitudes de mapeo para Netty</a></li>
<li><a href="../es435866/index.html">Release IT: una nueva plataforma para el lanzamiento de productos y servicios como parte del festival SXSW 2019</a></li>
<li><a href="../es435868/index.html">Slush 2018. D√≠a de vista previa</a></li>
<li><a href="../es435870/index.html">Orquesta Cibern√©tica. Docker Container Orchestration con aplicaciones .NET Core en la nube</a></li>
<li><a href="../es435876/index.html">Configuraci√≥n detallada del navegador Firefox</a></li>
<li><a href="../es435878/index.html">Amateur en c√≥digo abierto - lecciones aprendidas en 3 a√±os</a></li>
<li><a href="../es435880/index.html">Cambiar el esquema de tablas PostgreSQL sin bloqueos largos. Conferencia de Yandex</a></li>
<li><a href="../es435882/index.html">Revisi√≥n de Xiaomi Mi Box S y una peque√±a comparaci√≥n con Mi Box 3</a></li>
<li><a href="../es435884/index.html">B√∫squeda de metales y ... red neuronal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>