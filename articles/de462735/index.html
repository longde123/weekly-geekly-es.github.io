<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéß ‚ôøÔ∏è üëßüèø Zuverl√§ssiger Stresstest unter Ber√ºcksichtigung unvorhergesehener Nuancen üë©üèº‚Äçüåæ üçí üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben vor einem Jahr dar√ºber nachgedacht, die Infrastruktur f√ºr Tests mit gro√üer Last aufzubauen, als wir die Marke von 12.000 Online-Benutzern er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zuverl√§ssiger Stresstest unter Ber√ºcksichtigung unvorhergesehener Nuancen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/miro/blog/462735/"> Wir haben vor einem Jahr dar√ºber nachgedacht, die Infrastruktur f√ºr Tests mit gro√üer Last aufzubauen, als wir die Marke von 12.000 Online-Benutzern erreichten, die gleichzeitig in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem Service</a> arbeiten.  F√ºr 3 Monate haben wir die erste Version des Tests gemacht, die die Grenzen des Dienstes zeigte. <br><br>  Die Ironie des Schicksals ist, dass wir zur gleichen Zeit, als der Test gestartet wurde, die Grenzen des Produkts erreichten, wodurch der Service um 2 Stunden sank.  Dies ermutigte uns au√üerdem, von der Durchf√ºhrung von Tests von Fall zu Fall zur Schaffung einer effektiven tragenden Infrastruktur √ºberzugehen.  Mit Infrastruktur meine ich alle Tools f√ºr die Arbeit mit der Last: Tools zum Starten und Autostarten, ein Cluster zum Laden der Last, ein Cluster, ein √§hnliches Produkt, Services zum Sammeln von Metriken und zum Erstellen von Berichten, Code zum Verwalten all dieser und Services zum Skalieren. <br><br><img src="https://habrastorage.org/webt/mw/kz/jl/mwkzjls34yw96qxg5lu9ubf-0bs.png"><br><a name="habracut"></a><br>  So vereinfacht sieht das miro.com-Schema aus: Es gibt viele verschiedene Server, die irgendwie miteinander interagieren, und jeder f√ºhrt bestimmte Aufgaben aus.  Es scheint, dass es f√ºr den Aufbau der Infrastruktur f√ºr Auslastungstests ausreichte, ein solches Schema zu zeichnen, alle Beziehungen zu ber√ºcksichtigen und jeden Block nacheinander mit Skripten abzudecken.  Dieser Ansatz ist gut, aber es w√ºrde viele Monate dauern, was f√ºr uns aufgrund des schnellen Wachstums nicht geeignet war. In den letzten sechs Monaten sind wir von 12.000 auf 20.000 Online-Benutzer gewachsen, die gleichzeitig im Dienst arbeiten.  Dar√ºber hinaus wussten wir nicht, wie die Infrastruktur unseres Dienstes auf eine Zunahme der Last reagieren wird: Welcher der Bl√∂cke wird zu einem Engpass und welcher kann linear skaliert werden. <br><br>  Aus diesem Grund haben wir uns entschlossen, den Service mit virtuellen Benutzern zu testen und ihre realistische Arbeit zu simulieren, dh einen Produktionsklon zu erstellen und einen gro√üen Test durchzuf√ºhren. <br><br><ul><li>  Laden Sie einen Cluster, dessen Struktur mit der Produktion identisch ist, dessen Leistung jedoch voraus ist. </li><li>  Geben Sie uns alle Daten, um Entscheidungen zu treffen. </li><li>  wird zeigen, dass die gesamte Infrastruktur der richtigen Last standhalten kann; </li><li>  wird die Grundlage f√ºr Stresstests sein, die wir m√∂glicherweise in Zukunft ben√∂tigen. </li></ul><br>  Das einzige Minus eines solchen Tests ist sein Selbstkostenpreis, denn daf√ºr brauchen wir eine Umgebung, die gr√∂√üer ist als die Produktionsumgebung. <br><br>  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie ein realistisches Szenario erstellen, Plugins - WS, Stress-Client, Stier, - Cluster laden, Cluster verkaufen und Beispiele f√ºr die Verwendung von Tests zeigen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der n√§chste Artikel</a> befasst sich mit der Verwaltung von Hunderten von Servern f√ºr einen Auslastungstest. <br><br><h2>  Erstellen Sie ein realistisches Szenario </h2><br>  Um ein realistisches Szenario zu erstellen, ben√∂tigen wir: <br><br><ul><li>  Analysieren Sie die Arbeit der Benutzer am Produkt und bestimmen Sie dazu die f√ºr uns wichtigen Metriken, sammeln Sie sie regelm√§√üig und analysieren Sie die Spr√ºnge. </li><li>  Erstellen Sie bequeme benutzerdefinierte Bl√∂cke, mit denen wir den erforderlichen Teil der Gesch√§ftslogik effizient laden k√∂nnen. </li><li>  √úberpr√ºfen Sie den Skriptrealismus mit Servermetriken. </li></ul><br>  Nun mehr zu jedem Artikel. <br><br>  <b>Analyse der Benutzerarbeit an prod</b> <br><br>  In unserem Service k√∂nnen Benutzer Boards erstellen und mit verschiedenen Inhalten daran arbeiten: Fotos, Texte, Mocapas, Aufkleber, Diagramme usw.  Die erste Metrik, die wir sammeln m√ºssen, ist die Anzahl der Boards und die Verteilung der Inhalte darauf. <br><br><img align="left" src="https://habrastorage.org/webt/uq/ah/cp/uqahcpsgmjnzqao48ivvrhgzuvc.png" width="400" height="500"><br>  Auf demselben Board k√∂nnen einige Benutzer zum gleichen Zeitpunkt aktiv etwas tun - erstellen, l√∂schen, bearbeiten - und andere k√∂nnen einfach das erstellte Material anzeigen.  Dies ist auch eine wichtige Messgr√∂√üe - das Verh√§ltnis der Anzahl der Benutzer, die den Inhalt des Boards √§ndern, zur Gesamtzahl der Benutzer eines Boards.  Dies k√∂nnen wir auf der Grundlage von Statistiken √ºber die Arbeit mit der Datenbank erhalten. <br><br>  In unserem Backend verwenden wir den Komponentenansatz.  Komponenten, die wir Modelle nennen.  Wir teilen unseren Code in Modelle auf, sodass f√ºr jeden Teil der Gesch√§ftslogik ein bestimmtes Modell verantwortlich ist.  Wir k√∂nnen die Anzahl der Datenbankaufrufe berechnen, die in jedem Modell auftreten, und verstehen, welcher Teil der Logik die Datenbank am meisten l√§dt. <br><br><img src="https://habrastorage.org/webt/-d/zu/iu/-dzuiu9istykhoantxrs-po64ky.png"><br><br>  <b>Praktische benutzerdefinierte Bl√∂cke</b> <br><br>  Zum Beispiel m√ºssen wir dem Skript einen Block hinzuf√ºgen, der unseren Service genauso l√§dt, wie es passiert, wenn Sie eine Dashboard-Seite mit einer Liste von Benutzer-Boards √∂ffnen.  W√§hrend des Ladens dieser Seite werden http-Anfragen mit einer gro√üen Datenmenge gesendet: die Anzahl der Boards, die Konten, auf die der Benutzer Zugriff hat, alle Benutzer des Kontos usw. <br><br><img src="https://habrastorage.org/webt/zb/j1/sx/zbj1sxyfvbkfbotawsqnegvz8zg.gif"><br><br>  Wie lade ich ein Dashboard effektiv?  Bei der Analyse des Produktionsverhaltens wurden beim √ñffnen des Dashboards eines gro√üen Kontos Lastspitzen in der Datenbank festgestellt.  Wir k√∂nnen ein identisches Konto neu erstellen und die Intensit√§t der Verwendung seiner Daten im Skript √§ndern, wodurch ein Dashboard mit einer geringen Anzahl von Treffern effektiv geladen wird.  Wir k√∂nnen auch eine ungleichm√§√üige Last f√ºr mehr Realismus schaffen. <br><br>  Gleichzeitig ist es uns wichtig, dass die Anzahl der virtuellen Benutzer und die von ihnen erzeugte Last den Benutzern und der Produktionslast so √§hnlich wie m√∂glich sind.  Zu diesem Zweck erstellen wir im Test auch die Hintergrundlast des durchschnittlichen Dashboards neu.  Daher arbeiten die meisten virtuellen Benutzer mit kleinen durchschnittlichen Dashboards, und nur wenige Benutzer verursachen eine katastrophale Last, wie dies in der Produktion der Fall ist. <br><br>  Anfangs wollten wir nicht jede Serverrolle und jede Beziehung mit einem separaten Skript behandeln.  Dies ist im Beispiel mit dem Dashboard zu sehen - wir wiederholen einfach w√§hrend des Tests, was passiert, wenn das Dashboard auf dem Produkt ge√∂ffnet wird, wenn der Benutzer es √∂ffnet, und wir behandeln nicht, was es mit synthetischen Skripten beeinflusst.  Auf diese Weise k√∂nnen Sie standardm√§√üig Nuancen testen, die wir nicht einmal erwartet haben.  Daher n√§hern wir uns der Erstellung eines Infrastrukturtests von der Seite der Gesch√§ftslogik. <br><br>  Wir haben diese Logik verwendet, um alle anderen Bl√∂cke des Dienstes effektiv zu laden.  Gleichzeitig ist jeder einzelne Block unter dem Gesichtspunkt der Logik der Verwendung der Funktion m√∂glicherweise nicht realistisch.  Es ist wichtig, dass die Server realistisch belastet werden.  Und dann k√∂nnen wir aus diesen Bl√∂cken ein Skript erstellen, das die eigentliche Arbeit der Benutzer imitiert. <br><br><img src="https://habrastorage.org/webt/wk/gc/po/wkgcporetjxwqqbca-qfeedkuam.png"><br><br><h3>  Daten sind Teil des Skripts. </h3><br>  Beachten Sie, dass Daten auch Teil des Skripts sind und die Logik des Codes selbst stark von den Daten abh√§ngt.  Wenn Sie eine gro√üe Datenbank f√ºr den Test erstellen - und diese sollte nat√ºrlich f√ºr einen gro√üen Infrastrukturtest gro√ü sein -, m√ºssen Sie lernen, wie Sie Daten erstellen, die w√§hrend der Ausf√ºhrung des Skripts keine Rolle spielen.  Wenn Sie Junk-Daten sammeln, kann sich das Skript als unrealistisch herausstellen, und eine gro√üe Datenbank ist schwer zu reparieren.  Aus diesem Grund haben wir begonnen, die Rest-API zu verwenden, um Daten auf die gleiche Weise wie unsere Benutzer zu erstellen. <br><br>  Um beispielsweise Karten mit den verf√ºgbaren Daten zu erstellen, f√ºhren wir API-Anforderungen aus, um Karten aus der Sicherung zu laden.  Als Ergebnis erhalten wir ehrliche reale Daten - verschiedene Boards unterschiedlicher Gr√∂√üe.  Gleichzeitig wird die Datenbank ziemlich schnell gef√ºllt, da wir Anforderungen im Skript multithreaded abrufen.  In der Geschwindigkeit ist dies vergleichbar mit der Erzeugung von M√ºlldaten. <br><br><h3>  Ergebnisse f√ºr diesen Teil </h3><br><ul><li>  Verwenden Sie realistische Szenarien, wenn Sie alles auf einmal √ºberpr√ºfen m√∂chten. </li><li>  Analysieren Sie das tats√§chliche Benutzerverhalten, um die Skriptstruktur zu entwerfen. </li><li>  Erstellen Sie sofort praktische Bl√∂cke zur Anpassung. </li><li>  Konfigurieren Sie anhand realer Servermetriken und nicht anhand von Nutzungsanalysen. </li><li>  Denken Sie daran, dass Daten Teil des Skripts sind. </li></ul><br><h2>  Cluster laden </h2><br>  Schema der Werkzeuge zum Aufbringen der Last: <br><br><img src="https://habrastorage.org/webt/sw/gb/wg/swgbwgmqvkv2r8uue1tkrv5oyve.png"><br><br>  In Jmeter erstellen wir ein Skript, das wir mit Taurus starten und damit verschiedene Server laden: Web-, API- und Board-Server.  Wir f√ºhren Datenbanktests separat mit Postgresql und nicht mit Jmeter durch, daher zeigt das Diagramm eine gestrichelte Linie. <br><br><h3>  Benutzerdefinierte Arbeit in Web-Socket </h3><br>  Die Arbeit an der Karte erfolgt innerhalb der WS-Verbindung, und an der Karte ist Mehrbenutzerarbeit m√∂glich.  In der Jmeter-Box im Plug-In-Manager befinden sich jetzt mehrere Plug-Ins f√ºr die Arbeit mit dem Web-Socket.  Die Logik ist √ºberall gleich - Plugins √∂ffnen einfach eine Web-Socket-Verbindung, aber alle Aktionen, die darin ausgef√ºhrt werden, m√ºssen Sie auf jeden Fall selbst schreiben.  Warum?  Da wir nicht wie bei http-Anfragen arbeiten k√∂nnen, k√∂nnen wir kein Skript schreiben, dynamische Werte mit Extraktoren abrufen und weiter √ºberspringen. <br><br>  Die Arbeit innerhalb des Web-Sockets ist normalerweise sehr benutzerdefiniert: Sie rufen bestimmte Methoden mit bestimmten benutzerdefinierten Daten auf und m√ºssen dementsprechend selbst verstehen, ob die Anforderung korrekt ausgef√ºhrt wurde und wie lange die Ausf√ºhrung gedauert hat.  Der Listener in diesem Plugin ist ebenfalls unabh√§ngig geschrieben, wir haben keine gute vorgefertigte L√∂sung gefunden. <br><br><h3>  Stress-Klient </h3><br>  Wir m√∂chten so einfach wie m√∂glich wiederholen, was echte Benutzer tun.  Wir wissen jedoch nicht, wie wir aufzeichnen und wiedergeben sollen, was im Browser in WS geschieht.  Wenn wir alles in WS von Grund auf neu schreiben, erhalten wir einen neuen Client und nicht den, den echte Benutzer verwenden.  Ich habe keine Lust, einen neuen Kunden zu schreiben, wenn wir bereits einen haben. <br><br>  Aus diesem Grund haben wir uns entschlossen, unseren Kunden in Jmeter zu platzieren.  Und mit einer Reihe von Schwierigkeiten konfrontiert.  Zum Beispiel ist das Ausf√ºhren von js in Jmeter eine separate Geschichte  Dies ist eine absolut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spezifische Version der</a> unterst√ºtzten Funktionen.  Und wenn Sie Ihren vorhandenen Client-Code verwenden m√∂chten, werden Sie h√∂chstwahrscheinlich keinen Erfolg haben, da Konstruktionen mit neuen Rei√üz√§hnen hier nicht gestartet werden k√∂nnen. Sie m√ºssen neu geschrieben werden. <br><br>  Die zweite Schwierigkeit besteht darin, dass wir nicht den gesamten Client-Code f√ºr Auslastungstests unterst√ºtzen m√∂chten.  Daher haben wir alles √úberfl√ºssige vom Client entfernt und nur die Client-Server-Interaktion belassen.  Dies erm√∂glichte es uns, Client-Server-Methoden zu verwenden und alles zu tun, was unser Client tun kann.  Das Plus ist, dass sich die Client-Server-Interaktion √§u√üerst selten √§ndert, was bedeutet, dass Codeunterst√ºtzung innerhalb des Skripts selten erforderlich ist.  Zum Beispiel habe ich in den letzten sechs Monaten nie √Ñnderungen am Code vorgenommen, weil er gro√üartig funktioniert. <br><br>  Die dritte Schwierigkeit - das Erscheinen gro√üer Skripte erschwert das Skript erheblich.  Erstens kann es zu einem Engpass im Test werden.  Zweitens werden wir h√∂chstwahrscheinlich nicht in der Lage sein, eine gro√üe Anzahl von Threads von einer Maschine aus zu starten.  Jetzt k√∂nnen wir nur noch 730 Threads starten. <br><br>  <b>Unser Beispiel f√ºr eine Amazon-Instanz</b> <br><br><pre><code class="plaintext hljs"> Jmeter server  AWS: m5.large ($0.06 per Hour) vCPU: 2 Mem (GiB): 8 Dedicated EBS Bandwidth (Mbps): Up to 3,500 Network Performance (Gbps): Up to 10 ‚Üí ~730 </code> </pre> <br><h3>  Wo man Hunderte von Servern bekommt und wie man spart </h3><br>  Als n√§chstes stellt sich die Frage: 730 Threads von einer Maschine, aber wir wollen 50K.  Wo kann man so viele Server anheben?  Wir erstellen eine Cloud-L√∂sung, daher erscheint es seltsam, Server zum Testen einer Cloud-L√∂sung zu kaufen.  Au√üerdem ist es beim Kauf von neuem Eisen immer eine gewisse Langsamkeit.  Daher m√ºssen wir sie auch in der Cloud erh√∂hen, sodass wir uns letztendlich zwischen Cloud-Anbietern und Cloud-Load-Tools entschieden haben. <br><br>  Wir haben keine Cloud-Load-Tools wie Blazemeter und RedLine13 verwendet, da sie Nutzungsbeschr√§nkungen haben, die nicht zu uns passen.  Wir haben verschiedene Teststandorte, daher wollten wir eine universelle L√∂sung finden, mit der 90% der Entwicklungen verwendet werden k√∂nnen, auch in lokalen Tests. <br><br>  Aus diesem Grund haben wir uns zwischen Cloud-Anbietern entschieden. <br><br><img src="https://habrastorage.org/webt/ud/35/8n/ud358nhlnnsa9uopiwpfisoipa8.png"><br><br>  Unsere Produktion erfolgt auf AWS, daher testen wir haupts√§chlich dort und m√∂chten, dass der Pr√ºfstand der Produktion so √§hnlich wie m√∂glich ist.  Amazon verf√ºgt √ºber viele kostenpflichtige Funktionen, von denen einige im Produkt verwendet werden, z. B. Balancer.  Wenn diese Funktionen in AWS nicht ben√∂tigt werden, k√∂nnen Sie sie in Hetzner 17-mal g√ºnstiger verwenden.  Oder Sie k√∂nnen den Server in Hetzner behalten, Openstack verwenden und Balancer und andere Funktionen selbst schreiben, da Sie mit Openstack die gesamte Infrastruktur wiederholen k√∂nnen.  Wir haben es geschafft. <br><br>  Das Testen von 50.000 Benutzern mit 69 Instanzen in AWS kostet uns ungef√§hr 3.000 USD pro Monat.  Wie speichere ich?  Beispielsweise verf√ºgt AWS √ºber tempor√§re Instanzen - Spot-Instanzen.  Ihre Coolness ist, dass wir sie nicht st√§ndig behalten, sondern nur f√ºr die Dauer der Tests erh√∂hen und sie viel weniger kosten.  Die Nuance ist, dass jemand anderes sie zum Zeitpunkt unseres Tests zu einem h√∂heren Preis kaufen kann.  Gl√ºcklicherweise ist dies noch nie passiert, aber wir sparen bereits mindestens 60% der Kosten auf ihre Kosten. <br><br><h2>  Cluster laden </h2><br>  Wir verwenden das Jmeter-Box-Cluster.  Es funktioniert gro√üartig, es muss in keiner Weise modifiziert werden.  Es gibt mehrere Startoptionen.  Wir verwenden die einfachste Methode, wenn ein Assistent N Instanzen startet, von denen es m√∂glicherweise Hunderte gibt. <br><br><img src="https://habrastorage.org/webt/vz/oj/di/vzojdipz783bcxk6va84kxuu1ga.png"><br><br>  Der Assistent f√ºhrt das Skript auf Jmeter-Servern aus, w√§hrend er mit ihnen in Kontakt bleibt, sammelt allgemeine Statistiken aller Instanzen in Echtzeit und zeigt sie in der Konsole an.  All dies sieht genauso aus wie das Ausf√ºhren des Skripts auf einem Server, obwohl wir die Ergebnisse des Starts auf hundert Servern sehen. <br><br>  F√ºr eine detaillierte Analyse der Ergebnisse der Skriptausf√ºhrung in allen Instanzen verwenden wir Kibana.  Parsim-Protokolle mit Filebeat. <br><br><img src="https://habrastorage.org/webt/lp/2i/es/lp2ieslbdsgadsr41ydhss4vtco.png"><br><br><h3>  Ein Prometheus Listener f√ºr Apache JMeter </h3><br>  Jmeter verf√ºgt √ºber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin f√ºr die Arbeit mit Prometheus</a> , das sofort alle Statistiken zur Verwendung von JVM und Threads im Test enth√§lt.  Auf diese Weise k√∂nnen Sie sehen, wie oft sich Benutzer anmelden, abmelden usw.  Das Plugin kann angepasst werden, um Daten des Skripts an Prometheus zu senden und sie in Echtzeit in Grafana anzuzeigen. <br><br><img src="https://habrastorage.org/webt/mw/ig/3m/mwig3mwxuq6p7rexf1hq9nc8gek.png"><br><br><h3>  Stier </h3><br>  Wir m√∂chten eine Reihe aktueller Probleme mit Taurus l√∂sen, haben uns aber noch nicht damit befasst: <br><br><ul><li>  Konfigurationen anstelle von Skriptklonen.  Wenn Sie auf Jmeter getestet haben, mussten Sie wahrscheinlich Skripte mit verschiedenen S√§tzen von Quellparametern ausf√ºhren, f√ºr die Sie deren Klone erstellen mussten.  In Taurus ist es m√∂glich, ein Szenario zu haben und mithilfe von Konfigurationen die Startparameter zu steuern. </li><li>  Konfigurationen zum Verwalten von Jmeter-Servern bei der Arbeit mit einem Cluster; </li><li>  Ein Online-Ergebnisanalysator, mit dem Sie Ergebnisse getrennt von Jmeter-Threads erfassen und das Skript selbst nicht belasten k√∂nnen. </li><li>  Bequeme Integration mit CI; </li><li>  Die F√§higkeit, ein verteiltes System zu testen. </li></ul><br><h3>  Die Ergebnisse dieses Teils </h3><br><ul><li>  Wenn wir den Code in Jmeter verwenden, ist es besser, sofort √ºber seine Leistung nachzudenken, da wir sonst Jmeter testen k√∂nnen, nicht unser Produkt. </li><li>  Das Jmeter-Cluster ist eine wunderbare Sache: Es ist einfach zu konfigurieren, die √úberwachung l√§sst sich leicht daran anschlie√üen. </li><li>  Ein gro√üer Cluster kann vor Ort gehalten werden, es ist viel billiger; </li><li>  Seien Sie vorsichtig mit Listenern im Jmeter, damit das Skript die Arbeit auf einer gro√üen Anzahl von Servern nicht verlangsamt. </li></ul><br><h2>  Beispiele f√ºr die Verwendung von Infrastrukturtests </h2><br>  In der gesamten obigen Geschichte geht es haupts√§chlich darum, ein realistisches Szenario f√ºr einen Service-Limit-Test zu erstellen.  Die folgenden Beispiele zeigen, wie Sie die Infrastruktur von Auslastungstests wiederverwenden k√∂nnen, um lokale Probleme zu l√∂sen.  Ich werde im Detail √ºber zwei Tests sprechen, aber im Allgemeinen f√ºhren wir regelm√§√üig etwa 10 Arten von Belastungstests durch. <br><a name="database"></a><br><h3>  Datenbanktests </h3><br>  Was k√∂nnen wir Test in die Datenbank laden?  Schwere Abfragen sind unwahrscheinlich, da wir sie im Single-Thread-Modus testen k√∂nnen, wenn wir uns nur die Abfragepl√§ne ansehen. <br><br>  Eine interessante Situation ist, wenn wir den Test ausf√ºhren und die Last auf der Festplatte sehen.  Die Grafik zeigt, wie iowait steigt. <br><br><img src="https://habrastorage.org/webt/o9/7i/wy/o97iwyqnwc7rdo6utv-xjoe-p_c.png"><br><br>  Weiter sehen wir, dass dies Benutzer betrifft. <br><br><img src="https://habrastorage.org/webt/3z/c_/ia/3zc_iawonyc_jwscpgs4fl8yi1a.png"><br><br>  Wir verstehen den Grund: Vakuum hat nicht funktioniert und keine M√ºlldaten aus der Datenbank gel√∂scht.  Wenn Sie noch nicht mit Postgresql gearbeitet haben, ist Vacuum genau wie der Garbage Collector in Java. <br><br><img src="https://habrastorage.org/webt/2l/ks/vr/2lksvred5j50eummkssdxyw7i1w.png"><br><br>  Weiter sehen wir, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Checkpoint</a> anfing, au√üerhalb des Zeitplans zu arbeiten.  F√ºr uns ist dies ein Signal daf√ºr, dass Postgresql-Konfigurationen nicht der Intensit√§t der Arbeit mit der Datenbank entsprechen. <br><br><img src="https://habrastorage.org/webt/le/sx/cb/lesxcbanlw_j5iyhm0bawfrq4ic.png"><br><br>  Unsere Aufgabe ist es, die Datenbank richtig zu konfigurieren, damit solche Situationen nicht erneut auftreten.  Das gleiche Postgresql hat viele Einstellungen.  F√ºr die Feinabstimmung m√ºssen Sie in kurzen Iterationen arbeiten: Die Konfiguration korrigiert, gestartet, √ºberpr√ºft, die Konfiguration korrigiert, gestartet, √ºberpr√ºft.  Dazu m√ºssen Sie nat√ºrlich eine gute Last auf die Basis aufbringen, aber daf√ºr ben√∂tigen Sie nur gro√üe Infrastrukturtests. <br><br>  Die Besonderheit ist, dass das √úbertakten langwierig sein sollte, damit der Test normal beschleunigt und nicht dorthin f√§llt, wo er nicht ben√∂tigt wird.  Der Test dauert ungef√§hr drei Stunden, und dies sieht nicht mehr nach kurzen Iterationen aus. <br><br>  Wir suchen nach einer L√∂sung.  Wir finden eines der Postgresql-Tools - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pg_replay</a> .  Er kann mehrere Threads genau reproduzieren, was in den Protokollen geschrieben ist und genau so, wie es zum Zeitpunkt ihrer Aufzeichnung geschehen ist.  Wie k√∂nnen wir es effektiv nutzen?  Wir reduzieren den Datenbankspeicherauszug, protokollieren dann alles, was nach dem Speichern in den Protokollen mit der Datenbank passiert, und haben dann die M√∂glichkeit, den Speicherauszug bereitzustellen und alles abzuspielen, was mit dem Multithread-Datenbankprogramm passiert ist. <br><br>  Wo schreibe ich Protokolle?  Eine beliebte L√∂sung zum Aufzeichnen von Protokollen besteht darin, sie auf dem Produkt zu sammeln, da dies das realistischste reproduzierbare Skript ergibt.  Es gibt jedoch eine Reihe von Problemen: <br><br><ul><li>  F√ºr den Test m√ºssen Sie die Verkaufsdaten verwenden, was nicht immer m√∂glich ist. </li><li>  Der Prozess verwendet eine teure Syslog-Operation. </li><li>  Die Festplatte wird geladen. </li></ul><br>  Unser Ansatz f√ºr gro√üe Tests hilft uns hier.  Wir machen einen Dump in einer Testumgebung, f√ºhren einen gro√üen Test durch und zeichnen die Protokolle von allem auf, was zum Zeitpunkt der Ausf√ºhrung des realistischen Skripts passiert.  Als n√§chstes verwenden wir unser eigenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marucy-</a> Tool, um die Datenbank zu testen: <br><ol><li>  Eine Instanz wird in AWS erstellt. </li><li>  Der Dump, den wir ben√∂tigen, wird bereitgestellt. </li><li>  Pg_replay wird gestartet und spielt die erforderlichen Protokolle ab. </li><li>  Wir verwenden unsere √úberwachung, um das Ergebnis von Prometheus + Grafana zu analysieren.  Es gibt Beispiele f√ºr Dashboards im Repository. </li></ol><br>  Wenn wir marucy starten, k√∂nnen wir eine kleine Anzahl von Parametern √ºbergeben, die ge√§ndert werden k√∂nnen, z. B. die Intensit√§t des Skripts. <br><br>  Daher verwenden wir unser realistisches Skript, um einen Test zu erstellen, und spielen den Test dann ohne Verwendung eines gro√üen Clusters ab.  Es ist wichtig zu ber√ºcksichtigen, dass das Skript zum Testen einer SQL-Datenbank ungleichm√§√üig sein muss, da sich sonst die Datenbank selbst anders verh√§lt als das Produkt. <br><br><h3>  Abbau√ºberwachung </h3><br>  F√ºr Degradationstests verwenden wir unser realistisches Szenario.  Die Idee ist, dass wir sicherstellen m√ºssen, dass der Dienst nach der n√§chsten Version nicht langsamer arbeitet.  Wenn unsere Entwickler den Code √§ndern, was zu einer Verl√§ngerung der Ausf√ºhrungszeit von Anforderungen f√ºhrt, k√∂nnen wir die neuen Werte mit den Referenzwerten vergleichen und signalisieren, ob der Build einen Fehler aufweist.  F√ºr Referenzwerte nehmen wir die aktuellen Werte, die zu uns passen. <br><br>  Die Steuerung der Ausf√ºhrungszeit von Abfragen ist n√ºtzlich, aber wir sind noch weiter gegangen.  Wir wollten sehen, dass die Reaktionszeit w√§hrend der Arbeit von echten Benutzern nach der Ver√∂ffentlichung nicht l√§nger wurde.  Wir dachten, dass wir zum Zeitpunkt der Belastungstests wahrscheinlich etwas √ºberpr√ºfen k√∂nnen, aber dies werden nur Dutzende von F√§llen sein.  Es ist effizienter, vorhandene Funktionstests durchzuf√ºhren und gleichzeitig tausend F√§lle zu sehen. <br><br><img src="https://habrastorage.org/webt/_-/xy/0t/_-xy0t6oavpjngkog1hwqelq5ky.png"><br><br>  Wie funktioniert das bei uns?  Es gibt einen Meister, der nach der Montage auf einem Pr√ºfstand eingesetzt wird.  Parallel zu den Belastungstests werden dann automatisch Funktionstests durchgef√ºhrt.  Dann erhalten wir in Allure einen Bericht dar√ºber, wie die Funktionstests unter Last verlaufen sind. <br><br>  In diesem Bericht sehen wir beispielsweise, dass ein Vergleichstest mit einem Referenzwert gefallen ist. <br><br><img src="https://habrastorage.org/webt/t-/hh/b-/t-hhb-mrpc9zgyg0iwhvvt1yxtu.png"><br><br>  Auch in Funktionstests k√∂nnen wir die Ausf√ºhrungszeit eines Vorgangs in einem Browser messen.  Oder ein Funktionstest ist einfach nicht erfolgreich, da die Zeit, die zum Abschlie√üen des Vorgangs unter Last ben√∂tigt wird, l√§nger ist, da der Client eine Zeit√ºberschreitung aufweist. <br><br><h3>  Ergebnisse f√ºr diesen Teil </h3><br><ul><li>  Mit einem realistischen Test k√∂nnen Sie die Datenbank kosteng√ºnstig testen und einfach konfigurieren. </li><li>  Funktionspr√ºfung unter Last ist m√∂glich. </li></ul><br><br>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chste Artikel</a> befasst sich mit der Verwaltung von Hunderten von Servern f√ºr einen Auslastungstest. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462735/">https://habr.com/ru/post/de462735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462723/index.html">Fange eine Katze mit TLA +</a></li>
<li><a href="../de462725/index.html">Trigonometrie-Trick</a></li>
<li><a href="../de462727/index.html">Joomla Digest f√ºr Juni-Juli 2019</a></li>
<li><a href="../de462729/index.html">Offener Vortragsabend √ºber narratives Design am VSBI</a></li>
<li><a href="../de462733/index.html">Fibre Channel: Die Vitalit√§t der Verbindung zum Speicher im Rechenzentrum</a></li>
<li><a href="../de462737/index.html">Opencart-Integration in Buchhaltungssysteme</a></li>
<li><a href="../de462739/index.html">Spieleindustrie-Konferenz GAMEDEV.HOUSE</a></li>
<li><a href="../de462743/index.html">Moscow SPA Meetup # 5 - Ank√ºndigung des Treffens</a></li>
<li><a href="../de462747/index.html">Ich habe diesen Artikel geschrieben, ohne jemals auf die Tastatur zu schauen</a></li>
<li><a href="../de462749/index.html">Gl√ºcksmanagement: Pflege und Entwicklung eines Home-Office-Teams aus √ºber 30 St√§dten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>