<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèº ü•ß ü§õüèª Um pipeline de processamento de dados declarativo em cima dos atores? Porque n√£o üåÄ üìè üò¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° algum tempo, em uma discuss√£o sobre um dos lan√ßamentos do SObjectizer, perguntaram-nos: "√â poss√≠vel criar uma DSL para descrever um pipeline de pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um pipeline de processamento de dados declarativo em cima dos atores? Porque n√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  H√° algum tempo, em uma discuss√£o sobre um dos lan√ßamentos do SObjectizer, perguntaram-nos: "√â poss√≠vel criar uma DSL para descrever um pipeline de processamento de dados?"  Em outras palavras, √© poss√≠vel escrever algo assim: </p><br><p><code>A | B | C | D</code> </p> <br><p>  e obtenha um pipeline de trabalho no qual as mensagens v√£o de A para B, depois para C e depois para D. Com o controle, B recebe exatamente o tipo que A retorna.  E C recebe exatamente o tipo que B retorna.  E assim por diante </p><br><p>  Foi uma tarefa interessante, com uma solu√ß√£o surpreendentemente simples.  Por exemplo, √© assim que a cria√ß√£o de um pipeline pode parecer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  Ou, em um caso mais complexo (que ser√° discutido abaixo): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  Neste artigo, falaremos sobre a implementa√ß√£o desse DSL de pipeline.  Discutiremos principalmente partes relacionadas √†s fun√ß√µes <code>stage()</code> , <code>broadcast()</code> e <code>operator|()</code> com v√°rios exemplos de uso de modelos C ++.  Espero que seja interessante, mesmo para os leitores que n√£o conhecem o SObjectizer (se voc√™ nunca ouviu falar do SObjectizer, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> est√° uma vis√£o geral dessa ferramenta). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Algumas palavras sobre a demonstra√ß√£o usada </h1><br><p>  O exemplo usado no artigo foi influenciado pela minha experi√™ncia antiga (e um tanto esquecida) na √°rea do SCADA. </p><br><p>  A id√©ia da demonstra√ß√£o √© o tratamento dos dados lidos por algum sensor.  Os dados s√£o adquiridos de um sensor por um per√≠odo e, em seguida, esses dados precisam ser validados (dados incorretos devem ser ignorados) e convertidos em alguns valores reais.  Por exemplo, os dados brutos lidos de um sensor podem ser dois valores inteiros de 8 bits e esses valores devem ser convertidos em um n√∫mero de ponto flutuante. </p><br><p>  Em seguida, os valores v√°lidos e convertidos devem ser arquivados, distribu√≠dos em algum lugar (em diferentes n√≥s para visualiza√ß√£o, por exemplo), verificados quanto a "alarmes" (se os valores estiverem fora dos intervalos seguros, isso dever√° ser tratado especialmente).  Essas opera√ß√µes s√£o independentes e podem ser executadas em paralelo. </p><br><p>  As opera√ß√µes relacionadas ao alarme detectado tamb√©m podem ser executadas em paralelo: um "alarme" deve ser iniciado (para que a parte do SCADA no n√≥ atual possa reagir) e as informa√ß√µes sobre o "alarme" devem ser distribu√≠das em outro local (por exemplo, : armazenado em um banco de dados hist√≥rico e / ou visualizado no visor do operador SCADA). </p><br><p>  Essa l√≥gica pode ser expressa em forma de texto dessa maneira: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  Ou, em forma gr√°fica: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  √â um exemplo bastante artificial, mas tem algumas coisas interessantes que quero mostrar.  A primeira √© a presen√ßa de est√°gios paralelos em um pipeline (a opera√ß√£o <code>broadcast()</code> existe apenas por causa disso).  O segundo √© a presen√ßa de um estado em algumas etapas.  Por exemplo, alarm_detector √© um est√°gio stateful. </p><br><h1 id="pipeline-capabilities">  Recursos de pipeline </h1><br><p>  Um pipeline √© constru√≠do a partir de est√°gios separados.  Cada est√°gio √© uma fun√ß√£o ou um functor do seguinte formato: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  ou </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Os est√°gios que retornam <code>void</code> s√≥ podem ser usados ‚Äã‚Äãcomo o √∫ltimo est√°gio de um pipeline. </p><br><p>  As etapas s√£o vinculadas a uma cadeia.  Cada pr√≥ximo est√°gio recebe um objeto retornado pelo est√°gio anterior.  Se o est√°gio anterior retornar o valor vazio <code>opt&lt;Out&gt;</code> , o pr√≥ximo est√°gio n√£o ser√° chamado. </p><br><p>  H√° um est√°gio de <code>broadcast</code> especial.  √â constru√≠do a partir de v√°rios oleodutos.  Um est√°gio de <code>broadcast</code> recebe um objeto do est√°gio anterior e o transmite a todos os pipeline subsidi√°rios. </p><br><p>  Do ponto de vista do pipeline, o est√°gio de <code>broadcast</code> parece uma fun√ß√£o do seguinte formato: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Como n√£o h√° valor de retorno do est√°gio de <code>broadcast</code> , um est√°gio de <code>broadcast</code> pode ser apenas o √∫ltimo est√°gio de um pipeline. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  Por que o est√°gio do pipeline retorna um valor opcional? </h2><br><p>  √â porque √© necess√°rio eliminar alguns valores recebidos.  Por exemplo, o est√°gio <code>validate</code> n√£o retorna nada se um valor bruto estiver incorreto e n√£o faz sentido lidar com isso. </p><br><p>  Outro exemplo: o est√°gio <code>alarm_detector</code> n√£o retorna nada se o valor suspeito atual n√£o produzir um novo caso de alarme. </p><br><h1 id="implementation-details">  Detalhes da implementa√ß√£o </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Tipos e fun√ß√µes relacionadas √† l√≥gica do aplicativo </h2><br><p>  Vamos come√ßar com tipos de dados e fun√ß√µes relacionadas √† l√≥gica do aplicativo.  No exemplo discutido, os seguintes tipos de dados s√£o usados ‚Äã‚Äãpara passar informa√ß√µes de um est√°gio para outro: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Uma inst√¢ncia de <code>raw_value</code> est√° indo para o primeiro est√°gio do nosso pipeline.  Este <code>raw_value</code> cont√©m informa√ß√µes adquiridas de um sensor na forma de objeto <code>raw_measure</code> .  Em seguida, <code>raw_value</code> √© transformado em <code>valid_raw_value</code> .  Em seguida, <code>valid_raw_value</code> transformado em <code>sensor_value</code> com o valor real do sensor na forma de <code>calulated_measure</code> .  Se uma inst√¢ncia de <code>sensor_value</code> contiver um valor suspeito, ser√° <code>sensor_value</code> uma inst√¢ncia de <code>sensor_value</code> .  E esse <code>suspicious_value</code> pode ser transformado em inst√¢ncia <code>alarm_detected</code> por <code>alarm_detected</code> posteriormente. </p><br><p>  Ou, na forma gr√°fica: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Agora podemos dar uma olhada na implementa√ß√£o de nossos est√°gios de pipeline: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  Apenas pule coisas como <code>stage_result_t</code> , <code>make_result</code> e <code>make_empty</code> , discutiremos sobre isso na pr√≥xima se√ß√£o. </p><br><p>  Espero que o c√≥digo dessas etapas seja trivial.  A √∫nica parte que requer alguma explica√ß√£o adicional √© a implementa√ß√£o do est√°gio <code>alarm_detector</code> . </p><br><p>  Nesse exemplo, um alarme √© iniciado apenas se houver pelo menos dois valores <code>suspicious_values</code> em uma janela de tempo de 25 ms.  Portanto, temos que lembrar a hora da inst√¢ncia anterior <code>suspicious_value</code> no est√°gio <code>alarm_detector</code> .  Isso ocorre porque o <code>alarm_detector</code> √© implementado como um functor stateful com um operador de chamada de fun√ß√£o. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Os est√°gios retornam o tipo de SObjectizer em vez de std :: optional </h2><br><p>  Eu disse anteriormente que o est√°gio poderia retornar um valor opcional.  Mas <code>std::optional</code> n√£o √© usado no c√≥digo, o tipo diferente <code>stage_result_t</code> pode ser visto na implementa√ß√£o de est√°gios. </p><br><p>  Isso ocorre porque alguns dos itens espec√≠ficos do SObjectizer desempenham seu papel aqui.  Os valores retornados ser√£o distribu√≠dos como mensagens entre os agentes do SObjectizer (tamb√©m conhecidos como atores).  Toda mensagem no SObjectizer √© enviada como um objeto alocado dinamicamente.  Portanto, temos algum tipo de "otimiza√ß√£o" aqui: em vez de retornar <code>std::optional</code> e alocar um novo objeto de mensagem, apenas alocamos um objeto de mensagem e retornamos um ponteiro inteligente para ele. </p><br><p>  De fato, <code>stage_result_t</code> √© apenas um typedef para o anal√≥gico shared_ptr do SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  E <code>make_result</code> e <code>make_empty</code> s√£o apenas fun√ß√µes auxiliares para construir <code>stage_result_t</code> com ou sem um valor real dentro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Para simplificar, √© seguro dizer que o est√°gio de <code>validation</code> pode ser expresso dessa maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Por√©m, devido √† especificidade do SObjectizer, n√£o podemos usar <code>std::shared_ptr</code> e precisamos lidar com o tipo <code>so_5::message_holder_t</code> .  E <code>stage_result_t</code> esse espec√≠fico por tr√°s dos <code>stage_result_t</code> , <code>make_result</code> e <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  separa√ß√£o stage_handler_t e stage_builder_t </h2><br><p>  Um ponto importante da implementa√ß√£o do pipeline √© a separa√ß√£o dos conceitos de <em>manipulador</em> de <em>est√°gio</em> e <em>construtor de est√°gio</em> .  Isso √© feito para simplificar.  A presen√ßa desses conceitos me permitiu ter duas etapas na defini√ß√£o do pipeline. </p><br><p>  Na primeira etapa, um usu√°rio descreve os est√°gios do pipeline.  Como resultado, recebo uma inst√¢ncia de <code>stage_t</code> que cont√©m todos os est√°gios do pipeline dentro. </p><br><p>  Na segunda etapa, um conjunto de agentes subjacentes do SObjectizer √© criado.  Esses agentes recebem mensagens com resultados dos est√°gios anteriores e chamam os <em>manipuladores de est√°gios</em> reais e os enviam para os pr√≥ximos est√°gios. </p><br><p>  Mas, para criar esse conjunto de agentes, todos os est√°gios precisam ter um <em>construtor de est√°gios</em> .  <em>O construtor Stage</em> pode ser visto como uma f√°brica que cria o agente de um SObjectizer subjacente. </p><br><p>  Portanto, temos a seguinte rela√ß√£o: todo est√°gio de pipeline produz dois objetos: <em>manipulador de palco</em> que cont√©m l√≥gica relacionada ao <em>palco</em> e <em>construtor de palco</em> que cria um agente do SObjectizer subjacente para chamar o <em>manipulador de palco</em> no momento apropriado: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>O manipulador de palco</em> √© representado da seguinte maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Onde <code>handler_traits_t</code> s√£o definidos da seguinte maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>O construtor Stage</em> √© representado por apenas <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Tipos auxiliares lambda_traits_t e callable_traits_t </h2><br><p>  Como os est√°gios podem ser representados por fun√ß√µes ou functors livres (como inst√¢ncias da classe <code>alarm_detector</code> ou classes geradas por compiladores an√¥nimos que representam lambdas), precisamos de alguns auxiliares para detectar tipos de argumento e valor de retorno do est√°gio.  Eu usei o seguinte c√≥digo para esse fim: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  Espero que este c√≥digo seja bastante compreens√≠vel para leitores com bom conhecimento de C ++.  Caso contr√°rio, fique √† vontade para me perguntar nos coment√°rios. <code>lambda_traits_t</code> feliz em explicar a l√≥gica por tr√°s de <code>lambda_traits_t</code> e <code>callable_traits_t</code> em detalhes. </p><br><h2 id="stage-broadcast-and-operator-functions">  fun√ß√µes stage (), broadcast () e operator | () </h2><br><p>  Agora podemos examinar as principais fun√ß√µes de constru√ß√£o de tubula√ß√µes.  Mas antes disso, √© necess√°rio dar uma olhada na defini√ß√£o de uma classe de modelo <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  √â uma estrutura muito simples que cont√©m apenas a inst√¢ncia <code>stage_bulder_t</code> .  Os par√¢metros do modelo n√£o s√£o usados ‚Äã‚Äãdentro do <code>stage_t</code> , ent√£o por que eles est√£o presentes aqui? </p><br><p>  Eles s√£o necess√°rios para a verifica√ß√£o em tempo de compila√ß√£o da compatibilidade de tipos entre os est√°gios do pipeline.  Veremos isso em breve. </p><br><p>  Vejamos a fun√ß√£o mais simples de constru√ß√£o de pipeline, o <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Ele recebe um <em>manipulador de est√°gio</em> real como um √∫nico par√¢metro.  Pode ser um ponteiro para uma fun√ß√£o ou fun√ß√£o lambda ou functor.  Os tipos de entrada e sa√≠da do est√°gio s√£o deduzidos automaticamente devido √† "m√°gica do modelo" por tr√°s do modelo <code>callable_traits_t</code> . </p><br><p>  Uma inst√¢ncia do <em>construtor</em> de <em>est√°gio</em> √© criada dentro e ela √© retornada em um novo objeto <code>stage_t</code> como resultado da fun√ß√£o <code>stage()</code> .  Um <em>manipulador de palco</em> real √© capturado pelo <em>construtor de palco</em> lambda, depois ser√° usado para a constru√ß√£o do agente do SObjectizer subjacente (falaremos sobre isso na pr√≥xima se√ß√£o). </p><br><p>  A pr√≥xima fun√ß√£o a ser <code>operator|()</code> √© o <code>operator|()</code> que concatena dois est√°gios e retorna um novo est√°gio: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  A maneira mais simples de explicar a l√≥gica do <code>operator|()</code> √© tentar desenhar uma imagem.  Vamos supor que temos a express√£o: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Esta express√£o ser√° transformada dessa maneira: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  Tamb√©m podemos ver como a verifica√ß√£o de tipo em tempo de compila√ß√£o est√° funcionando: a defini√ß√£o de <code>operator|()</code> exige que o tipo de sa√≠da do primeiro est√°gio seja a entrada do segundo est√°gio.  Se n√£o for esse o caso, o c√≥digo n√£o ser√° compilado. </p><br><p>  E agora podemos dar uma olhada na fun√ß√£o de constru√ß√£o de pipeline mais complexa, a <code>broadcast()</code> .  A fun√ß√£o em si √© bastante simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  A principal diferen√ßa entre um est√°gio comum e um est√°gio de transmiss√£o √© que o est√°gio de transmiss√£o deve conter um vetor de <em>construtores de est√°gio</em> subsidi√°rios.  Portanto, temos que criar esse vetor e pass√°-lo para o <em>construtor</em> do <em>est√°gio</em> principal do <em>est√°gio</em> de transmiss√£o.  Por isso, podemos ver uma chamada para <code>collect_sink_builders</code> na lista de capturas de um lambda na fun√ß√£o <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Se olharmos para <code>collect_sink_builder</code> , veremos o seguinte c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  A verifica√ß√£o de tipo em tempo de compila√ß√£o tamb√©m funciona aqui: √© porque uma chamada para <code>move_sink_builder_to</code> explicitamente parametrizada pelo tipo 'In'.  Isso significa que uma chamada no formato <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> levar√° a erro de compila√ß√£o porque o compilador pro√≠be uma chamada <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Tamb√©m posso observar que, como a contagem de pipelines subsidi√°rios para <code>broadcast()</code> √© conhecida em tempo de compila√ß√£o, podemos usar <code>std::array</code> vez de <code>std::vector</code> e evitar algumas aloca√ß√µes de mem√≥ria.  Mas <code>std::vector</code> √© usado aqui apenas por simplicidade. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Rela√ß√£o entre est√°gios e agentes / mboxes do SObjectizer </h2><br><p>  A id√©ia por tr√°s da implementa√ß√£o do pipeline √© a cria√ß√£o de um agente separado para cada est√°gio do pipeline.  Um agente recebe uma mensagem recebida, passa para o <em>manipulador de est√°gio</em> correspondente, analisa o resultado e, se o resultado n√£o estiver vazio, envia o resultado como uma mensagem recebida para o pr√≥ximo est√°gio.  Pode ser ilustrado pelo seguinte diagrama de sequ√™ncia: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Algumas coisas relacionadas ao SObjectizer precisam ser discutidas, pelo menos brevemente.  Se voc√™ n√£o tem interesse em tais detalhes, pode pular as se√ß√µes abaixo e ir diretamente para a conclus√£o. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop √© um grupo de agentes para trabalhar juntos </h3><br><p>  Os agentes s√£o introduzidos no SObjectizer n√£o individualmente, mas em grupos denominados coops.  Uma cooperativa √© um grupo de agentes que devem trabalhar juntos e n√£o faz sentido continuar o trabalho se um dos agentes do grupo estiver ausente. </p><br><p>  Portanto, a introdu√ß√£o de agentes no SObjectizer parece com a cria√ß√£o da inst√¢ncia de coopera√ß√£o, preenchendo essa inst√¢ncia com os agentes apropriados e registrando a coopera√ß√£o no SObjectizer. </p><br><p>  Por isso, o primeiro argumento para um <em>construtor de est√°gios</em> √© uma refer√™ncia a uma nova cooperativa.  Essa coopera√ß√£o √© criada na fun√ß√£o <code>make_pipeline()</code> (discutida abaixo), depois √© preenchida por <em>construtores de est√°gio</em> e depois registrada (novamente na fun√ß√£o <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Caixas de mensagem </h3><br><p>  O SObjectizer implementa v√°rios modelos relacionados √† concorr√™ncia.  O modelo do ator apenas um deles.  Por isso, o SObjectizer pode diferir significativamente de outras estruturas de atores.  Uma das diferen√ßas √© o esquema de endere√ßamento das mensagens. </p><br><p>  As mensagens no SObjectizer n√£o s√£o endere√ßadas aos atores, mas √†s <em>caixas de mensagens</em> (mboxes).  Os atores precisam se inscrever nas mensagens de uma mbox.  Se um ator se inscrevesse em um tipo de mensagem espec√≠fico de uma mbox, ele receberia mensagens desse tipo: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Esse fato √© crucial porque √© necess√°rio enviar mensagens de um est√°gio para outro.  Isso significa que cada est√°gio deve ter sua mbox e esse mbox deve ser conhecido para o est√°gio anterior. </p><br><p>  Todo ator (aka agente) no SObjectizer possui <em>a mbox direta</em> .  Essa mbox est√° associada apenas ao agente propriet√°rio e n√£o pode ser usada por outros agentes.  As mboxes diretas de agentes criadas para est√°gios ser√£o usadas para a intera√ß√£o dos est√°gios. </p><br><p>  O recurso espec√≠fico deste SObjectizer determina alguns detalhes de implementa√ß√£o de pipeline. </p><br><p>  O primeiro √© o fato de o <em>construtor de palco</em> ter o seguinte prot√≥tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Isso significa que o <em>construtor de est√°gio</em> recebe uma mbox do pr√≥ximo est√°gio e deve criar um novo agente que enviar√° os resultados do est√°gio para essa mbox.  Uma mbox do novo agente deve ser retornada pelo <em>construtor de palco</em> .  Essa mbox ser√° usada para a cria√ß√£o de um agente para o est√°gio anterior. </p><br><p>  O segundo √© o fato de que agentes para est√°gios s√£o criados em ordem de reserva.  Isso significa que se tivermos um pipeline: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Um agente para o est√°gio C ser√° criado primeiro, ent√£o sua mbox ser√° usada para a cria√ß√£o de um agente para o est√°gio B e, em seguida, a mbox do agente do est√°gio B ser√° usada para a cria√ß√£o de um agente para o est√°gio A. </p><br><p>  Tamb√©m vale ressaltar que o <code>operator|()</code> n√£o cria agentes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  O <code>operator|()</code> cria um construtor que chama apenas outros construtores, mas n√£o apresenta agentes adicionais.  Ent√£o, para o caso: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  apenas dois agentes ser√£o criados (para os est√°gios A e B) e, em seguida, ser√£o vinculados no <em>construtor de est√°gios</em> criado pelo <code>operator|()</code> . </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  N√£o h√° agente para implementa√ß√£o de <code>broadcast()</code> </h3><br><p>  Uma maneira √≥bvia de implementar um est√°gio de transmiss√£o √© criar um agente especial que receber√° uma mensagem recebida e, em seguida, reenvie essa mensagem para uma lista de mboxes de destino.  Dessa maneira, <a href="">foi usada na primeira implementa√ß√£o</a> do DSL de pipeline descrito. </p><br><p>  Mas nosso projeto complementar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">so5extra</a> , agora possui uma variante especial da mbox: a transmiss√£o de uma.  Essa mbox faz exatamente o que √© necess√°rio aqui: pega uma nova mensagem e a entrega a um conjunto de mboxes de destino. </p><br><p>  Por esse motivo, n√£o h√° necessidade de criar um agente de transmiss√£o separado, podemos apenas usar a transmiss√£o mbox do so5extra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implementa√ß√£o do agente de est√°gio </h3><br><p>  Agora podemos dar uma olhada na implementa√ß√£o do agente do est√°gio: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  √â bastante trivial se voc√™ entender o b√°sico do SObjectizer.  Caso contr√°rio, ser√° muito dif√≠cil explicar em poucas palavras (sinta-se √† vontade para fazer perguntas nos coment√°rios). </p><br><p>  A principal implementa√ß√£o do agente <code>a_stage_point_t</code> cria uma assinatura para uma mensagem do tipo In.  Quando uma mensagem desse tipo chega, o <em>manipulador de palco</em> √© chamado.  Se o <em>manipulador de est√°gio</em> retornar um resultado real, o resultado ser√° enviado para o pr√≥ximo est√°gio (se esse est√°gio existir). </p><br><p>  H√° tamb√©m uma vers√£o de <code>a_stage_point_t</code> para o caso em que o est√°gio correspondente √© o est√°gio terminal e n√£o pode haver o pr√≥ximo est√°gio. </p><br><p>  A implementa√ß√£o de <code>a_stage_point_t</code> pode parecer um pouco complicada, mas acredite, √© um dos agentes mais simples que escrevi. </p><br><h2 id="make_pipeline-function">  fun√ß√£o make_pipeline () </h2><br><p>  √â hora de discutir a √∫ltima fun√ß√£o de constru√ß√£o de pipeline, o <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  N√£o h√° m√°gica nem surpresas aqui.  N√≥s apenas precisamos criar uma nova cooperativa para agentes subjacentes do pipeline, preencher essa cooperativa com agentes chamando um <em>construtor de est√°gio de</em> n√≠vel superior e depois registr√°-la no SObjectizer.  Isso tudo. </p><br><p>  O resultado de <code>make_pipeline()</code> √© a mbox do est√°gio mais √† esquerda (o primeiro) do pipeline.  Essa mbox deve ser usada para enviar mensagens para o pipeline. </p><br><h1 id="the-simulation-and-experiments-with-it">  A simula√ß√£o e experimentos com ela </h1><br><p>  Portanto, agora temos tipos de dados e fun√ß√µes para nossa l√≥gica de aplicativo e as ferramentas para encadear essas fun√ß√µes em um pipeline de processamento de dados.  Vamos fazer isso e ver um resultado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Se executarmos esse exemplo, veremos a seguinte sa√≠da: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Isso funciona. </p><br><p>  Mas parece que os est√°gios do nosso pipeline funcionam sequencialmente, um ap√≥s o outro, n√£o √©? </p><br><p>  √â sim.  Isso ocorre porque todos os agentes de pipeline est√£o vinculados ao expedidor do SObjectizer padr√£o.  E esse expedidor usa apenas um segmento de trabalho para servir o processamento de mensagens de todos os agentes. </p><br><p>  Mas isso pode ser facilmente alterado.  Basta passar um argumento adicional para a chamada <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Isso cria um novo conjunto de encadeamentos e liga todos os agentes de pipeline a esse conjunto.  Cada agente ser√° atendido pelo pool independentemente de outros agentes. </p><br><p>  Se rodarmos o exemplo modificado, podemos ver algo assim: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Portanto, podemos ver que diferentes est√°gios do pipeline funcionam em paralelo. </p><br><p>  Mas √© poss√≠vel ir al√©m e ter a capacidade de vincular est√°gios a diferentes expedidores? </p><br><p>  Sim, √© poss√≠vel, mas temos que implementar outra sobrecarga para a fun√ß√£o <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p> This version of <code>stage()</code> accepts not only a <em>stage handler</em> but also a dispatcher binder. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460123/">https://habr.com/ru/post/pt460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460113/index.html">Algumas hist√≥rias da vida do JSOC CERT, ou forense unbanal</a></li>
<li><a href="../pt460115/index.html">Dez anos de programa√ß√£o em Erlang</a></li>
<li><a href="../pt460117/index.html">Os maiores clientes da R√∫ssia s√£o um grande jackpot ou uma dor de cabe√ßa? Experi√™ncia AGIMA</a></li>
<li><a href="../pt460119/index.html">Erros que a an√°lise de c√≥digo est√°tico n√£o encontra porque n√£o √© usada</a></li>
<li><a href="../pt460121/index.html">Erros que a an√°lise de c√≥digo est√°tico n√£o encontra porque n√£o √© usada</a></li>
<li><a href="../pt460125/index.html">Node.js ou Java: desempenho, recursos, controle de fluxo, popularidade e experi√™ncia pessoal</a></li>
<li><a href="../pt460129/index.html">Rob√¥s e morangos: como a IA aumenta o rendimento do campo</a></li>
<li><a href="../pt460131/index.html">Sophos XG Firewall: do ME cl√°ssico ao NGFW com resposta autom√°tica a incidentes de seguran√ßa da informa√ß√£o</a></li>
<li><a href="../pt460133/index.html">Kotlin / Everywhere - Pr√°tica de demonstra√ß√£o: 31 de julho</a></li>
<li><a href="../pt460135/index.html">Semana 29 de seguran√ßa: Vulnerabilidade de zoom, seguran√ßa e drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>