<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏾 😩 🧝🏾 Raspberry Pi外形尺寸的STM32F4调试板 💆🏻 ☢️ 🔡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="下午好，亲爱的哈布罗维特人！ 我想向公众介绍我的项目-一个基于STM32的小型调试板，但采用Raspberry Pi尺寸。 它与其他调试板的不同之处在于，其几何结构与Raspberry Pi外壳兼容，并且具有作为无线调制解调器的ESP8266模块。 以及用于micro-SD卡和立体声放大器的连接器形...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raspberry Pi外形尺寸的STM32F4调试板</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413101/"><p><img src="https://habrastorage.org/webt/m_/xs/9t/m_xs9tnnhio8gxliqrjhdj3zxxw.jpeg" alt="图片" align="left"> 下午好，亲爱的哈布罗维特人！ 我想向公众介绍我的项目-一个基于STM32的小型调试板，但采用Raspberry Pi尺寸。 它与其他调试板的不同之处在于，其几何结构与Raspberry Pi外壳兼容，并且具有作为无线调制解调器的ESP8266模块。 以及用于micro-SD卡和立体声放大器的连接器形式的不错补充。 为了利用所有这些财富，我开发了一个高级库和一个演示程序（在C ++ 11中）。 在本文中，我想详细描述该项目的硬件和软件部分。 </p><a name="habracut"></a><br><p> 谁可以从这个项目中受益？ 可能只适用于那些想自己焊接该板的人，因为即使是小规模生产，我也不会考虑任何选择。 这是纯粹的爱好。 我认为，该委员会涵盖了使用WiFi和声音的小型家用工艺品框架中可能出现的相当广泛的任务。 </p><br><p> 首先，我将尝试回答为什么这就是所有问题。 该项目的主要动机如下： </p><br><ul><li> 选择STM32平台是出于纯粹的美学考虑-我喜欢性价比，再加上广泛的外围设备，以及控制器制造商提供的大型便捷开发生态系统（sw4stm，cubMX，HAL库）。 </li><li> 当然，控制器制造商本身（Discovery，Nucleo）以及第三方制造商（例如Olimex）都有许多调试板。 但是，至少对我来说，要在家中重复使用其中许多产品是有问题的。 在我的版本中，我们有一个简单的两层拓扑结构和一些便于手动焊接的组件。 </li><li> 对于他们的设备，我希望拥有合适的外壳，以掩盖内部电子设备的低质量。 至少有两个流行的平台，其中有大量最多样化的案例：Arduino和Raspberry Pi。 就连接器的切口位置而言，第二个对我来说似乎更方便。 因此，作为木板几何形状的捐助者，我选择了它。 </li><li> 我在板上选择的控制器具有USB，SDIO，I2S，网络。 另一方面，这些相同的接口对于家庭爱好平台也很有用。 因此，除了带有标准线束的控制器之外，我还添加了USB连接器，SD卡，音频路径（数模转换器和放大器）以及基于ESP8266的无线模块。 </li></ul><br><h2 id="shema-i-komponenty"> 电路及元件 </h2><br><p> 在我看来，具有以下特征和组件的非常不错的电路板： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM32F405RG</a>控制器：具有数学协处理器的ARM 32位Cortex-M4，频率高达168 MHz，1 Mb闪存，196 Kb RAM。 <br><img src="https://habrastorage.org/webt/w1/je/fb/w1jefbi3tuwerk7nyio5awywiky.png" alt="二手控制器引脚"><br><img src="https://habrastorage.org/webt/-a/ta/sr/-atasrnz4pajsqagowftqvzok5q.png" alt="控制器绑定"></li><li>  SWD连接器，用于对控制器进行编程（6针）。 </li><li> 重置按钮以重新启动。 </li><li> 三色LED。 一方面，三个控制器引脚丢失。 另一方面，由于GPIO连接器上的触点有限，它们仍然会丢失，并且对于调试此类LED来说，这非常有用。 </li><li> 高频HSE（核心时钟为16 MHz）和低频LSE（实时时钟为32.7680 kHz）石英。 </li><li> 间距为2.54 mm的GPIO引脚与原型板兼容。 </li><li> 我放置了5伏电源连接器，而不是Raspberry Pi的3.5毫米音频插孔。 乍一看，这个决定是有争议的。 但是有优点。 可以选择通过USB连接器供电（下面有详细信息），但这对于调试电路是一个不好的选择，因为在这种情况下，刻录计算机的USB端口之前的时间可能很短。 </li></ul><br><p><img src="https://habrastorage.org/webt/0s/qk/mk/0sqkmkrm5j1lt5bhkaiftrpz-y8.png" alt="电源电路"></p><br><ul><li> 迷你USB端口 一方面，它通过保护芯片<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STF203-22.TCT</a>连接到控制器的USB-OTG端口。 另一方面，VBUS电源引脚连接到GPIO连接器。 如果将其连接到+ 5V引脚，则将通过USB端口为开发板供电。 </li></ul><br><p><img src="https://habrastorage.org/webt/4q/te/om/4qteom17ikstddtnjafa78pqpme.png" alt="USB电路"></p><br><ul><li> 带有线束的micro-SD存储卡连接器： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">47kΩ上</a>拉电阻，电源管理晶体管（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P沟道MOSFET BSH205</a> ）和电源线上的绿色小LED。 </li></ul><br><p><img src="https://habrastorage.org/webt/qb/3x/el/qb3xelfstpguacjkqhnss45nlxk.png" alt="Micro SD卡概述"></p><br><p> 晶体管栅极连接到控制器的PA15引脚。 这是JTDI控制器的系统触点，其有趣之处在于，它在初始位置被配置为具有高电平（上拉）电压的输出。 由于使用SWD代替JTAG进行编程，因此该触点保持空闲状态，并且可以用于其他目的，例如控制晶体管。 这很方便-板上供电时，存储卡会断电；要启用该功能，您需要在PA15引脚上施加一个低电平。 </p><br><ul><li> 基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UDA1334的数模转换器</a> 。 该芯片不需要外部时钟信号，因此便于使用。 数据通过I2S总线传输。 另一方面，数据表建议使用多达47个F的5个极性电容器。 在这种情况下，尺寸很重要。 事实证明，购买的最小的是钽，尺寸为1411，甚至都不便宜。 但是，我将在下面详细介绍价格。 对于模拟电源，使用其自己的线性稳定器，数字部分的电源通过双晶体管打开/关闭。 </li></ul><br><p><img src="https://habrastorage.org/webt/4f/rh/ea/4frheacnbm39nin0t79ubdatfy8.png" alt="DAC电路"></p><br><ul><li> 基于两个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">31AP2005</a>芯片的两通道放大器。 它们的主要优点是捆扎部件数量少（仅电源滤波器和输入滤波器）。 音频输出-4个平台，间距为2.54毫米。 就我自己而言，我还没有决定最好的选择-这样的临时选择，或者像在覆盆子上那样，使用3.5毫米插头。 通常，耳机与3.5毫米相关，在我们的案例中，我们正在谈论连接扬声器。 </li></ul><br><p><img src="https://habrastorage.org/webt/ke/ge/qa/kegeqak09asea0z1npbr7u9clyw.png" alt="放大电路"></p><br><ul><li> 最后一个模块是带有捆扎带（电源，编程插座）的ESP11披肩，作为WiFi调制解调器。  UART板的结论连接到控制器，并同时输出到外部连接器（用于直接从端子和编程中使用该板）。 有一个电源开关（永久外部或由微控制器控制）。 有一个额外的LED指示电源，还有一个“ FLASH”连接器，用于将板子设置为编程模式。 </li></ul><br><p><img src="https://habrastorage.org/webt/3d/cq/1d/3dcq1dpb4u-iog9jbnix9icc1ac.png" alt="ESP电路"></p><br><p> 当然，ESP8266本身是一个不错的控制器，但在性能和外围设备方面仍然不如STM32F4。 是的，这个模块的价格以及它的价格暗示着这是它的哥哥泄漏的调制解调器单元。 该模块由USRT使用文本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AT</a>协议控制。 </p><br><p> 几张照片： <br> <a href=""><img src="https://habrastorage.org/webt/if/zv/di/ifzvdi77bc5vhkauczq8kwfa6mg.jpeg"></a> <br> <a href=""><img src="https://habrastorage.org/webt/dg/go/lz/dggolzrzpwxghtqnwtdyf_plogo.jpeg"></a> </p><br><h2 id="podgotovka-modulya-esp11"> 准备ESP11模块 </h2><br><p>  ESP8266是众所周知的东西。 我确信很多人已经熟悉它，因此这里没有多余的详细指南。 由于将ESP11模块连接到开发板上的原理图功能，对于那些想要更改其固件的人，我只给他一个简要指南： </p><br><ul><li> 我将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">esptool</a>实用程序与ESP一起使用。  esptool与制造商提供的标准实用程序不同，它与平台无关。 </li><li> 首先，使用ESP-PWR跳线打开外部电源模式（我们关闭触点1和2），然后通过任何USART-USB适配器将模块连接到计算机。 适配器连接到GRD / RX / TD引脚。 我们为电路板供电： <br> <a href=""><img src="https://habrastorage.org/webt/qk/sg/_u/qksg_updoacqtvh5a_bmczc_poe.jpeg"></a> </li><li> 我们确保适配器被操作系统识别。 在我的示例中，我使用基于FT232的适配器，因此在设备列表中，它应该显示为FT232串行（UART）IC： <br><pre><code class="bash hljs">&gt; lsusb ... Bus 001 Device 010: ID 0483:3748 STMicroelectronics ST-LINK/V2 Bus 001 Device 009: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC ...</code> </pre> </li><li>  ESP8266本身的闪存数量不同。 在实践中，在同一ESP11模块中，我同时遇到512 KB（4 Mbit）和1 MB（8 Mbit）。 因此，首先要检查的是模块使用的实例中有多少内存。 关闭开发板上的电源，然后将模块置于编程模式，关闭跳线“ FLASH”： </li></ul><br><p> <a href=""><img src="https://habrastorage.org/webt/dr/i8/8p/dri88pfduzkumw9u2_euqtz2_va.jpeg"></a> </p><br><ul><li> 打开电源，使用以下参数运行esptool </li></ul><br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 flash_id Connecting.... Detecting chip <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>... ESP8266 Chip is ESP8266EX Uploading stub... Running stub... Stub running... Manufacturer: e0 Device: 4014 Detected flash size: 1MB Hard resetting...</code> </pre> <br><ul><li>  esptool报告说，在这种情况下，我们正在处理具有1 MB内存的模块。 </li><li> 对于1 MB的版本，可以使用最新的固件，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ESP8266 AT Bin V1.6.1</a> 。 但是它不适用于4 Mbit的版本，您需要使用较旧的版本，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a> 。 固件由几个文件组成，每个文件的起始地址在官方文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ESP8266 AT指令集中进行介绍</a> 。 这些起始地址用作esptool实用程序的参数。 例如，对于具有1 MB的模块，esptool的参数应如下所示（所有必需的文件必须首先从固件档案中提取并收集在工作目录中） <br><pre> <code class="bash hljs">&gt; esptool.py --port /dev/ttyUSB0 write_flash 0x00000 boot.bin 0x01000 user1.1024.new.2.bin 0x7E000 blank.bin 0xFB000 blank.bin 0xFC000 esp_init_data_default.bin 0xFE000 blank.bin</code> </pre> </li><li> 我们为开发板供电，并使用指定的参数运行esptool。 </li><li> 完成脚本后，关闭开发板上的电源，打开“ FLASH”跳线，然后打开微控制器的电源控制。 该模块已准备就绪，可以开始工作了。 </li></ul><br><h2 id="programmnoe-obespechenie"> 软体类 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上有一个测试程序。 她执行以下操作： </p><br><ul><li> 以最大频率（168 MHz）显示控制器 </li><li> 激活实时时钟 </li><li> 激活SD卡并从中读取网络配置。  FatFS库用于处理文件系统。 </li><li> 建立与指定WLAN的连接 </li><li> 连接到指定的NTP服务器并从中请求当前时间。 带领时钟。 </li><li> 监视几个指定端口的状态。 如果其状态已更改，则将文本消息发送到指定的TCP服务器。 </li><li> 当您单击外部按钮时，它将从SD卡读取指定的* .wav文件，并以异步模式（使用DMA控制器的I2S）播放该文件。 </li><li>  ESP11的工作也以异步模式实现（到目前为止没有DMA，仅在中断时） </li><li> 通过USART1登录（引脚PB6 / PB7） </li><li> 当然，LED也会闪烁。 </li></ul><br><p> 在Habré上，有许多文章专门针对较低级别的STM32进行编程（仅通过寄存器管理或CMSIS）。 例如，从相对较后的位置开始： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三</a> 。 这些文章当然是非常高质量的，但是我的主观意见是，对于产品的一次性开发，这种方法也许是合理的。 但是对于一个长期的爱好项目，当您希望所有内容都美观且可扩展时，这种方法太底层了。 在我看来，Arduino成为软件平台之所以受欢迎，原因之一是Arduino的作者对面向对象的体系结构没有这么低的要求。 因此，我决定朝同一方向发展，并在HAL库上添加了一个相当高级的面向对象层。 </p><br><p> 因此，获得了程序的三个级别： </p><br><ul><li> 制造商库（HAL，FatFS，以后称为USB-OTG）构成基础 </li><li> 我的StmPlusPlus库基于此基础。 它包括一组基本类（例如System，IOPort，IOPin，Timer，RealTimeClock，Usart，Spi，I2S），一组外部设备的驱动程序类（例如SdCard，Esp11，DcfReceiver，Dac_MCP49x1，AudioDac_UDA1334等），以及服务类，例如WAV异步播放器。 </li><li> 基于StmPlusPlus库，正在构建应用程序本身。 </li></ul><br><p> 至于语言的方言。 虽然我有些过时，但我仍然使用C ++ 11。 该标准具有一些对开发固件特别有用的功能：枚举类，使用花括号调用构造函数以控制传递的参数的类型以及静态容器（如std :: array）。 顺便说一句，在哈布雷（Habré）上有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>关于该主题的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">精彩文章</a> 。 </p><br><h3 id="biblioteka-stmplusplus">  StmPlusPlus库 </h3><br><p> 完整的库代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上查看。 在这里，我将仅给出一些小示例，以说明该构想产生的结构，构想和问题。 </p><br><p>  <strong>第一个示例</strong>是用于定期轮询引脚（例如按钮）状态并在此状态更改时调用处理程序的类： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> :</span></span> IOPin { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onButtonPressed</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Button *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numOccured)</span></span></span><span class="hljs-function"> </span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; }; Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay = <span class="hljs-number"><span class="hljs-number">50</span></span>, duration_ms _pressDuration = <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventHandler * _handler)</span></span></span><span class="hljs-function"> </span></span>{ handler = _handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">periodic</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; rtc; duration_ms pressDelay, pressDuration; time_ms pressTime; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentState; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured; EventHandler * handler; };</code> </pre> <br><p> 构造函数定义所有按钮参数： </p><br><pre> <code class="cpp hljs">Button::Button (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RealTimeClock &amp; _rtc, duration_ms _pressDelay, duration_ms _pressDuration): IOPin{name, pin, GPIO_MODE_INPUT, pull, GPIO_SPEED_LOW}, rtc{_rtc}, pressDelay{_pressDelay}, pressDuration{_pressDuration}, pressTime{INFINITY_TIME}, currentState{<span class="hljs-literal"><span class="hljs-literal">false</span></span>}, numOccured{<span class="hljs-number"><span class="hljs-number">0</span></span>}, handler{<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>} { <span class="hljs-comment"><span class="hljs-comment">// empty }</span></span></code> </pre> <br><p> 如果处理此类事件不是优先事项，那么使用中断显然是多余的。 因此，在周期性过程中会实现各种按压场景（例如，一次按压或按住），应从主程序代码中定期调用这些情景。 定期分析状态变化并同步调用onButtonPressed虚拟处理程序，该处理程序应在主程序中实现： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::periodic () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> newState = (gpioParameters.Pull == GPIO_PULLUP)? !getBit() : getBit(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentState == newState) { <span class="hljs-comment"><span class="hljs-comment">// state is not changed: check for periodical press event if (currentState &amp;&amp; pressTime != INFINITY_TIME) { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &gt;= pressDuration) { handler-&gt;onButtonPressed(this, numOccured); pressTime = rtc.getUpTimeMillisec(); ++numOccured; } } } else if (!currentState &amp;&amp; newState) { pressTime = rtc.getUpTimeMillisec(); numOccured = 0; } else { duration_ms d = rtc.getUpTimeMillisec() - pressTime; if (d &lt; pressDelay) { // nothing to do } else if (numOccured == 0) { handler-&gt;onButtonPressed(this, numOccured); } pressTime = INFINITY_TIME; } currentState = newState; }</span></span></code> </pre> <br><p> 这种方法的主要优点是用于从事件处理中检测事件的逻辑和代码的多样性。 不是用于计数时间的HAL_GetTick，由于其类型（uint32_t），每2 ^ 32毫秒（每49天）通过溢出对其进行重置。 我实现了我自己的类RealTimeClock，该类从程序开始算起就是毫秒，或者打开了像uint64_t这样的控制器，这大约需要5 ^ 8年的时间。 </p><br><p>  <strong>第二个示例</strong>是使用硬件接口，控制器中有多个硬件接口。 例如，SPI。 从主程序的角度来看，仅选择所需的接口（SPI1 / SPI2 / SPI3）非常方便，并且依赖于此接口的所有其他参数将由类构造函数配置。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spi</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TIMEOUT = <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceName</span></span></span><span class="hljs-class"> {</span></span> SPI_1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, SPI_2 = <span class="hljs-number"><span class="hljs-number">1</span></span>, SPI_3 = <span class="hljs-number"><span class="hljs-number">2</span></span>, }; Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull = GPIO_NOPULL); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prescaler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataSize = SPI_DATASIZE_8BIT, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CLKPhase = SPI_PHASE_1EDGE)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBuffer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_SPI_Transmit(hspi, pData, pSize, TIMEOUT); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: DeviceName device; IOPin sck, miso, mosi; SPI_HandleTypeDef *hspi; SPI_HandleTypeDef spiParams; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disableClock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br><p> 引脚参数和接口参数存储在本地类中。 不幸的是，当直接根据特定接口实现参数设置时，我选择了一个并非完全成功的实现选项： </p><br><pre> <code class="cpp hljs">Spi::Spi (DeviceName _device, IOPort::PortName sckPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sckPin, IOPort::PortName misoPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> misoPin, IOPort::PortName mosiPort, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mosiPin, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pull): device(_device), sck(sckPort, sckPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), miso(misoPort, misoPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), mosi(mosiPort, mosiPin, GPIO_MODE_AF_PP, pull, GPIO_SPEED_HIGH, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), hspi(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (device) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DeviceName::SPI_1: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI1 sck.setAlternate(GPIO_AF5_SPI1); miso.setAlternate(GPIO_AF5_SPI1); mosi.setAlternate(GPIO_AF5_SPI1); spiParams.Instance = SPI1; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; ... case DeviceName::SPI_3: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SPI3 sck.setAlternate(GPIO_AF6_SPI3); miso.setAlternate(GPIO_AF6_SPI3); mosi.setAlternate(GPIO_AF6_SPI3); spiParams.Instance = SPI3; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; } spiParams.Init.Mode = SPI_MODE_MASTER; spiParams.Init.DataSize = SPI_DATASIZE_8BIT; spiParams.Init.CLKPolarity = SPI_POLARITY_HIGH; spiParams.Init.CLKPhase = SPI_PHASE_1EDGE; spiParams.Init.FirstBit = SPI_FIRSTBIT_MSB; spiParams.Init.TIMode = SPI_TIMODE_DISABLE; spiParams.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; spiParams.Init.CRCPolynomial = 7; spiParams.Init.NSS = SPI_NSS_SOFT; }</span></span></code> </pre> <br><p> 相同的方案实现了enableClock和disableClock过程，它们的扩展性很差，并且对其他控制器的移植性也很差。 在这种情况下，最好使用模板，其中模板参数为HAL接口名称（SPI1，SPI2，SPI3），引脚参数（GPIO_AF5_SPI1）以及用于控制时钟的开/关的模板。 关于此主题， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有</a>一篇有趣的文章，尽管它回顾了AVR控制器，但是这并没有根本的不同。 </p><br><p> 传输的开始和结束由两种开始/停止方法控制： </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef Spi::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> direction, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prescaler, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataSize, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> CLKPhase) { hspi = &amp;spiParams; enableClock(); spiParams.Init.Direction = direction; spiParams.Init.BaudRatePrescaler = prescaler; spiParams.Init.DataSize = dataSize; spiParams.Init.CLKPhase = CLKPhase; HAL_StatusTypeDef status = HAL_SPI_Init(hspi); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } <span class="hljs-comment"><span class="hljs-comment">/* Configure communication direction : 1Line */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spiParams.Init.Direction == SPI_DIRECTION_1LINE) { SPI_1LINE_TX(hspi); } <span class="hljs-comment"><span class="hljs-comment">/* Check if the SPI is already enabled */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((spiParams.Instance-&gt;CR1 &amp; SPI_CR1_SPE) != SPI_CR1_SPE) { <span class="hljs-comment"><span class="hljs-comment">/* Enable SPI peripheral */</span></span> __HAL_SPI_ENABLE(hspi); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Started SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device &lt;&lt; <span class="hljs-string"><span class="hljs-string">": BaudRatePrescaler = "</span></span> &lt;&lt; spiParams.Init.BaudRatePrescaler &lt;&lt; <span class="hljs-string"><span class="hljs-string">", DataSize = "</span></span> &lt;&lt; spiParams.Init.DataSize &lt;&lt; <span class="hljs-string"><span class="hljs-string">", CLKPhase = "</span></span> &lt;&lt; spiParams.Init.CLKPhase &lt;&lt; <span class="hljs-string"><span class="hljs-string">", Status = "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } HAL_StatusTypeDef Spi::stop () { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Stopping SPI "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)device); HAL_StatusTypeDef retValue = HAL_SPI_DeInit(&amp;spiParams); disableClock(); hspi = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retValue; }</code> </pre> <br><p>  <strong>使用中断使用硬件接口</strong> 。 该类使用DMA控制器实现I2S接口。  I2S（IC间声音）是SPI的硬件软件附加组件，例如它本身根据音频协议和比特率执行时钟选择和通道控制。 </p><br><p> 在这种情况下，I2S类是从“端口”类继承的，即I2S是具有特殊属性的端口。 某些数据存储在HAL结构中（为方便起见加号，为数据量减号）。 一些数据是通过链接从主代码传输的（例如irqPrio结构）。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I2S</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOPort { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type I2S_IRQ = SPI2_IRQn; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IRQn_Type DMA_TX_IRQ = DMA1_Stream4_IRQn; I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio); <span class="hljs-function"><span class="hljs-function">HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> standard, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> audioFreq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataFormat)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> HAL_StatusTypeDef </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transmit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_I2S_Transmit_DMA(&amp;i2s, pData, size); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processI2SInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_I2S_IRQHandler(&amp;i2s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDmaTxInterrupt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HAL_DMA_IRQHandler(&amp;i2sDmaTx); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: I2S_HandleTypeDef i2s; DMA_HandleTypeDef i2sDmaTx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; irqPrio; };</code> </pre> <br><p> 它的构造函数设置所有静态参数： </p><br><pre> <code class="cpp hljs">I2S::I2S (PortName name, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pin, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InterruptPriority &amp; prio): IOPort{name, GPIO_MODE_INPUT, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, pin, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, irqPrio{prio} { i2s.Instance = SPI2; i2s.Init.Mode = I2S_MODE_MASTER_TX; i2s.Init.Standard = I2S_STANDARD_PHILIPS; <span class="hljs-comment"><span class="hljs-comment">// will be re-defined at communication start i2s.Init.DataFormat = I2S_DATAFORMAT_16B; // will be re-defined at communication start i2s.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE; i2s.Init.AudioFreq = I2S_AUDIOFREQ_44K; // will be re-defined at communication start i2s.Init.CPOL = I2S_CPOL_LOW; i2s.Init.ClockSource = I2S_CLOCK_PLL; i2s.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE; i2sDmaTx.Instance = DMA1_Stream4; i2sDmaTx.Init.Channel = DMA_CHANNEL_0; i2sDmaTx.Init.Direction = DMA_MEMORY_TO_PERIPH; i2sDmaTx.Init.PeriphInc = DMA_PINC_DISABLE; i2sDmaTx.Init.MemInc = DMA_MINC_ENABLE; i2sDmaTx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD; i2sDmaTx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD; i2sDmaTx.Init.Mode = DMA_NORMAL; i2sDmaTx.Init.Priority = DMA_PRIORITY_LOW; i2sDmaTx.Init.FIFOMode = DMA_FIFOMODE_ENABLE; i2sDmaTx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL; i2sDmaTx.Init.MemBurst = DMA_PBURST_SINGLE; i2sDmaTx.Init.PeriphBurst = DMA_PBURST_SINGLE; }</span></span></code> </pre> <br><p> 数据传输的开始由启动方法控制，启动方法负责配置端口参数，为接口计时，配置中断，启动DMA，使用指定的传输参数启动接口本身。 </p><br><pre> <code class="cpp hljs">HAL_StatusTypeDef I2S::start (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> standard, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> audioFreq, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dataFormat) { i2s.Init.Standard = standard; i2s.Init.AudioFreq = audioFreq; i2s.Init.DataFormat = dataFormat; setMode(GPIO_MODE_AF_PP); setAlternate(GPIO_AF5_SPI2); __HAL_RCC_SPI2_CLK_ENABLE(); HAL_StatusTypeDef status = HAL_I2S_Init(&amp;i2s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not start I2S: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } __HAL_RCC_DMA1_CLK_ENABLE(); __HAL_LINKDMA(&amp;i2s, hdmatx, i2sDmaTx); status = HAL_DMA_Init(&amp;i2sDmaTx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != HAL_OK) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Can not initialize I2S DMA/TX channel: "</span></span> &lt;&lt; status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_ERROR; } HAL_NVIC_SetPriority(I2S_IRQ, irqPrio.first, irqPrio.second); HAL_NVIC_EnableIRQ(I2S_IRQ); HAL_NVIC_SetPriority(DMA_TX_IRQ, irqPrio.first + <span class="hljs-number"><span class="hljs-number">1</span></span>, irqPrio.second); HAL_NVIC_EnableIRQ(DMA_TX_IRQ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HAL_OK; }</code> </pre> <br><p> 停止过程执行相反的操作： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I2S::stop () { HAL_NVIC_DisableIRQ(I2S_IRQ); HAL_NVIC_DisableIRQ(DMA_TX_IRQ); HAL_DMA_DeInit(&amp;i2sDmaTx); __HAL_RCC_DMA1_CLK_DISABLE(); HAL_I2S_DeInit(&amp;i2s); __HAL_RCC_SPI2_CLK_DISABLE(); setMode(GPIO_MODE_INPUT); }</code> </pre> <br><p> 这里有几个有趣的功能： </p><br><ul><li> 在这种情况下，使用的中断被定义为静态常量。 这是对其他控制器的可移植性的减法。 </li><li> 这样的代码组织确保了在无传输时端口引脚始终处于GPIO_MODE_INPUT状态。 这是一个加号。 </li><li> 中断的优先级是从外部传递的，也就是说，有很好的机会在主代码的一个位置设置中断优先级映射。 这也是一个加号。 </li><li> 停止过程将禁用DMA1时钟。 在这种情况下，如果其他人继续使用DMA1，这种简化可能会带来非常不利的后果。 通过创建此类设备使用者的集中寄存器来解决该问题，该寄存器将负责计时。 </li><li> 另一个简化-启动过程不会在出现错误的情况下将接口恢复为原始状态（这是一个负值，但易于修复）。 同时，更详细地记录错误，这是一个加号。 </li><li> 使用此类时，主代码应拦截SPI2_IRQn和DMA1_Stream4_IRQn中断，并确保调用相应的processI2SInterrupt和processDmaTxInterrupt处理程序。 </li></ul><br><h3 id="osnovnaya-programma"> 主程序 </h3><br><p> 使用上述库很简单地编写了主程序： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_Init(); <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::A, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::B, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IOPort </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultPortC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IOPort::PortName::C, GPIO_MODE_INPUT, GPIO_PULLDOWN)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// System frequency 168MHz System::ClockDiv clkDiv; clkDiv.PLLM = 16; clkDiv.PLLN = 336; clkDiv.PLLP = 2; clkDiv.PLLQ = 7; clkDiv.AHBCLKDivider = RCC_SYSCLK_DIV1; clkDiv.APB1CLKDivider = RCC_HCLK_DIV8; clkDiv.APB2CLKDivider = RCC_HCLK_DIV8; clkDiv.PLLI2SN = 192; clkDiv.PLLI2SR = 2; do { System::setClock(clkDiv, FLASH_LATENCY_3, System::RtcType::RTC_EXT); } while (System::getMcuFreq() != 168000000L); MyApplication app; appPtr = &amp;app; app.run(); }</span></span></code> </pre> <br><p> 在这里，我们初始化HAL库，默认情况下通过输入（GPIO_MODE_INPUT / PULLDOWN）配置所有控制器引脚。 设置控制器的频率，启动时钟（包括来自外部石英的实时时钟）。 然后，以Java的风格，创建一个应用程序实例并调用其run方法，该方法实现了所有应用程序逻辑。 </p><br><p> 在单独的部分中，我们必须定义所有使用的中断。 由于我们使用C ++编写，并且中断是C语言世界中的东西，因此我们需要相应地屏蔽它们： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTick_Handler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HAL_IncTick(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appPtr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { appPtr-&gt;getRtc().onMilliSecondInterrupt(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream3_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaRxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA2_Stream6_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDIO_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Devices::SdCard::getInstance()-&gt;processSdIOInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPI2_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processI2SInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DMA1_Stream4_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;getI2S().processDmaTxInterrupt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_I2S_TxCpltCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2S_HandleTypeDef *channel)</span></span></span><span class="hljs-function"> </span></span>{ appPtr-&gt;processDmaTxCpltCallback(channel); } ... }</code> </pre> <br><p>  MyApplication类声明所有使用的设备，为所有这些设备调用构造函数，并实现必要的事件处理程序： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RealTimeClock::EventHandler, WavStreamer::EventHandler, Devices::Button::EventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> INPUT_PINS = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Number of monitored input pins private: UsartLogger log; RealTimeClock rtc; IOPin ledGreen, ledBlue, ledRed; PeriodicalEvent heartbeatEvent; IOPin mco; // Interrupt priorities InterruptPriority irqPrioI2S; InterruptPriority irqPrioEsp; InterruptPriority irqPrioSd; InterruptPriority irqPrioRtc; // SD card IOPin pinSdPower, pinSdDetect; IOPort portSd1, portSd2; SdCard sdCard; bool sdCardInserted; // Configuration Config config; // ESP Esp11 esp; EspSender espSender; // Input pins std::array&lt;IOPin, INPUT_PINS&gt; pins; std::array&lt;bool, INPUT_PINS&gt; pinsState; // I2S2 Audio I2S i2s; AudioDac_UDA1334 audioDac; WavStreamer streamer; Devices::Button playButton; ...</span></span></code> </pre> <br><p> 也就是说，实际上，所有用过的设备都是静态声明的，这有可能导致用过的内存增加，但大大简化了对数据的访问。 在MyApplication类的构造函数中，有必要调用所有设备的设计器，然后在启动运行过程之前，将初始化所有使用的微控制器设备： </p><br><pre> <code class="cpp hljs"> MyApplication::MyApplication () : <span class="hljs-comment"><span class="hljs-comment">// logging log(Usart::USART_1, IOPort::B, GPIO_PIN_6, GPIO_PIN_7, 115200), // RTC rtc(), ledGreen(IOPort::C, GPIO_PIN_1, GPIO_MODE_OUTPUT_PP), ledBlue(IOPort::C, GPIO_PIN_2, GPIO_MODE_OUTPUT_PP), ledRed(IOPort::C, GPIO_PIN_3, GPIO_MODE_OUTPUT_PP), heartbeatEvent(rtc, 10, 2), mco(IOPort::A, GPIO_PIN_8, GPIO_MODE_AF_PP), // Interrupt priorities irqPrioI2S(6, 0), // I2S DMA interrupt priority: 7 will be also used irqPrioEsp(5, 0), irqPrioSd(3, 0), // SD DMA interrupt priority: 4 will be also used irqPrioRtc(2, 0), // SD card pinSdPower(IOPort::A, GPIO_PIN_15, GPIO_MODE_OUTPUT_PP, GPIO_PULLDOWN, GPIO_SPEED_HIGH, true, false), pinSdDetect(IOPort::B, GPIO_PIN_3, GPIO_MODE_INPUT, GPIO_PULLUP), portSd1(IOPort::C, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12, /* callInit = */false), portSd2(IOPort::D, /* mode = */GPIO_MODE_OUTPUT_PP, /* pull = */GPIO_PULLUP, /* speed = */GPIO_SPEED_FREQ_VERY_HIGH, /* pin = */GPIO_PIN_2, /* callInit = */false), sdCard(pinSdDetect, portSd1, portSd2), sdCardInserted(false), // Configuration config(pinSdPower, sdCard, "conf.txt"), //ESP esp(rtc, Usart::USART_2, IOPort::A, GPIO_PIN_2, GPIO_PIN_3, irqPrioEsp, IOPort::A, GPIO_PIN_1), espSender(rtc, esp, ledRed), // Input pins pins { { IOPin(IOPort::A, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_6, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::A, GPIO_PIN_7, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::C, GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_0, GPIO_MODE_INPUT, GPIO_PULLUP), IOPin(IOPort::B, GPIO_PIN_1, GPIO_MODE_INPUT, GPIO_PULLUP) } }, // I2S2 Audio Configuration // PB10 --&gt; I2S2_CK // PB12 --&gt; I2S2_WS // PB15 --&gt; I2S2_SD i2s(IOPort::B, GPIO_PIN_10 | GPIO_PIN_12 | GPIO_PIN_15, irqPrioI2S), audioDac(i2s, /* power = */ IOPort::B, GPIO_PIN_11, /* mute = */ IOPort::B, GPIO_PIN_13, /* smplFreq = */ IOPort::B, GPIO_PIN_14), streamer(sdCard, audioDac), playButton(IOPort::B, GPIO_PIN_2, GPIO_PULLUP, rtc) { mco.activateClockOutput(RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_5); }</span></span></code> </pre> <br><p> 例如，用于单击开始/停止播放WAV文件的按钮的事件处理程序： </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::onButtonPressed (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Devices::Button * b, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numOccured) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == &amp;playButton) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"play button pressed: "</span></span> &lt;&lt; numOccured); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (streamer.isActive()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Stopping WAV"</span></span>); streamer.stop(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">" Starting WAV"</span></span>); streamer.start(AudioDac_UDA1334::SourceType:: STREAM, config.getWavFile()); } } }</code> </pre> <br><p> 最后，main run方法完成设备的配置（例如，将MyApplication设置为事件处理程序），并启动一个无限循环，在该循环中，它周期性地引用需要定期关注的设备： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyApplication::run () { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.initInstance(); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Oscillator frequency: "</span></span> &lt;&lt; System::getExternalOscillatorFreq() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", MCU frequency: "</span></span> &lt;&lt; System::getMcuFreq()); HAL_StatusTypeDef status = HAL_TIMEOUT; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { status = rtc.start(<span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">2047</span></span> + <span class="hljs-number"><span class="hljs-number">7</span></span>, RTC_WAKEUPCLOCK_RTCCLK_DIV2, irqPrioRtc, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"RTC start status: "</span></span> &lt;&lt; status); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (status != HAL_OK); sdCard.setIrqPrio(irqPrioSd); sdCard.initInstance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sdCard.isCardInserted()) { updateSdCardState(); } USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins: "</span></span> &lt;&lt; pins.size()); pinsState.fill(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Pin state: "</span></span> &lt;&lt; fillMessage()); esp.assignSendLed(&amp;ledGreen); streamer.stop(); streamer.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); streamer.setVolume(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); playButton.setHandler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { updateSdCardState(); playButton.periodic(); streamer.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInputPinsChanged()) { USART_DEBUG(<span class="hljs-string"><span class="hljs-string">"Input pins change detected"</span></span>); ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); reportState = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } espSender.periodic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (espSender.isOutputMessageSent()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reportState) { espSender.sendMessage(config, <span class="hljs-string"><span class="hljs-string">"TCP"</span></span>, config.getServerIp(), config.getServerPort(), fillMessage()); reportState = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!reportState) { ledBlue.putBit(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heartbeatEvent.isOccured()) { ledGreen.putBit(heartbeatEvent.occurance() == <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br><h3 id="nemnogo-eksperimentov"> 一点实验 </h3><br><p>   —    .    — 168 MHz. ,   ,      172 MHz   180 MHz,          ,      ,         MCO.     ,   USART  I2S, ,  ,      HAL. </p><br><h2 id="cena">  </h2><br><p>        .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://htmlpreview.github.io/%3F">github</a>     .    - ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mouser</a> (   ).     37      .            .  ,        STM  Olimex,      . </p><br><h2 id="problemy-i-perspektivy">    </h2><br><p>        .       ,   : </p><br><ul><li>        (   ).  ,       ,            .       :     4  8 .        PLL,         . </li><li>    ,       .      47 μF  . ,    . </li><li>   SWD      .    -  ,     .     . </li><li>     .     SMD ,    .       3       . </li></ul><br><h2 id="dokumentaciya"> 该文件 </h2><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>   GPL v3: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.google.com/viewer%3Furl%3D"></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.google.com/viewer%3Furl%3D"></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.google.com/viewer%3Furl%3D"> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://htmlpreview.github.io/%3F"> </a> </li></ul><br><p> 感谢您的关注！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413101/">https://habr.com/ru/post/zh-CN413101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413091/index.html">在SpringBoot + Log4j2 + Maven中方便地记录日志</a></li>
<li><a href="../zh-CN413093/index.html">预期美国和中国的太空商人竞赛</a></li>
<li><a href="../zh-CN413095/index.html">神经网络技术的应用：软件开发</a></li>
<li><a href="../zh-CN413097/index.html">基于企业级软件，经过了数百万次测试：openSUSE Leap 15已发布</a></li>
<li><a href="../zh-CN413099/index.html">Macbook上的降频RAM</a></li>
<li><a href="../zh-CN413103/index.html">3CX v15.5 Update 5 Beta和REST与AmoCRM集成发布</a></li>
<li><a href="../zh-CN413105/index.html">物联网提供商的说明。 LoraWAN中的激活和安全性</a></li>
<li><a href="../zh-CN413107/index.html">Svelto.ECS项目Wiki的翻译。 适用于Unity3D的ECS框架</a></li>
<li><a href="../zh-CN413109/index.html">如何构建SaaS产品集成平台：Poster Cloud Checkout体验</a></li>
<li><a href="../zh-CN413111/index.html">STM32 + NetBeans =？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>