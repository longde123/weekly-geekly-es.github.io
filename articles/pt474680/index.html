<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé§ üëÜüèæ üë®üèø‚Äçü§ù‚Äçüë®üèº AI e 2048. Parte 2: Recorte Minimax + alfa beta üêÉ ü§© üë∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Examinamos o m√©todo de Monte Carlo , hoje veremos como a mente do computador funciona em 2048 usando o bom e velho minimax com recorte alfa-beta. 

  ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI e 2048. Parte 2: Recorte Minimax + alfa beta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474680/"><div style="text-align:center;"><img width="690" height="314" src="https://habrastorage.org/webt/9t/ym/10/9tym105d327kylbfpejz4inkdxu.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Examinamos o m√©todo de Monte Carlo</a> , hoje veremos como a mente do computador funciona em 2048 usando o bom e velho minimax com recorte alfa-beta. <a name="habracut"></a><br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="EDISON Software - desenvolvimento web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - desenvolvimento web"></a> <br clear="right">  O artigo foi escrito com o apoio da EDISON, uma empresa que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desenvolve aplicativos m√≥veis</a> e fornece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">servi√ßos de teste de software</a> . </blockquote><br>  Solu√ß√£o espionada pelo usu√°rio stackoverflow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="14" height="14" src="https://habrastorage.org/webt/7c/q2/x_/7cq2x_1w7otpr1ksh4yryg83h4c.jpeg"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ovolve</a> , que observou na discuss√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como ensinar √† IA o jogo 2048</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Tradu√ß√£o de coment√°rios de ovolve</b> <div class="spoiler_text">  Eu sou o autor do programa mencionado neste t√≥pico.  Voc√™ pode ver a IA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em a√ß√£o</a> ou ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o c√≥digo</a> . <br><br>  Atualmente, o programa vence em cerca de 90% dos casos executando scripts java em um navegador no meu laptop, gastando 100 milissegundos para pensar no curso, funcionando, embora n√£o perfeitamente, mas muito bem. <br><br>  Como o jogo √© um espa√ßo de estado discreto com informa√ß√µes completas, na verdade, √© um jogo baseado em turnos, como xadrez e damas, usei os mesmos m√©todos que mostraram seu desempenho nesses jogos, ou seja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisa minimax</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recorte alfa-beta</a> .  Como os links fornecem muitas informa√ß√µes sobre esse algoritmo, falarei sobre as duas heur√≠sticas principais que usei na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√£o de estimativa est√°tica</a> e formalizei muitas das suposi√ß√µes intuitivas feitas por outras pessoas aqui. <br><br><img align="right" width="344" height="343" src="https://habrastorage.org/webt/hm/s0/cu/hms0cuvsvpeyvyvozxm-3f88xui.png"><br clear="left"><h3>  Monotonia </h3><br>  Essa heur√≠stica tenta garantir que todos os valores do bloco aumentem ou diminuam a esquerda / direita e para cima / para baixo.  Somente essa heur√≠stica reflete a conjectura de que muitos outros mencionaram que blocos mais valiosos devem ser agrupados em um canto.  Como regra, isso evita o ac√∫mulo de ladrilhos menos valiosos e mant√©m o tabuleiro organizado, √† medida que ladrilhos menores passam por cascatas em outros maiores. <br><br>  Aqui est√° uma captura de tela de uma grade completamente mon√≥tona.  Eu entendi essa situa√ß√£o executando um algoritmo com a fun√ß√£o eval instalada, a fim de ignorar outras heur√≠sticas e levar em conta apenas a monotonia. <br><br><img align="right" width="342" height="343" src="https://habrastorage.org/webt/iq/wp/4p/iqwp4pn8rsoynb1u6eknm99gmt8.png"><br clear="left"><h3>  Suavidade (suavidade, uniformidade) </h3><br>  A heur√≠stica acima, por si s√≥, tende a criar estruturas nas quais as c√©lulas vizinhas s√£o reduzidas em valor; no entanto, √© claro, as vizinhas devem ter o mesmo significado para combinar.  Portanto, a heur√≠stica da suavidade mede simplesmente a diferen√ßa de valores entre os blocos adjacentes, tentando minimizar seu n√∫mero. <br><br>  Um comentarista do Hacker News forneceu uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">formaliza√ß√£o interessante</a> dessa id√©ia em termos de teoria dos grafos. <br><br><div class="spoiler">  <b class="spoiler_title">Tradu√ß√£o da formaliza√ß√£o com Hacker News</b> <div class="spoiler_text"><blockquote>  Ontem mostrei este jogo a um colega, um amante da teoria dos grafos, e tamb√©m decidimos pensar em como resolver esse jogo usando IA. <br><br>  A solu√ß√£o mais simples √© o minimax, que, a meu ver, √© implementado muito bem.  Se algu√©m aqui n√£o estiver familiarizado com o minimax, o OP escreveu um c√≥digo muito elegante e bem comentado, que seria um √≥timo tutorial. <br><br>  A abordagem menos intensiva em termos de computa√ß√£o que propusemos foi modelar o estado do jogo na forma de um gr√°fico <b>G (V, E)</b> , em que <b>V</b> √© um conjunto de blocos ativos e <b>E</b> √© um conjunto de arestas que conectam blocos adjacentes ponderados pela fun√ß√£o <b>c (v1, v2)</b> , que retorna o valor absoluto da diferen√ßa entre os dois blocos.  Para cada solu√ß√£o, a IA escolhe uma jogada que minimiza a soma dos pesos de todas as arestas no novo estado do jogo. <br><br>  A raz√£o para isso √© que a √∫nica maneira de progredir no jogo √© ter pe√ßas com os mesmos valores pr√≥ximos umas das outras, para as quais o peso em <b>G</b> ser√° 0. Portanto, a IA deve tentar minimizar o peso total.  No final, haver√° um grande n√∫mero nas placas com um grande peso de arestas nos ladrilhos adjacentes; portanto, a IA tentar√° manter esses ladrilhos ao lado de outros ladrilhos grandes para minimizar a diferen√ßa. <br><br>  Como o jogo √© estoc√°stico, a abordagem que eu descrevi pode n√£o funcionar no pior dos casos, mas tamb√©m pode ser aplicada √† solu√ß√£o minimax existente como uma fun√ß√£o de peso para cada n√≥ na √°rvore. </blockquote></div></div><br><br>  Aqui est√° uma captura de tela de uma malha perfeitamente lisa, gentilmente fornecida por este excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20140315093348/">garfo falso</a> .  <i>(link para o arquivo da web, enquanto os scripts Java na p√°gina funcionam e voc√™ pode usar o teclado para mover-se em qualquer dire√ß√£o - nota do tradutor).</i> <br><br><h3>  Ladrilhos soltos </h3><br>  E, finalmente, h√° uma penalidade por ter poucas pe√ßas gratuitas, pois as op√ß√µes podem terminar rapidamente quando o campo de jogo fica muito apertado. <br><br>  E isso √© tudo!  A pesquisa no espa√ßo do jogo e a otimiza√ß√£o desses crit√©rios oferecem um desempenho surpreendentemente bom.  Um dos benef√≠cios de usar uma abordagem gen√©rica como essa, em vez de uma estrat√©gia de movimenta√ß√£o explicitamente codificada, √© que o algoritmo pode frequentemente encontrar solu√ß√µes interessantes e inesperadas.  Se voc√™ observar seu progresso, ele geralmente faz movimentos surpreendentes, mas eficazes, como a mudan√ßa repentina de paredes ou cantos, perto dos quais ele constr√≥i seu jogo. <br><br><img align="right" width="345" height="499" src="https://habrastorage.org/webt/tc/oi/hz/tcoihzahmdqlw9cxthywpapiwsa.png"><br clear="left"><h3>  Pequena mudan√ßa </h3><br>  A captura de tela demonstra o poder dessa abordagem.  Eu removi o limite do bloco (para que eles continuem a crescer depois de chegar a 2048), e aqui est√° o melhor resultado ap√≥s oito testes. <br><br>  Sim, isso √© 4096 junto com 2048. =) Isso significa que ele alcan√ßou o esquivo 2048 em uma placa. </div></div><br><hr><hr><hr><hr><hr><br>  O c√≥digo Java-Script para minimax com recorte alfa-beta e fun√ß√£o de avalia√ß√£o est√°tica do ovove do usu√°rio do stackoverflow √© fornecido abaixo no artigo. <br><br>  O m√©todo minimax √© dedicado a v√°rios excelentes artigos de habr, portanto omitimos a explica√ß√£o acad√™mica detalhada do que ele consiste.  Para aqueles que se <strike>juntaram √† comunidade de TI,</strike> ouvi <strike>recentemente</strike> os belos termos "minimax" e "recorte alfa-beta", mas n√£o sabem o que isso significa, vamos tentar, literalmente, em alguns par√°grafos, explicar o significado mais geral. <br><br><h2>  Minimax </h2><br>  Em alguns jogos, o processo de um jogo entre dois jogadores (que fazem um lance por sua vez) pode ser representado como uma chamada √°rvore de op√ß√µes.  Em cada posi√ß√£o espec√≠fica, cada jogador geralmente tem uma escolha entre diferentes op√ß√µes para sua jogada.  E em resposta a cada uma dessas op√ß√µes, um oponente tamb√©m pode ser como de v√°rias maneiras. <br><br><div style="text-align:center;"><img width="690" height="525" src="https://habrastorage.org/webt/xi/ye/j2/xiyej2z5e4n-kigoscjrgfpf2i8.png"></div><br>  <sup><em>Fragmento de uma √°rvore de op√ß√µes</em></sup> <br><br>  Como em qualquer momento do jogo h√° informa√ß√µes completas sobre o estado do campo de jogo, o estado atual da posi√ß√£o sempre pode ser estimado com precis√£o.  Essa fun√ß√£o √© chamada <strong>fun√ß√£o de avalia√ß√£o est√°tica</strong> ou <strong>SFO</strong> abreviado.  Al√©m disso, quanto mais importante √© essa fun√ß√£o ao avaliar uma posi√ß√£o espec√≠fica, mais vantajosa √© a posi√ß√£o de um jogador (vamos cham√°-lo de <strong>jogador maximizador</strong> ).  Quanto menor o valor num√©rico dessa fun√ß√£o ao avaliar uma posi√ß√£o, mais vantajosa √© a posi√ß√£o para o segundo jogador (vamos cham√°-lo de <strong>jogador minimizador</strong> ). <br><br>  Ap√≥s cada movimento, a posi√ß√£o muda e, portanto, sua pontua√ß√£o muda.  Ao considerar a √°rvore de op√ß√µes, cada jogador precisa n√£o apenas preferir aqueles ramos nos quais a classifica√ß√£o √© mais favor√°vel para ele.  Voc√™ tamb√©m deve evitar aqueles ramos em que a avalia√ß√£o da posi√ß√£o √© favor√°vel ao oponente. <br><br>  Sup√µe-se que o oponente tamb√©m seja guiado pelo racionalismo e tamb√©m evite op√ß√µes que possam lev√°-lo a perder.  Ou seja, cada jogador, ao escolher uma op√ß√£o, prossegue maximizando seu pr√≥prio benef√≠cio e, ao mesmo tempo, minimizando o lucro do oponente. <br><br>  Isso √© minimax. <br><br><h2>  Recorte alfa beta </h2><br>  √â bastante √≥bvio: quem calcula uma √°rvore de uma determinada posi√ß√£o para uma profundidade maior, ele tem mais chances de ganhar.  Mas h√° um inc√¥modo - a √°rvore de op√ß√µes nos jogos tem o h√°bito desagrad√°vel de ramificar e crescer exponencialmente a cada n√≠vel de aninhamento.  As habilidades de contagem de programas e, ainda mais, as pessoas s√£o limitadas, contando "at√© o fim" est√° longe de ser sempre poss√≠vel.  Pode facilmente acontecer que o jogador tenha contado at√© uma posi√ß√£o em que tenha uma boa avalia√ß√£o do campo de jogo, mas literalmente no pr√≥ximo n√≠vel (ileg√≠vel), o oponente tem a oportunidade de fazer um movimento que muda radicalmente a estimativa de posi√ß√£o para o oposto. <br><br>  Quem √© o culpado e o que fazer?  A complexidade computacional √© respons√°vel pelo percurso completo da √°rvore; prop√µe-se combater cortando galhos desnecess√°rios.  Se o jogador que est√° avaliando a posi√ß√£o v√™ que algum ramo da √°rvore de op√ß√µes: <br><br>  ou menos rent√°vel para ele do que outros ramos que j√° foram analisados, <br>  ou mais ben√©fico para o oponente do que outros ramos que j√° foram analisados, <br><br>  ent√£o o jogador descarta esse ramo, n√£o perde tempo e recursos ao considerar subop√ß√µes deste ramo obviamente pior para ele. <br><br>  Isso permite que voc√™ aloque mais recursos de computa√ß√£o para calcular ramifica√ß√µes mais favor√°veis ‚Äã‚Äãa uma maior profundidade de renderiza√ß√£o na √°rvore de op√ß√µes.  No processo de avalia√ß√£o do campo de jogo em diferentes n√≠veis da √°rvore de op√ß√µes, o jogador opera com dois coeficientes dinamicamente vari√°veis ‚Äã‚Äã- <strong>alfa</strong> (o valor do SFD que √© minimamente encontrado no ramo - ou seja, mais favor√°vel para o jogador que minimiza) e <strong>beta</strong> (o valor do SFD que √© mais encontrado no ramo - ou seja. mais favor√°vel para o jogador maximizador).  Em cada n√≠vel, comparar o SFD da posi√ß√£o atual com <em>os</em> coeficientes <em>alfa</em> e <em>beta</em> permite varrer (sem calcul√°-los completamente) ramos que s√£o <em>menos favor√°veis</em> para o jogador que avalia a posi√ß√£o e / ou <em>mais ben√©ficos</em> para o oponente. <br><br>  Este √© um recorte alfa beta. <br><br><h3>  Fun√ß√£o minimax recursiva com recorte alfa beta </h3><br><div class="spoiler">  <b class="spoiler_title">2048 com AI √© implementado como um aplicativo Excel com macros VBA, √© assim que o algoritmo minimax com recorte alfa beta parece um desprez√≠vel visual basic.</b> <div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''( - )''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '       -- 'Position -  4  4     'Depth - ,    'Alpha, Beta -         'MaximisingPlayer -      ? Private Function MiniMaxAlpaBeta_Evaluation(Position As Variant, Depth As Long, _ Alpha As Double, Beta As Double, _ MaximisingPlayer As Boolean, _ Optional MainLevel As Boolean = False) As Double Dim MaxEval As Double '  Dim MinEval As Double '  Dim PositionNext As Variant '     Dim PositionTemp As Variant '     Dim Eval As Double '   Dim Way As Long '   -      Dim Row As Long '     Dim Col As Long '     Dim TileNew As Long '      '   (  ,  '     ) If GameOverPosition(Position) Then '    ? '     MiniMaxAlpaBeta_Evaluation = -1000000 + TileMax(Position) '         ElseIf Depth = 0 Then '     MiniMaxAlpaBeta_Evaluation = StaticEvaluation(Position) '  ,    '     () ElseIf MaximisingPlayer Then MaxEval = -1000000 '      For Way = 1 To 4 ' 4   - (, , , ) ChangeCount = 0 ' ,      ',       PositionNext = StepHuman(Position, Way) If ChangeCount &gt; 0 Then '     '      , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, False) If Eval &gt; MaxEval Then MaxEval = Eval '  '     If Eval &gt; Alpha Then Alpha = Eval '    ,   '   -    If Beta &gt; Alpha Then Exit For End If Next '          MiniMaxAlpaBeta_Evaluation = MaxEval '  ,    '     () Else 'Not MaximisingPlayer MinEval = 1000000 '      For Row = 1 To 4 '     For Col = 1 To 4 '     If Position(Row, Col) = 0 Then '   For TileNew = 2 To 4 Step 2 '    2  4 ',       '    PositionNext = StepComp(Position, Row, Col, TileNew) '     , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, True) If Eval &lt; MinEval Then MinEval = Eval '  '     If Eval &lt; Beta Then Beta = Eval '    ,   '   -    If Alpha &lt; Beta Then Exit For Next End If Next Next '          MiniMaxAlpaBeta_Evaluation = MinEval End If End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Fornecer c√≥digo no java-script</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grid</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid = grid; } <span class="hljs-comment"><span class="hljs-comment">//   () AI.prototype.eval = function() { var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight; }; // alpha-beta depth first search AI.prototype.search = function(depth, alpha, beta, positions, cutoffs) { var bestScore; var bestMove = -1; var result; // the maxing player if (this.grid.playerTurn) { bestScore = alpha; for (var direction in [0, 1, 2, 3]) { var newGrid = this.grid.clone(); if (newGrid.move(direction).moved) { positions++; if (newGrid.isWin()) { return { move: direction, score: 10000, positions: positions, cutoffs: cutoffs }; } var newAI = new AI(newGrid); if (depth == 0) { result = { move: direction, score: newAI.eval() }; } else { result = newAI.search(depth-1, bestScore, beta, positions, cutoffs); if (result.score &gt; 9900) { // win result.score--; // to slightly penalize higher depth from win } positions = result.positions; cutoffs = result.cutoffs; } if (result.score &gt; bestScore) { bestScore = result.score; bestMove = direction; } if (bestScore &gt; beta) { cutoffs++ return { move: bestMove, score: beta, positions: positions, cutoffs: cutoffs }; } } } } else { // computer's turn, we'll do heavy pruning to keep the branching factor low bestScore = beta; // try a 2 and 4 in each cell and measure how annoying it is // with metrics from eval var candidates = []; var cells = this.grid.availableCells(); var scores = { 2: [], 4: [] }; for (var value in scores) { for (var i in cells) { scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); } } // now just pick out the most annoying moves var maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4])); for (var value in scores) { // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) { if (scores[value][i] == maxScore) { candidates.push( { position: cells[i], value: parseInt(value, 10) } ); } } } // search on each candidate for (var i=0; i&lt;candidates.length; i++) { var position = candidates[i].position; var value = candidates[i].value; var newGrid = this.grid.clone(); var tile = new Tile(position, value); newGrid.insertTile(tile); newGrid.playerTurn = true; positions++; newAI = new AI(newGrid); result = newAI.search(depth, alpha, bestScore, positions, cutoffs); positions = result.positions; cutoffs = result.cutoffs; if (result.score &lt; bestScore) { bestScore = result.score; } if (bestScore &lt; alpha) { cutoffs++; return { move: null, score: alpha, positions: positions, cutoffs: cutoffs }; } } } return { move: bestMove, score: bestScore, positions: positions, cutoffs: cutoffs }; } // performs a search and returns the best move AI.prototype.getBest = function() { return this.iterativeDeep(); } // performs iterative deepening over the alpha-beta search AI.prototype.iterativeDeep = function() { var start = (new Date()).getTime(); var depth = 0; var best; do { var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) { break; } else { best = newBest; } depth++; } while ( (new Date()).getTime() - start &lt; minSearchTime); return best } AI.prototype.translate = function(move) { return { 0: 'up', 1: 'right', 2: 'down', 3: 'left' }[move]; }</span></span></code> </pre> </div></div><br><h2>  Fun√ß√£o de Avalia√ß√£o Est√°tica </h2><br>  Como em cada n√≠vel da √°rvore de op√ß√µes √© necess√°rio avaliar o campo de jogo (para decidir para qual dos jogadores, a posi√ß√£o estimada √© realmente mais vantajosa), voc√™ precisa decidir quais crit√©rios distinguem uma boa posi√ß√£o da ruim. <br><br>  Assumimos que o jogador que maximiza √© a pessoa (ou AI) que decide em qual das 4 dire√ß√µes (para cima, esquerda, direita, baixo) deve mover todas as pe√ßas.  Um jogador que minimiza √© a sub-rotina insidiosa que gera aleatoriamente 2 ou 4 nos locais mais inadequados. <br><br>  O SFO √© compilado do ponto de vista de um jogador maximizador.  Quanto maior a classifica√ß√£o SFD para o campo de jogo, melhor a posi√ß√£o para o "maximalist".  Quanto menor - mais agrad√°vel √© a posi√ß√£o no quadro para o "minimalista". <br><br>  No caso de 2048 - que fatores s√£o considerados favor√°veis ‚Äã‚Äãpara quem move as pe√ßas? <br><br><h3>  Monotonia </h3><img align="right" width="388" height="189" src="https://habrastorage.org/webt/r8/jc/qt/r8jcqtbvrsyvrfwwsmeedgfrzrg.png"><br clear="left">  Em primeiro lugar, √© desej√°vel que as pe√ßas sejam dispostas em ordem crescente / decrescente em algumas dire√ß√µes.  Se isso n√£o for feito, quando novas pe√ßas forem geradas, o campo de jogo rapidamente ficar√° entupido com pe√ßas dispostas aleatoriamente de tamanhos diferentes, que n√£o podem ser imediatamente conectados normalmente entre si. <br><br>  No Distrito Federal da Sib√©ria, voc√™ precisa olhar em todas as quatro dire√ß√µes (de cima para baixo, da esquerda para a direita, da direita para a esquerda, de baixo para cima) e calcular onde os blocos s√£o uma progress√£o crescente ou decrescente.  Se em progress√£o houver blocos que n√£o se encaixam na s√©rie geral, isso reduz o coeficiente num√©rico da monotonia.  A partir dos 4 coeficientes para todas as dire√ß√µes, √© selecionado o melhor, que √© levado em considera√ß√£o no valor total do Distrito Federal da Sib√©ria. <br><br><h3>  Suavidade </h3><img align="right" width="387" height="189" src="https://habrastorage.org/webt/uw/mq/wh/uwmqwht6dm82fc_zptwwdqdar2c.png"><br clear="left">  Al√©m disso, seria mais prefer√≠vel se a progress√£o de ficar em uma fileira de pe√ßas n√£o estivesse apenas aumentando, mas n√£o diminuindo (ou, em vez de diminuir a linha, √© prefer√≠vel a n√£o aumentar), ou seja, √© bom quando as mesmas pe√ßas estiverem pr√≥ximas, o que lhes permite colapsar em uma, ganhando pontos e aumentando o espa√ßo livre no campo de jogo. <br><br>  Portanto, o Distrito Federal da Sib√©ria est√° procurando as mesmas pe√ßas adjacentes no campo de jogo e leva em considera√ß√£o o n√∫mero desses pares em um coeficiente especial. <br><br><h3>  C√©lulas vazias </h3><img align="right" width="387" height="193" src="https://habrastorage.org/webt/qj/as/ay/qjasayisfgowdqcciifm0igt3ru.png"><br clear="left">  Obviamente, quanto mais espa√ßo livre, mais espa√ßo para manobra e menos chances de perder rapidamente. <br><br>  A SFO considera as c√©lulas vazias no campo e, quanto mais, a posi√ß√£o √© considerada mais lucrativa para o jogador maximizador. <br><br><h3>  Ladrilho m√°ximo </h3><br>  Como o principal neste jogo √© colocar um bloco grande em campo, quanto melhor - 2048, 4096, 8192 (ou o que voc√™ tiver for√ßa e paci√™ncia), as op√ß√µes em que o valor m√°ximo do bloco √© mais devem ser consideradas como o SFD mais lucrativo. <br><br><h3>  Distrito Federal da Sib√©ria para 2048 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementa√ß√£o do Distrito Federal Siberiano como uma macro VBA</b> <div class="spoiler_text"><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''  '''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '     'Position -  4  4     Private Function StaticEvaluation(Position As Variant) As Double Dim Smoothness As Double ' Dim Monotonicity As Double ' Dim EmptyCount As Double '  Dim MaxValue As Long '  '   Const SmoothWeight = 0.1 Const MonoWeight = 1 Const EmptyWeight = 2.7 Const MaxWeight = 1 Dim k As Long '   Dim i As Long '  Dim j As Long '  Dim x As Long '  Dim y As Long '  ' Dim Value As Double '       '         Dim TargetValue As Double Smoothness = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) &gt; 0 Then '   Value = Log(Position(i, j)) / Log(2) If i &lt; 4 Then '       For x = i + 1 To 4 '    If Position(x, j) &gt; 0 Then '    '    TargetValue = Log(Position(x, j)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '       Exit For End If Next End If If j &lt; 4 Then '       For y = j + 1 To 4 '    If Position(i, y) &gt; 0 Then '    '    TargetValue = Log(Position(i, y)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '        Exit For End If Next End If End If Next Next ' Dim arrTotals(1 To 4) As Double '     Dim Current As Long '   Dim Next_ As Long '      Dim CurrentValue As Double '      Dim NextValue As Double '        Monotonicity = 0 '    '      For k = 1 To 4 arrTotals(k) = 0 Next ' -  - For x = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(x, Next_) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(x, Current) &gt; 0 Then CurrentValue = Log(Position(x, Current)) / Log(2) Else CurrentValue = 0 End If ' MsgBox "Position[" &amp; x &amp; ", " &amp; Next_ &amp; "]=" &amp; Position(x, Next_) If Position(x, Next_) &gt; 0 Then NextValue = Log(Position(x, Next_)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Up) = arrTotals(Up) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Down) = arrTotals(Down) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Up) &gt;= arrTotals(Down), _ Monotonicity + arrTotals(Up), _ Monotonicity + arrTotals(Down)) ' -  - For y = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(Next_, y) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(Current, y) &gt; 0 Then CurrentValue = Log(Position(Current, y)) / Log(2) Else CurrentValue = 0 End If If Position(Next_, y) &gt; 0 Then NextValue = Log(Position(Next_, y)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Left) = arrTotals(Left) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Right) = arrTotals(Right) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Left) &gt;= arrTotals(Right), _ Monotonicity + arrTotals(Left), _ Monotonicity + arrTotals(Right)) '     EmptyCount = 0 '      MaxValue = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) = 0 Then '  ... '...     EmptyCount = EmptyCount + 1 '     ... ElseIf Position(i, j) &gt; MaxValue Then MaxValue = Position(i, j) '...    End If Next Next '   StaticEvaluation = Smoothness * SmoothWeight + _ Monotonicity * MonoWeight + _ Log_Base_Arg(EmptyCount) * EmptyWeight + _ MaxValue * MaxWeight End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Fornecer c√≥digo no java-script</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTiles = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.build(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerTurn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// pre-allocate these objects (for speed) Grid.prototype.indexes = []; for (var x=0; x&lt;4; x++) { Grid.prototype.indexes.push([]); for (var y=0; y&lt;4; y++) { Grid.prototype.indexes[x].push( {x:x, y:y} ); } } // Build a grid of the specified size Grid.prototype.build = function () { for (var x = 0; x &lt; this.size; x++) { var row = this.cells[x] = []; for (var y = 0; y &lt; this.size; y++) { row.push(null); } } }; // Find the first available random position Grid.prototype.randomAvailableCell = function () { var cells = this.availableCells(); if (cells.length) { return cells[Math.floor(Math.random() * cells.length)]; } }; Grid.prototype.availableCells = function () { var cells = []; var self = this; this.eachCell(function (x, y, tile) { if (!tile) { //cells.push(self.indexes[x][y]); cells.push( {x:x, y:y} ); } }); return cells; }; // Call callback for every cell Grid.prototype.eachCell = function (callback) { for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { callback(x, y, this.cells[x][y]); } } }; // Check if there are any cells available Grid.prototype.cellsAvailable = function () { return !!this.availableCells().length; }; // Check if the specified cell is taken Grid.prototype.cellAvailable = function (cell) { return !this.cellOccupied(cell); }; Grid.prototype.cellOccupied = function (cell) { return !!this.cellContent(cell); }; Grid.prototype.cellContent = function (cell) { if (this.withinBounds(cell)) { return this.cells[cell.x][cell.y]; } else { return null; } }; // Inserts a tile at its position Grid.prototype.insertTile = function (tile) { this.cells[tile.x][tile.y] = tile; }; Grid.prototype.removeTile = function (tile) { this.cells[tile.x][tile.y] = null; }; Grid.prototype.withinBounds = function (position) { return position.x &gt;= 0 &amp;&amp; position.x &lt; this.size &amp;&amp; position.y &gt;= 0 &amp;&amp; position.y &lt; this.size; }; Grid.prototype.clone = function() { newGrid = new Grid(this.size); newGrid.playerTurn = this.playerTurn; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { if (this.cells[x][y]) { newGrid.insertTile(this.cells[x][y].clone()); } } } return newGrid; }; // Set up the initial tiles to start the game with Grid.prototype.addStartTiles = function () { for (var i=0; i&lt;this.startTiles; i++) { this.addRandomTile(); } }; // Adds a tile in a random position Grid.prototype.addRandomTile = function () { if (this.cellsAvailable()) { var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); } }; // Save all tile positions and remove merger info Grid.prototype.prepareTiles = function () { this.eachCell(function (x, y, tile) { if (tile) { tile.mergedFrom = null; tile.savePosition(); } }); }; // Move a tile and its representation Grid.prototype.moveTile = function (tile, cell) { this.cells[tile.x][tile.y] = null; this.cells[cell.x][cell.y] = tile; tile.updatePosition(cell); }; Grid.prototype.vectors = { 0: { x: 0, y: -1 }, // up 1: { x: 1, y: 0 }, // right 2: { x: 0, y: 1 }, // down 3: { x: -1, y: 0 } // left } // Get the vector representing the chosen direction Grid.prototype.getVector = function (direction) { // Vectors representing tile movement return this.vectors[direction]; }; // Move tiles on the grid in the specified direction // returns true if move was successful Grid.prototype.move = function (direction) { // 0: up, 1: right, 2:down, 3: left var self = this; var cell, tile; var vector = this.getVector(direction); var traversals = this.buildTraversals(vector); var moved = false; var score = 0; var won = false; // Save the current tile positions and remove merger information this.prepareTiles(); // Traverse the grid in the right direction and move tiles traversals.x.forEach(function (x) { traversals.y.forEach(function (y) { cell = self.indexes[x][y]; tile = self.cellContent(cell); if (tile) { //if (debug) { //console.log('tile @', x, y); //} var positions = self.findFarthestPosition(cell, vector); var next = self.cellContent(positions.next); // Only one merger per row traversal? if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.mergedFrom) { var merged = new Tile(positions.next, tile.value * 2); merged.mergedFrom = [tile, next]; self.insertTile(merged); self.removeTile(tile); // Converge the two tiles' positions tile.updatePosition(positions.next); // Update the score score += merged.value; // The mighty 2048 tile if (merged.value === 2048) { won = true; } } else { //if (debug) { //console.log(cell); //console.log(tile); //} self.moveTile(tile, positions.farthest); } if (!self.positionsEqual(cell, tile)) { self.playerTurn = false; //console.log('setting player turn to ', self.playerTurn); moved = true; // The tile moved from its original cell! } } }); }); //console.log('returning, playerturn is', self.playerTurn); //if (!moved) { //console.log('cell', cell); //console.log('tile', tile); //console.log('direction', direction); //console.log(this.toString()); //} return {moved: moved, score: score, won: won}; }; Grid.prototype.computerMove = function() { this.addRandomTile(); this.playerTurn = true; } // Build a list of positions to traverse in the right order Grid.prototype.buildTraversals = function (vector) { var traversals = { x: [], y: [] }; for (var pos = 0; pos &lt; this.size; pos++) { traversals.x.push(pos); traversals.y.push(pos); } // Always traverse from the farthest cell in the chosen direction if (vector.x === 1) traversals.x = traversals.x.reverse(); if (vector.y === 1) traversals.y = traversals.y.reverse(); return traversals; }; Grid.prototype.findFarthestPosition = function (cell, vector) { var previous; // Progress towards the vector direction until an obstacle is found do { previous = cell; cell = { x: previous.x + vector.x, y: previous.y + vector.y }; } while (this.withinBounds(cell) &amp;&amp; this.cellAvailable(cell)); return { farthest: previous, next: cell // Used to check if a merge is required }; }; Grid.prototype.movesAvailable = function () { return this.cellsAvailable() || this.tileMatchesAvailable(); }; // Check for available matches between tiles (more expensive check) // returns the number of matches Grid.prototype.tileMatchesAvailable = function () { var self = this; //var matches = 0; var tile; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { tile = this.cellContent({ x: x, y: y }); if (tile) { for (var direction = 0; direction &lt; 4; direction++) { var vector = self.getVector(direction); var cell = { x: x + vector.x, y: y + vector.y }; var other = self.cellContent(cell); if (other &amp;&amp; other.value === tile.value) { return true; //matches++; // These two tiles can be merged } } } } } //console.log(matches); return false; //matches; }; Grid.prototype.positionsEqual = function (first, second) { return first.x === second.x &amp;&amp; first.y === second.y; }; Grid.prototype.toString = function() { string = ''; for (var i=0; i&lt;4; i++) { for (var j=0; j&lt;4; j++) { if (this.cells[j][i]) { string += this.cells[j][i].value + ' '; } else { string += '_ '; } } string += '\n'; } return string; } // counts the number of isolated groups. Grid.prototype.islands = function() { var self = this; var mark = function(x, y, value) { if (x &gt;= 0 &amp;&amp; x &lt;= 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 3 &amp;&amp; self.cells[x][y] &amp;&amp; self.cells[x][y].value == value &amp;&amp; !self.cells[x][y].marked ) { self.cells[x][y].marked = true; for (direction in [0,1,2,3]) { var vector = self.getVector(direction); mark(x + vector.x, y + vector.y, value); } } } var islands = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y]) { this.cells[x][y].marked = false } } } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y] &amp;&amp; !this.cells[x][y].marked) { islands++; mark(x, y , this.cells[x][y].value); } } } return islands; } // measures how smooth the grid is (as if the values of the pieces // were interpreted as elevations). Sums of the pairwise difference // between neighboring tiles (in log space, so it represents the // number of merges that need to happen before they can merge). // Note that the pieces can be distant Grid.prototype.smoothness = function() { var smoothness = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if ( this.cellOccupied( this.indexes[x][y] )) { var value = Math.log(this.cellContent( this.indexes[x][y] ).value) / Math.log(2); for (var direction=1; direction&lt;=2; direction++) { var vector = this.getVector(direction); var targetCell = this.findFarthestPosition(this.indexes[x][y], vector).next; if (this.cellOccupied(targetCell)) { var target = this.cellContent(targetCell); var targetValue = Math.log(target.value) / Math.log(2); smoothness -= Math.abs(value - targetValue); } } } } } return smoothness; } Grid.prototype.monotonicity = function() { var self = this; var marked = []; var queued = []; var highestValue = 0; var highestCell = {x:0, y:0}; for (var x=0; x&lt;4; x++) { marked.push([]); queued.push([]); for (var y=0; y&lt;4; y++) { marked[x].push(false); queued[x].push(false); if (this.cells[x][y] &amp;&amp; this.cells[x][y].value &gt; highestValue) { highestValue = this.cells[x][y].value; highestCell.x = x; highestCell.y = y; } } } increases = 0; cellQueue = [highestCell]; queued[highestCell.x][highestCell.y] = true; markList = [highestCell]; markAfter = 1; // only mark after all queued moves are done, as if searching in parallel var markAndScore = function(cell) { markList.push(cell); var value; if (self.cellOccupied(cell)) { value = Math.log(self.cellContent(cell).value) / Math.log(2); } else { value = 0; } for (direction in [0,1,2,3]) { var vector = self.getVector(direction); var target = { x: cell.x + vector.x, y: cell.y+vector.y } if (self.withinBounds(target) &amp;&amp; !marked[target.x][target.y]) { if ( self.cellOccupied(target) ) { targetValue = Math.log(self.cellContent(target).value ) / Math.log(2); if ( targetValue &gt; value ) { //console.log(cell, value, target, targetValue); increases += targetValue - value; } } if (!queued[target.x][target.y]) { cellQueue.push(target); queued[target.x][target.y] = true; } } } if (markAfter == 0) { while (markList.length &gt; 0) { var cel = markList.pop(); marked[cel.x][cel.y] = true; } markAfter = cellQueue.length; } } while (cellQueue.length &gt; 0) { markAfter--; markAndScore(cellQueue.shift()) } return -increases; } // measures how monotonic the grid is. This means the values of the tiles are strictly increasing // or decreasing in both the left/right and up/down directions Grid.prototype.monotonicity2 = function() { // scores for all four directions var totals = [0, 0, 0, 0]; // up/down direction for (var x=0; x&lt;4; x++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[x][next] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:x, y:current}) ? Math.log(this.cellContent( this.indexes[x][current] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:x, y:next}) ? Math.log(this.cellContent( this.indexes[x][next] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[0] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[1] += currentValue - nextValue; } current = next; next++; } } // left/right direction for (var y=0; y&lt;4; y++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[next][y] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:current, y:y}) ? Math.log(this.cellContent( this.indexes[current][y] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:next, y:y}) ? Math.log(this.cellContent( this.indexes[next][y] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[2] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[3] += currentValue - nextValue; } current = next; next++; } } return Math.max(totals[0], totals[1]) + Math.max(totals[2], totals[3]); } Grid.prototype.maxValue = function() { var max = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { var value = this.cellContent(this.indexes[x][y]).value; if (value &gt; max) { max = value; } } } } return Math.log(max) / Math.log(2); } // WIP. trying to favor top-heavy distributions (force consolidation of higher value tiles) /* Grid.prototype.valueSum = function() { var valueCount = []; for (var i=0; i&lt;11; i++) { valueCount.push(0); } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { valueCount[Math.log(this.cellContent(this.indexes[x][y]).value) / Math.log(2)]++; } } } var sum = 0; for (var i=1; i&lt;11; i++) { sum += valueCount[i] * Math.pow(2, i) + i; } return sum; } */ // check for win Grid.prototype.isWin = function() { var self = this; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (self.cellOccupied(this.indexes[x][y])) { if (self.cellContent(this.indexes[x][y]).value == 2048) { return true; } } } } return false; } //Grid.prototype.zobristTable = {} //for //Grid.prototype.hash = function() { //}</span></span></code> </pre> </div></div><br><h2>  2048.xlsm </h2><br>  O pr√≥prio aplicativo Excel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode ser baixado do Google</a> . <br><br>  A funcionalidade do aplicativo √© descrita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um artigo anterior, onde o AI √© reproduzido usando o m√©todo Monte Carlo</a> .  A solu√ß√£o de hoje foi adicionada ao Monte Carlo existente. <br><br><h3>  Todos os artigos das s√©ries AI e 2048 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monte Carlo</a> </li><li>  <strong>Recorte beta Minimax + alfa</strong> </li><li>  Aguardando o m√°ximo </li><li>  Rede neural </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474680/">https://habr.com/ru/post/pt474680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474668/index.html">A√ß√µes do GitHub como um IC / CD para um site em um gerador est√°tico e nas p√°ginas do GitHub</a></li>
<li><a href="../pt474672/index.html">Reagir, JSX, importa√ß√£o de m√≥dulos ES (incluindo din√¢mico) em um navegador sem Webpack</a></li>
<li><a href="../pt474674/index.html">Vis√£o de m√°quina e medicina</a></li>
<li><a href="../pt474676/index.html">O algoritmo de intera√ß√£o de centenas de milhares de part√≠culas √∫nicas na GPU, no GLES3 e WebGL2</a></li>
<li><a href="../pt474678/index.html">O Khronos Group criou um reposit√≥rio unificado com exemplos do Vulkan</a></li>
<li><a href="../pt474686/index.html">Hist√≥ria fant√°stica "Salva√ß√£o" (10 min.)</a></li>
<li><a href="../pt474688/index.html">Trem retr√¥ com uma locomotiva a vapor</a></li>
<li><a href="../pt474690/index.html">Criando um console com altura vari√°vel para um trabalho mais conveniente em um computador</a></li>
<li><a href="../pt474692/index.html">Revis√£o Skaffold para Kubernetes Development</a></li>
<li><a href="../pt474694/index.html">Como selecionamos e distorcemos a estrutura para teste de desempenho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>