<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚀 🤓 👨🏻‍✈️ Comment nous avons implémenté ML dans une application avec près de 50 millions d'utilisateurs. Expérience Sberbank 👨🏼‍🔧 👩🏼‍🍳 🍐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Nikolai et je suis engagé dans la construction et la mise en œuvre de modèles d'apprentissage automatique à Sberbank. Aujo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous avons implémenté ML dans une application avec près de 50 millions d'utilisateurs. Expérience Sberbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/461747/">  Bonjour, Habr!  Je m'appelle Nikolai et je suis engagé dans la construction et la mise en œuvre de modèles d'apprentissage automatique à Sberbank.  Aujourd'hui, je vais parler du développement d'un système de recommandation pour les paiements et les transferts dans l'application sur vos smartphones. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/358/23c/0f8/35823c0f8e513f268f58de291b8504c7.png"></a> <br>  <i>Conception de l'écran principal de l'application mobile avec recommandations</i> <br><br>  Nous avions 2 centaines de milliers d'options de paiement possibles, 55 millions de clients, 5 sources bancaires différentes, une demi-colonne développeur et une montagne d'activité bancaire, des algorithmes et tout cela, toutes les couleurs, ainsi qu'un litre de graines aléatoires, une boîte d'hyperparamètres, un demi-litre de facteurs de correction et deux des dizaines de bibliothèques.  Ce n'est pas que tout cela était nécessaire dans le travail, mais depuis qu'il a commencé à améliorer la vie des clients, allez dans votre passe-temps jusqu'à la fin.  Sous la coupe se trouve l'histoire de la bataille pour l'UX, la formulation correcte du problème, la lutte contre la dimensionnalité des données, la contribution à l'open source et nos résultats. <br><br><a name="habracut"></a><br><h2>  Énoncé du problème </h2><br>  Au fur et à mesure du développement et de l'extension, l'application Sberbank Online gagne des fonctionnalités utiles et des fonctionnalités supplémentaires.  En particulier, dans l'application, vous pouvez transférer de l'argent ou payer des services de diverses organisations. <br><br>  «Nous avons examiné attentivement tous les chemins utilisateur à l'intérieur de l'application et nous avons réalisé que beaucoup d'entre eux peuvent être considérablement réduits.  Pour ce faire, nous avons décidé de personnaliser l'écran principal en plusieurs étapes.  Tout d'abord, nous avons essayé de supprimer de l'écran ce que le client n'utilise pas, à commencer par les cartes bancaires.  Ensuite, ils ont mis en évidence les actions que le client avait déjà effectuées plus tôt et pour lesquelles il pouvait entrer dans l'application dès maintenant.  Maintenant, la liste des actions comprend les paiements aux organisations et les transferts aux contacts, puis la liste de ces actions sera élargie », a déclaré mon collègue Sergey Komarov, qui développe la fonctionnalité du point de vue du client dans l'équipe Sberbank Online.  Il est nécessaire de construire un modèle qui remplirait les emplacements désignés dans les widgets Actions (figure ci-dessus) avec des recommandations personnelles de paiements et de transferts au lieu de règles simples. <br><br><h2>  Solution </h2><br>  Dans l'équipe, nous avons décomposé la tâche en deux parties: <br><br><ul><li>  la recommandation de la répétition des opérations de paiement de services ou de transfert de fonds (bloc "Opérations recommandées") <br></li><li>  recommandation d'exemples de demandes de recherche de paiement pour des services non utilisés auparavant par ce client (bloc «Exemples de recherche») <br></li></ul><br>  Nous avons décidé de tester d'abord la fonctionnalité sur l'onglet de recherche: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/450/0ee/8fe4500ee0d612b4210a7237a643850b.png"></div><br>  <i>Conception d'écran de recherche recommandée</i> <br><br><h2>  Opérations recommandées </h2><br><h3>  Optimisation du scoring </h3><br>  Si nous définissons la sous-tâche comme une recommandation de répéter les opérations, cela nous permet de nous débarrasser du calcul et de l'évaluation de milliers de milliards de combinaisons de toutes les opérations possibles pour tous les clients et de nous concentrer sur un nombre beaucoup plus limité d'entre elles.  Si, sur l'ensemble des opérations disponibles pour nos clients, le client hypothétique avec le hachage YYY n'a utilisé que le paiement pour le gaz et le stationnement, alors nous évaluerons la probabilité de répéter uniquement ces opérations pour ce client: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33f/d0e/415/33fd0e4159a1143ff54c6834c0cd964d.png"><br>  <i>Un exemple de réduction de la dimension des données pour le scoring</i> <br><br><h3>  Préparation de l'ensemble de données </h3><br>  L'échantillon est une observation transactionnelle, enrichie de facteurs de démographie des clients, d'agrégats financiers et de diverses caractéristiques de fréquence d'une opération particulière. <br><br>  La variable cible dans ce cas est binaire et reflète le fait de l'événement le jour suivant le jour où les facteurs sont calculés.  Ainsi, en déplaçant itérativement le jour du calcul des facteurs et en positionnant le drapeau de la variable cible, nous multiplions et marquons les mêmes opérations et les marquons différemment selon la position par rapport à ce jour. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/618/c8a/929618c8a1fbcf3b2385300bf9669ae3.png"></div><br>  <i>Schéma d'observation</i> <br><br>  En calculant la coupe du 17/03/2019 pour le client "YYY", nous obtenons deux observations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/e70/741/78be707412f6a3fee92dcb5d62413de9.png"></div><br>  <i>Un exemple des observations pour un ensemble de données</i> <br><br>  «Fonction 1» peut signifier, par exemple, le solde sur toutes les cartes du client, «Fonction 2» - la présence de ce type d'opération la semaine dernière. <br><br>  Nous prenons les mêmes transactions, mais formons des observations pour une formation à une date différente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/901/c8e/618/901c8e6188d792bb9c77fc207f7d95d1.png"></div><br>  <i>Schéma d'observation</i> <br><br>  Nous obtiendrons des observations pour un ensemble de données avec d'autres valeurs des deux entités et de la variable cible: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e99/a4f/060/e99a4f0602c8c127f47aecee38f02292.png"><br>  <i>Un exemple des observations pour un ensemble de données</i> <br><br>  Dans les exemples ci-dessus, pour plus de clarté, les valeurs réelles des facteurs sont données, mais en fait, les valeurs sont traitées par un algorithme automatique: les résultats de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conversion WOE</a> sont introduits dans l'entrée du modèle.  Il vous permet d'amener les variables dans une relation monotone avec la variable cible et en même temps de vous débarrasser des effets des valeurs aberrantes.  Par exemple, nous avons le facteur «Nombre de cartes» et une certaine distribution de la variable cible: <br><br><img src="https://habrastorage.org/webt/4z/vz/xt/4zvzxtz04cy0corijvcyz4zfhf0.png"><br><br>  <i>Exemple de conversion WOE</i> <br><br>  La transformation WOE nous permet de transformer une dépendance non linéaire en au moins une dépendance monotone.  Chaque valeur du facteur analysé est associée à sa propre valeur WOE et donc un nouveau facteur est formé, et l'original est supprimé de l'ensemble de données: <br><br><img src="https://habrastorage.org/webt/9j/os/o4/9joso4mjqdpris64sxtrb3ji34k.png"><br>  <i>L'effet de la transformation WOE sur la relation avec la variable cible</i> <br><br>  Le dictionnaire de conversion des valeurs variables en WOE est enregistré et utilisé ultérieurement pour la notation.  Autrement dit, si nous devons calculer les probabilités pour demain, nous créons un ensemble de données comme dans les tableaux avec des exemples d'observations ci-dessus, convertissons les variables nécessaires en WOE avec le code enregistré et appliquons le modèle à ces données. <br><br><h3>  La formation </h3><br>  Le choix de la méthode était strictement limité - interprétabilité.  Par conséquent, afin de respecter les délais, il a été décidé de reporter les explications en utilisant le même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SHAP</a> dans la seconde moitié du problème et de tester des méthodes relativement simples: régression et neurones superficiels.  L'outil était SAS Miner, un logiciel de prétraitement, d'analyse et de construction de modèles sur diverses données sous une forme interactive, ce qui permet d'économiser beaucoup de temps sur l'écriture de code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ae/80d/b3c/1ae80db3c2741d5c70a2cbc9e48dd0ff.png"><br>  <i>Interface SAS Miner</i> <br><br><h3>  Évaluation de la qualité </h3><br>  La comparaison de la métrique GINI sur un échantillon hors du temps a montré que le réseau neuronal fait le mieux face à la tâche: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/553/e79/d24553e79a193415b2fa94c6e3b0d987.png"></div><br>  <i>Tableau comparatif des modèles de qualité et des règles de fréquence</i> <br><br>  Le modèle a deux points de sortie.  Les recommandations sous forme de cartes widget sur l'écran principal incluent des opérations dont la prévision est supérieure à un certain seuil (voir la première image dans le billet).  La frontière est sélectionnée sur la base d'un équilibre de qualité et de couverture, qui dans une telle architecture représente la moitié de toutes les opérations effectuées.  Les 4 premières opérations sont envoyées au bloc «opérations recommandées» de l'écran de recherche (voir la deuxième image). <br><br><h2>  Exemples de recherche </h2><br>  Passant à la deuxième partie de la tâche, nous revenons au problème d'un grand nombre d'options de paiement possibles pour les services des fournisseurs qui doivent être évaluées et triées au sein de chaque client - des milliards de paires.  En plus de cela, nous avons des données implicites, c'est-à-dire qu'il n'y a aucune information sur l'évaluation des paiements effectués, ni pourquoi le client n'a effectué aucun paiement.  Par conséquent, pour commencer, il a été décidé de tester différentes méthodes d'élargissement de la matrice des paiements des clients aux fournisseurs: ALS et FM. <br><br><h3>  SLA </h3><br>  ALS (Alternating Least Squares) ou Alternating Least Squares - en filtrage collaboratif, l'une des méthodes pour résoudre le problème de la factorisation de la matrice d'interaction.  Nous présenterons nos données transactionnelles sur le paiement des services sous la forme d'une matrice dans laquelle les colonnes sont des identifiants uniques des services de tous les fournisseurs et les lignes sont des clients uniques.  Dans les cellules, nous plaçons le nombre d'opérations de clients spécifiques avec des prestataires spécifiques pendant une certaine période: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/430/fcd/db7/430fcddb7494ed4ba54411d0423b5b16.png"><br>  <i>Principe de décomposition matricielle</i> <br><br>  Le sens de la méthode est que nous créons deux de ces matrices de dimension inférieure, dont la multiplication donne le résultat le plus proche de la grande matrice d'origine dans les cellules remplies.  Le modèle apprend à créer une description factorielle cachée pour les clients et les fournisseurs.  Une implémentation de la méthode dans la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implicite</a> a été utilisée.  La formation se déroule selon l'algorithme suivant: <br><br><ol><li>  Les matrices des clients et des fournisseurs avec des facteurs cachés sont initialisées.  Leur nombre est l'hyperparamètre du modèle. <br></li><li>  La matrice des facteurs cachés des fournisseurs est fixe et la dérivée de la fonction de perte pour la correction de la matrice client est considérée.  L'auteur a utilisé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">méthode</a> intéressante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de gradients conjugués</a> , qui vous permet d'accélérer considérablement cette étape. <br></li><li>  L'étape précédente est répétée de la même manière pour la matrice des facteurs cachés des clients. </li><li>  Les étapes 2-3 alternent jusqu'à ce que l'algorithme converge. </li></ol><br><h3>  La préparation </h3><br>  Les données transactionnelles ont été transformées en une matrice d'interactions avec un degré de rareté de ~ 99% avec une grande inégalité entre les prestataires.  Pour séparer les données en échantillons de train et de validation, nous avons masqué au hasard la proportion de cellules remplies: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d60/d96/282/d60d96282aac1b7425ee0ea597253d66.png"><br>  <i>Exemple de partage de données</i> <br><br>  Les transactions ont été prises comme test pour la période suivant la formation, et présentées dans une matrice du même format - elle s'est avérée hors du temps. <br><br><h3>  La formation </h3><br>  Le modèle possède plusieurs hyperparamètres qui peuvent être ajustés pour améliorer la qualité: <br><br><ul><li>  Alpha est le coefficient par lequel la matrice est pondérée, ajustant le degré de confiance ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C_iu</a> ) que le service donné est vraiment «aimé» par le client. <br></li><li>  Le nombre de facteurs dans les matrices cachées des clients et des fournisseurs est le nombre de colonnes et de lignes, respectivement. <br></li><li>  Coefficient de régularisation L2 λ. <br></li><li>  Le nombre d'itérations de la méthode. <br></li></ul><br>  Nous avons utilisé la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hyperopt</a> , qui nous permet d'évaluer l'effet des hyperparamètres sur la métrique de qualité à l'aide de la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TPE</a> et de sélectionner leur valeur optimale.  L'algorithme commence par un démarrage à froid et effectue plusieurs évaluations de la métrique de qualité en fonction des valeurs des hyperparamètres analysés.  Ensuite, en substance, il essaie de sélectionner un ensemble de valeurs d'hyperparamètres qui est plus susceptible de donner une bonne valeur pour la métrique de qualité.  Les résultats sont enregistrés dans un dictionnaire à partir duquel vous pouvez créer un graphique et évaluer visuellement le résultat de l'optimiseur (le bleu c'est mieux): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa2/175/64a/fa217564a3f448a81abbbfad1d27f7a1.png"></div><br>  <i>Le graphique de la dépendance de la métrique de qualité sur la combinaison d'hyperparamètres</i> <br><br>  Le graphique montre que les valeurs des hyperparamètres affectent fortement la qualité du modèle.  Puisqu'il est nécessaire d'appliquer des plages pour chacune d'entre elles à l'entrée de la méthode, le graphique peut en outre déterminer s'il est judicieux d'agrandir l'espace de valeurs ou non.  Par exemple, dans notre tâche, il est clair qu'il est logique de tester de grandes valeurs pour le nombre de facteurs.  À l'avenir, cela a vraiment amélioré le modèle. <br><br><h3>  Métrique et complexité de l'évaluation de la qualité </h3><br>  Comment évaluer la qualité du modèle?  L'une des mesures les plus couramment utilisées pour les systèmes de recommandation où la commande est importante est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAP @ k</a> ou Mean Average Precision à K.Cette mesure estime la précision du modèle sur K recommandations, en tenant compte de l'ordre des articles dans la liste de ces recommandations en moyenne pour tous les clients. <br><br>  Malheureusement, une opération d'évaluation de la qualité, même sur un échantillon, a pris plusieurs heures.  Après avoir retroussé nos manches, nous avons commencé à profiler la fonction mean_average_pecision_at_k () avec la bibliothèque line_profiler.  La tâche était encore compliquée par le fait que la fonction utilisait du code cython et devait être correctement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en compte</a> , faute de quoi les statistiques nécessaires n'étaient tout simplement pas collectées.  En conséquence, nous avons de nouveau été confrontés au problème de la dimensionnalité de nos données.  Pour calculer cette métrique, vous devez obtenir des estimations de chaque service de tous les possibles pour chaque client et sélectionner les recommandations personnelles top-K en les triant à partir du tableau résultant.  Même en considérant l'utilisation du tri partiel de numpy.argpartition () avec la complexité O (n), le tri des notes s'est avéré être l'étape la plus longue étirant la notation de qualité au fil du temps.  Comme numpy.argpartition () n'a pas utilisé tous les noyaux de notre serveur, il a été décidé d'améliorer l'algorithme en réécrivant cette partie en C ++ et OpenMP via cython.  Un nouvel algorithme succinct est le suivant: <br><br><ol><li>  Les données sont découpées en lots par les clients. <br></li><li>  Une matrice vide et des pointeurs vers la mémoire sont initialisés. <br></li><li>  Les chaînes de lots par pointeurs sont triées de deux manières: par la fonction partial_sort puis triées par la bibliothèque d'algorithmes C ++. <br></li><li>  Les résultats sont écrits en parallèle dans les cellules de la matrice vide. <br></li><li>  Les données sont renvoyées en python. <br></li></ol><br>  Cela nous a permis d'accélérer plusieurs fois le calcul des recommandations.  La révision a été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajoutée</a> au référentiel officiel. <br><br><h2>  Analyse des résultats OOT </h2><br>  Et maintenant, il est temps d'évaluer la qualité du modèle.  Pourquoi avons-nous besoin d'un échantillonnage hors temps?  Si nous regardons la distribution des opérations par les fournisseurs, nous verrons l'image suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/5d2/3d4/3455d23d4093172fbbf416d9719e14fa.png"></div><br>  <i>Répartition de la popularité des prestataires de services</i> <br><br>  Il y a un déséquilibre.  Cela conduit au fait que le modèle essaie de recommander des services populaires.  Retour à l'image ci-dessus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/0fd/b08/6ef0fdb084bd7495ad12821c42cd70c2.png"><br><br>  Le problème est que si vous vérifiez la précision du modèle en masquant la même matrice, comme cela est conseillé presque partout, alors pour la plupart des clients (exemples marginaux: «W», «E» et «I») la qualité des prévisions de validation (nous ferons comme si elle n'a pas participé à la sélection des hyperparamètres) sera élevé si ce sont les prestataires les plus populaires.  En conséquence, nous obtenons une fausse confiance dans la force du modèle.  Par conséquent, nous avons agi comme suit: <br><br><ol><li>  Estimations formées des prestataires par modèle. <br></li><li>  Les couples client-service existants ont été exclus des classifications (voir la figure ci-dessous) et des matrices OOT. <br></li><li>  Formé à partir des notes restantes des recommandations K-top et noté MAP @ k sur le reste OOT. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/ee7/c06/f4b/ee7c06f4b68beda0b4f0e22e3c8163c1.png"><br>  <i>La logique de préparation de la matrice de génération des prévisions</i> <br><br>  En tant que ligne de base, nous avons compilé une liste de fournisseurs, triée par popularité, et multipliée par tous les clients, en excluant à nouveau les paires de service client existantes.  Il s'est avéré être triste et pas du tout ce que nous attendions et avons vu sur les échantillons de train \ validation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/a94/050/ee2a94050abe17d305bdcffeb895f2d0.png"></div><br>  <i>Tableau de comparaison de la référence et de la qualité du modèle</i> <br><br>  Arrête ça!  Nous avons des facteurs clients et des paramètres de fournisseurs.  Nous obtenons des machines de factorisation. <br><br><h3>  FM </h3><br>  Machines de factorisation (machine de factorisation) - un algorithme d'apprentissage avec un enseignant, conçu pour trouver des relations entre des facteurs qui décrivent des entités en interaction, qui sont présentées sous la forme de matrices clairsemées.  Nous avons utilisé l'implémentation FM de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LightFM</a> . <br><br><h3>  Format des données </h3><br>  En plus de la matrice d'interaction normalisée, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">méthode</a> utilise deux jeux de données supplémentaires avec des facteurs pour les clients et pour les services des fournisseurs sous la forme de matrices codées à chaud connectées à des matrices uniques: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61b/fa6/c8a/61bfa6c8ab458cfb9b747a37a28e0e32.png"><br>  <i>La logique de préparation de la matrice de génération des prévisions</i> <br><br><h3>  Évaluation de la qualité </h3><br>  La qualité du modèle FM sur nos données s'est avérée inférieure à ALS: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/457/003/48b457003013f435b77ba2d9ecc4cb25.png"></div><br>  <i>Tableau comparatif des modèles de qualité et de référence</i> <br><br><h3>  Changer l'architecture du modèle - Booster </h3><br>  Il a été décidé de venir de l'autre côté.  Rappelant la répartition de la popularité des services, nous en avons identifié 300, transactions qui couvrent 80% de l'ensemble des opérations, et formé un classificateur sur celles-ci.  Ici, les données représentent des agrégats de transactions client enrichis de fonctionnalités client: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d25/47d/718/d2547d718a7199fba96be2d0f653bf9a.png"><br>  <i>Schéma d'agrégation de transactions</i> <br><br>  Pourquoi seulement côté client, demandez-vous?  Parce que dans ce cas, pour préparer des recommandations, il nous suffira d'avoir une ligne par client.  En lui appliquant le modèle, nous obtenons le vecteur de sortie des probabilités pour toutes les classes, à partir duquel il est facile de choisir des recommandations top-K.  Si nous ajoutons les fonctionnalités des services du fournisseur à l'ensemble de formation, alors au stade de l'application du modèle, nous serons obligés soit de préparer 300 lignes pour chaque client - une pour chaque service du fournisseur avec des fonctionnalités les décrivant, soit de construire un autre modèle pour le tri préalable des candidats évaluant les candidats. . <br><br>  L'ajout de fonctionnalités aux clients de la SLA n'a pas augmenté nos données, car nous avons déjà pris en compte l'activité transactionnelle - par exemple, dans des sections de MCC ou des catégories dans le style de "gamer" ou de "théâtre".  Dans ce format, nous avons réussi à obtenir de bons résultats: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eed/66a/389/eed66a389e4b545fa18a59c6c4ac123a.png"></div><br>  <i>Tableau comparatif des modèles de qualité et de référence</i> <br><br><h3>  Filtre régional </h3><br>  Malgré la haute qualité du modèle, un problème de plus demeure dans cette approche.  Étant donné que l'architecture des données et du modèle n'implique pas l'utilisation de fonctionnalités des services des fournisseurs, le modèle ne prend pas pleinement en compte la géographie et peut recommander que les gens paient pour le service d'un fournisseur local d'une autre région.  Pour minimiser ce risque, nous avons développé un petit filtre pour pré-couper les options avant de formuler des recommandations.  Une fleur de récursivité facile est jetée sur l'algorithme: <br><br><ol><li>  Nous collectons des informations sur la région du client à partir des profils bancaires et d'autres sources internes. <br></li><li>  Nous distinguons les principales régions de présence pour chaque fournisseur. <br></li><li>  Nous clarifions / complétons les informations sur la région du client par les régions des prestataires qu'il utilise. <br></li></ol><br>  Après ces manipulations, à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'indice Herfindahl, nous</a> séparons les prestataires régionaux, qui sont représentés dans un ensemble limité de régions, des prestataires fédéraux: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/15f/090/62015f090d3bdcc34d468f7b36ffef90.png"></div><br>  <i>Séparation des prestataires par présence dans les régions</i> <br><br>  Nous formons un masque avec des fournisseurs régionaux acceptables pour les clients et excluons les éléments inutiles des prédictions du modèle avant de créer une liste de recommandations. <br><br><h2>  Conclusion </h2><br>  Nous avons développé deux modèles qui forment ensemble un ensemble complet de recommandations sur les paiements et les transferts.  Il a été possible de réduire le chemin du client pour la moitié des opérations récurrentes en un seul clic.  Dans les plans futurs visant à améliorer le modèle des «opérations recommandées» à l'aide de données de rétroaction (les cartes peuvent être masquées, etc.), ce qui réduira le seuil de sélection des recommandations et augmentera la couverture.  Il est également prévu d'étendre la couverture des paiements recommandés dans le modèle des «exemples de recherche» et de développer un algorithme d'optimisation de la notation pour celui-ci. <br><br>  Nous sommes passés par la voie épineuse de la construction d'un système de recommandation de paiements et de transferts.  Sur le chemin, nous avons eu des bosses et acquis de l'expérience dans la décomposition et la simplification de telles tâches, l'évaluation correcte de ces systèmes, l'applicabilité des méthodes, un travail optimal avec de grands volumes de données et nous avons considérablement élargi notre compréhension des spécificités de ces tâches.  En chemin, j'ai réussi à contribuer à l'open source, que nous utilisons nous-mêmes.  Je vous souhaite des tâches intéressantes, des lignes de base réalistes et une F1 unique.  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461747/">https://habr.com/ru/post/fr461747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461737/index.html">Nous collectons l'environnement pour le TDD moderne sur le code JavaScript + VS</a></li>
<li><a href="../fr461739/index.html">Backend United 4: Okroshka. Incidents</a></li>
<li><a href="../fr461741/index.html">Regroupement hiérarchique des données catégorielles dans R</a></li>
<li><a href="../fr461743/index.html">Security Week 31: vulnérabilité VLC et téléphone cassé</a></li>
<li><a href="../fr461745/index.html">DeviceLock DLP: Prix du marché noir russe pour percer les données personnelles (plus une réponse à la réponse de Tinkoff Bank)</a></li>
<li><a href="../fr461749/index.html">La beauté dans l'œil du spectateur</a></li>
<li><a href="../fr461751/index.html">Contribution du concepteur au développement d'applications mobiles</a></li>
<li><a href="../fr461753/index.html">InterSystems IRIS Global Transactions</a></li>
<li><a href="../fr461755/index.html">La psychologie de la vision sonore. Svetlana Lebedeva a expliqué comment les gens apprennent une nouvelle façon de percevoir</a></li>
<li><a href="../fr461759/index.html">Écoute des communications VoIP cryptées</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>