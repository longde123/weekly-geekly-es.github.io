<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥊 📧 👩🏼‍🚀 SwiftUI di rak 👨🏿‍🚀 👩🏽‍⚖️ 😳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap kali kerangka baru muncul dalam bahasa pemrograman, cepat atau lambat, orang-orang muncul yang belajar bahasa darinya. Ini mungkin merupakan ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SwiftUI di rak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485548/"> Setiap kali kerangka baru muncul dalam bahasa pemrograman, cepat atau lambat, orang-orang muncul yang belajar bahasa darinya.  Ini mungkin merupakan kasus dalam pengembangan iOS pada saat kemunculan Swift: pada awalnya dianggap sebagai tambahan untuk Objective-C - tetapi saya belum menemukannya.  Sekarang, jika Anda mulai dari awal, pilihan bahasa tidak lagi sepadan.  Swift melampaui kompetisi. <br><br>  Hal yang sama, tetapi dalam skala yang lebih kecil, terjadi dengan kerangka kerja.  Penampilan SwiftUI tidak terkecuali.  Saya mungkin perwakilan dari generasi pertama pengembang yang memulai dengan mempelajari SwiftUI, mengabaikan UIKit.  Ini memiliki harga - sejauh ini hanya ada sedikit materi pelatihan dan contoh kode kerja.  Ya, jaringan sudah memiliki sejumlah artikel yang menceritakan tentang fitur tertentu, alat tertentu.  Pada <a href="https://www.hackingwithswift.com/quick-start/swiftui" rel="nofollow">www.hackingwithswift.com yang</a> sama sudah ada cukup banyak contoh kode dengan penjelasan.  Namun, mereka tidak banyak membantu mereka yang memutuskan untuk belajar SwiftUI dari awal, seperti saya.  Sebagian besar materi di jaringan adalah jawaban untuk pertanyaan spesifik dan dirumuskan.  Pengembang yang berpengalaman dapat dengan mudah mengetahui cara kerja semuanya, mengapa demikian, dan mengapa harus diterapkan.  Untuk pemula, pertama-tama Anda harus memahami pertanyaan apa yang harus ditanyakan, dan baru setelah itu ia bisa sampai ke artikel ini. <br><br><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png"><br><br>  Di bawah potongan, saya akan mencoba mensistematisasikan dan memilah-milah apa yang telah saya pelajari saat ini.  Format artikel ini hampir menjadi panduan, meskipun, sebuah lembar contekan yang saya buat dalam bentuk di mana saya sendiri ingin membacanya di awal perjalanan saya.  Untuk pengembang berpengalaman yang belum mempelajari SwiftUI secara mendalam, ada juga beberapa contoh kode yang menarik, dan penjelasan tekstual dapat dibaca secara diagonal. <br><br>  Saya harap artikel ini akan menghemat waktu ketika Anda juga ingin merasakan sedikit keajaiban. <br><a name="habracut"></a><br><h3>  Sebagai permulaan, sedikit tentang diri Anda </h3><br>  Saya praktis tidak memiliki latar belakang pengembangan seluler, dan pengalaman yang signifikan <br>  dalam 1s tidak bisa membantu banyak di sini.  Tentang bagaimana dan mengapa saya memutuskan untuk belajar SwiftUI, saya akan memberi tahu Anda lain waktu, jika itu akan menarik bagi seseorang, tentu saja. <br><br>  Kebetulan permulaan saya dalam pengembangan ponsel bertepatan dengan rilis iOS 13 dan SwiftUI.  Ini pertanda, pikirku, dan memutuskan untuk segera memulai dengan itu, mengabaikan UIKit.  Saya merasa kebetulan yang lucu bahwa saya mulai bekerja dengan 1c pada saat-saat seperti itu: kemudian formulir yang dikelola muncul.  Dalam kasus 1c, mempopulerkan teknologi baru memakan waktu hampir lima tahun.  Setiap kali seorang pengembang diperintahkan untuk menerapkan beberapa fungsi baru, ia menghadapi pilihan: melakukannya dengan cepat dan andal, dengan alat-alat yang sudah dikenal, atau menghabiskan banyak waktu untuk meributkan yang baru, dan tanpa jaminan hasil.  Pilihan biasanya dibuat untuk mendukung kecepatan dan kualitas saat ini, dan waktu investasi dalam alat baru tertunda untuk waktu yang sangat lama. <br><br>  Sekarang, tampaknya, situasi dengan SwiftUI hampir sama.  Semua orang tertarik, semua orang mengerti bahwa ini adalah masa depan, tetapi sejauh ini hanya sedikit yang meluangkan waktu untuk mempelajarinya.  Kecuali untuk proyek kesayangan. <br><br>  Secara umum, tidak masalah bagi saya kerangka kerja mana yang harus dipelajari, dan saya memutuskan untuk mengambil kesempatan meskipun ada pendapat umum bahwa akan mungkin untuk meluncurkannya dalam produksi dalam satu atau dua tahun.  Dan karena kebetulan saya berada di antara para perintis, saya memutuskan untuk berbagi pengalaman praktis.  Saya ingin mengatakan bahwa saya bukan seorang guru, dan secara umum dalam pengembangan ponsel - ketel.  Namun demikian, saya sudah menempuh cara tertentu, di mana saya mencari semua Internet untuk mencari informasi, dan saya dapat dengan yakin mengatakan bahwa itu tidak cukup dan secara praktis tidak sistematis.  Tetapi dalam bahasa Rusia, tentu saja, praktis tidak ada.  Jika demikian, saya memutuskan untuk mengumpulkan kekuatan saya, menyingkirkan kompleks <a href="https://habr.com/ru/post/370877">penipu</a> itu, dan berbagi dengan komunitas apa yang saya berhasil pahami sendiri.  Saya akan melanjutkan dari asumsi bahwa pembaca sudah setidaknya paling tidak terbiasa dengan SwiftUI, dan saya tidak akan menguraikan hal-hal seperti <code>VStack{…}</code> , <code>Text(…)</code> , dll. <br><br>  Saya menekankan sekali lagi bahwa saya akan lebih jauh menggambarkan kesan saya sendiri tentang upaya untuk mencapai hasil yang diinginkan dari SwiftUI.  Saya tidak dapat memahami sesuatu, dan dari beberapa percobaan menarik kesimpulan yang salah atau tidak akurat, sehingga segala koreksi dan klarifikasi sangat kami harapkan. <br><br>  Untuk pengembang berpengalaman, artikel ini mungkin tampak penuh dengan deskripsi hal-hal yang jelas, tetapi jangan menilai dengan ketat.  Tutorial untuk boneka di SwiftUI belum ditulis. <br><br><h2>  Apa ini SwiftUI? </h2><br>  Jadi, saya mungkin akan mulai dengan apa itu semua, ini SwiftUI Anda.  Di sini lagi, masa laluku yang pertama muncul.  Analogi dengan formulir terkelola hanya semakin kuat ketika saya menonton beberapa video tutorial tentang cara tata letak antarmuka di Storyboard (mis. Ketika bekerja dengan UIKit).  Saya mengambil nostalgia sesuai dengan bentuk "tidak terkendali" dalam 1s: penempatan elemen secara manual pada formulir, dan terutama binding ... Oh, ketika penulis video pelatihan selama sekitar 20 menit berbicara tentang seluk-beluk pengikatan berbagai elemen satu sama lain dan tepi layar, saya ingat dengan senyuman 1C - semuanya sama sebelum bentuk-bentuk yang dikendalikan.  Yah, hampir ... sedikit lebih buruk, tentu saja, baik, dan karenanya - lebih mudah.  Dan SwiftUI, secara kasar, mengelola formulir dari Apple.  Tidak ada ikatan.  Tidak ada storyboard dan segways.  Anda cukup menggambarkan struktur tampilan dalam kode Anda.  Dan itu saja.  Semua parameter, ukuran, dll. Diatur langsung dalam kode - tetapi cukup sederhana.  Lebih tepatnya, Anda dapat mengedit parameter objek yang ada di Canvas, tetapi untuk ini, Anda harus terlebih dahulu menambahkannya dalam kode.  Sejujurnya, saya tidak tahu bagaimana ini akan bekerja di tim pengembangan besar, di mana biasanya memisahkan tata letak desain dan konten View itu sendiri, tetapi sebagai pengembang indie saya sangat menyukai pendekatan ini. <br><br><h3>  Gaya deklaratif </h3><br>  SwiftUI mengasumsikan bahwa deskripsi struktur View Anda sepenuhnya dalam kode.  Selain itu, Apple menawarkan gaya penulisan kode ini kepada kami.  Yaitu, kira-kira seperti ini: <br><blockquote>  “Ini Pandangan.  Itu <s>(untuk beberapa alasan saya ingin mengatakan "tampilan", dan, karenanya, berlaku kemunduran untuk kata perempuan)</s> terdiri dari dua bidang teks dan satu gambar.  Bidang teks disusun satu demi satu secara horizontal.  Gambar di bawah mereka dan ujung-ujungnya dipotong dalam bentuk lingkaran. " </blockquote>  Kedengarannya tidak biasa, bukan?  Biasanya, dalam kode kita menggambarkan proses itu sendiri, apa yang perlu dilakukan untuk mencapai hasil yang kita miliki di kepala kita: <br><blockquote>  "Sisipkan blok, masukkan bidang teks ke dalam blok ini, diikuti oleh bidang teks lain, dan setelah itu, ambil gambar, potong tepinya dengan membulatkannya, dan tempel di bawah." </blockquote>  Kedengarannya seperti instruksi untuk furnitur dari Ikea.  Dan di swiftUI, kita segera melihat apa hasilnya.  Bahkan tanpa Canvas atau debugging, struktur kode dengan jelas mencerminkan struktur View.  Jelas apa dan dalam urutan apa yang akan ditampilkan dan dengan efek apa. <br><br>  Artikel yang sangat baik tentang FunctionBuilder, dan bagaimana memungkinkan Anda untuk menulis kode dengan gaya deklaratif sudah ada di <a href="https://habr.com/ru/company/tinkoff/blog/455760/">Habré</a> . <br><br>  Pada prinsipnya, banyak yang telah ditulis tentang gaya deklaratif dan kelebihannya, jadi saya akan mengakhirinya.  Saya akan menambahkan dari diri saya bahwa saya sudah terbiasa dengannya dan benar-benar merasakan betapa nyamannya menulis kode dengan gaya ini ketika datang ke antarmuka.  Dengan ini, Apple menabrak apa yang disebut bullseye! <br><br><h2>  Terdiri dari apa tampilan? </h2><br>  Tapi mari kita lihat lebih dekat.  Apple menyarankan gaya deklaratifnya seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text1 = <span class="hljs-string"><span class="hljs-string">"some text"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text2 = <span class="hljs-string"><span class="hljs-string">"some more text"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span>{ <span class="hljs-type"><span class="hljs-type">Text</span></span>(text1) .padding() .frame(width: <span class="hljs-number"><span class="hljs-number">100</span></span>, height: <span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-type"><span class="hljs-type">Text</span></span>(text2) .background(<span class="hljs-type"><span class="hljs-type">Color</span></span>.gray) .border(<span class="hljs-type"><span class="hljs-type">Color</span></span>.green) } } }</code> </pre> <br>  Harap dicatat, <code>View</code> adalah struktur dengan beberapa parameter.  Untuk membuat struktur <code>View</code> , kita perlu mengatur <code>body</code> parameter yang dihitung, yang mengembalikan <code>some View</code> .  Kami akan membicarakan ini nanti.  Isi dari <code>body: some View { … }</code> closure <code>body: some View { … }</code> adalah deskripsi dari apa yang akan ditampilkan di layar.  Sebenarnya, ini adalah semua yang diperlukan untuk struktur kami untuk memenuhi persyaratan protokol View.  Saya terutama menyarankan fokus pada <code>body</code> . <br><br><h3>  Jadi, rak </h3><br>  Secara total, saya menghitung tiga jenis elemen dari mana tubuh View dibangun: <br><br><ul><li>  <b>Pandangan Lain</b> <br>  Yaitu  Setiap Tampilan berisi satu atau lebih <code>View</code> lainnya.  Mereka, pada gilirannya, juga dapat mengandung baik tampilan sistem seperti <code>Text()</code> , dan kustom, yang kompleks yang ditulis oleh pengembang.  Ternyata semacam boneka bersarang dengan tingkat bersarang tanpa batas. </li><li>  <b>Pengubah</b> <br>  Dengan bantuan pengubah, semua keajaiban terjadi.  Berkat mereka, kami secara singkat dan jelas memberi tahu SwiftUI pandangan seperti apa yang ingin kami lihat.  Cara kerjanya, kami masih akan mengetahuinya, tetapi hal utama adalah bahwa pengubah menambahkan bagian yang diperlukan ke konten <code>View</code> tertentu. </li><li>  <b>Wadah</b> <br>  Kontainer pertama yang dimulai dengan "Hello, world" standar adalah <code>HStack</code> dan <code>VStack</code> .  Beberapa saat kemudian, <code>Group</code> , <code>Section</code> , dan lainnya muncul.  Bahkan, kontainer adalah View yang sama, tetapi mereka memiliki fitur.  Anda memberikan mereka beberapa konten yang ingin Anda tampilkan.  Seluruh fitur wadah itu entah bagaimana harus mengelompokkan dan menampilkan elemen konten ini.  Dalam pengertian ini, kontainer mirip dengan pengubah, dengan satu-satunya perbedaan adalah bahwa pengubah dimaksudkan untuk mengubah satu tampilan yang sudah jadi, dan wadah mengatur tampilan ini (elemen konten, atau blok sintaksis deklaratif) dalam urutan tertentu, misalnya, secara vertikal atau horizontal ( <code>VStack{...}</code> <code>HStack{...}</code> ).  Ada juga wadah khusus, seperti <code>ForEach</code> atau <code>GeometryReader</code> , kita akan membicarakannya nanti. <br><br>  Secara umum, saya menganggap wadah sebagai Tampilan apa pun, di mana Konten dapat diteruskan sebagai parameter. </li></ul><br>  Dan itu saja.  Semua elemen dari SwiftUI murni dapat dikaitkan dengan salah satu dari jenis ini.  Ya, ini tidak cukup untuk mengisi Tampilan Anda dengan fungsionalitas, tetapi hanya ini yang Anda butuhkan untuk menunjukkan fungsionalitas Anda di layar. <br><br><h3>  .modifiers () - bagaimana pengaturannya? </h3><br>  Mari kita mulai dengan yang paling sederhana.  Pengubah sebenarnya adalah hal yang sangat sederhana.  Dia hanya mengambil beberapa <code>View</code> , menerapkan beberapa perubahan padanya <s>(atau tidak?)</s> , Dan mengembalikannya kembali.  Yaitu  Pengubah adalah fungsi dari <code>View</code> itu sendiri, yang mengembalikan <code>self</code> , setelah sebelumnya melakukan beberapa modifikasi. <br><br>  Di bawah ini adalah contoh kode yang dengannya saya mendeklarasikan pengubah saya sendiri.  Lebih tepatnya, saya membebani <code>frame(width:height:)</code> pengubah yang ada <code>frame(width:height:)</code> , dengan mana Anda dapat memperbaiki dimensi tertentu dari Tampilan tertentu.  Dari kotak untuk itu, Anda perlu menentukan lebar dan tinggi, dan saya harus meneruskan objek <code>CGSize</code> ke dalamnya dengan satu argumen, yang merupakan deskripsi hanya panjang dan lebar.  Mengapa saya membutuhkan ini, saya akan katakan nanti. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameFromSize</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModifier</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: Content)</span></span></span></span> -&gt; some <span class="hljs-type"><span class="hljs-type">View</span></span> { content .frame(width: size.width, height: size.height) } }</code> </pre> <br>  Dengan kode ini, kami telah membuat struktur yang sesuai dengan protokol <code>ViewModifier</code> .  Protokol ini mengharuskan kita bahwa fungsi <code>body()</code> diimplementasikan dalam struktur ini, inputnya akan berupa beberapa <code>Content</code> , dan output akan memiliki <code>some View</code> : tipe yang sama dengan parameter <code>body</code> dari <code>View</code> kita (kita akan berbicara tentang beberapa View di bawah) .  <code>Content</code> macam apa ini? <br><br><h4>  Konten + ViewBuilder = Lihat </h4><br>  Dalam dokumentasi bawaan tentangnya dikatakan: <br><blockquote>  `content` adalah proxy untuk tampilan yang akan membuat modifier diwakili oleh` Self` yang diterapkan padanya. </blockquote>  Ini adalah tipe proksi, yang merupakan prefab Tampilan yang dapat diterapkan pengubah.  Semacam produk setengah jadi.  Sebenarnya, <code>Content</code> adalah penutupan gaya deklaratif yang menggambarkan struktur tampilan.  Jadi, jika kita memanggil pengubah ini untuk beberapa Tampilan, maka yang dia lakukan adalah mendapatkan penutup dari <code>body</code> dan meneruskannya ke fungsi <code>body</code> kita, di mana kita menambahkan lima sen ke penutupan ini. <br><br>  Sekali lagi, <code>View</code> adalah struktur utama yang menyimpan semua parameter yang diperlukan untuk menghasilkan gambar di layar.  Termasuk instruksi perakitan, yang isinya.  Dengan demikian, penutupan dalam gaya deklaratif ( <code>Content</code> ) yang diproses menggunakan <code>ViewBuilder</code> mengembalikan kita Tampilan. <br><br>  Mari kembali ke pengubah kami.  Pada prinsipnya, deklarasi struktur <code>FrameFromSize</code> sudah cukup untuk mulai menerapkannya.  Di dalam <code>body</code> kita bisa menulis seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">RoundedRectangle</span></span>(cornerRadius: <span class="hljs-number"><span class="hljs-number">4</span></span>).modifier(<span class="hljs-type"><span class="hljs-type">FrameFromSize</span></span>(size: size))</code> </pre><br>  <code>modifier</code> adalah metode protokol tampilan yang mengekstraksi konten dari <code>View</code> dimodifikasi, meneruskannya ke fungsi tubuh dari struktur pengubah, dan meneruskan hasilnya lebih jauh ke pemrosesan <code>ViewBuilder</code> , atau ke pengubah berikutnya, jika kita memiliki rantai modifikasi. <br><br>  Tetapi Anda dapat membuatnya lebih ringkas dengan mendeklarasikan pengubah Anda sendiri sebagai suatu fungsi, sehingga memperluas kemampuan protokol View. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size: CGSize)</span></span></span></span> -&gt; some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.modifier(<span class="hljs-type"><span class="hljs-type">FrameFromSize</span></span>(size: size)) } }</code> </pre> <br>  Dalam hal ini, saya membebani <code>.frame(width: height:)</code> pengubah yang ada <code>.frame(width: height:)</code> varian lain dari parameter <code>.frame(width: height:)</code> .  Sekarang, kita dapat menggunakan opsi memanggil modifier <code>frame(size:)</code> untuk <code>View</code> apa pun.  Ternyata, tidak ada yang rumit. <br><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang kesalahan</b> <div class="spoiler_text">  Ngomong-ngomong, saya berpikir bahwa itu tidak perlu untuk memperluas seluruh protokol, itu akan cukup untuk memperluas secara khusus <code>RoundedRectangle</code> dalam kasus saya, dan itu seharusnya bekerja, seperti yang tampak bagi saya - tetapi tampaknya Xcode tidak mengharapkan kelancangan seperti itu, dan jatuh dengan kesalahan yang tidak dapat dipahami “ <code>Abort trap: 6</code> "dan proposal untuk mengirim dump ke pengembang.  Secara umum, di SwiftUI, deskripsi kesalahan sejauh ini sangat sering tidak sepenuhnya mengungkapkan penyebab kesalahan ini. <br></div></div><br>  Dengan cara yang sama, Anda dapat membuat pengubah khusus apa pun, dan menggunakannya dengan cara yang sama seperti SwiftUI bawaan: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">RoundedRectangle</span></span>(cornerRadius: <span class="hljs-number"><span class="hljs-number">4</span></span>).frame(size)</code> </pre><br>  Nyaman, ringkas, jelas. <br><br>  Saya membayangkan rantai modifikasi ketika manik-manik digantung pada seutas benang - Pandangan kami.  Analogi ini juga benar dalam arti bahwa urutan modifikasi disebut hal. <br><br><img src="https://habrastorage.org/webt/tw/1p/ak/tw1paklgxp9d5acpcmwvjywxjce.png"><br><br><div class="spoiler">  <b class="spoiler_title">Hampir semua yang ada di SwiftUI adalah View</b> <div class="spoiler_text">  Omong-omong, komentar yang menarik.  Sebagai parameter input, latar belakang tidak menerima warna, tetapi Lihat.  Yaitu  Kelas Warna bukan hanya deskripsi warna, ini adalah Tampilan lengkap, yang dapat diterapkan pengubah dan lebih banyak lagi.  Dan sebagai latar belakang, dengan demikian, Anda dapat melewati View lainnya. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pengubah - hanya untuk modifikasi</b> <div class="spoiler_text">  Mungkin perlu diperhatikan satu hal lagi.  Pengubah yang tidak mengubah konten sumber diabaikan begitu saja oleh SwiftUI dan tidak dipanggil.  Yaitu  Anda tidak akan dapat membuat pemicu berdasarkan pengubah yang menyebabkan beberapa peristiwa, tetapi tidak melakukan tindakan apa pun dengan konten.  Apple terus-menerus mendorong kami untuk meninggalkan beberapa tindakan saat runtime saat merender antarmuka, dan mempercayai gaya deklaratif. <br></div></div><br><h2>  Masih Melihat </h2><br>  Sebelumnya kami berbicara tentang apa yang terdiri dari tubuh, tubuh <code>View</code> , atau instruksi perakitannya.  Mari kita kembali ke <code>View</code> itu sendiri.  Pertama-tama, ini adalah struktur di mana beberapa parameter dapat dideklarasikan, dan <code>body</code> hanyalah salah satunya.  Seperti yang telah kami katakan, mencari tahu apa <code>Content</code> , <code>body</code> adalah instruksi tentang cara mengumpulkan Tampilan yang diinginkan, yang merupakan penutupan dalam gaya deklaratif.  Tapi apa yang harus mengembalikan penutupan kita? <br><br><h3>  beberapa View - kenyamanan </h3><br><img align="right" src="https://habrastorage.org/webt/j9/zh/zz/j9zhzza2ma_4if9rhtzqjkqvdhi.jpeg"><br><br>  Dan kami dengan lancar sampai pada sebuah pertanyaan bahwa untuk waktu yang lama saya tidak bisa mengetahuinya, meskipun ini tidak menghentikan saya dari menulis kode kerja.  Apa ini <code>some View</code> ?  Dokumentasi mengatakan bahwa deskripsi ini adalah "tipe hasil buram" - tetapi itu tidak masuk akal. <br><br>  <code>some</code> kata kunci adalah versi "umum" dari deskripsi jenis yang dikembalikan oleh penutupan yang tidak bergantung pada apa pun selain kode itu sendiri.  Yaitu  Hasil dari mengakses properti yang dihitung dari badan View kami haruslah beberapa struktur yang memenuhi protokol View.  Mungkin ada banyak dari mereka - Teks, Gambar, atau mungkin beberapa struktur yang Anda nyatakan.  Keseluruhan chip dari beberapa kata kunci adalah untuk menyatakan "generik" yang sesuai dengan protokol View.  Ini ditentukan secara statis oleh kode yang diterapkan di dalam tubuh View Anda, dan Xcode cukup mampu mengurai kode ini, dan menghitung tanda tangan spesifik dari nilai pengembalian <s>(well, hampir selalu)</s> .  Dan beberapa hanya upaya untuk tidak membebani pengembang dengan <a href="https://habr.com/ru/post/482834/">upacara yang</a> tidak perlu.  Cukup bagi pengembang untuk mengatakan: "akan ada semacam Tampilan", dan yang mana - atur sendiri.  Kuncinya di sini adalah bahwa jenis beton ditentukan bukan oleh parameter input, seperti dengan tipe generik yang biasa, tetapi langsung oleh kode.  Karena itu, di atas, generik saya kutip. <br><br>  Xcode harus dapat menentukan jenis tertentu tanpa mengetahui dengan tepat nilai yang Anda berikan ke struktur ini.  Ini penting untuk dipahami - setelah dikompilasi, ekspresi Some View diganti dengan tipe spesifik dari <code>View</code> Anda.  Tipe ini cukup deterministik, dan bisa sangat kompleks, misalnya, seperti ini: <code>Group&lt;TupleView&lt;(Text, ForEach&lt;[SomeClass], SomeClass.ID, Text&gt;)&gt;&gt;</code> . <br><br>  Kode sampel dapat dipulihkan dari jenis ini: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Group</span></span>{ <span class="hljs-type"><span class="hljs-type">Text</span></span>(…) <span class="hljs-type"><span class="hljs-type">ForEach</span></span>(…){(value: <span class="hljs-type"><span class="hljs-type">SomeClass</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>(…) } }</code> </pre> <br>  <code>ForEach</code> , seperti yang bisa dilihat dari tipe signature, bukan loop runtime.  Ini hanya <code>View</code> yang dibangun berdasarkan array dari objek <code>SomeClass</code> .  sebagai pengenal <code>subView</code> tertentu yang terkait dengan elemen koleksi, ID elemen ditunjukkan, dan untuk setiap elemen <code>subView</code> tipe <code>Text</code> <code>subView</code> .  <code>Text</code> dan <code>TupleView</code> digabungkan dalam <code>TupleView</code> , dan semua ini ditempatkan dalam <code>Group</code> .  Kami akan berbicara lebih banyak tentang <code>ForEach</code> lebih rinci. <br><br>  Bayangkan berapa banyak tulisan yang akan terjadi jika kita dipaksa untuk menggambarkan tanda tangan persis seperti <code>body</code> parameter?  Untuk menghindari ini, <code>some</code> kata kunci telah dibuat. <br><br><div class="spoiler">  <b class="spoiler_title">Ringkasan</b> <div class="spoiler_text">  <code>some</code> , ini "generik - dan sebaliknya".  Kami mendapatkan generik klasik dari luar fungsi, dan sudah mengetahui tipe spesifik dari tipe generik, Xcode menentukan cara kerja fungsi kami.  <code>some-</code> tidak tergantung pada parameter input, tetapi hanya pada kode itu sendiri.  Ini hanyalah singkatan, yang memungkinkan untuk tidak menentukan jenis tertentu, tetapi untuk menunjukkan hanya keluarga dari nilai yang dikembalikan oleh fungsi (protokol). <br></div></div><br><h3>  beberapa View - dan konsekuensi </h3><br>  Pendekatan untuk menghitung tipe statis dari ekspresi di dalam tubuh memunculkan, menurut saya, dua poin penting: <br><br><ul><li>  Saat dikompilasi, Xcode mem-parsing isi tubuh untuk menghitung tipe pengembalian spesifik.  Dalam tubuh yang kompleks, ini bisa memakan waktu.  Dalam beberapa badan yang sangat kompleks, ia mungkin tidak dapat mengatasi waktu yang waras sama sekali, dan ia akan langsung mengatakannya. <br><img src="https://habrastorage.org/webt/-b/cf/nv/-bcfnvtylozajmnzcgjcto_8ms0.png"><br>  Secara umum, View perlu dijaga sesederhana mungkin.  Struktur kompleks paling baik ditempatkan pada tampilan terpisah.  Dengan demikian, seluruh rantai tipe nyata digantikan oleh satu jenis - CustomView Anda, yang memungkinkan kompiler tidak menjadi gila dengan semua kekacauan ini. <br>  Ngomong-ngomong, benar-benar sangat nyaman untuk men-debug sepotong kecil View besar, di sini, dengan cepat, menerima dan mengamati hasilnya di Canvas. </li><li>  Kita tidak bisa mengendalikan arus secara langsung.  Jika - jika SwiftUI masih dapat memprosesnya dengan membuat “Schrödinger View” dengan tipe &lt;_ConditionalContent &lt;Text, TextField &gt;&gt; maka operator kondisi trinar hanya dapat digunakan untuk memilih nilai parameter tertentu, tetapi bukan tipe, atau bahkan untuk memilih urutan pengubah. <br><img src="https://habrastorage.org/webt/cp/18/7s/cp187s4fsvn9v3kvwobduyk5rie.png"><br>  Tetapi perlu mengembalikan urutan pengubah yang sama, dan catatan seperti itu tidak lagi menjadi masalah. </li></ul><br><h2>  Kecuali tubuh </h2><br>  Namun, mungkin ada parameter lain dalam struktur yang dapat Anda gunakan.  Sebagai parameter kita dapat mendeklarasikan hal-hal berikut. <br><br><h3>  Parameter eksternal </h3><br>  Ini adalah parameter struktur sederhana yang harus kami lewati dari luar selama inisialisasi agar View dapat membuatnya entah bagaimana: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> textValue: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(textValue) } }</code> </pre> <br>  Dalam contoh ini, <code>textValue</code> untuk struktur <code>TextView</code> adalah parameter yang harus diisi secara eksternal karena tidak memiliki nilai default.  Mengingat bahwa struktur mendukung pembuatan inisialisasi otomatis, kami dapat menggunakan Tampilan ini hanya: <br><br><pre> <code class="swift hljs"> <span class="hljs-type"><span class="hljs-type">TextView</span></span>(textValue: <span class="hljs-string"><span class="hljs-string">"some text"</span></span>)</code> </pre><br>  Dari luar, Anda juga dapat mentransfer penutupan yang perlu dilakukan saat suatu peristiwa terjadi.  Misalnya, <code>Button(lable:action:)</code> tidak hanya itu: melakukan penutupan tindakan yang lewat ketika tombol diklik. <br><br><h3>  status - parameter </h3><br>  SwiftUI sangat aktif menggunakan fitur Swift 5.1 baru - <a href="https://habr.com/ru/company/funcorp/blog/485008/">Wrapper Properti</a> . <br><br>  Pertama-tama, ini adalah variabel keadaan - parameter yang disimpan dari struktur kami, perubahan yang harus tercermin pada layar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka dibungkus pembungkus khusus </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- untuk tipe primitif, dan </font></font><code>@ObservedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- untuk kelas. Kelas harus memenuhi protokol </font></font><code>ObservableObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ini berarti kelas ini harus dapat memberi tahu pelanggan (Lihat, yang menggunakan nilai ini dengan pembungkus </font></font><code>@ObservedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) tentang perubahan properti mereka. Untuk melakukan ini, cukup bungkus properti yang diperlukan di </font></font><code>@Published</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak mencari cara mudah, atau Anda memerlukan fungsionalitas tambahan, alih-alih pembungkus ini, Anda dapat menggunakan </font></font><code>ObservableObjectPublisher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengirim pemberitahuan secara manual menggunakan peristiwa </font></font><code>willSet()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter ini, seperti dijelaskan, misalnya, di </font></font><a href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-send-state-updates-manually-using-objectwillchange" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingat, saya mengatakan itu</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ini properti yang hanya dapat dihitung? Pada awalnya, saya tidak segera memahami semuanya tentang variabel State, dan saya mencoba mendeklarasikan beberapa variabel State di dalam </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa pembungkus apa pun. Masalahnya ternyata </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah, seperti yang saya katakan, instruksi tanpa kewarganegaraan. Tampilan dihasilkan sesuai dengan instruksi ini, dan seluruh konteks yang dinyatakan di dalam tubuh pergi ke TPA. Selanjutnya, hanya parameter struktur yang disimpan yang hidup. Saat mengubah Status-parameter, semua parameter kita </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperbarui. Instruksi sekali lagi diambil, nilai saat ini dari semua parameter struktur disubstitusi ke dalamnya, gambar pada layar dikumpulkan, instruksi dibuang lagi sampai waktu berikutnya. Variabel dideklarasikan di dalam </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- bersama dengan itu. Untuk pengembang berpengalaman, ini mungkin jelas, tetapi pada awalnya, saya tersiksa dengan ini, tidak memahami esensi dari proses tersebut.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan satu lagi komentar</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda tidak dapat menggunakan </font></font><code>didSet</code> <code>willSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peristiwa parameter struktur yang dibungkus pembungkus. </font><font style="vertical-align: inherit;">Kompiler memungkinkan Anda untuk menulis kode ini, tetapi tidak bisa dijalankan. </font><font style="vertical-align: inherit;">Mungkin karena pembungkusnya adalah semacam kode templat yang dieksekusi ketika peristiwa ini terjadi.</font></font><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh </font></font><a href="https://habr.com/ru/users/state/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keadaan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasik </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tapCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">Button</span></span>(action: {<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tapCount += <span class="hljs-number"><span class="hljs-number">1</span></span>}, label: { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Tap count \(tapCount)"</span></span>) }) } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengikat parameter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, untuk mencerminkan beberapa perubahan dalam tampilan Lihat </font></font><code>@State</code> <code>@ObservedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tapi bagaimana perubahan ini bisa terjadi </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Untuk melakukan ini, SwiftUI memiliki PropertyWrapper lain - </font></font><code>@Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mari kita tambahkan contoh kita dengan tombol untuk menghitung klik. Misalkan kita memiliki orangtua </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mencerminkan, antara lain, penghitung klik, dan anak </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan tombol. Pada tampilan induk, penghitung dideklarasikan sebagai </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- dapat dimengerti, tetapi kami ingin penghitung di layar diperbarui. Tetapi di anak perusahaan, penghitung harus dinyatakan sebagai </font></font><code>@Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah Wrapper Properti lain, dengan bantuan yang kami nyatakan parameter struktur yang tidak hanya akan berubah, tetapi juga kembali ke induk </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini semacam </font></font><code>inout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penanda untuk</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ketika nilai berubah dalam tampilan anak, perubahan ini diterjemahkan kembali ke tampilan induk, tempat asalnya. </font><font style="vertical-align: inherit;">Dan seperti halnya </font></font><code>inout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita perlu menandai nilai yang dikirimkan dengan simbol khusus </font></font><code>$,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menunjukkan bahwa kita sedang menunggu nilai yang dikirim untuk berubah di dalam tampilan lain. </font><font style="vertical-align: inherit;">Bereaksi dalam aksi.</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tapCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span>{ <span class="hljs-type"><span class="hljs-type">SomeView</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: $tapCount) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"you tap \(tapCount) times"</span></span>) } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini juga tercermin dalam tipe data. </font></font><code>@Binding var tapCount: Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">misalnya, ini bukan hanya </font></font><code>Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipe </font><font style="vertical-align: inherit;">lagi </font><font style="vertical-align: inherit;">, itu</font></font><br><br><pre> <code class="plaintext hljs">Binding&lt;Int&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berguna untuk mengetahui, misalnya, jika Anda ingin menulis penginisialisasi Anda sendiri </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span></span>{ @<span class="hljs-type"><span class="hljs-type">Binding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tapCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>: <span class="hljs-type"><span class="hljs-type">Binding</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>._tapCount = <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> <span class="hljs-comment"><span class="hljs-comment">//    -    } var body: some View{ Button(action: {self.tapCount += 1}, label: { Text("Tap me") }) } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap dicatat bahwa di dalam </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda </font></font><code>@PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menggunakan garis bawah </font><font style="vertical-align: inherit;">untuk merujuk ke parameter yang dibungkus dalam beberapa parameter </font></font><code>self._</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ini berfungsi di inisialisasi, ketika </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masih dalam proses pembuatan. </font><font style="vertical-align: inherit;">Lebih tepatnya, dengan bantuan </font></font><code>self._</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita merujuk ke parameter beserta pembungkusnya. </font><font style="vertical-align: inherit;">Menerapkan langsung ke nilai di dalam pembungkus dilakukan tanpa menggarisbawahi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada gilirannya, jika Anda memiliki variabel yang dibungkus dalam beberapa jenis input </font></font><code>PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami mendapatkan jenis pembungkus, dalam hal ini</font></font><br><br><pre> <code class="plaintext hljs">Binding&lt;Int&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda </font></font><code>Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat </font><font style="vertical-align: inherit;">mengakses nilai jenis secara langsung </font></font><code>.wrappedValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan seperti biasa, menyapu pribadi</font></font></b> <div class="spoiler_text"> ,  Binding     .   View          View.      View      ,    @Binding-.  ,   View     <a href="https://habr.com/ru/users/state/" class="user_link">State</a>  @Binding — ,     State-   Binding.       -,  ,    . <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek Lingkungan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singkatnya, </font></font><code>EnvironmentObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameternya seperti </font></font><code>Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hanya segera untuk semua orang </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam hierarki, tanpa harus memberikannya secara eksplisit.</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ContentView</span></span>().environmentObject(session)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya, keadaan aplikasi saat ini, atau beberapa bagian darinya, yang dibutuhkan oleh banyak View sekaligus, ditransmisikan. Misalnya, data tentang pengguna, sesi, atau sesuatu yang serupa, masuk akal untuk meletakkannya di EnvironmentObject sekali, di tampilan root. Di setiap View, di mana mereka diperlukan, mereka dapat diekstraksi dari lingkungan dengan mendeklarasikan variabel dengan wrapper @EnvironmentObject, misalnya seperti ini</font></font><br><br><pre> <code class="swift hljs"> @<span class="hljs-type"><span class="hljs-type">EnvironmentObject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> session: <span class="hljs-type"><span class="hljs-type">Session</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengidentifikasi nilai tertentu adalah tipe itu sendiri. Jika Anda memasukkan </font></font><code>EnvironmentObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa nilai dari jenis yang sama, maka urutannya penting. Untuk sampai ke 3, misalnya, nilai, Anda harus mendapatkan semua nilai secara berurutan, bahkan jika Anda tidak membutuhkannya. Oleh karena itu, </font></font><code>EnvironmentObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat cocok untuk mencerminkan keadaan aplikasi, tetapi tidak cocok untuk melewatkan beberapa nilai dari jenis yang sama </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mereka harus ditransmisikan secara manual, melalui </font></font><code>Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ Lingkungan hampir sama. Dalam arti, ini adalah keadaan lingkungan, mis. OS Lebih mudah untuk melewati pembungkus ini, misalnya, posisi layar (vertikal atau horizontal), tema terang atau gelap digunakan, dll. Juga, melalui pembungkus ini Anda dapat mengakses database saat menggunakan CoreData:</font></font><br><br><pre> <code class="swift hljs">@<span class="hljs-type"><span class="hljs-type">Environment</span></span>(\.managedObjectContext) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moc: <span class="hljs-type"><span class="hljs-type">NSManagedObjectContext</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, banyak hal menarik telah dilakukan untuk bekerja dengan CoreData di SwiftUI. </font><font style="vertical-align: inherit;">Tapi soal ini, mungkin, lain kali. </font><font style="vertical-align: inherit;">Jadi artikelnya telah berkembang melampaui semua harapan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> @PropertyWrapper khusus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada umumnya, </font></font><code>PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini adalah jalan pintas untuk setter dan pengambil, sama untuk semua parameter yang dibungkus dalam yang sama </font></font><code>property wrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anda dapat sepenuhnya memulihkan fungsi ini sendiri dengan menghapus deklarasi wrapper dan menulis parameter pengambil {} setter {}, tetapi Anda harus melakukan ini setiap kali, untuk masing-masing </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menduplikasi kode. </font><font style="vertical-align: inherit;">Misalnya, menggunakannya </font></font><code>PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat nyaman untuk menyembunyikan pekerjaan </font></font><code>UserDefaults</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="swift hljs">@propertyWrapper <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDefault</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialValue: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedValue: <span class="hljs-type"><span class="hljs-type">T</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(newValue, forKey: key) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: key) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">T</span></span> ?? initialValue } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, kita dapat menyimpan tipe data primitif dalam penyimpanan </font></font><code>UserDefaults</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apple mengklaim kecepatan akses yang sangat baik ke penyimpanan ini, jadi mungkin tidak perlu untuk cache data ini dalam memori dalam bentuk parameter atau variabel struktur, kecuali tentu saja mereka digunakan dalam loop besar dan tugas-tugas yang menuntut kecepatan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan ini, Anda dapat membuat tipe rintisan (dalam hal ini, enumerasi) untuk mendeklarasikan variabel statis untuk mengakses nilai spesifik yang disimpan </font></font><code>UserDefaults</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menggunakan pembungkus yang baru saja dibuat:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserPreferences</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">UserDefault</span></span>(key: <span class="hljs-string"><span class="hljs-string">"isCheatModeEnabled"</span></span>, initialValue: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isCheatModeEnabled: <span class="hljs-type"><span class="hljs-type">Bool</span></span> @<span class="hljs-type"><span class="hljs-type">UserDefault</span></span>(key: <span class="hljs-string"><span class="hljs-string">"highestScore"</span></span>, initialValue: <span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> highestScore: <span class="hljs-type"><span class="hljs-type">Int</span></span> @<span class="hljs-type"><span class="hljs-type">UserDefault</span></span>(key: <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>, initialValue: <span class="hljs-string"><span class="hljs-string">"cloudstrife97"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nickname: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasilnya dapat digunakan dengan sangat ringkas, berfokus pada logika dan tampilan visual, dan semua pekerjaan dilakukan di bawah tenda. </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">UserPreferences</span></span>.isCheatModeEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">UserPreferences</span></span>.highestScore = <span class="hljs-number"><span class="hljs-number">25000</span></span> <span class="hljs-type"><span class="hljs-type">UserPreferences</span></span>.nickname = <span class="hljs-string"><span class="hljs-string">"squallleonhart”</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh awalnya dijelaskan di </font></font><a href="https://medium.com/swlh/understanding-property-wrappers-in-swift-by-examples-604206022b5c" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wadah </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, hal terakhir yang saya diskusikan dari daftar saya adalah kontainer. Kami sudah sebagian menyinggung ini ketika kami berbicara tentang </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Faktanya, wadah adalah hal biasa </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Satu-satunya perbedaan adalah bahwa sebagai salah satu parameter struktur ini, kami mengirimkan konten. Ingat bahwa konten adalah penutup yang mengandung satu atau lebih ekspresi deklaratif. Penutupan ini, jika diproses dengan bantuan </font></font><code>@ViewBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, akan mengembalikan kepada kami Tampilan baru, menggabungkan dengan cara tertentu semua Tampilan yang tercantum dalam penutupan (blok konten). Pada saat yang sama, untuk wadah yang berbeda, mekanisme pemrosesan blok itu sendiri berbeda. </font></font><code>VStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatur elemen konten secara vertikal, </font></font><code>HStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal, dan sebagainya. Ini seperti pengubah, tapi kali ini bukan hanya satu Tampilan spesifik yang sedang dimodifikasi, tetapi keseluruhan</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipindahkan ke wadah dan yang baru dihasilkan </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apalagi yang baru ini </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki tipe baru. </font><font style="vertical-align: inherit;">Misalnya, untuk </font></font><code>HStack{Text(…)}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipe ini akan </font></font><code>TupleView&lt;Text, Image&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, jangan lupa bahwa apapun </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, termasuk wadah, adalah struktur yang dapat memiliki parameter lain selain bodi. </font><font style="vertical-align: inherit;">Sebagai contoh, untuk waktu yang lama saya tidak bisa menemukan cara menghilangkan celah kecil di </font></font><code>Text(«a»)</code> <code>Text(«b»)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam </font></font><code>HStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya menghabiskan banyak waktu dengan </font></font><code>offset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>position()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menghitung koordinat offset berdasarkan panjang garis, sampai saya secara tidak sengaja menemukan sintaks penuh deklarasi </font></font><code>HStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HStack (spasi:, alingment:, konteks :). </font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhananya, dua parameter pertama adalah opsional, dan dilewati dalam kebanyakan contoh. </font><font style="vertical-align: inherit;">Kesalahan pemula - tidak melihat sintaks lengkap.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Foreach </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara terpisah, ada baiknya dibicarakan </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah wadah yang berfungsi untuk merefleksikan di layar semua elemen koleksi yang ditransfer. Pertama-tama, Anda perlu memahami bahwa ini tidak sama dengan meminta beberapa koleksi </font></font><code>forEach(…)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seperti yang kami katakan di atas, ia </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan satu yang unik </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dibuat berdasarkan elemen dari koleksi yang ditransfer.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu hanya wadah lain di mana koleksi ditransfer, dan instruksi tentang cara merefleksikan elemen-elemen koleksi di layar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, ia </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus ditempatkan di dalam wadah lain yang sudah menentukan bagaimana mengelompokkan banyak entitas ini - dengan menempatkannya secara vertikal, horizontal, atau, misalnya, menempatkannya dalam daftar ( </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br> <code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima tiga parameter: koleksi ( </font></font><code>data: RandomAccesCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), alamat pengidentifikasi elemen koleksi ( </font></font><code>id: Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dan konten ( </font></font><code>content: ()-&gt;Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Yang ketiga yang telah kita bahas: seperti wadah lainnya, ia </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- yaitu. korsleting. Tetapi tidak seperti wadah biasa, di mana </font></font><code>content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak mengandung parameter, itu </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melewati elemen koleksi penutupan yang dapat digunakan untuk menggambarkan konten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koleksinya </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak cocok </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">apa pun, tetapi hanya </font></font><code>RandomAccesCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Untuk berbagai koleksi yang tidak teratur, cukup memanggil metode </font></font><code>sorted(by:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dapat Anda peroleh </font></font><code>RandomAccesCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah set yang </font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibuat untuk setiap elemen koleksi berdasarkan konten yang dikirimkan. Penting untuk dicatat bahwa SwiftUI perlu mengetahui </font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen mana yang terkait dengan koleksi. Untuk ini, masing </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">masing </font><font style="vertical-align: inherit;">harus memiliki pengenal. Parameter kedua diperlukan tepat untuk ini. Jika elemen koleksi adalah </font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipe, seperti string, Anda dapat menulis secara sederhana </font></font><code>id: \.self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini berarti bahwa string itu sendiri akan menjadi pengidentifikasi. Jika elemen koleksi adalah kelas dan memenuhi protokol</font></font><code>Identifiable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- maka argumen kedua bisa dilewatkan. Dalam hal ini, id dari setiap item dalam koleksi akan menjadi pengidentifikasi </font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika objek Anda memiliki beberapa jenis alat peraga yang memberikan keunikan, dan yang memenuhi protokol </font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda dapat menentukannya seperti ini:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ForEach</span></span>(values, id: \.value){item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> …}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh saya, </font></font><code>values</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah array objek kelas </font></font><code>SomeObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang propsnya dideklarasikan </font></font><code>value: Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bagaimanapun, Anda harus memastikan bahwa setiap pengidentifikasi yang </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terkait dengan elemen koleksi Anda adalah </font><font style="vertical-align: inherit;">unik </font><font style="vertical-align: inherit;">. Misalnya, dalam konteks Anda, beberapa parameter objek Anda dapat berubah. </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu harus dicocokkan 1 hingga 1 dengan objek data (elemen koleksi), jika tidak maka tidak akan jelas ke mana harus mengembalikan perubahan </font></font><code>@Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, mengorganisir merangkak elemen koleksi yang tidak memenuhi Identifikasi juga dapat dilakukan dengan menggunakan indeks.</font></font> Misalnya, seperti ini: <br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ForEach</span></span>(keys.<span class="hljs-built_in"><span class="hljs-built_in">indices</span></span>){ind <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">SomeView</span></span>(key: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.keys[ind]) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, traversal akan dibangun bukan oleh elemen itu sendiri, tetapi oleh indeks mereka. Untuk koleksi kecil, ini bisa diterima. Pada koleksi dengan sejumlah besar elemen, ini mungkin dapat mempengaruhi kinerja, terutama ketika elemen koleksi bukan tipe referensi, tetapi, misalnya, string tebal atau data JSON. Secara umum, gunakan dengan hati-hati. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin penting tentang </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa yang dimaksud </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dia sangat murung, dan menolak untuk bekerja secara normal dengan penutupan, dengan lebih dari satu blok (mis., Dia melihat konten dari satu baris secara normal, tetapi dia sudah tidak memiliki 2 atau lebih). Ini diselesaikan dengan cukup sederhana, cukup sederhana untuk memasukkan semua konten ke dalamnya </font></font><code>Groupe{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- peretasan seperti itu tidak lagi menjadi masalah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cukup nyatakan variabel internal dalam lingkup penutupan ini tidak akan berfungsi. </font><font style="vertical-align: inherit;">Setiap penutupan yang diteruskan ke ViewBuilder tidak dapat berisi deklarasi variabel. </font><font style="vertical-align: inherit;">Ingat, di awal artikel saya memberi contoh membuat pengubah </font></font><code>.frame(size:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Saya membuatnya karena alasan ini. </font><font style="vertical-align: inherit;">Saya menghitung ukuran tombol berdasarkan jumlah tombol-tombol ini dalam satu baris dan jumlah baris (saya tidak senang dengan peregangan otomatis, tombol yang berbeda harus memiliki ukuran yang berbeda). </font><font style="vertical-align: inherit;">Fungsi mengembalikan CGSize, dan beberapa tingkat struktur bersarang dirayapi di dalam. </font><font style="vertical-align: inherit;">Jika mungkin untuk menjalankan fungsi satu kali, tulis hasilnya sebagai ukuran variabel, lalu panggil</font></font><code>.ftame(width: size.width, height: size.height)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aku akan melakukannya." </font><font style="vertical-align: inherit;">Tetapi tidak ada kemungkinan seperti itu, dan saya tidak ingin melakukan fungsi dua kali - karena saya menghindari batasan ini dan memasukkan bagian dari kode ke dalam pengubah.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilan wadah khusus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, seperti yang terjadi, saya akan memberikan contoh membuat wadah kustom. </font><font style="vertical-align: inherit;">Cukup sering, hubungan beberapa objek dari tipe "1: N" dapat dengan mudah direpresentasikan dalam bentuk kamus. </font><font style="vertical-align: inherit;">Tidak </font></font><code>dict: [KeyObject: [SomeObject]]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sulit untuk </font><font style="vertical-align: inherit;">mengeksekusi kueri dan mengubah hasilnya menjadi kamus jenis </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, objek kelas bertindak sebagai kunci kamus </font></font><code>KeyObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(untuk ini, harus mendukung protokol </font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), dan nilainya adalah array objek kelas lain - </font></font><code>SomeObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Identifiable</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">UUID</span></span> = <span class="hljs-type"><span class="hljs-type">UUID</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Int</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyObject</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(name: <span class="hljs-type"><span class="hljs-type">String</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &lt; (lhs: KeyObject, rhs: KeyObject) -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bool</span></span></span><span class="hljs-function"> </span></span>{ lhs.name &lt; rhs.name } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> == </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: KeyObject, rhs: KeyObject)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.name == rhs.name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(into hasher: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hasher)</span></span></span></span> { hasher.combine(name) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika aplikasi Anda merencanakan beberapa jenis analitik dengan pengelompokan, masuk akal untuk membuat wadah terpisah untuk menampilkan kamus seperti itu agar tidak menggandakan semua kode di setiap tampilan. Dan mengingat fakta bahwa pengelompokan dapat diubah oleh pengguna, kita harus menggunakan generik. Saya tidak memperumitnya dengan menambahkan desain visual, hanya menyisakan struktur wadah kami:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Identifiable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyContent</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueContent</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyContent</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueContent</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data: [<span class="hljs-type"><span class="hljs-type">K</span></span>: [<span class="hljs-type"><span class="hljs-type">V</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyContent: (<span class="hljs-type"><span class="hljs-type">K</span></span>)-&gt;<span class="hljs-type"><span class="hljs-type">KeyContent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> valueContent: (<span class="hljs-type"><span class="hljs-type">V</span></span>)-&gt;<span class="hljs-type"><span class="hljs-type">ValueContent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span>{ <span class="hljs-type"><span class="hljs-type">VStack</span></span>(alignment: .leading, spacing: <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-type"><span class="hljs-type">ForEach</span></span>(data.keys.sorted(), id: \.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>){(key: <span class="hljs-type"><span class="hljs-type">K</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">VStack</span></span>(alignment: .trailing, spacing: <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.keyContent(key) <span class="hljs-type"><span class="hljs-type">ForEach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data[key]!){(value: <span class="hljs-type"><span class="hljs-type">V</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.valueContent(value) } } } } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, wadah menerima kamus jenis </font></font><code>[K: [V]]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(di mana </font></font><code>K</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah jenis objek kunci kamus, </font></font><code>V</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah jenis array yang terdiri dari nilai-nilai kamus), dan dua konteks: satu untuk menampilkan kunci kamus, dan yang lain untuk menampilkan nilai-nilai. Sayangnya, saya tidak menemukan contoh membuat kustom </font></font><code>ViewBuilder-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk wadah kustom (mungkin opsi ini tidak ada), jadi kita harus menggunakan yang standar </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena hanya menerima pada input </font></font><code>RandomAccessCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>dict.keys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak, kami harus menggunakan penyortiran. Oleh karena itu persyaratan untuk mendukung protokol </font></font><code>Comparable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font><code>KeyObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menggunakan dua </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kontainer </font><font style="vertical-align: inherit;">bersarang </font><font style="vertical-align: inherit;">. Dalam kasus pertama, saya menggunakan hash dari item koleksi (</font></font><code>\.self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sebagai pengidentifikasi setiap sarang </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saya bisa melakukan ini karena kunci kamus harus mendukung protokol </font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam kasus kedua, saya menambahkan </font></font><code>SomeObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dukungan protokol </font><font style="vertical-align: inherit;">ke kelas</font></font><code>Identifiable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini memungkinkan saya untuk tidak menentukan kunci komunikasi sama sekali - id digunakan secara otomatis. </font><font style="vertical-align: inherit;">Dalam kasus saya, id tidak disimpan di mana pun. </font><font style="vertical-align: inherit;">Setiap kali sebuah objek dibuat - apakah itu kreasi dalam kode, atau mengambil menggunakan query database - id baru dihasilkan. </font><font style="vertical-align: inherit;">Untuk antarmuka, ini tidak penting. </font><font style="vertical-align: inherit;">Itu tidak akan berubah sepanjang kehidupan objek yaitu </font><font style="vertical-align: inherit;">sesi, dan ini cukup untuk menampilkannya di bawah id ini. </font><font style="vertical-align: inherit;">Dan jika lain kali Anda membuka aplikasi itu akan memiliki id yang berbeda - tidak ada hal buruk yang akan terjadi. </font><font style="vertical-align: inherit;">Jika objek Anda sudah memiliki bidang kunci, Anda dapat dengan mudah membuat id sebagai parameter yang dihitung, dan tetap menggunakan dukungan protokol ini dan sintaks steno </font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh menggunakan wadah kami:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dict: [<span class="hljs-type"><span class="hljs-type">KeyObject</span></span>: [<span class="hljs-type"><span class="hljs-type">SomeObject</span></span>]] = [ <span class="hljs-type"><span class="hljs-type">KeyObject</span></span>(name: <span class="hljs-string"><span class="hljs-string">"1st group"</span></span>) : [<span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">3</span></span>)], <span class="hljs-type"><span class="hljs-type">KeyObject</span></span>(name: <span class="hljs-string"><span class="hljs-string">"2nd group"</span></span>) : [<span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">6</span></span>)], <span class="hljs-type"><span class="hljs-type">KeyObject</span></span>(name: <span class="hljs-string"><span class="hljs-string">"3rd group"</span></span>) : [<span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">7</span></span>), <span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-type"><span class="hljs-type">SomeObject</span></span>(value: <span class="hljs-number"><span class="hljs-number">9</span></span>)] ] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">TreeView</span></span>(data: dict, keyContent: {keyObject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"the key is: \(keyObject.name)"</span></span>) } ){valueObject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"value: \(valueObject.value)"</span></span>) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan hasilnya di layar di Canvas: </font></font><br><br><img src="https://habrastorage.org/webt/48/jl/e_/48jle_vonedzfqtotu7uclu2u1e.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk dilanjutkan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu saja untuk saat ini. </font><font style="vertical-align: inherit;">Saya juga ingin menyoroti semua garu yang saya injak, mencoba menggunakannya </font></font><code>CoreData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bersamaan dengan SwiftUI, tetapi, terus terang, saya tidak berharap bahwa hanya dasar-dasar SwiftUI yang akan memakan banyak waktu dan artikelnya akan sangat tebal. </font><font style="vertical-align: inherit;">Jadi, seperti kata mereka, harus dilanjutkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memiliki sesuatu untuk ditambahkan atau diperbaiki - selamat datang di komentar. </font><font style="vertical-align: inherit;">Saya akan mencoba untuk mencerminkan komentar yang signifikan dalam artikel ini.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485548/">https://habr.com/ru/post/id485548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485536/index.html">Apakah mungkin untuk meretas pesawat - 2</a></li>
<li><a href="../id485538/index.html">Zabbix: memonitor semuanya secara berurutan (pada contoh Redis)</a></li>
<li><a href="../id485542/index.html">Tambahkan grafik ke Notion</a></li>
<li><a href="../id485544/index.html">Catur sebagai sistem yang dinamis</a></li>
<li><a href="../id485546/index.html">Kiamat akan datang</a></li>
<li><a href="../id485550/index.html">Apakah ada kehidupan di luar Moscow Ring Road? Bagaimana kami mencari dan menyiapkan pengembang</a></li>
<li><a href="../id485552/index.html">Cara lain untuk melacak waktu dan membangun nomor untuk Java</a></li>
<li><a href="../id485554/index.html">Tujuan dan Hasil Utama (OKR) - Pengalaman Implementasi Bertahap Kami</a></li>
<li><a href="../id485556/index.html">Butuh 12 tahun untuk membuat bagian dari peta otak Drosophila, upaya 250 orang dan $ 40 juta</a></li>
<li><a href="../id485558/index.html">Tidak ada nyamuk! Sekilas tentang nyamuk "amunisi phyto"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>