<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚û∞ üèúÔ∏è üë®üèº‚Äç‚úàÔ∏è Jalankan tes unit secara lokal di STM32CubeIDE di bawah Windows üßîüèø üòÑ üåî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Semua orang tahu manfaat pengujian unit. Pertama-tama, menulis tes pada saat yang sama dengan kode memungkinkan Anda untuk mendeteksi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jalankan tes unit secara lokal di STM32CubeIDE di bawah Windows</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469367/"><h3 id="vvedenie">  Pendahuluan </h3><br><p><img src="https://habrastorage.org/webt/8f/3q/2r/8f3q2rt_-eycgp3_ejr_hfwqnva.png" align="left" width="200">  Semua orang tahu manfaat pengujian unit.  Pertama-tama, menulis tes pada saat yang sama dengan kode memungkinkan Anda untuk mendeteksi kesalahan lebih awal dan tidak membuang-buang waktu setelahnya pada debugging rumit yang melelahkan.  Dalam kasus pengembangan tertanam, pengujian unit memiliki fitur yang terkait, pertama, dengan fakta bahwa kode berjalan di suatu tempat yang jauh di dalam usus perangkat dan cukup sulit untuk berinteraksi dengannya, dan kedua, kode ini sangat terkait dengan perangkat keras target. . </p><br><p>  Jika ada fragmen dalam proyek yang tidak bergantung pada perangkat keras dan pada saat yang sama menerapkan logika yang cukup kompleks, bagi mereka penggunaan unit test akan memberikan manfaat terbesar.  Misalnya, itu mungkin implementasi protokol transfer data, berbagai perhitungan, atau mesin negara pengendali. </p><br><p>  Ada tiga cara untuk menjalankan tes unit untuk platform tertanam: </p><a name="habracut"></a><br><ol><li>  Luncurkan langsung pada platform target.  Dalam hal ini, Anda dapat bekerja dengan peralatan perangkat, dan kodenya akan bekerja persis sama seperti dalam kondisi pertempuran.  Namun, untuk pengujian Anda perlu akses fisik ke perangkat.  Selain itu, siklus pengujian akan cukup lama karena kebutuhan untuk terus mengunduh kode ke perangkat. </li><li>  Berjalan di emulator.  Metode ini baik terutama karena memungkinkan Anda untuk bekerja bahkan ketika platform target tidak tersedia (misalnya, karena belum dilakukan).  Kerugiannya adalah ketepatan yang terbatas dalam mereproduksi perilaku besi (dan dunia sekitarnya), serta kesulitan membuat emulator semacam itu. </li><li>  Berjalan di mesin host (lokal).  Ini tidak akan bekerja dengan peralatan (Anda dapat menggunakan rintisan uji sebagai gantinya), tetapi tes akan dengan cepat memulai dan bekerja, dan Anda tidak perlu akses ke perangkat target.  Contoh yang baik untuk menggunakan metode ini adalah menguji implementasi pada mikrokontroler dari beberapa algoritma komputasi, yang dengan sendirinya tidak tergantung pada perangkat keras, tetapi menggunakan data sensor perangkat.  Menguji suatu algoritma dengan sumber data nyata akan sangat merepotkan, jauh lebih baik untuk mencatat pengukuran ini sekali dan menjalankan tes yang sudah ada pada data yang disimpan.  Script ini akan menjalankan tes secara lokal dan akan dibahas nanti. </li></ol><br><p>  Publikasi ini menyediakan cara untuk mengonfigurasi uji unit di lingkungan STM32CubeIDE, berdasarkan Eclipse dan dimaksudkan untuk pengembangan untuk pengontrol keluarga STM32.  Bahasa pengembangan adalah C, tetapi tes itu sendiri ditulis dalam C ++.  Tes akan berjalan pada mesin host Windows menggunakan Cygwin.  Sebagai kerangka uji, Google Test digunakan.  Hasilnya akan ditampilkan di jendela plug-in khusus untuk pengujian unit, dan mereka dapat diluncurkan dengan satu tombol dari proyek untuk STM32: </p><br><p><img src="https://habrastorage.org/webt/mo/_j/gw/mo_jgwdlc6e3qqzjkcbsxrslvaq.png"></p><br><p>  Metode yang dijelaskan ini cocok untuk lingkungan pengembangan lain berdasarkan Eclipse, kecuali tentu saja produsen yang baik telah memotongnya terlalu banyak demi kenyamanan pengembang.  Metode ini juga akan bekerja dengan CubeIDE di Linux, tanpa perlu repot dengan Cygwin. </p><br><h3 id="vam-ponadobyatsya">  Anda akan membutuhkannya </h3><br><ol><li>  Cygwin 3.0.7 x86 (karena tes ini untuk mikrokontroler 32-bit, kami juga akan menggunakan lingkungan 32-bit pada platform 64-bit) </li><li>  STM32CubeIDE 1.0.2 untuk Windows. </li><li>  Google Test Framework 1.8.1 </li></ol><br><h3 id="ustanovka-cygwin-i-stm32cubeide">  Instal Cygwin dan STM32CubeIDE </h3><br><h4 id="cygwin">  Cygwin </h4><br><p>  Instal Cygwin, versi x86.  Di installer, pilih paket tambahan: gcc-core, g ++, binutils, automake, autoconf, cmake, libtool, gdb, make.  Anda dapat menginstal versi stabil paket terbaru. </p><br><p><img src="https://habrastorage.org/webt/xc/fj/6v/xcfj6v0wun10fgdbskuccodkqqk.png"></p><br><p>  Anda juga perlu mendaftarkan variabel lingkungan: </p><br><p>  <strong>PATH:</strong> ...; C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ bin;  C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib <br>  <strong>classpath:</strong> C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib </p><br><h4 id="stm32cubeide">  STM32CubeIDE </h4><br><p>  Lingkungan dipasang seperti biasa.  Disarankan untuk menginstal CubeIDE setelah Cygwin, karena dalam hal ini Cube akan mengambil toolchain Cygwin yang ada. </p><br><p>  Pertama, buat proyek C ++ untuk platform x86 Cygwin.  Kita akan membutuhkannya, pertama, untuk memeriksa fungsionalitas toolchain, dan kedua, kita akan menggunakannya sebagai "donor" konfigurasi perakitan untuk proyek utama. </p><br><p>  Pilih File&gt; Baru&gt; Proyek C / C ++.  Pilih C ++ Build yang Dikelola.  Kami membuat proyek bertipe hello world untuk rantai alat Cygwin GCC: </p><br><p><img src="https://habrastorage.org/webt/jc/ny/1n/jcny1ntttq4rzapxeth3-s2emim.png"></p><br><p>  Selanjutnya, Anda harus memilih konfigurasi rakitan mana yang akan dibuat.  Hanya Debug sudah cukup. <br>  Sekarang Anda dapat memverifikasi bahwa proyek berjalan dengan memilih Project&gt; Build All.  Juga disarankan untuk memeriksa debugging di bawah Cygwin dengan menjalankan Run&gt; Debug As&gt; C / C ++ Aplikasi Lokal.  Aplikasi ini akan menampilkan "Hello world" ke konsol di dalam CubeIDE. </p><br><p>  Agar debugger menampilkan baris yang dapat dieksekusi dalam file kode sumber, Anda perlu mengonfigurasi tampilan jalur.  Di jendela&gt; Preferensi, di tab C / C ++&gt; Debug, pilih Jalur Pencarian Sumber dan tambahkan tampilan baru: Tambah&gt; Pemetaan Jalur.  Di jendela, Anda perlu memberi nama sesuatu seperti tampilan baru dan menambahkan baris untuk disk yang ada di sistem: </p><br><ul><li>  \ cygdrive \ c - C: \ </li><li>  \ cygdrive \ g - G: \ </li></ul><br><p><img src="https://habrastorage.org/webt/fe/ro/2h/fero2hpb7i_n1cjf4sie1nfdndm.png"></p><br><p><img src="https://habrastorage.org/webt/cc/y3/4e/ccy34eo_dtfubifpmfnmkgzkjgu.png"></p><br><p>  Untuk uji coba yang indah, kami juga membutuhkan plug-in untuk Eclipse dengan dukungan untuk tes unit untuk C ++.  Itu diinstal langsung dari STM32CubeIDE: menu Bantuan&gt; Instal Perangkat Lunak Baru, lalu pilih Eclipse Repository dan instal plugin C / C ++ Unit Testing. </p><br><p><img src="https://habrastorage.org/webt/67/eh/ns/67ehnsuupvabu-i1vvkp6dfz4yc.png"></p><br><h3 id="sborka-biblioteki-google-test">  Bangun Perpustakaan Tes Google </h3><br><p>  Kode sumber perpustakaan dapat ditemukan di: <a href="">https://github.com/google/googletest/tree/release-1.8.1</a> <br>  Buka paket sumbernya, buka direktori googletest-release-1.8.1 menggunakan terminal Cygwin, dan jalankan: </p><br><pre><code class="bash hljs">cmake . make</code> </pre> <br><p>  Setelah perakitan berhasil, file perpustakaan statis akan berada di ./googlemock/lib/libgtest.a, dan file header akan berada di direktori ./googletest/include/gtest/ direktori.  Mereka perlu disalin ke proyek kami (atau menulis path ke file-file ini dalam pengaturan proyek). </p><br><h3 id="sozdanie-proekta-dlya-stm32">  Membuat proyek untuk STM32 </h3><br><p>  Desain untuk papan debug STM32L476G-DISCO.  Contohnya tidak akan terlalu canggih - ada dua LED di papan tulis, biarkan mereka menunjukkan penghitung biner dari 00 hingga 11. Kami akan menerapkan modul terpisah untuk penghitung, dijelaskan dalam sepasang file .h dan .c, dan menulis tes untuk itu. <br>  Proyek ini dapat dibuat seperti biasa, menggunakan konfigurator Cube, yang utama adalah memastikan bahwa pin PB2 dan PE8 dikonfigurasi sebagai output digital.  Saat membuat proyek, akan lebih baik untuk menentukan jenis - C ++, ini akan diperlukan untuk mengkompilasi tes (kode utama masih akan dikompilasi oleh kompiler C).  Mengonversi proyek dari C akan dimungkinkan nanti, dengan mengklik nama proyek RMB dan memilih "Konversikan ke C ++". </p><br><p>  Untuk kompilasi di bawah MK dan untuk pengujian kami membutuhkan dua konfigurasi rakitan yang berbeda.  Dalam konfigurasi ini, kumpulan file yang berbeda akan dikumpulkan - yang utama akan mendapatkan modul untuk bekerja dengan perangkat keras dan modul yang diuji, dan yang uji akan mendapatkan modul yang diuji dan file uji yang sama.  Oleh karena itu, kami akan membuat direktori berbeda di root proyek - Aplikasi dengan kode aplikasi untuk MK (Anda dapat dengan mudah mengganti nama direktori Src yang dibuat Cube), Umum untuk modul yang tidak bergantung pada besi (yang akan kami uji) dan Tes untuk pengujian.  Direktori dapat dikecualikan dari majelis dengan mengklik RMB pada namanya, menu Konfigurasi Sumber Daya&gt; Kecualikan dari build. </p><br><p>  Tambahkan modul penghitung kami ke direktori Umum: </p><br><div class="spoiler">  <b class="spoiler_title">Kode Led_counter</b> <div class="spoiler_text"><p>  (led_counter.h): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; void Led_Counter_Init(); uint8_t Led_Counter_Get_Next(); #endif /* LED_COUNTER_H_ */</span></span></span></span></code> </pre> <br><p>  led_counter.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> static uint8_t led_cnt_state = 0; void Led_Counter_Init() { led_cnt_state = 0; } uint8_t Led_Counter_Get_Next() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(++led_cnt_state &gt; 3) led_cnt_state = 0; return led_cnt_state; }</span></span></code> </pre> </div></div><br><p>  Direktori Umum dan Tes harus ditambahkan ke jalur pencarian untuk menyertakan file: properti proyek (Properti)&gt; C / C ++ Umum&gt; Jalur dan Simbol&gt; Termasuk. </p><br><p>  Tambahkan untuk bekerja dengan LED utama </p><br><div class="spoiler">  <b class="spoiler_title">Fragmen main.c</b> <div class="spoiler_text"><p>  main.c: </p><br><pre> <code class="cpp hljs">‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> ‚Ä¶ int main(void) { ‚Ä¶ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span></span></span><span class="hljs-meta"> Led_Counter_Init(); uint8_t led_state = 0; while (1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END WHILE */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 3 */</span></span></span><span class="hljs-meta"> led_state = Led_Counter_Get_Next(); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, led_state &amp; (1&lt;&lt;0)); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, led_state &amp; (1&lt;&lt;1)); HAL_Delay(500); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 3 */</span></span></span><span class="hljs-meta"> ‚Ä¶ }</span></span></code> </pre> </div></div><br><p>  Proyek harus dikompilasi dan dijalankan, dan LED harus berkedip. </p><br><h3 id="napisanie-testov">  Tes menulis </h3><br><p>  Sekarang yang semuanya dimulai. </p><br><p>  Buat konfigurasi bangunan baru melalui properti proyek - Properti&gt; C / C ++ Build&gt; Pengaturan&gt; Kelola Konfigurasi.  CubeIDE tidak akan membiarkan Anda membuat konfigurasi untuk membangun di bawah Cygwin, jadi salinlah dari proyek yang kami buat sebelumnya: </p><br><p><img src="https://habrastorage.org/webt/4d/ro/kd/4drokdgkom2o6z18duo1v_tbmwi.png"></p><br><p>  Sekarang Anda perlu beralih ke konfigurasi ini dan mengkonfigurasi jalur ke file sumber dan file header.  Dalam properti proyek di tab Paths and Symbols yang kami tentukan (saat menambahkan entri, lebih baik meletakkan daw di bidang "tambahkan ke semua bahasa"): </p><br><ul><li>  Termasuk - Tes / Inc, Umum / Inc </li><li>  Perpustakaan - gtest </li><li>  Jalur Perpustakaan - Tes / Lib </li><li>  Lokasi Sumber - / &lt;prj_name&gt; / Umum dan / &lt;prj_name&gt; / Tes (ganti &lt;prj_name&gt; dengan nama proyek) </li></ul><br><p>  Selanjutnya, salin perpustakaan gtest - file .a ke direktori Tests / Lib ke proyek, dan file header di folder gtest - ke folder Tests / Inc.  Di folder Tes, buat file main.cpp baru di mana tes akan dijalankan.  Isinya standar: </p><br><p>  main.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Unit tests main file */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); }</span></span></code> </pre> <br><p>  Juga, untuk memeriksa pengaturan, kami akan membuat satu tes yang akan memeriksa bahwa ukuran pointer adalah 32 bit di lingkungan kami (kami ingin memastikan bahwa itu sama seperti pada mikrokontroler, untuk ini kami mengatur 32-bit Cygwin). </p><br><p>  Buat file tes test_platform.cpp berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> TEST(PlatformTest, TestPointerSize) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Check pointer size is 32 bit ASSERT_EQ(sizeof(void*)*8, 32U); }</span></span></span></span></code> </pre> <br><p>  Sekarang, jika proyek dijalankan seperti biasa Aplikasi C ++, hasil debug akan berisi pesan dari Google Test yang menyatakan bahwa semua tes telah lulus. </p><br><p>  Struktur proyek akan terlihat seperti ini: <br><img src="https://habrastorage.org/webt/ev/ld/g2/evldg2fj_pqta199knozgvzicu8.png"></p><br><p>  Sekarang kita akan menulis tes untuk modul penghitung LED kita.  File pengujian dapat ditemukan di folder Tes: </p><br><div class="spoiler">  <b class="spoiler_title">test_led_counter.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Test fixture class LedCounterTest: public ::testing::Test { protected: void SetUp() { Led_Counter_Init(); } }; // Check initial value TEST_F(LedCounterTest, TestInitialValue) { Led_Counter_Init(); ASSERT_EQ(Led_Counter_Get_Next(), 1); } // Check how value is incremented TEST_F(LedCounterTest, TestIncrementValue) { Led_Counter_Init(); unsigned int val = Led_Counter_Get_Next(); for(int i=0;i&lt;1;i++) { ASSERT_EQ(Led_Counter_Get_Next(), ++val); } } // Check how value return to 0 after 3 TEST_F(LedCounterTest, TestZeroCrossing) { Led_Counter_Init(); for(int i=0;i&lt;3;i++) { Led_Counter_Get_Next(); } ASSERT_EQ(Led_Counter_Get_Next(), 0); }</span></span></span></span></code> </pre> </div></div><br><p>  Agar hasil pengujian ditampilkan di jendela yang indah, Anda perlu membuat konfigurasi peluncuran baru di menu Run&gt; Debug Configurations.  Plugin yang diinstal memungkinkan Anda untuk membuat konfigurasi tipe C / C ++ Unit.  Buat itu, panggil Jalankan Tes, pilih konfigurasi perakitan "Uji" yang digunakan dan hapus centang pada kotak centang "berhenti saat mulai di" pada tab Debugger.  Setelah itu, konfigurasi dapat dimulai. </p><br><p>  Untuk jendela dengan hasil yang muncul, pilih di Window&gt; Show View&gt; Other&gt; C / C ++&gt; C / C ++ Unit. </p><br><p><img src="https://habrastorage.org/webt/ip/qd/cr/ipqdcrsjl0iohvf1yq4_99xwieq.png"></p><br><p>  Selesai!  Sekarang proyek dapat dikompilasi dan dijalankan di bawah target MK seperti biasa.  Ketika Anda perlu menjalankan tes lokal, ketika Anda menjalankan konfigurasi Run Tests, proyek akan secara otomatis dibangun kembali untuk x86, lingkungan akan menjalankan tes dan menunjukkan hasilnya. </p><br><h3 id="literatura">  Sastra </h3><br><ol><li>  J. Grenning.  Pengembangan Didorong Uji untuk Embedded C. - pekerjaan mendasar pada pengujian unit sistem tertanam dan pada penerapan metodologi TDD. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://uncannier.com/unit-testing-of-embedded-firmware-part-1-software-confucius/</a> - Pengujian unit kode mikrokontroler x86 di Texas Composer Studio Code Composer Studio, kerangka CppUTest </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://blog.atollic.com/why-running-your-embedded-arm-cortex-code-on-a-host-pc-is-a-good-thing</a> - sebuah artikel tentang mengapa mungkin berguna untuk menjalankan kode untuk mikrokontroler pada platform desktop </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469367/">https://habr.com/ru/post/id469367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469351/index.html">Intel Comet Lake-U dan Comet Lake-Y: hingga 6 core untuk laptop tipis dan ringan</a></li>
<li><a href="../id469353/index.html">Intisari materi yang menarik untuk pengembang seluler # 317 (23-29 September)</a></li>
<li><a href="../id469355/index.html">Tutorial NumPy yang Membosankan</a></li>
<li><a href="../id469357/index.html">Lari, Gopher, lari! - apa yang akan kita bicarakan di GolangConf</a></li>
<li><a href="../id469361/index.html">Nyeri dan Air Mata di Svelte 3</a></li>
<li><a href="../id469369/index.html">Acara digital di Moskow dari 30 September hingga 06 Oktober</a></li>
<li><a href="../id469371/index.html">Deskripsi pendekatan untuk mengatur dan menguji kode menggunakan Redux Thunk</a></li>
<li><a href="../id469373/index.html">Hasil proyek untuk membuat antarmuka saraf untuk pasien yang lumpuh total dipertanyakan</a></li>
<li><a href="../id469375/index.html">Mengapa Mozilla, Coil, dan Creative Commons membagikan $ 100 juta untuk proyek sumber terbuka?</a></li>
<li><a href="../id469379/index.html">Penerapan metode validasi model formal untuk UI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>