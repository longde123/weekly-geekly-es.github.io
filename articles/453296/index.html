<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ã üåª üî¢ Gestionar la asincron√≠a en PHP: de las promesas a las rutinas üë©üèø‚Äçüíº üë©üèø‚Äç‚úàÔ∏è üõ†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQu√© es la asincron√≠a? En resumen, asincron√≠a significa realizar varias tareas durante un per√≠odo espec√≠fico de tiempo. PHP se ejecuta en un solo hilo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestionar la asincron√≠a en PHP: de las promesas a las rutinas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/453296/"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  ¬øQu√© es la asincron√≠a?  En resumen, asincron√≠a significa realizar varias tareas durante un per√≠odo espec√≠fico de tiempo.  PHP se ejecuta en un solo hilo, lo que significa que solo se puede ejecutar una pieza de c√≥digo PHP en un momento dado.  Esto puede parecer una limitaci√≥n, pero en realidad nos da m√°s libertad.  Como resultado, no tenemos que enfrentar toda la complejidad asociada con la programaci√≥n multiproceso.  Pero, por otro lado, hay una serie de problemas.  Tenemos que lidiar con la asincron√≠a.  Necesitamos de alguna manera administrarlo y coordinarlo. </p><br><p>  <em>Presentamos la traducci√≥n de un art√≠culo del blog del desarrollador de backend de Skyeng Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  Por ejemplo, cuando ejecutamos dos solicitudes HTTP paralelas, decimos que se est√°n "ejecutando en paralelo".  Esto suele ser f√°cil y sencillo de hacer, pero surgen problemas cuando necesitamos simplificar las respuestas de estas solicitudes, por ejemplo, cuando una solicitud requiere datos recibidos de otra solicitud.  Por lo tanto, es en la gesti√≥n de asincron√≠a donde reside la mayor dificultad.  Hay varias formas diferentes de resolver este problema. </p><br><blockquote>  Actualmente no hay soporte integrado para abstracciones de alto nivel para administrar la asincron√≠a en PHP, y tenemos que usar bibliotecas de terceros como ReactPHP y Amp.  En los ejemplos de este art√≠culo, uso ReactPHP. </blockquote><br><h3>  Promesas </h3><br><p>  Para comprender mejor la idea de las promesas, un ejemplo de la vida real ser√° √∫til.  Imagina que est√°s en McDonald's y quieres hacer un pedido.  Usted paga dinero por ello y as√≠ comienza la transacci√≥n.  En respuesta a esta transacci√≥n, espera obtener una hamburguesa y papas fritas.  Pero el cajero no devuelve inmediatamente la comida.  En su lugar, recibir√° un cheque con el n√∫mero de pedido.  Considere este cheque como una promesa para un pedido futuro.  Ahora puede tomar este cheque y comenzar a pensar en su delicioso almuerzo.  La esperada hamburguesa y papas fritas a√∫n no est√°n listas, por lo que debe ponerse de pie y esperar hasta que se complete su pedido.  Tan pronto como aparezca su n√∫mero en la pantalla, cambiar√° el cheque de su pedido.  Estas son las promesas: </p><br><blockquote>  <i>Sustituir el valor futuro.</i> </blockquote><p>  Una promesa es una representaci√≥n de un significado futuro, una envoltura independiente del tiempo que envolvemos alrededor de un significado.  No nos importa si el valor ya est√° aqu√≠ o todav√≠a no.  Seguimos pensando en √©l de la misma manera.  Imagine que tenemos tres solicitudes HTTP asincr√≥nicas que se ejecutan "en paralelo" para que se completen aproximadamente en un punto en el tiempo.  Pero queremos coordinar y organizar de alguna manera sus respuestas.  Por ejemplo, queremos imprimir estas respuestas tan pronto como se reciban, pero con una ligera restricci√≥n: no imprima la segunda respuesta hasta que se reciba la primera.  Aqu√≠ quiero decir que si <b>$ promise1</b> se cumple, entonces lo imprimimos.  Pero si <b>$ promise2</b> se cumple primero, no lo imprimimos, porque <b>$ promise1</b> todav√≠a <b>est√°</b> en progreso.  Imagine que estamos tratando de adaptar tres solicitudes competitivas de tal manera que para el usuario final se vean como una solicitud r√°pida. </p><br><p>  Entonces, ¬øc√≥mo podemos resolver este problema con promesas?  En primer lugar, necesitamos una funci√≥n que devuelva una promesa.  Podemos recolectar tres de esas promesas y luego juntarlas.  Aqu√≠ hay un c√≥digo falso para esto: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Aqu√≠ tengo dos funciones: <br>  <b>fakeResponse (string $ url, calllable $ callback)</b> contiene una respuesta codificada y permite la devoluci√≥n de llamada especificada con esta respuesta; <br>  <b>makeRequest (string $ url)</b> devuelve una promesa que usa <b>fakeResponse ()</b> para indicar que la solicitud se ha completado. </p><br><p>  Desde el c√≥digo del cliente, simplemente llamamos a la funci√≥n <b>makeRequest ()</b> y obtenemos las promesas: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  Era simple, pero ahora tenemos que ordenar estas respuestas de alguna manera.  Una vez m√°s, queremos que la respuesta de la segunda promesa se imprima solo despu√©s de completar la primera.  Para resolver este problema, puede construir una cadena de promesas: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  En el c√≥digo anterior, comenzamos con <b>$ promise1</b> .  Una vez que se completa, imprimimos su valor.  No nos importa cu√°nto tiempo lleve: menos de un segundo o una hora.  Tan pronto como se complete la promesa, imprimiremos su valor.  Y luego esperamos <b>$ promise2</b> .  Y aqu√≠ podemos tener dos escenarios: </p><br><p>  <b>$ promise2</b> ya <b>est√°</b> completado e imprimimos inmediatamente su valor; <br>  <b>$ promise2</b> todav√≠a se est√° cumpliendo y estamos esperando. </p><br><p>  Gracias al encadenamiento de promesas, ya no tenemos que preocuparnos por si se ha cumplido alguna promesa.  Promis no depende del tiempo y, por lo tanto, nos oculta sus estados (en el proceso, ya completados o cancelados). </p><br><p>  As√≠ es como puede controlar la asincron√≠a con promesas.  Y se ve muy bien, la cadena de promesas es mucho m√°s bonita y m√°s comprensible que un mont√≥n de devoluciones de llamadas anidadas. </p><br><h3>  Generadores </h3><br><p>  En PHP, los generadores son soporte de lenguaje incorporado para funciones que se pueden pausar y luego continuar.  Cuando se detiene la ejecuci√≥n de c√≥digo dentro de dicho generador, parece un peque√±o programa bloqueado.  Pero fuera de este programa, fuera del generador, todo lo dem√°s sigue funcionando.  Esta es toda la magia y el poder de los generadores. </p><br><p>  Literalmente, podemos pausar el generador localmente para esperar que se complete la promesa.  La idea b√°sica es usar promesas y generadores juntos.  Asumen el control de la asincron√≠a, y solo llamamos rendimiento cuando necesitamos suspender el generador.  Aqu√≠ est√° el mismo programa, pero ahora estamos conectando generadores y promesas: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>Para este c√≥digo, uso la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recoilphp / recoil</a> , que le permite llamar a <b>ReactKernel :: start ()</b> .</i>  <i>Recoil hace posible el uso de generadores PHP para ejecutar promesas asincr√≥nicas de ReactPHP.</i> </blockquote><p>  Aqu√≠, todav√≠a estamos haciendo tres consultas en paralelo, pero ahora estamos ordenando las respuestas usando la palabra clave de <b>rendimiento</b> .  Y nuevamente, mostramos los resultados al final de cada promesa, pero solo despu√©s de la anterior. </p><br><h3>  Corutinas </h3><br><p>  Las rutinas son una forma de dividir una operaci√≥n o proceso en fragmentos, con cierta ejecuci√≥n dentro de cada fragmento.  Como resultado, resulta que en lugar de realizar toda la operaci√≥n a la vez (lo que puede conducir a una congelaci√≥n notable de la aplicaci√≥n), se realizar√° gradualmente hasta que se complete toda la cantidad necesaria de trabajo. </p><br><p>  Ahora que tenemos generadores renovables e interrumpibles, podemos usarlos para escribir c√≥digo asincr√≥nico con promesas en una forma sincr√≥nica m√°s familiar.  Usando generadores y promesas PHP, puede deshacerse por completo de las devoluciones de llamada.  La idea es que cuando hacemos una promesa (usando la llamada de rendimiento), una corutina se suscribe a ella.  Corutin hace una pausa y espera hasta que se complete la promesa (completada o cancelada).  Tan pronto como se complete la promesa, la rutina continuar√° cumpli√©ndose.  Una vez finalizado con √©xito, la promesa de rutina env√≠a el valor recibido al contexto del generador mediante la llamada <b>Generator :: send ($ value)</b> .  Si la promesa falla, entonces Corutin lanza una excepci√≥n a trav√©s del generador usando la llamada <b>Generator :: throw ()</b> .  En ausencia de devoluciones de llamada, podemos escribir c√≥digo as√≠ncrono que se parece casi al s√≠ncrono habitual. </p><br><p>  <b>Ejecuci√≥n secuencial</b> </p><br><p>  Cuando se usa la rutina, el orden de ejecuci√≥n en c√≥digo asincr√≥nico ahora importa.  El c√≥digo se ejecuta exactamente en el lugar donde se llama la palabra clave de rendimiento y luego se detiene hasta que se completa la promesa.  Considere el siguiente c√≥digo: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Promise1:</b> se mostrar√° <b>aqu√≠</b> , luego la ejecuci√≥n se detiene y espera.  Tan pronto como se <b>complete</b> la promesa de <b>makeRequest ('url1')</b> , imprimimos su resultado y pasamos a la siguiente l√≠nea de c√≥digo. </p><br><p>  <b>Manejo de errores</b> </p><br><p>  El est√°ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Promises / A +</a> Promise establece que cada Promesa contiene los m√©todos <b>then () y catch ()</b> .  Esta interfaz le permite construir cadenas a partir de promesas y, opcionalmente, detectar errores.  Considere el siguiente c√≥digo: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Aqu√≠ tenemos una cadena de promesas que pasa el resultado de cada promesa anterior a la siguiente.  Pero no hay un bloque <b>catch ()</b> en esta cadena, no hay manejo de errores aqu√≠.  Cuando falla una promesa en una cadena, la ejecuci√≥n del c√≥digo se mueve al controlador de errores m√°s cercano en la cadena.  En nuestro caso, esto significa que la promesa pendiente ser√° ignorada, y cualquier error arrojado desaparecer√° para siempre.  Con las rutinas, el manejo de errores se destaca.  Si falla alguna operaci√≥n asincr√≥nica, se generar√° una excepci√≥n: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Hacer que el c√≥digo asincr√≥nico sea legible </h3><br><p>  Los generadores tienen un efecto secundario realmente importante que podemos usar para controlar la asincron√≠a y que resuelve el problema de la legibilidad del c√≥digo asincr√≥nico.  Es dif√≠cil para nosotros entender c√≥mo se ejecutar√° el c√≥digo asincr√≥nico debido al hecho de que el hilo de ejecuci√≥n cambia constantemente entre diferentes partes del programa.  Sin embargo, nuestro cerebro b√°sicamente funciona sincr√≥nicamente y de un solo subproceso.  Por ejemplo, planificamos nuestro d√≠a de manera muy consistente: hacer uno, luego otro, y as√≠ sucesivamente.  Pero el c√≥digo asincr√≥nico no funciona de la manera en que nuestros cerebros est√°n acostumbrados a pensar.  Incluso una simple cadena de promesas puede no parecer muy legible: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Tenemos que desmontarlo mentalmente para comprender lo que est√° sucediendo all√≠.  Entonces necesitamos un patr√≥n diferente para controlar la asincron√≠a.  Y en resumen, los generadores proporcionan una forma de escribir c√≥digo asincr√≥nico para que parezca s√≠ncrono. </p><br><p>  Las promesas y los generadores combinan lo mejor de ambos mundos: obtenemos c√≥digo as√≠ncrono con un gran rendimiento, pero al mismo tiempo parece s√≠ncrono, lineal y secuencial.  Las rutinas le permiten ocultar la asincron√≠a, que ya se est√° convirtiendo en un detalle de implementaci√≥n.  Y nuestro c√≥digo al mismo tiempo parece que nuestro cerebro est√° acostumbrado a pensar, de forma lineal y secuencial. </p><br><p>  Si estamos hablando de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReactPHP</a> , entonces podemos usar la biblioteca RecoilPHP para escribir promesas en forma de rutina.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amp, las</a> corutinas est√°n disponibles desde el primer momento. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453296/">https://habr.com/ru/post/453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453280/index.html">Deuda t√©cnica</a></li>
<li><a href="../453286/index.html">El error m√°s caro de mi vida: detalles sobre el ataque al puerto de la tarjeta SIM</a></li>
<li><a href="../453290/index.html">Data Science Digest (mayo de 2019)</a></li>
<li><a href="../453292/index.html">"Un peque√±o libro sobre agujeros negros"</a></li>
<li><a href="../453294/index.html">Reaccionar Carga perezosa</a></li>
<li><a href="../453298/index.html">Verano: tiempo de actualizaci√≥n ... usted mismo</a></li>
<li><a href="../453300/index.html">Shaders de juegos en 3D para principiantes</a></li>
<li><a href="../453302/index.html">La primera hora de vida con Yandex.Module</a></li>
<li><a href="../453304/index.html">Beneficios clave de Zextras PowerStore</a></li>
<li><a href="../453306/index.html">Kubernetes se har√° cargo del mundo. Cuando y como</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>