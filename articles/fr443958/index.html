<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•á üë©üèø‚Äçüéì üèôÔ∏è Mod√®le jetable (principe de conception jetable) pt.1 üòÑ üôçüèæ üîõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mod√®le jetable (principe de conception jetable) 


 Je suppose que presque tous les programmeurs qui utilisent .NET diront maintenant que ce mod√®le es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√®le jetable (principe de conception jetable) pt.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443958/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h1 id="disposable-pattern-disposable-design-principle">  Mod√®le jetable (principe de conception jetable) </h1><br><p>  Je suppose que presque tous les programmeurs qui utilisent .NET diront maintenant que ce mod√®le est un morceau de g√¢teau.  Que c'est le mod√®le le plus connu utilis√© sur la plateforme.  Cependant, m√™me le domaine probl√©matique le plus simple et le plus connu aura des zones secr√®tes que vous n'avez jamais examin√©es.  D√©crivons donc le tout depuis le d√©but pour les d√©butants et tout le reste (afin que chacun de vous se souvienne des bases).  Ne sautez pas ces paragraphes - je vous regarde! </p><br><p>  Si je demande ce qui est IDisposable, vous direz s√ªrement que c'est </p><br><pre><code class="plaintext hljs">public interface IDisposable { void Dispose(); }</code> </pre> <br><p>  Quel est le but de l'interface?  Je veux dire, pourquoi devons-nous effacer la m√©moire du tout si nous avons un garbage collector intelligent qui efface la m√©moire √† notre place, donc nous n'avons m√™me pas √† y penser.  Cependant, il y a quelques petits d√©tails. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Il existe une id√©e fausse selon laquelle <code>IDisposable</code> sert √† lib√©rer des ressources non g√©r√©es.  Ceci n'est que partiellement vrai et pour le comprendre, il vous suffit de vous souvenir des exemples de ressources non g√©r√©es.  La classe <code>File</code> est-elle une ressource non g√©r√©e?  Non.  Peut-√™tre que <code>DbContext</code> est une ressource non g√©r√©e?  Non, encore une fois.  Une ressource non g√©r√©e est quelque chose qui n'appartient pas au syst√®me de type .NET.  Quelque chose que la plateforme n'a pas cr√©√©, quelque chose qui existe hors de sa port√©e.  Un exemple simple est un descripteur de fichier ouvert dans un syst√®me d'exploitation.  Un handle est un nombre qui identifie de mani√®re unique un fichier ouvert - non, pas par vous - par un syst√®me d'exploitation.  Autrement dit, toutes les structures de contr√¥le (par exemple, la position d'un fichier dans un syst√®me de fichiers, les fragments de fichiers en cas de fragmentation et d'autres informations de service, les num√©ros d'un cylindre, d'une t√™te ou d'un secteur d'un disque dur) sont √† l'int√©rieur d'un syst√®me d'exploitation mais pas Plateforme .NET.  La seule ressource non g√©r√©e transmise √† la plateforme .NET est le num√©ro IntPtr.  Ce nombre est encapsul√© par FileSafeHandle, qui est √† son tour encapsul√© par la classe File.  Cela signifie que la classe File n'est pas une ressource non g√©r√©e √† elle seule, mais utilise une couche suppl√©mentaire sous la forme d'IntPtr pour inclure une ressource non g√©r√©e - le handle d'un fichier ouvert.  Comment lisez-vous ce fichier?  Utilisation d'un ensemble de m√©thodes sous WinAPI ou Linux OS. </p><br><p>  Les primitives de synchronisation dans les programmes multithread ou multiprocesseurs sont le deuxi√®me exemple de ressources non g√©r√©es.  Ici appartiennent des tableaux de donn√©es qui sont pass√©s par P / Invoke et aussi des mutex ou des s√©maphores. </p><br><blockquote>  Notez que le syst√®me d'exploitation ne transmet pas simplement le handle d'une ressource non g√©r√©e √† une application.  Il enregistre √©galement cette poign√©e dans le tableau des poign√©es ouvertes par le processus.  Ainsi, le syst√®me d'exploitation peut fermer correctement les ressources apr√®s la fin de l'application.  Cela garantit que les ressources seront ferm√©es de toute fa√ßon apr√®s avoir quitt√© l'application.  Cependant, la dur√©e d'ex√©cution d'une application peut √™tre diff√©rente, ce qui peut entra√Æner un verrouillage des ressources long. </blockquote><p>  Ok  Maintenant, nous avons couvert les ressources non g√©r√©es.  Pourquoi devons-nous utiliser IDisposable dans ces cas?  Parce que .NET Framework n'a aucune id√©e de ce qui se passe en dehors de son territoire.  Si vous ouvrez un fichier √† l'aide de l'API OS, .NET n'en saura rien.  Si vous allouez une plage de m√©moire √† vos propres besoins (par exemple en utilisant VirtualAlloc), .NET ne saura rien non plus.  S'il ne le sait pas, il ne lib√©rera pas la m√©moire occup√©e par un appel VirtualAlloc.  Ou, il ne fermera pas un fichier ouvert directement via un appel API OS.  Ceux-ci peuvent entra√Æner des cons√©quences diff√©rentes et inattendues.  Vous pouvez obtenir OutOfMemory si vous allouez trop de m√©moire sans la lib√©rer (par exemple, simplement en d√©finissant un pointeur sur null).  Ou, si vous ouvrez un fichier sur un partage de fichiers via le syst√®me d'exploitation sans le fermer, vous verrouillerez le fichier sur ce partage de fichiers pendant une longue p√©riode.  L'exemple de partage de fichiers est particuli√®rement bon car le verrou restera du c√¥t√© IIS m√™me apr√®s la fermeture d'une connexion avec un serveur.  Vous n'avez pas le droit de lib√©rer le verrou et vous devrez demander aux administrateurs d'effectuer <code>iisreset</code> ou de fermer la ressource manuellement √† l'aide d'un logiciel sp√©cial. <br>  Ce probl√®me sur un serveur distant peut devenir une t√¢che complexe √† r√©soudre. </p><br><p>  Tous ces cas n√©cessitent un <em>protocole</em> universel et familier <em>pour l'interaction</em> entre un syst√®me de type et un programmeur.  Il doit clairement identifier les types qui n√©cessitent une fermeture forc√©e.  L'interface IDisposable sert exactement ce but.  Il fonctionne de la mani√®re suivante: si un type contient l'impl√©mentation de l'interface IDisposable, vous devez appeler Dispose () apr√®s avoir fini de travailler avec une instance de ce type. </p><br><p>  Il existe donc deux fa√ßons standard de l'appeler.  Habituellement, vous cr√©ez une instance d'entit√© pour l'utiliser rapidement dans une m√©thode ou pendant la dur√©e de vie de l'instance d'entit√©. </p><br><p>  La premi√®re fa√ßon consiste √† encapsuler une instance en <code>using(...){ ... }</code> .  Cela signifie que vous demandez de d√©truire un objet une fois le bloc li√© √† l'utilisation termin√©, c'est-√†-dire d'appeler Dispose ().  La deuxi√®me fa√ßon consiste √† d√©truire l'objet, lorsque sa dur√©e de vie est termin√©e, avec une r√©f√©rence √† l'objet que nous voulons lib√©rer.  Mais .NET n'a rien d'autre qu'une m√©thode de finalisation qui implique la destruction automatique d'un objet, non?  Cependant, la finalisation ne convient pas du tout car nous ne savons pas quand elle sera appel√©e.  Pendant ce temps, nous devons lib√©rer un objet √† un certain moment, par exemple juste apr√®s avoir fini de travailler avec un fichier ouvert.  C'est pourquoi nous devons √©galement impl√©menter IDisposable et appeler Dispose pour lib√©rer toutes les ressources que nous poss√©dions.  Ainsi, nous suivons le <em>protocole</em> , et c'est tr√®s important.  Parce que si quelqu'un le suit, tous les participants doivent faire de m√™me pour √©viter les probl√®mes. </p><br><h2 id="different-ways-to-implement-idisposable">  Diff√©rentes fa√ßons de mettre en ≈ìuvre IDisposable </h2><br><p>  Examinons les impl√©mentations d'IDisposable du simple au compliqu√©.  La premi√®re et la plus simple consiste √† utiliser IDisposable tel quel: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { DisposableResource _anotherResource = new DisposableResource(); public void Dispose() { _anotherResource.Dispose(); } }</code> </pre> <br><p>  Ici, nous cr√©ons une instance d'une ressource qui est ensuite publi√©e par Dispose ().  La seule chose qui rend cette impl√©mentation incoh√©rente est que vous pouvez toujours travailler avec l'instance apr√®s sa destruction par <code>Dispose()</code> : </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { private DisposableResource _anotherResource = new DisposableResource(); private bool _disposed; public void Dispose() { if(_disposed) return; _anotherResource.Dispose(); _disposed = true; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } }</code> </pre> <br><p>  CheckDisposed () doit √™tre appel√© comme premi√®re expression dans toutes les m√©thodes publiques d'une classe.  La structure de classe <code>ResourceHolder</code> obtenue semble bonne pour d√©truire une ressource non manag√©e, qui est <code>DisposableResource</code> .  Toutefois, cette structure n'est pas adapt√©e √† une ressource non g√©r√©e encapsul√©e.  Regardons l'exemple avec une ressource non g√©r√©e. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { CloseHandle(_handle); } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern IntPtr CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError=true)] private static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Quelle est la diff√©rence de comportement des deux derniers exemples?  Le premier d√©crit l'interaction de deux ressources g√©r√©es.  Cela signifie que si un programme fonctionne correctement, la ressource sera quand m√™me lib√©r√©e.  √âtant donn√© que <code>DisposableResource</code> est g√©r√©, .NET CLR le sait et en lib√©rera la m√©moire si son comportement est incorrect.  Notez que je ne suppose pas consciemment ce que le type <code>DisposableResource</code> encapsule.  Il peut y avoir n'importe quel type de logique et de structure.  Il peut contenir √† la fois des ressources g√©r√©es et non g√©r√©es.  <em>Cela ne devrait pas nous concerner du tout</em> .  Personne ne nous demande de d√©compiler les biblioth√®ques de tiers √† chaque fois et de voir s'ils utilisent des ressources g√©r√©es ou non g√©r√©es.  Et si <em>notre type</em> utilise une ressource non g√©r√©e, nous ne pouvons pas l'ignorer.  Nous le faisons dans la classe <code>FileWrapper</code> .  Alors, que se passe-t-il dans ce cas?  Si nous utilisons des ressources non g√©r√©es, nous avons deux sc√©narios.  Le premier est lorsque tout est OK et que Dispose est appel√©.  Le deuxi√®me est lorsque quelque chose se passe mal et que Dispose √©choue. </p><br><p>  Disons tout de suite pourquoi cela peut mal tourner: </p><br><ul><li>  Si nous utilisons <code>using(obj) { ... }</code> , une exception peut appara√Ætre dans un bloc de code interne.  Cette exception est intercept√©e par <code>finally</code> bloc, que nous ne pouvons pas voir (il s'agit du sucre syntaxique de C #).  Ce bloc appelle implicitement Dispose.  Cependant, il y a des cas o√π cela ne se produit pas.  Par exemple, ni <code>catch</code> ni intercepter <code>finally</code> <code>StackOverflowException</code> .  Vous devez toujours vous en souvenir.  Parce que si un thread devient r√©cursif et que <code>StackOverflowException</code> se produit √† un moment donn√©, .NET oubliera les ressources qu'il a utilis√©es mais non publi√©es.  Il ne sait pas comment lib√©rer des ressources non g√©r√©es.  Ils resteront en m√©moire jusqu'√† ce que le syst√®me d'exploitation les lib√®re, c'est-√†-dire lorsque vous quittez un programme, ou m√™me quelque temps apr√®s la fin d'une application. </li><li>  Si nous appelons Dispose () √† partir d'un autre Dispose ().  Encore une fois, il se peut que nous n'arrivions pas √† y parvenir.  Ce n'est pas le cas d'un d√©veloppeur d'applications distrait, qui a oubli√© d'appeler Dispose ().  C'est la question des exceptions.  Cependant, ce ne sont pas seulement les exceptions qui bloquent un thread d'une application.  Ici, nous parlons de toutes les exceptions qui emp√™cheront un algorithme d'appeler un Dispose () externe qui appellera notre Dispose (). </li></ul><br><p>  Tous ces cas cr√©eront des ressources non g√©r√©es suspendues.  C'est parce que Garbage Collector ne sait pas qu'il doit les collecter.  Tout ce qu'il peut faire lors de la prochaine v√©rification est de d√©couvrir que la derni√®re r√©f√©rence √† un graphique d'objet avec notre type <code>FileWrapper</code> est perdue.  Dans ce cas, la m√©moire sera r√©allou√©e pour les objets avec r√©f√©rences.  Comment l'emp√™cher? </p><br><p>  Nous devons impl√©menter le finaliseur d'un objet.  Le ¬´finaliseur¬ª est ainsi nomm√© expr√®s.  Ce n'est pas un destructeur comme cela peut sembler √† cause de fa√ßons similaires d'appeler les finaliseurs en C # et les destructeurs en C ++.  La diff√©rence est qu'un finaliseur sera appel√© de <em>toute fa√ßon</em> , contrairement √† un destructeur (ainsi que <code>Dispose()</code> ).  Un finaliseur est appel√© lorsque le Garbage Collection est lanc√© (maintenant il suffit de le savoir, mais les choses sont un peu plus compliqu√©es).  Il est utilis√© pour une lib√©ration garantie des ressources en cas de <em>probl√®me</em> .  Nous <em>devons</em> impl√©menter un finaliseur pour lib√©rer les ressources non g√©r√©es.  Encore une fois, comme un finaliseur est appel√© lorsque GC est lanc√©, nous ne savons pas quand cela se produit en g√©n√©ral. </p><br><p>  D√©veloppons notre code: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { InternalDispose(); GC.SuppressFinalize(this); } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Nous avons am√©lior√© l'exemple avec les connaissances sur le processus de finalisation et s√©curis√© l'application contre la perte d'informations sur les ressources si Dispose () n'est pas appel√©.  Nous avons √©galement appel√© GC. SuppressFinalize pour d√©sactiver la finalisation de l'instance du type si Dispose () est appel√© avec succ√®s.  Il n'est pas n√©cessaire de lib√©rer deux fois la m√™me ressource, non?  Ainsi, nous r√©duisons √©galement la file d'attente de finalisation en l√¢chant une r√©gion al√©atoire de code susceptible de s'ex√©cuter avec la finalisation en parall√®le, quelque temps plus tard.  Maintenant, am√©liorons encore plus l'exemple. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Maintenant, notre exemple d'un type qui encapsule une ressource non g√©r√©e semble complet.  Malheureusement, le second <code>Dispose()</code> est en fait un standard de la plateforme et nous permettons de l'appeler.  Notez que les gens autorisent souvent le deuxi√®me appel de <code>Dispose()</code> pour √©viter les probl√®mes avec un code d'appel et c'est faux.  Cependant, un utilisateur de votre biblioth√®que qui consulte la documentation MS peut ne pas le penser et autorisera plusieurs appels de Dispose ().  L'appel √† d'autres m√©thodes publiques d√©truira de toute fa√ßon l'int√©grit√© d'un objet.  Si nous d√©truisons l'objet, nous ne pouvons plus travailler avec lui.  Cela signifie que nous devons appeler <code>CheckDisposed</code> au d√©but de chaque m√©thode publique. </p><br><p>  Cependant, ce code contient un probl√®me grave qui l'emp√™che de fonctionner comme pr√©vu.  Si nous nous souvenons du fonctionnement du ramasse-miettes, nous remarquerons une fonctionnalit√©.  Lors de la collecte des ordures, GC finalise <em>principalement</em> tout ce qui est h√©rit√© directement d' <em>Object</em> .  Ensuite, il traite des objets qui impl√©mentent <em>CriticalFinalizerObject</em> .  Cela devient un probl√®me car les deux classes que nous avons con√ßues h√©ritent de Object.  Nous ne savons pas dans quel ordre ils arriveront au ¬´dernier kilom√®tre¬ª.  Cependant, un objet de niveau sup√©rieur peut utiliser son finaliseur pour finaliser un objet avec une ressource non g√©r√©e.  Bien que cela ne semble pas √™tre une excellente id√©e.  L'ordre de finalisation serait tr√®s utile ici.  Pour le d√©finir, le type de niveau inf√©rieur avec une ressource non g√©r√©e encapsul√©e doit √™tre h√©rit√© de <code>CriticalFinalizerObject</code> . </p><br><p>  La deuxi√®me raison est plus profonde.  Imaginez que vous osiez √©crire une application qui ne prend pas grand soin de la m√©moire.  Il alloue de la m√©moire en grande quantit√©, sans encaissement ni autres subtilit√©s.  Un jour, cette application se bloquera avec OutOfMemoryException.  Lorsqu'il se produit, le code s'ex√©cute sp√©cifiquement.  Il ne peut rien allouer, car cela entra√Ænera une exception r√©p√©t√©e, m√™me si la premi√®re est intercept√©e.  Cela ne signifie pas que nous ne devrions pas cr√©er de nouvelles instances d'objets.  M√™me un simple appel de m√©thode peut lever cette exception, par exemple celle de la finalisation.  Je vous rappelle que les m√©thodes sont compil√©es lorsque vous les appelez pour la premi√®re fois.  Il s'agit d'un comportement habituel.  Comment √©viter ce probl√®me?  Assez facilement.  Si votre objet est h√©rit√© de <em>CriticalFinalizerObject</em> , <em>toutes les</em> m√©thodes de ce type seront compil√©es imm√©diatement lors du chargement en m√©moire.  De plus, si vous marquez des m√©thodes avec l'attribut <em>[PrePrepareMethod]</em> , elles seront √©galement pr√©compil√©es et seront s√©curis√©es pour appeler dans une situation de faibles ressources. </p><br><p>  Pourquoi est-ce important?  Pourquoi consacrer trop d'efforts √† ceux qui d√©c√®dent?  Parce que les ressources non g√©r√©es peuvent √™tre suspendues dans un syst√®me pendant longtemps.  M√™me apr√®s avoir red√©marr√© un ordinateur.  Si un utilisateur ouvre un fichier √† partir d'un partage de fichiers dans votre application, le premier sera verrouill√© par un h√¥te distant et lib√©r√© √† l'expiration du d√©lai ou lorsque vous lib√©rez une ressource en fermant le fichier.  Si votre application se bloque √† l'ouverture du fichier, elle ne sera pas publi√©e m√™me apr√®s le red√©marrage.  Vous devrez attendre longtemps jusqu'√† ce que l'h√¥te distant le lib√®re.  De plus, vous ne devez pas autoriser d'exceptions dans les finaliseurs.  Cela conduit √† un crash acc√©l√©r√© du CLR et d'une application car vous ne pouvez pas envelopper l'appel d'un finaliseur dans <em>try ... catch</em> .  Je veux dire, lorsque vous essayez de publier une ressource, vous devez √™tre s√ªr qu'elle peut √™tre publi√©e.  Dernier fait non moins important: si le CLR d√©charge anormalement un domaine, les finaliseurs de types, d√©riv√©s de <em>CriticalFinalizerObject,</em> seront √©galement appel√©s, contrairement √† ceux h√©rit√©s directement d' <em>Object</em> . </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce charper traduit du russe comme de la langue de l'auteur par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider √† cr√©er une version traduite de ce texte dans n'importe quelle autre langue, y compris le chinois ou l'allemand, en utilisant les versions russe et anglaise du texte comme source. <br><br>  De plus, si vous voulez dire "merci", la meilleure fa√ßon que vous pouvez choisir est de nous donner une √©toile sur github ou un r√©f√©rentiel de forking <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443958/">https://habr.com/ru/post/fr443958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443948/index.html">Concours "Je suis un expert Intel Studio" avec des super prix pour les d√©veloppeurs</a></li>
<li><a href="../fr443950/index.html">Faites confiance, conseillez, sugg√©rez - recherchez de v√©ritables critiques de logiciels</a></li>
<li><a href="../fr443952/index.html">Internet souverain - pour notre argent</a></li>
<li><a href="../fr443954/index.html">Singularit√© technologique: le mythe moderne de la fin du monde sous le couvert de l'hypoth√®se du progr√®s</a></li>
<li><a href="../fr443956/index.html">R√©seau social en 2019: Yandex lance Aura</a></li>
<li><a href="../fr443960/index.html">Mod√®le jetable (principe de conception jetable) pt.2</a></li>
<li><a href="../fr443962/index.html">Mod√®le jetable (principe de conception jetable) pt.3</a></li>
<li><a href="../fr443964/index.html">Kolesa Conf est la plus grande conf√©rence informatique au Kazakhstan. Annonce des rapports</a></li>
<li><a href="../fr443966/index.html">Google Docs - un chat pr√©f√©r√© des √©tudiants</a></li>
<li><a href="../fr443968/index.html">Comment nous avons achet√© une maison avec des panneaux solaires et ce qui en est arriv√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>