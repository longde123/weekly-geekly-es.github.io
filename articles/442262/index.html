<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏻 🕝 🙏🏾 Secreto de firmware 😧 🛷 🐳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Autores: Ph.D. Chernov A.V. ( monsieur_cher ) y Ph.D. Troshina K.N. 

 ¿Cómo, utilizando los supuestos más generales basados ​​en el conocimiento de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Secreto de firmware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/442262/">  <b>Autores: Ph.D.</b>  <b>Chernov A.V.</b>  <b>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">monsieur_cher</a> ) y Ph.D.</b>  <b>Troshina K.N.</b> <br><br>  <b>¿Cómo, utilizando los supuestos más generales basados ​​en el conocimiento de las arquitecturas de procesador modernas, puede restaurar la estructura del programa a partir de una imagen binaria de una arquitectura desconocida, y luego restaurar algoritmos y mucho más?</b> <br><br>  En este artículo hablaremos sobre una tarea interesante que se nos planteó hace varios años.  El cliente solicitó lidiar con el firmware binario del dispositivo que administraba cierto proceso físico.  Necesitaba un algoritmo de control en forma de un programa C compilado, así como fórmulas con una explicación de cómo funcionan y por qué.  Según el Cliente, esto era necesario para garantizar la compatibilidad con el equipo "antiguo" en el nuevo sistema.  La forma en que finalmente tratamos la física, en el marco de esta serie de artículos, la omitimos, pero consideraremos en detalle el proceso de restauración del algoritmo. <br><br>  El uso casi omnipresente de microcontroladores programables en dispositivos masivos (IOT o SmartHome Internet of Things) requiere prestar atención al análisis binario del código incrustado o, en otras palabras, al análisis binario del firmware del dispositivo. <br><br>  Un análisis binario del firmware del dispositivo puede tener los siguientes objetivos: <br><br><ul><li>  Análisis del código en busca de vulnerabilidades que permitan obtener acceso no autorizado al dispositivo o a los datos transmitidos o procesados ​​por este dispositivo. </li><li>  Análisis de código para características no documentadas, que conducen, por ejemplo, a la fuga de información. </li><li>  Análisis de código para restaurar protocolos e interfaces de interacción con dispositivos para garantizar la compatibilidad de este dispositivo con otros. </li></ul><br>  La tarea anterior de analizar un código binario se puede considerar como un caso especial de la tarea de analizar un binario para garantizar la compatibilidad del dispositivo. <br><a name="habracut"></a><br><h4>  Análisis del formato de archivo binario. </h4><br>  Si en el mundo de los sistemas operativos "reales", los formatos de archivos ejecutables están estandarizados, entonces, en el mundo de los programas integrados, cada proveedor puede usar su solución patentada.  Por lo tanto, el análisis del archivo de firmware binario debe comenzar con el análisis del formato de archivo binario. <br><br>  Al comienzo del trabajo, la situación para nosotros era la siguiente: recibimos un cierto archivo con el firmware sin ninguna documentación que lo acompañara.  No hubo información sobre el formato del archivo de firmware, ni sobre la arquitectura del microcontrolador. <br><br>  El archivo de firmware resultó ser un archivo de texto.  Contenía líneas de la siguiente forma: <br><br><pre><code class="tex hljs">:04013000260F970CF8 :10020000004D000B043F000B34AD010C002FFE4D30 :02023000FD0BC1 :1004000018001A0000001E0008005E000200190052</code> </pre> <br>  Después de analizar cuidadosamente el conjunto de estas líneas, nos dimos cuenta de que este es un formato Intel HEX completamente estándar para microcontroladores.  El archivo consta de registros, cada uno de los cuales indica su tipo, ubicación de memoria, datos y suma de verificación.  Por sí solo, el uso del formato Intel Hex implica que el archivo probablemente no está encriptado y es una imagen de un programa que reside en la memoria. <br><br>  Aunque el formato Intel Hex admite direcciones de memoria de hasta 32 bits, solo había direcciones de memoria de 16 bits en nuestro archivo.  Por lo tanto, es fácil crear un archivo binario de una imagen de memoria a partir de un archivo de texto en el que los registros del archivo de prueba original ya se colocarán en las direcciones especificadas.  Es más conveniente inspeccionar dicho archivo binario utilizando las utilidades de análisis de archivos binarios, y es más fácil escribir sus propias utilidades para él que para Intel HEX.  El archivo de memoria de imagen binaria confirmó que el archivo no estaba encriptado, ya que se encontraron varias líneas significativas dispersas en diferentes lugares del código. <br>  Sin embargo, esto no respondió la pregunta para qué arquitectura es este archivo. <br><br><img src="https://habrastorage.org/webt/25/6a/cq/256acqp6bgydpoj5ju-vwvc97gq.jpeg"><br><br>  Tenemos un archivo con la imagen de memoria de un microcontrolador de 16 u 8 bits.  Y qué tipo de microcontrolador es no está claro.  Tomamos IDA Pro e intentamos desmontar el archivo con todas las variantes posibles de procesadores compatibles.  Y nada  Ninguno de los procesadores IDA Pro admitidos apareció: la lista no se generó o contenía tonterías obvias.  Puede haber sido un programa para uno de los procesadores IDA Pro compatibles, pero hicimos algo mal.  Por ejemplo, solo necesitaba un procesamiento adicional del archivo de imagen.  En cualquier caso, aquí fue posible suspender el trabajo y solicitar información adicional sobre el archivo binario. <br><br><h4>  Todos los procesadores son casi iguales. </h4><br>  Pero nos resultó interesante y lo que podemos entender del programa binario, incluso si se desconoce el procesador para el que está compilado.  La respuesta es "nada", sin interés, incluso si podemos entender un poco, es mejor que nada.  Obviamente, las cadenas de texto pueden proporcionar información sobre el programa, pero nuestro objetivo es más: comprender algo de la estructura del programa. <br>  Varias arquitecturas de procesador: un gran número.  La evolución de la informática ha generado incluso las arquitecturas más inusuales, como las computadoras ternarias.  Sin embargo, los microprocesadores y microcontroladores que existen actualmente, al menos los masivos, son notablemente similares entre sí. <br><br>  A continuación, enumeramos los principios básicos comunes a los microprocesadores modernos. <br><br>  Ejecución consistente de instrucciones.  El procesador ejecuta instrucciones en secuencia en la memoria.  Hay instrucciones especiales para salto y llamada condicional e incondicional desde la subrutina, que le permiten interrumpir la selección secuencial de instrucciones de la memoria y proceder a la ejecución de otra instrucción.  Sin embargo, el resto de las instrucciones asumen una ejecución secuencial y, por lo tanto, no contienen la dirección de la siguiente instrucción. <br><br>  <i>Codificación binaria.</i>  Además del hecho de que el procesador procesa los datos en forma binaria, las instrucciones del procesador que componen el programa ejecutable están codificadas en formato binario, es decir, los campos en los que se almacenan los parámetros de la instrucción, por ejemplo, compensaciones o números de registro, ocupan un número entero de bits.  Teóricamente, uno puede imaginar que, a pesar de la codificación binaria de datos y programas, serán procesados ​​en el procesador en algún otro sistema de números, pero no somos conscientes de tal exotismo. <br><br>  Los siguientes principios, en general, no son principios arquitectónicos básicos, pero se implementan de manera prácticamente universal, especialmente para el código de máquina que no está escrito manualmente en lenguaje ensamblador, sino que es generado por un compilador de lenguaje de alto nivel. <br><br>  <i>Programación procesal.</i>  El programa se divide en unidades estructurales, que se pueden llamar de manera diferente: procedimientos, funciones, subprogramas, etc. Los subprogramas pueden llamar a otros subprogramas, pasarles parámetros y recuperar el resultado de la ejecución.  Es importante que el subprograma tenga un punto de entrada, es decir, todos los subprogramas que invocan el dado van a la misma dirección del punto de entrada. <br><br>  Típicamente, las rutinas tienen un punto de salida que devuelve el control al punto de llamada, pero esto es menos significativo que requerir un punto de entrada para cada rutina.  Tal código generalmente se obtiene compilando un programa.  El optimizador de tiempo de enlace puede destruir parcialmente esta estructura para reducir el tamaño del programa, y ​​el tamaño del programa es crítico para los sistemas integrados.  Además, esta estructura puede ser destruida por el ofuscador de código. <br><br>  La anidación de llamadas de subrutina se puede organizar utilizando la pila, que todavía se puede usar para pasar argumentos a la subrutina y almacenar variables locales, pero en el nivel actual de desarrollo de la arquitectura esta información es prematura. <br><br>  ¿Cómo se pueden aplicar estos principios al análisis inicial del código binario? <br><br>  Suponemos que hay una instrucción RET (retorno de una subrutina) en el sistema de comando del procesador.  Esta instrucción tiene algún tipo de representación binaria fija, que buscaremos.  Si RET no es el único, como en x86, donde RET tiene un argumento: el tamaño del área de parámetros de la subrutina, o si RET es un efecto secundario de una operación más complicada, como en ARMv7, donde el valor de PC se puede obtener de la pila simultáneamente con los valores de otros registros (ldmfd sp! , {fp, pc}), entonces, muy probablemente, nuestra búsqueda heurística no arrojará resultados. <br><br>  También necesitamos hacer suposiciones razonables de inmediato sobre el principio de codificar las instrucciones del procesador en estudio.  Los procesadores existentes utilizan varios principios para codificar instrucciones: <br><br><ul><li>  Una secuencia de bytes a partir de la cual se generan las instrucciones, y diferentes instrucciones se codifican con un número diferente de bytes.  En esta categoría, el representante más famoso es la familia x86, desde los primeros procesadores 8080 hasta los procesadores de 64 bits más modernos.  Una instrucción de procesador x86_64 puede codificarse en una secuencia de 1 a 16 bytes.  La misma familia de procesadores con longitudes de instrucción variables incluye 8051, que se utiliza en microcontroladores. </li><li>  Una secuencia de valores de 16 bits.  Además, cada instrucción tiene un tamaño fijo: 16 bits. </li><li>  Una secuencia de valores de 16 bits, mientras que las instrucciones son de tamaño variable.  Uno de los representantes de esta familia es la arquitectura PDP-11, en la cual el comando mismo ocupa los primeros 16 bits, y puede ser seguido por valores directos o direcciones de memoria para direccionamiento directo.  Esto incluye la codificación THUMB en la arquitectura ARM. </li><li>  Una secuencia de valores de 32 bits, cada instrucción tiene un tamaño fijo de 32 bits.  Estos son la mayoría de los procesadores RISC de 32 y 64 bits: ARMv7, ARMv8, MIPS. </li></ul><br>  Elegir entre una secuencia de bytes de longitud variable y una secuencia de palabras de 16 bits ayudará a ver la imagen de la memoria "a simple vista".  No importa cómo se codifiquen las instrucciones del procesador, en un programa de longitud suficiente, inevitablemente se repetirán.  Por ejemplo, en la instrucción x86 <br><br><pre> <code class="tex hljs">add <span class="hljs-comment"><span class="hljs-comment">%ebx,%eax</span></span></code> </pre> <br>  que agrega los valores de los registros eax y ebx y pone el resultado en eax, se codifica en dos bytes: <br><br><pre> <code class="tex hljs">01 d8.</code> </pre> <br>  En la instrucción ARMv7 <br><br><pre> <code class="tex hljs">add r0, r0, r1</code> </pre> <br>  que agrega los valores de los registros r0 y r1 y pone el resultado en r0, está codificado por el valor de 32 bits e0800001. <br><br>  En un programa suficientemente grande, tales instrucciones se repetirán más de una vez.  Si se produce una secuencia de bytes de interés para nosotros (por ejemplo, 01 d8) en una dirección arbitraria desalineada, podemos suponer que las instrucciones del procesador están codificadas por una secuencia de bytes de tamaño variable.  Si el valor, por ejemplo, e0800001 se encuentra solo en direcciones que son múltiplos de 4, podemos suponer un tamaño fijo de las instrucciones del procesador.  Por supuesto, aquí hay un error de que tomamos bytes de datos para una instrucción, o sucedió por casualidad que alguna instrucción siempre resultó estar alineada.  Sin embargo, el impacto de tal "ruido" en un programa de tamaño suficiente será pequeño. <br><br>  Cuando observamos el firmware analizado desde este ángulo, quedó claro que lo más probable es que las instrucciones para el procesador en cuestión estén codificadas con valores de 16 bits. <br><br>  Entonces, en base al supuesto de que la codificación de la instrucción RET es un valor fijo de 16 bits, intentemos encontrarlo.  Encontramos en la imagen del programa los valores de 16 bits más comunes.  En nuestro caso, sucedió lo siguiente: <br><br><pre> <code class="tex hljs"> (hex)   0b01 854 5.1<span class="hljs-comment"><span class="hljs-comment">% 0800 473 2.8% 8c0d 432 2.6% 2b00 401 2.4% 4e1c 365 2.2% 0801 277 1.6%</span></span></code> </pre><br>  Buscaremos la instrucción RET entre estos valores de 16 bits que se encuentran con mayor frecuencia en el código.  Inmediatamente buscaremos la instrucción CALL - emparejada con la instrucción RET.  La instrucción CALL tiene al menos un parámetro: la dirección de salto, por lo que los valores fijos son indispensables. <br><br>  Suponemos que en muchos casos, inmediatamente después del final de un subprograma, es decir, después de la instrucción RET, comienza otro subprograma, y ​​la instrucción CALL llama a este subprograma desde otro punto del programa.  Una gran cantidad de saltos a la dirección inmediatamente después de RET será una de las características de la instrucción CALL.  Por supuesto, esta regla no es universal, ya que en algunas plataformas, en particular, ARMv7, inmediatamente después de la finalización de la subrutina, generalmente se encuentra un grupo constante.  En este caso, podemos considerar un rango razonable de direcciones inmediatamente después de RET como puntos de transición de la instrucción RET. <br><br>  En el caso de la instrucción CALL, puede haber muchas opciones para codificarla en la subrutina.  En primer lugar, el procesador puede usar un orden de bytes diferente en la palabra: little-endian, como en la mayoría de los procesadores modernos, cuando un entero multibyte se escribe en la memoria, comenzando con el byte bajo, y big-endian, cuando un entero multibyte se escribe en la memoria, comenzando de alto byte.  Casi todos los procesadores modernos funcionan en modo little-endian, pero no debe descartar otras posibles órdenes de bytes en una palabra. <br>  En segundo lugar, la instrucción CALL puede usar el direccionamiento absoluto del punto de salto o el direccionamiento relativo a la dirección actual.  En el caso del direccionamiento absoluto, la instrucción codificada contiene la dirección a la que desea ir en algunos bits de la instrucción codificada.  Para garantizar que la subrutina se llame desde cualquier punto en el espacio de direcciones de 16 bits a cualquier otro punto en la dirección absoluta de la palabra de 16 bits, la instrucción codificada no es suficiente, ya que además de la dirección de transición, los bits del código de operación deben almacenarse en otro lugar.  Por lo tanto, tiene sentido considerar dos palabras de 16 bits seguidas y probar diferentes opciones para dividir la dirección de transición entre estas palabras. <br><br>  Una alternativa a la codificación absoluta de una dirección de rutina es la codificación relativa.  En la instrucción codificada, registramos la diferencia entre la dirección del subprograma y el punto actual.  La codificación relativa generalmente es preferible a absoluta, porque, en primer lugar, un programa con transiciones relativas es posicionalmente independiente, es decir, puede ubicarse en la memoria desde cualquier dirección sin ningún cambio en el código binario.  En segundo lugar, para codificar el desplazamiento, se pueden reservar menos bits que la dimensión del espacio de direcciones, debido al hecho de que en muchos casos la rutina llamada no está tan lejos de la que llama.  Sin embargo, si el desplazamiento de la llamada está fuera del rango de valores representables, deberá insertar instrucciones especiales: "saltos". <br><br>  La codificación relativa de una dirección de subprograma se puede realizar con algunas variaciones: en primer lugar, la dirección del punto actual del programa se puede tomar como la dirección de la instrucción actual, o como la dirección de la siguiente instrucción, como en procesadores x86, o la dirección de alguna otra instrucción cerca del punto actual.  Por ejemplo, en los procesadores ARM, el punto de referencia es la dirección de la instrucción actual +8 (es decir, no la dirección de la instrucción que sigue a la LLAMADA, sino la dirección de la instrucción que sigue a la siguiente).  Además, dado que en nuestro caso el programa se escribe como un flujo de palabras de 16 bits, es lógico esperar que el desplazamiento se exprese en palabras.  Es decir, para obtener la dirección de la rutina llamada, el desplazamiento deberá multiplicarse por 2. <br><br>  Teniendo en cuenta todo lo anterior, obtenemos el siguiente espacio de enumeración para buscar un par CALL / RET en código binario. <br><br>  Primero, tomamos palabras de 16 bits de la lista de los valores más comunes en el código como candidatos para la instrucción RET.  A continuación, buscamos a través de la instrucción CALL: <br><br><ul><li>  Orden de bytes de palabras big-endian y little-endian </li><li>  Codificación absoluta y relativa de la dirección de rutina en la instrucción. </li></ul><br>  Para la codificación absoluta, consideramos dos valores de 16 bits en una fila, es decir, clasificamos varias opciones para colocar un campo de bits que almacena una dirección absoluta en una palabra de 32 bits, y para la codificación relativa consideramos valores de 16 bits y dos palabras de 16 bits en una fila. .  A continuación, clasificamos las diferentes opciones para colocar un campo de bits que almacena las compensaciones.  Verificamos si el desplazamiento se expresa en bytes o en palabras de 16 bits, es decir, si es necesario multiplicar el desplazamiento por 2, verificamos diferentes opciones para el punto de referencia: la dirección de la instrucción actual, la dirección de la siguiente instrucción. <br><br>  Para cada una de las opciones en el espacio de búsqueda descrito anteriormente, calculamos estadísticas: <br><br><ul><li>  Cuántas supuestas direcciones del comienzo de los subprogramas no son obviamente correctas, es decir, están ubicadas donde no hay nada o donde los datos (filas explícitas o tablas explícitas de valores) están obviamente ubicadas.  Incluso para el valor correspondiente a la codificación correcta de la instrucción CALL, es bastante posible que sea posible un pequeño número de direcciones incorrectas del comienzo del subprograma si el valor correspondiente a la instrucción CALL ocurre accidentalmente en los datos. </li><li>  Cuántas direcciones de inicio de rutina putativas hay inmediatamente después de la instrucción RET putativa. </li><li>  Cuántas direcciones de inicio hipotéticas de rutinas se usan más de una vez. </li></ul><br>  Si nuestras suposiciones sobre un par de instrucciones CALL / RET son correctas, entonces debería estar en el espacio de enumeración descrito.  Pero también puede haber falsos positivos.  Bueno, comenzamos la búsqueda. <br><br>  ¡Y encontramos solo una opción posible! <br><br><pre> <code class="tex hljs">Trying 8c0d as RET After-ret-addr-set-size: 430 Matching call opcodes for 1, ff00ff00, 1: 000b003d: total: 1275, hits: 843 (66<span class="hljs-comment"><span class="hljs-comment">%), misses: 432 (33%), coverage: 76%</span></span></code> </pre> <br>  Por lo tanto, la palabra 8c0d de 16 bits es adecuada como candidata para la instrucción RET.  En total, el firmware contiene 430 posiciones de direcciones de programa inmediatamente después de esta instrucción.  Consideramos valores de 32 bits (dos palabras de 16 bits seguidas), con un valor de máscara de dirección de ff 00 ff 00, se encontró una instrucción con el código 00 0b 00 3d.  Hay 1275 instrucciones de este tipo, de las cuales 843 (es decir, 66%) transfieren el control al punto que sigue inmediatamente al candidato para RET.  Por lo tanto, se han identificado dos instrucciones: <br><br><ul><li>  RET: 8c0d (Little-Endian de 16 bits) </li><li>  CALL HHLL: 0bHH 3dLL (2 Little-Endian de 16 bits) </li></ul><br>  La instrucción CALL usa direccionamiento absoluto, y al escribir la dirección de salto, el byte alto se escribe primero, luego se escribe el byte bajo.  Es posible que en realidad se trate de dos instrucciones de procesador, cada una de las cuales carga la mitad de la dirección de transición, pero desde el punto de vista del análisis del programa, esto no es importante.  Conociendo las instrucciones CALL y RET, podemos marcar con mayor precisión las áreas de código y los datos del programa, que serán importantes para un análisis posterior. <br><br>  Continuará ... <br><br>  Además, diremos cómo se restauraron las transiciones condicionales e incondicionales y algunas operaciones aritméticas y lógicas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442262/">https://habr.com/ru/post/442262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442250/index.html">Reaccionar y Vue: fortalezas</a></li>
<li><a href="../442252/index.html">Python Code Life Cycle - Modelo de tiempo de ejecución de CPython</a></li>
<li><a href="../442256/index.html">Defensa digital del mundo plástico de los reguladores nacionales de Internet.</a></li>
<li><a href="../442258/index.html">Raspado web para desarrolladores web: un breve resumen</a></li>
<li><a href="../442260/index.html">10 comandos de Git que un desarrollador debe saber</a></li>
<li><a href="../442264/index.html">Eliminando oportunidades para secuestro de tráfico</a></li>
<li><a href="../442266/index.html">Delta Chat: mensajería descentralizada en la parte superior del correo electrónico</a></li>
<li><a href="../442268/index.html">AsyncIO Micropython: métodos de sincronización en programación asincrónica</a></li>
<li><a href="../442270/index.html">5 errores a evitar al crear modelos 3D para impresión 3D</a></li>
<li><a href="../442272/index.html">Ir + = versión de paquete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>