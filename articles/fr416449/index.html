<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏿 👨🏾‍💻 📁 .NET Core + Docker sur Raspberry Pi. Est-ce légal? 💠 📳 🕴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plate-forme ouverte .NET Core fonctionne sur presque tout: Windows, Mac et une douzaine de systèmes Linux. Mais il existe également un SDK et Runti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET Core + Docker sur Raspberry Pi. Est-ce légal?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/416449/">  La plate-forme ouverte .NET Core fonctionne sur presque tout: Windows, Mac et une douzaine de systèmes Linux.  Mais il existe également un SDK et Runtime.  Auparavant, le SDK .NET Core n'était pas pris en charge sur les puces ARMv7 / ARMv8 qui exécutent le Raspberry Pi.  Mais tout a changé.  Plus sur la façon de courir sous la coupe! <br><br><img src="https://habrastorage.org/webt/_f/b3/eg/_fb3egm773lk0sdnwyqx7cah0-s.jpeg"><a name="habracut"></a><br><br>  <i>Cet article a été écrit par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scott Hanselman</a> .</i>  <i>Je lui donne la parole.</i> <br><br>  J'aime le Raspberry Pi.  Ce sont d'excellentes machines d'apprentissage compactes, et les enfants aiment vraiment jouer avec eux.  Même si ces enfants sont des adultes, ils <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créent un cluster de six nœuds Kubernetes Raspberry Pi</a> . <br><br>  <b>NET Core est désormais pris en charge sur les distributions Linux ARM32 comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raspbian</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ubuntu</a> !</b> <br><br><blockquote>  <i>Remarque</i>  .NET Core 2.1 est pris en charge sur le Raspberry Pi 2+.  Il n'est pas pris en charge sur Pi Zero ou d'autres appareils avec une puce ARMv6.  Pour fonctionner avec .NET Core, une puce ARMv7 ou ARMv8, telle qu'une ARM Cortex-A53, est requise.  Les spécialistes de l'équipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Azure IoT Edge</a> utilisent les images .NET Core Bionic ARM32 Docker .NET pour prendre en charge les développeurs <a href="">écrivant en C # sur les appareils Edge</a> . </blockquote><br>  Il existe deux façons d'exécuter .NET Core sur le Raspberry Pi. <br><br>  <b>La première</b> consiste à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utiliser Docker</a> .  C'est littéralement le moyen le plus rapide et le plus simple de faire fonctionner .NET Core sur un Pi.  Cela semble incroyable, mais ces petits appareils Raspberry Pi prennent parfaitement en charge les conteneurs de la plate-forme Docker.  Cela peut se faire en quelques minutes.  Pour installer rapidement Docker, vous aurez besoin de: <br><br><pre><code class="cs hljs">curl -sSL https:<span class="hljs-comment"><span class="hljs-comment">//get.docker.com | sh sudo usermod -aG docker pi</span></span></code> </pre> <br>  Après avoir installé Docker, vous devez vous connecter et vous déconnecter.  Consultez un petit exemple pour vous assurer que .NET Core fonctionne correctement.  Vous pouvez voir les balises Docker disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur</a> et en savoir plus sur les modèles Docker .NET Core <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Maintenant, je peux simplement lancer Docker, puis exécuter la commande «dotnet --info» pour en savoir plus sur dotnet sur mon Pi. <br><br><pre> <code class="cs hljs">pi@raspberrypi:~ $ docker run --rm -it microsoft/dotnet:<span class="hljs-number"><span class="hljs-number">2.1</span></span>-sdk dotnet --info .<span class="hljs-function"><span class="hljs-function">NET Core </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDK</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reflecting any </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">global</span></span></span></span><span class="hljs-function"><span class="hljs-params">.json</span></span></span><span class="hljs-function">): Version: 2.1.300-rc1-008673 Commit: f5e3ddbe73 Runtime Environment: OS Name: debian OS Version: 9 OS Platform: Linux RID: debian.9-x86 Base Path: /usr/share/dotnet/sdk/2.1.300-rc1-008673/ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Host</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">useful </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> support</span></span></span><span class="hljs-function">): Version: 2.1.0-rc1 Commit: eb9bc92051 .NET Core SDKs installed: 2.1.300-rc1-008673 [/usr/share/dotnet/sdk] .NET Core runtimes installed: Microsoft.NETCore.App 2.1.0-rc1 [/usr/share/dotnet/shared/Microsoft.NETCore.App] To install additional .NET Core runtimes or SDKs: https:</span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//aka.ms/dotnet-download</span></span></span></span></code> </pre> <br>  C'est tout simplement génial!  Maintenant, je demande juste dotnet: 2.1-sdk sur le Raspberry Pi (RPi), et comme ils utilisent des fichiers multi-architecture Docker, la plate-forme fonctionne correctement.  Si vous souhaitez utiliser <a href="">.NET Core avec Docker sur ARM32</a> , vous pouvez utiliser l'une des balises suivantes. <br><br><blockquote>  <i>Remarque</i>  Les trois premières balises sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multi-arch</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bioniques</a> pour Ubuntu 18.04.  Le nom de code est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extensible</a> pour Debian 9. J'utilise donc 2.1-sdk et cela fonctionne très bien sur mon RPi, mais je peux être plus précis si je veux. </blockquote><br><ul><li>  2.1-sdk </li><li>  2.1-runtime </li><li>  2.1-aspnetcore-runtime </li><li>  2.1-sdk-stretch-arm3 </li><li>  2.1-runtime-stretch-slim-arm32v7 </li><li>  2.1-aspnetcore-runtime-stretch-slim-arm32v7 </li><li>  2.1-sdk-bionic-arm32v7 </li><li>  2.1-runtime-bionic-arm32v7 </li><li>  2.1-aspnetcore-runtime-bionic-arm32v7 </li></ul><br>  Essayez-le en quelques minutes de cette façon: <br><br><pre> <code class="cs hljs">docker run --rm microsoft/dotnet-samples:dotnetapp</code> </pre> <br>  Ici, il télécharge l'image ... <br><br><img src="https://habrastorage.org/webt/33/6m/xs/336mxsz44dzblzznmtsbk7xsykk.png"><br><br>  Dans les versions précédentes des fichiers Docker .NET Core, cela ne fonctionnerait pas si vous exécutiez l'image x64 sur ARM. <br><br><pre> <code class="cs hljs">standard_init_linux.go:<span class="hljs-number"><span class="hljs-number">190</span></span>: exec user process caused <span class="hljs-string"><span class="hljs-string">"exec format error"</span></span></code> </pre> <br>  Différents processeurs!  Mais avec les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">balises multi-</a> architecture de Kendra Havens de Microsoft, tout fonctionne bien dans la version 2.1. <br><br><blockquote>  Docker a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une fonctionnalité multi-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture</a> qui a récemment commencé à être utilisée dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">microsoft / dotnet-nightly</a> .  Dans un avenir proche, il est prévu de le transférer vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dépôt</a> officiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft / Dotnet</a> .  La fonctionnalité multi-architecture vous permet d'utiliser une balise pour plusieurs configurations de machine.  Sans cette fonctionnalité, une balise unique est requise pour chaque architecture / système d'exploitation / plate-forme.  Par exemple, la balise microsoft / dotnet: 1.0-runtime est basée sur Debian, et la balise microsoft / dotnet: 1.0-runtime-nanoserver se trouve sur le Nano Server.  Avec la multi-architecture, une seule balise microsoft / dotnet commune sera nécessaire: 1.0-runtime.  Si vous prenez cette balise de l'environnement de conteneur Linux, vous obtenez une image basée sur Debian, alors que si vous la prenez de l'environnement de conteneur Windows, vous obtenez une image basée sur Nano Server.  Cela permet de garantir la cohérence des balises dans l'environnement Docker, en évitant toute confusion. </blockquote><br>  Dans les exemples ci-dessus, je peux faire ce qui suit: <br><br>  Exécutez une application préconfigurée dans une image Docker, par exemple: <br> <code>docker run --rm microsoft/dotnet-samples:dotnetapp</code> <br> <br>  Exécutez les commandes dotnet dans une image SDK, par exemple: <br> <code>docker run --rm -it microsoft/dotnet:2.1-sdk dotnet --info</code> <br> <br>  Lancez un terminal interactif dans une image SDK, par exemple: <br> <code>docker run --rm -it microsoft/dotnet:2.1-sdk</code> <br> <br>  Comme petit exemple, ici je vais aller dans le conteneur et ajouter une petite application console et l'exécuter, juste pour prouver que c'est possible.  Tout sera supprimé lorsque je quitterai le conteneur. <br><br><pre> <code class="cs hljs">pi@raspberrypi:~ $ docker run --rm -it microsoft/dotnet:<span class="hljs-number"><span class="hljs-number">2.1</span></span>-sdk root@<span class="hljs-number"><span class="hljs-number">063f</span></span>3c50c88a:/<span class="hljs-meta"><span class="hljs-meta"># ls bin boot dev etc home lib media mnt opt proc root run sbin srv sys tmp usr var root@063f3c50c88a:/# cd ~ root@063f3c50c88a:~# mkdir mytest root@063f3c50c88a:~# cd mytest/ root@063f3c50c88a:~/mytest# dotnet new console The template "Console Application" was created successfully. Processing post-creation actions... Running 'dotnet restore' on /root/mytest/mytest.csproj... Restoring packages for /root/mytest/mytest.csproj... Installing Microsoft.NETCore.DotNetAppHost 2.1.0-rc1. Installing Microsoft.NETCore.DotNetHostResolver 2.1.0-rc1. Installing NETStandard.Library 2.0.3. Installing Microsoft.NETCore.DotNetHostPolicy 2.1.0-rc1. Installing Microsoft.NETCore.App 2.1.0-rc1. Installing Microsoft.NETCore.Platforms 2.1.0-rc1. Installing Microsoft.NETCore.Targets 2.1.0-rc1. Generating MSBuild file /root/mytest/obj/mytest.csproj.nuget.g.props. Generating MSBuild file /root/mytest/obj/mytest.csproj.nuget.g.targets. Restore completed in 15.8 sec for /root/mytest/mytest.csproj. Restore succeeded. root@063f3c50c88a:~/mytest# dotnet run Hello World! root@063f3c50c88a:~/mytest# dotnet exec bin/Debug/netcoreapp2.1/mytest.dll Hello World!</span></span></code> </pre> <br>  Si vous l'essayez vous-même, vous remarquerez que la commande dotnet run est lente.  En effet, il effectue la récupération, la génération et le démarrage.  La compilation ne va pas trop vite sur ces petits appareils.  Par conséquent, cela vaut la peine de faire le moins de travail possible.  Au lieu d'exécuter dotnet tout le temps, j'exécuterai la commande dotnet build puis l'exécutable dotnet, qui sont très rapides. <br><br>  Si vous allez essayer Docker et .NET Core, ces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ressources vous</a> seront incroyablement utiles. <br><br><h2>  Création d'applications .NET Core à l'aide de Docker </h2><br><ul><li>  <a href="">Exemple pour .NET Core Docker</a> - Cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> crée, teste et exécute un exemple.  Il intègre et crée plusieurs projets. </li><li>  <a href="">Exemple de Docker ASP.NET Core</a> - Cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> montre comment utiliser Docker à l'aide de l'application Web ASP.NET Core. </li></ul><br><h2>  Création d'applications .NET Core dans un conteneur </h2><br><ul><li>  <a href="">Développement d'applications .NET Core</a> - Cet exemple montre comment développer, créer et tester des applications .NET Core à l'aide de Docker sans installer le SDK .NET Core. </li><li>  <a href="">Développement d'applications ASP.NET Core</a> - Cet exemple montre comment développer et tester des applications ASP.NET de base à l'aide de Docker sans installer le SDK .NET Core. </li></ul><br><h2>  Optimisation de la taille des conteneurs </h2><br><ul><li>  <a href="">Exemple pour .NET Core Alpine Docker</a> - dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , une application est créée, testée et lancée à l'aide d'Alpine. </li><li>  <a href="">Exemple pour les applications autonomes NET Core</a> - dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , une application autonome est créée et lancée. </li></ul><br><h2>  ARM32 / FRAMBOISE PI </h2><br><ul><li>  <a href="">Exemple pour .NET Core ARM32 Docker</a> - dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , l'application est construite et lancée de Debian à ARM32 (s'exécute sur Raspberry Pi). </li><li>  <a href="">Exemple pour ASP.NET Core ARM32 Docker</a> - dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> , l'application ASP.NET Core est construite et lancée de Debian à ARM32 (s'exécute sur le Raspberry Pi). </li></ul><br>  Il me semble que <a href="">ces exemples sont</a> très utiles ... Assurez-vous de regarder les fichiers Docker eux-mêmes, car ils vous donneront une énorme quantité d'informations sur la façon de structurer vos propres fichiers.  La possibilité de créer des fichiers Docker en plusieurs étapes est essentielle lorsque vous travaillez sur un petit appareil, tel que RPi.  Il est conseillé de faire le moins de travail possible et de laisser Docker mettre automatiquement en cache autant de couches que possible.  Si vous ne réfléchissez pas à ce point, vous finirez par passer 10 fois plus de temps à créer des calques d'images pour chaque assemblage. <br><br><h2>  Traduction d'un vrai site ASP.NET sur Docker avec des tests! </h2><br>  Puis-je transférer mon site avec des podcasts vers Docker, et aussi le construire / tester / l'exécuter sur Raspberry Pi?  Oui! <br><br><pre> <code class="cs hljs">FROM microsoft/dotnet:<span class="hljs-number"><span class="hljs-number">2.1</span></span>-sdk AS build WORKDIR /app <span class="hljs-meta"><span class="hljs-meta"># copy csproj and restore as distinct layers COPY *.sln . COPY hanselminutes.core/*.csproj ./hanselminutes.core/ COPY hanselminutes.core.tests/*.csproj ./hanselminutes.core.tests/ RUN dotnet restore # copy everything </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> and build app COPY . . WORKDIR /app/hanselminutes.core RUN dotnet build FROM build AS testrunner WORKDIR /app/hanselminutes.core.tests ENTRYPOINT ["dotnet", "test", "--logger:trx"] FROM build AS test WORKDIR /app/hanselminutes.core.tests RUN dotnet test FROM build AS publish WORKDIR /app/hanselminutes.core RUN dotnet publish -c Release -o out FROM microsoft/dotnet:2.1-aspnetcore-runtime AS runtime WORKDIR /app COPY --from=publish /app/hanselminutes.core/out ./ ENTRYPOINT ["dotnet", "hanselminutes.core.dll"]</span></span></code> </pre> <br>  Super  Maintenant, je peux exécuter la commande docker build.  sur le Raspberry Pi.  L'appareil le restaurera, le testera et le construira.  Si le test échoue, la génération Docker échouera. <br><br>  Vous voyez, il y a une section supplémentaire appelée "testrunner", puis "test?" Après  Cette section ne fonctionne pas.  Il définit ENTRYPOINT, mais personne ne l'utilise jamais ... pour l'instant.  ENTRYPOINT est un début implicite s'il se trouve sur la dernière ligne du fichier Docker.  Ceci est fait pour que je puisse le retrouver si je veux. <br><br>  Je peux simplement le construire et courir comme ceci: <br><br><pre> <code class="cs hljs">docker build -t podcast . docker run --rm -it -p <span class="hljs-number"><span class="hljs-number">8000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> podcast</code> </pre> <br><blockquote>  <i>Remarque</i>  Notez que l'image «runtime» est microsoft / dotnet: 2.1-aspnetcore-runtime, et non microsoft / dotnet: 2.1-runtime.  En outre, aspnetcore one inclut précédemment le code binaire nécessaire pour exécuter l'application ASP.NET, donc je peux simplement inclure un lien vers "/&gt;" dans csproj.  Si vous n'avez pas utilisé l'image de base d'exécution aspnetcore, vous devez activer manuellement tous les packages ASP.NET Core dont j'ai besoin.  L'utilisation d'une image de base peut agrandir les fichiers d'image finaux, mais ce n'est qu'un équilibre entre commodité et taille.  Ça dépend de vous.  Vous pouvez activer manuellement uniquement les packages dont vous avez besoin ou utiliser le méta-package «Microsoft.AspNetCore.App» pour plus de commodité.  Mon image de podcast finale pesait 205 mégaoctets, ce qui n'est pas mal, mais, bien sûr, si je le voulais, je pourrais la réduire de plusieurs façons. </blockquote><br>  Et si j'ai juste besoin <a href="">des</a> résultats des <a href="">tests de Docker</a> , je peux les obtenir!  Cela signifie que je peux exécuter le test dans le conteneur Docker, monter le volume entre le conteneur Linux et l'hôte Windows (théorique), puis ouvrir le fichier .trx résultant dans Visual Studio! <br><br><pre> <code class="cs hljs">docker build --pull --target testrunner -t podcast:test . docker run --rm -v D:\github\hanselminutes-core\TestResults:/app/hanselminutes.core.tests/TestResults podcast:test</code> </pre> <br>  Regardez!  Voici les résultats des tests effectués dans un conteneur Linux: <br><br><img src="https://habrastorage.org/webt/ht/tm/iw/httmiwxbkkpmk-su3oodd96snbc.png"><br><br>  Voici le résultat.  J'ai maintenant un site de podcast fonctionnant dans Docker sur le ARM32 Raspberry Pi 3, et cela m'a pris juste une heure pour travailler (écrire un fichier Docker)! <br><br><img src="https://habrastorage.org/webt/s8/cc/tf/s8cctfjbtp1df_s_krt5xejcaf4.png"><br><br>  <b>La deuxième façon.</b>  Avez-vous atteint ce point?  Vous pouvez simplement installer le SDK .NET Core 2.1 sur le matériel.  Docker n'est pas nécessaire, téléchargez simplement tar.gz et configurez-le.  Je peux l'installer sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appareil comme RPI ARM32v7 Dockerfile</a> .  Notez que ce faisant, j'ai un runtime ASP.NET Core * et * .NET Core SDK communs.  Dans la version finale, vous obtiendrez un SDK qui comprendra tout, y compris ASP.NET. <br><br><pre> <code class="cs hljs">$ sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y update $ sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -y install libunwind8 gettext $ wget https:<span class="hljs-comment"><span class="hljs-comment">//dotnetcli.blob.core.windows.net/dotnet/Sdk/2.1.300-rc1-008673/dotnet-sdk-2.1.300-rc1-008673-linux-arm.tar.gz $ wget https://dotnetcli.blob.core.windows.net/dotnet/aspnetcore/Runtime/2.1.0-rc1-final/aspnetcore-runtime-2.1.0-rc1-final-linux-arm.tar.gz $ sudo mkdir /opt/dotnet $ sudo tar -xvf dotnet-sdk-2.1.300-rc1-008673-linux-arm.tar.gz -C /opt/dotnet/ $ sudo tar -xvf aspnetcore-runtime-2.1.0-rc1-final-linux-arm.tar.gz -C /opt/dotnet/ $ sudo ln -s /opt/dotnet/dotnet /usr/local/bin $ dotnet --info</span></span></code> </pre><br>  Longue vie multiplateforme! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416449/">https://habr.com/ru/post/fr416449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416437/index.html">Y a-t-il suffisamment de produits chimiques sur les mondes glacés pour y maintenir la vie?</a></li>
<li><a href="../fr416439/index.html">iOS 12: regroupement des notifications</a></li>
<li><a href="../fr416441/index.html">Pitch-tracking, ou détermination de la fréquence de pitch dans la parole, en utilisant Praat, YAAPT et YIN comme exemples</a></li>
<li><a href="../fr416443/index.html">9 secrets d'ASP.NET Core</a></li>
<li><a href="../fr416445/index.html">Webinaires Skillbox: les plus intéressants - gratuits</a></li>
<li><a href="../fr416451/index.html">Les bases de données de recherche Microsoft désormais accessibles à tous</a></li>
<li><a href="../fr416453/index.html">Schémas de vol dans les systèmes RBS et cinq niveaux de contre-attaque</a></li>
<li><a href="../fr416455/index.html">Le robot "aveugle" Cheetah 3 peut gravir une échelle jonchée d'obstacles</a></li>
<li><a href="../fr416457/index.html">Bloomberg: les fonds spéculatifs découvrent les résultats du Brexit pour les autres et gagnent des milliards</a></li>
<li><a href="../fr416459/index.html">Balises HTML en cascade à l'aide de C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>