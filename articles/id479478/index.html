<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💫 🔖 💍 Plug-in Java tanpa rasa sakit 👨‍👨‍👧‍👦 🙅🏼 😽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya ingin memberi tahu Anda cara membuat kerangka kerja aplikasi Java dengan cepat dan mudah dengan dukungan untuk pemuatan dinamis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plug-in Java tanpa rasa sakit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479478/">  Pada artikel ini, saya ingin memberi tahu Anda cara membuat kerangka kerja aplikasi Java dengan cepat dan mudah dengan dukungan untuk pemuatan dinamis plugin.  Pembaca mungkin akan segera berpikir bahwa tugas seperti itu telah dipecahkan untuk waktu yang lama, dan Anda dapat menggunakan kerangka kerja yang sudah jadi atau menulis loader kelas Anda, tetapi tidak ada yang akan diperlukan dalam solusi yang saya usulkan: <br><br><ul><li>  Kami tidak membutuhkan perpustakaan atau kerangka kerja khusus ( <a href="https://www.youtube.com/watch%3Fv%3DE3A6Z02TIjg">OSGi</a> , Guice, dll.) </li><li>  Kami tidak akan menggunakan parsing bytecode dengan ASM dan pustaka sejenis. </li><li>  Kami tidak akan menulis pemuat kelas kami. </li><li>  Kami tidak akan menggunakan refleksi dan anotasi. </li><li>  Tidak perlu repot dengan classpath untuk menemukan plugin.  Kami tidak akan menyentuh jalan setapak sama sekali. </li><li> Selain itu, kami tidak akan menggunakan XML, YAML atau bahasa deklaratif lainnya untuk mendeskripsikan titik ekstensi (titik ekstensi dalam plugin). </li></ul><br>  Namun, masih ada satu persyaratan - solusi semacam itu hanya akan bekerja di Java 9 atau lebih tinggi.  Karena itu akan didasarkan pada <a href="https://www.youtube.com/watch%3Fv%3DJ1fHBhFvmco">modul dan layanan</a> . <br><a name="habracut"></a><br>  Jadi mari kita mulai.  Kami merumuskan masalah lebih khusus: <br><blockquote> Anda perlu menerapkan kerangka kerja aplikasi minimal, yang saat startup akan memuat plugin pengguna dari folder <code>plugins</code> . </blockquote><br>  Artinya, aplikasi yang dirakit akan terlihat seperti ini: <br><br><pre> <code class="bash hljs">plugin-app/ plugins/ plugin1.jar plugin2.jar ... core.jar …</code> </pre> <br>  Mari kita mulai dengan modul <code>core</code> .  Modul ini adalah inti dari aplikasi kita, yaitu, pada kenyataannya, adalah kerangka kerja kita. <br><br><div class="spoiler">  <b class="spoiler_title">Bagi mereka yang menghargai waktu, proyek yang sudah selesai tersedia di GitHub.</b>  <b class="spoiler_title">Instruksi perakitan.</b> <div class="spoiler_text">  <a href="https://github.com/orionll/plugin-app">Tautan</a> <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/orionll/plugin-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> plugin-app mvn verify <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> core/target java --module-path core-1.0-SNAPSHOT.jar --module core</code> </pre> </div></div><br>  Buat 4 file Java berikut dalam modul: <br><br><pre> <code class="bash hljs">core/ src/main/java/ org/example/pluginapp/core/ IService.java BasicService.java Main.java module-info.java</code> </pre> <br>  File pertama, <code>IService.java</code> adalah file yang menjelaskan titik ekstensi kami.  Plugin lain kemudian akan dapat berkontribusi ke titik ekspansi ini ("berkontribusi").  Ini adalah prinsip standar untuk membangun aplikasi plug-in, yang disebut <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">prinsip inversi ketergantungan</a> (Dependency Inversion).  Prinsip ini didasarkan pada kenyataan bahwa kernel tidak bergantung pada kelas-kelas tertentu, tetapi pada antarmuka. <br><br>  Saya memberi titik ekstensi nama abstrak <code>IService</code> , karena saya sekarang menunjukkan konsep secara eksklusif.  Pada kenyataannya, itu bisa berupa titik ekstensi tertentu, misalnya, jika Anda menulis editor grafis, itu bisa menjadi efek pemrosesan gambar, misalnya, <code>IEffectProvider</code> , <code>IEffectContribution</code> atau yang lainnya, tergantung pada bagaimana Anda lebih suka menyebutkan titik ekstensi.  Pada saat yang sama, aplikasi itu sendiri akan berisi beberapa set efek dasar, dan pengembang pihak ketiga akan dapat menulis efek tambahan yang lebih canggih dan mengirimkannya dalam bentuk plug-in.  Pengguna hanya perlu memasukkan efek-efek ini di folder <code>plugins</code> dan restart aplikasi. <br><br>  File <code>IService.java</code> adalah sebagai berikut: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;IService&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleLayer layer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServiceLoader .load(layer, IService.class) .stream() .map(Provider::get) .collect(Collectors.toList()); } }</code> </pre> <br>  Jadi, <code>IService</code> hanyalah sebuah antarmuka yang melakukan beberapa <code>doJob()</code> abstrak (saya ulangi, detailnya tidak penting, pada kenyataannya itu akan menjadi sesuatu yang konkret). <br><br>  Perhatikan juga metode <code>getServices()</code> kedua.  Metode ini mengembalikan semua implementasi antarmuka <code>IService</code> yang ditemukan di lapisan modul ini dan orang tuanya.  Kami akan membicarakan hal ini secara lebih rinci nanti. <br><br>  File kedua, <code>BasicService.java</code> , adalah implementasi dasar dari antarmuka <code>IService</code> .  Itu akan selalu ada, bahkan jika tidak ada plugin dalam aplikasi.  Dengan kata lain, <code>core</code> bukan hanya inti, tetapi juga plugin untuk dirinya sendiri, yang akan selalu dimuat.  File <code>BasicService.java</code> terlihat seperti ini: <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Basic service"</span></span>); } }</code> </pre> <br>  Untuk kesederhanaan, <code>doJob()</code> hanya mencetak string <code>"Basic service"</code> dan hanya itu. <br><br>  Jadi, saat ini kami memiliki gambar berikut: <br><br><img src="https://habrastorage.org/webt/du/0f/fd/du0ffdkzy6bqmyc6rvqj6p-jw7w.png"><br><br>  File ketiga, <code>Main.java</code> , adalah tempat metode <code>main()</code> diimplementasikan.  Ada sedikit keajaiban di dalamnya, untuk memahami yang Anda perlu tahu apa itu layer modul. <br><br><h2>  Tentang lapisan modul </h2><br>  Ketika Java meluncurkan aplikasi, maka semua modul platform + modul yang tercantum dalam argumen <code>--module-path</code> (dan juga <code>classpath</code> , jika ada) jatuh ke dalam apa yang disebut layer <code>Boot</code> .  Dalam kasus kami, jika kami mengkompilasi modul core.jar dan menjalankan <code>java --module-path core.jar --module core</code> dari baris perintah, maka setidaknya <code>java.base</code> dan modul <code>core</code> akan berada di lapisan <code>Boot</code> : <br><br><img src="https://habrastorage.org/webt/z5/ar/n-/z5arn-jtfurxwqjja-fxrbdfjbu.png"><br><br>  Lapisan <code>Boot</code> selalu ada di aplikasi Java apa pun, dan ini adalah konfigurasi sekecil mungkin.  Sebagian besar aplikasi ada dalam satu lapisan modul.  Namun, dalam kasus kami, kami ingin melakukan pemuatan dinamis plugin dari folder <code>plugins</code> .  Kami hanya bisa memaksa pengguna untuk memperbaiki jalur peluncuran aplikasi sehingga ia sendiri menambahkan plugin yang diperlukan ke <code>--module-path</code> , tetapi ini tidak akan menjadi solusi terbaik.  Terutama orang-orang yang bukan programmer dan tidak mengerti mengapa mereka harus naik ke suatu tempat dan memperbaiki sesuatu untuk hal yang begitu sederhana. <br><br>  Untungnya, ada solusinya: Java memungkinkan Anda membuat layer modul Anda sendiri dalam runtime, yang akan memuat modul dari tempat yang kita butuhkan.  Untuk keperluan kami, satu lapisan baru untuk plugin akan cukup, yang akan memiliki lapisan <code>Boot</code> sebagai induk (setiap lapisan harus memiliki induk): <br><br><img src="https://habrastorage.org/webt/1-/yd/5i/1-yd5ikax42qfadybbu1uqbnkgo.png"><br><br>  Fakta bahwa lapisan plugin memiliki lapisan <code>Boot</code> sebagai induknya berarti bahwa modul-modul dari lapisan plugin dapat merujuk ke modul-modul dari lapisan <code>Boot</code> , tetapi tidak sebaliknya. <br><br>  Jadi, mengetahui sekarang apa itu lapisan modul, Anda akhirnya dapat melihat isi file <code>Main.java</code> : <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Path pluginsDir = Paths.get(<span class="hljs-string"><span class="hljs-string">"plugins"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      plugins ModuleFinder pluginsFinder = ModuleFinder.of(pluginsDir); //  ModuleFinder      plugins       List&lt;String&gt; plugins = pluginsFinder .findAll() .stream() .map(ModuleReference::descriptor) .map(ModuleDescriptor::name) .collect(Collectors.toList()); //  ,      (   ) Configuration pluginsConfiguration = ModuleLayer .boot() .configuration() .resolve(pluginsFinder, ModuleFinder.of(), plugins); //      ModuleLayer layer = ModuleLayer .boot() .defineModulesWithOneLoader(pluginsConfiguration, ClassLoader.getSystemClassLoader()); //     IService       Boot List&lt;IService&gt; services = IService.getServices(layer); for (IService service : services) { service.doJob(); } } }</span></span></code> </pre> <br>  Jika ini adalah pertama kalinya Anda melihat kode ini, ini mungkin terlihat sangat rumit, tetapi ini adalah sensasi yang salah karena banyaknya kelas baru yang tidak dikenal.  Jika Anda mengerti sedikit tentang arti dari kelas <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html">ModuleFinder</a> , <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html">Konfigurasi,</a> dan <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">ModuleLayer</a> , maka semuanya jatuh ke tempatnya.  Dan selain itu, hanya ada beberapa baris!  Ini semua logika yang ditulis sekali. <br><br><h2>  Deskriptor modul </h2><br>  Ada satu lagi (keempat) file yang tidak kami pertimbangkan: <code>module-info.java</code> .  Ini adalah file terpendek yang berisi deklarasi modul kami dan deskripsi layanan (titik ekstensi): <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> core { <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> org.example.pluginapp.core; uses IService; provides IService with BasicService; }</code> </pre> <br>  Arti dari baris file ini harus jelas: <br><br><ul><li>  Pertama, modul mengekspor paket <code>org.example.pluginapp.core</code> plugin dapat mewarisi dari antarmuka <code>IService</code> (jika tidak, <code>IService</code> tidak akan dapat diakses di luar modul <code>core</code> ). </li><li>  Kedua, ia mengumumkan bahwa ia menggunakan Layanan. </li><li>  Ketiga, ia mengatakan bahwa ia menyediakan implementasi layanan <code>IService</code> melalui kelas <code>BasicService</code> . </li></ul><br>  Karena deklarasi modul ditulis dalam Java, kami mendapatkan keuntungan yang sangat penting: <i>pemeriksaan kompiler dan jaminan statis</i> .  Misalnya, jika kami melakukan kesalahan atas nama tipe atau mengindikasikan paket yang tidak ada, kami akan segera mendapatkannya.  Dalam kasus beberapa OSGi, kami tidak akan memiliki pemeriksaan pada waktu kompilasi, karena deklarasi titik ekstensi akan ditulis dalam XML. <br><br>  Jadi, frame sudah siap.  Mari kita coba jalankan: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Basic service</code> </pre> <br>  Apa yang terjadi <br><br><ol><li>  Java mencoba menemukan modul di folder <code>plugins</code> dan tidak menemukannya. </li><li>  Lapisan kosong telah dibuat. </li><li>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> mulai mencari semua implementasi <code>IService</code> . </li><li>  Di lapisan kosong, ia tidak menemukan implementasi layanan, karena tidak ada modul di sana. </li><li>  Setelah lapisan ini, ia terus mencari di lapisan induk (mis., Lapisan <code>Boot</code> ) dan menemukan satu implementasi <code>BasicService</code> dalam modul <code>core</code> . </li><li>  Semua implementasi yang ditemukan memiliki metode <code>doJob()</code> yang dipanggil.  Karena hanya satu implementasi yang ditemukan, hanya <code>"Basic service"</code> yang dicetak. </li></ol><br><h2>  Menulis sebuah plugin </h2><br>  Setelah menulis inti dari aplikasi kita, sekarang saatnya untuk mencoba menulis plugin untuk itu.  Mari kita menulis dua <code>plugin1</code> dan <code>plugin2</code> : biarkan cetak pertama <code>"Service 1"</code> , yang kedua - <code>"Service 2"</code> .  Untuk melakukan ini, Anda harus memberikan dua implementasi <code>IService</code> lagi di <code>plugin1</code> dan <code>plugin2</code> masing-masing: <br><br><img src="https://habrastorage.org/webt/-o/3n/4v/-o3n4vlwhx-vwqxn7jpkunlamjq.png"><br><br>  Buat plugin pertama dengan dua file: <br><br><pre> <code class="bash hljs">plugin1/ src/main/java/ org/example/pluginapp/plugin1/ Service1.java module-info.java</code> </pre> <br>  File <code>Service1.java</code> : <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Service 1"</span></span>); } }</code> </pre> <br>  File <code>module-info.java</code> : <br><br><pre> <code class="java hljs">… <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> plugin1 { <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> core; provides IService with Service1; }</code> </pre> <br>  Perhatikan bahwa <code>plugin1</code> bergantung pada <code>core</code> .  Ini adalah prinsip inversi ketergantungan yang saya sebutkan sebelumnya: kernel tidak bergantung pada plugin, tetapi sebaliknya. <br><br>  Plugin kedua sangat mirip dengan yang pertama, jadi saya tidak akan memberikannya di sini. <br><br>  Sekarang mari kita kumpulkan plugin, letakkan di folder <code>plugins</code> dan jalankan aplikasi: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Service 1 Service 2 Basic service</code> </pre> <br>  Hore, plugin sudah diambil!  Bagaimana ini terjadi: <br><br><ol><li>  Java menemukan dua modul di folder <code>plugins</code> . </li><li>  Sebuah layer dibuat dengan dua modul <code>plugins1</code> dan <code>plugins2</code> . </li><li>  ServiceLoader mulai mencari semua implementasi <code>IService</code> . </li><li>  Di lapisan plugin, ia menemukan dua implementasi layanan <code>IService</code> . </li><li>  Setelah itu, ia terus mencari di lapisan induk (mis., Lapisan <code>Boot</code> ) dan menemukan satu implementasi <code>BasicService</code> dalam modul <code>core</code> . </li><li>  Semua implementasi yang ditemukan memiliki metode <code>doJob()</code> yang dipanggil. </li></ol><br>  Perhatikan bahwa justru karena pencarian penyedia layanan dimulai dengan lapisan anak, dan kemudian pergi ke lapisan induk, kemudian <code>"Service 1"</code> dan <code>"Service 2"</code> dicetak terlebih dahulu, kemudian <code>"Basic Service"</code> .  Jika Anda ingin layanan diurutkan sehingga layanan dasar berjalan lebih dulu, dan kemudian plugin, maka Anda dapat mengubah metode <code>IService.getServices()</code> dengan menambahkan pengurutan di sana (Anda mungkin perlu menambahkan metode <code>int getOrdering()</code> ke antarmuka <code>IService</code> ). <br><br><h2>  Ringkasan </h2><br>  Jadi, saya menunjukkan bagaimana Anda dapat dengan cepat dan efisien mengatur aplikasi Java plug-in yang memiliki properti berikut: <br><br><ul><li>  <b>Kesederhanaan:</b> untuk titik ekstensi dan pengikatannya, hanya fitur Java dasar (antarmuka, kelas, dan <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> ) yang digunakan, tanpa kerangka kerja, refleksi, anotasi, dan pemuat kelas. </li><li>  <b>Deklarabilitas:</b> titik ekstensi dijelaskan dalam deskriptor modul.  Lihat saja <code>module-info.java</code> dan pahami poin ekstensi apa yang ada dan plugin apa yang berkontribusi pada poin-poin ini. </li><li>  <b>Jaminan statis:</b> jika terjadi kesalahan dalam deskriptor modul, program tidak akan dikompilasi.  Juga, sebagai bonus, jika Anda menggunakan IntelliJ IDEA, Anda akan menerima peringatan tambahan (misalnya, jika Anda lupa menggunakan <code>uses</code> dan menggunakan <code>ServiceLoader.load()</code> ) </li><li>  <b>Keamanan:</b> sistem Java modular memeriksa saat startup bahwa konfigurasi modul sudah benar dan menolak untuk menjalankan program jika terjadi kesalahan. </li></ul><br>  Saya ulangi, saya hanya menunjukkan ide.  Dalam aplikasi plug-in yang sebenarnya, akan ada puluhan hingga ratusan modul dan ratusan hingga ribuan titik ekstensi. <br><br>  Saya memutuskan untuk mengangkat topik ini karena selama 7 tahun terakhir saya telah menulis aplikasi modular menggunakan Eclipse RCP, di mana OSGi terkenal digunakan sebagai sistem plug-in, dan deskriptor plug-in ditulis dalam XML.  Kami memiliki lebih dari seratus plugin dan kami masih duduk di Java 8. Tetapi bahkan jika kami meningkatkan ke versi baru Java, kami tidak mungkin menggunakan modul Java, karena mereka sangat terikat dengan OSGi. <br><br>  Tetapi jika Anda menulis aplikasi plug-in dari awal, maka modul Java adalah salah satu opsi yang mungkin untuk implementasinya.  Ingat bahwa modul hanyalah alat, bukan tujuan. <br><br><h2>  Tentang saya secara singkat </h2><br>  Saya telah pemrograman selama lebih dari 10 tahun (8 di antaranya di Jawa), saya menanggapi <a href="https://stackoverflow.com/users/706317/zhekakozlov">StackOverflow</a> dan menjalankan <a href="https://t.me/miniJUG">saluran</a> saya sendiri <a href="https://t.me/miniJUG">di Telegram yang</a> dikhususkan untuk Jawa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479478/">https://habr.com/ru/post/id479478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479462/index.html">Serialisasi dalam C ++</a></li>
<li><a href="../id479464/index.html">Pipa & Filter. Contoh aplikasi dan implementasi menggunakan Spring</a></li>
<li><a href="../id479466/index.html">Habraiting 2019: statistik dan peringkat artikel terbaik untuk 2019</a></li>
<li><a href="../id479468/index.html">Edge of Honesty dan John Doe</a></li>
<li><a href="../id479474/index.html">Mengapa self-organisasi tim sangat penting dalam Scrum dan mengapa tidak ada manajer di dalamnya</a></li>
<li><a href="../id479480/index.html">SARIF SDK dan Kesalahannya</a></li>
<li><a href="../id479482/index.html">SARIF SDK dan kesalahannya</a></li>
<li><a href="../id479486/index.html">Pemrograman heterogen dan oneAPI Toolkit. Kuliah pakar improvisasi Intel menjawab pertanyaan Anda</a></li>
<li><a href="../id479488/index.html">Dari laptop - server rumah dengan daya redundan ke router Mikrotik</a></li>
<li><a href="../id479492/index.html">Komputasi tanpa server berdasarkan OpenWhisk, bagian 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>