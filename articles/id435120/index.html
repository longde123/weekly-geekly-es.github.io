<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😫 🙌 🕞 Fungsi Lambda dalam SQL ... mari kita pikirkan 🤵🏾 🔝 👩🏼‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tentang apa artikel itu, dan demikian namanya. 

 Selain itu, penulis akan menjelaskan mengapa ini perlu dari sudut pandangnya, serta memberi tahu bah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fungsi Lambda dalam SQL ... mari kita pikirkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435120/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ch/fp/slchfpm_a-deoh62fqiazjgdc5k.png" alt="gambar"></div><br>  Tentang apa artikel itu, dan demikian namanya. <br><br>  Selain itu, penulis akan menjelaskan mengapa ini perlu dari sudut pandangnya, serta memberi tahu bahwa SUBJ bukan hanya teknologi yang modis, tetapi juga "bisnis yang perlu dua kali lipat - menyenangkan dan bermanfaat." <br><a name="habracut"></a><br>  Itu selalu menarik untuk melihat bagaimana beberapa orang berbakat melakukan sesuatu (bahasa pemrograman, mengapa tidak), tahu persis masalah apa yang mereka pecahkan dan tugas apa yang mereka tetapkan untuk diri mereka sendiri.  Dan juga menguji kreasi mereka pada diri mereka sendiri.  Itu tidak bisa dibandingkan dengan kreasi monumental komite raksasa, yang menempatkan pemeliharaan harmoni alam semesta di garis depan, dan siapa yang memahaminya. <br><br>  Bandingkan, misalnya, nasib <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FORTRAN</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PL / 1</a> .  Siapa yang sekarang akan ingat tentang PL / 1 ini. <br><br>  Dari sudut pandang ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWK</a> , misalnya, sangat sukses.  Patut dikatakan bahwa dalam namanya A adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alfred Aho</a> , salah satu penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dragon Book</a> , W adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peter Weinberger</a> , yang memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">andil</a> di Fortran-77, K adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brian Kernigan</a> , di mana ia akan tanpanya.  Bahasa ini dimaksudkan untuk memproses aliran teks on-the-fly dalam pipa di antara proses. <br><br>  Bahasa ini tidak bertuliskan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini tidak sepenuhnya benar</a> ), sintaksisasinya sangat mirip dengan C, ia memiliki kemampuan penyaringan, susunan asosiatif, peristiwa mulai / akhir streaming, acara baris baru ... <br><br>  Penulis selalu terkesan dengan bahasa ini juga oleh kenyataan bahwa penerjemahnya tidak perlu diinstal, di bawah sistem seperti UNIX selalu ada, dan di bawah Windows itu cukup hanya untuk menyalin file yang dapat dieksekusi dan semuanya berfungsi.  Namun, ini bukan masalahnya. <br><br>  Dalam prosesnya, penulis harus menggunakan bundel SQL + AWK cukup sering, dan itulah sebabnya.  SQL masih merupakan bahasa yang awalnya bersifat deklaratif yang dirancang untuk mengontrol aliran data.  Ini memberikan peluang yang sangat terbatas untuk bekerja dengan konteks eksekusi permintaan dalam bentuk fungsi agregat. <br><br>  Bagaimana, misalnya, untuk membangun histogram dua dimensi menggunakan SQL? <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   100 x 100 SELECT count(), round(x, -2) AS cx, round(y, -2) AS cy FROM samples GROUP BY cx, xy</span></span></code> </pre> <br>  Tapi katakanlah, menggunakan GROUP BY menyiratkan penyortiran, dan itu bukan kesenangan murah jika Anda memiliki ratusan juta (atau bahkan lebih) baris. <br><div class="spoiler">  <b class="spoiler_title">UPD: dalam komentar mereka mengoreksi saya bahwa ini tidak sepenuhnya benar (atau tidak sama sekali)</b> <div class="spoiler_text">  Prosesor SQL memiliki kemampuan untuk melakukan fungsi agregat dalam proses membangun hash sesuai dengan kriteria pengelompokan.  Untuk ini, perlu memiliki jumlah memori bebas yang cukup untuk menempatkan peta hash dalam memori. <br><br>  Kemudian konteks grup akan diperbarui saat tabel dibaca dan pada akhir bacaan ini kita sudah memiliki hasil perhitungan. <br>  Teknik yang sama dapat diperluas ke fungsi jendela (di bawah), hanya konteksnya akan "lebih tebal". <br><br>  Dalam kasus ketika jumlah grup tidak diketahui sebelumnya atau sangat besar, prosesor SQL dipaksa untuk membangun indeks sementara dan menjalankannya dalam pass kedua. <br><br>  Dalam kasus sederhana, misalnya, seperti di sini - COUNT sederhana, opsi universal dimungkinkan - indeks sementara (cx, cy, hitung), kemudian dengan sejumlah kecil grup, semuanya akan tersimpan dalam memori pada halaman yang di-cache.  Dalam kasus kompleks, fungsi jendela, keadaan kelompok menjadi non-sepele dan terus-menerus membuat serialisasi itu sama sekali bukan apa yang diperintahkan dokter. <br></div></div>  Ringkasan: Prosesor SQL resor untuk menyortir ketika tidak dapat memperkirakan jumlah grup setelah GROUP BY.  Namun, pengelompokan berdasarkan nilai yang dihitung (seringkali) adalah kasus yang sebenarnya. <br><br>  Karena itu, Anda harus melakukan sesuatu seperti: <br><br><pre> <code class="bash hljs">psql -t -q -c <span class="hljs-string"><span class="hljs-string">'select x, y from samples'</span></span> | gawk -f mk_hist2d.awk</code> </pre> <br>  di mana mk_hist2d.awk mengakumulasi statistik dalam array asosiatif dan menampilkannya setelah selesai bekerja <br><br><pre> <code class="cpp hljs"># mk_hist2d.awk { bucket[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>)]+=$<span class="hljs-number"><span class="hljs-number">1</span></span>; } END { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i, j) in bucket) print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>bucket[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" 0"</span></span>; } }</code> </pre><br>  Ada satu TETAPI - aliran data lengkap harus dikirim dari server ke mesin yang bekerja, dan ini tidak begitu murah. <br><br>  Apakah mungkin untuk entah bagaimana menggabungkan yang menyenangkan dengan yang berguna - untuk mengumpulkan statistik selama pelaksanaan query SQL, tetapi tanpa menggunakan penyortiran?  Ya, misalnya, menggunakan fungsi agregat khusus. <br><br><h4>  Fungsi Agregat Khusus </h4><br>  Subj hadir dalam sistem yang berbeda, di mana pun ia dilakukan sedikit dengan caranya sendiri. <br><br><ol><li>  <b>PostgreSQL</b>  Dokumentasinya ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinilah</a> saldo akun maksimum dihitung. <br>  Dan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> yang menghitung apa yang lebih dalam kolom boolean - benar atau salah. <br><br>  Sepertinya ini - <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AGGREGATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mode</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span>) ( SFUNC = mode_bool_state, STYPE = <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>[], FINALFUNC = mode_bool_final, INITCOND = <span class="hljs-string"><span class="hljs-string">'{0,0}'</span></span> );</code> </pre><br>  Di sini <b>SFUNC</b> adalah fungsi yang dipanggil untuk setiap baris dalam aliran, <br>  argumen pertama di dalamnya adalah tipe <b>STYPE</b> . <br><br>  <b>FINALFUNC</b> digunakan untuk menyelesaikan perhitungan dan mengembalikan nilai agregat. <br>  <b>INITCOND</b> - inisialisasi nilai awal status internal ( <b>STYPE</b> ), disahkan sebagai argumen pertama. <br>  Mengingat bahwa fungsi dapat ditulis dalam C (yang berarti bahwa untuk keadaan internal Anda dapat menggunakan memori yang secara otomatis dibebaskan ketika Anda menutup permintaan), ini adalah alat yang sangat kuat.  Di luar ruang lingkup penggunaannya, seseorang masih harus bisa pergi. </li><li>  <b>MS SQL</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebelumnya</a> (2000), sebelum permintaan, perlu membuat objek ActiveX, untuk melakukan agregasi menggunakan objek ini. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sekarang</a> (2016+) ini dilakukan di lingkungan CLR.  Anda harus membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> kustom, membuat dan mendaftarkan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">majelis</a> .  Kemudian Anda bisa membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">agregat</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh</a> menghitung rata-rata geometrik, serta menggabungkan string: dengan parameter tambahan dan tipe yang ditentukan pengguna untuk menyimpan keadaan perantara. </li><li>  <b>Oracle</b> <br>  Di Oracle, ini dilakukan dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ODCIAggregate</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Cartridge</a> (antarmuka). <br>  Untuk membuat agregat Anda sendiri, Anda perlu menulis jenis khusus yang mengimplementasikan 4 metode <br>  - inisialisasi (ODCIAggregateInitialize), statis, harus membuat turunan dari tipe yang diinginkan dan kembali melalui parameter <br>  - iterations (ODCIAggregateIterate), dipanggil pada setiap baris data <br>  - merge (ODCIAggregateMerge), digunakan untuk menggabungkan agregat yang dieksekusi secara paralel <br>  - selesai (ODCIAggregateTerminate) - hasil keluaran <br>  Contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4</a> . </li><li>  <b>DB2</b> <br>  Tidak ada cara eksplisit untuk menggunakan agregat kustom di DB2. <br>  Tapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda bisa</a> memasukkan fungsi standar (meskipun MAX) ke tipe yang ditentukan pengguna (di Jawa) dan membuat sistem mengeksekusi kueri formulir <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> Complex <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span>, i <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span> ) … <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> complexNumbers ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> Complex ) … <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum..real, sum..i <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GetAggrResult(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(BuildComplexSum(<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> complexNumbers ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>)</code> </pre></li></ol><br>  Apa yang patut diperhatikan dalam semua sistem ini? <br><br><ul><li>  Dengan satu atau lain cara, Anda perlu membuat beberapa objek dalam database.  Baik itu AGREGAT atau JENIS.  Minimal, diperlukan hak yang sesuai.  <i>Dan hanya ingin menambahkan beberapa angka pada lututnya.</i> <br></li><li>  Anda mungkin harus menulis sesuatu dalam bahasa lain, apakah itu C, C # atau Java. <br>  Untuk mengintegrasikan apa yang ditulis ke dalam sistem, sekali lagi, diperlukan hak.  <i>Tapi yang saya inginkan ...</i> <br></li><li>  Inisialisasi kesulitan.  Misalkan Anda ingin membaca histogram dengan ukuran keranjang yang berbeda.  Tampaknya lebih mudah - kami akan menunjukkan INITCOND yang diinginkan ketika mendeklarasikan agregat (PostgreSQL) dan seluruh bisnis.  Tetapi kemudian untuk setiap ukuran keranjang Anda akan membutuhkan agregat Anda sendiri, dan untuk ini lagi diperlukan hak. <br><br>  Di sini Anda dapat menggunakan trik kotor dan menyelipkan prosesor gabungan dari garis inisialisasi (maju) dan data, membangun konteks bukan di konstruktor, tetapi ketika baris pertama diterima. <br></li><li>  Namun demikian, bahkan dengan batasan yang dijelaskan, agregat khusus memungkinkan Anda menghitung apa pun. <br></li><li>  Adalah penting bahwa <u>agregat dapat diparalelkan</u> , setidaknya PostgreSQL, dan Oracle (Enterprise Edition) dapat melakukan ini.  Untuk ini, kebenaran harus belajar bagaimana membuat serial / deserialize negara perantara dan juga membekukan mereka yang diterima dari aliran yang berbeda. </li></ul><br><h4>  Fungsi jendela </h4><br>  Fungsi jendela muncul dalam standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SQL: 2003</a> .  Saat ini, mereka didukung oleh semua sistem di atas.  Intinya, fungsi jendela adalah perpanjangan dari kerja dengan unit.  Dan, tentu saja, fungsi agregat kustom juga berfungsi dalam konteks berjendela. <br><br>  Perpanjangannya adalah ini.  Dan sebelum SQL: 2003, fungsi agregat bekerja di jendela tertentu, yang merupakan seluruh resultset atau bagiannya, yang sesuai dengan kombinasi nilai bidang dari ekspresi GROUP BY.  Pengguna sekarang memiliki kebebasan dalam memanipulasi jendela ini. <br><br>  Perbedaannya adalah bahwa nilai-nilai yang dihitung menggunakan windows ditambahkan ke output dalam kolom terpisah, dan tidak memerlukan seluruh aliran untuk runtuh menggunakan fungsi agregat.  Jadi dalam satu permintaan, Anda dapat menggunakan beberapa agregat jendela masing-masing dalam konteksnya sendiri (jendela).  Mungkin ada beberapa fungsi agregat sebelumnya, tetapi mereka semua bekerja dalam satu jendela. <br><br>  Stroke besar <br><br><ul><li>  <b>Over ()</b> <br>  jendela adalah seluruh resultset.  Katakanlah kueri ' <i>pilih hitungan (1) dari Sampel</i> ' mengembalikan 169. Dalam kasus ini, menjalankan ' <i>pilih menghitung (1) lebih dari () dari Sampel</i> ', kita mendapatkan kolom yang ditulis 169 kali 169 kali. </li><li>  <b>LEBIH DARI (PARTISI DENGAN)</b> <br>  ini adalah analog dari GROUP BY, untuk setiap kombinasi nilai, sebuah jendela dibuat di mana fungsi agregat dilakukan.  Katakanlah dalam tabel Sampel satu kolom bilangan bulat adalah val, data adalah angka dari 1 hingga 169. <br>  Kemudian permintaan ' <i>pilih hitungan (1) lebih (partisi dengan (12 + val) / 13) dari Sampel</i> ' akan mengembalikan kolom di mana nilai 13 ditulis 169 kali. <br></li><li>  <b>OVER (ORDER BY)</b> <br>  dapat dikombinasikan dengan PARTITION BY, memungkinkan Anda untuk secara dinamis mengubah ukuran jendela selama kursor, dalam hal ini, jendela memanjang dari awal grup ke posisi kursor saat ini.  Akibatnya, untuk grup, ternyata bukan nilai yang sama di kolom agregat, tetapi nilai sendiri.  Nyaman untuk menghitung jumlah kumulatif.  Hasil kueri <br>  <i>'pilih penjumlahan (val) dari (urutan dengan val) dari Sampel</i> ' akan menjadi kolom di mana elemen ke-n akan berisi jumlah bilangan asli dari 1 ke n. </li><li>  <b>LEBIH (ROWS)</b> <br>  memungkinkan Anda untuk menentukan bingkai jendela, mulai dari posisi kursor atau awal / akhir kisaran ORDER BY. <br><br>  Sebagai contoh, ' <i>... ROWS 1 PRECEDING ...</i> ' berarti bahwa jendela terdiri dari baris saat ini dan 1 sebelumnya.  A ' <i>... ROWS ANTARA 1 BERIKUT DAN 2 MENGIKUTI ...</i> ' - jendela terdiri dari dua baris segera setelah kursor. <br><br>  CURRENT ROW dalam mode ini menunjukkan posisi kursor saat ini.  Misalnya, ' <i>BARIS ANTARA BARIS SAAT INI DAN BERIKUTNYA BERIKUT</i> ' berarti dari garis saat ini ke akhir rentang. </li><li>  <b>LEBIH (RANGE)</b> <br>  berbeda dari ROWS dalam ROW SAAT ini di sini berarti sebagai awal jendela awal rentang dari ORDER BY, dan sebagai akhir jendela - baris terakhir dari rentang ORDER BY. </li></ul><br>  Sintaks untuk menggunakan fungsi jendela pada sistem yang berbeda sedikit berbeda. <br><br>  Untuk meringkas hal di atas, masih ada perasaan yang agak menyakitkan bahwa para pengembang, setelah menganalisis pembangunan berbagai laporan dalam SQL, menyoroti kasus-kasus yang paling umum dan secara konkret mereka dalam sintaksis. <br><br><h4>  Fungsi Pengembalian Rekam </h4><br>  Dalam output fungsi agregat / jendela, setiap baris yang dihasilkan sesuai dengan rentang baris tertentu dari aliran data yang masuk.  Dalam hidup, korespondensi semacam itu tidak selalu ada. <br><br>  Sebagai contoh, diperlukan untuk membangun matriks kovarians 10X10 (untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini,</a> dibutuhkan 672X672).  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> dilakukan dalam satu pass, untuk ini kami menjalankan fungsi agregat yang ditulis oleh kami dengan 10 parameter numerik.  Hasil karyanya adalah recordset 10 baris dari 10 nilai, setiap elemen matriks mengacu pada semua baris aliran input (tidak peduli berapa banyak ada). <br><br>  Kita dapat mengatakan - jadi apa, di PostgreSQl, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat</a> mengembalikan array dua dimensi dari suatu fungsi (Contoh: 'ARRAY [[1,2], [3,4]')).  Atau hanya membuat serialisasi matriks menjadi satu baris. <br><br>  Itu bagus, tetapi tidak selalu memungkinkan untuk menjaga ukuran hasil dalam kerangka kerja yang dapat diterima untuk pendekatan semacam itu. <br><br><div class="spoiler">  <b class="spoiler_title">Penyimpangan liris</b> <div class="spoiler_text">  Misalnya, tugas kita adalah menggeneralisasi geometri. <br><br>  Ukuran geometri tidak diketahui oleh kita, mungkin juga garis pantai Eurasia dari puluhan juta titik.  Atau sebaliknya, ada geometri yang sangat kasar, Anda perlu menghaluskannya dengan splines.  Saya ingin meneruskan parameter ke agregat dan mendapatkan aliran data, bukan vektor atau string. <br><br>  Anda dapat, tentu saja, mengatakan bahwa masalahnya tidak masuk akal, bahwa tidak ada yang melakukannya, geometri dalam DBMS disimpan dengan cara khusus, ada program khusus untuk memproses geometri, ... <br><br>  Faktanya, cukup nyaman untuk menyimpan geometri dalam tabel reguler secara searah, jika hanya karena, dengan memindahkan satu titik, tidak perlu menulis ulang seluruh gumpalan.  Sebelum data spasial bocor di mana-mana di DBMS, itu, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ArcSDE</a> . <br><br>  Segera setelah ukuran rata-rata gumpalan geometri melebihi ukuran halaman, menjadi lebih menguntungkan untuk bekerja secara langsung dengan poin.  Jika ada peluang fisik untuk beroperasi dengan aliran poin, mungkin roda sejarah akan berubah lagi. <br></div></div><br>  Matriks kovarians masih bukan contoh yang sangat baik dari sinkronisasi antara aliran input dan output, karena seluruh hasil diperoleh secara bersamaan di akhir.  Misalkan Anda ingin memproses / mengompres aliran data sumber.  Pada saat bersamaan <br><br><ul><li>  ada banyak data, mereka berada di "tumpukan" tanpa indeks, sebenarnya mereka hanya 'cepat' ditulis ke disk </li><li>  Anda perlu mengurutkannya ke dalam kategori yang berbeda, yang relatif sedikit </li><li>  dalam kategori, rata-rata dari interval waktu, hanya menyimpan rata-rata, jumlah pengukuran dan varians </li><li>  semua ini perlu dilakukan dengan cepat </li></ul><br>  Apa saja pilihannya? <br><br><ol><li>  Dalam SQL, pengurutan berdasarkan interval waktu / kategori diperlukan, yang bertentangan dengan poin terakhir. </li><li>  Jika data sudah diurutkan berdasarkan waktu (yang, pada kenyataannya, tidak dijamin), dan akan dimungkinkan untuk menyampaikan fakta ini ke prosesor SQL, Anda dapat melakukannya dengan fungsi jendela dan satu lintasan. </li><li>  Tulis aplikasi terpisah yang akan melakukan semua ini.  Dalam PL / SQL atau, lebih mungkin, mengingat bahwa ada banyak data, di C / C ++. </li><li>  Fungsi yang mengembalikan catatan.  Mungkin mereka bisa membantu kita. </li></ol><br>  Lebih detail tentang A.4.  Ada dua mekanisme untuk ini - tabel sementara dan fungsi pipa. <br><br><ol><li>  Fungsi konveyor. <br>  Mekanisme ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">muncul</a> di Oracle (mulai dari 9i, 2001) dan memungkinkan fungsi yang mengembalikan recordset bukan untuk mengumpulkan data, tetapi menghitungnya sesuai kebutuhan (secara analogi dengan sinkronisasi stdout dan stdin dari dua proses yang terhubung melalui pipa). <br>  Yaitu  Hasil fungsi-fungsi pipelined mungkin mulai diproses sebelum keluar dari fungsi ini.  Untuk ini, cukup mengatakan dalam definisi fungsi <br><br><pre> <code class="sql hljs"> FUNCTION f_trans(p refcur_t) RETURN outrecset PIPELINED IS …</code> </pre> <br>  dan daftarkan garis hasil di badan <br><br><pre> <code class="sql hljs">LOOP … out_rec.var_char1 := in_rec.email; out_rec.var_char2 := in_rec.phone_number; PIPE ROW(out_rec); … <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br>  Hasilnya, kita punya <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>( refcur_pkg.f_trans( <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">60</span></span>)));</code> </pre><br>  Agregat khusus tidak diperlukan saat ada fungsi pipa. <br><br>  Bravo, Oracle! <br><br>  Belum lama ini (2014), fungsi pipa juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">muncul</a> di DB2 (IBM i 7.1 TR9, i 7.2 TR1). </li><li>  Meja sementara. <br>  Untuk memulainya, tampaknya baik MS SQL maupun PostgreSQL tidak dapat mengembalikan kursor dari fungsi agregat. <br><br>  Baiklah, mari, dengan analogi dengan fungsi-fungsi pipa, dapatkan kursor sebagai parameter, proses itu, tambahkan ke tabel sementara dan kembalikan kursor ke sana. <br><br>  Namun, dalam MS SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mungkin</a> untuk melewatkan kursor ke prosedur tersimpan oleh parameter, hanya mungkin untuk membuat kursor dalam prosedur dan mengembalikan parameter melalui output.  Hal yang sama dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikatakan untuk</a> PostgreSQL. <br><br>  Baiklah, buka saja kursor, kurangi, proses nilainya, hitung hasilnya, tambahkan ke tabel sementara dan render kursornya. <br><br>  Atau bahkan lebih sederhana, kami menambahkan hasil kueri ke satu tabel sementara, memprosesnya dan mengembalikan hasilnya melalui kursor ke tabel sementara lainnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang</a> bisa saya katakan.  Pertama, dan yang paling penting, membaca data melalui kursor lebih lambat daripada memproses dalam aliran.  Kedua, mengapa Anda memerlukan prosesor SQL sama sekali, mari kita baca tabel dengan kursor, buat tabel sementara dengan tangan kami, tulis logika join di loop ... Ini seperti insert assembler di C / C ++, kadang-kadang Anda bisa memperlakukan diri sendiri, tetapi lebih baik tidak menyalahgunakannya. </li></ol><br>  Jadi, setelah mempertimbangkan pertanyaan dengan fungsi mengembalikan recordset, kami sampai pada kesimpulan: <br><br><ul><li>  Agregat khusus tidak akan sangat membantu kami di sini. </li><li>  Bagaimanapun, Anda perlu membuat beberapa objek dalam database.  Baik itu fungsi atau tabel sementara.  Minimal, diperlukan hak yang sesuai.  <i>Dan hanya ingin memproses beberapa angka.</i> <br></li><li>  Namun demikian, bahkan dengan batasan yang dijelaskan, terkadang tidak terlalu elegan, tetapi dengan metode ini Anda dapat menyelesaikan masalah. </li></ul><br><h4>  Apa lagi </h4><br>  Padahal, jika kita sudah memiliki kesempatan untuk menyelesaikan masalah, apa lagi yang dibutuhkan penulis? <br>  Sebenarnya, mesin Turing juga dapat menghitung apa saja, hanya saja tidak terlalu cepat dan tidak terlalu nyaman. <br><br>  Kami merumuskan persyaratan sebagai berikut: <br><br><ol><li>  itu harus operator relasional yang dapat digunakan setara dengan yang lainnya (seleksi, proyeksi, ...) </li><li>  itu harus menjadi operator yang mengubah satu aliran data menjadi yang lain </li><li>  tidak ada sinkronisasi antara aliran input dan output </li><li>  deklarasi operator mendefinisikan struktur aliran output </li><li>  operator memiliki kemampuan untuk menginisialisasi secara dinamis (dalam bentuk fungsi, lebih tepatnya tubuhnya, ditentukan langsung dalam definisi operator) </li><li>  serta destruktor dalam bentuk fungsi (...) </li><li>  serta fungsi (...) yang dipanggil setiap kali baris baru diterima dari aliran input </li><li>  operator memiliki konteks eksekusi - seperangkat variabel dan / atau koleksi yang ditentukan pengguna yang diperlukan untuk pekerjaan </li><li>  untuk menjalankan operator ini, Anda tidak perlu membuat objek database, Anda tidak perlu hak tambahan </li><li>  segala sesuatu yang diperlukan untuk pekerjaan didefinisikan di satu tempat, dalam satu bahasa </li></ol><br>  Sekali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">waktu,</a> penulis membuat operator yang memperluas prosesor buatan sendiri dari subset <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TTM / Tutorial D.</a>  Sekarang ide yang sama sedang diusulkan untuk SQL. <br><br>  Perlu peringatan, di sini SQL berakhir dan improvisasi dimulai.  Sintaksinya dibiarkan seperti aslinya, pada akhirnya, gula sintaksis bisa apa saja, tidak mengubah esensinya. <br><br>  Jadi, operator <b>mengunyah</b> terdiri dari <br><br><ol><li>  Header yang berisi daftar bidang output dan tipenya. <br>  Setiap bidang output (dan input) adalah variabel lokal. <br>  Contoh: <i>"chew {" var1 "float," var2 "integer}"</i> berarti bahwa akan ada dua kolom dalam aliran output - titik mengambang dan bilangan bulat </li><li>  Tubuh - daftar panggilan balik untuk acara, saat ini - awal aliran, akhir aliran, baris.  Dengan sintaks, fungsinya dekat dengan PL / SQL.  Fungsi yang telah ditetapkan <i>__interrupt</i> () adalah analog dari PIPE, ia mengambil nilai dari variabel yang sesuai dengan kolom output dan menempatkannya dalam aliran output.  Jika buffer aliran output meluap, pekerjaan pawang akan berhenti dan pekerjaan sisi penerima aliran akan dimulai. <br>  Mis: “hook“ init ”{var1: = 0;  var2: = -1;  } " </li></ol><br>  Cara termudah untuk menunjukkan contoh. <br><br><ul><li>  Analog dari fungsi agregat SUM. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples' -- select * from samples chew {“sum(val)” float} --    hook “init” { “sum(val)” := 0; --      } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; end if; } hook “finit” { call __interrupt(); --  PIPE }</span></span></code> </pre><br>  Terlihat tebal, tapi itu hanya contoh, <br>  tidak perlu menulis program C untuk menambahkan beberapa angka. </li><li>  SUM + AVG <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val), avg(val) from samples' -- select * from samples chew { “sum(val)” float, “avg(val)” float --       } hook “init” { “sum(val)” := 0; “avg(val)” := 0; var num integer; num := 0; --    ,       } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then “avg(val)” := “sum(val)” / num; end if; call __interrupt(); }</span></span></code> </pre><br>  Di sini kita menarik perhatian pada fakta bahwa penjumlahan hanya terjadi satu kali. </li><li>  SUM + GROUP BY <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples group by type' -- select * from --     ( samples val, type from samples order by type ) chew { “sum(val)” float } hook “init” { “sum(val)” := 0; var gtype integer; gtype := NULL; var num integer; --   num := 0; } hook “row” { if (gtype &lt;&gt; “type”) then __interrupt(); “gtype” := type; "sum(val)" := 0; num := 0; end if; if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then call __interrupt(); end if; }</span></span></code> </pre></li><li>  ROW_NUMBER () OVER () <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- select row_number() over() as num, * from samples -- select * from samples chew { “num” integer, * --        --   '* except val1, ...valX',   TTM } hook “init” { num := 0; } hook “row” { num := num + 1; call __interrupt(); }</span></span></code> </pre></li></ul><br>  Apakah mungkin untuk memberikan contoh di mana pendekatan ini memberikan hasil yang secara fundamental tidak dapat dicapai dengan cara yang biasa?  Kami memilikinya. <br><br>  Kadang-kadang terjadi bahwa data hampir diurutkan.  Mereka bahkan mungkin sepenuhnya diurutkan, tetapi tidak diketahui pasti. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan dalam contoh di atas (kompresi aliran data) data berasal dari sumber yang berbeda dan karena berbagai alasan dapat sedikit dicampur.</font></font> Yaitu        T1            T2   T1 &lt; T2. <br><br>    ,    T1  T2     () ,    ( )  . <br><br> ,   ,             ,        ,         . <br><br>     . <br><br>   ,    . <br><br>      . <br><br>       ,       . <br>        ,   . <br><br>    SQL-           . <br><br>   lambda-     SQL-   ,     ,    . <br><br><h4>  Kesimpulan </h4><br>        . <br><br>       PL/SQL. <br><br>             . <br><br>   ,         , GROUP BY. <br><br> ,      ,    SQL-   . <br><br>   ,  ,                . <br><br> <b>PS:</b>        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435120/">https://habr.com/ru/post/id435120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435106/index.html">Sekali lagi tentang passport.js</a></li>
<li><a href="../id435108/index.html">Menggunakan Prolog</a></li>
<li><a href="../id435112/index.html">Wawancara Perusahaan</a></li>
<li><a href="../id435114/index.html">Data pegas jpa</a></li>
<li><a href="../id435118/index.html">Save File Me - layanan cadangan gratis dengan enkripsi sisi klien</a></li>
<li><a href="../id435122/index.html">Bagaimana nyala api diimplementasikan dalam Doom di Playstation</a></li>
<li><a href="../id435124/index.html">Karya konstruksi kolom dunia: transformator monitor studio dengan jumlah band yang bervariasi</a></li>
<li><a href="../id435126/index.html">Pengalaman dalam mengatur dan melakukan konferensi perusahaan untuk analis</a></li>
<li><a href="../id435128/index.html">Pi-Sonos: hobi yang tidak terkendali</a></li>
<li><a href="../id435132/index.html">Pengembara: masalah dan solusi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>