<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐏 👎🏾 👇🏻 从内到外的皮林特。 他是怎么做到的 👨‍🍳 👶 🚵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="编写出色代码的各种助手就在我们周围，包括linter，typechekery，发现漏洞的实用程序。 我们已经习惯并使用它，而没有像“黑匣子”这样的细节。 例如，很少有人了解Pylint的原理，而Pylint是用于优化和改进Python代码的必不可少的工具之一。 

 但是马克西姆·马扎夫（Maxim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从内到外的皮林特。 他是怎么做到的</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433474/"> 编写出色代码的各种助手就在我们周围，包括linter，typechekery，发现漏洞的实用程序。 我们已经习惯并使用它，而没有像“黑匣子”这样的细节。 例如，很少有人了解Pylint的原理，而Pylint是用于优化和改进Python代码的必不可少的工具之一。 <br><br> 但是<strong>马克西姆·马扎夫（Maxim Mazaev）</strong>知道理解他的工具有多么重要，他在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莫斯科Python Conf ++上</a>告诉我们。 他通过实际例子展示了Pylint内部设备及其插件的知识如何帮助减少代码审查时间，提高代码质量并总体上提高开发效率。 以下是解密指令。 <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2> 我们为什么需要Pylint？ <br></h2><br> 如果您已经使用过它，那么可能会出现一个问题：“为什么知道Pylint内在是什么，这种知识如何提供帮助？” <br><br> 通常，开发人员编写代码，启动lint，接收有关需要改进的消息，如何使代码更漂亮以及进行建议的更改的消息。 现在，该代码更易于阅读，不会为同事展示感到羞耻。 <br><br> 长期以来，他们与Cyan Institute中的Pylint的工作方式完全相同，只是增加了一点：他们更改了配置，删除了不必要的规则并增加了最大字符串长度。 <br><br> 但是在某些时候，他们遇到了一个问题，对此我不得不深入研究Pylint并弄清楚它是如何工作的。 这个问题是什么以及如何解决，请继续阅读。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>关于演讲者：</strong> Maxim Mazaev（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">反斜杠</a> ），已发展5年，在CIAN工作。 深入学习Python，异步和函数式编程。 <br><br><h2> 关于青色 <br></h2><br> 大多数人认为CIAN是一家拥有经纪人的房地产代理商，当他们发现我们拥有程序员而不是房地产经纪人时，他们感到非常惊讶。 <br><br> 我们是一家技术公司，没有经纪人，但是有很多程序员。 <br><br><ul><li> 每天有100万唯一身份用户。 </li><li> 莫斯科和圣彼得堡最大的房地产买卖公告栏。 在2018年，他们进入了联邦级别，并在整个俄罗斯工作。 </li><li> 开发团队有将近100个人，其中每天有30个人编写Python代码。 </li></ul><br> 每天，成千上万行新代码投入生产。 该代码的要求非常简单： <br><br><ul><li> 体面的质量守则。 </li><li> 风格上的同质性。 所有开发人员都应编写近似相似的代码，在存储库中不要使用“ vinaigrette”。 </li></ul><br> 为此，当然，您需要进行代码审查。 <br><br><h2> 代码审查 <br></h2><br>  CIAN中的代码审查分为两个阶段： <br><br><ol><li> 第一阶段是<strong>自动化的</strong> 。 由于我们使用微服务，因此Jenkins机器人可以运行测试，运行Pylint并检查微服务之间API的一致性。 如果在此阶段测试失败或短绒显示出一些奇怪的情况，则这是拒绝请求请求并发送代码进行修订的机会。 <br></li><li> 如果第一阶段成功，那么第二阶段将获得<strong>两个</strong> <strong>开发人员的</strong>批准。 他们可以评估代码在业务逻辑方面的表现，批准请求请求或返回代码以进行修订。 <br></li></ol><br><h3><br> 代码审查问题 <br></h3><br> 由于以下原因，拉取请求可能无法通过代码审查： <br><br><ul><li> 当开发人员无效或错误地解决了问题时，业务逻辑中的错误； </li><li> 代码样式问题。 </li></ul><br> 如果短绒检查代码，样式问题可能是什么？ <br><br> 每个用Python编写的人都知道有一个编写<strong>PEP-8</strong>代码的指南。 像任何标准一样，PEP-8非常通用，对于我们（作为开发人员）来说，这还不够。 我想在某些地方指定标准，在其他地方扩展。 <br><br> 因此，我们就代码的外观和工作方式制定了内部安排，并将其称为<strong>“ Decline Cian Proposals”</strong> 。 <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  “拒绝Cian提案”-一组规则，现在大约有15条。每条规则都是拒绝请求并将其发送以进行修订的基础。 <br><br><h3> 是什么阻碍了高效的代码审查？ <br></h3><br><blockquote> 我们的内部规则存在一个问题-小子不了解这些规则，如果他知道，那将很奇怪-它们是内部的。 <br></blockquote> 执行任务的开发人员必须始终记住并牢记规则。 如果他忘记了其中一条规则，则在代码审阅过程中，审阅者会指出问题所在，任务将进行修订，并且任务的发布时间将增加。 完成并纠正错误后，测试人员需要记住任务中所包含的内容，以切换上下文。 <br><br> 这对于开发人员和审阅者都造成了问题。 结果，严重降低了代码审查的速度。 测试人员没有分析代码的逻辑，而是开始分析视觉样式，即，他​​们执行lint的工作：他们逐行扫描代码，并以导入格式查找缩进中的不一致之处。 <br><br> 我们想摆脱这个问题。 <br><br><h2> 但是不要写信给我们您的棉绒呢？ <br></h2><br> 看来该问题将通过一种工具解决，该工具将了解所有内部协议并能够检查其实现代码。 所以我们需要自己的短绒棉呢？ <br><br> 不完全是 这个想法很愚蠢，因为我们已经使用了Pylint。 这是一个方便的linter，受到开发人员的喜欢，并内置于所有流程中：它在Jenkins中运行，生成完全满意的精美报告，并以注释的形式提出请求。 一切都很好， <strong>不需要第二个棉绒</strong> 。 <br><br> 那么，如果我们不想编写自己的Linter，该如何解决问题呢？ <br><br><h2> 编写一个Pylint插件 <br></h2><br> 您可以为Pylint编写插件，它们称为检查器。 根据每个内部规则，您可以编写自己的检查器，该检查器将对其进行检查。 <br><br> 考虑这种检查器的两个例子。 <br><br><h3> 示例1 <br></h3><br> 在某个时候，事实证明该代码包含许多“ TODO”形式的注释-承诺重构，删除不必要的代码或精美地重写它，但不是现在，而是以后。 这样的评论有问题-他们绝对不强迫您做任何事情。 <br><br><h4> 问题 <br></h4><br> 开发人员写了一个诺言，呼气而安心地去做下一个任务。 <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br> 总结： <br><br><ul><li> 带有诺言的评论多年来悬而未决； </li><li> 代码乱七八糟； </li><li> 技术债务已经积累了多年。 </li></ul><br> 例如，一个三年前的开发人员曾承诺在成功发布后删除某些内容，但是发布是在三年后发生的吗？ 也许是。 在这种情况下，我应该删除代码吗？ 这是一个大问题，但很可能不是。 <br><br><h4> 解决方案：为Pylint编写检查程序 <br></h4><br> 您不能禁止开发人员写这样的评论，但是可以使他们做额外的工作：在跟踪器中创建任务以最终兑现承诺。 那我们绝对不会忘记她的。 <br><br> 我们需要找到TODO形式的所有注释，并确保每个注释都具有指向Jira中任务的链接。 写吧 <br><br> 什么是Pylint的检查器？ 这是一个从检查器的基类继承并实现特定接口的类。 <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br> 在我们的例子中，这是<strong>IRawChecker-</strong>所谓的“原始”检查器。 <br><br> 原始检查程序会遍历文件的各行，并且可以对某行执行某些操作。 在我们的例子中，检查器将在每一行中查找类似于注释和指向任务的链接的内容。 <br><br> 对于检查器，您需要确定它将发出的消息列表： <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br> 该消息有： <br><br><ul><li> 描述简短而冗长； </li><li> 检查代码和一个简短的助记符名称，用于确定它是哪种消息。 </li></ul><br> 消息代码的格式为“ C1234”，其中： <br><br><ul><li> 对于不同类型的消息，首字母已明确标准化： <strong>[C]</strong>发明；  <strong>[W]</strong>警告；  <strong>[E]</strong>哟；  <strong>[F]</strong> atal;  <strong>[R]</strong>分解。 多亏了这封信，该报告立即显示了正在发生的事情：提醒人们必须紧急解决的协议或致命问题。 </li><li>  Pylint独有的4个随机数。 </li></ul><br> 如果不需要检查，则需要使用该代码来禁用检查。 您可以编写Pylint：disable和简短的字母数字代码或助记符名称： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  Pylint的作者建议放弃字母数字代码并使用助记符，因为它更直观。 <br><br> 下一步是定义一个名为<strong>process_module</strong>的方法。 <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br> 这个名字很重要。 该方法应以这种方式调用，因为Pylint将随后对其进行调用。 <br><br> 将<strong>节点</strong>参数传递给模块。 在这种情况下，它的类型或类型无关紧要，记住节点具有逐行返回文件的<strong>流</strong>方法是很重要的。 <br><br> 您可以浏览文件，并针对每一行检查注释和指向任务的链接。 如果有评论，但没有链接，则使用检查代码和行号以<strong>“ issue-code-in-todo”</strong>形式<strong>发出</strong>警告。 该算法非常简单。 <br><br> 注册检查器，以便Pylint知道它。 这是通过<strong>register</strong>函数完成的： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  Pylint的一个实例进入该函数。 </li><li> 它调用register_checker方法。 </li><li> 我们将检查器传递给该方法。 </li></ul><br>  <strong>重要的一点：</strong>检查器模块必须位于PYTHONPATH中，以便Pylint以后可以导入它。 <br><br> 测试文件将对注册的检查器进行检查，该文件带有不带任务链接的注释。 <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker …</span></span></code> </pre><br> 对于测试，运行Pylint，将模块传递给它，使用<strong>load-plugins</strong>参数传递检查器，然后在linter内部运行两个阶段。 <br><br><h4> 阶段1.插件初始化 <br></h4><br><ul><li> 所有带有插件的模块均已导入。  Pylint具有内部和外部检查器。 它们都汇合在一起并被进口。 </li><li> 我们注册<strong>-module.register（自己）</strong> 。 对于每个检查器，都会调用register函数，并在其中传递Pylint实例。 </li><li> 执行检查：参数的有效性，消息，选项和报告是否以正确的格式存在。 </li></ul><br><h4> 阶段2。解析棋盘池 <br></h4><br> 在阶段1之后，将保留不同类型的检查器的完整列表： <br><br><ul><li>  AST检查器； </li><li> 原始检查器； </li><li> 令牌检查器。 </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br> 从列表中，我们选择与原始检查器接口相关的那些：我们查看哪些检查器实现了IRawChecker接口并将它们自己带走。 <br><br> 对于每个选定的检查器，调用<strong>checker.process_module（模块）</strong>方法，然后运行检查。 <br><br><h4> 结果 <br></h4><br> 再次在测试文件上运行检查器： <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br> 将会出现一条消息，指出有关于TODO的评论，没有指向任务的链接。 <br><br> 问题已解决，现在在代码审查过程中，开发人员无需用眼睛扫描代码，查找注释，向代码作者发出提醒，即已达成协议，建议您保留链接。 一切都会自动发生，并且代码审查会更快。 <br><br><h3> 例2。关键字参数 <br></h3><br> 有些函数带有位置参数。 如果有很多参数，那么当他们调用函数时，不清楚参数在哪里以及为什么需要它。 <br><br><h4> 问题 <br></h4><br> 例如，我们有一个函数： <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br> 该代码包含<strong>sale</strong>和<strong>True，</strong>目前尚不清楚它们的含义。 如果仅使用命名参数来调用其中包含许多参数的函数，则更加方便： <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br> 这是一个很好的代码，其中可以立即清楚地知道哪个参数在哪里，并且我们不会混淆它们的顺序。 让我们尝试编写一个检查此类情况的检查器。 <br><br> 在这种情况下，上一个示例中使用的“原始”检查器很难编写。 您可以添加超复杂的正则表达式，但是此类代码很难阅读。  Pylint使得基于<strong>AST</strong>抽象语法树编写另一种类型的检查器成为可能，我们将使用它。 <br><br><h4> 关于AST的歌词 <br></h4><br>  AST或抽象语法树是代码的树表示形式，其中顶点是操作数，叶子是运算符。 <br><br> 例如，将具有一个位置参数和两个命名参数的函数调用转换为抽象树： <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br> 有一个类型为<strong>Call</strong>的顶点，它具有： <br><br><ul><li> 函数属性称为func； </li><li> 位置参数args的列表，其中有一个类型为Const且值为112的节点； </li><li> 命名参数关键字列表。 </li></ul><br> 在这种情况下的任务： <br><br><ul><li> 在模块中找到所有类型为Call（函数调用）的节点。 </li><li> 计算函数接受的参数总数。 </li><li> 如果有两个以上的参数，请确保节点中没有位置参数。 </li><li> 如果有位置参数，则显示警告。 </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ … ]))]</code> </pre><br> 从Pylint的角度来看，基于AST的检查器是一个继承自基本检查器类并实现<strong>IAstroidChecker</strong>接口的类： <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br> 与第一个示例一样，检查列表描述，消息代码，短助记符名称在消息列表中指示： <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br> 下一步是定义<strong>visit_call</strong>方法： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> …</span></span></code> </pre><br> 该方法不必被称为。 其中最重要的是visit_前缀，然后是我们感兴趣的顶点的名称，并带有一个小写字母。 <br><br><ul><li>  AST解析器遍历树，并针对每个顶点查看检查器是否已定义visit_ &lt;Name&gt;接口。 </li><li> 如果是这样，则调用它。 </li><li> 递归地遍历她的所有孩子。 </li><li> 离开节点时，它将调用leave_ &lt;Name&gt;方法。 </li></ul><br> 在此示例中，visit_call方法将接收一个Call-type节点作为输入，并查看它是否具有两个以上的参数，以及是否存在位置参数以发出警告并将代码传递给节点本身。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br> 我们像上一个示例一样注册检查程序：我们转移Pylint实例，调用register_checker，传递检查程序本身并启动它。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br> 这是一个测试函数调用的示例，其中有3个参数，并且其中只有一个被命名： <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker …</code> </pre><br> 从我们的角度来看，此函数可能被错误地调用。 启动Pylint。 <br><br> 如上例所示，插件初始化阶段1完全重复。 <br><br><h4> 阶段2。AST的模块解析 <br></h4><br> 该代码被解析为AST树。 该分析由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Astroid库</a>执行。 <br><br><h4> 为什么是Astroid而不是AST（stdlib） <br></h4><br>  Astroid内部不使用标准的Python AST模块，而是使用<strong>typed_ast类型的AST解析器</strong> ，其特征在于它支持PEP 484 <strong>类型提示</strong> 。 有趣的是，AST中存在相同的错误，并且可以并行修复。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br> 以前，Astroid使用标准的AST模块，在该模块中可能会遇到使用第二个Python注释中定义的taiphint的问题。 如果通过Pylint检查此代码，则在一定程度上它会在未使用的导入时起誓，因为导入的Entity类仅在注释中存在。 <br><br><blockquote> 在某个时候，Guido Van Rossum在GitHub上访问了Astroid并说：“伙计，您有Pylint，在这种情况下发誓，我们有一个支持所有这些的类型化AST解析器。 成为朋友吧！” <br></blockquote><br> 工作已经开始沸腾了！  2年过去了，这个春天Pylint切换到了AST解析器类型，并不再对此发誓。  taiphint的进口不再标记为未使用。 <br><br>  Astroid使用AST解析器将代码解析为树，然后在构建代码时做一些有趣的事情。 例如，如果您使用<strong>import *</strong> ，那么它将导入所有带有星号的内容，并将其添加到本地，以防止未使用的导入产生错误。 <br><br> 当所有属性都动态生成时，在某些基于元类的复杂模型的情况下，可以使用<strong>Transform插件</strong> 。 在这种情况下，Astroid很难理解其含义。 在检查时，Pylint会发誓，模型在访问时没有这样的属性，使用Transform插件可以解决问题： <br><br><ul><li> 帮助Astroid修改抽象树并了解Python的动态特性。 </li><li> 用有用的信息补充AST。 </li></ul><br> 一个典型的例子是<strong>pylint-django</strong> 。 当使用复杂的django模型时，短绒棉通常会以未知的属性发誓。  Pylint-django只是解决了这个问题。 <br><br><h4> 阶段3.解析检查池 <br></h4><br> 我们返回检查器。 我们再次有一个检查器列表，从中我们可以找到实现AST检查器接口的检查器。 <br><br><h4> 阶段4.按节点类型解析检查器 <br></h4><br> 接下来，我们为每个检查器找到方法，它们可以是两种类型： <br><br><ul><li>  visit_ &lt;节点名称&gt; </li><li> 级别&lt;节点名称&gt;。 </li></ul><br> 知道在树中行走时需要为节点调用哪些节点会很高兴。 因此，他们理解字典，其中的键是节点的名称，值是对访问此节点的事实感兴趣的那些检查程序的列表。 <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br> 与离开方法相同：节点名称形式的键，对从该节点退出的事实感兴趣的检查者列表。 <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br> 启动Pylint。 它显示警告，我们有一个函数，其中有两个以上的参数，并且其中有一个位置参数： <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br> 问题已解决。 现在，代码审查程序员无需读取函数的参数； lint会为他们完成此工作。  <strong>我们节省了时间</strong> ， <strong>节省了</strong>代码审查的<strong>时间</strong> ，并使任务在生产中更快地进行。 <br><br><h2> 并编写测试？ <br></h2><br>  Pylint允许您对检查程序进行单元测试，这非常简单。 从<strong>linter</strong>的角度来看，测试检查器看起来像是从抽象<strong>CheckerTestCase</strong>继承的类。 有必要指出正在检查中的检查器。 <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br> 步骤1.我们从正在检查的代码部分中创建一个测试AST节点。 <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br> 步骤2.验证进入节点的检查程序是否抛出或未抛出相应的消息： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2> 令牌检查器 <br></h2><br> 还有另一种检查器，称为<strong>TokenChecker</strong> 。 它根据词法分析器的原理工作。  Python有一个<strong>标记化</strong>模块，该模块完成词法扫描程序的工作并将代码分解为标记列表。 它可能看起来像这样： <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br> 变量名称，函数名称和关键字成为NAME类型的令牌，而分隔符，方括号和冒号成为OP类型的令牌。 此外，还有用于缩进，换行和反向转换的单独标记。 <br><br>  Pylint如何与TokenChecker一起使用： <br><br><ul><li> 被测模块已标记。 </li><li> 大量的令牌被传递给实现ITokenChecker的所有检查器，并且<strong>调用process_tokens</strong> （令牌）方法。 </li></ul><br> 我们尚未找到TokenChecker的用法，但是Pylint使用了一些示例： <br><br><ul><li>  <strong>拼写检查</strong> 。 例如，您可以使用text类型的所有标记，查看词汇素养，从停用词列表中检查单词，等等。 </li><li>  <strong>检查缩进</strong> ，空格。 </li><li>  <strong>处理字符串</strong> 。 例如，您可以验证Python 3不使用Unicode文字，或验证字节字符串中仅存在ASCI字符。 </li></ul><br><h2> 结论 <br></h2><br> 我们在代码审查方面遇到了问题。 开发人员执行了linter的工作，将时间花在了毫无意义的代码扫描上，并通知了作者错误。 通过Pylint，我们： <br><br><ul><li> 将例行检查转移到短绒棉衣，并在其中实施内部协议。 </li><li> 提高了速度和质量代码审查。 </li><li> 减少了拒绝请求请求的数量，并且在生产中通过任务的时间变得更少了。 </li></ul><br> 一个简单的检查程序在半小时内就可以完成，而复杂的检查程序在几个小时内就可以完成。 该检查程序比编写代码节省了更多的时间，并且可以为几个未拒绝的请求请求而奋斗。 <br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档中</a>了解有关Pylint的更多信息以及如何为它编写检查器，但是就编写检查器而言，它相当差。 例如，关于TokenChecker，仅提及其中，而不涉及如何编写检查器本身。 有关更多信息，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参见GitHub上的Pylint源</a> 。 您可以查看标准包装中的检查器，并受到启发来编写自己的检查器。 <br><br>  <em>了解Pylint内部设计可节省工时并简化工作</em> <em><br></em>  <em>性能并改进代码。</em>  <em>节省您的时间，编写好的代码，</em> <em><br></em>  <em>使用短绒。</em> <br><blockquote> 下一次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莫斯科Python Conf ++</a>会议将于<b>2019年4月5日</b>举行，您现在可以预订早鸟票。 最好收集您的想法并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">申请</a>报告，然后访问将是免费的，精美的面包也将作为奖励，其中包括指导编写报告的过程。 <br><br> 我们的会议是一个与志趣相投的人，行业引擎开会，交流和讨论Python开发人员喜欢的事物的平台：后端和Web，数据收集和处理，AI / ML，测试，IoT。 秋天的情况如何， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请在</a>我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python频道</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">观看视频报告</a>并订阅该频道-很快我们将发布会议中的最佳报告以免费提供。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433474/">https://habr.com/ru/post/zh-CN433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433456/index.html">如何说服客户或公司使用Flutter</a></li>
<li><a href="../zh-CN433462/index.html">运行状况检查和分布式系统的逐步降级</a></li>
<li><a href="../zh-CN433464/index.html">亚种族</a></li>
<li><a href="../zh-CN433468/index.html">故障注入：如果您未尝试破坏系统，则系统将不可靠</a></li>
<li><a href="../zh-CN433472/index.html">Unity 2018.3发布</a></li>
<li><a href="../zh-CN433476/index.html">50种芹菜色</a></li>
<li><a href="../zh-CN433478/index.html">为什么在Tinkoff Magazine中选择Django</a></li>
<li><a href="../zh-CN433480/index.html">霍利瓦尼关于短毛绒的故事</a></li>
<li><a href="../zh-CN433482/index.html">显微镜下的Django</a></li>
<li><a href="../zh-CN433486/index.html">又怎么了 非银行借记卡的复兴</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>