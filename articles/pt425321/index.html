<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèª üë®üèΩ‚Äç‚úàÔ∏è üßù Programa√ß√£o √© a materializa√ß√£o de id√©ias. üöΩ üèÑ üçÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A tese principal deste artigo: O desenvolvimento de software deve ser considerado como a materializa√ß√£o de id√©ias atrav√©s da transforma√ß√£o de modelos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o √© a materializa√ß√£o de id√©ias.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425321/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ca/ha/pc/cahapcznbgjnjjfsimgdlkqovig.jpeg"></a> <br><br>  A tese principal deste artigo: O desenvolvimento de software deve ser considerado como a materializa√ß√£o de id√©ias atrav√©s da transforma√ß√£o de modelos mentais em c√≥digo de programa. <br>  O artigo descreve o paradigma de materializar id√©ias em engenharia de software (engl .: RPSE: Reification as Paradigm of Software Engineering). <br><a name="habracut"></a><br>  Vers√£o em ingl√™s do artigo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RPSE: Reifica√ß√£o como paradigma de engenharia de software</a> .  A abrevia√ß√£o RPSE √© usada posteriormente no texto para indicar o paradigma descrito. <br><br><h2>  Defini√ß√µes-chave </h2><br>  Antes de discutir os pontos principais deste artigo, voc√™ precisa concordar com o significado dos termos b√°sicos usados ‚Äã‚Äãnele. <br><br><h3>  Engenharia de software </h3><br>  Por <b>engenharia de software</b> , entendemos a defini√ß√£o cl√°ssica da disciplina Engenharia de Software do dicion√°rio IEEE [1]: Engenharia de software √© "A aplica√ß√£o de uma abordagem sistem√°tica, disciplinada e quantific√°vel para o desenvolvimento, opera√ß√£o e manuten√ß√£o de software". <br><br><h3>  Paradigma </h3><br>  O termo <b>paradigma</b> usado neste artigo baseia-se na defini√ß√£o cl√°ssica do paradigma de Thomas Kuhn [2]: Um paradigma √© um c√≠rculo de problemas, um conjunto de conceitos, regras e leis geralmente aceitas, m√©todos para resolver problemas em um determinado campo da ci√™ncia. <br><br><div class="spoiler">  <b class="spoiler_title">Mais sobre paradigmas</b> <div class="spoiler_text">  Para determinar com mais precis√£o o conceito de paradigma usado abaixo, √© √∫til citar duas cita√ß√µes conhecidas do livro de Kuhn: <br><blockquote>  Por paradigmas, quero dizer conquistas cient√≠ficas reconhecidas que, por algum tempo, d√£o √† comunidade cient√≠fica um modelo para apresentar problemas e suas solu√ß√µes ... <br><br>  Introduzindo esse termo, eu quis dizer que alguns exemplos geralmente aceitos da pr√°tica real da pesquisa cient√≠fica - exemplos que incluem direito, teoria, sua aplica√ß√£o pr√°tica e o equipamento necess√°rio - todos juntos nos d√£o modelos a partir dos quais surgem tradi√ß√µes espec√≠ficas da pesquisa cient√≠fica. </blockquote><br>  O dualismo desse conceito reside no fato de que, por um lado, o paradigma √© caracterizado por uma comunidade de especialistas que o reconhecem.  S√£o os especialistas de um determinado campo que determinam, criam e desenvolvem suas partes.  Por outro lado, o reconhecimento de um certo paradigma significa que um especialista se junta a essa comunidade. </div></div><br>  Thomas Kuhn considerou paradigmas cient√≠ficos em seu livro.  No entanto, logo ap√≥s o lan√ßamento da primeira edi√ß√£o do livro, a utilidade de usar esse conceito em tecnologia e em v√°rias √°reas da vida social tornou-se aparente.  Nesse sentido, numerosas publica√ß√µes sobre paradigmas e suas mudan√ßas na ind√∫stria automotiva, planejamento urbano, tratamento de certas doen√ßas etc. come√ßaram a aparecer na literatura especial e popular. <br><br>  A engenharia de software e, especialmente, seu componente importante - programa√ß√£o, n√£o foram exce√ß√£o.  Atualmente, existem muitos paradigmas de programa√ß√£o concorrentes.  Um artigo separado na Wikipedia [3], bem como cr√≠ticas interessantes como [4], s√£o dedicadas √† sua enumera√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre as limita√ß√µes dos paradigmas de programa√ß√£o</b> <div class="spoiler_text">  Os autores dos paradigmas descritos em [3] e [4] concentram-se em uma sub√°rea estreita da engenharia de software, a saber, a escrita de programas em uma linguagem de programa√ß√£o espec√≠fica.  Eu acho que muitos profissionais concordam que projetos de software reais n√£o podem ser conclu√≠dos dentro da estrutura de apenas um desses paradigmas (por exemplo, programa√ß√£o funcional). <br><br>  O paradigma descrito neste artigo, por outro lado, √© aplic√°vel a uma ampla variedade de √°reas e fases do desenvolvimento de software. </div></div><br><div class="spoiler">  <b class="spoiler_title">Sobre as limita√ß√µes dos paradigmas de gerenciamento de projetos de software</b> <div class="spoiler_text">  Alguns autores, por exemplo, na revis√£o [5], nomeiam v√°rias abordagens ou modelos para organizar e conduzir projetos de software como paradigmas.  Por exemplo, modelos em cascata, modelos V ou modelos √°geis s√£o comparados.  √â improv√°vel que essas abordagens, em contraste com os paradigmas de programa√ß√£o mencionados acima, possam ser chamadas de paradigmas no esp√≠rito da defini√ß√£o de Kuhn, devido √† sua relativa simplicidade te√≥rica e √† falta de uma ampla base te√≥rica. <br><br>  O paradigma proposto neste artigo tamb√©m ainda n√£o possui base te√≥rica desenvolvida, mas hoje seus caminhos de desenvolvimento j√° s√£o vis√≠veis. </div></div><br><h3>  Materializa√ß√£o de id√©ias </h3><br>  O termo <b>materializa√ß√£o de id√©ias</b> (engl: <i>reification</i> ) usado neste artigo √© uma extens√£o da defini√ß√£o cl√°ssica de reifica√ß√£o em ci√™ncia da computa√ß√£o: ‚ÄúReifica√ß√£o √© o processo pelo qual uma id√©ia abstrata sobre um programa de computador √© transformada em um modelo de dados expl√≠cito ou outro objeto criado em uma linguagem de programa√ß√£o‚Äù [6] <br><br><div class="spoiler">  <b class="spoiler_title">Mais sobre o mundo das id√©ias, o mundo das coisas e a materializa√ß√£o</b> <div class="spoiler_text">  A ess√™ncia da expans√£o da defini√ß√£o cl√°ssica do conceito de materializa√ß√£o usada neste artigo pode ser definida da seguinte forma. <br><br>  J√° nos primeiros folhetos filos√≥ficos que chegaram at√© n√≥s, era costume contrastar o Ideal (o mundo das id√©ias) com o Material (o mundo das coisas). <br><br>  Podemos sentir o ideal na melhor das hip√≥teses (ou pensar que o sentimos).  Um indicador desse sentimento do Ideal pode ser uma mudan√ßa de humor ou uma linha de pensamento depois de ouvir uma pe√ßa musical, um fragmento lido de um livro etc.  √â claro, quero dizer o efeito indireto, por exemplo, da m√∫sica, em nossa consci√™ncia, e n√£o a subordina√ß√£o fisiol√≥gica primitiva do corpo ao rugido de um show de rock ou ao ritmo de uma discoteca. <br><br>  Tentativas de formular nosso senso do Ideal como regra n√£o levam ao sucesso. <br>  O grande poeta russo Fedor Ivanovich Tyutchev observou isso notavelmente: <br><blockquote>  Como o cora√ß√£o se expressa? <br>  Como mais para entender voc√™? <br>  Ele vai entender como voc√™ mora? <br>  O pensamento pronunciado √© uma mentira ... [7] </blockquote>  Mesmo id√©ias pr√°ticas, como pequenos reparos em casa ou preparar uma nova varia√ß√£o de um prato familiar, s√£o dif√≠ceis de formular no in√≠cio.  E somente ap√≥s delibera√ß√£o ou tentativa de explica√ß√£o para outra pessoa, a ideia assume "contornos" cada vez mais claros. <br><br>  Passamos agora da considera√ß√£o do conceito do Ideal para a considera√ß√£o do Material.  Podemos sentir e registrar objetos materiais ao nosso redor, para distinguir qualitativamente suas propriedades.  As propriedades de muitos objetos podem ser medidas objetivamente.  Tamb√©m podemos identificar objetivamente hierarquias e outras estruturas de objetos materiais. </div></div><br>  Para avaliar ou medir (para obter caracter√≠sticas quantitativas), n√£o √© necess√°rio ter um item.  Basta ter o seu modelo.  Al√©m disso, em muitas situa√ß√µes praticamente interessantes, o modelo pode ser usado sem um objeto.  Modelos podem ser discutidos com outras pessoas.  Modelos podem ser negociados.  Os modelos podem ser padronizados (formalizados). <br><br>  Em algumas √°reas da atividade humana, a padroniza√ß√£o de modelos foi t√£o longe que as pe√ßas (por exemplo, parafusos roscados) feitas com base em um modelo padronizado (por exemplo, um desenho) por diferentes pessoas ou metralhadoras ser√£o indistingu√≠veis do ponto de vista tecnol√≥gico. <br><br>  Percebendo a relativa imprecis√£o da defini√ß√£o proposta, mais adiante neste artigo, dividirei o mundo dos fen√¥menos de nosso mundo interno e externo <b>U</b> em duas partes: <br><br>  <b>U = M + I</b> <br><br>  onde o conjunto <b>M</b> consiste em seus fen√¥menos que podem ser objetivamente registrados ou medidos (mundo material) e <b>I</b> - tudo o resto. <br><br>  Se esta f√≥rmula √© aplic√°vel a absolutamente todos os fen√¥menos do mundo ao nosso redor √© uma quest√£o filos√≥fica aberta.  Mais adiante neste artigo, restringimos o escopo dessa f√≥rmula ao mundo dos fen√¥menos do mundo da engenharia de software. <br><br>  Ou, formulando-o como uma tese: todo o conjunto de fen√¥menos relacionados √† engenharia de software pode ser dividido em um subconjunto do ideal e um subconjunto do material.  Al√©m disso, os fen√¥menos materiais s√£o registrados ou medidos com base em seus modelos. <br>  O processo de cria√ß√£o ou modifica√ß√£o de um sistema de software termina na maioria dos casos com a cria√ß√£o de um ou outro c√≥digo, que, usando um computador, √© exibido em um processo f√≠sico (um fen√¥meno do mundo real). <br><br>  Esse processo come√ßa com o surgimento de certas id√©ias sobre o futuro sistema nas mentes dos clientes ou desenvolvedores.  Vamos chamar essas id√©ias e id√©ias de <b>modelo mental</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Sobre modelos intermedi√°rios</b> <div class="spoiler_text">  Em sistemas simples ou com simples adi√ß√µes / altera√ß√µes em sistemas grandes, o desenvolvedor imediatamente escreve o c√≥digo ou configura o sistema com base em seu modelo mental.  No entanto, na maioria dos casos, modelos intermedi√°rios de complexidade e n√≠vel de formaliza√ß√£o diferentes s√£o criados - de uma lista simples de requisitos a modelos formais extensivos (por exemplo, modelos UML ou BPMN) </div></div><br><h2>  Materializa√ß√£o de id√©ias em √°reas adjacentes √† Engenharia de Software </h2><br>  √â claro que a defini√ß√£o acima n√£o √© radicalmente nova e √© amplamente usada (consciente ou inconscientemente) em √°reas de trabalho intelectual adjacentes √† programa√ß√£o.  Por exemplo, considere duas dessas √°reas - engenharia mec√¢nica e matem√°tica. <br><br>  Essas duas √°reas v√™m usando materializa√ß√£o de id√©ias h√° muito tempo e de forma eficaz.  Eles t√™m muito a aprender sobre programa√ß√£o a esse respeito. <br><br>  Na engenharia mec√¢nica, vemos um ciclo completo de materializa√ß√£o de id√©ias - desde o surgimento de uma id√©ia na cabe√ßa de um projetista, passando pelo pensamento, elabora√ß√£o, mapeamento em um modelo e, finalmente, fabrica√ß√£o de um determinado material. <br><br>  A situa√ß√£o √© diferente em matem√°tica. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre a materializa√ß√£o de id√©ias em matem√°tica</b> <div class="spoiler_text">  Fatos e considera√ß√µes interessantes sobre a materializa√ß√£o de id√©ias em matem√°tica podem ser encontrados no par√°grafo 7.3 do livro [8]. </div></div><br>  O "produto final" da matem√°tica s√£o modelos formais com propriedades estritamente comprovadas. <br><br>  Deste ponto de vista, a programa√ß√£o est√° no meio.  Isso pode ser representado graficamente da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/8n/ja/84/8nja84baboink2t_bp02narqbja.png"><br><br>  Assim, a matem√°tica usa um n√∫mero maior de modelos mais abstratos e quase n√£o se aplica ao campo de modelos extremamente espec√≠ficos, como desenhos de engenharia. <br><br>  A engenharia mec√¢nica, pelo contr√°rio, usa relativamente poucos modelos abstratos, mas muitos modelos espec√≠ficos.  Por exemplo, aqueles para os quais objetos f√≠sicos podem ser feitos sem ambiguidade. <br><br>  Deste ponto de vista, a programa√ß√£o est√° no meio. <br><br><div class="spoiler">  <b class="spoiler_title">Por que a programa√ß√£o est√° no meio?</b> <div class="spoiler_text">  O produto final de programa√ß√£o √© o c√≥digo do software.  E, embora seja executado no hardware, seja mapeado para objetos f√≠sicos espec√≠ficos (sinais el√©tricos e campos de v√°rias naturezas f√≠sicas), √© dif√≠cil comparar esses objetos com porcas, engrenagens e carrocerias.  Por outro lado, o c√≥digo do programa est√° pr√≥ximo das f√≥rmulas matem√°ticas e, √†s vezes, √© seu reflexo direto.  No entanto, em qualquer sistema de software real, √© necess√°rio considerar muitos aspectos espec√≠ficos do ambiente e a intera√ß√£o com usu√°rios ou outros sistemas.  Isso torna o c√≥digo do programa mais espec√≠fico do que as f√≥rmulas matem√°ticas. </div></div><br><div class="spoiler">  <b class="spoiler_title">O que a engenharia de software pode aprender com as √°reas vizinhas em termos de uso do modelo</b> <div class="spoiler_text">  Considere primeiro a matem√°tica. <br><br><h3>  Multimodelo do mundo </h3><br>  Por v√°rios milhares de anos de seu desenvolvimento, a matem√°tica aprendeu a descrever os mesmos fen√¥menos do mundo real ou imagin√°rio em termos muito diferentes.  Os gregos antigos aprenderam a substituir descri√ß√µes puramente verbais de tarefas por figuras geom√©tricas e com sua ajuda para resolver problemas praticamente importantes.  Posteriormente, surgiu um entendimento sobre a intercambiabilidade de segmentos no plano e n√∫meros.  Em seguida, o conceito de vari√°vel alg√©brica e redu√ß√£o de problemas geom√©tricos para sistemas de equa√ß√µes alg√©bricas cristalizaram. <br><br>  Hoje, os alunos do ensino m√©dio j√° sabem que o mesmo problema pode ser resolvido de maneiras diferentes (por exemplo, geometricamente ou algebricamente) e que o mesmo modelo matem√°tico, por exemplo, uma equa√ß√£o alg√©brica, descreve muitos aspectos f√≠sicos, qu√≠micos etc.  fen√¥menos. <br><br><h3>  Morfismo de modelos e consist√™ncia de conceitos e nota√ß√µes </h3><br>  A matem√°tica aprendeu bem n√£o apenas a descrever os mesmos objetos e processos reais ou imagin√°rios, usando modelos de natureza matem√°tica muito diferente.  Uma conquista importante da matem√°tica √© a capacidade de determinar o grau de similaridade dos modelos de diferentes ramos da matem√°tica, bem como a capacidade de transform√°-los um no outro.  Muitas solu√ß√µes inovadoras para os problemas matem√°ticos mais importantes dos √∫ltimos anos s√£o essencialmente cadeias de evid√™ncias separadas, cada uma das quais utiliza um aparato especializado de uma se√ß√£o especial de matem√°tica.  Nas jun√ß√µes dessa evid√™ncia altamente especializada, a matem√°tica habilmente transforma modelos de uma se√ß√£o da matem√°tica em modelos de outra se√ß√£o.  Na programa√ß√£o, algo semelhante acontece agora ao compilar o c√≥digo fonte de um programa e ao gerar c√≥digo a partir de DSL (Domain Specific Language) ou metadados.  Mas a cultura de trabalhar com modelos no campo da engenharia de software est√° muito atr√°s da matem√°tica. <br><br><h3>  Modelos em engenharia mec√¢nica </h3><br>  E o que a engenharia de software pode aprender com a materializa√ß√£o em engenharia? <br>  Em muitas ind√∫strias, e mesmo dentro de grandes preocupa√ß√µes, existem cadeias de modelos coordenados formais e semi-formais.  Essas correntes terminam com modelos, com base nos quais objetos f√≠sicos s√£o fabricados e montados - dispositivos e m√°quinas.  Como regra, para a maioria dos tipos de modelos intermedi√°rios, existem m√©todos formais para verificar sua corre√ß√£o (padr√µes t√©cnicos).  Os modelos s√£o a principal linguagem de comunica√ß√£o de especialistas de v√°rios perfis no design e fabrica√ß√£o de produtos de engenharia. <br><br>  Nesse contexto, a situa√ß√£o na TI parece muito pior.  Somente em grandes preocupa√ß√µes de TI nos √∫ltimos anos foram feitas tentativas para criar conjuntos compar√°veis ‚Äã‚Äãde modelos e processos.  As pequenas empresas e as startups de TI, por regra, n√£o apenas n√£o desenvolveram modelos e processos formais, como sequer suspeitam de sua exist√™ncia.  Atualmente, esta situa√ß√£o √© determinada pelos seguintes fatores: <br><br><ul><li>  A falta de efici√™ncia dos modelos e processos existentes </li><li>  A falta de fama desses modelos fora de grandes preocupa√ß√µes </li><li>  Educa√ß√£o inadequada para desenvolvedores e especialmente gerentes </li><li>  O atraso da educa√ß√£o universit√°ria a partir das reais necessidades da engenharia de software. </li></ul></div></div><br><h2>  Defini√ß√£o e contornos do paradigma de materializa√ß√£o de id√©ias (RPSE) </h2><br>  Identificamos todos os conceitos necess√°rios para fornecer uma defini√ß√£o b√°sica do paradigma proposto.  Aqui est√°: <br><blockquote>  Desenvolvimento de software √© a materializa√ß√£o de id√©ias atrav√©s da transforma√ß√£o de modelos mentais em c√≥digo executado em computadores. <br><br>  No quadro do paradigma proposto: <br><br><ol><li>  Todos os principais processos de desenvolvimento de software s√£o variantes espec√≠ficas (implementa√ß√µes) do processo de constru√ß√£o de cadeias de modelos mentais e materiais.  O √∫ltimo modelo mais espec√≠fico dessa cadeia √©, via de regra, o c√≥digo do programa. </li><li>  A ess√™ncia do desenvolvimento de software √© criar essas cadeias. </li><li>  Todas as principais quest√µes de otimiza√ß√£o do desenvolvimento, reduzindo seu custo e melhorando sua qualidade, podem ser reduzidas para otimizar a constru√ß√£o da cadeia de modelos correspondente. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">Por que materializa√ß√£o e n√£o modelagem?</b> <div class="spoiler_text">  Observe que, embora a defini√ß√£o de RPSE se refira √† constru√ß√£o de cadeias de modelos, √© proposto, no entanto, chamar a materializa√ß√£o do paradigma em vez de modelar.  Assim, tenta-se enfatizar a peculiaridade das cadeias de modelos que est√£o se tornando cada vez menos abstratas / ideais e cada vez mais concretas / materiais. </div></div><br>  A defini√ß√£o acima possui caracter√≠sticas e varia√ß√µes pr√≥prias em diferentes √°reas da engenharia de software.  Somente em um n√∫mero muito pequeno de casos acontece que, na cabe√ßa de um programador, uma id√©ia clara de como resolver o problema antes dele amadurece completamente, o que ele traduz em um c√≥digo de linguagem de programa√ß√£o em pouco tempo.  Na maioria dos projetos do mundo real, o processo de encontrar uma solu√ß√£o e sua implementa√ß√£o coexiste, desenvolve-se em paralelo e interage entre si.  I.e.  modelos mentais, c√≥digo e, geralmente, modelos intermedi√°rios (na forma de teste, imagens, modelos formais como UML) crescem e mudam em paralelo, influenciando-se mutuamente. <br><br><div class="spoiler">  <b class="spoiler_title">Op√ß√µes de defini√ß√£o</b> <div class="spoiler_text">  Muitas vezes, v√°rias pessoas trabalham em um problema ao mesmo tempo.  Cada um deles tem seu pr√≥prio modelo mental e, possivelmente, seus modelos intermedi√°rios e fragmentos de c√≥digo. <br><br>  Geralmente, o c√≥digo em alguma linguagem de programa√ß√£o est√° praticamente ausente, pois a cria√ß√£o de uma nova solu√ß√£o se resume ao gerenciamento de m√°scaras de configuradores ou geradores, como quando se trabalha com ferramentas de desenvolvimento em sistemas como SAP ou WebSphere. <br><br>  As op√ß√µes para transformar c√≥digo escrito manualmente ou gerado automaticamente em c√≥digo execut√°vel tamb√©m se tornaram muito diversas atualmente. <br><br>  E, finalmente, o pr√≥prio conceito de processador no qual o c√≥digo √© executado tamb√©m se expandiu significativamente nos √∫ltimos anos.  Se anteriormente eram processadores que estavam nas placas, que por sua vez eram inseridos nas capas de desktops, laptops e racks de servidores, agora esse conjunto foi expandido por v√°rios chips de v√°rios tamanhos que s√£o incorporados a telefones celulares, consoles de jogos, c√¢meras de vigil√¢ncia " eletrodom√©sticos inteligentes etc.  Sem mencionar computadores qu√¢nticos. <br><br>  No entanto, o RPSE, em virtude de sua generalidade, √© aplic√°vel a todas as √°reas listadas acima. </div></div><br>  O que mais se pode dizer sobre um certo paradigma hoje em dia, √© poss√≠vel delinear de maneira mais precisa seus contornos? <br><br>  O pr√≥ximo passo para refinar o paradigma depois de tentar definir sua defini√ß√£o principal √© uma tentativa de listar as principais categorias de fen√¥menos que ele afeta.  Recordando a defini√ß√£o de Kuhn, precisamos tentar listar os tipos de modelos que o RPSE apresenta e usa. <br><br>  Os modelos RPSE podem ser divididos em tr√™s categorias principais: <br><br><ul><li>  Modelos mentais </li><li>  C√≥digo em linguagens de programa√ß√£o ou seus equivalentes como modelos de c√≥digo execut√°vel. </li><li>  Modelos intermedi√°rios. </li></ul><br>  Os menos explorados nessa tr√≠ade s√£o os modelos mentais.  O que exatamente se entende por eles? <br><br>  <b>Modelos mentais</b> s√£o um termo para id√©ias que existem na cabe√ßa de clientes, programadores e outros participantes do processo e com base nas quais o c√≥digo execut√°vel finalmente surge.  A presen√ßa de tais modelos √© indiscut√≠vel e pode ser registrada no n√≠vel mental, por exemplo, pelo pr√≥prio programador.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No atual n√≠vel de desenvolvimento tecnol√≥gico, esses modelos n√£o podem ser medidos com seguran√ßa por instrumentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma das maneiras eficazes de corrigir e medir esses modelos √© usar o meio da ideia. </font><font style="vertical-align: inherit;">Obviamente, o processo de entrevista ou similar afeta drasticamente o pr√≥prio modelo mental. </font><font style="vertical-align: inherit;">Cada um de n√≥s deve ter experimentado a situa√ß√£o mais de uma vez, quando apenas uma tentativa de formular um problema com o objetivo de consultar um colega levou ao "insight" e, freq√ºentemente, a uma solu√ß√£o para o problema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A entrevista permite, com base em perguntas formuladas corretamente, construir de maneira relativamente objetiva modelos de complexidade variada. </font><font style="vertical-align: inherit;">Os mais comuns s√£o: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelos estruturais:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lista com valores bin√°rios, enumera√ß√£o, num√©ricos, sequ√™ncia e outros. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estruturas de dados de redes e gr√°ficos </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos de descri√ß√£o comportamental: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos sete-formais para determinar o comportamento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modelos formais para determinar o comportamento (por exemplo, m√°quinas de estados finitos) </font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre a teoria dos modelos mentais</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses padr√µes s√£o um reflexo dos padr√µes mentais. </font><font style="vertical-align: inherit;">O grau de proximidade dos modelos mentais com os modelos reais deve ser tratado pela psicologia ou pela pedagogia te√≥rica. </font><font style="vertical-align: inherit;">Infelizmente, o autor n√£o tem conhecimento de trabalhos s√©rios nessa √°rea. </font><font style="vertical-align: inherit;">(Isso n√£o significa que esse trabalho n√£o exista).</font></font></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por que a engenharia de software precisa de um paradigma de ponta a ponta? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A presen√ßa de um paradigma ‚Äútransversal‚Äù abre as seguintes possibilidades para os participantes usarem o paradigma do processo de cria√ß√£o, modifica√ß√£o e uso de software: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A capacidade de todos os participantes do processo usarem a mesma terminologia. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A capacidade de criar um processo completo para criar um novo software. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A capacidade de avaliar seus par√¢metros de processo, seus resultados intermedi√°rios e gerenci√°-lo. </font></font></li></ul>  . <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os principais objetivos do desenvolvimento de paradigmas </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problemas te√≥ricos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como j√° foi observado repetidamente, inclusive no livro de Kuhn [2], na maioria dos casos, os cientistas est√£o envolvidos na solu√ß√£o de problemas potenciais que est√£o sendo resolvidos e s√£o menos propensos a enfrentar aqueles que n√£o s√£o muito claros sobre como abordar. </font><font style="vertical-align: inherit;">Mas essas s√£o exatamente nossas tarefas.</font></font> Aqui est√£o os principais: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defini√ß√£o construtiva do conceito de modelo mental. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar crit√©rios construtivos para avaliar o grau de abstra√ß√£o / idealidade vs. </font><font style="vertical-align: inherit;">especificidade / materialidade dos modelos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontrar crit√©rios para selecionar candidatos para o papel de modelos intermedi√°rios e adicionais. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sele√ß√£o e desenvolvimento de crit√©rios e m√©todos para comparar modelos de v√°rios tipos, incluindo o rastreamento direto e reverso. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desenvolvimento de m√©todos para transforma√ß√£o automatizada e autom√°tica de modelos. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tarefas pr√°ticas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juntamente com as tarefas te√≥ricas para o desenvolvimento e implementa√ß√£o do paradigma descrito na pr√°tica da engenharia de software, √© necess√°rio resolver pelo menos os seguintes problemas pr√°ticos: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cria√ß√£o de ferramentas para: a) Extra√ß√£o e fixa√ß√£o de modelos mentais. </font><font style="vertical-align: inherit;">b) Transforma√ß√£o automatizada e autom√°tica de modelos mentais em modelos intermedi√°rios. </font><font style="vertical-align: inherit;">c) Tra√ßos e estimativas de mudan√ßas no conte√∫do de modelos transform√°veis</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cria√ß√£o da literatura t√©cnica e educacional necess√°ria e outro material educacional medial. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Organiza√ß√£o de f√≥runs e confer√™ncias sobre este assunto </font></font></li></ol><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este artigo tenta definir o paradigma da engenharia de software como a materializa√ß√£o de id√©ias. A palavra para definir (e n√£o abrir) √© usada aqui, n√£o por acaso. De fato, os participantes de projetos de TI h√° muito tempo se envolvem na cria√ß√£o, transforma√ß√£o e uso de modelos, talvez sem perceber. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No sentido estrito da defini√ß√£o de Kuhn, a abordagem descrita ainda n√£o pode reivindicar o direito de ser chamado de paradigma, mas apenas um candidato a um paradigma, porque n√£o possui uma extensa comunidade de pessoas apoiando-o e um sistema bem desenvolvido de modelos interconectados. No entanto, quero acreditar que as defici√™ncias ser√£o superadas em breve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© o primeiro artigo de uma s√©rie planejada de artigos. Nos artigos a seguir, vou falar sobre modelos mentais e intermedi√°rios.</font></font><br><br><h3>  Literatura </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Gloss√°rio Padr√£o IEEE de Terminologia de Engenharia de Software, IEEE std 610.12-1990, 1990. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kuhn, Thomas S. A Estrutura das Revolu√ß√µes Cient√≠ficas. 3rd ed. Chicago, IL: University of Chicago Press, 1996. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Paradigma de programa√ß√£o: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Programming_paradigm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (estado - 27/08/2018) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Peter A. Henning, Holger Vogelsang Taschenbuch Programmiersprachen. Carl Hanser Verlag GmbH &amp; Co. KG; Auflage: 2., neu bearbeitete (5. de setembro de 2007). ISBN-13: 978-3446407442. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Ensaio sobre tecnologia da informa√ß√£o e modelos de paradigmas e modelos de engenharia de software </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.uniassignment.com/essay-samples/information-technology/software-engineering-paradigms-and-models-information-technology-essay.php</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (estado - 27/08/2018)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Reifica√ß√£o (ci√™ncia da computa√ß√£o) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Reification_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (computer_science) (estado - 27/08/2018) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Fedor Ivanovich Tyutchev. </font><font style="vertical-align: inherit;">Sil√™ncio! </font><font style="vertical-align: inherit;">(Silence (lat.), 1829. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Borovik, Alexandre. Matem√°tica ao microsc√≥pio: notas sobre aspectos cognitivos da pr√°tica matem√°tica. American Mathematics Society. ISBN-13: 978-0821847619. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustra√ß√£o: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geralt</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425321/">https://habr.com/ru/post/pt425321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425305/index.html">Como o Chemical Brothers Show organiza: detalhes t√©cnicos e comuta√ß√£o</a></li>
<li><a href="../pt425311/index.html">O livro "Programa√ß√£o para crian√ßas. Do b√°sico √† cria√ß√£o de rob√¥s</a></li>
<li><a href="../pt425313/index.html">As 10 melhores extens√µes de c√≥digo VS de 2018 para desenvolvedores front-end</a></li>
<li><a href="../pt425315/index.html">Organizando o armazenamento de c√≥digo no GitLab e integrando a revis√£o de c√≥digo no GitFlow</a></li>
<li><a href="../pt425317/index.html">Como √© feito: escrevemos ‚ÄúCampo Minado‚Äù em 4 minutos</a></li>
<li><a href="../pt425323/index.html">"Toca do coelho". Designer de UX na equipe de produtos</a></li>
<li><a href="../pt425325/index.html">Int√©rpretes de Bytecode DIY</a></li>
<li><a href="../pt425327/index.html">Programa√ß√£o funcional: me√ßa sete vezes, corte uma vez</a></li>
<li><a href="../pt425329/index.html">Alguns conselhos aos millennials dos "oldies". Como ter sucesso em nosso mundo digital</a></li>
<li><a href="../pt425331/index.html">Alice ajudar√° os desenvolvedores a encontrar objetos nas solicita√ß√µes do usu√°rio. NER em caixas de di√°logo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>