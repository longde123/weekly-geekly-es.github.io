<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏿 🥜 🧓🏽 Transformation von Entwicklungs- und Bereitstellungsprozessen für eine Legacy-Anwendung 🈸 🗜️ 🏅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unser Team ist verantwortlich für den Betrieb und die Entwicklung eines großen Unternehmensprodukts. 
 Anfang 2017 haben wir uns entschlossen, die Ent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transformation von Entwicklungs- und Bereitstellungsprozessen für eine Legacy-Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427111/"><p>  Unser Team ist verantwortlich für den Betrieb und die Entwicklung eines großen Unternehmensprodukts. <br>  Anfang 2017 haben wir uns entschlossen, die Entwicklung und Bereitstellung unserer Anwendung zu überprüfen, nachdem wir eine Pause von einer wichtigen Implementierung eingelegt und die „Lessons Learned“ erneut gelesen hatten.  Wir waren besorgt über die geringe Geschwindigkeit und Qualität der Lieferung und konnten nicht den Service bieten, den Kunden von uns erwarten. </p><br><p>  Es war Zeit, von Worten zu Taten überzugehen - Prozesse zu ändern. </p><br><p>  In diesem Artikel wird kurz darauf eingegangen, wo wir angefangen haben, was wir getan haben, wie die Situation jetzt ist, auf welche Schwierigkeiten wir gestoßen sind, was wir zurücklassen müssen, was wir sonst noch vorhaben. </p><a name="habracut"></a><br><h1 id="nachalo">  Starten Sie </h1><br><h3 id="nemnogo-o-sisteme">  Ein wenig über das System </h3><br><p>  Die Anwendung ist ein klassisches Beispiel für eine monolithische Unternehmensanwendung der "Architektur der 2000er Jahre": </p><br><ul><li>  Betrieben und entwickelt über 15 Jahre. </li><li>  Es handelt sich um eine Reihe von anderthalb Dutzend WinForms, Windows-Diensten und ASP .Net-Anwendungen, die an eine einzelne MS SQL-Datenbank gebunden sind. </li><li>  Codebasisgröße: ~ 1MLOC für C #, ~ 9000 Datenbankobjekte.  Ein Großteil der Geschäftslogik läuft auf der Datenbankseite. </li><li>  Die Anwendung besteht aus über 250 Lösungen zum Erstellen eines Win / Web-Clients (eine Lösung pro Gruppe verwandter Formulare).  Dies ist ein Erbe des vorherigen Entwicklungsprozesses und der Client-Architektur. </li><li>  Die Anwendung unterstützt verschiedene Arten von Prozessen (Clients) durch Ändern der internen Konfiguration: Festlegen von Prozessen, Berechtigungen, flexiblen Feldern usw. in den Konfigurationstabellen der Systemdatenbank.  Gleichzeitig ist die Anwendungscodebasis für alle Clients gleich. </li><li>  Die Anwendung wird auf mehr als 25 Standorten bereitgestellt und unterstützt (jeder Standort ist eine unabhängige Instanz des Systems) und bedient insgesamt mehrere tausend Endbenutzer in verschiedenen Zeitzonen. </li></ul><br><h3 id="process-dostavki-do-transformacii">  Lieferprozess vor der Transformation </h3><br><ol><li>  Die Entwicklung und Montage der fertigen Anwendung und ihrer Komponenten erfolgt durch den Auftragnehmer. </li><li>  Der Code wurde auf der Seite des Auftragnehmers gespeichert (lokale Version von MS TFS).  Der Code wird monatlich in Form eines Archivs der aktuellen Version des Haupt-Repository-Zweigs an den Kunden übermittelt. </li><li>  Die Lieferung erfolgte durch Lieferung von "Delta-Updates": für die Anwendung (Satz von DLL, Exe usw.) und Datenbankkomponenten (Satz von SQL-Skripten erstellen / ändern).  Die Anwendung wurde erstellt und die Delta-Pakete vom Auftragnehmer vorbereitet. </li><li>  Der Bereitstellungsprozess wurde vom Transportsystem unterstützt, Änderungen wurden automatisch übernommen. </li></ol><br><p>  Die Lieferung erfolgt im Rahmen monatlicher Veröffentlichungen (wie ich es arrangiert habe, habe ich Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> früher gesagt). </p><br><h3 id="suschestvovavshie-problemy">  Bestehende Probleme </h3><br><p>  <em>Mangel an Kontrolle</em> </p><br><ul><li>  Trotz des formellen Eigentums an dem Code war die tatsächliche Zusammenstellung des Antrags durch den Kunden nicht möglich. </li><li>  Infolgedessen ist es unmöglich, die Funktionsfähigkeit des an den Kunden übermittelten Codes zu überprüfen. </li><li>  Änderungen im Code - für den Kunden nicht transparent.  Es ist nicht möglich, die angeforderten und tatsächlichen Änderungen im Produkt abzugleichen. </li><li>  Die Codeanalyse ist für SQL schwierig und für C # -Komponenten unmöglich </li></ul><br><p>  <em>Arbeitseinsatz und Fehler</em> </p><br><ul><li>  Die Erstellung von "Delta-Paketen" ist ein zeitaufwändiges Entwicklungsverfahren, eine Fehlerquelle und bestimmte Projektkosten. </li><li>  Für die Bereitstellung einer Delta Packet-Anwendung muss die Reihenfolge der Pakete verfolgt werden.  Ein Paketfehler außerhalb der Reihenfolge ist ein großes Bereitstellungsproblem und eine erhebliche Ursache für Vorfälle. </li><li>  Regelmäßig treten Regressionen auf: Fehler, die anscheinend repariert und Korrekturen am Produkt vorgenommen wurden, traten erneut auf. </li></ul><br><p>  <em>Einschränkungen</em> </p><br><ul><li>  Die Möglichkeit, den Status des Systems zu einem früheren Zeitpunkt wiederherzustellen (Rollback-Änderungen), fehlt praktisch. </li><li>  Die Fähigkeit, Entwicklungs- und frühzeitige Testressourcen effektiv zu skalieren, indem Kundenmitarbeiter angezogen werden, fehlt praktisch. </li></ul><br><h3 id="ozhidaemye-rezultaty">  Erwartete Ergebnisse </h3><br><p>  Zu Beginn des Projekts haben wir uns offensichtliche Ziele gesetzt, um die oben genannten Probleme zu lösen. </p><br><ul><li>  Übertragen Sie das Code-Repository an die Kundenkontrolle </li><li>  Verschieben Sie den Anwendungserstellungsprozess auf die Kundenseite </li><li>  Ändern Sie den Prozess der Verteilung von Änderungen, indem Sie das „Delta der Änderungen“ zugunsten einer vollständigen Aktualisierung aufgeben </li></ul><br><p>  Zusätzlich haben wir unter Verwendung der Lösungen, die erhalten wurden, als die ersten beiden Ziele erreicht wurden, berechnet: </p><br><ul><li>  Verbessern Sie die technische Qualität der resultierenden Lösungen durch Code-Kontrolle </li><li>  Steigern Sie das Testengagement und die Benutzerfreundlichkeit, indem Sie eine Self-Service-Bereitstellung bereitstellen. </li></ul><br><h1 id="etapy-bolshogo-puti">  Etappen eines langen Weges </h1><br><h3 id="analiz-tekuschego-sostoyaniya-processov-razrabotki">  Analyse des aktuellen Standes der Entwicklungsprozesse </h3><br><p>  Erster Schritt: Analyse des bestehenden Entwicklungsprozesses für Auftragnehmer.  Dies half, die Änderungen so zu planen, dass die Arbeit nach Möglichkeit nicht unterbrochen wurde. </p><br><p>  Leider hat die Kenntnis des Entwicklungsprozesses gezeigt, dass der Prozess nach heutigem Verständnis der IT-Branche nicht vorhanden war. </p><br><ol><li>  Der Datenbankcode und die Geschäftslogik dafür wurden nicht aktuell im Repository verwaltet.  Der Hauptgrund: das Fehlen von Tools, die die Assembly aus dem Code im Repository implementieren, und die Bereitstellung des Ergebnisses.  Der Code im Repository ist also nur eine Dokumentation. </li><li>  Die "echte" Version des Datenbankcodes befindet sich in der gemeinsamen "Entwicklungsdatenbank", an der Dutzende von Entwicklern arbeiten. </li><li>  Der Clientanwendungscode (C #, ASP.NET) wurde im Repository verwaltet, die Qualität und Aktualität der Festschreibungen wurde jedoch nicht garantiert. </li><li>  Die Montage der Komponenten (nicht der gesamten Anwendung) erfolgte an den Entwicklerstationen.  Es ist nicht ganz klar, wie der Code vor dem Zusammenbau aktualisiert wurde.  Die zusammengesetzte Komponente wurde in einem freigegebenen freigegebenen Ordner angeordnet.  Von dort wurde ein "Delta-Paket" für den Kunden gebildet. </li><li>  Der völlige Mangel an Praxis bei der Pflege von Entwicklungszweigen.  Durch indirekte Anzeichen haben wir dies lange vermutet - aber nachdem wir in den Prozess eingetaucht waren, wurde alles offensichtlich. </li></ol><br><h3 id="perehod-na-novyy-repozitoriy-i-sistemu-kontrolya-versiy">  Wechsel zu einem neuen Repository und Versionskontrollsystem </h3><br><p>  Die Abhängigkeit von MS-Plattformen und Unternehmensstandards bestimmte die Wahl der Entwicklungsumgebung - Team Foundation Server. <br>  Als wir das Projekt jedoch direkt starteten (April 2017), wurde gerade die Version von Visual Studio Team Services veröffentlicht.  Das Produkt schien sehr interessant zu sein, es wurde als strategische Richtung für MS festgelegt, es bot Git-Repositories, Montage und Bereitstellung für On-Prem und Cloud. </p><br><p>  Das On-Prem-TFS für Unternehmen blieb hinter der Version und Funktionalität von VSTS zurück. Die Migration auf die neue Version wurde erst diskutiert.  Wir wollten nicht warten.  Wir haben uns entschlossen, sofort auf VSTS umzusteigen, da dies unsere Gemeinkosten für die Unterstützung der Plattform senkte und uns die volle Kontrolle darüber gab, wie und was wir tun. </p><br><p>  Zum Zeitpunkt des Beginns der Änderungen hatte das Entwicklungsteam Erfahrung mit TFSVC, der Anwendungscode wurde in einem solchen Repository gespeichert.  Auf der anderen Seite ist GIT längst zum Standard für die IT-Community geworden - der Kunde und Berater von Drittanbietern haben empfohlen, auf dieses System umzusteigen. <br>  Wir wollten, dass das Entwicklungsteam an der Entscheidung für ein neues Versionskontrollsystem beteiligt ist und eine fundierte Entscheidung trifft. </p><br><p>  Wir haben zwei Projekte in VSTS mit unterschiedlichen Repositorys bereitgestellt - TFSVC und GIT.  Es wurde eine Reihe von Szenarien definiert, die vorgeschlagen wurden, um die Verwendbarkeit in jedem der Systeme zu testen und zu bewerten. </p><br><p>  Unter den bewerteten Szenarien waren: </p><br><ul><li>  Zweige erstellen und zusammenführen </li><li>  Organisation gemeinsamer Arbeit (in einem oder mehreren Zweigen) </li><li>  Kettenoperationen ändern (Festschreiben, Rückgängig machen) </li><li>  Integration von Drittanbietern </li><li>  Die Möglichkeit, weiter zu arbeiten, wenn der Server nicht verfügbar ist. </li></ul><br><p>  Infolgedessen wurde erwartungsgemäß GIT ausgewählt, und bisher hat es niemand bereut. </p><br><p>  Als Prozess haben wir begonnen, GitFlow zu verwenden.  Dieser Prozess bot genügend Kontrolle über die Änderungen und ermöglichte die Lieferung von Releases, wie wir es gewohnt sind. </p><br><ol><li>  Wir haben den Entwicklungszweig mit einer Richtlinie verteidigt, die verlangt, dass alle Änderungen Pull-Anforderungen durchlaufen. </li><li>  Wir versuchen, die Praxis von "einem Ticket - eine Pull-Anforderung" einzuhalten.  Änderungen von verschiedenen Tickets werden niemals in einer Änderung kombiniert.  Wir versuchen unser Bestes, um den Feature-Zweig zu testen, um die Situation mit Korrekturen bei nachfolgenden Pull-Anforderungen zu vermeiden. </li><li>  Beim Zusammenführen mit Develop werden alle Änderungen zu einem einzigen Commit (Squash) zusammengeführt. </li><li>  Release-Zweige werden aus Develop erstellt. </li><li>  Bei Bedarf können Sie im Release-Zweig die neuesten Änderungen selektiv (Cherry-Pick) oder alle (Rebase) hinzufügen.  Wir führen die Korrektur nicht direkt im Release-Zweig durch. </li><li>  Nach der Bereitstellung der neuesten Version für das Produkt wird es per Push Force an den Master gesendet (nur wenige Personen haben dieses Recht). </li></ol><br><h3 id="avtomatizaciya-sborki-produkta">  Automatisierung der Produktmontage </h3><br><p>  Die Anwendung bestand aus einer großen Anzahl von Baugruppen, Hunderten von Lösungen.  Wie sich während des Prozessaudits herausstellte, wurde dies alles separat und „manuell“ erfasst. <br>  In der ersten Phase haben wir beschlossen, nicht alles von Grund auf neu zu erstellen (um die vorhandene Lieferung nicht zu stoppen), sondern die Assembly in eine Reihe von msbuild-Skripten zu "verpacken" - ein Skript pro Komponente. <br>  So erhielten wir schnell Skripte, die alle notwendigen Zwischenartefakte ausführten, und am Ende das fertige Produkt. </p><br><p>  Eine separate Geschichte ist ein Datenbankdesign.  Leider enthält das System mehrere CLR-Komponenten, die nicht gut strukturiert waren.  Abhängigkeiten erlauben keine einfache Bereitstellungsbasis mit Inhalten.  Derzeit wird dies durch ein Skript vor der Bereitstellung gelöst. <br>  Aufgrund der ungleichmäßigen Systemlandschaft (SQL Server-Versionen 2008 und 2014 wurden an verschiedenen Stellen installiert) war es außerdem erforderlich, die Zusammenstellung des Basisprojekts für die .NET-Versionen 2.0 und 4.0 zu organisieren. </p><br><p>  Nachdem alle Skripte fertig und getestet waren, wurden sie im Build-Skript VSTS verwendet. </p><br><p>  Unmittelbar vor Beginn der Montage wurden die Versionen aller Produkte auf eine gemeinsame Standardnummer aktualisiert, einschließlich der Build-Through-Nummer des Builds.  Die gleiche Nummer wurde im Post-Deployment-Skript gespeichert.  Somit waren alle Komponenten - die Datenbank und alle Clientanwendungen - konsistent und gleich nummeriert. </p><br><h3 id="razvertyvaniya-na-testovyy-stend">  Bereitstellung auf dem Prüfstand </h3><br><p>  Nachdem die erste Version des Erstellungsprozesses abgeschlossen war, haben wir mit der Vorbereitung des Bereitstellungsskripts fortgefahren. </p><br><p>  Es wird erwartet, dass die Datenbank am problematischsten war. </p><br><p>  Die Bereitstellung einer „Top“ -Kopie einer realen Datenbank ergab viele Konflikte zwischen der Assembly und dem Status realer Systeme: </p><br><ul><li>  Inkonsistente Versionen in GIT und im realen System </li><li>  Datenbankschemata von Benutzern, deren Löschung geplant war. </li></ul><br><h3 id="stabilizaciya-processa-razrabotki">  Stabilisierung des Entwicklungsprozesses </h3><br><p>  Natürlich ist es seltsam, darüber zu sprechen und noch mehr hier zu schreiben, aber die schwerwiegendste Änderung für Entwickler war die Einführung des Prinzips "Wenn dies nicht in git ist, existiert es nicht".  Zuvor wurde der Code "zur Berichterstattung an den Kunden" festgeschrieben.  Jetzt - ohne das ist es unmöglich, etwas zu liefern. </p><br><p>  Das Schwierigste war mit dem Datenbankcode.  Nach dem Wechsel zur Bereitstellung der Datenbank aus dem Repository durch Zusammenstellung und Bereitstellung mithilfe von SQL Package wurde der "Delta" -Ansatz durch den "gewünschten Status" -Ansatz ersetzt.  Pakete gehörten der Vergangenheit an, alles musste automatisch bereitgestellt werden. </p><br><p>  Aber!  Bis zum vollständigen Übergang zum neuen Bereitstellungsprozess mussten noch Änderungen bereitgestellt werden.  Und das musste auf die altmodische Art und Weise geschehen - „Delta-Updates“. </p><br><p>  Wir standen vor der Aufgabe, eine vollständige und konstante Konsistenz des Systemzustands bei der Zustellung von Delta-Paketen und des Inhalts des Repositorys sicherzustellen. </p><br><p>  Zu diesem Zweck haben wir den folgenden Prozess organisiert: </p><br><ol><li>  Regelmäßig wurde Code aus dem Repository gesammelt und in einer leeren "Modell" -Datenbank bereitgestellt. </li><li>  Basierend auf der "Modell" -Basis wurde ein spezieller Autotest vorbereitet.  Für jedes Objekt der Modelldatenbank wurden Prüfsummen berechnet.  Der Autotest enthält alle diese Prüfsummen und berechnet beim Start die Prüfsummen der entsprechenden Objekte der "geprüften" Datenbank.  Jede Diskrepanz in der Zusammensetzung von Objekten oder deren Prüfsummen führt zu einem Abfall des Tests. </li><li>  Der "fallende" Test verbot automatisch die Übertragung von Paketen aus der Testumgebung weiter unten in der Landschaft.  Eine solche Integration wurde bereits im vorherigen Verkehrssystem implementiert. </li></ol><br><p>  Mit der automatischen Steuerung war es somit möglich, den Produktdatenbankcode relativ schnell auf den neuesten Stand zu bringen und ohne zusätzlichen Aufwand seitens des Projektteams zu pflegen.  Gleichzeitig gewöhnten sich die Entwickler an die Notwendigkeit, Code korrekt und rechtzeitig in das Repository zu übertragen. </p><br><h3 id="razvertyvanie-produkta-na-okruzheniya-integracionnyh-testov">  Produktbereitstellung in Integrationstestumgebungen </h3><br><p>  Nach Abschluss der vorherigen Phase haben wir die Anwendung direkt in einer Testumgebung bereitgestellt.  Wir haben die Anwendung von Delta-Paketen auf Testsysteme vollständig eingestellt und auf die automatische Bereitstellung mit VSTS umgestellt. </p><br><p>  Von diesem Moment an erhielt das gesamte Team die ersten Früchte der früher aufgewendeten Bemühungen: Der Einsatz erfolgte ohne zusätzliche Anstrengungen.  Benutzerdefinierter Code wurde automatisch erfasst, bereitgestellt und getestet. </p><br><p>  Wie wir später verstanden haben, führte die „Ausrichtung des Repositorys“ leider dazu, dass wir eine Version der stabil unterstützten Version von „Entwickeln“ hatten, aber die Version von „Produktion“ war immer noch nicht verfügbar.  Daher gab es mit QAS und PRD nichts, was über die Testumgebung hinausging. </p><br><p>  Der Anwendungscode auf der Datenbankseite könnte mit dem produktiven Code verglichen werden und die Unterschiede verstehen.  Es gab nichts, mit dem man Clientanwendungen vergleichen konnte - es gab nur eine aktuelle produktive Version in Form einer Reihe ausführbarer Dateien, aus denen sie kompiliert wurden, was man nicht mit Sicherheit sagen konnte. </p><br><h3 id="testirovanie-produkta-kak-rezultata-avtomaticheskoy-sborki">  Testen des Produkts als Ergebnis einer automatischen Montage </h3><br><p>  Nach einer Änderung des Montageansatzes musste das Produkt umfangreichen Regressionstests unterzogen werden.  Es musste sichergestellt werden, dass die Anwendung funktionierte und nichts verloren ging. <br>  Beim Testen stellte sich heraus, dass die Funktionalität auf der Seite der Datenbank einfacher war.  Glücklicherweise haben wir eine Reihe von Autotests entwickelt, die kritische Bereiche abdecken. </p><br><p>  Es gab jedoch keine Tests für C # - daher wurde alles von Hand überprüft.  Dies war ein erheblicher Arbeitsaufwand, und die Überprüfung dauerte einige Zeit. </p><br><h3 id="pryzhok-very---pilotnoe-razvertyvanie-na-produktiv">  Glaubenssprung - produktiver Piloteinsatz </h3><br><p>  Trotz der Tests war die erstmalige Bereitstellung auf einem Produkt beängstigend. </p><br><p>  Wir hatten Glück - wir hatten gerade die nächste Bereitstellung des Systems an einem neuen Standort geplant.  Und wir haben uns entschlossen, diese Chance für einen Piloteinsatz zu nutzen. <br>  Benutzer haben nicht gesehen, mögliche Fehler der neuen Baugruppe waren einfach zu beheben, echte produktive Arbeit hat noch nicht begonnen. </p><br><p>  Wir haben das System bereitgestellt und es befand sich mehrere Wochen lang im vorproduktiven Modus (geringe Last, ein bestimmtes Nutzungsmuster, das im Produkt übersprungen werden kann).  Während dieser Zeit wurden mehrere Fehler entdeckt, die während des Tests übersehen wurden.  Sie wurden korrigiert, als sie gefunden wurden, und die neue Version wurde sofort zur Überprüfung bereitgestellt. </p><br><p>  Nach dem offiziellen Start und einer Woche Support nach dem Start haben wir angekündigt, dass dies das erste Exemplar ist, das "auf neue Weise" zusammengestellt und geliefert wird. </p><br><p>  Diese Version der Assembly wurde zur ersten stabilen Version des Hauptzweigs. Sie wurde mit den Feiertags-Tags "fisrt_deployment" aufgehängt (wir haben keine Symbole mit einem Hash des Commits bestellt). </p><br><h3 id="masshtabirovanie-razvertyvaniya-na-ves-produktivnyy-landshaft">  Skalieren Sie die Bereitstellung in einer gesamten produktiven Landschaft </h3><br><p>  Wie James Bond sagte: "Das zweite Mal ist viel einfacher."  Nach dem Erfolg der Pilotbereitstellung haben wir die verbleibenden Instanzen von Systemen eines ähnlichen Typs schnell verbunden. </p><br><p>  Das System hat jedoch mehrere Verwendungsarten - eine Funktionalität kann für einen Typ verwendet werden und wird in anderen Fällen nicht verwendet.  Dementsprechend garantierte die bei der Implementierung des ersten Typs getestete Funktionalität nicht unbedingt den Erfolg für andere Fälle. </p><br><p>  Um die Funktionalität der verbleibenden Nutzungsarten zu testen, haben wir begonnen, aktive Projekte zu verwenden, die sich in der Entwicklung befinden.  Die Idee war ähnlich und die erste Bereitstellung - wir haben angefangen, automatische Baugruppen zu verwenden, um sie zusammen mit der Entwurfsfunktionalität an die Benutzer weiterzugeben.  So überprüften Benutzer, die mit der "Projekt" -Version des Produkts arbeiteten, gleichzeitig die alte Funktionalität. </p><br><p>  Die Skalierung selbst ergab unerwartete technische Probleme: </p><br><p>  <em>Inhomogene Systemlandschaft</em> <br>  Neben der direkten Bereitstellung der Anwendung mussten wir zunächst darauf achten, dass überall alles gleich war - .NET-Versionen, Powershell und Module.  Es hat ziemlich viel Zeit gekostet. </p><br><p>  <em>Netzwerkverbindung</em> <br>  An einigen Standorten erlaubte die Netzwerkverbindung einfach nicht das Pumpen aller Komponenten der Baugruppe.  Es gab Timeouts, Schäden während der Übertragung.  Wir haben viele Dinge überprüft und ausprobiert - nicht sehr erfolgreich. </p><br><p>  Ich musste mich mit der folgenden Lösung befassen: Das Assemblerskript wurde fertiggestellt, sodass alle Ergebnisse in ein großes Archiv gepackt wurden, das dann in kleine Fragmente (jeweils 2 MB) geschnitten wurde.  Wir haben das Bereitstellungsszenario abgeschlossen, um die Parallelität beim Herunterladen von Artefakten zu beseitigen, alle 2-Megabyte-Fragmente akzeptiert und daraus wiederhergestellt, was bereits erweitert werden kann. </p><br><p>  <em>Konflikt mit Antivirus</em> <br>  Ein weiteres seltsames Problem ist ein Konflikt zwischen Antivirensoftware und einem der Bereitstellungsschritte: Wenn alle Arten von „verdächtigen“ Dateien wie .js, .dll aus Artefaktarchiven extrahiert werden, beginnt das Antivirus, sie genau zu untersuchen.  Und das Seltsamste ist, dass das Antivirenprogramm vor dem Ende des Entpackens auf die Datei stürzt und der Entpackvorgang mit der Meldung "Die Datei wird von einem anderen Prozess belegt" beendet wird.  Wir haben zwar Probleme damit, den lokalen Ordner mit Artefakten vom Scan auszuschließen, aber es ist nicht sehr gut, aber wir haben uns nichts anderes ausgedacht. </p><br><h3 id="uluchshenie-processov">  Prozessverbesserung </h3><br><p>      ,    "   " —   . </p><br><ul><li>        (service-now.com)  VSTS      Work Items.     develop —       . </li><li>  CI   feature .      —        </li><li>            "self-service"      </li><li>         —     .        ,            . </li><li>      :    , CI/CD        ,      </li><li>         (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ) </li><li>   -    (   )     .        —    ,      . </li><li>     VSTS     ,        ,     . </li></ul><br><h1 id="itogi">  Zusammenfassung </h1><br><h3 id="tekuschaya-situaciya">   </h3><br><ul><li>        MS VisualStudio Team Services (   — Azure Devops)  .    — GIT </li><li>          (/) </li><li>    git / GitFlow    . </li><li>   code review    . </li><li>     CI.       ,    feature ,     . </li><li>          . ,           . </li><li>          (  )    —     . -      . </li><li>  -      1 .      -  . </li><li>   ""     . </li></ul><br><h3 id="vremya-po-etapam">    </h3><br><table><thead><tr><th>  Nein, nein. </th><th>   </th><th>  Dauer </th></tr></thead><tbody><tr><td>  1 </td><td>    —     ,        </td><td> 6  </td></tr><tr><td>  2 </td><td>       —       </td><td> 3  </td></tr><tr><td>  3 </td><td>      —       </td><td> 5  </td></tr></tbody></table><br><p>   — 14  </p><br><p> ,    ,    ,     . </p><br><h3 id="trudozatraty">  </h3><br><p>           ,    —  250  * . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427111/">https://habr.com/ru/post/de427111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427097/index.html">Die mobile App hilft, Depressionen und andere psychische Probleme in den frühesten Stadien zu erkennen.</a></li>
<li><a href="../de427101/index.html">Google plant, Herstellern von Mobilgeräten bis zu 40 US-Dollar für jedes verkaufte Gerät in Rechnung zu stellen</a></li>
<li><a href="../de427105/index.html">Lernen zu lernen: Weiterbildung ist der Schlüssel zur Wettbewerbsfähigkeit im Zeitalter der digitalen Wirtschaft</a></li>
<li><a href="../de427107/index.html">Parsim X12 "auf dem Knie"</a></li>
<li><a href="../de427109/index.html">Piraterie im Weltraum - Das Delicious Delta-V und die Hydrogen Stealth Steamboats - Teil 1</a></li>
<li><a href="../de427113/index.html">Programmierbare Gate-Arrays: Wie sie 5G-Netzwerken helfen</a></li>
<li><a href="../de427117/index.html">Tagungsräume basierend auf Asterisk</a></li>
<li><a href="../de427123/index.html">Turing Spiel</a></li>
<li><a href="../de427129/index.html">Threat Intelligence - ein moderner Ansatz zur Informationssicherheit</a></li>
<li><a href="../de427131/index.html">Bekanntschaft mit Audiomania: 15 thematische Materialien zu Produktion, Design, Büro und Business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>