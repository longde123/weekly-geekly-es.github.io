<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏻 ⬆️ 💙 Cómo funciona el aleteo 🏇 🕴🏼 👨‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Cómo funciona realmente Flutter? 


 ¿Qué son los widgets, elementos, BuildContext, RenderOject, Bindings? .. 


 Dificultad: principiante 
 Entrada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo funciona el aleteo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  ¿Cómo funciona realmente Flutter? </p><br><p>  ¿Qué son los widgets, elementos, BuildContext, RenderOject, Bindings? .. </p><br><p>  Dificultad: <em>principiante</em> </p><br><h1 id="vstuplenie">  Entrada </h1><br><p>  El año pasado ( <em>nota: en 2018</em> ), cuando comencé mi viaje al fabuloso mundo de Flutter, había muy poca información en Internet en comparación con lo que es hoy.  Ahora, a pesar del hecho de que muchos materiales ya se han escrito, solo una pequeña parte de ellos habla sobre cómo funciona realmente Flutter. </p><br><p>  ¿Qué son los widgets ( <em>widgets</em> ), elementos ( <em>elementos</em> ), BuildContext?  ¿Por qué es rápido Flutter?  ¿Por qué a veces no funciona como se esperaba?  ¿Qué son los árboles y por qué se necesitan? </p><br><p>  En el 95% de los casos al escribir una aplicación, solo tratará con widgets para mostrar algo o interactuar con él.  Pero, ¿nunca te has preguntado cómo funciona toda esta magia por dentro?  ¿Cómo sabe el sistema cuándo actualizar la pantalla y qué partes deben actualizarse? </p><br><p>  <strong>Contenido:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entrada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: antecedentes</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un poco sobre el dispositivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interfaz entre código y dispositivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrar el renderizado de Flutter Framework Flutter Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RenderView y RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlaces de inicialización</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gesto vinculante</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace de renderizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Encuadernación de widgets</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. De widgets a píxeles</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Configuración inmutable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La estructura jerárquica de los widgets.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bosque detrás de los árboles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elemento de comprensión en un árbol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3 categorías de widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tipos de elementos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funcionan juntos los widgets y los elementos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: gestos de manejo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: animaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Imagen completa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué tan útil puede ser un BuildContext?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por diversión</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusión</a> </li></ul><br><h1 id="chast-1-predystoriya">  Parte 1: antecedentes </h1><br><p>  La primera parte del artículo presenta algunos conceptos clave que se utilizarán en la segunda parte del material y ayudan a comprender mejor Flutter. </p><br><h2 id="nemnogo-ob-ustroystve">  Un poco sobre el dispositivo </h2><br><p>  Comencemos desde el final y volvamos a lo básico. </p><br><p>  Cuando mira su dispositivo o, más precisamente, la aplicación que se ejecuta en su dispositivo, solo ve la pantalla. </p><br><p>  De hecho, todo lo que ves son los píxeles, que juntos forman una imagen bidimensional, y cuando tocas la pantalla con el dedo, el dispositivo solo reconoce la posición de tu dedo en el cristal. </p><br><p>  Toda la magia de la aplicación (desde un punto de vista visual) en la mayoría de los casos es actualizar esta imagen en función de las siguientes interacciones: </p><br><ul><li>  con la pantalla del dispositivo ( <em>por ejemplo, un dedo en el cristal</em> ) </li><li>  con la red ( <em>por ejemplo, comunicación con el servidor</em> ) </li><li>  con el tiempo ( <em>por ejemplo, animación</em> ) </li><li>  con otros sensores externos </li></ul><br><p>  La visualización de la imagen en la pantalla es proporcionada por hardware (pantalla), que regularmente (generalmente 60 veces por segundo) actualiza la pantalla.  Esto se llama "frecuencia de actualización" y se expresa en Hz (Hertz). </p><br><p>  La pantalla recibe información para su visualización desde la GPU (Unidad de procesamiento de gráficos), que es un circuito electrónico especializado optimizado y diseñado para formar rápidamente imágenes a partir de algunos datos (polígonos y texturas).  El número de veces por segundo que el procesador de gráficos puede generar una "imagen" (= búfer de cuadros) para mostrar y enviarlo al hardware se denomina velocidad de cuadros ( <em>nota: velocidad de cuadros</em> ).  Esto se mide usando un bloque de cuadros por segundo ( <em>por ejemplo, 60 cuadros por segundo o 60 fps</em> ). </p><br><p>  Puede preguntarme por qué comencé este artículo con los conceptos de una imagen bidimensional mostrada por una GPU / hardware y un sensor de vidrio físico, y ¿cuál es la conexión con los widgets Flutter normales? </p><br><p>  Creo que será más fácil entender cómo funciona realmente Flutter si lo miramos desde este punto de vista, ya que uno de los objetivos principales de la aplicación Flutter es crear esta imagen bidimensional y permitirle interactuar con ella.  Además, porque en Flutter, lo creas o no, ¡casi todo se debe a la necesidad de actualizar la pantalla rápidamente y en el momento adecuado! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Interfaz entre código y dispositivo </h2><br><p>  De todos modos, todos los interesados ​​en Flutter ya han visto la siguiente imagen que describe la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">arquitectura de alto nivel de</a> Flutter. </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Cuando escribimos una aplicación Flutter usando Dart, permanecemos en el nivel de <em>Marco Flutter</em> (resaltado en verde). </p><br><p>  <em>El Marco de Flutter</em> interactúa con el <em>Motor de Flutter</em> (en azul) a través de una capa de abstracción llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ventana</a> .  Este nivel de abstracción proporciona una serie de API para la interacción indirecta con el dispositivo. </p><br><p>  También a través de este nivel de abstracción, <em>Flutter Engine</em> notifica a <em>Flutter Framework</em> cuando: </p><br><ul><li>  se produce un evento de interés a nivel del dispositivo (cambio de orientación, cambio de configuración, problema de memoria, estado operativo de la aplicación ...) </li><li>  algún evento ocurre a nivel del cristal (= gesto) </li><li>  el canal de la plataforma envía algunos datos </li><li>  pero también principalmente cuando el <strong>Flutter Engine está listo para renderizar un nuevo marco</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Administrar el renderizado de Flutter Framework Flutter Engine </h2><br><p>  Es difícil de creer, pero es verdad.  Excepto en algunos casos ( <em>ver más abajo</em> ), no se ejecuta el código de <em>Flutter Framework</em> sin iniciar el renderizado de <em>Flutter Engine</em> . </p><br><p>  Excepciones: </p><br><ul><li>  Gesto / Gesto (= evento en vidrio) </li><li>  Mensajes de plataforma (= mensajes generados por un dispositivo, como GPS) </li><li>  Mensajes del dispositivo (= mensajes relacionados con un cambio en el estado del dispositivo, por ejemplo, orientación, aplicación enviada en segundo plano, alertas de memoria, configuración del dispositivo ...) </li><li>  Respuestas futuras o http </li></ul><br><p>  <em>(Entre nosotros, puede aplicar un cambio visual sin llamar desde Flutter Engine, pero esto <strong>no</strong> es <strong>recomendable</strong> )</em> </p><br><p>  Me preguntas: "Si se ejecuta algún tipo de código relacionado con el <em>gesto</em> y causa un cambio visual, o si uso un <em>temporizador</em> para establecer la frecuencia de la tarea que conduce a cambios visuales (por ejemplo, animación), ¿cómo funciona?" </p><br><p>  Si desea que se produzca un cambio visual o que se ejecute algún código en función de un temporizador, debe decirle al <em>motor de flutter</em> que debe dibujarse algo. </p><br><p>  Por lo general, la próxima vez que se actualice <em>Flutter Engine</em> , llamará a <em>Flutter Framework</em> para que ejecute algún código y, en última instancia, proporcionará una nueva escena para el renderizado. </p><br><p>  Por lo tanto, una pregunta importante es cómo el motor Flutter organiza todo el comportamiento de la aplicación en función del renderizado. </p><br><p>  Para tener una idea de los mecanismos internos, mire la siguiente animación: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Una breve explicación (más detalles vendrán más adelante): </p><br><ul><li>  Algunos eventos externos (gestos, respuestas http, etc.) o incluso futuros pueden desencadenar tareas que hacen necesario actualizar la pantalla.  El mensaje correspondiente se envía al <em>Flutter Engine</em> (= <em>Marco de programación</em> ) </li><li>  Cuando el <em>motor Flutter está</em> listo para comenzar a actualizar el renderizado, crea una solicitud de inicio de <em>marco</em> </li><li>  Esta solicitud de <em>marco de</em> inicio es interceptada por <em>Flutter Framework</em> , que realiza tareas principalmente relacionadas con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Tickers</a> (por ejemplo, animación) </li><li>  Estas tareas pueden volver a crear la solicitud para su posterior representación (ejemplo: la animación no ha completado su ejecución y, para completarla, necesitará obtener otro <em>Marco de inicio</em> en una etapa posterior) </li><li>  A continuación, <em>Flutter Engine</em> envía un <em>cuadro de dibujo</em> , que es interceptado por <em>Flutter Framework</em> , que buscará cualquier tarea relacionada con la actualización del diseño en términos de estructura y tamaño. </li><li>  Después de completar todas estas tareas, continúa con las tareas asociadas con la actualización del diseño en términos de representación </li><li>  Si hay algo en la pantalla que necesita dibujarse, se envía una nueva escena ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Escena</a> ) para visualización al <em>Flutter Engine</em> , que actualizará la pantalla </li><li>  El <em>Flutter Framework</em> realiza todas las tareas que se realizarán después de la representación (= devoluciones de llamada PostFrame), y cualquier otra tarea posterior que no esté relacionada con la representación </li><li>  ... y este proceso comienza de nuevo </li></ul><br><h2 id="renderview-i-renderobject">  RenderView y RenderObject </h2><br><p>  Antes de sumergirse en los detalles del flujo de trabajo, es hora de presentar el concepto del <em>árbol de renderizado</em> . </p><br><p>  Como se mencionó anteriormente, todo se convertirá eventualmente en píxeles que se mostrarán en la pantalla, y el <em>Marco Flutter</em> convertirá los <em>Widgets</em> que usamos para desarrollar la aplicación en bloques visuales que se mostrarán en la pantalla. </p><br><p>  Estas partes visuales corresponden a objetos llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RenderObject</a> , que se utilizan para: </p><br><ul><li>  definir un área determinada de la pantalla en términos de tamaño, posición, geometría, así como en términos de <em>"contenido renderizado"</em> </li><li>  Identificar áreas de la pantalla que pueden verse afectadas por los gestos (= tocar con el dedo) </li></ul><br><p>  Un conjunto de todos los <em>RenderObjects</em> forma un árbol llamado <em>Render Tree</em> .  En la parte superior de este árbol (= <em>raíz</em> ) encontramos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> proporciona una superficie común para los objetos de <em>Render Tree</em> y es una versión especial de <em>RenderObject</em> . </p><br><p>  Visualmente, podríamos representar todo esto de la siguiente manera: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  La relación entre <em>Widget</em> y <em>RenderObject</em> se discutirá más adelante.  Mientras tanto, es hora de ir un poco más profundo ... </p><br><h2 id="inicializaciya-bindings">  Enlaces de inicialización </h2><br><p> Cuando se inicia la aplicación Flutter, primero se llama a la función <code>main()</code> , que finalmente llama al <code>runApp(Widget app)</code> . </p><br><p>  Cuando se <code>runApp()</code> método <code>runApp()</code> <em>Marco de Flutter</em> inicializa las interfaces entre sí mismo y el <em>Motor de Flutter</em> .  Estas interfaces se denominan <strong>enlaces</strong> ( <em>nota: enlaces</em> ). </p><br><p>  <strong>Introducción a los enlaces</strong> </p><br><p>  Los enlaces están diseñados para ser el enlace entre el marco y el motor Flutter.  Solo a través de enlaces se pueden intercambiar datos entre <em>Flutter Framework</em> y <em>Flutter Engine</em> . <br>  <em>(Solo hay una excepción a esta regla:</em> RenderView <em>, pero lo discutiremos más adelante).</em> </p><br><p>  Cada enlace es responsable de procesar un conjunto de tareas, acciones, eventos específicos, agrupados por área de actividad. </p><br><p>  Al momento de escribir este artículo, el <em>Marco Flutter</em> tiene 8 enlaces. </p><br><p>  A continuación hay 4 de ellos que serán considerados en este artículo: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Gesto vinculante</em> </li><li>  <em>Enlace de renderizador</em> </li><li>  <em>Encuadernación de widgets</em> </li></ul><br><p>  Para completar, mencionaré los 4 restantes: </p><br><ul><li>  <em>ServicesBinding</em> : responsable de procesar los mensajes enviados por el <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">canal de</a></em> la <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">plataforma</a></em> </li><li>  <em>PaintingBinding</em> : responsable de procesar el caché de imágenes </li><li>  <em>Enlace semántico</em> : reservado para la implementación posterior de todo lo relacionado con la semántica </li><li>  <em>TestWidgetsFlutterBinding</em> : utilizado por la biblioteca de prueba de widgets </li></ul><br><p>  También puede mencionar <em>WidgetsFlutterBinding</em> , pero esto no es realmente un enlace, sino más bien un tipo de <em>"inicializador de enlace"</em> . </p><br><p>  El siguiente diagrama muestra la interacción entre los enlaces, que voy a considerar a continuación, y el <em>motor Flutter</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Veamos cada uno de estos enlaces "centrales". </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Este enlace tiene dos responsabilidades principales: </p><br><ul><li>  Di <em>Flutter Engine</em> : <em>"¡Hey! La próxima vez que no estés ocupado, despiértame para que pueda trabajar un poco y decirte qué hacer, o si necesito que me llames más tarde ..."</em> </li><li>  Escuche y responda a tales <em>"despertares perturbadores"</em> (ver más abajo) </li></ul><br><p>  ¿Cuándo <em>SchedulerBinding</em> solicita una <em>llamada de atención</em> ? </p><br><ul><li><p>  Cuando <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ticker</a></em> debe <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">resolver</a></em> <em>un</em> nuevo <em>tic</em> </p><br><p>  Por ejemplo, tienes una animación, la comienzas.  La animación se recorta utilizando el <em>Ticker</em> , que se llama a intervalos regulares (= <em>tick</em> ) para realizar una <em>devolución de llamada</em> .  Para iniciar una <em>devolución de llamada de este tipo</em> , debemos informarle al <em>motor de flutter</em> para que nos despierte durante la próxima actualización (= <em>marco</em> inicial).  Esto iniciará la devolución de llamada de <em>ticker</em> para completar su tarea.  Si el <em>ticker</em> aún necesita continuar la ejecución, al final de su tarea, llamará a <em>SchedulerBinding</em> para programar otro marco. </p><br></li><li><p>  Cuándo actualizar la pantalla </p><br><p>  Por ejemplo, necesitamos resolver un evento que conduzca a un cambio visual (ejemplo: actualizar el color de una parte de la pantalla, desplazarse, agregar / eliminar algo de la pantalla), para esto debemos seguir los pasos necesarios para mostrar la imagen actualizada en la pantalla.  En este caso, cuando se produce dicho cambio, el <em>Marco de Flutter</em> llama a <em>SchedulerBinding</em> para programar otro marco utilizando el <em>Motor de Flutter</em> .  <em>(Más adelante veremos cómo funciona esto)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Gesto vinculante </h3><br><p>  Este enlace escucha la interacción con el motor en términos del <em>"dedo"</em> (= <em>gesto</em> ). </p><br><p>  En particular, es responsable de recibir datos relacionados con los <em>dedos</em> y de determinar con qué parte (s) de la pantalla trabajan los gestos.  Luego notifica en consecuencia / de estas partes. </p><br><h3 id="rendererbinding">  Enlace de renderizador </h3><br><p>  Este enlace es el enlace entre el <em>motor Flutter</em> y el <em>árbol de renderizado</em> .  Ella es responsable de: </p><br><ul><li>  escuchar eventos generados por el motor para informar sobre los cambios aplicados por el usuario a través de la configuración del dispositivo que afecta los efectos visuales y / o semánticos </li><li>  mensaje al motor sobre los cambios que se aplicarán a la pantalla </li></ul><br><p>  Para proporcionar los cambios que se mostrarán en la pantalla, <em>RendererBinding</em> es responsable de administrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">PipelineOwner</a> e inicializar <strong>RenderView</strong> . </p><br><p>  <em>PipelineOwner</em> es un tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">orquesta</a> que sabe lo que se debe hacer con <em>RenderObject</em> de acuerdo con el <em>componente</em> y coordina estas acciones. </p><br><h3 id="widgetsbinding">  Encuadernación de widgets </h3><br><p>  Este enlace escucha los cambios aplicados por el usuario a través de la configuración del dispositivo que afecta el idioma (= <em>localidad</em> ) y la <em>semántica</em> . </p><br><blockquote>  <em>Pequeña nota</em> <br><br>  <em>Supongo que en una etapa posterior en el desarrollo de</em> Flutter, <em>todos los eventos relacionados con la</em> semántica <em>se transferirán a</em> SemanticsBinding <em>, pero en el momento de escribir este artículo, este no es el caso.</em> </blockquote><p>  Además, <em>WidgetsBinding</em> es el enlace entre widgets y <em>Flutter Engine</em> .  Ella es responsable de: </p><br><ul><li>  gestión del proceso de procesamiento de cambios en la estructura de widgets </li><li>  hacer una llamada </li></ul><br><p>  El procesamiento de los cambios en la estructura de los widgets se realiza con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> realiza un seguimiento de qué widgets deben reconstruirse y maneja otras tareas que se aplican a la estructura del widget en su conjunto. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Parte 2. De widgets a píxeles </h1><br><p>  Ahora que hemos aprendido los conceptos básicos del trabajo interno de <em>Flutter</em> , es hora de hablar sobre widgets. </p><br><p>  En toda la documentación de Flutter leerá que todos los <em>Widgets</em> (widgets). </p><br><p>  Esto es casi correcto.  Pero para ser un poco más preciso, prefiero decir: </p><br><blockquote>  Del lado del desarrollador, todo lo relacionado con la interfaz de usuario en términos de diseño e interacción se realiza mediante widgets. </blockquote><p>  ¿Por qué tanta precisión?  Además del hecho de que <em>Widget</em> permite al desarrollador determinar parte de la pantalla en términos de tamaño, contenido, diseño e interacción, <strong>PERO</strong> hay mucho más.  Entonces, ¿qué es realmente <em>Widget</em> ? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Configuración inmutable </h2><br><p>  Si observa el código fuente de <em>Flutter</em> , notará la siguiente definición de la clase <em>Widget</em> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  ¿Qué significa esto? </p><br><p>  La anotación <strong>"@immutable" es</strong> muy importante y nos dice que <strong>cualquier variable en la clase Widget debe ser FINAL</strong> , en otras palabras: "definida y asignada <strong>UNA VEZ PARA TODOS</strong> ".  Por lo tanto, después de crear una instancia, Widget ya no podrá cambiar sus variables internas. </p><br><blockquote>  <em>Como Widget es inmutable, puede considerarse una configuración estática.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  La estructura jerárquica de los widgets. </h2><br><p>  Cuando diseña con Flutter, define la estructura de su (s) pantalla (s) utilizando widgets como este: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  Este ejemplo utiliza 7 widgets que juntos forman una estructura jerárquica.  Un esquema muy simplificado basado en este código es el siguiente: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Como puede ver, el diagrama presentado se parece a un árbol, donde <em>SafeArea</em> es su raíz. </p><br><h2 id="les-za-derevyami">  Bosque detrás de los árboles </h2><br><p>  Como ya sabe, un widget en sí mismo puede ser una agregación de otros widgets.  Como ejemplo, puede modificar el código anterior de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Esta opción supone que el widget <em>"MyOwnWidget" en</em> sí mostrará <em>SafeArea</em> , <em>Scaffold</em> .  Pero lo más importante en este ejemplo es que </p><br><blockquote>  <em>Un widget</em> puede representar una hoja, un nudo en un árbol, incluso el árbol mismo o, por qué no, un bosque de árboles ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  <em>Elemento de</em> comprensión en un árbol </h2><br><p>  ¿Qué tiene esto que ver con eso? </p><br><p>  Como se mostrará más adelante, para poder generar píxeles que componen la imagen que se muestra en el dispositivo, <em>Flutter</em> debe conocer en detalle todas las partes pequeñas que componen la pantalla, y para determinar todas las partes, necesita conocer la <strong>expansión de</strong> todos los widgets. </p><br><p>  Para ilustrar este punto, considere el principio de una muñeca anidada: cuando está cerrado, solo ve 1 muñeca, pero contiene otra, que a su vez contiene otra y así sucesivamente ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Cuando <em>Flutter</em> expande todos los widgets <em>(parte de la pantalla)</em> , será como obtener todas las muñecas <em>(parte del todo)</em> . </p><br><p>  La siguiente imagen muestra parte de la estructura jerárquica final de los widgets correspondientes al código anterior.  En amarillo, destaqué los widgets que se mencionaron en el código anteriormente, para que pueda definirlos en el árbol final. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Aclaraciones importantes</em></strong> <br><br>  <em>El lenguaje "Árbol de widgets" existe solo para facilitar la comprensión, ya que los programadores usan widgets, ¡pero NO hay un árbol de widgets en Flutter!</em> <br><br>  <em>De hecho, sería más correcto decir "árbol de elementos"</em> </blockquote><p>  Es hora de presentar el concepto de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">elemento</a> . </p><br><blockquote>  <em><strong>Cada</strong> widget tiene <strong>un</strong> elemento.</em>  <em>Los elementos están conectados entre sí y forman un árbol.</em>  <em>Por lo tanto, <strong>un elemento</strong> es una referencia a algo en el árbol.</em> </blockquote><p>  Para empezar, piense en un elemento como un nodo que tiene un padre y posiblemente un hijo.  Al vincularlos a través de una relación <em>padre-hijo</em> , obtenemos una estructura de árbol. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Como puede ver, el elemento apunta a un widget y también <strong>puede</strong> apuntar a un <em>RenderObject</em> . </p><br><blockquote>  <em>Aún mejor ... ¡Element señala a Widget que <strong>creó</strong> este Element!</em> </blockquote><p>  Resumamos: </p><br><ul><li>  No hay un árbol de widgets, pero hay un árbol de elementos. </li><li>  Los elementos son creados por widgets. </li><li>  El elemento se refiere al widget que lo creó. </li><li>  Elementos vinculados a las relaciones entre padres </li><li>  Un artículo puede tener un "bebé". </li><li>  Los elementos también pueden apuntar a un <em>RenderObject.</em> </li></ul><br><blockquote>  <em><strong>Los elementos</strong> determinan cómo las partes de los bloques mostrados están relacionadas entre sí.</em> </blockquote><p>  Para imaginar mejor dónde encaja el concepto de <em>un elemento</em> , veamos la siguiente representación visual: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Como puede ver, el árbol de elementos es la relación real entre widgets y <em>RenderObjects</em> . </p><br><p>  Pero, ¿por qué <em>Widget</em> crea un <em>elemento</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 categorías de widgets </h2><br><p>  En Flutter, los widgets se dividen en 3 categorías, personalmente los llamo de la siguiente manera <em>(pero esta es solo mi forma de clasificarlos)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  La tarea principal de estos widgets es almacenar cierta información (que debería ser accesible para los widgets), parte de la estructura de árbol basada en Proxy.  Un ejemplo de tales widgets es <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">InheritedWidget</a></strong> o <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Estos widgets no participan directamente en la formación de la interfaz de usuario, pero se utilizan para obtener la información que pueden proporcionar. </p><br></li><li><p>  Renderizador </p><br><p>  Estos widgets están directamente relacionados con el diseño de la pantalla, ya que determinan (o se utilizan para determinar) el <em>tamaño</em> , la <em>posición</em> y la <em>representación</em> .  Los ejemplos típicos son: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Fila</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Columna</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Pila</a></strong> , así como <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Relleno</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Alinear</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Opacidad</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Componente </p><br><p>  Estos son otros widgets que proporcionan directamente no la información final relacionada con los tamaños, las posiciones, la apariencia, sino los datos (o consejos) que se utilizarán para obtener la información final.  Estos widgets se conocen comúnmente como componentes. </p><br><p>  Ejemplos: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Este archivo PDF</a> enumera la mayoría de los widgets agrupados por categoría. </p><br><p>  ¿Por qué es importante esta separación?  Porque dependiendo de la categoría del widget, el tipo de elemento correspondiente está asociado con ... </p><br><h2 id="tipy-elementov">  Tipos de elementos </h2><br><p>  Hay varios tipos de elementos: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Como puede ver en la imagen de arriba, los elementos se dividen en 2 tipos principales: </p><br><ul><li><p>  Componente </p><br><p>  Estos elementos no <strong>son directamente</strong> responsables de representar ninguna parte de la pantalla. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Estos elementos son responsables de partes de la imagen mostrada en la pantalla. </p><br></li></ul><br><p>  Genial  Tanta información, pero ¿cómo se relaciona todo esto entre sí y por qué es interesante hablar de ello? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Cómo funcionan juntos los widgets y los elementos </h2><br><blockquote>  <em>En Flutter, toda la mecánica se basa en invalidar un elemento o renderObject.</em> </blockquote><p>  La invalidación de elementos se puede hacer de las siguientes maneras: </p><br><ul><li>  usando <code>setState</code> , que invalida todo el <strong>StatefulElement</strong> (tenga en cuenta que intencionalmente no digo <em>StatefulWidget</em> ) </li><li>  mediante notificaciones procesadas por <strong>proxyElement</strong> (por ejemplo, InheritedWidget), que invalida cualquier <em>elemento</em> que dependa de este <em>proxyElement</em> </li></ul><br><p>  El resultado de la <em>invalidación</em> es que aparece un enlace al <em>elemento</em> correspondiente en la lista de elementos <strong>sucios</strong> . </p><br><p>  La <em>invalidación de renderObject</em> significa que la estructura de los elementos no cambia en absoluto, pero hay un cambio en el nivel de <em>renderObject</em> , por ejemplo: </p><br><ul><li>  cambiando su tamaño, posición, geometría ... </li><li>  algo necesita ser repintado, por ejemplo, cuando solo cambia el color de fondo, el estilo de fuente ... </li></ul><br><p>  El resultado de dicha <em>invalidación</em> es un enlace al <em>renderObject</em> correspondiente en la lista de objetos de renderizado <em>(renderObjects)</em> que necesitan ser reconstruidos o repintados. </p><br><p>  Independientemente del tipo de invalidación, se llama a <strong>SchedulerBinding</strong> (¿recuerda esto?) Para solicitar al <strong>Flutter Engine</strong> que programe un nuevo marco. </p><br><p>  Este es exactamente el momento en que el <em>motor Flutter</em> "despierta" el <em>SchedulerBinding</em> y sucede toda la magia ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Anteriormente en este artículo, notamos que <em>SchedulerBinding tiene</em> dos responsabilidades principales, una de las cuales es la disposición a manejar las solicitudes hechas por <em>Flutter Engine</em> relacionadas con la reconstrucción de marcos.  Este es el momento perfecto para enfocarse en esto. </p><br><p>  El siguiente diagrama de secuencia parcial muestra lo que sucede cuando <em>SchedulerBinding</em> recibe una solicitud <em>onDrawFrame ()</em> de <em>Flutter Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Paso 1. Elementos</strong> </p><br><p>  Se <em>llama WidgetsBinding</em> , y este enlace primero considera los cambios asociados con los elementos.  <em>WidgetsBinding</em> llama al método <em>buildScope del</em> objeto <em>buildOwner</em> , ya que <strong>BuildOwner</strong> es responsable de procesar el árbol de elementos.  Este método revisa la lista de elementos <em>sucios</em> y solicita su <strong>reconstrucción</strong> . </p><br><p>  Los principios principales de este método de <code>rebuild()</code> ) son: </p><br><ol><li>  Hay una solicitud para reconstruir el elemento (esto llevará la mayor parte del tiempo), llamando al método <code>build()</code> del widget al que se refiere este elemento <code>build()</code> método = = <code>Widget build (BuildContext context) {...}</code> ).  Este método <code>build()</code> devolverá un nuevo widget </li><li>  Si el elemento no tiene "hijos", se crea un elemento para el nuevo widget (ver más abajo) ( <em>nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">inflateWidget</a></em> ), de lo contrario </li><li>  el nuevo widget se compara con el referenciado por el elemento secundario del elemento <br><ul><li>  Si son intercambiables (= <em>el mismo tipo de widget y clave</em> ), se produce la actualización y se guarda el elemento secundario. </li><li>  Si no son intercambiables, el niño se descarta ( <em>~ se descarta</em> ) y se crea un elemento para el nuevo widget </li></ul></li><li>  Este nuevo elemento se monta como elemento secundario del elemento.  ( <em>montado)</em> = insertado en el árbol de elementos) </li></ol><br><p>  La siguiente animación intentará hacer esta explicación un poco más clara. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Nota sobre widgets y elementos</strong> </p><br><p>  Para un nuevo widget, se crea un elemento de un <em>tipo específico</em> que corresponde a <em>la categoría del</em> widget, a saber: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Cada uno de estos tipos de elementos tiene su propio comportamiento.  Por ejemplo: </p><br><ul><li>  <em>StatefulElement</em> llamará al método <code>widget.createState()</code> en la inicialización, lo que creará un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">estado</a> y lo asociará con el elemento </li><li>  Cuando <em>se</em> monta un elemento de tipo <em>RenderObjectElement</em> , se crea un <em>RenderObject</em> .  Este <em>renderObject</em> se agregará al <em>Render Tree</em> y se asociará con el elemento. </li></ul><br><p>  <strong>Paso 2. renderObjects</strong> </p><br><p>  Ahora, después de completar todas las acciones asociadas con elementos <em>sucios</em> , el <em>Árbol de elementos</em> es estable.  Es hora de considerar el proceso de visualización. </p><br><p>  Dado que <em>RendererBinding</em> es responsable de renderizar el <em>Render Tree</em> , <em>WidgetsBinding</em> llama al método <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p>  El siguiente diagrama parcial muestra la secuencia de acciones realizadas durante la solicitud <em>drawFrame ()</em> . </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  En este paso, se realizan las siguientes acciones: </p><br><ul><li>  Cada <em>renderObject</em> marcado como <em>sucio</em> debe componerlo (es decir, calcular su tamaño y geometría) </li><li>  Cada <em>renderObject</em> marcado como "necesita volver a dibujar" se vuelve a dibujar utilizando su propio método de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">capa</a> </li><li>  La escena resultante se forma y se envía al <em>Flutter Engine</em> , para que este último lo transfiera a la pantalla del dispositivo. </li><li>  Finalmente, la semántica también se actualiza y se envía al <em>Flutter Engine.</em> </li></ul><br><p>  Al final de este flujo de trabajo, la pantalla del dispositivo se actualiza. </p><br><h1 id="chast-3-obrabotka-zhestov">  Parte 3: gestos de manejo </h1><br><p>  Los gestos (= <em>eventos relacionados con las acciones de los dedos en el cristal</em> ) se procesan utilizando <em>GestureBinding</em> . </p><br><p>  Cuando <em>Flutter Engine</em> envía información sobre un evento de gesto a través de la API <em>window.onPointerDataPacket</em> , <strong>GestureBinding lo</strong> intercepta, realiza un almacenamiento en búfer y: </p><br><ol><li>  convierte las coordenadas proporcionadas por <em>Flutter Engine</em> para que coincidan con la <strong>relación de píxeles</strong> del <strong>dispositivo</strong> , y luego </li><li>  recupera de <em>render Vea una</em> lista de todos los <em>RenderObjects</em> que están en la parte de la pantalla relacionada con las coordenadas del evento </li><li>  luego recorre la lista resultante de <em>renderObjects</em> y envía un evento relacionado a cada uno de ellos </li><li>  si <em>renderObject</em> "escucha" eventos de este tipo, lo procesa </li></ol><br><p>  Con suerte, ahora entiendo lo importante que <em>es renderObjects</em> . </p><br><h1 id="chast-4-animacii">  Parte 4: animaciones </h1><br><p>  Esta parte del artículo trata sobre el concepto de <strong>animación</strong> y una comprensión profunda de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p>  Cuando trabaja con animaciones, generalmente usa un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">AnimationController</a> o cualquier widget para animaciones ( <em>nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  En <em>Flutter,</em> todo lo relacionado con animaciones se refiere a <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ticker</a></em> .  <em>Ticker</em> , cuando está activo, solo tiene una tarea: "le pide a <em>SchedulerBinding que</em> registre una devolución de llamada y le dice al <em>Flutter Engine</em> que la active cuando aparezca una nueva devolución de llamada".  Cuando <em>Flutter Engine está</em> listo, llama a <em>SchedulerBinding a</em> través de una solicitud: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> accede a la lista de devolución de llamada de <em>ticker</em> y ejecuta cada una. </p><br><p>  Cada <em>tic es</em> interceptado por un controlador "interesado" para procesarlo.  Si la animación está completa, el <em>ticker está</em> "deshabilitado", de lo contrario, el <em>ticker</em> solicita un <em>SchedulerBinding</em> para programar una nueva devolución de llamada.  Y así sucesivamente ... </p><br><h1 id="polnaya-kartina">  Imagen completa </h1><br><p>  Ahora hemos aprendido cómo funciona <em>Flutter</em> : </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Finalmente, regrese al diagrama que muestra los diferentes tipos de elementos y considere la firma del <em>Elemento</em> raíz: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  ¡Vemos el famoso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">BuildContext</a> !  Pero que es eso? </p><br><p>  <strong>BuildContext</strong> es una interfaz que define una serie de captadores y métodos que un elemento puede implementar.  Mayormente <em>BuildContext se</em> usa en el método <code>build()</code> de <em>StatelessWidget</em> o <em>State</em> for <em>StatefulWidget</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> no es más que el <strong>Elemento en</strong> sí, que coincide</em> <br><ul><li>  <em>widget que se actualiza (dentro de los métodos de <code>build</code> o <code>builder</code> )</em> </li><li>  <em>StatefulWidget asociado con el <strong>estado</strong> en el que hace referencia a la variable de contexto.</em> </li></ul><br></blockquote><p>  Esto significa que la mayoría de los desarrolladores trabajan constantemente con elementos sin siquiera saberlo. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  ¿Qué tan útil puede ser un BuildContext? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> …) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> –  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    – ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Conclusión </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476018/">https://habr.com/ru/post/476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476000/index.html">Actualizaciones de ML.NET Model Builder</a></li>
<li><a href="../476002/index.html">Experiencia en encontrar un puesto de estudiante de doctorado en Alemania</a></li>
<li><a href="../476004/index.html">Gerente de proyecto: ¿mito o realidad? ¿O por qué se necesita en el campo de los efectos visuales?</a></li>
<li><a href="../476006/index.html">Mitos y leyendas de los constructores de SOC, o 3 conceptos erróneos sobre los centros para monitorear y responder a los ataques cibernéticos</a></li>
<li><a href="../476008/index.html">Meetup de MOSDROID: conéctate a la transmisión</a></li>
<li><a href="../476022/index.html">Vue Storefront: elevando el backend</a></li>
<li><a href="../476024/index.html">La mejor arquitectura para MVP: monolito, SOA, microservicios o sin servidor ... Parte 1</a></li>
<li><a href="../476026/index.html">Cool Life Hacks para trabajar con WSL (Windows Subsystem for Linux)</a></li>
<li><a href="../476032/index.html">Brunner Elektronik: del sistema CAD a la cabina</a></li>
<li><a href="../476034/index.html">El más indefenso es el halcón peregrino.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>