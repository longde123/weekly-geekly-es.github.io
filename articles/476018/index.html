<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèª ‚¨ÜÔ∏è üíô C√≥mo funciona el aleteo üèá üï¥üèº üë®‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øC√≥mo funciona realmente Flutter? 


 ¬øQu√© son los widgets, elementos, BuildContext, RenderOject, Bindings? .. 


 Dificultad: principiante 
 Entrada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona el aleteo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  ¬øC√≥mo funciona realmente Flutter? </p><br><p>  ¬øQu√© son los widgets, elementos, BuildContext, RenderOject, Bindings? .. </p><br><p>  Dificultad: <em>principiante</em> </p><br><h1 id="vstuplenie">  Entrada </h1><br><p>  El a√±o pasado ( <em>nota: en 2018</em> ), cuando comenc√© mi viaje al fabuloso mundo de Flutter, hab√≠a muy poca informaci√≥n en Internet en comparaci√≥n con lo que es hoy.  Ahora, a pesar del hecho de que muchos materiales ya se han escrito, solo una peque√±a parte de ellos habla sobre c√≥mo funciona realmente Flutter. </p><br><p>  ¬øQu√© son los widgets ( <em>widgets</em> ), elementos ( <em>elementos</em> ), BuildContext?  ¬øPor qu√© es r√°pido Flutter?  ¬øPor qu√© a veces no funciona como se esperaba?  ¬øQu√© son los √°rboles y por qu√© se necesitan? </p><br><p>  En el 95% de los casos al escribir una aplicaci√≥n, solo tratar√° con widgets para mostrar algo o interactuar con √©l.  Pero, ¬ønunca te has preguntado c√≥mo funciona toda esta magia por dentro?  ¬øC√≥mo sabe el sistema cu√°ndo actualizar la pantalla y qu√© partes deben actualizarse? </p><br><p>  <strong>Contenido:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entrada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: antecedentes</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un poco sobre el dispositivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interfaz entre c√≥digo y dispositivo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrar el renderizado de Flutter Framework Flutter Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RenderView y RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlaces de inicializaci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gesto vinculante</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace de renderizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Encuadernaci√≥n de widgets</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. De widgets a p√≠xeles</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Configuraci√≥n inmutable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La estructura jer√°rquica de los widgets.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bosque detr√°s de los √°rboles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elemento de comprensi√≥n en un √°rbol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3 categor√≠as de widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tipos de elementos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funcionan juntos los widgets y los elementos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: gestos de manejo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: animaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Imagen completa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© tan √∫til puede ser un BuildContext?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por diversi√≥n</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> </li></ul><br><h1 id="chast-1-predystoriya">  Parte 1: antecedentes </h1><br><p>  La primera parte del art√≠culo presenta algunos conceptos clave que se utilizar√°n en la segunda parte del material y ayudan a comprender mejor Flutter. </p><br><h2 id="nemnogo-ob-ustroystve">  Un poco sobre el dispositivo </h2><br><p>  Comencemos desde el final y volvamos a lo b√°sico. </p><br><p>  Cuando mira su dispositivo o, m√°s precisamente, la aplicaci√≥n que se ejecuta en su dispositivo, solo ve la pantalla. </p><br><p>  De hecho, todo lo que ves son los p√≠xeles, que juntos forman una imagen bidimensional, y cuando tocas la pantalla con el dedo, el dispositivo solo reconoce la posici√≥n de tu dedo en el cristal. </p><br><p>  Toda la magia de la aplicaci√≥n (desde un punto de vista visual) en la mayor√≠a de los casos es actualizar esta imagen en funci√≥n de las siguientes interacciones: </p><br><ul><li>  con la pantalla del dispositivo ( <em>por ejemplo, un dedo en el cristal</em> ) </li><li>  con la red ( <em>por ejemplo, comunicaci√≥n con el servidor</em> ) </li><li>  con el tiempo ( <em>por ejemplo, animaci√≥n</em> ) </li><li>  con otros sensores externos </li></ul><br><p>  La visualizaci√≥n de la imagen en la pantalla es proporcionada por hardware (pantalla), que regularmente (generalmente 60 veces por segundo) actualiza la pantalla.  Esto se llama "frecuencia de actualizaci√≥n" y se expresa en Hz (Hertz). </p><br><p>  La pantalla recibe informaci√≥n para su visualizaci√≥n desde la GPU (Unidad de procesamiento de gr√°ficos), que es un circuito electr√≥nico especializado optimizado y dise√±ado para formar r√°pidamente im√°genes a partir de algunos datos (pol√≠gonos y texturas).  El n√∫mero de veces por segundo que el procesador de gr√°ficos puede generar una "imagen" (= b√∫fer de cuadros) para mostrar y enviarlo al hardware se denomina velocidad de cuadros ( <em>nota: velocidad de cuadros</em> ).  Esto se mide usando un bloque de cuadros por segundo ( <em>por ejemplo, 60 cuadros por segundo o 60 fps</em> ). </p><br><p>  Puede preguntarme por qu√© comenc√© este art√≠culo con los conceptos de una imagen bidimensional mostrada por una GPU / hardware y un sensor de vidrio f√≠sico, y ¬øcu√°l es la conexi√≥n con los widgets Flutter normales? </p><br><p>  Creo que ser√° m√°s f√°cil entender c√≥mo funciona realmente Flutter si lo miramos desde este punto de vista, ya que uno de los objetivos principales de la aplicaci√≥n Flutter es crear esta imagen bidimensional y permitirle interactuar con ella.  Adem√°s, porque en Flutter, lo creas o no, ¬°casi todo se debe a la necesidad de actualizar la pantalla r√°pidamente y en el momento adecuado! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Interfaz entre c√≥digo y dispositivo </h2><br><p>  De todos modos, todos los interesados ‚Äã‚Äãen Flutter ya han visto la siguiente imagen que describe la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">arquitectura de alto nivel de</a> Flutter. </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Cuando escribimos una aplicaci√≥n Flutter usando Dart, permanecemos en el nivel de <em>Marco Flutter</em> (resaltado en verde). </p><br><p>  <em>El Marco de Flutter</em> interact√∫a con el <em>Motor de Flutter</em> (en azul) a trav√©s de una capa de abstracci√≥n llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ventana</a> .  Este nivel de abstracci√≥n proporciona una serie de API para la interacci√≥n indirecta con el dispositivo. </p><br><p>  Tambi√©n a trav√©s de este nivel de abstracci√≥n, <em>Flutter Engine</em> notifica a <em>Flutter Framework</em> cuando: </p><br><ul><li>  se produce un evento de inter√©s a nivel del dispositivo (cambio de orientaci√≥n, cambio de configuraci√≥n, problema de memoria, estado operativo de la aplicaci√≥n ...) </li><li>  alg√∫n evento ocurre a nivel del cristal (= gesto) </li><li>  el canal de la plataforma env√≠a algunos datos </li><li>  pero tambi√©n principalmente cuando el <strong>Flutter Engine est√° listo para renderizar un nuevo marco</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Administrar el renderizado de Flutter Framework Flutter Engine </h2><br><p>  Es dif√≠cil de creer, pero es verdad.  Excepto en algunos casos ( <em>ver m√°s abajo</em> ), no se ejecuta el c√≥digo de <em>Flutter Framework</em> sin iniciar el renderizado de <em>Flutter Engine</em> . </p><br><p>  Excepciones: </p><br><ul><li>  Gesto / Gesto (= evento en vidrio) </li><li>  Mensajes de plataforma (= mensajes generados por un dispositivo, como GPS) </li><li>  Mensajes del dispositivo (= mensajes relacionados con un cambio en el estado del dispositivo, por ejemplo, orientaci√≥n, aplicaci√≥n enviada en segundo plano, alertas de memoria, configuraci√≥n del dispositivo ...) </li><li>  Respuestas futuras o http </li></ul><br><p>  <em>(Entre nosotros, puede aplicar un cambio visual sin llamar desde Flutter Engine, pero esto <strong>no</strong> es <strong>recomendable</strong> )</em> </p><br><p>  Me preguntas: "Si se ejecuta alg√∫n tipo de c√≥digo relacionado con el <em>gesto</em> y causa un cambio visual, o si uso un <em>temporizador</em> para establecer la frecuencia de la tarea que conduce a cambios visuales (por ejemplo, animaci√≥n), ¬øc√≥mo funciona?" </p><br><p>  Si desea que se produzca un cambio visual o que se ejecute alg√∫n c√≥digo en funci√≥n de un temporizador, debe decirle al <em>motor de flutter</em> que debe dibujarse algo. </p><br><p>  Por lo general, la pr√≥xima vez que se actualice <em>Flutter Engine</em> , llamar√° a <em>Flutter Framework</em> para que ejecute alg√∫n c√≥digo y, en √∫ltima instancia, proporcionar√° una nueva escena para el renderizado. </p><br><p>  Por lo tanto, una pregunta importante es c√≥mo el motor Flutter organiza todo el comportamiento de la aplicaci√≥n en funci√≥n del renderizado. </p><br><p>  Para tener una idea de los mecanismos internos, mire la siguiente animaci√≥n: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Una breve explicaci√≥n (m√°s detalles vendr√°n m√°s adelante): </p><br><ul><li>  Algunos eventos externos (gestos, respuestas http, etc.) o incluso futuros pueden desencadenar tareas que hacen necesario actualizar la pantalla.  El mensaje correspondiente se env√≠a al <em>Flutter Engine</em> (= <em>Marco de programaci√≥n</em> ) </li><li>  Cuando el <em>motor Flutter est√°</em> listo para comenzar a actualizar el renderizado, crea una solicitud de inicio de <em>marco</em> </li><li>  Esta solicitud de <em>marco de</em> inicio es interceptada por <em>Flutter Framework</em> , que realiza tareas principalmente relacionadas con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Tickers</a> (por ejemplo, animaci√≥n) </li><li>  Estas tareas pueden volver a crear la solicitud para su posterior representaci√≥n (ejemplo: la animaci√≥n no ha completado su ejecuci√≥n y, para completarla, necesitar√° obtener otro <em>Marco de inicio</em> en una etapa posterior) </li><li>  A continuaci√≥n, <em>Flutter Engine</em> env√≠a un <em>cuadro de dibujo</em> , que es interceptado por <em>Flutter Framework</em> , que buscar√° cualquier tarea relacionada con la actualizaci√≥n del dise√±o en t√©rminos de estructura y tama√±o. </li><li>  Despu√©s de completar todas estas tareas, contin√∫a con las tareas asociadas con la actualizaci√≥n del dise√±o en t√©rminos de representaci√≥n </li><li>  Si hay algo en la pantalla que necesita dibujarse, se env√≠a una nueva escena ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Escena</a> ) para visualizaci√≥n al <em>Flutter Engine</em> , que actualizar√° la pantalla </li><li>  El <em>Flutter Framework</em> realiza todas las tareas que se realizar√°n despu√©s de la representaci√≥n (= devoluciones de llamada PostFrame), y cualquier otra tarea posterior que no est√© relacionada con la representaci√≥n </li><li>  ... y este proceso comienza de nuevo </li></ul><br><h2 id="renderview-i-renderobject">  RenderView y RenderObject </h2><br><p>  Antes de sumergirse en los detalles del flujo de trabajo, es hora de presentar el concepto del <em>√°rbol de renderizado</em> . </p><br><p>  Como se mencion√≥ anteriormente, todo se convertir√° eventualmente en p√≠xeles que se mostrar√°n en la pantalla, y el <em>Marco Flutter</em> convertir√° los <em>Widgets</em> que usamos para desarrollar la aplicaci√≥n en bloques visuales que se mostrar√°n en la pantalla. </p><br><p>  Estas partes visuales corresponden a objetos llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RenderObject</a> , que se utilizan para: </p><br><ul><li>  definir un √°rea determinada de la pantalla en t√©rminos de tama√±o, posici√≥n, geometr√≠a, as√≠ como en t√©rminos de <em>"contenido renderizado"</em> </li><li>  Identificar √°reas de la pantalla que pueden verse afectadas por los gestos (= tocar con el dedo) </li></ul><br><p>  Un conjunto de todos los <em>RenderObjects</em> forma un √°rbol llamado <em>Render Tree</em> .  En la parte superior de este √°rbol (= <em>ra√≠z</em> ) encontramos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> proporciona una superficie com√∫n para los objetos de <em>Render Tree</em> y es una versi√≥n especial de <em>RenderObject</em> . </p><br><p>  Visualmente, podr√≠amos representar todo esto de la siguiente manera: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  La relaci√≥n entre <em>Widget</em> y <em>RenderObject</em> se discutir√° m√°s adelante.  Mientras tanto, es hora de ir un poco m√°s profundo ... </p><br><h2 id="inicializaciya-bindings">  Enlaces de inicializaci√≥n </h2><br><p> Cuando se inicia la aplicaci√≥n Flutter, primero se llama a la funci√≥n <code>main()</code> , que finalmente llama al <code>runApp(Widget app)</code> . </p><br><p>  Cuando se <code>runApp()</code> m√©todo <code>runApp()</code> <em>Marco de Flutter</em> inicializa las interfaces entre s√≠ mismo y el <em>Motor de Flutter</em> .  Estas interfaces se denominan <strong>enlaces</strong> ( <em>nota: enlaces</em> ). </p><br><p>  <strong>Introducci√≥n a los enlaces</strong> </p><br><p>  Los enlaces est√°n dise√±ados para ser el enlace entre el marco y el motor Flutter.  Solo a trav√©s de enlaces se pueden intercambiar datos entre <em>Flutter Framework</em> y <em>Flutter Engine</em> . <br>  <em>(Solo hay una excepci√≥n a esta regla:</em> RenderView <em>, pero lo discutiremos m√°s adelante).</em> </p><br><p>  Cada enlace es responsable de procesar un conjunto de tareas, acciones, eventos espec√≠ficos, agrupados por √°rea de actividad. </p><br><p>  Al momento de escribir este art√≠culo, el <em>Marco Flutter</em> tiene 8 enlaces. </p><br><p>  A continuaci√≥n hay 4 de ellos que ser√°n considerados en este art√≠culo: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Gesto vinculante</em> </li><li>  <em>Enlace de renderizador</em> </li><li>  <em>Encuadernaci√≥n de widgets</em> </li></ul><br><p>  Para completar, mencionar√© los 4 restantes: </p><br><ul><li>  <em>ServicesBinding</em> : responsable de procesar los mensajes enviados por el <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">canal de</a></em> la <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">plataforma</a></em> </li><li>  <em>PaintingBinding</em> : responsable de procesar el cach√© de im√°genes </li><li>  <em>Enlace sem√°ntico</em> : reservado para la implementaci√≥n posterior de todo lo relacionado con la sem√°ntica </li><li>  <em>TestWidgetsFlutterBinding</em> : utilizado por la biblioteca de prueba de widgets </li></ul><br><p>  Tambi√©n puede mencionar <em>WidgetsFlutterBinding</em> , pero esto no es realmente un enlace, sino m√°s bien un tipo de <em>"inicializador de enlace"</em> . </p><br><p>  El siguiente diagrama muestra la interacci√≥n entre los enlaces, que voy a considerar a continuaci√≥n, y el <em>motor Flutter</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Veamos cada uno de estos enlaces "centrales". </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Este enlace tiene dos responsabilidades principales: </p><br><ul><li>  Di <em>Flutter Engine</em> : <em>"¬°Hey! La pr√≥xima vez que no est√©s ocupado, despi√©rtame para que pueda trabajar un poco y decirte qu√© hacer, o si necesito que me llames m√°s tarde ..."</em> </li><li>  Escuche y responda a tales <em>"despertares perturbadores"</em> (ver m√°s abajo) </li></ul><br><p>  ¬øCu√°ndo <em>SchedulerBinding</em> solicita una <em>llamada de atenci√≥n</em> ? </p><br><ul><li><p>  Cuando <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ticker</a></em> debe <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">resolver</a></em> <em>un</em> nuevo <em>tic</em> </p><br><p>  Por ejemplo, tienes una animaci√≥n, la comienzas.  La animaci√≥n se recorta utilizando el <em>Ticker</em> , que se llama a intervalos regulares (= <em>tick</em> ) para realizar una <em>devoluci√≥n de llamada</em> .  Para iniciar una <em>devoluci√≥n de llamada de este tipo</em> , debemos informarle al <em>motor de flutter</em> para que nos despierte durante la pr√≥xima actualizaci√≥n (= <em>marco</em> inicial).  Esto iniciar√° la devoluci√≥n de llamada de <em>ticker</em> para completar su tarea.  Si el <em>ticker</em> a√∫n necesita continuar la ejecuci√≥n, al final de su tarea, llamar√° a <em>SchedulerBinding</em> para programar otro marco. </p><br></li><li><p>  Cu√°ndo actualizar la pantalla </p><br><p>  Por ejemplo, necesitamos resolver un evento que conduzca a un cambio visual (ejemplo: actualizar el color de una parte de la pantalla, desplazarse, agregar / eliminar algo de la pantalla), para esto debemos seguir los pasos necesarios para mostrar la imagen actualizada en la pantalla.  En este caso, cuando se produce dicho cambio, el <em>Marco de Flutter</em> llama a <em>SchedulerBinding</em> para programar otro marco utilizando el <em>Motor de Flutter</em> .  <em>(M√°s adelante veremos c√≥mo funciona esto)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Gesto vinculante </h3><br><p>  Este enlace escucha la interacci√≥n con el motor en t√©rminos del <em>"dedo"</em> (= <em>gesto</em> ). </p><br><p>  En particular, es responsable de recibir datos relacionados con los <em>dedos</em> y de determinar con qu√© parte (s) de la pantalla trabajan los gestos.  Luego notifica en consecuencia / de estas partes. </p><br><h3 id="rendererbinding">  Enlace de renderizador </h3><br><p>  Este enlace es el enlace entre el <em>motor Flutter</em> y el <em>√°rbol de renderizado</em> .  Ella es responsable de: </p><br><ul><li>  escuchar eventos generados por el motor para informar sobre los cambios aplicados por el usuario a trav√©s de la configuraci√≥n del dispositivo que afecta los efectos visuales y / o sem√°nticos </li><li>  mensaje al motor sobre los cambios que se aplicar√°n a la pantalla </li></ul><br><p>  Para proporcionar los cambios que se mostrar√°n en la pantalla, <em>RendererBinding</em> es responsable de administrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">PipelineOwner</a> e inicializar <strong>RenderView</strong> . </p><br><p>  <em>PipelineOwner</em> es un tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">orquesta</a> que sabe lo que se debe hacer con <em>RenderObject</em> de acuerdo con el <em>componente</em> y coordina estas acciones. </p><br><h3 id="widgetsbinding">  Encuadernaci√≥n de widgets </h3><br><p>  Este enlace escucha los cambios aplicados por el usuario a trav√©s de la configuraci√≥n del dispositivo que afecta el idioma (= <em>localidad</em> ) y la <em>sem√°ntica</em> . </p><br><blockquote>  <em>Peque√±a nota</em> <br><br>  <em>Supongo que en una etapa posterior en el desarrollo de</em> Flutter, <em>todos los eventos relacionados con la</em> sem√°ntica <em>se transferir√°n a</em> SemanticsBinding <em>, pero en el momento de escribir este art√≠culo, este no es el caso.</em> </blockquote><p>  Adem√°s, <em>WidgetsBinding</em> es el enlace entre widgets y <em>Flutter Engine</em> .  Ella es responsable de: </p><br><ul><li>  gesti√≥n del proceso de procesamiento de cambios en la estructura de widgets </li><li>  hacer una llamada </li></ul><br><p>  El procesamiento de los cambios en la estructura de los widgets se realiza con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> realiza un seguimiento de qu√© widgets deben reconstruirse y maneja otras tareas que se aplican a la estructura del widget en su conjunto. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Parte 2. De widgets a p√≠xeles </h1><br><p>  Ahora que hemos aprendido los conceptos b√°sicos del trabajo interno de <em>Flutter</em> , es hora de hablar sobre widgets. </p><br><p>  En toda la documentaci√≥n de Flutter leer√° que todos los <em>Widgets</em> (widgets). </p><br><p>  Esto es casi correcto.  Pero para ser un poco m√°s preciso, prefiero decir: </p><br><blockquote>  Del lado del desarrollador, todo lo relacionado con la interfaz de usuario en t√©rminos de dise√±o e interacci√≥n se realiza mediante widgets. </blockquote><p>  ¬øPor qu√© tanta precisi√≥n?  Adem√°s del hecho de que <em>Widget</em> permite al desarrollador determinar parte de la pantalla en t√©rminos de tama√±o, contenido, dise√±o e interacci√≥n, <strong>PERO</strong> hay mucho m√°s.  Entonces, ¬øqu√© es realmente <em>Widget</em> ? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Configuraci√≥n inmutable </h2><br><p>  Si observa el c√≥digo fuente de <em>Flutter</em> , notar√° la siguiente definici√≥n de la clase <em>Widget</em> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  ¬øQu√© significa esto? </p><br><p>  La anotaci√≥n <strong>"@immutable" es</strong> muy importante y nos dice que <strong>cualquier variable en la clase Widget debe ser FINAL</strong> , en otras palabras: "definida y asignada <strong>UNA VEZ PARA TODOS</strong> ".  Por lo tanto, despu√©s de crear una instancia, Widget ya no podr√° cambiar sus variables internas. </p><br><blockquote>  <em>Como Widget es inmutable, puede considerarse una configuraci√≥n est√°tica.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  La estructura jer√°rquica de los widgets. </h2><br><p>  Cuando dise√±a con Flutter, define la estructura de su (s) pantalla (s) utilizando widgets como este: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  Este ejemplo utiliza 7 widgets que juntos forman una estructura jer√°rquica.  Un esquema muy simplificado basado en este c√≥digo es el siguiente: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Como puede ver, el diagrama presentado se parece a un √°rbol, donde <em>SafeArea</em> es su ra√≠z. </p><br><h2 id="les-za-derevyami">  Bosque detr√°s de los √°rboles </h2><br><p>  Como ya sabe, un widget en s√≠ mismo puede ser una agregaci√≥n de otros widgets.  Como ejemplo, puede modificar el c√≥digo anterior de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Esta opci√≥n supone que el widget <em>"MyOwnWidget" en</em> s√≠ mostrar√° <em>SafeArea</em> , <em>Scaffold</em> .  Pero lo m√°s importante en este ejemplo es que </p><br><blockquote>  <em>Un widget</em> puede representar una hoja, un nudo en un √°rbol, incluso el √°rbol mismo o, por qu√© no, un bosque de √°rboles ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  <em>Elemento de</em> comprensi√≥n en un √°rbol </h2><br><p>  ¬øQu√© tiene esto que ver con eso? </p><br><p>  Como se mostrar√° m√°s adelante, para poder generar p√≠xeles que componen la imagen que se muestra en el dispositivo, <em>Flutter</em> debe conocer en detalle todas las partes peque√±as que componen la pantalla, y para determinar todas las partes, necesita conocer la <strong>expansi√≥n de</strong> todos los widgets. </p><br><p>  Para ilustrar este punto, considere el principio de una mu√±eca anidada: cuando est√° cerrado, solo ve 1 mu√±eca, pero contiene otra, que a su vez contiene otra y as√≠ sucesivamente ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Cuando <em>Flutter</em> expande todos los widgets <em>(parte de la pantalla)</em> , ser√° como obtener todas las mu√±ecas <em>(parte del todo)</em> . </p><br><p>  La siguiente imagen muestra parte de la estructura jer√°rquica final de los widgets correspondientes al c√≥digo anterior.  En amarillo, destaqu√© los widgets que se mencionaron en el c√≥digo anteriormente, para que pueda definirlos en el √°rbol final. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Aclaraciones importantes</em></strong> <br><br>  <em>El lenguaje "√Årbol de widgets" existe solo para facilitar la comprensi√≥n, ya que los programadores usan widgets, ¬°pero NO hay un √°rbol de widgets en Flutter!</em> <br><br>  <em>De hecho, ser√≠a m√°s correcto decir "√°rbol de elementos"</em> </blockquote><p>  Es hora de presentar el concepto de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">elemento</a> . </p><br><blockquote>  <em><strong>Cada</strong> widget tiene <strong>un</strong> elemento.</em>  <em>Los elementos est√°n conectados entre s√≠ y forman un √°rbol.</em>  <em>Por lo tanto, <strong>un elemento</strong> es una referencia a algo en el √°rbol.</em> </blockquote><p>  Para empezar, piense en un elemento como un nodo que tiene un padre y posiblemente un hijo.  Al vincularlos a trav√©s de una relaci√≥n <em>padre-hijo</em> , obtenemos una estructura de √°rbol. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Como puede ver, el elemento apunta a un widget y tambi√©n <strong>puede</strong> apuntar a un <em>RenderObject</em> . </p><br><blockquote>  <em>A√∫n mejor ... ¬°Element se√±ala a Widget que <strong>cre√≥</strong> este Element!</em> </blockquote><p>  Resumamos: </p><br><ul><li>  No hay un √°rbol de widgets, pero hay un √°rbol de elementos. </li><li>  Los elementos son creados por widgets. </li><li>  El elemento se refiere al widget que lo cre√≥. </li><li>  Elementos vinculados a las relaciones entre padres </li><li>  Un art√≠culo puede tener un "beb√©". </li><li>  Los elementos tambi√©n pueden apuntar a un <em>RenderObject.</em> </li></ul><br><blockquote>  <em><strong>Los elementos</strong> determinan c√≥mo las partes de los bloques mostrados est√°n relacionadas entre s√≠.</em> </blockquote><p>  Para imaginar mejor d√≥nde encaja el concepto de <em>un elemento</em> , veamos la siguiente representaci√≥n visual: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Como puede ver, el √°rbol de elementos es la relaci√≥n real entre widgets y <em>RenderObjects</em> . </p><br><p>  Pero, ¬øpor qu√© <em>Widget</em> crea un <em>elemento</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 categor√≠as de widgets </h2><br><p>  En Flutter, los widgets se dividen en 3 categor√≠as, personalmente los llamo de la siguiente manera <em>(pero esta es solo mi forma de clasificarlos)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  La tarea principal de estos widgets es almacenar cierta informaci√≥n (que deber√≠a ser accesible para los widgets), parte de la estructura de √°rbol basada en Proxy.  Un ejemplo de tales widgets es <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">InheritedWidget</a></strong> o <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Estos widgets no participan directamente en la formaci√≥n de la interfaz de usuario, pero se utilizan para obtener la informaci√≥n que pueden proporcionar. </p><br></li><li><p>  Renderizador </p><br><p>  Estos widgets est√°n directamente relacionados con el dise√±o de la pantalla, ya que determinan (o se utilizan para determinar) el <em>tama√±o</em> , la <em>posici√≥n</em> y la <em>representaci√≥n</em> .  Los ejemplos t√≠picos son: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Fila</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Columna</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Pila</a></strong> , as√≠ como <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Relleno</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Alinear</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Opacidad</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Componente </p><br><p>  Estos son otros widgets que proporcionan directamente no la informaci√≥n final relacionada con los tama√±os, las posiciones, la apariencia, sino los datos (o consejos) que se utilizar√°n para obtener la informaci√≥n final.  Estos widgets se conocen com√∫nmente como componentes. </p><br><p>  Ejemplos: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Este archivo PDF</a> enumera la mayor√≠a de los widgets agrupados por categor√≠a. </p><br><p>  ¬øPor qu√© es importante esta separaci√≥n?  Porque dependiendo de la categor√≠a del widget, el tipo de elemento correspondiente est√° asociado con ... </p><br><h2 id="tipy-elementov">  Tipos de elementos </h2><br><p>  Hay varios tipos de elementos: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Como puede ver en la imagen de arriba, los elementos se dividen en 2 tipos principales: </p><br><ul><li><p>  Componente </p><br><p>  Estos elementos no <strong>son directamente</strong> responsables de representar ninguna parte de la pantalla. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Estos elementos son responsables de partes de la imagen mostrada en la pantalla. </p><br></li></ul><br><p>  Genial  Tanta informaci√≥n, pero ¬øc√≥mo se relaciona todo esto entre s√≠ y por qu√© es interesante hablar de ello? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  C√≥mo funcionan juntos los widgets y los elementos </h2><br><blockquote>  <em>En Flutter, toda la mec√°nica se basa en invalidar un elemento o renderObject.</em> </blockquote><p>  La invalidaci√≥n de elementos se puede hacer de las siguientes maneras: </p><br><ul><li>  usando <code>setState</code> , que invalida todo el <strong>StatefulElement</strong> (tenga en cuenta que intencionalmente no digo <em>StatefulWidget</em> ) </li><li>  mediante notificaciones procesadas por <strong>proxyElement</strong> (por ejemplo, InheritedWidget), que invalida cualquier <em>elemento</em> que dependa de este <em>proxyElement</em> </li></ul><br><p>  El resultado de la <em>invalidaci√≥n</em> es que aparece un enlace al <em>elemento</em> correspondiente en la lista de elementos <strong>sucios</strong> . </p><br><p>  La <em>invalidaci√≥n de renderObject</em> significa que la estructura de los elementos no cambia en absoluto, pero hay un cambio en el nivel de <em>renderObject</em> , por ejemplo: </p><br><ul><li>  cambiando su tama√±o, posici√≥n, geometr√≠a ... </li><li>  algo necesita ser repintado, por ejemplo, cuando solo cambia el color de fondo, el estilo de fuente ... </li></ul><br><p>  El resultado de dicha <em>invalidaci√≥n</em> es un enlace al <em>renderObject</em> correspondiente en la lista de objetos de renderizado <em>(renderObjects)</em> que necesitan ser reconstruidos o repintados. </p><br><p>  Independientemente del tipo de invalidaci√≥n, se llama a <strong>SchedulerBinding</strong> (¬ørecuerda esto?) Para solicitar al <strong>Flutter Engine</strong> que programe un nuevo marco. </p><br><p>  Este es exactamente el momento en que el <em>motor Flutter</em> "despierta" el <em>SchedulerBinding</em> y sucede toda la magia ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Anteriormente en este art√≠culo, notamos que <em>SchedulerBinding tiene</em> dos responsabilidades principales, una de las cuales es la disposici√≥n a manejar las solicitudes hechas por <em>Flutter Engine</em> relacionadas con la reconstrucci√≥n de marcos.  Este es el momento perfecto para enfocarse en esto. </p><br><p>  El siguiente diagrama de secuencia parcial muestra lo que sucede cuando <em>SchedulerBinding</em> recibe una solicitud <em>onDrawFrame ()</em> de <em>Flutter Engine</em> . </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Paso 1. Elementos</strong> </p><br><p>  Se <em>llama WidgetsBinding</em> , y este enlace primero considera los cambios asociados con los elementos.  <em>WidgetsBinding</em> llama al m√©todo <em>buildScope del</em> objeto <em>buildOwner</em> , ya que <strong>BuildOwner</strong> es responsable de procesar el √°rbol de elementos.  Este m√©todo revisa la lista de elementos <em>sucios</em> y solicita su <strong>reconstrucci√≥n</strong> . </p><br><p>  Los principios principales de este m√©todo de <code>rebuild()</code> ) son: </p><br><ol><li>  Hay una solicitud para reconstruir el elemento (esto llevar√° la mayor parte del tiempo), llamando al m√©todo <code>build()</code> del widget al que se refiere este elemento <code>build()</code> m√©todo = = <code>Widget build (BuildContext context) {...}</code> ).  Este m√©todo <code>build()</code> devolver√° un nuevo widget </li><li>  Si el elemento no tiene "hijos", se crea un elemento para el nuevo widget (ver m√°s abajo) ( <em>nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">inflateWidget</a></em> ), de lo contrario </li><li>  el nuevo widget se compara con el referenciado por el elemento secundario del elemento <br><ul><li>  Si son intercambiables (= <em>el mismo tipo de widget y clave</em> ), se produce la actualizaci√≥n y se guarda el elemento secundario. </li><li>  Si no son intercambiables, el ni√±o se descarta ( <em>~ se descarta</em> ) y se crea un elemento para el nuevo widget </li></ul></li><li>  Este nuevo elemento se monta como elemento secundario del elemento.  ( <em>montado)</em> = insertado en el √°rbol de elementos) </li></ol><br><p>  La siguiente animaci√≥n intentar√° hacer esta explicaci√≥n un poco m√°s clara. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Nota sobre widgets y elementos</strong> </p><br><p>  Para un nuevo widget, se crea un elemento de un <em>tipo espec√≠fico</em> que corresponde a <em>la categor√≠a del</em> widget, a saber: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Cada uno de estos tipos de elementos tiene su propio comportamiento.  Por ejemplo: </p><br><ul><li>  <em>StatefulElement</em> llamar√° al m√©todo <code>widget.createState()</code> en la inicializaci√≥n, lo que crear√° un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">estado</a> y lo asociar√° con el elemento </li><li>  Cuando <em>se</em> monta un elemento de tipo <em>RenderObjectElement</em> , se crea un <em>RenderObject</em> .  Este <em>renderObject</em> se agregar√° al <em>Render Tree</em> y se asociar√° con el elemento. </li></ul><br><p>  <strong>Paso 2. renderObjects</strong> </p><br><p>  Ahora, despu√©s de completar todas las acciones asociadas con elementos <em>sucios</em> , el <em>√Årbol de elementos</em> es estable.  Es hora de considerar el proceso de visualizaci√≥n. </p><br><p>  Dado que <em>RendererBinding</em> es responsable de renderizar el <em>Render Tree</em> , <em>WidgetsBinding</em> llama al m√©todo <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p>  El siguiente diagrama parcial muestra la secuencia de acciones realizadas durante la solicitud <em>drawFrame ()</em> . </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  En este paso, se realizan las siguientes acciones: </p><br><ul><li>  Cada <em>renderObject</em> marcado como <em>sucio</em> debe componerlo (es decir, calcular su tama√±o y geometr√≠a) </li><li>  Cada <em>renderObject</em> marcado como "necesita volver a dibujar" se vuelve a dibujar utilizando su propio m√©todo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">capa</a> </li><li>  La escena resultante se forma y se env√≠a al <em>Flutter Engine</em> , para que este √∫ltimo lo transfiera a la pantalla del dispositivo. </li><li>  Finalmente, la sem√°ntica tambi√©n se actualiza y se env√≠a al <em>Flutter Engine.</em> </li></ul><br><p>  Al final de este flujo de trabajo, la pantalla del dispositivo se actualiza. </p><br><h1 id="chast-3-obrabotka-zhestov">  Parte 3: gestos de manejo </h1><br><p>  Los gestos (= <em>eventos relacionados con las acciones de los dedos en el cristal</em> ) se procesan utilizando <em>GestureBinding</em> . </p><br><p>  Cuando <em>Flutter Engine</em> env√≠a informaci√≥n sobre un evento de gesto a trav√©s de la API <em>window.onPointerDataPacket</em> , <strong>GestureBinding lo</strong> intercepta, realiza un almacenamiento en b√∫fer y: </p><br><ol><li>  convierte las coordenadas proporcionadas por <em>Flutter Engine</em> para que coincidan con la <strong>relaci√≥n de p√≠xeles</strong> del <strong>dispositivo</strong> , y luego </li><li>  recupera de <em>render Vea una</em> lista de todos los <em>RenderObjects</em> que est√°n en la parte de la pantalla relacionada con las coordenadas del evento </li><li>  luego recorre la lista resultante de <em>renderObjects</em> y env√≠a un evento relacionado a cada uno de ellos </li><li>  si <em>renderObject</em> "escucha" eventos de este tipo, lo procesa </li></ol><br><p>  Con suerte, ahora entiendo lo importante que <em>es renderObjects</em> . </p><br><h1 id="chast-4-animacii">  Parte 4: animaciones </h1><br><p>  Esta parte del art√≠culo trata sobre el concepto de <strong>animaci√≥n</strong> y una comprensi√≥n profunda de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p>  Cuando trabaja con animaciones, generalmente usa un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">AnimationController</a> o cualquier widget para animaciones ( <em>nota: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  En <em>Flutter,</em> todo lo relacionado con animaciones se refiere a <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ticker</a></em> .  <em>Ticker</em> , cuando est√° activo, solo tiene una tarea: "le pide a <em>SchedulerBinding que</em> registre una devoluci√≥n de llamada y le dice al <em>Flutter Engine</em> que la active cuando aparezca una nueva devoluci√≥n de llamada".  Cuando <em>Flutter Engine est√°</em> listo, llama a <em>SchedulerBinding a</em> trav√©s de una solicitud: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> accede a la lista de devoluci√≥n de llamada de <em>ticker</em> y ejecuta cada una. </p><br><p>  Cada <em>tic es</em> interceptado por un controlador "interesado" para procesarlo.  Si la animaci√≥n est√° completa, el <em>ticker est√°</em> "deshabilitado", de lo contrario, el <em>ticker</em> solicita un <em>SchedulerBinding</em> para programar una nueva devoluci√≥n de llamada.  Y as√≠ sucesivamente ... </p><br><h1 id="polnaya-kartina">  Imagen completa </h1><br><p>  Ahora hemos aprendido c√≥mo funciona <em>Flutter</em> : </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Finalmente, regrese al diagrama que muestra los diferentes tipos de elementos y considere la firma del <em>Elemento</em> ra√≠z: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  ¬°Vemos el famoso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">BuildContext</a> !  Pero que es eso? </p><br><p>  <strong>BuildContext</strong> es una interfaz que define una serie de captadores y m√©todos que un elemento puede implementar.  Mayormente <em>BuildContext se</em> usa en el m√©todo <code>build()</code> de <em>StatelessWidget</em> o <em>State</em> for <em>StatefulWidget</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> no es m√°s que el <strong>Elemento en</strong> s√≠, que coincide</em> <br><ul><li>  <em>widget que se actualiza (dentro de los m√©todos de <code>build</code> o <code>builder</code> )</em> </li><li>  <em>StatefulWidget asociado con el <strong>estado</strong> en el que hace referencia a la variable de contexto.</em> </li></ul><br></blockquote><p>  Esto significa que la mayor√≠a de los desarrolladores trabajan constantemente con elementos sin siquiera saberlo. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  ¬øQu√© tan √∫til puede ser un BuildContext? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> ‚Ä¶) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> ‚Äì  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    ‚Äì ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476018/">https://habr.com/ru/post/476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476000/index.html">Actualizaciones de ML.NET Model Builder</a></li>
<li><a href="../476002/index.html">Experiencia en encontrar un puesto de estudiante de doctorado en Alemania</a></li>
<li><a href="../476004/index.html">Gerente de proyecto: ¬ømito o realidad? ¬øO por qu√© se necesita en el campo de los efectos visuales?</a></li>
<li><a href="../476006/index.html">Mitos y leyendas de los constructores de SOC, o 3 conceptos err√≥neos sobre los centros para monitorear y responder a los ataques cibern√©ticos</a></li>
<li><a href="../476008/index.html">Meetup de MOSDROID: con√©ctate a la transmisi√≥n</a></li>
<li><a href="../476022/index.html">Vue Storefront: elevando el backend</a></li>
<li><a href="../476024/index.html">La mejor arquitectura para MVP: monolito, SOA, microservicios o sin servidor ... Parte 1</a></li>
<li><a href="../476026/index.html">Cool Life Hacks para trabajar con WSL (Windows Subsystem for Linux)</a></li>
<li><a href="../476032/index.html">Brunner Elektronik: del sistema CAD a la cabina</a></li>
<li><a href="../476034/index.html">El m√°s indefenso es el halc√≥n peregrino.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>