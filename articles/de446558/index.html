<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚀 🕺🏽 🧑🏾‍🤝‍🧑🏾 Exotische Datenstrukturen: Modifizierte Merkle Patricia Trie 🌰 ✴️ 💈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""An was für einen Teufel sollte ich mich auswendig an all diese verdammten Algorithmen und Datenstrukturen erinnern?" 


 Diesbezüglich kommt es auf d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exotische Datenstrukturen: Modifizierte Merkle Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"An was für einen Teufel sollte ich mich auswendig an all diese verdammten Algorithmen und Datenstrukturen erinnern?"</em> </p><br><p>  Diesbezüglich kommt es auf die Kommentare der meisten Artikel zum Durchgang technischer Interviews an.  Die Hauptthese lautet in der Regel, dass alles, was auf die eine oder andere Weise verwendet wird, bereits zehnmal implementiert wurde und es höchst unwahrscheinlich ist, dass sich dieser gewöhnliche Programmierer damit befassen muss.  Nun, bis zu einem gewissen Grad ist dies wahr.  Aber wie sich herausstellte, wurde nicht alles implementiert, und ich musste leider (oder zum Glück?) Immer noch eine Datenstruktur erstellen. </p><br><p>  Geheimnisvolle modifizierte Merkle Patricia Trie. </p><br><p>  Da es zu diesem Baum überhaupt keine Informationen über den Habr und das Medium gibt - ein bisschen mehr - möchte ich Ihnen sagen, um welche Art von Tier es sich handelt und womit es gefressen wird. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  Was ist das? </h2><br><p>  <em>Haftungsausschluss: Die Hauptinformationsquelle für die Implementierung war für mich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gelbe Papier</a> sowie die Quellcodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parity-Ethereum</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Ethereum</a> .</em>  <em>Es gab ein Minimum an theoretischen Informationen zur Rechtfertigung bestimmter Entscheidungen, daher sind alle Schlussfolgerungen über die Gründe für bestimmte Entscheidungen meine persönlichen.</em>  <em>Falls ich mich in etwas irre - ich freue mich über Korrekturen in den Kommentaren.</em> </p><br><p>  <em>Ein Baum</em> ist eine Datenstruktur, die ein zusammenhängender azyklischer Graph ist.  Hier ist alles einfach, das kennt jeder. </p><br><p>  <em>Der Präfixbaum</em> ist der Stammbaum, in dem Schlüssel-Wert-Paare gespeichert werden können, da die Knoten in zwei Typen unterteilt sind: diejenigen, die einen Teil des Pfads (Präfix) enthalten, und Blattknoten, die den gespeicherten Wert enthalten.  Ein Wert ist in einem Baum genau dann vorhanden, wenn wir mit dem Schlüssel den ganzen Weg von der Wurzel des Baums gehen und einen Knoten mit einem Wert am Ende finden können. </p><br><p>  <em>Der PATRICIA-Baum</em> ist ein Präfixbaum, in dem die Präfixe binär sind - das heißt, jeder Schlüsselknoten speichert Informationen über ein Bit. </p><br><p>  <em>Der Merkle-</em> Baum ist ein Hash-Baum, der auf einer Art Datenkette aufgebaut ist und dieselben Hashes zu einem (Root) zusammenfasst und Informationen über den Status aller Datenblöcke speichert.  Das heißt, der Root-Hash ist eine Art "digitale Signatur" des Zustands der Blockkette.  Dieses Ding wird aktiv in der Blockchain verwendet, und mehr darüber finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="Harte Arbeit ist ..."></p><br><p>  Gesamt: Modifizierte Merkle Patricia Trie (im Folgenden kurz MPT) ist ein Hash-Baum, in dem Schlüssel-Wert-Paare gespeichert werden, während die Schlüssel in binärer Form dargestellt werden.  Und worum es genau bei „Modified“ geht, erfahren wir etwas später, wenn wir die Implementierung besprechen. </p><br><h2 id="zachem-eto">  Warum ist das so? </h2><br><p>  MPT wird im Ethereum-Projekt verwendet, um Daten über Konten, Transaktionen, Ergebnisse ihrer Ausführung und andere Daten zu speichern, die für das Funktionieren des Systems erforderlich sind. <br>  Im Gegensatz zu Bitcoin, bei dem der Status implizit ist und von jedem Knoten unabhängig berechnet wird, wird der Kontostand jedes Kontos (sowie die damit verbundenen Daten) direkt in der Blockchain in der Luft gespeichert.  Darüber hinaus sollte das Auffinden und die Invarianz von Daten kryptografisch bereitgestellt werden - nur wenige Personen verwenden Kryptowährung, bei der sich der Kontostand eines zufälligen Kontos ohne objektive Gründe ändern kann. </p><br><p>  Das Hauptproblem der Entwickler von Ethereum ist die Erstellung einer Datenstruktur, mit der Sie Schlüssel-Wert-Paare effektiv speichern und gleichzeitig die gespeicherten Daten überprüfen können.  Also erschien MPT. </p><br><h2 id="kak-eto">  Wie ist es? </h2><br><p>  MPT ist ein Präfix-PATRICIA-Baum, in dem die Schlüssel Folgen von Bytes sind. </p><br><p>  Die Kanten in diesem Baum sind Halbbyte-Sequenzen (halbe Bytes).  Dementsprechend kann ein Knoten bis zu 16 Nachkommen haben (entsprechend Zweigen von 0x0 bis 0xF). </p><br><p>  Knoten sind in 3 Typen unterteilt: </p><br><ul><li>  Zweigknoten.  Der zum Verzweigen verwendete Knoten.  Enthält bis zu 1 bis 16 Links zu untergeordneten Knoten.  Kann auch einen Wert enthalten. </li><li>  Erweiterungsknoten.  Ein Hilfsknoten, der einen Teil des Pfads speichert, der mehreren untergeordneten Knoten gemeinsam ist, sowie eine Verknüpfung zum Zweigknoten, der darunter liegt. </li><li>  Blattknoten.  Ein Knoten, der einen Teil des Pfads und einen gespeicherten Wert enthält.  Es ist das Ende in der Kette. </li></ul><br><p> Wie bereits erwähnt, basiert MPT auf einem anderen kv-Repository, in dem Knoten in Form von "link" =&gt; " <code>RLP</code> codierter Knoten" gespeichert werden. </p><br><p>  <em>Und hier haben wir ein neues Konzept: RLP.</em>  <em>Kurz gesagt, dies ist eine Methode zum Codieren von Daten, die Listen oder Bytesequenzen darstellen.</em>  <em>Beispiel: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>Ich werde nicht besonders auf Details eingehen, und bei der Implementierung verwende ich eine vorgefertigte Bibliothek, da auch die Berichterstattung über dieses Thema einen bereits ziemlich großen Artikel aufblähen wird.</em>  <em>Wenn Sie noch interessiert sind, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr lesen.</em>  <em>Wir beschränken uns auf die Tatsache, dass wir Daten in <code>RLP</code> codieren und zurückdecodieren können.</em> </p><br><p>  Eine Verbindung zu einem Knoten ist wie folgt definiert: Wenn die Länge des <code>RLP</code> codierten Knotens 32 oder mehr Bytes beträgt, ist die Verbindung ein <code>keccak</code> Hash aus der <code>RLP</code> Darstellung des Knotens.  Wenn die Länge weniger als 32 Bytes beträgt, ist die Verbindung die <code>RLP</code> Darstellung des Knotens selbst. </p><br><p>  Im zweiten Fall müssen Sie den Knoten natürlich nicht in der Datenbank speichern, weil  Es wird vollständig im übergeordneten Knoten gespeichert. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="Knoten sind unterschiedlich"></p><br><p>  Die Kombination von drei Knotentypen ermöglicht es Ihnen, Daten effektiv zu speichern, wenn nur wenige Schlüssel vorhanden sind (dann werden die meisten Pfade in Erweiterungs- und Blattknoten gespeichert und es gibt nur wenige Verzweigungsknoten) und wenn viele Knoten vorhanden sind (Pfade werden nicht explizit gespeichert). aber sie "sammeln" sich während des Durchgangs durch Zweigknoten). </p><br><p>  Ein vollständiges Beispiel eines Baums mit allen Arten von Knoten: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="Der Baum ist voll aber nicht dick"></p><br><p>  Wie Sie vielleicht bemerkt haben, haben die gespeicherten Teile der Pfade Präfixe.  Präfixe werden für verschiedene Zwecke benötigt: </p><br><ol><li>  Unterscheidungsknoten von Blattknoten unterscheiden. </li><li>  Zum Ausrichten von Sequenzen einer ungeraden Anzahl von Knabbereien. </li></ol><br><p>  Die Regeln zum Erstellen von Präfixen sind sehr einfach: </p><br><ul><li>  Das Präfix benötigt 1 Nibble.  Wenn die Pfadlänge (ohne das Präfix) ungerade ist, beginnt der Pfad unmittelbar nach dem Präfix.  Wenn die Pfadlänge gerade ist, wird zum Ausrichten nach dem Präfix zuerst Nibble 0x0 hinzugefügt. </li><li>  Das Präfix ist anfänglich 0x0. </li><li>  Wenn die Pfadlänge ungerade ist, wird 0x1 zum Präfix hinzugefügt, wenn gerade - 0x0. </li><li>  Wenn der Pfad zu einem Blattknoten führt, wird 0x2 zum Präfix hinzugefügt, wenn 0x0 zum Erweiterungsknoten hinzugefügt wird. </li></ul><br><p>  Bei Beatiks wird es meiner Meinung nach klarer: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Entfernung, die keine Entfernung ist </h3><br><p>  Trotz der Tatsache, dass der Baum Knoten löscht, bleibt alles, was einmal hinzugefügt wurde, für immer im Baum. </p><br><p>  Dies ist erforderlich, um nicht für jeden Block einen vollständigen Baum zu erstellen, sondern nur den Unterschied zwischen der alten und der neuen Version des Baums zu speichern. </p><br><p>  Dementsprechend können wir unter Verwendung verschiedener Root-Hashes als Einstiegspunkt jeden der Zustände abrufen, in denen sich der Baum jemals befunden hat. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="Was ist mit einem Stift geschrieben ..."></p><br><p>  Dies sind nicht alle Optimierungen.  Es gibt noch mehr, aber wir werden nicht darüber sprechen - und so ist der Artikel groß.  Sie können jedoch selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> . </p><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Die Theorie ist vorbei, lasst uns zur Praxis übergehen.  Wir werden Verkehrssprache aus der IT-Welt verwenden, das ist <code>python</code> . </p><br><p>  Da es viel Code geben wird und für das Format des Artikels viel reduziert und geteilt werden muss, werde ich sofort einen Link zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github hinterlassen</a> . <br>  Bei Bedarf sehen Sie dort das ganze Bild. </p><br><p>  Zunächst definieren wir die Baumschnittstelle, die wir als Ergebnis erhalten möchten: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Die Schnittstelle ist sehr einfach.  Verfügbare Vorgänge sind das Abrufen, Löschen, Einfügen und Ändern (kombiniert im Update) sowie das Abrufen des Root-Hash. </p><br><p>  Der Speicher wird an die Methode <code>__init__</code> - eine <code>__init__</code> Datenstruktur, in der wir die Knoten sowie <code>root</code> speichern - die "Spitze" des Baums.  Wenn <code>None</code> als <code>root</code> , gehen wir davon aus, dass der Baum leer ist und von Grund auf neu funktioniert. </p><br><p>  _Remark: Sie fragen sich möglicherweise, warum die Variablen in den Methoden als <code>encoded_key</code> und <code>encoded_value</code> und nicht nur als <code>key</code> / <code>value</code> .  Die Antwort ist einfach: Gemäß der Spezifikation müssen alle Schlüssel und Werte in <code>RLP</code> codiert sein.  Wir werden uns damit keine Sorgen machen und diesen Beruf den Bibliotheksbenutzern überlassen. </p><br><p>  Bevor wir jedoch mit der Implementierung des Baums selbst beginnen, müssen zwei wichtige Dinge getan werden: </p><br><ol><li>  Implementieren Sie die <code>NibblePath</code> Klasse, eine Kette von Nibbles, um sie nicht manuell zu codieren. </li><li>  So implementieren Sie die <code>Node</code> Klasse im Rahmen dieser Klasse - <code>Extension</code> , <code>Leaf</code> und <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Knabberweg </h3><br><p>  Also, <code>NibblePath</code> .  Da wir uns aktiv im Baum bewegen, sollte die Grundlage für die Funktionalität unserer Klasse die Fähigkeit sein, den "Versatz" vom Anfang des Pfades an festzulegen und ein bestimmtes Knabbern zu erhalten.  In diesem Wissen definieren wir die Basis unserer Klasse (sowie einige nützliche Konstanten für die Arbeit mit den folgenden Präfixen): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  Ganz einfach, nicht wahr? </p><br><p>  Es bleiben nur Funktionen zum Codieren und Decodieren einer Folge von Halbbytes zu schreiben. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  Im Prinzip ist dies das Minimum, das für ein bequemes Arbeiten mit Knabbereien erforderlich ist.  Natürlich gibt es in der aktuellen Implementierung noch eine Reihe von Hilfsmethoden (z. B. <code>combine</code> , Zusammenführen von zwei Pfaden zu einem), aber ihre Implementierung ist sehr trivial.  Bei Interesse finden Sie die Vollversion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h3 id="node">  Knoten </h3><br><p>  Wie wir bereits wissen, sind unsere Knoten in drei Typen unterteilt: Blatt, Erweiterung und Zweig.  Alle können codiert und decodiert werden, und der einzige Unterschied besteht in den darin gespeicherten Daten.  Um ehrlich zu sein, sind dies algebraische Datentypen, und in <code>Rust</code> würde ich zum Beispiel etwas im Geiste schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  In Python als solchem ​​gibt es jedoch kein ADT. Daher definieren wir die <code>Node</code> Klasse. Darin befinden sich drei Klassen, die den Knotentypen entsprechen.  Wir implementieren die Codierung direkt in den Knotenklassen und die Decodierung in der <code>Node</code> . </p><br><p>  Die Implementierung ist jedoch elementar: </p><br><p>  Blatt: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Erweiterung: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Zweig: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Alles ist sehr einfach.  Das einzige, was Fragen verursachen kann, ist die Funktion <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Dann gestehe ich, ich musste eine kleine Krücke benutzen.</em>  <em>Tatsache ist, dass die verwendete <code>rlp</code> Bibliothek die Daten rekursiv decodiert und die Verknüpfung zu einem anderen Knoten, wie wir wissen, <code>rlp</code> Daten sein kann (falls der codierte Knoten weniger als 32 Zeichen lang ist).</em>  <em>Das Arbeiten mit Links in zwei Formaten - Hash-Bytes und einem dekodierten Knoten - ist sehr unpraktisch.</em>  <em>Aus diesem Grund habe ich zwei Funktionen geschrieben, die nach dem Dekodieren des Knotens die Links im Byte-Format zurückgeben und gegebenenfalls vor dem Speichern dekodieren.</em>  <em>Diese Funktionen sind:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Beenden Sie mit Knoten, indem Sie eine <code>Node</code> schreiben.  Es gibt nur zwei Methoden: Dekodieren Sie den Knoten und verwandeln Sie den Knoten in eine Verknüpfung. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Eine Pause </h2><br><p>  Fuh!  Es gibt viele Informationen.  Ich denke es ist Zeit sich zu entspannen.  Hier ist eine weitere Katze für dich: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Sie können während der Pause einen Bissen haben"></p><br><p>  Milota, richtig?  Okay, zurück zu unseren Bäumen. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hurra - Hilfselemente sind fertig, wir gehen zu den leckersten über.  Für alle Fälle erinnere ich die Benutzeroberfläche an unseren Baum.  Gleichzeitig implementieren wir die Methode <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Aber mit den restlichen Methoden werden wir uns eins nach dem anderen befassen. </p><br><h3 id="get">  bekommen </h3><br><p>  Die <code>get</code> Methode (wie im Prinzip die anderen Methoden) besteht aus zwei Teilen.  Die Methode selbst bereitet die Daten vor und bringt das Ergebnis in die erwartete Form, während die eigentliche Arbeit innerhalb der Hilfsmethode erfolgt. </p><br><p>  Die grundlegende Methode ist sehr einfach: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  <code>_get</code> nicht viel komplizierter: Um zum gewünschten Knoten zu gelangen, müssen wir vom Stamm zum gesamten bereitgestellten Pfad wechseln.  Wenn wir am Ende einen Knoten mit Daten gefunden haben (Blatt oder Zweig) - Hurra, werden die Daten empfangen.  Wenn das Bestehen nicht möglich war, fehlt der erforderliche Schlüssel im Baum. </p><br><p>  Implementierung: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Gleichzeitig werden wir Methoden zum Speichern und Laden von Knoten schreiben.  Sie sind einfach: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  Update </h3><br><p>  Die <code>update</code> Methode ist bereits interessanter.  Gehen Sie einfach bis zum Ende durch und fügen Sie den Blattknoten ein, der nicht immer funktioniert.  Es ist wahrscheinlich, dass sich der Schlüsseltrennpunkt irgendwo innerhalb des bereits gespeicherten Blatt- oder Erweiterungsknotens befindet.  In diesem Fall müssen Sie sie trennen und mehrere neue Knoten erstellen. </p><br><p>  Im Allgemeinen kann jede Logik durch die folgenden Regeln beschrieben werden: </p><br><ol><li>  Während der Pfad vollständig mit den vorhandenen Knoten übereinstimmt, steigen wir den Baum rekursiv ab. </li><li>  Wenn der Pfad fertig ist und wir uns im Zweig- oder Blattknoten befinden, bedeutet dies, dass durch <code>update</code> einfach der Wert aktualisiert wird, der diesem Schlüssel entspricht. </li><li>  Wenn die Pfade geteilt sind (dh wir aktualisieren den Wert nicht, sondern fügen einen neuen ein), befinden wir uns im Zweigknoten. Erstellen Sie einen Blattknoten und geben Sie im entsprechenden Zweigzweig einen Link dazu an. </li><li>  Wenn die Pfade geteilt sind und wir uns im Blatt- oder Erweiterungsknoten befinden, müssen wir einen Verzweigungsknoten erstellen, der die Pfade trennt, und gegebenenfalls einen Erweiterungsknoten für den gemeinsamen Teil des Pfads. </li></ol><br><p>  Lassen Sie uns dies schrittweise im Code ausdrücken.  Warum nach und nach?  Weil die Methode groß ist und es schwierig sein wird, sie in großen Mengen zu verstehen. <br>  Ich werde hier jedoch einen Link zur vollständigen Methode hinterlassen. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  Es gibt nicht genug allgemeine Logik, das Interessanteste ist drinnen, <code>if</code> s. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Lassen Sie uns zunächst die Blattknoten behandeln.  Mit ihnen sind nur 2 Szenarien möglich: </p><br><ol><li><p>  Der Rest des Pfades, dem wir folgen, entspricht genau dem Pfad, der im Blattknoten gespeichert ist.  In diesem Fall müssen wir nur den Wert ändern, den neuen Knoten speichern und einen Link dazu zurückgeben. </p><br></li><li><p>  Die Wege sind unterschiedlich. <br>  In diesem Fall müssen Sie einen Verzweigungsknoten erstellen, der die beiden Pfade trennt. <br>  Wenn einer der Pfade leer ist, wird sein Wert direkt an den Verzweigungsknoten übertragen. <br>  Andernfalls müssen zwei Blattknoten erstellt werden, die um die Länge des gemeinsamen Teils der Pfade + 1 Halbbyte verkürzt sind (dieses Halbbyte wird durch den Index des entsprechenden Zweigs des Zweigknotens angezeigt). </p><br></li></ol><br><p>  Sie müssen auch überprüfen, ob es einen gemeinsamen Teil des Pfads gibt, um zu verstehen, ob wir auch einen Erweiterungsknoten erstellen müssen. </p><br><p>  Im Code sieht es folgendermaßen aus: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  Die Prozedur <code>_create_branch_node</code> lautet wie folgt: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  Im Fall des Erweiterungsknotens sieht alles wie ein Blattknoten aus. </p><br><ol><li><p>  Wenn der Pfad vom Erweiterungsknoten ein Präfix für unseren Pfad ist, fahren wir einfach rekursiv fort. </p><br></li><li><p>  Andernfalls müssen wir die Trennung mithilfe des Verzweigungsknotens durchführen, wie im oben beschriebenen Fall. </p><br></li></ol><br><p>  Dementsprechend ist der Code: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  Die Prozedur <code>_create_branch_extension</code> entspricht logisch der Prozedur <code>_create_branch_leaf</code> , funktioniert jedoch mit dem Erweiterungsknoten. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Aber mit dem Branch-Node ist alles einfach.  Wenn der Pfad leer ist, speichern wir einfach den neuen Wert im aktuellen Zweigknoten.  Wenn der Pfad nicht leer ist, „beißen“ wir ein Knabbern davon ab und gehen rekursiv tiefer. </p><br><p>  Ich denke, der Code braucht keine Kommentare. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  löschen </h3><br><p>  Fuh!  Die letzte Methode bleibt bestehen.  Er ist der fröhlichste.  Die Komplexität des Löschens besteht darin, dass wir die Struktur in den Zustand zurückversetzen müssen, in den sie gefallen wäre, wenn wir die gesamte <code>update</code> ohne den gelöschten Schlüssel durchgeführt hätten. </p><br><p>   ,       ,     ,      ,    .   "",   ,      . </p><br><p>         .  ,   N-        ,    N+1 .      enum — <code>DeleteAction</code> ,    . </p><br><p>    <code>delete</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      —     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" —    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   —    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    —   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     … </p><br><p>  Warum?   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    —     Leaf-.          —      Extension-.         ,    ,    2   —  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> — <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    — Leaf  Extension,           ,   . </p><br><p>     — Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  Der Rest </h3><br><p>      .  , …    <code>root</code> . </p><br><p>  Hier: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  …  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> —  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="That's all folks!"></p><br><h2 id="rezultaty">  Ergebnisse </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    —  ,       . </p><br><p> -,   ,  ,            — .  ,        skip list  interval tree,     — , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     —   . </p><br><p>   ,  ,        —    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446558/">https://habr.com/ru/post/de446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446546/index.html">Microsoft erweitert Azure IP Advantage um neue IP-Vorteile für Azure IoT-Innovatoren und -Starts</a></li>
<li><a href="../de446548/index.html">Analyse von Statistiken zu Werbekampagnen - Erstellen Sie eine neue Metrik im DataFrame (Python)</a></li>
<li><a href="../de446550/index.html">Probleme mit Koordinatormustern und was hat RouteComposer damit zu tun?</a></li>
<li><a href="../de446552/index.html">Arbeiten mit APDU-Befehlen anhand des Beispiel-EToken</a></li>
<li><a href="../de446554/index.html">Yandex Resident Program oder Wie man aus einem erfahrenen Backend ein ML-Ingenieur wird</a></li>
<li><a href="../de446560/index.html">"Courtesy Exchange": die Essenz des Konflikts zwischen den beiden bekanntesten Streaming-Unternehmen</a></li>
<li><a href="../de446562/index.html">Asynchronität in der Programmierung</a></li>
<li><a href="../de446566/index.html">Projekt Null. Wie Amazon mit Fälschungen umgehen will</a></li>
<li><a href="../de446568/index.html">Umbraco 8 umfangreiches CMS-Update: Was ist neu?</a></li>
<li><a href="../de446570/index.html">Die Geschichte der ersten GPU: Rendition Vérité 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>