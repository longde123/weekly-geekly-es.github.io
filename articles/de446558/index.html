<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚ÄçüöÄ üï∫üèΩ üßëüèæ‚Äçü§ù‚Äçüßëüèæ Exotische Datenstrukturen: Modifizierte Merkle Patricia Trie üå∞ ‚ú¥Ô∏è üíà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""An was f√ºr einen Teufel sollte ich mich auswendig an all diese verdammten Algorithmen und Datenstrukturen erinnern?" 


 Diesbez√ºglich kommt es auf d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exotische Datenstrukturen: Modifizierte Merkle Patricia Trie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446558/"><p>  <em>"An was f√ºr einen Teufel sollte ich mich auswendig an all diese verdammten Algorithmen und Datenstrukturen erinnern?"</em> </p><br><p>  Diesbez√ºglich kommt es auf die Kommentare der meisten Artikel zum Durchgang technischer Interviews an.  Die Hauptthese lautet in der Regel, dass alles, was auf die eine oder andere Weise verwendet wird, bereits zehnmal implementiert wurde und es h√∂chst unwahrscheinlich ist, dass sich dieser gew√∂hnliche Programmierer damit befassen muss.  Nun, bis zu einem gewissen Grad ist dies wahr.  Aber wie sich herausstellte, wurde nicht alles implementiert, und ich musste leider (oder zum Gl√ºck?) Immer noch eine Datenstruktur erstellen. </p><br><p>  Geheimnisvolle modifizierte Merkle Patricia Trie. </p><br><p>  Da es zu diesem Baum √ºberhaupt keine Informationen √ºber den Habr und das Medium gibt - ein bisschen mehr - m√∂chte ich Ihnen sagen, um welche Art von Tier es sich handelt und womit es gefressen wird. </p><br><p><img src="https://habrastorage.org/webt/mc/ar/6q/mcar6qnrhs1vh6noextlta_dpfo.png" alt="KDPV"></p><a name="habracut"></a><br><h2 id="chto-eto">  Was ist das? </h2><br><p>  <em>Haftungsausschluss: Die Hauptinformationsquelle f√ºr die Implementierung war f√ºr mich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gelbe Papier</a> sowie die Quellcodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parity-Ethereum</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Ethereum</a> .</em>  <em>Es gab ein Minimum an theoretischen Informationen zur Rechtfertigung bestimmter Entscheidungen, daher sind alle Schlussfolgerungen √ºber die Gr√ºnde f√ºr bestimmte Entscheidungen meine pers√∂nlichen.</em>  <em>Falls ich mich in etwas irre - ich freue mich √ºber Korrekturen in den Kommentaren.</em> </p><br><p>  <em>Ein Baum</em> ist eine Datenstruktur, die ein zusammenh√§ngender azyklischer Graph ist.  Hier ist alles einfach, das kennt jeder. </p><br><p>  <em>Der Pr√§fixbaum</em> ist der Stammbaum, in dem Schl√ºssel-Wert-Paare gespeichert werden k√∂nnen, da die Knoten in zwei Typen unterteilt sind: diejenigen, die einen Teil des Pfads (Pr√§fix) enthalten, und Blattknoten, die den gespeicherten Wert enthalten.  Ein Wert ist in einem Baum genau dann vorhanden, wenn wir mit dem Schl√ºssel den ganzen Weg von der Wurzel des Baums gehen und einen Knoten mit einem Wert am Ende finden k√∂nnen. </p><br><p>  <em>Der PATRICIA-Baum</em> ist ein Pr√§fixbaum, in dem die Pr√§fixe bin√§r sind - das hei√üt, jeder Schl√ºsselknoten speichert Informationen √ºber ein Bit. </p><br><p>  <em>Der Merkle-</em> Baum ist ein Hash-Baum, der auf einer Art Datenkette aufgebaut ist und dieselben Hashes zu einem (Root) zusammenfasst und Informationen √ºber den Status aller Datenbl√∂cke speichert.  Das hei√üt, der Root-Hash ist eine Art "digitale Signatur" des Zustands der Blockkette.  Dieses Ding wird aktiv in der Blockchain verwendet, und mehr dar√ºber finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p><img src="https://habrastorage.org/webt/ui/x4/nr/uix4nregm5i_dcxm5cgxsv27hjg.png" alt="Harte Arbeit ist ..."></p><br><p>  Gesamt: Modifizierte Merkle Patricia Trie (im Folgenden kurz MPT) ist ein Hash-Baum, in dem Schl√ºssel-Wert-Paare gespeichert werden, w√§hrend die Schl√ºssel in bin√§rer Form dargestellt werden.  Und worum es genau bei ‚ÄûModified‚Äú geht, erfahren wir etwas sp√§ter, wenn wir die Implementierung besprechen. </p><br><h2 id="zachem-eto">  Warum ist das so? </h2><br><p>  MPT wird im Ethereum-Projekt verwendet, um Daten √ºber Konten, Transaktionen, Ergebnisse ihrer Ausf√ºhrung und andere Daten zu speichern, die f√ºr das Funktionieren des Systems erforderlich sind. <br>  Im Gegensatz zu Bitcoin, bei dem der Status implizit ist und von jedem Knoten unabh√§ngig berechnet wird, wird der Kontostand jedes Kontos (sowie die damit verbundenen Daten) direkt in der Blockchain in der Luft gespeichert.  Dar√ºber hinaus sollte das Auffinden und die Invarianz von Daten kryptografisch bereitgestellt werden - nur wenige Personen verwenden Kryptow√§hrung, bei der sich der Kontostand eines zuf√§lligen Kontos ohne objektive Gr√ºnde √§ndern kann. </p><br><p>  Das Hauptproblem der Entwickler von Ethereum ist die Erstellung einer Datenstruktur, mit der Sie Schl√ºssel-Wert-Paare effektiv speichern und gleichzeitig die gespeicherten Daten √ºberpr√ºfen k√∂nnen.  Also erschien MPT. </p><br><h2 id="kak-eto">  Wie ist es? </h2><br><p>  MPT ist ein Pr√§fix-PATRICIA-Baum, in dem die Schl√ºssel Folgen von Bytes sind. </p><br><p>  Die Kanten in diesem Baum sind Halbbyte-Sequenzen (halbe Bytes).  Dementsprechend kann ein Knoten bis zu 16 Nachkommen haben (entsprechend Zweigen von 0x0 bis 0xF). </p><br><p>  Knoten sind in 3 Typen unterteilt: </p><br><ul><li>  Zweigknoten.  Der zum Verzweigen verwendete Knoten.  Enth√§lt bis zu 1 bis 16 Links zu untergeordneten Knoten.  Kann auch einen Wert enthalten. </li><li>  Erweiterungsknoten.  Ein Hilfsknoten, der einen Teil des Pfads speichert, der mehreren untergeordneten Knoten gemeinsam ist, sowie eine Verkn√ºpfung zum Zweigknoten, der darunter liegt. </li><li>  Blattknoten.  Ein Knoten, der einen Teil des Pfads und einen gespeicherten Wert enth√§lt.  Es ist das Ende in der Kette. </li></ul><br><p> Wie bereits erw√§hnt, basiert MPT auf einem anderen kv-Repository, in dem Knoten in Form von "link" =&gt; " <code>RLP</code> codierter Knoten" gespeichert werden. </p><br><p>  <em>Und hier haben wir ein neues Konzept: RLP.</em>  <em>Kurz gesagt, dies ist eine Methode zum Codieren von Daten, die Listen oder Bytesequenzen darstellen.</em>  <em>Beispiel: <code>[ "cat", "dog" ] = [ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]</code> .</em>  <em>Ich werde nicht besonders auf Details eingehen, und bei der Implementierung verwende ich eine vorgefertigte Bibliothek, da auch die Berichterstattung √ºber dieses Thema einen bereits ziemlich gro√üen Artikel aufbl√§hen wird.</em>  <em>Wenn Sie noch interessiert sind, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr lesen.</em>  <em>Wir beschr√§nken uns auf die Tatsache, dass wir Daten in <code>RLP</code> codieren und zur√ºckdecodieren k√∂nnen.</em> </p><br><p>  Eine Verbindung zu einem Knoten ist wie folgt definiert: Wenn die L√§nge des <code>RLP</code> codierten Knotens 32 oder mehr Bytes betr√§gt, ist die Verbindung ein <code>keccak</code> Hash aus der <code>RLP</code> Darstellung des Knotens.  Wenn die L√§nge weniger als 32 Bytes betr√§gt, ist die Verbindung die <code>RLP</code> Darstellung des Knotens selbst. </p><br><p>  Im zweiten Fall m√ºssen Sie den Knoten nat√ºrlich nicht in der Datenbank speichern, weil  Es wird vollst√§ndig im √ºbergeordneten Knoten gespeichert. </p><br><p><img src="https://habrastorage.org/webt/rs/vz/0j/rsvz0j-fmp0f3p35phzmkxzbzlw.png" alt="Knoten sind unterschiedlich"></p><br><p>  Die Kombination von drei Knotentypen erm√∂glicht es Ihnen, Daten effektiv zu speichern, wenn nur wenige Schl√ºssel vorhanden sind (dann werden die meisten Pfade in Erweiterungs- und Blattknoten gespeichert und es gibt nur wenige Verzweigungsknoten) und wenn viele Knoten vorhanden sind (Pfade werden nicht explizit gespeichert). aber sie "sammeln" sich w√§hrend des Durchgangs durch Zweigknoten). </p><br><p>  Ein vollst√§ndiges Beispiel eines Baums mit allen Arten von Knoten: </p><br><p><img src="https://habrastorage.org/webt/tm/8y/_p/tm8y_p43ggyutxiw5a7murovrpa.png" alt="Der Baum ist voll aber nicht dick"></p><br><p>  Wie Sie vielleicht bemerkt haben, haben die gespeicherten Teile der Pfade Pr√§fixe.  Pr√§fixe werden f√ºr verschiedene Zwecke ben√∂tigt: </p><br><ol><li>  Unterscheidungsknoten von Blattknoten unterscheiden. </li><li>  Zum Ausrichten von Sequenzen einer ungeraden Anzahl von Knabbereien. </li></ol><br><p>  Die Regeln zum Erstellen von Pr√§fixen sind sehr einfach: </p><br><ul><li>  Das Pr√§fix ben√∂tigt 1 Nibble.  Wenn die Pfadl√§nge (ohne das Pr√§fix) ungerade ist, beginnt der Pfad unmittelbar nach dem Pr√§fix.  Wenn die Pfadl√§nge gerade ist, wird zum Ausrichten nach dem Pr√§fix zuerst Nibble 0x0 hinzugef√ºgt. </li><li>  Das Pr√§fix ist anf√§nglich 0x0. </li><li>  Wenn die Pfadl√§nge ungerade ist, wird 0x1 zum Pr√§fix hinzugef√ºgt, wenn gerade - 0x0. </li><li>  Wenn der Pfad zu einem Blattknoten f√ºhrt, wird 0x2 zum Pr√§fix hinzugef√ºgt, wenn 0x0 zum Erweiterungsknoten hinzugef√ºgt wird. </li></ul><br><p>  Bei Beatiks wird es meiner Meinung nach klarer: </p><br><pre> <code class="plaintext hljs">0b0000 =&gt;  , Extension  0b0001 =&gt;  , Extension  0b0010 =&gt;  , Leaf  0b0011 =&gt;  , Leaf </code> </pre> <br><h3 id="udalenie-kotoroe-ne-udalenie">  Entfernung, die keine Entfernung ist </h3><br><p>  Trotz der Tatsache, dass der Baum Knoten l√∂scht, bleibt alles, was einmal hinzugef√ºgt wurde, f√ºr immer im Baum. </p><br><p>  Dies ist erforderlich, um nicht f√ºr jeden Block einen vollst√§ndigen Baum zu erstellen, sondern nur den Unterschied zwischen der alten und der neuen Version des Baums zu speichern. </p><br><p>  Dementsprechend k√∂nnen wir unter Verwendung verschiedener Root-Hashes als Einstiegspunkt jeden der Zust√§nde abrufen, in denen sich der Baum jemals befunden hat. </p><br><p><img src="https://habrastorage.org/webt/lv/-e/mr/lv-emrvfxac4ccdfi38ps6ajvfs.png" alt="Was ist mit einem Stift geschrieben ..."></p><br><p>  Dies sind nicht alle Optimierungen.  Es gibt noch mehr, aber wir werden nicht dar√ºber sprechen - und so ist der Artikel gro√ü.  Sie k√∂nnen jedoch selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> . </p><br><h2 id="realizaciya">  Implementierung </h2><br><p>  Die Theorie ist vorbei, lasst uns zur Praxis √ºbergehen.  Wir werden Verkehrssprache aus der IT-Welt verwenden, das ist <code>python</code> . </p><br><p>  Da es viel Code geben wird und f√ºr das Format des Artikels viel reduziert und geteilt werden muss, werde ich sofort einen Link zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github hinterlassen</a> . <br>  Bei Bedarf sehen Sie dort das ganze Bild. </p><br><p>  Zun√§chst definieren wir die Baumschnittstelle, die wir als Ergebnis erhalten m√∂chten: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Die Schnittstelle ist sehr einfach.  Verf√ºgbare Vorg√§nge sind das Abrufen, L√∂schen, Einf√ºgen und √Ñndern (kombiniert im Update) sowie das Abrufen des Root-Hash. </p><br><p>  Der Speicher wird an die Methode <code>__init__</code> - eine <code>__init__</code> Datenstruktur, in der wir die Knoten sowie <code>root</code> speichern - die "Spitze" des Baums.  Wenn <code>None</code> als <code>root</code> , gehen wir davon aus, dass der Baum leer ist und von Grund auf neu funktioniert. </p><br><p>  _Remark: Sie fragen sich m√∂glicherweise, warum die Variablen in den Methoden als <code>encoded_key</code> und <code>encoded_value</code> und nicht nur als <code>key</code> / <code>value</code> .  Die Antwort ist einfach: Gem√§√ü der Spezifikation m√ºssen alle Schl√ºssel und Werte in <code>RLP</code> codiert sein.  Wir werden uns damit keine Sorgen machen und diesen Beruf den Bibliotheksbenutzern √ºberlassen. </p><br><p>  Bevor wir jedoch mit der Implementierung des Baums selbst beginnen, m√ºssen zwei wichtige Dinge getan werden: </p><br><ol><li>  Implementieren Sie die <code>NibblePath</code> Klasse, eine Kette von Nibbles, um sie nicht manuell zu codieren. </li><li>  So implementieren Sie die <code>Node</code> Klasse im Rahmen dieser Klasse - <code>Extension</code> , <code>Leaf</code> und <code>Branch</code> . </li></ol><br><h3 id="nibblepath">  Knabberweg </h3><br><p>  Also, <code>NibblePath</code> .  Da wir uns aktiv im Baum bewegen, sollte die Grundlage f√ºr die Funktionalit√§t unserer Klasse die F√§higkeit sein, den "Versatz" vom Anfang des Pfades an festzulegen und ein bestimmtes Knabbern zu erhalten.  In diesem Wissen definieren wir die Basis unserer Klasse (sowie einige n√ºtzliche Konstanten f√ºr die Arbeit mit den folgenden Pr√§fixen): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> ODD_FLAG = <span class="hljs-number"><span class="hljs-number">0x10</span></span> LEAF_FLAG = <span class="hljs-number"><span class="hljs-number">0x20</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, offset=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self._data = data <span class="hljs-comment"><span class="hljs-comment"># ,   . self._offset = offset #      def consume(self, amount): # "" N      . self._offset += amount return self def at(self, idx): #      idx = idx + self._offset #    ,   ,    , #   ,    -      . byte_idx = idx // 2 nibble_idx = idx % 2 #   . byte = self._data[byte_idx] #      . nibble = byte &gt;&gt; 4 if nibble_idx == 0 else byte &amp; 0x0F return nibble</span></span></code> </pre> <br><p>  Ganz einfach, nicht wahr? </p><br><p>  Es bleiben nur Funktionen zum Codieren und Decodieren einer Folge von Halbbytes zu schreiben. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NibblePath</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def decode_with_type(data): #   : # ,     ,    . is_odd_len = data[0] &amp; NibblePath.ODD_FLAG == NibblePath.ODD_FLAG is_leaf = data[0] &amp; NibblePath.LEAF_FLAG == NibblePath.LEAF_FLAG #    ,     #    . offset  , #       "" . offset = 1 if is_odd_len else 2 return NibblePath(data, offset), is_leaf def encode(self, is_leaf): output = [] #    ,       . nibbles_len = len(self._data) * 2 - self._offset is_odd = nibbles_len % 2 == 1 #  . prefix = 0x00 #    ,    . #      (self.at(0))     . #           (0x0). prefix += self.ODD_FLAG + self.at(0) if is_odd else 0x00 #  ,  Leaf node,  . prefix += self.LEAF_FLAG if is_leaf else 0x00 output.append(prefix) # ,      ,  . pos = nibbles_len % 2 #          , #     2 ,    , #     , #    . while pos &lt; nibbles_len: byte = self.at(pos) * 16 + self.at(pos + 1) output.append(byte) pos += 2 return bytes(output)</span></span></code> </pre> <br><p>  Im Prinzip ist dies das Minimum, das f√ºr ein bequemes Arbeiten mit Knabbereien erforderlich ist.  Nat√ºrlich gibt es in der aktuellen Implementierung noch eine Reihe von Hilfsmethoden (z. B. <code>combine</code> , Zusammenf√ºhren von zwei Pfaden zu einem), aber ihre Implementierung ist sehr trivial.  Bei Interesse finden Sie die Vollversion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><h3 id="node">  Knoten </h3><br><p>  Wie wir bereits wissen, sind unsere Knoten in drei Typen unterteilt: Blatt, Erweiterung und Zweig.  Alle k√∂nnen codiert und decodiert werden, und der einzige Unterschied besteht in den darin gespeicherten Daten.  Um ehrlich zu sein, sind dies algebraische Datentypen, und in <code>Rust</code> w√ºrde ich zum Beispiel etwas im Geiste schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { Leaf(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]), Extension(NibblesSlice&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, NodeReference), Branch([<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NodeReference&gt;; <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;), }</code> </pre> <br><p>  In Python als solchem ‚Äã‚Äãgibt es jedoch kein ADT. Daher definieren wir die <code>Node</code> Klasse. Darin befinden sich drei Klassen, die den Knotentypen entsprechen.  Wir implementieren die Codierung direkt in den Knotenklassen und die Decodierung in der <code>Node</code> . </p><br><p>  Die Implementierung ist jedoch elementar: </p><br><p>  Blatt: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, data)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -  . return rlp.encode([self.path.encode(True), self.data])</span></span></code> </pre> <br><p>  Erweiterung: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extension</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, next_ref)</span></span></span><span class="hljs-function">:</span></span> self.path = path self.next_ref = next_ref <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    , #   -  ,   -    . next_ref = _prepare_reference_for_encoding(self.next_ref) return rlp.encode([self.path.encode(False), next_ref])</span></span></code> </pre> <br><p>  Zweig: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Branch</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches, data=None)</span></span></span><span class="hljs-function">:</span></span> self.branches = branches self.data = data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    --    ,  #  16 -     (  ), #   -   (  ). branches = list(map(_prepare_reference_for_encoding, self.branches)) return rlp.encode(branches + [self.data])</span></span></code> </pre> <br><p>  Alles ist sehr einfach.  Das einzige, was Fragen verursachen kann, ist die Funktion <code>_prepare_reference_for_encoding</code> . </p><br><p>  <em>Dann gestehe ich, ich musste eine kleine Kr√ºcke benutzen.</em>  <em>Tatsache ist, dass die verwendete <code>rlp</code> Bibliothek die Daten rekursiv decodiert und die Verkn√ºpfung zu einem anderen Knoten, wie wir wissen, <code>rlp</code> Daten sein kann (falls der codierte Knoten weniger als 32 Zeichen lang ist).</em>  <em>Das Arbeiten mit Links in zwei Formaten - Hash-Bytes und einem dekodierten Knoten - ist sehr unpraktisch.</em>  <em>Aus diesem Grund habe ich zwei Funktionen geschrieben, die nach dem Dekodieren des Knotens die Links im Byte-Format zur√ºckgeben und gegebenenfalls vor dem Speichern dekodieren.</em>  <em>Diese Funktionen sind:</em> </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_reference_for_encoding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ( ,   ) --  . #       :) if 0 &lt; len(ref) &lt; 32: return rlp.decode(ref) return ref def _prepare_reference_for_usage(ref): #     -   . #          . if isinstance(ref, list): return rlp.encode(ref) return ref</span></span></code> </pre> <br><p>  Beenden Sie mit Knoten, indem Sie eine <code>Node</code> schreiben.  Es gibt nur zwei Methoden: Dekodieren Sie den Knoten und verwandeln Sie den Knoten in eine Verkn√ºpfung. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># class Leaf(...) # class Extension(...) # class Branch(...) def decode(encoded_data): data = rlp.decode(encoded_data) # 17  -  Branch . if len(data) == 17: branches = list(map(_prepare_reference_for_usage, data[:16])) node_data = data[16] return Node.Branch(branches, node_data) #    17,   2.   - . #      ,     . path, is_leaf = NibblePath.decode_with_type(data[0]) if is_leaf: return Node.Leaf(path, data[1]) else: ref = _prepare_reference_for_usage(data[1]) return Node.Extension(path, ref) def into_reference(node): #    . #      32 , #   -   . #       . encoded_node = node.encode() if len(encoded_node) &lt; 32: return encoded_node else: return keccak_hash(encoded_node)</span></span></code> </pre> <br><h2 id="pereryv">  Eine Pause </h2><br><p>  Fuh!  Es gibt viele Informationen.  Ich denke es ist Zeit sich zu entspannen.  Hier ist eine weitere Katze f√ºr dich: </p><br><p><img src="https://habrastorage.org/webt/cn/qu/jt/cnqujtdcxdavek8wvwghernczvk.png" alt="Sie k√∂nnen w√§hrend der Pause einen Bissen haben"></p><br><p>  Milota, richtig?  Okay, zur√ºck zu unseren B√§umen. </p><br><h2 id="merklepatriciatrie">  MerklePatriciaTrie </h2><br><p>  Hurra - Hilfselemente sind fertig, wir gehen zu den leckersten √ºber.  F√ºr alle F√§lle erinnere ich die Benutzeroberfl√§che an unseren Baum.  Gleichzeitig implementieren wir die Methode <code>__init__</code> . </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, storage, root=None)</span></span></span><span class="hljs-function">:</span></span> self._storage = storage self._root = root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key, encoded_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, encoded_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  Aber mit den restlichen Methoden werden wir uns eins nach dem anderen befassen. </p><br><h3 id="get">  bekommen </h3><br><p>  Die <code>get</code> Methode (wie im Prinzip die anderen Methoden) besteht aus zwei Teilen.  Die Methode selbst bereitet die Daten vor und bringt das Ergebnis in die erwartete Form, w√§hrend die eigentliche Arbeit innerhalb der Hilfsmethode erfolgt. </p><br><p>  Die grundlegende Methode ist sehr einfach: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def get(self, encoded_key): if not self._root: raise KeyError path = NibblePath(encoded_key) #       #  ,    ,    . result_node = self._get(self._root, path) if type(result_node) is Node.Extension or len(result_node.data) == 0: raise KeyError return result_node.data</span></span></code> </pre> <br><p>  <code>_get</code> nicht viel komplizierter: Um zum gew√ºnschten Knoten zu gelangen, m√ºssen wir vom Stamm zum gesamten bereitgestellten Pfad wechseln.  Wenn wir am Ende einen Knoten mit Daten gefunden haben (Blatt oder Zweig) - Hurra, werden die Daten empfangen.  Wenn das Bestehen nicht m√∂glich war, fehlt der erforderliche Schl√ºssel im Baum. </p><br><p>  Implementierung: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get(self, node_ref, path): #      . node = self._get_node(node_ref) #    --   . #   ,      . if len(path) == 0: return node if type(node) is Node.Leaf: #     Leaf-,     , #      . if node.path == path: return node elif type(node) is Node.Extension: #    -- Extension,    . if path.starts_with(node.path): rest_path = path.consume(len(node.path)) return self._get(node.next_ref, rest_path) elif type(node) is Node.Branch: #    -- Branch,     . #   ,           #  :      . branch = node.branches[path.at(0)] if len(branch) &gt; 0: return self._get(branch, path.consume(1)) #    ,        , #     . raise KeyError</span></span></code> </pre> <br><p>  Gleichzeitig werden wir Methoden zum Speichern und Laden von Knoten schreiben.  Sie sind einfach: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def _get_node(self, node_ref): raw_node = None if len(node_ref) == 32: raw_node = self._storage[node_ref] else: raw_node = node_ref return Node.decode(raw_node) def _store_node(self, node): reference = Node.into_reference(node) if len(reference) == 32: self._storage[reference] = node.encode() return reference</span></span></code> </pre> <br><h3 id="update">  Update </h3><br><p>  Die <code>update</code> Methode ist bereits interessanter.  Gehen Sie einfach bis zum Ende durch und f√ºgen Sie den Blattknoten ein, der nicht immer funktioniert.  Es ist wahrscheinlich, dass sich der Schl√ºsseltrennpunkt irgendwo innerhalb des bereits gespeicherten Blatt- oder Erweiterungsknotens befindet.  In diesem Fall m√ºssen Sie sie trennen und mehrere neue Knoten erstellen. </p><br><p>  Im Allgemeinen kann jede Logik durch die folgenden Regeln beschrieben werden: </p><br><ol><li>  W√§hrend der Pfad vollst√§ndig mit den vorhandenen Knoten √ºbereinstimmt, steigen wir den Baum rekursiv ab. </li><li>  Wenn der Pfad fertig ist und wir uns im Zweig- oder Blattknoten befinden, bedeutet dies, dass durch <code>update</code> einfach der Wert aktualisiert wird, der diesem Schl√ºssel entspricht. </li><li>  Wenn die Pfade geteilt sind (dh wir aktualisieren den Wert nicht, sondern f√ºgen einen neuen ein), befinden wir uns im Zweigknoten. Erstellen Sie einen Blattknoten und geben Sie im entsprechenden Zweigzweig einen Link dazu an. </li><li>  Wenn die Pfade geteilt sind und wir uns im Blatt- oder Erweiterungsknoten befinden, m√ºssen wir einen Verzweigungsknoten erstellen, der die Pfade trennt, und gegebenenfalls einen Erweiterungsknoten f√ºr den gemeinsamen Teil des Pfads. </li></ol><br><p>  Lassen Sie uns dies schrittweise im Code ausdr√ºcken.  Warum nach und nach?  Weil die Methode gro√ü ist und es schwierig sein wird, sie in gro√üen Mengen zu verstehen. <br>  Ich werde hier jedoch einen Link zur vollst√§ndigen Methode hinterlassen. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def update(self, encoded_key, encoded_value): path = NibblePath(encoded_key) result = self._update(self._root, path, encoded_value) self._root = result def _update(self, node_ref, path, value): #       (,   ), #       . if not node_ref: return self._store_node(Node.Leaf(path, value)) #          #    . node = self._get_node(node_ref) if type(node) == Node.Leaf: ... elif type(node) == Node.Extension: ... elif type(node) == Node.Branch: ...</span></span></code> </pre> <br><p>  Es gibt nicht genug allgemeine Logik, das Interessanteste ist drinnen, <code>if</code> s. </p><br><h5 id="if-typenode--nodeleaf"> <code>if type(node) == Node.Leaf</code> </h5> <br><p>  Lassen Sie uns zun√§chst die Blattknoten behandeln.  Mit ihnen sind nur 2 Szenarien m√∂glich: </p><br><ol><li><p>  Der Rest des Pfades, dem wir folgen, entspricht genau dem Pfad, der im Blattknoten gespeichert ist.  In diesem Fall m√ºssen wir nur den Wert √§ndern, den neuen Knoten speichern und einen Link dazu zur√ºckgeben. </p><br></li><li><p>  Die Wege sind unterschiedlich. <br>  In diesem Fall m√ºssen Sie einen Verzweigungsknoten erstellen, der die beiden Pfade trennt. <br>  Wenn einer der Pfade leer ist, wird sein Wert direkt an den Verzweigungsknoten √ºbertragen. <br>  Andernfalls m√ºssen zwei Blattknoten erstellt werden, die um die L√§nge des gemeinsamen Teils der Pfade + 1 Halbbyte verk√ºrzt sind (dieses Halbbyte wird durch den Index des entsprechenden Zweigs des Zweigknotens angezeigt). </p><br></li></ol><br><p>  Sie m√ºssen auch √ºberpr√ºfen, ob es einen gemeinsamen Teil des Pfads gibt, um zu verstehen, ob wir auch einen Erweiterungsknoten erstellen m√ºssen. </p><br><p>  Im Code sieht es folgenderma√üen aus: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.path == path: <span class="hljs-comment"><span class="hljs-comment">#  .       . node.data = value return self._store_node(node) #    . #    . common_prefix = path.common_prefix(node.path) #      . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch . branch_reference = self._create_branch_node(path, value, node.path, node.data) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  Die Prozedur <code>_create_branch_node</code> lautet wie folgt: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_branch_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path_a, value_a, path_b, value_b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Branch-. branches = [b''] * 16 # ,     Branch- . branch_value = b'' if len(path_a) == 0: branch_value = value_a elif len(path_b) == 0: branch_value = value_b #    Leaf-,  . self._create_branch_leaf(path_a, value_a, branches) self._create_branch_leaf(path_b, value_b, branches) #  Branch-     . return self._store_node(Node.Branch(branches, branch_value)) def _create_branch_leaf(self, path, value, branches): # ,     Leaf-. if len(path) &gt; 0: #    ( ). idx = path.at(0) #  Leaf-   ,     . leaf_ref = self._store_node(Node.Leaf(path.consume(1), value)) branches[idx] = leaf_ref</span></span></code> </pre> <br><h5 id="if-typenode--nodeextension"> <code>if type(node) == Node.Extension</code> </h5> <br><p>  Im Fall des Erweiterungsknotens sieht alles wie ein Blattknoten aus. </p><br><ol><li><p>  Wenn der Pfad vom Erweiterungsknoten ein Pr√§fix f√ºr unseren Pfad ist, fahren wir einfach rekursiv fort. </p><br></li><li><p>  Andernfalls m√ºssen wir die Trennung mithilfe des Verzweigungsknotens durchf√ºhren, wie im oben beschriebenen Fall. </p><br></li></ol><br><p>  Dementsprechend ist der Code: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.starts_with(node.path): <span class="hljs-comment"><span class="hljs-comment">#         . new_reference = \ self._update(node.next_ref, path.consume(len(node.path)), value) return self._store_node(Node.Extension(node.path, new_reference)) #  Extension-. #     . common_prefix = path.common_prefix(node.path) #  . path.consume(len(common_prefix)) node.path.consume(len(common_prefix)) #  Branch- ,  ,    . branches = [b''] * 16 branch_value = value if len(path) == 0 else b'' #     Leaf-  Extension- . self._create_branch_leaf(path, value, branches) self._create_branch_extension(node.path, node.next_ref, branches) branch_reference = self._store_node(Node.Branch(branches, branch_value)) # ,    Extension-. if len(common_prefix) != 0: return self._store_node(Node.Extension(common_prefix, branch_reference)) else: return branch_reference</span></span></code> </pre> <br><p>  Die Prozedur <code>_create_branch_extension</code> entspricht logisch der Prozedur <code>_create_branch_leaf</code> , funktioniert jedoch mit dem Erweiterungsknoten. </p><br><h5 id="if-typenode--nodebranch"> <code>if type(node) == Node.Branch</code> </h5> <br><p>  Aber mit dem Branch-Node ist alles einfach.  Wenn der Pfad leer ist, speichern wir einfach den neuen Wert im aktuellen Zweigknoten.  Wenn der Pfad nicht leer ist, ‚Äûbei√üen‚Äú wir ein Knabbern davon ab und gehen rekursiv tiefer. </p><br><p>  Ich denke, der Code braucht keine Kommentare. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(Node.Branch(node.branches, value)) idx = path.at(<span class="hljs-number"><span class="hljs-number">0</span></span>) new_reference = self._update(node.branches[idx], path.consume(<span class="hljs-number"><span class="hljs-number">1</span></span>), value) node.branches[idx] = new_reference <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._store_node(node)</code> </pre> <br><h3 id="delete">  l√∂schen </h3><br><p>  Fuh!  Die letzte Methode bleibt bestehen.  Er ist der fr√∂hlichste.  Die Komplexit√§t des L√∂schens besteht darin, dass wir die Struktur in den Zustand zur√ºckversetzen m√ºssen, in den sie gefallen w√§re, wenn wir die gesamte <code>update</code> ohne den gel√∂schten Schl√ºssel durchgef√ºhrt h√§tten. </p><br><p>   ,       ,     ,      ,    .   "",   ,      . </p><br><p>         .  ,   N-        ,    N+1 .      enum ‚Äî <code>DeleteAction</code> ,    . </p><br><p>    <code>delete</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... # Enum, ,         . class _DeleteAction(Enum): #    . #     , #        (_DeleteAction, None). DELETED = 1, #    (,    ). #     ,    #    : (_DeleteAction, ___). UPDATED = 2, #    Branch-  .   -- #    : # (_DeleteAction, (___, ___)) USELESS_BRANCH = 3 def delete(self, encoded_key): if self._root is None: return path = NibblePath(encoded_key) action, info = self._delete(self._root, path) if action == MerklePatriciaTrie._DeleteAction.DELETED: #   . self._root = None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #   . new_root = info self._root = new_root elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #   . _, new_root = info self._root = new_root def _delete(self, node_ref, path): node = self._get_node(node_ref) if type(node) == Node.Leaf: pass elif type(node) == Node.Extension: pass elif type(node) == Node.Branch: pass</span></span></code> </pre> <br><p>      ,      <code>get</code>  <code>update</code> .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><h4 id="if-typenode--nodeleaf-1"> <code>if type(node) == Node.Leaf</code> </h4> <br><p>   .     .      ‚Äî     ,     ,   . </p><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(node) == Node.Leaf: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path == node.path: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MerklePatriciaTrie._DeleteAction.DELETED, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError</code> </pre> <br><p>    ,  "" ‚Äî    .       ,      .              . </p><br><h4 id="if-typenode--nodeextension-1"> <code>if type(node) == Node.Extension</code> </h4> <br><p> C Extension-   : </p><br><ol><li>  ,     Extension-      .   ‚Äî    . </li><li>   <code>_delete</code> , ""   . </li><li>    .  : </li></ol><br><ul><li>    .         . </li><li>    .      . </li><li>      Branch-.          .      ,  Branch-   .      ,   ,    Leaf-.    ‚Äî   Extension-. </li></ul><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Extension: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.starts_with(node.path): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-comment"><span class="hljs-comment">#   . #       . action, info = self._delete(node.next_ref, path.consume(len(node.path))) if action == MerklePatriciaTrie._DeleteAction.DELETED: return action, None elif action == MerklePatriciaTrie._DeleteAction.UPDATED: #    ,     . child_ref = info new_ref = self._store_node(Node.Extension(node.path, child_ref)) return action, new_ref elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #     Branch-. stored_path, stored_ref = info # ,     Branch-. child = self._get_node(stored_ref) new_node = None if type(child) == Node.Leaf: #  branch-  . #     Leaf-  Extension. path = NibblePath.combine(node.path, child.path) new_node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: #  Branch-  Extension-. #       . path = NibblePath.combine(node.path, child.path) new_node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: #  Branch-      Branch-. #    Extension-    . path = NibblePath.combine(node.path, stored_path) new_node = Node.Extension(path, stored_ref) new_reference = self._store_node(new_node) return MerklePatriciaTrie._DeleteAction.UPDATED, new_reference</span></span></code> </pre> <br><h4 id="if-typenode--nodebranch-1"> <code>if type(node) == Node.Branch</code> </h4> <br><p>   . </p><br><p> , .    Branch-,     ‚Ä¶ </p><br><p>  Warum?   Branch-      Leaf- ( )     Extension- (    ). <br> ,        .      ,    ‚Äî     Leaf-.          ‚Äî      Extension-.         ,    ,    2   ‚Äî  Branch-   . </p><br><p>     ?  : </p><br><p>    : </p><br><ol><li>    ,   . </li><li>    ,  <code>_delete</code>   . </li></ol><br><p>      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> type(node) == Node.Branch: action = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(path) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) != <span class="hljs-number"><span class="hljs-number">0</span></span>: node.data = <span class="hljs-string"><span class="hljs-string">b''</span></span> action = MerklePatriciaTrie._DeleteAction.DELETED <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,    . #    . idx = path.at(0) if len(node.branches[idx]) == 0: raise KeyError action, info = self._delete(node.branches[idx], path.consume(1)) #  ,   ,  . #      -    #    . node.branches[idx] = b''</span></span></code> </pre> <br><p>     <code>_DeleteAction</code>       . </p><br><ol><li>       Branch-  ,      (    ,   ).            . </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.UPDATED: <span class="hljs-comment"><span class="hljs-comment">#   . next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference elif action == MerklePatriciaTrie._DeleteAction.USELESS_BRANCH: #    . _, next_ref = info node.branches[idx] = next_ref reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><ol><li>     ( ,  ),   ,      . </li></ol><br><p>      .  : </p><br><ul><li>       .  ,   ,    ,       .  ,  . </li><li>   ,   .   Leaf-   .      . </li><li>  ,   .    ,   ,      . </li><li>   , ,  Branch-   .    ,  <code>_DeleteAction</code> ‚Äî <code>UPDATED</code> . </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == MerklePatriciaTrie._DeleteAction.DELETED: non_empty_count = sum(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, node.branches)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non_empty_count == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.data) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Branch- ,  . return MerklePatriciaTrie._DeleteAction.DELETED, None elif non_empty_count == 0 and len(node.data) != 0: #  ,   . path = NibblePath([]) reference = self._store_node(Node.Leaf(path, node.data)) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference) elif non_empty_count == 1 and len(node.data) == 0: #  ,   . return self._build_new_node_from_last_branch(node.branches) else: #  1+   ,  2+ . # Branch-  ,   - UPDATED. reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.UPDATED, reference</span></span></code> </pre> <br><p>  <code>_build_new_node_from_last_branch</code>           . </p><br><p>    ‚Äî Leaf  Extension,           ,   . </p><br><p>     ‚Äî Branch,      Extension ,        ,      Branch. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_build_new_node_from_last_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, branches)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    . idx = 0 for i in range(len(branches)): if len(branches[i]) &gt; 0: idx = i break #     . prefix_nibble = NibblePath([idx], offset=1) #     child = self._get_node(branches[idx]) path = None node = None #   . if type(child) == Node.Leaf: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Leaf(path, child.data) elif type(child) == Node.Extension: path = NibblePath.combine(prefix_nibble, child.path) node = Node.Extension(path, child.next_ref) elif type(child) == Node.Branch: path = prefix_nibble node = Node.Extension(path, branches[idx]) #  . reference = self._store_node(node) return MerklePatriciaTrie._DeleteAction.USELESS_BRANCH, (path, reference)</span></span></code> </pre> <br><h3 id="ostalnoe">  Der Rest </h3><br><p>      .  , ‚Ä¶    <code>root</code> . </p><br><p>  Hier: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MerklePatriciaTrie</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def root(self): return self._root</span></span></code> </pre> <br><p>   ,   . </p><br><p>  ‚Ä¶  .  ,   ,      Ethereum         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . ,   , ,   .      ,    :) </p><br><p> ,      ,    <code>pip install -U eth_mpt</code> ‚Äî  . </p><br><p><img src="https://habrastorage.org/webt/qm/wo/fx/qmwofx6jaxe_0t50akn0sdnt-0m.png" alt="That's all folks!"></p><br><h2 id="rezultaty">  Ergebnisse </h2><br><p>      ? </p><br><p> , -,      ,  -       ,      ,   .    ‚Äî  ,       . </p><br><p> -,   ,  ,            ‚Äî .  ,        skip list  interval tree,     ‚Äî , , . </p><br><p> -,     ,            .   ,           -  . </p><br><p> -,     ‚Äî   . </p><br><p>   ,  ,        ‚Äî    ! </p><br><h2 id="arty">  </h2><br><p>      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> .   !    ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446558/">https://habr.com/ru/post/de446558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446546/index.html">Microsoft erweitert Azure IP Advantage um neue IP-Vorteile f√ºr Azure IoT-Innovatoren und -Starts</a></li>
<li><a href="../de446548/index.html">Analyse von Statistiken zu Werbekampagnen - Erstellen Sie eine neue Metrik im DataFrame (Python)</a></li>
<li><a href="../de446550/index.html">Probleme mit Koordinatormustern und was hat RouteComposer damit zu tun?</a></li>
<li><a href="../de446552/index.html">Arbeiten mit APDU-Befehlen anhand des Beispiel-EToken</a></li>
<li><a href="../de446554/index.html">Yandex Resident Program oder Wie man aus einem erfahrenen Backend ein ML-Ingenieur wird</a></li>
<li><a href="../de446560/index.html">"Courtesy Exchange": die Essenz des Konflikts zwischen den beiden bekanntesten Streaming-Unternehmen</a></li>
<li><a href="../de446562/index.html">Asynchronit√§t in der Programmierung</a></li>
<li><a href="../de446566/index.html">Projekt Null. Wie Amazon mit F√§lschungen umgehen will</a></li>
<li><a href="../de446568/index.html">Umbraco 8 umfangreiches CMS-Update: Was ist neu?</a></li>
<li><a href="../de446570/index.html">Die Geschichte der ersten GPU: Rendition V√©rit√© 1000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>