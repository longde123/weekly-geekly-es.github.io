<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç£ üåØ üêÜ Escrevendo um balanceador simples no Go üêæ üö∂üèΩ üë®üèΩ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os balanceadores de carga desempenham um papel fundamental na arquitetura da web. Eles permitem que voc√™ distribua a carga por v√°rios back-end, melhor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevendo um balanceador simples no Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t8/nm/ze/t8nmzevaswfyxtitu7xpx3ml-ho.jpeg"></div><br>  Os balanceadores de carga desempenham um papel fundamental na arquitetura da web.  Eles permitem que voc√™ distribua a carga por v√°rios back-end, melhorando a escalabilidade.  E como temos v√°rios back-end configurados, o servi√ßo se torna altamente dispon√≠vel, pois, no caso de uma falha em um servidor, o balanceador pode escolher outro servidor em funcionamento. <br><br>  Tendo tocado com balanceadores profissionais como o NGINX, tentei criar um balanceador simples por divers√£o.  Eu escrevi no Go, √© uma linguagem moderna que suporta paralelismo total.  A biblioteca padr√£o no Go possui muitos recursos e permite gravar aplicativos de alto desempenho com menos c√≥digo.  Al√©m disso, para facilitar a distribui√ß√£o, ele gera um √∫nico bin√°rio estaticamente vinculado. <br><a name="habracut"></a><br><h2>  Como nosso balanceador funciona </h2><br>  Diferentes algoritmos s√£o usados ‚Äã‚Äãpara distribuir a carga entre os back-ends.  Por exemplo: <br><br><ul><li>  Round Robin - a carga √© distribu√≠da uniformemente, levando em considera√ß√£o o mesmo poder de computa√ß√£o dos servidores. </li><li>  Robin redondo ponderado - Dependendo da capacidade de processamento, os servidores podem receber pesos diferentes. </li><li>  Menos conex√µes - a carga √© distribu√≠da entre servidores com o menor n√∫mero de conex√µes ativas. </li></ul><br>  Em nosso balanceador, implementamos o algoritmo mais simples - Round Robin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3e/35c/751/b3e35c7510dc44451088756d14739161.png"></div><br><br><h2>  Sele√ß√£o na Round Robin </h2><br>  O algoritmo Round Robin √© simples.  D√° a todos os artistas a mesma oportunidade de concluir tarefas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/4a7/861/3b34a78610b7c1e2d22b85f0419700d2.png"></div><br>  <i>Selecione servidores no Round Robin para lidar com solicita√ß√µes recebidas.</i> <br><br>  Conforme mostrado na ilustra√ß√£o, o algoritmo seleciona os servidores em um c√≠rculo, ciclicamente.  Mas n√£o podemos selecion√°-los <i>diretamente</i> , certo? <br><br>  E se o servidor estiver mentindo?  Provavelmente n√£o precisamos enviar tr√°fego para ele.  Ou seja, o servidor n√£o pode ser usado diretamente at√© o trazermos ao estado desejado.  √â necess√°rio direcionar o tr√°fego apenas para os servidores que est√£o em funcionamento. <br><br><h2>  Definir a estrutura </h2><br>  Precisamos acompanhar todos os detalhes relacionados ao back-end.  Voc√™ precisa saber se ele est√° vivo e acompanhar o URL.  Para fazer isso, podemos definir a seguinte estrutura: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Backend <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { URL *url.URL Alive <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mux sync.RWMutex ReverseProxy *httputil.ReverseProxy }</code> </pre> <br>  N√£o se preocupe, vou explicar o significado dos campos no back-end. <br><br>  Agora, no balanceador, voc√™ precisa rastrear de alguma forma todos os back-ends.  Para fazer isso, voc√™ pode usar o Slice e um contador vari√°vel.  Defina-o no ServerPool: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ServerPool <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { backends []*Backend current <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> }</code> </pre> <br><h2>  Usando ReverseProxy </h2><br>  Como j√° determinamos, a ess√™ncia do balanceador √© distribuir o tr√°fego para diferentes servidores e retornar resultados ao cliente.  Como diz a documenta√ß√£o do Go: <br><br>  <i>ReverseProxy √© um manipulador HTTP que recebe solicita√ß√µes recebidas e as envia para outro servidor, proxyizando as respostas de volta ao cliente.</i> <br><br>  Exatamente o que precisamos.  N√£o h√° necessidade de reinventar a roda.  Voc√™ pode simplesmente transmitir nossos pedidos atrav√©s do <code>ReverseProxy</code> . <br><br><pre> <code class="go hljs">u, _ := url.Parse(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080"</span></span>) rp := httputil.NewSingleHostReverseProxy(u) <span class="hljs-comment"><span class="hljs-comment">// initialize your server and add this as handler http.HandlerFunc(rp.ServeHTTP)</span></span></code> </pre> <br>  Utilizando o <code>httputil.NewSingleHostReverseProxy(url)</code> voc√™ pode inicializar o <code>ReverseProxy</code> , que transmitir√° solicita√ß√µes para o <code>url</code> passado.  No exemplo acima, todas as solicita√ß√µes foram enviadas para o host local: 8080 e os resultados foram enviados para o cliente. <br><br>  Se voc√™ observar a assinatura do m√©todo ServeHTTP, poder√° encontrar a assinatura do manipulador HTTP.  Portanto, voc√™ pode pass√°-lo para <code>HandlerFunc</code> em <code>http</code> . <br><br>  Outros exemplos est√£o na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://golang.org/pkg/net/http/">documenta√ß√£o</a> . <br><br>  Para nosso balanceador, voc√™ pode iniciar o <code>ReverseProxy</code> com o <code>URL</code> associado no <code>Backend</code> para que o ReverseProxy roteie solicita√ß√µes para o <code>URL</code> . <br><br><h2>  Processo de sele√ß√£o do servidor </h2><br>  Durante a pr√≥xima sele√ß√£o de servidores, precisamos pular os servidores subjacentes.  Mas voc√™ precisa organizar a contagem. <br><br>  V√°rios clientes se conectam ao balanceador e, quando cada um deles pede ao pr√≥ximo n√≥ para transferir tr√°fego, uma condi√ß√£o de corrida pode ocorrer.  Para evitar isso, podemos bloquear o <code>ServerPool</code> com <code>mutex</code> .  Mas ser√° redundante, al√©m de n√£o querermos bloquear o <code>ServerPool</code> .  S√≥ precisamos aumentar o contador em um. <br><br>  A melhor solu√ß√£o para atender a esses requisitos seria o incremento at√¥mico.  O Go o suporta com o pacote <code>atomic</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *ServerPool)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(atomic.AddUint64(&amp;s.current, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) % <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s.backends))) }</code> </pre> <br>  N√≥s aumentamos atomicamente o valor atual em um e retornamos o √≠ndice alterando o comprimento da matriz.  Isso significa que o valor deve sempre estar no intervalo de 0 ao comprimento da matriz.  No final, estaremos interessados ‚Äã‚Äãem um √≠ndice espec√≠fico, n√£o no contador inteiro. <br><br><h2>  Escolhendo um servidor ativo </h2><br>  J√° sabemos que nossos pedidos s√£o alternados ciclicamente em todos os servidores.  E s√≥ precisamos pular o ocioso. <br><br>  <code>GetNext()</code> sempre retorna um valor que varia de 0 ao comprimento da matriz.  A qualquer momento, podemos obter o pr√≥ximo n√≥ e, se estiver inativo, precisamos procurar mais na matriz como parte do loop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/7a7/fc5/9c17a7fc56f9bf6c9e4583c29127aa55.png"></div><br>  <i>N√≥s passamos pela matriz.</i> <br><br>  Como mostrado na ilustra√ß√£o, queremos ir do pr√≥ximo n√≥ at√© o final da lista.  Isso pode ser feito usando o <code>next + length</code> .  Mas, para selecionar um √≠ndice, voc√™ precisa limit√°-lo ao comprimento da matriz.  Isso pode ser feito facilmente usando a opera√ß√£o de modifica√ß√£o. <br><br>  Depois de encontrarmos um servidor ativo durante a pesquisa, ele deve ser marcado como atual: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetNextPeer returns next active peer to take a connection func (s *ServerPool) GetNextPeer() *Backend { // loop entire backends to find out an Alive backend next := s.NextIndex() l := len(s.backends) + next // start from next and move a full cycle for i := next; i &lt; l; i++ { idx := i % len(s.backends) // take an index by modding with length // if we have an alive backend, use it and store if its not the original one if s.backends[idx].IsAlive() { if i != next { atomic.StoreUint64(&amp;s.current, uint64(idx)) // mark the current one } return s.backends[idx] } } return nil }</span></span></code> </pre><br><h2>  Evitando a condi√ß√£o de corrida na estrutura de back-end </h2><br>  Aqui voc√™ precisa se lembrar de uma quest√£o importante.  A estrutura de <code>Backend</code> cont√©m uma vari√°vel que v√°rias goroutines podem modificar ou consultar ao mesmo tempo. <br><br>  Sabemos que as goroutines ir√£o ler a vari√°vel mais do que escrever nela.  Portanto, para serializar o acesso ao <code>Alive</code> escolhemos o <code>RWMutex</code> . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// SetAlive for this backend func (b *Backend) SetAlive(alive bool) { b.mux.Lock() b.Alive = alive b.mux.Unlock() } // IsAlive returns true when backend is alive func (b *Backend) IsAlive() (alive bool) { b.mux.RLock() alive = b.Alive b.mux.RUnlock() return }</span></span></code> </pre><br><h2>  Solicita√ß√µes de balanceamento </h2><br>  Agora podemos formular um m√©todo simples para equilibrar nossos pedidos.  S√≥ falhar√° se todos os servidores ca√≠rem. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Este m√©todo pode ser passado para o servidor HTTP simplesmente como um <code>HandlerFunc</code> . <br><br><pre> <code class="go hljs">server := http.Server{ Addr: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">":%d"</span></span>, port), Handler: http.HandlerFunc(lb), }</code> </pre><br><h2>  Roteamos o tr√°fego apenas para servidores em execu√ß√£o </h2><br>  Nosso balanceador tem um problema s√©rio.  N√£o sabemos se o servidor est√° em execu√ß√£o.  Para descobrir, voc√™ precisa verificar o servidor.  Existem duas maneiras de fazer isso: <br><br><ul><li>  Ativo: executando a solicita√ß√£o atual, descobrimos que o servidor selecionado n√£o est√° respondendo e a marcamos como ocioso. </li><li>  Passivo: voc√™ pode executar ping nos servidores em algum intervalo e verificar o status. </li></ul><br><h2>  Verificando ativamente os servidores em execu√ß√£o </h2><br>  Se <code>ReverseProxy</code> algum erro <code>ReverseProxy</code> inicia a fun√ß√£o de retorno de chamada <code>ErrorHandler</code> .  Isso pode ser usado para detectar falhas: <br><br><pre> <code class="go hljs">proxy.ErrorHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(writer http.ResponseWriter, request *http.Request, e error)</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"[%s] %s\n"</span></span>, serverUrl.Host, e.Error()) retries := GetRetryFromContext(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> retries &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-time.After(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Millisecond): ctx := context.WithValue(request.Context(), Retry, retries+<span class="hljs-number"><span class="hljs-number">1</span></span>) proxy.ServeHTTP(writer, request.WithContext(ctx)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// after 3 retries, mark this backend as down serverPool.MarkBackendStatus(serverUrl, false) // if the same request routing for few attempts with different backends, increase the count attempts := GetAttemptsFromContext(request) log.Printf("%s(%s) Attempting retry %d\n", request.RemoteAddr, request.URL.Path, attempts) ctx := context.WithValue(request.Context(), Attempts, attempts+1) lb(writer, request.WithContext(ctx)) }</span></span></code> </pre> <br>  Ao desenvolver esse manipulador de erros, usamos os recursos de fechamentos.  Isso nos permite capturar vari√°veis ‚Äã‚Äãexternas, como URLs do servidor, em nosso m√©todo.  O manipulador verifica o contador de novas tentativas e, se for menor que 3, enviamos novamente a mesma solicita√ß√£o para o mesmo servidor.  Isso ocorre porque, devido a erros tempor√°rios, o servidor pode interromper nossas solicita√ß√µes, mas logo fica dispon√≠vel (o servidor pode n√£o ter soquetes livres para novos clientes).  Portanto, voc√™ precisa definir o timer de atraso para uma nova tentativa ap√≥s cerca de 10 ms.  A cada solicita√ß√£o, aumentamos o contador de tentativas. <br><br>  Ap√≥s a falha de cada tentativa, marcamos o servidor como ocioso. <br><br>  Agora voc√™ precisa atribuir um novo servidor para a mesma solicita√ß√£o.  Faremos isso usando o contador de tentativas usando o pacote de <code>context</code> .  Depois de aumentar o contador de tentativas, passamos para <code>lb</code> para selecionar um novo servidor para processar a solicita√ß√£o. <br><br>  N√£o podemos fazer isso indefinidamente, portanto, verificaremos <code>lb</code> se o n√∫mero m√°ximo de tentativas foi atingido antes de continuar com o processamento da solicita√ß√£o. <br><br>  Voc√™ pode simplesmente obter o contador de tentativas da solicita√ß√£o, se atingir o m√°ximo, ent√£o interromperemos a solicita√ß√£o. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { attempts := GetAttemptsFromContext(r) if attempts &gt; 3 { log.Printf("%s(%s) Max attempts reached, terminating\n", r.RemoteAddr, r.URL.Path) http.Error(w, "Service not available", http.StatusServiceUnavailable) return } peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Esta √© uma implementa√ß√£o recursiva. <br><br><h2>  Usando o pacote de contexto </h2><br>  O pacote de <code>context</code> permite armazenar dados √∫teis em solicita√ß√µes HTTP.  Usaremos isso ativamente para rastrear dados relacionados a solicita√ß√µes - contadores de <code>Attempt</code> e novas <code>Attempt</code> . <br><br>  Primeiro, voc√™ precisa definir as chaves para o contexto.  √â recomend√°vel usar n√£o string, mas valores num√©ricos exclusivos.  Go possui uma palavra-chave <code>iota</code> para implementa√ß√£o incremental de constantes, cada uma das quais cont√©m um valor exclusivo.  Esta √© uma √≥tima solu√ß√£o para definir chaves num√©ricas. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Attempts <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> Retry )</code> </pre> <br>  Voc√™ pode ent√£o extrair o valor, como costumamos fazer com o <code>HashMap</code> .  O valor padr√£o pode depender da situa√ß√£o atual. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetAttemptsFromContext returns the attempts for request func GetRetryFromContext(r *http.Request) int { if retry, ok := r.Context().Value(Retry).(int); ok { return retry } return 0 }</span></span></code> </pre><br><h2>  Valida√ß√£o passiva do servidor </h2><br>  As verifica√ß√µes passivas identificam e recuperam servidores ca√≠dos.  N√≥s os fazemos ping em um determinado intervalo para determinar seu status. <br><br>  Para executar ping, tente estabelecer uma conex√£o TCP.  Se o servidor responder, marcamos como funcionando.  Este m√©todo pode ser adaptado para chamar pontos de extremidade espec√≠ficos como <code>/status</code> .  Certifique-se de fechar a conex√£o depois que ela for criada para reduzir a carga adicional no servidor.  Caso contr√°rio, ele tentar√° manter essa conex√£o e acabar√° esgotando seus recursos. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// isAlive checks whether a backend is Alive by establishing a TCP connection func isBackendAlive(u *url.URL) bool { timeout := 2 * time.Second conn, err := net.DialTimeout("tcp", u.Host, timeout) if err != nil { log.Println("Site unreachable, error: ", err) return false } _ = conn.Close() // close it, we dont need to maintain this connection return true }</span></span></code> </pre> <br>  Agora voc√™ pode iterar os servidores e marcar seus status: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HealthCheck pings the backends and update the status func (s *ServerPool) HealthCheck() { for _, b := range s.backends { status := "up" alive := isBackendAlive(b.URL) b.SetAlive(alive) if !alive { status = "down" } log.Printf("%s [%s]\n", b.URL, status) } }</span></span></code> </pre> <br>  Para executar esse c√≥digo periodicamente, voc√™ pode executar o cron√¥metro no Go.  Isso permitir√° que voc√™ ou√ßa eventos no canal. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// healthCheck runs a routine for check status of the backends every 2 mins func healthCheck() { t := time.NewTicker(time.Second * 20) for { select { case &lt;-tC: log.Println("Starting health check...") serverPool.HealthCheck() log.Println("Health check completed") } } }</span></span></code> </pre> <br>  Nesse c√≥digo, o canal <code>&lt;-tC</code> retornar√° um valor a cada 20 segundos.  <code>select</code> permite definir este evento.  Na aus√™ncia de uma situa√ß√£o <code>default</code> , aguarda at√© que pelo menos um caso possa ser executado. <br><br>  Agora execute o c√≥digo em uma goroutine separada: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> healthCheck()</code> </pre><br><h2>  Conclus√£o </h2><br>  Neste artigo, examinamos muitas perguntas: <br><br><ul><li>  Algoritmo Round Robin </li><li>  ReverseProxy da biblioteca padr√£o </li><li>  Mutexes </li><li>  Opera√ß√µes at√¥micas </li><li>  Curto-circuito </li><li>  Retornos de chamada </li><li>  Opera√ß√£o de sele√ß√£o </li></ul><br>  Existem muitas outras maneiras de melhorar nosso balanceador.  Por exemplo: <br><br><ul><li>  Use heap para classificar servidores ativos para reduzir o escopo da pesquisa. </li><li>  Colete estat√≠sticas. </li><li>  Implemente o algoritmo round-robin ponderado com o menor n√∫mero de conex√µes. </li><li>  Adicione suporte para arquivos de configura√ß√£o. </li></ul><br>  E assim por diante <br><br>  O c√≥digo fonte est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476276/">https://habr.com/ru/post/pt476276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476264/index.html">Bot de telegrama para aprender l√≠nguas estrangeiras: de palavras cheias a falar</a></li>
<li><a href="../pt476266/index.html">Est√°gio na Mars Digital Technologies. Como aplicamos o aprendizado profundo na M&M</a></li>
<li><a href="../pt476268/index.html">Solu√ß√µes para desafios de detec√ß√£o de bugs oferecidos pela equipe PVS-Studio nas confer√™ncias em 2018-2019</a></li>
<li><a href="../pt476270/index.html">O que ganhou: TopCoder Open 2019</a></li>
<li><a href="../pt476272/index.html">Respostas √†s tarefas do estande PVS-Studio nas confer√™ncias 2018-2019</a></li>
<li><a href="../pt476278/index.html">Confer√™ncia BLACK HAT USA. Enrique√ßa ou morra: ganhe dinheiro na Internet usando o Black Hat. Parte 3</a></li>
<li><a href="../pt476280/index.html">Dos espinhos ao DOS: quatro disquetes que mudaram o mundo</a></li>
<li><a href="../pt476284/index.html">Formulamos uma estrat√©gia para trabalhar com erros no React</a></li>
<li><a href="../pt476286/index.html">Os 5 principais frameworks de JS para desenvolvimento front-end em 2020. Parte 1</a></li>
<li><a href="../pt476288/index.html">Os 5 principais frameworks de JS para desenvolvimento front-end em 2020. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>