<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèª ‚åõÔ∏è üõ†Ô∏è Einf√ºhrung in die Shader-Programmierung f√ºr Layouts üí∏ üë®‚Äçüè´ üëÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebGL gibt es schon lange, viele Artikel wurden √ºber Shader geschrieben, es gibt eine Reihe von Lektionen. Aber zum gr√∂√üten Teil sind sie f√ºr den Layo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in die Shader-Programmierung f√ºr Layouts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420847/"><p><img src="https://habrastorage.org/webt/mx/-v/ry/mx-vryd99xgt73gzsgzhfvcqpe0.jpeg"></p><br><p> WebGL gibt es schon lange, viele Artikel wurden √ºber Shader geschrieben, es gibt eine Reihe von Lektionen.  Aber zum gr√∂√üten Teil sind sie f√ºr den Layout-Designer zu kompliziert.  Es ist sogar noch besser zu sagen, dass sie gro√üe Mengen an Informationen abdecken, die der Entwickler der Spiele-Engine ben√∂tigt, und nicht den Layout-Designer.  Sie beginnen sofort mit dem Erstellen einer komplexen Szene, einer Kamera, eines Lichts ... Auf einer normalen Site ist all dieses Wissen √ºberfl√ºssig, um ein Paar von Effekten mit Fotos zu erstellen.  Infolgedessen erstellen Menschen sehr komplexe architektonische Strukturen und schreiben lange, lange Shader f√ºr im Wesentlichen sehr einfache Aktionen. </p><br><p>  All dies f√ºhrte zu einer Einf√ºhrung in die Aspekte der Arbeit mit Shadern, die f√ºr den Layoutdesigner am wahrscheinlichsten n√ºtzlich sind, um verschiedene 2D-Effekte mit Bildern auf der Site zu erstellen.  Nat√ºrlich angepasst an die Tatsache, dass sie selbst relativ selten im Interface-Design verwendet werden.  Wir werden eine Startvorlage in reinem JS ohne Bibliotheken von Drittanbietern erstellen und die Idee in Betracht ziehen, einige beliebte Effekte basierend auf Pixelverschiebung zu erstellen, die in SVG schwierig sind, aber gleichzeitig einfach mit Shadern implementiert werden k√∂nnen. </p><a name="habracut"></a><br><blockquote> Es wird davon ausgegangen, dass der Leser bereits mit <code>canvas</code> vertraut ist, beschreibt, was WebGL ist, und nur minimale Kenntnisse der Mathematik besitzt.  Einige Punkte werden vereinfacht und nicht akademisch beschrieben, um ein praktisches Verst√§ndnis der Technologien f√ºr die Arbeit mit ihnen zu vermitteln, und nicht eine vollst√§ndige Theorie ihrer inneren K√ºche oder Lernbegriffe.  Daf√ºr gibt es intelligente B√ºcher. </blockquote><p>  <em>Es sollte sofort beachtet werden, dass die in den Artikel von CodePen integrierten Editoren die M√∂glichkeit haben, die Leistung dessen zu beeinflussen, was in ihnen getan wird.</em>  <em>Bevor Sie einen Kommentar schreiben, dass sich etwas auf Ihrem MacBook verlangsamt, stellen Sie sicher, dass das Problem nicht von ihnen herr√ºhrt.</em> </p><br><h2 id="osnovnye-idei">  Hauptideen </h2><br><p>  <strong>Was ist ein Shader?</strong> </p><br><p>  Was ist ein Fragment-Shader?  Dies ist im Wesentlichen ein kleines Programm.  Es wird f√ºr jedes Pixel auf der <code>anvas</code> .  Wenn wir eine Zeichenfl√§che mit einer Gr√∂√üe von 1000 x 500 Pixel haben, wird dieses Programm 500.000 Mal ausgef√ºhrt, wobei jedes Mal die Koordinaten des Pixels, f√ºr das es gerade ausgef√ºhrt wird, als Eingabeparameter empfangen werden.  Dies alles geschieht auf der GPU in einer Vielzahl von parallelen Threads.  Auf dem Zentralprozessor w√ºrden solche Berechnungen viel l√§nger dauern. </p><br><p>  Ein Vertex-Shader ist ebenfalls ein Programm, wird jedoch nicht f√ºr jedes Pixel auf der <code>canvas</code> , sondern f√ºr jeden Vertex in den Formen, aus denen alles im dreidimensionalen Raum erstellt wird.  Auch parallel zu allen Eckpunkten.  Dementsprechend empf√§ngt die Eingabe die Koordinaten des Scheitelpunkts, nicht das Pixel. </p><br><p>  Im Rahmen unserer Aufgabe geschieht Folgendes: </p><br><ul><li>  Wir nehmen einen Satz von Koordinaten der Eckpunkte des Rechtecks, auf die das Foto dann "gezeichnet" wird. </li><li>  Ein Vertex-Shader f√ºr jeden Vertex ber√ºcksichtigt seine Position im Raum.  F√ºr uns kommt es auf einen Sonderfall an - eine Ebene parallel zum Bildschirm.  Fotos in 3d brauchen wir nicht.  Die anschlie√üende Projektion auf die Bildschirmebene kann nichts aussagen. </li><li>  Ferner wird f√ºr jedes sichtbare Fragment und in unserem Kontext f√ºr alle Pixelfragmente ein Fragment-Shader ausgef√ºhrt, der ein Foto und aktuelle Koordinaten aufnimmt, etwas z√§hlt und Farbe f√ºr dieses bestimmte Pixel ausgibt. </li><li>  Wenn der Fragment-Shader keine Logik enth√§lt, √§hnelt das Verhalten all dessen der <code>drawImage()</code> -Methode von <code>canvas</code> .  Aber dann f√ºgen wir genau diese Logik hinzu und erhalten viele interessante Dinge. </li></ul><br><p>  Dies ist eine sehr vereinfachte Beschreibung, aber es sollte klar sein, wer was tut. </p><br><p>  <strong>Ein wenig √ºber die Syntax</strong> </p><br><p>  Shader sind in GLSL - OpenGL Shading Language geschrieben.  Diese Sprache ist C. sehr √§hnlich.  Es ist nicht sinnvoll, hier die gesamte Syntasis und die Standardmethoden zu beschreiben, aber Sie k√∂nnen immer den Spickzettel verwenden: </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler mit Bildern</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/id/vb/6e/idvb6ew9k7ackf94bjviuxavhxc.jpeg"><br><img src="https://habrastorage.org/webt/ye/ax/b4/yeaxb44uvcjkhir92ezxcsnc2oo.jpeg"><br><img src="https://habrastorage.org/webt/f7/2q/5q/f72q5qifi99xwv5nsqfnkb2x1au.jpeg"><br><img src="https://habrastorage.org/webt/8c/ty/in/8ctyinenggjs8gutaj484oreep4.jpeg"></p></div></div><br><p>  Jeder Shader hat eine Hauptfunktion, mit der seine Ausf√ºhrung beginnt.  Standardeingabeparameter f√ºr Shader und die Ausgabe der Ergebnisse ihrer Arbeit werden durch spezielle Variablen mit dem Pr√§fix <code>gl_</code> .  Sie sind im Voraus reserviert und in denselben Shadern verf√ºgbar.  Die Scheitelpunktkoordinaten f√ºr den Scheitelpunkt-Shader liegen also in der Variablen <code>gl_Position</code> , die Fragmentkoordinaten (Pixel) f√ºr den Fragment-Shader liegen in <code>gl_FragCoord</code> usw.  Die vollst√§ndige Liste der verf√ºgbaren Spezialvariablen finden Sie immer im selben Spickzettel. </p><br><p>  Die Haupttypen von Variablen in GLSL sind eher unpr√§tenti√∂s - <code>void</code> , <code>bool</code> , <code>int</code> , <code>float</code> ... Wenn Sie mit einer C-√§hnlichen Sprache gearbeitet haben, haben Sie sie bereits gesehen.  Es gibt andere Typen, insbesondere Vektoren mit unterschiedlichen Dimensionen - <code>vec2</code> , <code>vec3</code> , <code>vec4</code> .  Wir werden sie st√§ndig f√ºr Koordinaten und Farben verwenden.  Die Variablen, die wir erstellen k√∂nnen, weisen drei wichtige √Ñnderungen auf: </p><br><ul><li>  <strong>Einheitlich</strong> - Globale Daten in jeder Hinsicht.  Von au√üen √ºbergeben, f√ºr alle Vertex- und Fragment-Shader-Aufrufe gleich. </li><li>  <strong>Attribut</strong> - Diese Daten werden genauer √ºbertragen und k√∂nnen f√ºr jeden Shader-Aufruf unterschiedlich sein. </li><li>  <strong>Variierend</strong> - <strong>Wird</strong> ben√∂tigt, um Daten von Vertex-Shadern zu Fragment-Shadern zu √ºbertragen. </li></ul><br><blockquote>  Es ist n√ºtzlich, allen Variablen in den Shadern das Pr√§fix u / a / v zuzuordnen, um leichter zu verstehen, von welchen Daten sie stammen. </blockquote><p>  Ich glaube, es lohnt sich, zu einem praktischen Beispiel √ºberzugehen, um all dies sofort in Aktion zu sehen und nicht Ihr Ged√§chtnis zu laden. </p><br><h2 id="gotovim-startovyy-shablon">  Kochstartvorlage </h2><br><p>  Beginnen wir mit JS.  Wie es normalerweise bei der Arbeit mit <code>canvas</code> , brauchen wir es und den Kontext.  Um den Beispielcode nicht zu laden, erstellen wir globale Variablen: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.canvas); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GL = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'webgl'</span></span>);</code> </pre> <br><p>  √úberspringen Sie den Moment, der mit der Gr√∂√üe der <code>canvas</code> und ihrer Neuberechnung verbunden ist, wenn Sie die Gr√∂√üe des Browserfensters √§ndern.  Dieser Code ist in den Beispielen enthalten und h√§ngt normalerweise vom Rest des Layouts ab.  Es macht keinen Sinn, sich auf ihn zu konzentrieren.  Fahren wir mit Aktionen mit WebGL fort. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaders</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PROGRAM</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.vertex)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.fragment)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Zuerst kompilieren wir die Shader (es wird etwas niedriger sein), erstellen ein Programm, f√ºgen unsere beiden Shader hinzu und stellen einen Link her.  Zu diesem Zeitpunkt wird die Kompatibilit√§t der Shader √ºberpr√ºft.  Erinnern Sie sich an unterschiedliche Variablen, die vom Scheitelpunkt an das Fragment √ºbergeben werden?  - Insbesondere werden hier ihre Sets √ºberpr√ºft, damit sich sp√§ter im Prozess nicht herausstellt, dass etwas nicht oder gar nicht √ºbertragen wurde.  Nat√ºrlich wird diese √úberpr√ºfung keine logischen Fehler aufdecken, ich denke, das ist verst√§ndlich. </p><br><p>  Die Koordinaten der Scheitelpunkte werden in einem speziellen Pufferarray gespeichert und in Teilen, einem Scheitelpunkt, an jeden Shader-Aufruf √ºbertragen.  Als n√§chstes beschreiben wir einige Details f√ºr die Arbeit mit diesen St√ºcken.  Zun√§chst verwenden wir die Koordinaten des Scheitelpunkts im Shader √ºber die Attributvariable <code>a_position</code> .  Es kann anders genannt werden, es spielt keine Rolle.  Wir erhalten seine Position (dies ist so etwas wie ein Zeiger in C, aber kein Zeiger, sondern eine Entit√§tsnummer, die nur innerhalb des Programms existiert). </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexPositionAttribute = GL.getAttribLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'a_position'</span></span>);</code> </pre> <br><p>  Als n√§chstes geben wir an, dass ein Array mit Koordinaten durch diese Variable geleitet wird (im Shader selbst werden wir es bereits als Vektor wahrnehmen).  WebGL ermittelt unabh√§ngig, welche Koordinaten von welchen Punkten in unseren Formen an welchen Shader-Aufruf √ºbergeben werden sollen.  Wir legen nur die Parameter f√ºr das zu √ºbertragende Vektorarray fest: Dimension - 2 (wir √ºbertragen die Koordinaten <code>(x,y)</code> ), es besteht aus Zahlen und ist nicht normalisiert.  Die letzten Parameter sind f√ºr uns nicht interessant, wir lassen standardm√§√üig Nullen. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.enableVertexAttribArray</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.vertexAttribPointer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>, 2, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FLOAT</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>, 0, 0);</code> </pre> <br><p>  Erstellen Sie nun den Puffer selbst mit den Koordinaten der Eckpunkte unserer Ebene, auf denen das Foto angezeigt wird.  Die "2d" -Koordinaten sind klarer, aber f√ºr unsere Aufgaben ist dies das Wichtigste. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.ARRAY_BUFFER, GL.createBuffer()</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufferData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GL.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, -1, 1, 1 ])</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">STATIC_DRAW</span></span></span><span class="hljs-function"> ); }</span></span></code> </pre> <br><p>  Dieses Quadrat wird f√ºr alle unsere Beispiele ausreichen.  <code>STATIC_DRAW</code> bedeutet, dass der Puffer einmal geladen und dann wiederverwendet wird.  Wir werden nichts mehr hochladen. </p><br><p>  Bevor wir zu den Shadern selbst √ºbergehen, schauen wir uns ihre Zusammenstellung an: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">vertex</span></span>: compileShader( GL.VERTEX_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.vertex).textContent ), <span class="hljs-attr"><span class="hljs-attr">fragment</span></span>: compileShader( GL.FRAGMENT_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.fragment).textContent ) }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compileShader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shader; }</code> </pre> <br><p>  Wir erhalten den Shader-Code von den Elementen auf der Seite, erstellen einen Shader und kompilieren ihn.  Theoretisch k√∂nnen Sie den Shader-Code in separaten Dateien speichern und w√§hrend der Assemblierung als Zeichenfolge an der richtigen Stelle laden. CodePen bietet jedoch keine solche M√∂glichkeit f√ºr Beispiele.  In vielen Lektionen wird empfohlen, Code direkt in die Zeile in JS zu schreiben, aber die Sprache verwandelt ihn nicht in eine bequeme Sprache.  Obwohl es nat√ºrlich schmeckt und Farbe ... </p><br><p>  Wenn w√§hrend der Kompilierung ein Fehler auftritt, wird das Skript weiterhin ausgef√ºhrt und zeigt einige Warnungen in der Konsole an, die wenig sinnvoll sind.  Es ist n√ºtzlich, sich die Protokolle nach dem Kompilieren anzusehen, um sich nicht √ºber das Gedanken zu machen, was dort nicht kompiliert wurde: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getShaderInfoLog</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>));</code> </pre> <br><blockquote>  WebGL bietet verschiedene Optionen zum Verfolgen von Problemen beim Kompilieren von Shadern und Erstellen eines Programms. In der Praxis stellt sich jedoch heraus, dass wir in Echtzeit sowieso nichts beheben k√∂nnen.  So oft werden wir von dem Gedanken geleitet, "fiel ab - dann fiel ab", und wir werden den Code nicht mit einer Reihe zus√§tzlicher √úberpr√ºfungen laden. </blockquote><p>  <strong>Gehen wir weiter zu den Shadern</strong> </p><br><p>  Da wir nur eine Ebene haben werden, mit der wir nichts tun werden, reicht uns ein einfacher Vertex-Shader, was wir gleich zu Beginn tun werden.  Die Hauptanstrengungen werden sich auf Fragment-Shader konzentrieren und alle nachfolgenden Beispiele werden f√ºr sie relevant sein. </p><br><blockquote>  Versuchen Sie, Shader-Code mit mehr oder weniger aussagekr√§ftigen Variablennamen zu schreiben.  Im Netzwerk finden Sie Beispiele, in denen Funktionen mit starker Mathematik f√ºr 200 Zeilen fortlaufenden Text aus Ein-Buchstaben-Variablen zusammengestellt werden. Nur weil dies jemand tut, bedeutet dies nicht, dass es sich lohnt, sie zu wiederholen.  Ein solcher Ansatz ist keine ‚ÄûBesonderheit der Arbeit mit GL‚Äú, sondern eine banale Kopie von Quellcodes aus dem letzten Jahrhundert, die von Menschen geschrieben wurden, die in ihrer Jugend Einschr√§nkungen hinsichtlich der L√§nge von Variablennamen hatten. </blockquote><p>  Zun√§chst der Vertex-Shader.  Ein 2d-Vektor mit Koordinaten <code>(x,y)</code> wird wie gesagt in die Attributvariable <code>a_position</code> √ºbertragen.  Der Shader sollte einen Vektor mit vier Werten <code>(x,y,z,w)</code> .  Es bewegt nichts im Raum, also setzen wir auf der z-Achse einfach alles auf Null und setzen den Wert von w auf die Standardeinheit.  Wenn Sie sich fragen, warum es vier statt drei Koordinaten gibt, k√∂nnen Sie die Netzwerksuche nach "einheitlichen Koordinaten" verwenden. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'vertex-shader'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'x-shader/x-vertex'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision mediump float; attribute vec2 a_position; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main() { gl_Position = vec4(position, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0</span></span></span><span class="actionscript">, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Das Arbeitsergebnis wird in einer speziellen Variablen <code>gl_Position</code> .  Shader haben keine <code>return</code> im wahrsten Sinne des Wortes, sie schreiben alle Ergebnisse ihrer Arbeit in Variablen auf, die speziell f√ºr diese Zwecke reserviert sind. </p><br><blockquote>  Beachten Sie den Pr√§zisionsjob f√ºr den Float-Datentyp.  Um einige der Probleme auf Mobilger√§ten zu vermeiden, sollte die Genauigkeit schlechter als die von Highp sein und in beiden Shadern gleich sein.  Dies wird hier als Beispiel gezeigt, aber es ist eine gute Praxis auf Telefonen, solche Sch√∂nheit mit Shadern insgesamt auszuschalten. </blockquote><p>  Der Fragment-Shader gibt zun√§chst immer dieselbe Farbe zur√ºck.  Unser Quadrat nimmt die gesamte <code>canvas</code> , daher legen wir hier die Farbe f√ºr jedes Pixel fest: </p><br><pre> <code class="hljs pgsql">&lt;script id=<span class="hljs-string"><span class="hljs-string">'fragment-shader'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-string"><span class="hljs-string">'x-shader/x-fragment'</span></span>&gt; <span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; #define GOLD vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.86</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-type"><span class="hljs-type">void</span></span> main() { gl_FragColor = GOLD; } &lt;/script&gt;</code> </pre> <br><p>  Sie k√∂nnen auf die Zahlen achten, die die Farbe beschreiben.  Dies ist allen RGBA-Setzern bekannt, nur normalisiert.  Werte sind keine ganzen Zahlen von 0 bis 255, sondern Bruchzahlen von 0 bis 1. Die Reihenfolge ist dieselbe. </p><br><blockquote>  Vergessen Sie nicht, den Pr√§prozessor f√ºr alle magischen Konstanten in realen Projekten zu verwenden - dies macht den Code verst√§ndlicher, ohne die Leistung zu beeintr√§chtigen (Substitution wie in C erfolgt w√§hrend der Kompilierung). </blockquote><p>  Es ist erw√§hnenswert, einen weiteren Punkt √ºber den Pr√§prozessor zu erw√§hnen: </p><br><blockquote>  Die Verwendung von Konstantenpr√ºfungen #ifdef GL_ES in verschiedenen Lektionen hat keine praktische Bedeutung.  In unserem heutigen Browser gibt es einfach keine anderen GL-Optionen. </blockquote><p>  Aber es ist Zeit, sich das Ergebnis bereits anzusehen: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/JaoYMj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Das goldene Quadrat zeigt an, dass die Shader wie erwartet funktionieren.  Es ist sinnvoll, ein wenig mit ihnen herumzuspielen, bevor Sie mit Fotos arbeiten. </p><br><p>  <strong>Gradienten- und Transformationsvektoren</strong> </p><br><p>  In der Regel beginnen WebGL-Tutorials mit dem Zeichnen von Verl√§ufen.  Dies macht praktisch wenig Sinn, aber es wird n√ºtzlich sein, einige Punkte zu beachten. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gl_FragColor = vec4(gl_FragCoord.zxy / <span class="hljs-number"><span class="hljs-number">500.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  In diesem Beispiel verwenden wir die Koordinaten des aktuellen Pixels als Farbe.  Sie werden dies oft in Beispielen im Internet sehen.  Beide sind Vektoren.  Also st√∂rt es niemanden, alles auf einem Haufen zu mischen.  TypeScript-Evangelisten sollten hier angegriffen werden.  Ein wichtiger Punkt ist, wie wir nur einen Teil der Koordinaten aus dem Vektor erhalten.  Eigenschaften <code>.x</code> , <code>.y</code> , <code>.z</code> , <code>.xy</code> , <code>.zy</code> , <code>.xyz</code> , <code>.zyx</code> , <code>.xyzw</code> usw.  In verschiedenen Sequenzen k√∂nnen Sie die Elemente eines Vektors in einer bestimmten Reihenfolge in Form eines anderen Vektors herausziehen.  Sehr bequem implementiert.  Ein Vektor mit h√∂herer Dimension kann auch aus einem Vektor mit niedrigerer Dimension erstellt werden, indem die fehlenden Werte hinzugef√ºgt werden, wie wir es getan haben. </p><br><blockquote>  Geben Sie immer explizit den Bruchteil von Zahlen an.  Es gibt hier keine automatische Konvertierung int -&gt; float. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/vzENvx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Uniformen und der Lauf der Zeit</strong> </p><br><p>  Das n√§chste n√ºtzliche Beispiel ist die Verwendung von Uniformen.  Dies sind die h√§ufigsten Daten f√ºr alle Shader-Aufrufe.  Wir erhalten ihre Position auf die gleiche Weise wie bei Attributvariablen, zum Beispiel: </p><br><pre> <code class="hljs delphi">GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_time'</span></span>)</code> </pre> <br><p>  Dann k√∂nnen wir sie vor jedem Frame einstellen.  Wie bei Vektoren gibt es hier viele √§hnliche Methoden, beginnend mit dem Wort <code>uniform</code> , dann kommt die Dimension der Variablen (1 f√ºr Zahlen, 2, 3 oder 4 f√ºr Vektoren) und des Typs (f - float, i - int, v - vector). . </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_time')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStamp</span></span></span><span class="hljs-function"> / 1000.0); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawArrays</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TRIANGLE_STRIP, 0, 4)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">window</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestAnimationFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(draw)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><blockquote>  Tats√§chlich ben√∂tigen wir in Schnittstellen nicht immer 60 fps.  Es ist durchaus m√∂glich, requestAnimationFrame zu verlangsamen und die H√§ufigkeit des Neuzeichnens von Frames zu verringern. </blockquote><p>  Zum Beispiel werden wir die F√ºllfarbe √§ndern.  In den Shadern stehen alle grundlegenden mathematischen Funktionen zur Verf√ºgung - <code>sin</code> , <code>cos</code> , <code>tan</code> , <code>asin</code> , <code>acos</code> , <code>atan</code> , <code>pow</code> , <code>exp</code> , <code>log</code> , <code>sqrt</code> , <code>abs</code> und andere.  Wir werden zwei davon verwenden. </p><br><pre> <code class="hljs cpp">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_time; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_FragColor = vec4( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Zeit in solchen Animationen ist ein relatives Konzept.  Hier verwenden wir die von <code>requestAnimationFrame</code> bereitgestellten <code>requestAnimationFrame</code> , k√∂nnen aber unsere eigene "Zeit" <code>requestAnimationFrame</code> .  Die Idee ist, dass wenn einige Parameter durch eine Funktion der Zeit beschrieben werden, wir die Zeit in die entgegengesetzte Richtung drehen, verlangsamen, beschleunigen oder in ihren urspr√ºnglichen Zustand zur√ºckkehren k√∂nnen.  Dies kann sehr hilfreich sein. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/VGYvNP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Aber genug abstrakte Beispiele, lassen Sie uns mit der Verwendung von Bildern fortfahren. </p><br><p>  <strong>Laden eines Bildes in eine Textur</strong> </p><br><p>  Um das Bild verwenden zu k√∂nnen, m√ºssen wir eine Textur erstellen, die dann auf unserer Ebene gerendert wird.  Laden Sie zun√§chst das Bild selbst: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); image.crossOrigin = <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>; image.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .... }; image.src = 'example.jpg'; }</span></span></code> </pre> <br><p>  Erstellen Sie nach dem Laden eine Textur und geben Sie an, dass sie die Nummer 0 hat. In WebGL k√∂nnen viele Texturen gleichzeitig vorhanden sein, und wir m√ºssen explizit angeben, auf welche nachfolgenden Befehle sich beziehen.  In unseren Beispielen gibt es nur eine Textur, aber wir geben immer noch explizit an, dass sie Null sein wird. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> texture = GL.createTexture(); GL.activeTexture(GL.TEXTURE0); GL.bindTexture(GL.TEXTURE_2D, texture);</code> </pre> <br><p>  Es bleibt ein Bild hinzuzuf√ºgen.  Wir sagen auch sofort, dass es entlang der Y-Achse gedreht werden muss, weil  In WebGL steht die Achse auf dem Kopf: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pixelStorei</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNPACK_FLIP_Y_WEBGL</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texImage2D</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNSIGNED_BYTE</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">image</span></span>);</code> </pre> <br><p>  Theoretisch sollte die Textur quadratisch sein.  Genauer gesagt sollten sie sogar eine Gr√∂√üe haben, die der Potenz von zwei entspricht - 32px, 64px, 128px usw.  Aber wir alle verstehen, dass niemand Fotos verarbeiten wird und sie jedes Mal unterschiedliche Proportionen haben werden.  Dies f√ºhrt zu Fehlern, selbst wenn die <code>canvas</code> perfekt in die Textur passt.  Daher f√ºllen wir den gesamten Raum bis zu den R√§ndern der Ebene mit den extremen Pixeln des Bildes.  Dies ist Standard, obwohl es eine kleine Kr√ºcke scheint. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_S</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_T</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_MIN_FILTER</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LINEAR</span></span>);</code> </pre> <br><p>  Es bleibt die Textur auf die Shader zu √ºbertragen.  Diese Daten sind allen gemeinsam, daher verwenden wir den <code>uniform</code> Modifikator. </p><br><pre> <code class="hljs delphi">GL.uniform1i(GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_texture'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Jetzt k√∂nnen wir die Farben aus der Textur im Fragment-Shader verwenden.  Wir m√∂chten aber auch, dass das Bild die gesamte <code>canvas</code> .  Wenn das Bild und die <code>canvas</code> die gleichen Proportionen haben, wird diese Aufgabe trivial.  Zuerst √ºbertragen wir die <code>canvas</code> auf die Shader (dies muss jedes Mal erfolgen, wenn Sie die Gr√∂√üe √§ndern): </p><br><pre> <code class="hljs pgsql">GL.uniform1f(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_canvas_size'</span></span>), Math.max(CANVAS.height, CANVAS.width));</code> </pre> <br><p>  Und teilen Sie die Koordinaten hinein: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D u_texture; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> float u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, gl_FragCoord.xy / u_canvas_size); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/QVwjeJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>An diesem Punkt k√∂nnen Sie pausieren und Tee kochen.</em>  <em>Wir haben alle Vorbereitungsarbeiten durchgef√ºhrt und verschiedene Effekte erzielt.</em> </p><br><h2 id="effekty">  Effekte </h2><br><p>  Bei der Erzeugung verschiedener Effekte spielen Intuition und Experimentieren eine wichtige Rolle.  Oft k√∂nnen Sie einen komplexen Algorithmus durch etwas v√∂llig Einfaches ersetzen und ein √§hnliches Ergebnis erzielen.  Der Endbenutzer wird den Unterschied nicht bemerken, aber wir beschleunigen die Arbeit und vereinfachen den Support.  WebGL bietet keine sinnvollen Tools zum Debuggen von Shadern. Daher ist es f√ºr uns von Vorteil, kleine Codeteile zu haben, die in den gesamten Kopf passen. </p><br><blockquote>  Weniger Code bedeutet weniger Probleme.  Und es ist einfacher zu lesen.  √úberpr√ºfen Sie die im Netzwerk gefundenen Shader immer auf unn√∂tige Aktionen.  Es kommt vor, dass Sie die H√§lfte des Codes entfernen k√∂nnen und sich nichts √§ndert. </blockquote><p>  Lass uns ein wenig mit dem Shader spielen.  Die meisten unserer Effekte basieren auf der Tatsache, dass wir nicht die Farbe des Pixels auf der Textur zur√ºckgeben, die an dieser Stelle sein sollte, sondern einige der benachbarten.  Es ist n√ºtzlich zu versuchen, das Ergebnis einer Standardfunktion der Koordinaten zu den Koordinaten hinzuzuf√ºgen.  Die Verwendung von Zeit ist ebenfalls n√ºtzlich, sodass das Ergebnis der Ausf√ºhrung leichter zu verfolgen ist und wir am Ende immer noch animierte Effekte erstellen.  Versuchen wir, den Sinus zu verwenden: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Das Ergebnis ist seltsam.  Offensichtlich bewegt sich alles mit zu viel Amplitude.  Teilen Sie alles durch eine Zahl: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Schon besser.  Jetzt ist klar, dass wir ein wenig aufgeregt sind.  Theoretisch m√ºssen wir, um jede Welle zu vergr√∂√üern, das Sinusargument - die Koordinate - teilen.  Lass es uns tun: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y / <span class="hljs-number"><span class="hljs-number">30.0</span></span>) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/jvEWbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  √Ñhnliche Effekte gehen oft mit der Auswahl von Koeffizienten einher.  Dies geschieht mit dem Auge.  Wie beim Kochen wird es zun√§chst schwer zu erraten sein, aber dann wird es von selbst passieren.  Die Hauptsache ist, zumindest grob zu verstehen, wie sich dieser oder jener Koeffizient in der resultierenden Formel auswirkt.  Nachdem die Koeffizienten ausgew√§hlt wurden, ist es sinnvoll, sie in Makros einzuf√ºgen (wie im ersten Beispiel) und aussagekr√§ftige Namen zu vergeben. </p><br><p>  <strong>Krummer Spiegel, Fahrr√§der und Experimente</strong> </p><br><p>  Denken ist gut.  Ja, es gibt vorgefertigte Algorithmen zur L√∂sung einiger Probleme, die wir einfach √ºbernehmen und verwenden k√∂nnen.       ,      . </p><br><p>         ,   " ",       .  Was tun? </p><br><p> ,       ,   ?      .   ,       rand()  - .    ,    ,   ,  ,   .    .                  .   ,      .         .      .    -,    .      .    ,     ,       ,   .     ,           "": </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(vec2 <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre><br><p>    ,          , ,      NVIDIA  ATI     .     ,        . </p><br><p>       ,    ,          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy + vec2(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">u_time</span></span>))) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,   ,   : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/pOvgbX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ,        .     ,   ,     .   ‚Äî           .  Wie kann man das machen? .      . </p><br><p>       0  1,     - .    5 ‚Äî          .       ,      . </p><br><pre> <code class="hljs matlab">vec2 texture_coord = gl_FragCoord.xy / u_canvas_size; gl_FragColor = texture2D(u_texture, texture_coord + <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + vec2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time))) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>);</code> </pre> <br><p>   ,   -    .   -   . ,    ,   .     ? </p><br><p>        ,  ,   ,  - .     , .    , ..      -.      ,      .      . ,         ,   .        . </p><br><p>    <code>sin</code>  <code>cos</code>   ,    .   .         . </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2( <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>));</code> </pre> <br><p>      .   <code>fract</code>  .    1  1 ‚Äî     : </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(vec2 position) { vec2 block_position = <span class="hljs-keyword"><span class="hljs-keyword">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computed_value = fract(position); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>        . WebGL      <code>smoothstep</code> ,     : </p><br><pre> <code class="hljs lisp">vec2 computed_value = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(<span class="hljs-name"><span class="hljs-name">position</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,      .   ,          X   : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computed_value.x;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/mGyVBK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ‚Ä¶    ,  ,    ... </p><br><blockquote>    - ,     ,     ...        . </blockquote><p>     y ‚Äî    ,   .      ? </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(computed_value);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMza" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     . </p><br><p>     .     0.5 ‚Äî      . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_left_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> * (1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_right_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/eLmJMZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>     ,   , ,  .</em> </p><br><p> <strong> </strong> </p><br><p>        ,     ,          .         - . </p><br><p>    uniform-,       .   0  1,  0 ‚Äî   ,  1 ‚Äî  . </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_intensity;</code> </pre> <br><p>       : </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>) * u_intensity);</code> </pre> <br><p>         ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/PdwZdX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         (  0  1),             . </p><br><blockquote>  ,    ,         ,       .          ‚Äî         requestAnimationFrame.       ,     FPS. </blockquote><p> <strong>   </strong> </p><br><p>      ,        .   uniform-. </p><br><pre> <code class="hljs powershell">document.addEventListener(<span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>, (e) =&gt; { let rect = CANVAS.getBoundingClientRect(); MOUSE_POSITION = [ <span class="hljs-type"><span class="hljs-type">e.clientX</span></span> - <span class="hljs-type"><span class="hljs-type">rect.left</span></span>, <span class="hljs-type"><span class="hljs-type">rect.height</span></span> - (<span class="hljs-type"><span class="hljs-type">e.clientY</span></span> - <span class="hljs-type"><span class="hljs-type">rect.top</span></span>) ]; GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_mouse_position'</span></span>), MOUSE_POSITION); });</code> </pre> <br><p>    ,            .      ‚Äî  ,       . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> texture_coord = gl_FragCoord.xy / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> direction = u_mouse_position / u_canvas_size - texture_coord; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> dist = distance(gl_FragCoord.xy, u_mouse_position) / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord + u_intensity * direction * dist * <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); } }</code> </pre> <br><p>         -    .         . </p><br><blockquote>             .    ,        . </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/bxNEOP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <strong></strong> </p><br><p>      . Glitch-     ,      SVG.      .    ‚Äî .      ?       ‚Äî  ,   ,   ,      . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> random_value = rand(vec2(texture_coord.y, u_time)); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (random_value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">05</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, vec2(texture_coord.x + random_value / <span class="hljs-number"><span class="hljs-number">5</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, texture_coord.y)); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); }</code> </pre> <br><blockquote> "     ?" ‚Äî   ,      .          . </blockquote><p>     .      ‚Äî  ,           . </p><br><pre> <code class="hljs lisp">float random_value = rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><p>     .   ,       : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, vec2(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.x + random_value / <span class="hljs-number"><span class="hljs-number">4.0</span></span>, texture_coord.y)) + vec4(<span class="hljs-name"><span class="hljs-name">vec3</span></span>(<span class="hljs-name"><span class="hljs-name">random_value</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          .          ‚Äî    . ,           ‚Äî   <code>.r</code> , <code>.g</code> , <code>.b</code> , <code>.rg</code> , <code>.rb</code> , <code>.rgb</code> , <code>.bgr</code> , ...               . </p><br><p>       : </p><br><pre> <code class="hljs lisp">float random_value = u_intensity * rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMeY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-v-itoge">  Was ist das Ergebnis? </h2><br><p>         ,                   ,     .          ,  ,      ‚Äî         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420847/">https://habr.com/ru/post/de420847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420833/index.html">Wichtige Monetarisierungsfehler bei Anwendungen [und wie man sie behebt]</a></li>
<li><a href="../de420837/index.html">Testen von Software-RAID-Arrays f√ºr NVMe-Ger√§te mithilfe der SNIA-Methode</a></li>
<li><a href="../de420841/index.html">Hotfix vor dem Krankenhaus oder ‚ÄûHey Swagger! Wo sind meine Fehler? "</a></li>
<li><a href="../de420843/index.html">7. September, Jekaterinburg - ein Treffen f√ºr .NET-Entwickler</a></li>
<li><a href="../de420845/index.html">Die Z√§hmung des Hartn√§ckigen mit einer Kr√ºcke: das Loch des WLAN-Adapters WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../de420853/index.html">Lernen Sie die Windows Pseudo Console (ConPTY) kennen</a></li>
<li><a href="../de420857/index.html">Nahtloses Wi-Fi-Roaming: Theorie in der Praxis</a></li>
<li><a href="../de420859/index.html">Zur Frage von Wirth und Ketten</a></li>
<li><a href="../de420861/index.html">Vorbereitungen f√ºr C ++ 20. Coroutines TS Real Fallstudie</a></li>
<li><a href="../de420863/index.html">Als wir das erste russische Smartphone machten, ging es weiter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>