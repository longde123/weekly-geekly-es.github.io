<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 🤵🏾 🐵 Portar Quake 3 a Rust 💰 ✊🏾 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nuestro equipo Immunant ama a Rust y está trabajando activamente en C2Rust, un marco de migración que se encarga de toda la rutina de migrar a Rust. N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Portar Quake 3 a Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483142/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Nuestro equipo Immunant ama a Rust y está trabajando activamente en C2Rust, un marco de migración que se encarga de toda la rutina de migrar a Rust.  Nos esforzamos por introducir automáticamente mejoras de seguridad en el código Rust convertido y ayudar al programador a hacerlo él mismo cuando falla el marco.  Sin embargo, antes que nada, necesitamos crear un traductor confiable que permita a los usuarios comenzar a usar Rust.  Las pruebas en pequeños programas CLI se están volviendo obsoletas lentamente, por lo que decidimos transferir Quake 3 a Rust. Después de un par de días, ¡probablemente fuimos los primeros en jugar Quake3 en Rust! <br><br><h2>  Preparación: Quake 3 fuentes </h2><br>  Después de estudiar el código fuente del Quake 3 original y varios tenedores, nos decidimos por <a href="https://ioquake3.org/">ioquake3</a> .  Esta es una bifurcación creada por la comunidad de Quake 3, que todavía es compatible y está construida en plataformas modernas. <br><a name="habracut"></a><br>  Como punto de partida, decidimos asegurarnos de que podemos armar el proyecto en su forma original: <br><br><pre><code class="bash hljs">$ make release</code> </pre> <br>  Al construir ioquake3, se crean varias bibliotecas y archivos ejecutables: <br><br><pre> <code class="bash hljs">$ tree --prune -I missionpack -P <span class="hljs-string"><span class="hljs-string">"*.so|*x86_64"</span></span> . └── build └── debug-linux-x86_64 ├── baseq3 │ ├── cgamex86_64.so <span class="hljs-comment"><span class="hljs-comment"># client │ ├── qagamex86_64.so # game server │ └── uix86_64.so # ui ├── ioq3ded.x86_64 # dedicated server binary ├── ioquake3.x86_64 # main binary ├── renderer_opengl1_x86_64.so # opengl1 renderer └── renderer_opengl2_x86_64.so # opengl2 renderer</span></span></code> </pre> <br>  Entre estas bibliotecas, las bibliotecas de UI, cliente y servidor se pueden compilar como un ensamblaje <a href="https://fabiensanglard.net/quake3/qvm.php">Quake VM</a> o como bibliotecas compartidas X86 nativas.  En nuestro proyecto, decidimos usar versiones nativas.  Traducir máquinas virtuales a Rust y usar versiones de QVM sería mucho más simple, pero queríamos probar a fondo C2Rust. <br><br>  En nuestro proyecto de transferencia, nos centramos en la interfaz de usuario, el juego, el cliente, el renderizador OpenGL1 y el ejecutable principal.  También podríamos traducir el renderizador OpenGL2, pero decidimos omitir esto porque usa una cantidad significativa de <code>.glsl</code> sombreador <code>.glsl</code> , que el sistema de compilación incorpora como literales de cadena en el código fuente C. Después de la compilación, agregaremos soporte para los scripts de compilación para incrustar Código GLSL en cadenas Rust, pero todavía no hay una buena forma automatizada de transponer estos archivos temporales generados automáticamente.  Entonces, en su lugar, solo tradujimos la biblioteca de renderizador OpenGL1 y forzamos al juego a usarla en lugar del renderizador predeterminado.  Además, decidimos omitir el servidor dedicado y los archivos de misión empaquetados, porque no serán difíciles de transferir y no son necesarios para nuestra demostración. <br><br><h2>  Transponer Quake 3 </h2><br>  Para preservar la estructura de directorios utilizada en Quake 3 y no cambiar el código fuente, necesitábamos obtener exactamente los mismos archivos binarios que en el ensamblado nativo, es decir, cuatro bibliotecas compartidas y un archivo ejecutable. <br><br>  Como C2Rust crea los archivos de ensamblaje de Cargo, cada binario requiere su propia caja Rust con el archivo <code>Cargo.toml</code> correspondiente. <br><br>  Para que C2Rust cree una caja por archivo binario de salida, también necesitará una lista de archivos binarios con el objeto o los archivos fuente correspondientes, así como una llamada de enlazador utilizada para crear cada archivo binario (utilizado para determinar otros detalles, por ejemplo, dependencias de la biblioteca). <br><br>  Sin embargo, rápidamente encontramos una limitación causada por la forma en que C2Rust intercepta el proceso de compilación nativo: C2Rust recibe en la entrada un archivo de <a href="https://sarcasm.github.io/notes/dev/compilation-database.html">base de datos de compilación</a> que contiene una lista de comandos de compilación que se ejecutan durante la compilación.  Sin embargo, esta base de datos contiene <strong>solo</strong> comandos de compilación sin llamadas de enlazador.  La mayoría de las herramientas que crean esta base de datos tienen esta limitación intencional, por ejemplo, <code>cmake</code> con <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> , <code>bear</code> y <code>compiledb</code> .  En nuestra experiencia, la única herramienta que incluye comandos de <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> es el <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> de <code>CodeChecker</code> creado por <code>CodeChecker</code> , que no utilizamos porque solo lo aprendimos después de escribir nuestros propios contenedores (se describen a continuación).  Esto significaba que para compilar un programa en C con varios archivos binarios, no podíamos usar el archivo <code>compile_commands.json</code> creado por ninguna de las herramientas comunes. <br><br>  Por lo tanto, escribimos nuestros propios scripts de envoltura de <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/cc">compilador</a> y <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/ld">enlazador</a> que vuelcan todas las llamadas al compilador y enlazador a la base de datos, y luego lo convierten en <code>compile_commands.json</code> extendido.  En lugar del ensamblaje habitual usando un comando como: <br><br><pre> <code class="bash hljs">$ make release</code> </pre> <br>  agregamos envoltorios para interceptar el ensamblaje con: <br><br><pre> <code class="bash hljs">$ make release CC=/path/to/C2Rust/scripts/cc-wrappers/cc</code> </pre> <br>  Los contenedores crean un directorio de varios archivos JSON, uno por llamada.  El segundo <a href="https://github.com/immunant/c2rust/blob/master/scripts/convert_build_commands.py">script los</a> recopila a todos en un nuevo archivo <code>compile_commands.json</code> , que contiene tanto los comandos de compilación como los de compilación.  Luego ampliamos C2Rust para que lea los comandos de compilación de la base de datos y cree una caja separada para cada binario vinculado.  Además, C2Rust ahora también lee las dependencias de la biblioteca para cada archivo binario y las agrega automáticamente al archivo <code>build.rs</code> de la caja correspondiente. <br><br>  Para mejorar la comodidad, todos los archivos binarios se pueden recopilar a la vez colocándolos dentro del <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">espacio de trabajo</a> .  C2Rust crea el archivo <code>Cargo.toml</code> espacio de trabajo de nivel <code>Cargo.toml</code> , por lo que podemos construir el proyecto con el único <code>cargo build</code> en el directorio <code>quake3-rs</code> : <br><br><pre> <code class="bash hljs">$ tree -L 1 . ├── Cargo.lock ├── Cargo.toml ├── cgamex86_64 ├── ioquake3 ├── qagamex86_64 ├── renderer_opengl1_x86_64 ├── rust-toolchain └── uix86_64 $ cargo build --release</code> </pre> <br><h2>  Eliminar la aspereza </h2><br>  Cuando intentamos compilar el código traducido por primera vez, nos encontramos con un par de problemas con las fuentes de Quake 3: hubo casos límite que C2Rust no pudo manejar (ni correctamente, ni de ninguna manera). <br><br><h3>  Punteros de matriz </h3><br>  Varios lugares en el código fuente original contienen expresiones que apuntan al siguiente elemento después del último elemento de la matriz.  Aquí hay un ejemplo de código C simplificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p; <span class="hljs-comment"><span class="hljs-comment">// ... if (p &gt;= &amp;array[1024]) { // error... }</span></span></code> </pre> <br>  El estándar C (véase, por ejemplo, <a href="http://www.iso-9899.info/n1570.html">C11, Sección 6.5.6</a> ) permite que los punteros a un elemento vayan más allá del final de una matriz.  Sin embargo, Rust prohíbe esto, incluso si solo tomamos la dirección del elemento.  Encontramos ejemplos de dicho patrón en la función <a href=""><code>AAS_TraceClientBBox</code></a> . <br><br>  El compilador Rust también señaló un ejemplo similar, pero en realidad con <a href=""><code>G_TryPushingEntity</code></a> en <a href=""><code>G_TryPushingEntity</code></a> , donde la instrucción condicional tiene la forma <code>&gt;</code> , no <code>&gt;=</code> .  Un puntero que se sale de los límites se desreferencia después de la construcción condicional, que es un error de seguridad de la memoria. <br><br>  Para evitar este problema en el futuro, arreglamos el transpilador C2Rust para que use la aritmética de puntero para calcular la dirección de un elemento de matriz, en lugar de usar la operación de indexación de matriz.  Gracias a esta solución, el código que utiliza el patrón similar "dirección del elemento al final de la matriz" ahora se traduce correctamente y se ejecuta sin modificaciones. <br><br><h3>  Elementos de matriz de longitud variable </h3><br>  Lanzamos el juego para probarlo todo, e inmediatamente recibimos pánico de Rust: <br><br><pre> <code class="cpp hljs">thread <span class="hljs-string"><span class="hljs-string">'main'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'index out of bounds: the len is 4 but the index is 4'</span></span>, quake3-client/src/cm_polylib.rs:<span class="hljs-number"><span class="hljs-number">973</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span></code> </pre> <br>  Echando un vistazo a <code>cm_polylib.c</code> , notamos que desreferencia el campo <code>p</code> en la siguiente estructura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  El campo <code>p</code> en la estructura es una versión del miembro de matriz flexible que no es compatible con el estándar C99, pero que aún es aceptado por <code>gcc</code> .  C2Rust reconoce elementos de matrices de longitud variable con la sintaxis C99 ( <code>vec3_t p[]</code> ) e implementa una <a href="">heurística</a> simple para identificar también versiones de este patrón antes de C99 (matrices de tamaños 0 y 1 al final de las estructuras; también encontramos varios ejemplos en el código fuente ioquake3). <br><br>  <a href="https://github.com/immunant/ioq3/commit/ace1fae43e736613544c8d33cc69dee794f5124a">Cambiar</a> la estructura anterior a la sintaxis C99 eliminó el pánico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Un intento de corregir automáticamente este patrón en el caso general (con tamaños de matriz diferentes de 0 y 1) será extremadamente difícil, ya que tendremos que distinguir entre matrices ordinarias y elementos de matrices de longitud variable de tamaños arbitrarios.  Por lo tanto, le recomendamos que corrija el código C original manualmente, como hicimos con ioquake3. <br><br><h3>  Operandos atados en código ensamblador en línea </h3><br>  Otra fuente de fallas fue este código de ensamblador C-assembler del encabezado del sistema <code>/usr/include/bits/select.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cld; rep; "</span></span></span><span class="hljs-meta"> __FD_ZERO_STOS \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (__d0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (__d1) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0"</span></span></span><span class="hljs-meta"> (sizeof (fd_set) \ / sizeof (__fd_mask)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta"> (&amp;__FDS_BITS (fdsp)[0]) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  definiendo la versión interna de la macro <code>__FD_ZERO</code> .  Esta definición plantea un raro caso límite de <code>gcc</code> : <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">operandos vinculados de E / S</a> con diferentes tamaños.  El operador de salida <code>"=D" (__d1)</code> vincula el registro <code>edi</code> a la variable <code>__d1</code> como un valor de 32 bits, y <code>"1" (&amp;__FDS_BITS (fdsp)[0])</code> vincula el mismo registro a la dirección <code>fdsp-&gt;fds_bits</code> como un puntero de 64 bits.  <code>gcc</code> y <code>clang</code> resuelven este desajuste.  usando el registro <code>rdi</code> 64 bits y truncando su valor antes de asignar el valor <code>__d1</code> , y Rust usa la semántica LLVM por defecto, en cuyo caso permanece indefinido.  En las compilaciones de depuración (no en las versiones, que se comportaron bien), vimos que ambos operandos pueden asignarse al registro <code>edi</code> , por lo que el puntero se trunca a 32 bits antes del código ensamblador incorporado, lo que causa fallas. <br><br>  Dado que <code>rustc</code> pasa el código de ensamblador Rust incorporado a LLVM con muy pocos cambios, decidimos arreglar este caso particular en C2Rust.  Implementamos la nueva caja <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> , que <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> este problema gracias al sistema de tipo Rust que utiliza funciones de <a href="">rasgo</a> y ayuda que automáticamente expanden y truncan los operandos atados a un tamaño interno que es lo suficientemente grande como para contener ambos operandos.  El código anterior se traduce correctamente a lo siguiente: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d0: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d1: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reference to the output value of the first operand let fresh5 = &amp;mut __d0; // The internal storage for the first tied operand let fresh6; // Reference to the output value of the second operand let fresh7 = &amp;mut __d1; // The internal storage for the second tied operand let fresh8; // Input value of the first operand let fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong); // Input value of the second operand let fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask; asm!("cld; rep; stosq" : "={cx}" (fresh6), "={di}" (fresh8) : "{ax}" (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension "0" (AsmCast::cast_in(fresh5, fresh9)), "1" (AsmCast::cast_in(fresh7, fresh10)) : "memory" : "volatile"); // Cast the operands out (types are inferred) with truncation AsmCast::cast_out(fresh5, fresh9, fresh6); AsmCast::cast_out(fresh7, fresh10, fresh8);</span></span></code> </pre> <br>  Vale la pena señalar que este código no requiere ningún tipo de valores de entrada y salida en el ensamblaje del código del ensamblador; al resolver conflictos de tipos, confiando en ellos para generar tipos Rust (principalmente tipos <code>fresh6</code> y <code>fresh8</code> ). <br><br><h3>  Variables globales alineadas </h3><br>  La última fuente del error fue la siguiente variable global que almacenaba la constante SSE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ssemask[<span class="hljs-number"><span class="hljs-number">16</span></span>] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">16</span></span>))) = { <span class="hljs-string"><span class="hljs-string">"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00\x00\x00"</span></span> };</code> </pre> <br>  Rust actualmente admite el atributo de alineación para tipos estructurales, pero no para variables globales, es decir  elementos <code>static</code>  Consideramos formas de resolver este problema en el caso general, ya sea en Rust o en C2Rust, pero por ahora en ioquake3 decidimos solucionarlo manualmente con un pequeño archivo de <a href="https://github.com/immunant/ioq3/blob/master/asm-snapvector.patch">parche</a> .  Este archivo de parche reemplaza el equivalente de Rust <code>ssemask</code> siguiente: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C, align(16))]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SseMask</span></span></span></span>([<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ssemask: SseMask = SseMask([ <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ]);</code> </pre> <br><h2>  Running quake3-rs </h2><br>  Cuando se <code>cargo build --release</code> , se crean binarios, pero se crean bajo <code>target/release</code> con una estructura de directorio que el binario <code>ioquake3</code> no reconoce.  Escribimos un <a href="">script</a> que crea enlaces simbólicos en el directorio actual para recrear la estructura de directorios correcta (incluidos los enlaces a archivos <code>.pk3</code> que contienen recursos del juego): <br><br><pre> <code class="bash hljs">$ /path/to/make_quake3_rs_links.sh /path/to/quake3-rs/target/release /path/to/paks</code> </pre> <br>  La ruta <code>/path/to/paks</code> debe apuntar al directorio que contiene los archivos <code>.pk3</code> . <br><br>  Ahora vamos a correr el juego!  Necesitamos pasar <code>+set vm_game 0</code> , etc., por lo que <code>+set vm_game 0</code> estos módulos como bibliotecas compartidas Rust, y no como un conjunto QVM, así como <code>cl_renderer</code> para usar el renderizador OpenGL1. <br><br><pre> <code class="bash hljs">$ ./ioquake3 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sv_pure 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_game 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_cgame 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_ui 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cl_renderer <span class="hljs-string"><span class="hljs-string">"opengl1"</span></span></code> </pre> <br>  Y ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18e/fb3/94c/18efb394c9f33f6a1cbe78503a25bb4c.png"></div><br>  ¡Lanzamos Quake3 en Rust! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Aquí hay un video de cómo transponemos Quake 3, descargamos el juego y jugamos un poco: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQjvSJLDXW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Puede estudiar las <a href="https://github.com/immunant/ioq3/tree/transpiled/quake3-rs">fuentes transpiladas</a> en la rama <code>transpiled</code> de nuestro repositorio.  También hay una rama <code>refactored</code> contiene las mismas <a href="https://github.com/immunant/ioq3/tree/refactored/quake3-rs">fuentes</a> con varios <a href="https://github.com/immunant/ioq3/blob/transpiled/refactor_commands.txt">comandos de refactorización preaplicados</a> . <br><br><h2>  Cómo transponer </h2><br>  Si desea intentar transponer Quake 3 y ejecutarlo usted mismo, tenga en cuenta que necesitará sus propios recursos de juego Quake 3 o recursos de demostración de Internet.  También necesitará instalar C2Rust (al momento de escribir, la versión nocturna requerida es <code>nightly-2019-12-05</code> , pero le recomendamos que busque en <a href="https://github.com/immunant/c2rust">el repositorio de</a> C2Rust o en <a href="https://crates.io/crates/c2rust">crates.io</a> para encontrar la última versión): <br><br><pre> <code class="bash hljs">$ cargo +nightly-2019-12-05 install c2rust</code> </pre> <br>  y copias de nuestros repositorios C2Rust y ioquake3: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/c2rust.git $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/ioq3.git</code> </pre> <br>  Como alternativa a la instalación de <code>c2rust</code> usando el comando anterior, puede construir C2Rust manualmente usando <code>cargo build --release</code> .  En cualquier caso, aún se necesitará el repositorio C2Rust, porque contiene los scripts de envoltura del compilador necesarios para transponer ioquake3. <br><br>  Hemos publicado un <a href="">script</a> que transporta automáticamente el código C y aplica el parche <code>ssemask</code> .  Para usarlo, ejecute el siguiente comando desde el nivel superior del repositorio <code>ioq3</code> : <br><br><pre> <code class="bash hljs">$ ./transpile.sh &lt;/path/to/C2Rust repository&gt; &lt;/path/to/c2rust binary&gt;</code> </pre> <br>  Este comando debe crear un subdirectorio <code>quake3-rs</code> contenga el código Rust, para el cual puede ejecutar el <code>cargo build --release</code> y los pasos restantes descritos anteriormente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483142/">https://habr.com/ru/post/483142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483130/index.html">¿Qué hacer si se olvida el código para el candado de la maleta?</a></li>
<li><a href="../483132/index.html">Diseño y fabricación de un telescopio.</a></li>
<li><a href="../483134/index.html">Prueba de autenticación de dos factores y posibles soluciones</a></li>
<li><a href="../483136/index.html">Verificación del MacBook usado antes de la compra - lista de verificación</a></li>
<li><a href="../483140/index.html">Polígonos Otro Mundo: Amiga 500</a></li>
<li><a href="../483144/index.html">El científico He Jiankui es un héroe, no un criminal.</a></li>
<li><a href="../483146/index.html">Conferencia DEFCON 27. Herramienta de piratería WiFi inalámbrica Kraken</a></li>
<li><a href="../483148/index.html">Discutimos gemelos digitales y simulación con el fundador de una empresa de consultoría.</a></li>
<li><a href="../483154/index.html">Gasté $ 40 mil y arruiné una gran idea para una startup</a></li>
<li><a href="../483156/index.html">Pon al gato de pie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>