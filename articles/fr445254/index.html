<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ŸğŸ¾ ğŸ“— ğŸŒ©ï¸ Test des contrats intelligents Ethereum sur Go: au revoir, JavaScript ğŸ¤™ ğŸ‘ğŸ» ğŸ‘ˆğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je tiens Ã  remercier mes collÃ¨gues: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich et Igor Titarenko pour les consultations, les commentaires et les t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test des contrats intelligents Ethereum sur Go: au revoir, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="image"><br>  <em>Je tiens Ã  remercier mes collÃ¨gues: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich et Igor Titarenko pour les consultations, les commentaires et les tests.</em>  <em>Je tiens Ã©galement Ã  remercier l'Ã©quipe PolySwarm pour avoir dÃ©veloppÃ© la version originale du PÃ©rigord.</em> <em><br></em> <br>  <em>Ceci est une traduction de mon premier article en anglais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moyen</a> publiÃ©</em> </p><br><p>  Les tests ont toujours fait partie intÃ©grante du dÃ©veloppement logiciel, bien que ce ne soit pas le plus agrÃ©able.  En ce qui concerne les contrats intelligents, des tests rigoureux sont requis avec une attention exceptionnelle aux dÃ©tails, comme  les erreurs seront impossibles Ã  corriger aprÃ¨s le dÃ©ploiement sur le rÃ©seau blockchain.  Au cours des derniÃ¨res annÃ©es, la communautÃ© Ethereum a crÃ©Ã© de nombreux outils pour dÃ©velopper des contrats intelligents.  Certains d'entre eux ne sont pas devenus populaires, par exemple, Vyper - un dialecte Python pour Ã©crire des contrats intelligents.  D'autres, comme Solidity, sont devenus une norme reconnue.  La documentation la plus complÃ¨te sur les tests de contrats intelligents Ã  ce jour fournit un tas de truffes et de ganaches.  Ces deux outils ont une bonne documentation, de nombreux cas ont dÃ©jÃ  Ã©tÃ© dÃ©cidÃ©s sur Stack Overflow et des ressources similaires.  Cependant, cette approche prÃ©sente un inconvÃ©nient important: pour Ã©crire des tests, vous devez utiliser Node.js. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  PiÃ¨ges JavaScript </h4><br><p>  MÃªme si vous n'Ãªtes pas un fan des langages de programmation typÃ©s statiques et que vous aimez JavaScript, envisagez de faire une faute de frappe et de commencer Ã  comparer le rÃ©sultat d'une fonction qui renvoie une chaÃ®ne avec une valeur boolÃ©enne en utilisant la mÃ©thode dÃ©prÃ©ciÃ©e d'Ã©gal au lieu de strictEqual. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Si checkProposal renvoie la chaÃ®ne Â«ouiÂ» ou Â«nonÂ», vous les convertirez toujours en true.  La frappe dynamique masque bon nombre de ces piÃ¨ges, et mÃªme les programmeurs expÃ©rimentÃ©s peuvent commettre de telles erreurs lorsqu'ils travaillent sur un grand projet ou en Ã©quipe avec d'autres dÃ©veloppeurs qui peuvent apporter des modifications au code sans le signaler. </p><br><p>  La saisie statique de Go permet d'Ã©viter de telles erreurs.  De plus, l'utilisation du langage Go au lieu de Node.js pour les tests est le rÃªve de tout dÃ©veloppeur Go qui commence Ã  travailler avec des contrats intelligents. </p><br><p>  Mon Ã©quipe dÃ©veloppait un systÃ¨me d'investissement basÃ© sur des contrats intelligents avec une architecture trÃ¨s complexe.  Le systÃ¨me de contrat intelligent contenait plus de 2 000 lignes de code.  Ã‰tant donnÃ© que la majeure partie de l'Ã©quipe Ã©tait constituÃ©e de dÃ©veloppeurs Go, les tests sur Go Ã©taient prÃ©fÃ©rables Ã  Node.js. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  Le premier environnement pour tester les contrats intelligents sur Go </h4><br><p>  En 2017, PolySwarm a dÃ©veloppÃ© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Perigord</a> , un outil similaire Ã  Truffle, utilisant Go au lieu de JavaScript.  Malheureusement, ce projet n'est plus supportÃ©, il n'a qu'un seul tutoriel avec des exemples trÃ¨s simples.  De plus, il ne prend pas en charge l'intÃ©gration avec Ganache (une chaÃ®ne de blocs privÃ©e pour dÃ©velopper Ethereum avec une interface graphique trÃ¨s pratique).  Nous avons amÃ©liorÃ© Perigord en Ã©liminant les bogues et en introduisant deux nouvelles fonctions: gÃ©nÃ©rer des portefeuilles Ã  partir du code mnÃ©monique et les utiliser pour tester et se connecter Ã  la blockchain Ganache.  Vous pouvez lire le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Le didacticiel PÃ©rigord d'origine ne contient que l'exemple le plus simple d'invoquer un contrat pour modifier une valeur unique.  Cependant, dans le monde rÃ©el, vous devrez Ã©galement appeler un contrat Ã  partir de diffÃ©rents portefeuilles, envoyer et recevoir de l'Ã©ther, etc.  Maintenant, vous pouvez faire tout cela en utilisant le PÃ©rigord avancÃ© et la bonne vieille Ganache.  Vous trouverez ci-dessous des conseils dÃ©taillÃ©s sur le dÃ©veloppement et le test de contrats intelligents Ã  l'aide de PÃ©rigord et Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Utilisation du PÃ©rigord avancÃ©: un guide complet </h4><br><p>  Pour utiliser Perigord, vous devez installer Go 1.7+, solc, abigen et Ganache.  Veuillez consulter la documentation de votre systÃ¨me d'exploitation. </p><br><p>  Installez PÃ©rigord comme suit: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  AprÃ¨s cela, vous pouvez utiliser la commande perigord: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Nous allons maintenant crÃ©er un contrat intelligent Market simple pour dÃ©montrer les options de test disponibles. </p><br><p>  Pour dÃ©marrer un projet, entrez les informations suivantes dans le terminal: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  Le projet apparaÃ®tra dans le dossier src / dans GOPATH.  DÃ©placez le projet vers un autre dossier et mettez Ã  jour les chemins d'importation si vous souhaitez modifier son emplacement.  Voyons ce qu'il y a dans le dossier market /. </p><br><pre> <code class="plaintext hljs">$ tree . â”œâ”€â”€ contracts â”‚ â””â”€â”€ Foo.sol â”œâ”€â”€ generate.go â”œâ”€â”€ main.go â”œâ”€â”€ migrations â”‚ â””â”€â”€ 1_Migrations.go â”œâ”€â”€ perigord.yaml â”œâ”€â”€ stub â”‚ â”œâ”€â”€ README.md â”‚ â””â”€â”€ main.go â”œâ”€â”€ stub_test.go â””â”€â”€ tests â””â”€â”€ Foo.go</code> </pre> <br><p>  TrÃ¨s similaire au projet crÃ©Ã© dans Truffle, n'est-ce pas?  Mais c'est parti!  Voyons ce qu'il y a dans le fichier de configuration perigord.yaml. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Pour les tests, vous pouvez utiliser Ã  la fois le rÃ©seau geth privÃ© et les fichiers de portefeuille, et vous connecter Ã  Ganache.  Ces options s'excluent mutuellement.  Nous prenons les mnÃ©moniques par dÃ©faut, gÃ©nÃ©rons 10 comptes et nous connectons Ã  Ganache.  Remplacez le code dans perigord.yaml par: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP http://127.0.0.1:7545</a> - l'adresse standard du serveur Ganache RPC.  Veuillez noter que vous pouvez crÃ©er n'importe quel nombre de comptes pour les tests, mais seuls les comptes gÃ©nÃ©rÃ©s dans la Ganache (GUI) contiendront des fonds. </p><br><p>  Nous allons crÃ©er un contrat appelÃ© Market.sol.  Il peut tenir un registre des paires d'adresses, dont l'une envoie des fonds au compte du contrat, et l'autre a le droit de recevoir des fonds lorsque le propriÃ©taire du contrat autorise une telle transaction.  Par exemple, deux participants ne se font pas confiance, mais font confiance au propriÃ©taire du contrat, qui dÃ©cide si une certaine condition est remplie.  L'exemple implÃ©mente plusieurs fonctions de base Ã  des fins de dÃ©monstration. </p><br><p>  Ajoutez un contact au projet: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  Le suffixe .sol sera ajoutÃ© automatiquement.  Vous pouvez Ã©galement ajouter d'autres contrats ou supprimer l'exemple de contrat Foo.sol.  Pendant que vous travaillez chez GOPATH, vous pouvez utiliser des contrats d'importation pour crÃ©er des structures complexes.  Nous aurons trois fichiers Solidity: le contrat Market principal, les contrats auxiliaires Ownable et Migrations, et la bibliothÃ¨que SafeMath.  Vous pouvez trouver le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Maintenant, le projet a la structure suivante: </p><br><pre> <code class="plaintext hljs">. â”œâ”€â”€ contracts â”‚ â”œâ”€â”€ Market.sol â”‚ â”œâ”€â”€ Ownable.sol â”‚ â””â”€â”€ SafeMath.sol â”œâ”€â”€ generate.go â”œâ”€â”€ main.go â”œâ”€â”€ migrations â”‚ â””â”€â”€ 1_Migrations.go â”œâ”€â”€ perigord.yaml â”œâ”€â”€ stub â”‚ â”œâ”€â”€ README.md â”‚ â””â”€â”€ main.go â”œâ”€â”€ stub_test.go â””â”€â”€ tests â””â”€â”€ Foo.go</code> </pre> <br><p>  GÃ©nÃ©rez le bytecode EVM, les liaisons ABI et Go: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  Ajoutez les migrations de tous les contrats que vous dÃ©ploierez.  Parce que  nous dÃ©ployons uniquement Market.sol, nous n'avons besoin que d'une nouvelle migration: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Notre contrat ne contient pas de constructeur qui accepte les paramÃ¨tres.  Si vous devez transmettre des paramÃ¨tres au constructeur, ajoutez-les Ã  la fonction Deploy {NewContract} dans le fichier de migration: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), â€œFOOâ€, â€œBARâ€)</code> </pre> <br><p>  Supprimez l'exemple de fichier Foo.go et ajoutez un fichier de test pour notre contrat: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Pour utiliser des portefeuilles dÃ©terministes, nous devons lire les mnÃ©moniques du fichier de configuration: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  La fonction d'assistance suivante est utilisÃ©e pour obtenir l'adresse rÃ©seau: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Une autre fonction d'assistance dont nous aurons besoin est sendETH, nous l'utiliserons pour transfÃ©rer Ether depuis l'un des portefeuilles gÃ©nÃ©rÃ©s (indiquÃ© par l'index) vers n'importe quelle adresse Ethereum: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  Les deux fonctions suivantes sont utilisÃ©es pour modifier un appel de contrat: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  ProcÃ©dure de test </h4><br><p>  Pour un appel, nous crÃ©ons un contratSessionActual pour un contrat spÃ©cifique.  Parce que  le contrat a un propriÃ©taire, nous pouvons obtenir son adresse et vÃ©rifier s'il correspond au compte Ganache zÃ©ro par dÃ©faut.  Nous procÃ©derons comme suit (nous omettons la gestion des erreurs pour Ã©conomiser de l'espace): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  La prochaine fonctionnalitÃ© utile consiste Ã  changer le portefeuille Ã  l'origine du contrat: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Parce que  l'une des principales fonctions utilisÃ©es dans les tests est la modification du contrat d'appel, effectuons un paiement au nom de l'expÃ©diteur: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  Le code de test complet est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Ouvrez maintenant stub_test.go et assurez-vous que toutes les importations pointent vers votre projet actuel.  Dans notre cas, c'est: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  ExÃ©cutez les tests: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Si tout est fait correctement, aprÃ¨s la fin du test, il y aura un rÃ©sultat similaire: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Si vous rencontrez des problÃ¨mes, tÃ©lÃ©chargez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers</a> source et rÃ©pÃ©tez les Ã©tapes dÃ©crites dans ce guide. </p><br><h4 id="v-zaklyuchenie">  En conclusion </h4><br><p>  Perigord est un outil de test fiable Ã©crit dans votre langue prÃ©fÃ©rÃ©e.  Il crÃ©e la mÃªme structure de projet que Truffle et a les mÃªmes Ã©quipes, vous n'aurez donc pas besoin de rÃ©apprendre.  Le typage statique et une signature de fonction sans ambiguÃ¯tÃ© vous permettent de dÃ©velopper et d'effectuer rapidement le dÃ©bogage, ainsi que de vous protÃ©ger de maniÃ¨re significative contre les fautes de frappe dans les arguments.  En PÃ©rigord, vous pouvez facilement migrer un projet existant vers Truffle (tout ce que vous devez faire est de copier et coller les fichiers de contrat dans le dossier appropriÃ© et ajouter des tests), et Ã©galement dÃ©marrer un tout nouveau projet avec des tests Ã©crits en Go. </p><br><p>  J'espÃ¨re que le travail commencÃ© par l'Ã©quipe PolySwarm et poursuivi par Inn4Science sera utile Ã  la communautÃ© Go et libÃ©rera des heures de test et de dÃ©bogage Ã  l'aide d'outils moins pratiques. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445254/">https://habr.com/ru/post/fr445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445242/index.html">ExpÃ©rience avec Coroutines et Retrofit2</a></li>
<li><a href="../fr445244/index.html">Â«Les jeux d'argent en dehors de la blockchain doivent mourirÂ»</a></li>
<li><a href="../fr445246/index.html">Les jeux non Blockchain impliquant de l'argent doivent mourir</a></li>
<li><a href="../fr445248/index.html">Vous voulez Ãªtre un peu plus heureux? Essayez d'Ãªtre le meilleur dans votre domaine</a></li>
<li><a href="../fr445252/index.html">Les droits numÃ©riques sont arrivÃ©s en Russie</a></li>
<li><a href="../fr445256/index.html">Les cybercriminels contrÃ´lent ASUS Live Update pendant cinq mois</a></li>
<li><a href="../fr445258/index.html">Comment supprimer en toute sÃ©curitÃ© vos donnÃ©es de votre smartphone Android avant de les vendre</a></li>
<li><a href="../fr445260/index.html">Les robots se reconnaÃ®tront-ils jamais vraiment? Les scientifiques s'orientent dans cette direction.</a></li>
<li><a href="../fr445262/index.html">GeekUniversity ouvre le recrutement au dÃ©partement Big Data d'Analytics</a></li>
<li><a href="../fr445264/index.html">PrÃ©chargement, prÃ©lecture et autres balises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>