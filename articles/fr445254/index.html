<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏾 📗 🌩️ Test des contrats intelligents Ethereum sur Go: au revoir, JavaScript 🤙 👍🏻 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je tiens à remercier mes collègues: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich et Igor Titarenko pour les consultations, les commentaires et les t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test des contrats intelligents Ethereum sur Go: au revoir, JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445254/"><p><img src="https://cdn-images-1.medium.com/max/1600/1*WNQyyGK2TrOy2m784kJang.jpeg" alt="image"><br>  <em>Je tiens à remercier mes collègues: Sergey Nemesh, Mikhail Popsuyev, Evgeny Babich et Igor Titarenko pour les consultations, les commentaires et les tests.</em>  <em>Je tiens également à remercier l'équipe PolySwarm pour avoir développé la version originale du Périgord.</em> <em><br></em> <br>  <em>Ceci est une traduction de mon premier article en anglais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moyen</a> publié</em> </p><br><p>  Les tests ont toujours fait partie intégrante du développement logiciel, bien que ce ne soit pas le plus agréable.  En ce qui concerne les contrats intelligents, des tests rigoureux sont requis avec une attention exceptionnelle aux détails, comme  les erreurs seront impossibles à corriger après le déploiement sur le réseau blockchain.  Au cours des dernières années, la communauté Ethereum a créé de nombreux outils pour développer des contrats intelligents.  Certains d'entre eux ne sont pas devenus populaires, par exemple, Vyper - un dialecte Python pour écrire des contrats intelligents.  D'autres, comme Solidity, sont devenus une norme reconnue.  La documentation la plus complète sur les tests de contrats intelligents à ce jour fournit un tas de truffes et de ganaches.  Ces deux outils ont une bonne documentation, de nombreux cas ont déjà été décidés sur Stack Overflow et des ressources similaires.  Cependant, cette approche présente un inconvénient important: pour écrire des tests, vous devez utiliser Node.js. </p><a name="habracut"></a><br><h4 id="lovushki-javascript">  Pièges JavaScript </h4><br><p>  Même si vous n'êtes pas un fan des langages de programmation typés statiques et que vous aimez JavaScript, envisagez de faire une faute de frappe et de commencer à comparer le résultat d'une fonction qui renvoie une chaîne avec une valeur booléenne en utilisant la méthode dépréciée d'égal au lieu de strictEqual. </p><br><pre><code class="plaintext hljs">let proposalExists = await voting.checkProposal(); assert.equal(proposalExists, true, 'Proposal should exist');</code> </pre> <br><p>  Si checkProposal renvoie la chaîne «oui» ou «non», vous les convertirez toujours en true.  La frappe dynamique masque bon nombre de ces pièges, et même les programmeurs expérimentés peuvent commettre de telles erreurs lorsqu'ils travaillent sur un grand projet ou en équipe avec d'autres développeurs qui peuvent apporter des modifications au code sans le signaler. </p><br><p>  La saisie statique de Go permet d'éviter de telles erreurs.  De plus, l'utilisation du langage Go au lieu de Node.js pour les tests est le rêve de tout développeur Go qui commence à travailler avec des contrats intelligents. </p><br><p>  Mon équipe développait un système d'investissement basé sur des contrats intelligents avec une architecture très complexe.  Le système de contrat intelligent contenait plus de 2 000 lignes de code.  Étant donné que la majeure partie de l'équipe était constituée de développeurs Go, les tests sur Go étaient préférables à Node.js. </p><br><h4 id="pervaya-sreda-dlya-testirovaniya-smart-kontraktov-na-go">  Le premier environnement pour tester les contrats intelligents sur Go </h4><br><p>  En 2017, PolySwarm a développé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Perigord</a> , un outil similaire à Truffle, utilisant Go au lieu de JavaScript.  Malheureusement, ce projet n'est plus supporté, il n'a qu'un seul tutoriel avec des exemples très simples.  De plus, il ne prend pas en charge l'intégration avec Ganache (une chaîne de blocs privée pour développer Ethereum avec une interface graphique très pratique).  Nous avons amélioré Perigord en éliminant les bogues et en introduisant deux nouvelles fonctions: générer des portefeuilles à partir du code mnémonique et les utiliser pour tester et se connecter à la blockchain Ganache.  Vous pouvez lire le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Le didacticiel Périgord d'origine ne contient que l'exemple le plus simple d'invoquer un contrat pour modifier une valeur unique.  Cependant, dans le monde réel, vous devrez également appeler un contrat à partir de différents portefeuilles, envoyer et recevoir de l'éther, etc.  Maintenant, vous pouvez faire tout cela en utilisant le Périgord avancé et la bonne vieille Ganache.  Vous trouverez ci-dessous des conseils détaillés sur le développement et le test de contrats intelligents à l'aide de Périgord et Ganache. </p><br><h4 id="ispolzovanie-uluchshennogo-perigord-polnoe-rukovodstvo">  Utilisation du Périgord avancé: un guide complet </h4><br><p>  Pour utiliser Perigord, vous devez installer Go 1.7+, solc, abigen et Ganache.  Veuillez consulter la documentation de votre système d'exploitation. </p><br><p>  Installez Périgord comme suit: </p><br><pre> <code class="plaintext hljs">$ go get gitlab.com/go-truffle/enhanced-perigord $ go build</code> </pre> <br><p>  Après cela, vous pouvez utiliser la commande perigord: </p><br><pre> <code class="plaintext hljs">$ perigord A golang development environment for Ethereum Usage: perigord [command] Available Commands: add Add a new contract or test to the project build (alias for compile) compile Compile contract source files deploy (alias for migrate) generate (alias for compile) help Help about any command init Initialize new Ethereum project with example contracts and tests migrate Run migrations to deploy contracts test Run go and solidity tests Flags: -h, --help help for perigord Use "perigord [command] --help" for more information about a command.</code> </pre> <br><p>  Nous allons maintenant créer un contrat intelligent Market simple pour démontrer les options de test disponibles. </p><br><p>  Pour démarrer un projet, entrez les informations suivantes dans le terminal: </p><br><pre> <code class="plaintext hljs">$ perigord init market</code> </pre> <br><p>  Le projet apparaîtra dans le dossier src / dans GOPATH.  Déplacez le projet vers un autre dossier et mettez à jour les chemins d'importation si vous souhaitez modifier son emplacement.  Voyons ce qu'il y a dans le dossier market /. </p><br><pre> <code class="plaintext hljs">$ tree . ├── contracts │ └── Foo.sol ├── generate.go ├── main.go ├── migrations │ └── 1_Migrations.go ├── perigord.yaml ├── stub │ ├── README.md │ └── main.go ├── stub_test.go └── tests └── Foo.go</code> </pre> <br><p>  Très similaire au projet créé dans Truffle, n'est-ce pas?  Mais c'est parti!  Voyons ce qu'il y a dans le fichier de configuration perigord.yaml. </p><br><pre> <code class="plaintext hljs">networks: dev: url: /tmp/geth_private_testnet/geth.ipc keystore: /tmp/geth_private_testnet/keystore passphrase: blah mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  Pour les tests, vous pouvez utiliser à la fois le réseau geth privé et les fichiers de portefeuille, et vous connecter à Ganache.  Ces options s'excluent mutuellement.  Nous prenons les mnémoniques par défaut, générons 10 comptes et nous connectons à Ganache.  Remplacez le code dans perigord.yaml par: </p><br><pre> <code class="plaintext hljs">networks: dev: url: HTTP://127.0.0.1:7545 mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat num_accounts: 10</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP http://127.0.0.1:7545</a> - l'adresse standard du serveur Ganache RPC.  Veuillez noter que vous pouvez créer n'importe quel nombre de comptes pour les tests, mais seuls les comptes générés dans la Ganache (GUI) contiendront des fonds. </p><br><p>  Nous allons créer un contrat appelé Market.sol.  Il peut tenir un registre des paires d'adresses, dont l'une envoie des fonds au compte du contrat, et l'autre a le droit de recevoir des fonds lorsque le propriétaire du contrat autorise une telle transaction.  Par exemple, deux participants ne se font pas confiance, mais font confiance au propriétaire du contrat, qui décide si une certaine condition est remplie.  L'exemple implémente plusieurs fonctions de base à des fins de démonstration. </p><br><p>  Ajoutez un contact au projet: </p><br><pre> <code class="plaintext hljs">$ perigord add contract Market</code> </pre> <br><p>  Le suffixe .sol sera ajouté automatiquement.  Vous pouvez également ajouter d'autres contrats ou supprimer l'exemple de contrat Foo.sol.  Pendant que vous travaillez chez GOPATH, vous pouvez utiliser des contrats d'importation pour créer des structures complexes.  Nous aurons trois fichiers Solidity: le contrat Market principal, les contrats auxiliaires Ownable et Migrations, et la bibliothèque SafeMath.  Vous pouvez trouver le code source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Maintenant, le projet a la structure suivante: </p><br><pre> <code class="plaintext hljs">. ├── contracts │ ├── Market.sol │ ├── Ownable.sol │ └── SafeMath.sol ├── generate.go ├── main.go ├── migrations │ └── 1_Migrations.go ├── perigord.yaml ├── stub │ ├── README.md │ └── main.go ├── stub_test.go └── tests └── Foo.go</code> </pre> <br><p>  Générez le bytecode EVM, les liaisons ABI et Go: </p><br><pre> <code class="plaintext hljs">$ perigord build</code> </pre> <br><p>  Ajoutez les migrations de tous les contrats que vous déploierez.  Parce que  nous déployons uniquement Market.sol, nous n'avons besoin que d'une nouvelle migration: </p><br><pre> <code class="plaintext hljs">$ perigord add migration Market</code> </pre> <br><p>  Notre contrat ne contient pas de constructeur qui accepte les paramètres.  Si vous devez transmettre des paramètres au constructeur, ajoutez-les à la fonction Deploy {NewContract} dans le fichier de migration: </p><br><pre> <code class="plaintext hljs">address, transaction, contract, err := bindings.Deploy{NewContract}(auth, network.Client(), “FOO”, “BAR”)</code> </pre> <br><p>  Supprimez l'exemple de fichier Foo.go et ajoutez un fichier de test pour notre contrat: </p><br><pre> <code class="plaintext hljs">$ perigord add test Market</code> </pre> <br><p>  Pour utiliser des portefeuilles déterministes, nous devons lire les mnémoniques du fichier de configuration: </p><br><pre> <code class="plaintext hljs">func getMnemonic() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } mnemonic := viper.GetStringMapString("networks.dev")["mnemonic"] return mnemonic }</code> </pre> <br><p>  La fonction d'assistance suivante est utilisée pour obtenir l'adresse réseau: </p><br><pre> <code class="plaintext hljs">func getNetworkAddress() string { viper.SetConfigFile("perigord.yaml") if err := viper.ReadInConfig(); err != nil { log.Fatal() } networkAddr := viper.GetStringMapString("networks.dev")["url"] return networkAddr }</code> </pre> <br><p>  Une autre fonction d'assistance dont nous aurons besoin est sendETH, nous l'utiliserons pour transférer Ether depuis l'un des portefeuilles générés (indiqué par l'index) vers n'importe quelle adresse Ethereum: </p><br><pre> <code class="plaintext hljs">func sendETH(s *MarketSuite, c *ethclient.Client, sender int, receiver common.Address, value *big.Int) { senderAcc := s.network.Accounts()[sender].Address nonce, err := c.PendingNonceAt(context.Background(), senderAcc) if err != nil { log.Fatal(err) } gasLimit := uint64(6721975) // in units gasPrice := big.NewInt(3700000000) wallet, err := hdwallet.NewFromMnemonic(getMnemonic()) toAddress := receiver var data []byte tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data) chainID, err := c.NetworkID(context.Background()) if err != nil { log.Fatal(err) } privateKey, err := wallet.PrivateKey(s.network.Accounts()[sender]) signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) if err != nil { log.Fatal(err) } ts := types.Transactions{signedTx} rawTx := hex.EncodeToString(ts.GetRlp(0)) var trx *types.Transaction rawTxBytes, err := hex.DecodeString(rawTx) err = rlp.DecodeBytes(rawTxBytes, &amp;trx) err = c.SendTransaction(context.Background(), trx) if err != nil { log.Fatal(err) } }</code> </pre> <br><p>  Les deux fonctions suivantes sont utilisées pour modifier un appel de contrat: </p><br><pre> <code class="plaintext hljs">func ensureAuth(auth bind.TransactOpts) *bind.TransactOpts { return &amp;bind.TransactOpts{ auth.From, auth.Nonce, auth.Signer, auth.Value, auth.GasPrice, auth.GasLimit, auth.Context} } func changeAuth(s MarketSuite, account int) bind.TransactOpts { return *s.network.NewTransactor(s.network.Accounts()[account]) }</code> </pre> <br><h4 id="procedura-testirovaniya">  Procédure de test </h4><br><p>  Pour un appel, nous créons un contratSessionActual pour un contrat spécifique.  Parce que  le contrat a un propriétaire, nous pouvons obtenir son adresse et vérifier s'il correspond au compte Ganache zéro par défaut.  Nous procéderons comme suit (nous omettons la gestion des erreurs pour économiser de l'espace): </p><br><pre> <code class="plaintext hljs">contractSession := contract.Session("Market") c.Assert(contractSession, NotNil) contractSessionActual, ok := contractSession.(*bindings.MarketSession) c.Assert(ok, Equals, true) c.Assert(contractSessionActual, NotNil) owner, _ := contractSessionActual.Owner() account0 := s.network.Accounts()[0] c.Assert(owner.Hex(), Equals, account0.Address.Hex()) //Owner account is account 0</code> </pre> <br><p>  La prochaine fonctionnalité utile consiste à changer le portefeuille à l'origine du contrat: </p><br><pre> <code class="plaintext hljs">ownerInd := 0 sender := 5 receiver := 6 senderAcc := s.network.Accounts()[sender].Address receiverAcc := s.network.Accounts()[receiver].Address //Call contract on behalf of its owner auth := changeAuth(*s, ownerInd) _, err = contractSessionActual.Contract.SetSenderReceiverPair(ensureAuth(auth), senderAcc, receiverAcc)</code> </pre> <br><p>  Parce que  l'une des principales fonctions utilisées dans les tests est la modification du contrat d'appel, effectuons un paiement au nom de l'expéditeur: </p><br><pre> <code class="plaintext hljs">auth = changeAuth(*s, sender) //Change auth fo senderAcc to make a deposit on behalf of the sender client, _ := ethclient.Dial(getNetworkAddress()) //Let's check the current balance balance, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance.Int64(), Equals, big.NewInt(0).Int64()) //Balance should be 0 //Let's transfer 3 ETH to the contract on behalf of the sender value := big.NewInt(3000000000000000000) // in wei (3 eth) contractReceiver := contract.AddressOf("Market") sendETH(s, client, sender, contractReceiver, value) balance2, _ := client.BalanceAt(context.Background(), contract.AddressOf("Market"), nil) c.Assert(balance2.Int64(), Equals, value.Int64()) //Balance should be 3 ETH</code> </pre> <br><p>  Le code de test complet est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Ouvrez maintenant stub_test.go et assurez-vous que toutes les importations pointent vers votre projet actuel.  Dans notre cas, c'est: </p><br><pre> <code class="plaintext hljs">import ( _ "market/migrations" _ "market/tests" "testing" . "gopkg.in/check.v1" )</code> </pre> <br><p>  Exécutez les tests: </p><br><pre> <code class="plaintext hljs">$ perigord test</code> </pre> <br><p>  Si tout est fait correctement, après la fin du test, il y aura un résultat similaire: </p><br><pre> <code class="plaintext hljs">Running migration 2 Running migration 3 OK: 1 passed PASS ok market 0.657s</code> </pre> <br><p>  Si vous rencontrez des problèmes, téléchargez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers</a> source et répétez les étapes décrites dans ce guide. </p><br><h4 id="v-zaklyuchenie">  En conclusion </h4><br><p>  Perigord est un outil de test fiable écrit dans votre langue préférée.  Il crée la même structure de projet que Truffle et a les mêmes équipes, vous n'aurez donc pas besoin de réapprendre.  Le typage statique et une signature de fonction sans ambiguïté vous permettent de développer et d'effectuer rapidement le débogage, ainsi que de vous protéger de manière significative contre les fautes de frappe dans les arguments.  En Périgord, vous pouvez facilement migrer un projet existant vers Truffle (tout ce que vous devez faire est de copier et coller les fichiers de contrat dans le dossier approprié et ajouter des tests), et également démarrer un tout nouveau projet avec des tests écrits en Go. </p><br><p>  J'espère que le travail commencé par l'équipe PolySwarm et poursuivi par Inn4Science sera utile à la communauté Go et libérera des heures de test et de débogage à l'aide d'outils moins pratiques. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445254/">https://habr.com/ru/post/fr445254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445242/index.html">Expérience avec Coroutines et Retrofit2</a></li>
<li><a href="../fr445244/index.html">«Les jeux d'argent en dehors de la blockchain doivent mourir»</a></li>
<li><a href="../fr445246/index.html">Les jeux non Blockchain impliquant de l'argent doivent mourir</a></li>
<li><a href="../fr445248/index.html">Vous voulez être un peu plus heureux? Essayez d'être le meilleur dans votre domaine</a></li>
<li><a href="../fr445252/index.html">Les droits numériques sont arrivés en Russie</a></li>
<li><a href="../fr445256/index.html">Les cybercriminels contrôlent ASUS Live Update pendant cinq mois</a></li>
<li><a href="../fr445258/index.html">Comment supprimer en toute sécurité vos données de votre smartphone Android avant de les vendre</a></li>
<li><a href="../fr445260/index.html">Les robots se reconnaîtront-ils jamais vraiment? Les scientifiques s'orientent dans cette direction.</a></li>
<li><a href="../fr445262/index.html">GeekUniversity ouvre le recrutement au département Big Data d'Analytics</a></li>
<li><a href="../fr445264/index.html">Préchargement, prélecture et autres balises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>