<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèª ‚ô•Ô∏è üõÖ Precio de composici√≥n en el mundo javascript üßìüèø üôéüèΩ üöû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La idea de que en el desarrollo de una l√≥gica comercial m√°s o menos compleja, se debe dar prioridad a la composici√≥n de los objetos, en lugar de la he...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Precio de composici√≥n en el mundo javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438404/"> La idea de que en el desarrollo de una l√≥gica comercial m√°s o menos compleja, se debe dar prioridad a la composici√≥n de los objetos, en lugar de la herencia, es popular entre los desarrolladores de software de varios tipos.  En la pr√≥xima ola de popularidad del paradigma de programaci√≥n funcional lanzado por el √©xito de ReactJS, se habl√≥ sobre los beneficios de las soluciones compositivas.  En esta publicaci√≥n hay un peque√±o dise√±o en los estantes de la teor√≠a de la composici√≥n de objetos en Javascript, un ejemplo espec√≠fico, su an√°lisis y la respuesta a la pregunta de cu√°nto cuesta la elegancia sem√°ntica para el usuario (spoiler: mucho). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f30/874/502/f308745025666d09822337569aad1b1c.jpg" alt="V. Kandinsky - Composici√≥n X"><br>  <i>Vasily Kandinsky - "Composici√≥n X"</i> <br><a name="habracut"></a><br>  A√±os de desarrollo exitoso de un enfoque de desarrollo orientado a objetos, principalmente en la esfera acad√©mica, han llevado a un desequilibrio notable en la mente del desarrollador promedio.  Entonces, en la mayor√≠a de los casos, el primer pensamiento, si es necesario, para generalizar un comportamiento para varias entidades diversas es crear una clase padre y heredar este comportamiento.  Este enfoque de abuso conduce a varios problemas que complican el dise√±o e inhiben el desarrollo. <br><br>  Primero, la clase base sobrecargada de l√≥gica se vuelve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fr√°gil</a> : un peque√±o cambio en sus m√©todos puede afectar fatalmente las clases derivadas.  Una forma de sortear esta situaci√≥n es distribuir la l√≥gica en varias clases, creando una jerarqu√≠a de herencia m√°s compleja.  En este caso, el desarrollador tiene otro problema: la l√≥gica de las clases principales se duplica en los herederos seg√∫n sea necesario, en casos de intersecci√≥n entre la funcionalidad de las clases principales, pero, lo que es m√°s importante, no est√° completa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/fc2/3fa/4ac/fc23fa4ac64d720585bded474be46303.png" alt="imagen"></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mail.mozilla.org/pipermail/es-discuss/2013-June/031614.html</a> <br><br>  Y finalmente, creando una jerarqu√≠a bastante profunda, el usuario, cuando usa cualquier entidad, se ve obligado a arrastrar a todos sus antepasados ‚Äã‚Äãjunto con todas sus dependencias, independientemente de si va a usar su funcionalidad o no.  Este problema de dependencia excesiva del medio ambiente con una mano ligera de Joe Armstrong, creador de Erlang, se llam√≥ el problema del gorila y el pl√°tano: <br><br><blockquote>  Creo que la falta de reutilizaci√≥n viene en lenguajes orientados a objetos, no en lenguajes funcionales.  Debido a que el problema con los lenguajes orientados a objetos es que tienen todo este entorno impl√≠cito que llevan consigo.  Quer√≠as un pl√°tano pero lo que obtuviste fue un gorila sosteniendo el pl√°tano y toda la jungla. </blockquote><br>  La composici√≥n de los objetos est√° llamada a resolver todos estos problemas como una alternativa a la herencia de clases.  La idea no es nueva en absoluto, pero no encuentra una comprensi√≥n completa entre los desarrolladores.  La situaci√≥n en el mundo front-end es ligeramente mejor, donde la estructura de los proyectos de software es a menudo bastante simple y no estimula la creaci√≥n de un esquema complejo de relaci√≥n orientada a objetos.  Sin embargo, seguir ciegamente los convenios de la Banda de los Cuatro, recomendando preferir la composici√≥n sobre la herencia, tambi√©n puede jugar un truco en la sabidur√≠a inspiradora de los grandes desarrolladores. <br><br>  Transfiriendo definiciones de "Patrones de dise√±o" al mundo din√°mico de Javascript, podemos resumir tres tipos de composici√≥n de objetos: <b>agregaci√≥n</b> , <b>concatenaci√≥n</b> y <b>delegaci√≥n</b> .  Vale la pena decir que esta separaci√≥n y el concepto de composici√≥n de objetos en general tiene una naturaleza puramente t√©cnica, mientras que el significado de estos t√©rminos tiene intersecciones, lo que introduce confusi√≥n.  Entonces, por ejemplo, la herencia de clases en Javascript se implementa sobre la base de la delegaci√≥n (herencia prototipo).  Por lo tanto, cada uno de los casos es mejor hacer copias de seguridad con ejemplos de c√≥digo en vivo. <br><br>  <b>La agregaci√≥n</b> es una uni√≥n enumerable de objetos, cada uno de los cuales se puede obtener utilizando un identificador de acceso √∫nico.  Los ejemplos incluyen matrices, √°rboles, gr√°ficos.  Un buen ejemplo del mundo del desarrollo web es el √°rbol DOM.  La principal cualidad de este tipo de composici√≥n y la raz√≥n de su creaci√≥n es la capacidad de aplicar convenientemente alg√∫n controlador a cada elemento secundario de la composici√≥n. <br><br>  Un ejemplo sint√©tico es una matriz de objetos que se turnan para configurar un estilo para un elemento visual arbitrario. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> styles = [  { <span class="hljs-attr"><span class="hljs-attr">fontSize</span></span>: <span class="hljs-string"><span class="hljs-string">'12px'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Verdana'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'italic'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontWeight</span></span>: <span class="hljs-string"><span class="hljs-string">'bold'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Tahoma'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'normal'</span></span>} ];</code> </pre> <br>  Cada uno de los objetos de estilo puede extraerse por su √≠ndice sin p√©rdida de informaci√≥n.  Adem√°s, utilizando Array.prototype.map (), puede procesar todos los valores almacenados de una manera determinada. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFontFamily = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.fontFamily; styles.map(getFontFamily) <span class="hljs-comment"><span class="hljs-comment">//["Arial","Verdana","Tahoma"]</span></span></code> </pre> <br>  <b>La concatenaci√≥n</b> implica expandir la funcionalidad de un objeto existente al agregarle nuevas propiedades.  As√≠, por ejemplo, los reductores de estado en Redux funcionan.  Los datos recibidos para la actualizaci√≥n se escriben en el objeto de estado, expandi√©ndolo.  Los datos sobre el estado actual del objeto, a diferencia de la agregaci√≥n, se pierden si no se guardan. <br><br>  Volviendo al ejemplo, aplicando alternativamente la configuraci√≥n anterior al elemento visual, puede generar el resultado final concatenando los par√°metros de los objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> concatenate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, s</span></span></span><span class="hljs-function">) =&gt;</span></span> ({‚Ä¶a, ‚Ä¶s}); styles.reduce(concatenate, {}) <span class="hljs-comment"><span class="hljs-comment">//{fontSize:"12px",fontFamily:"Tahoma",fontStyle:"normal",fontWeight:"bold"}</span></span></code> </pre> <br>  Los valores de un estilo m√°s espec√≠fico eventualmente sobrescribir√°n los estados anteriores. <br><br>  Al <b>delegar</b> , como puede suponer, un objeto se delega a otro.  Los delegados, por ejemplo, son prototipos en Javascript.  Las instancias de objetos derivados redirigen las llamadas a los m√©todos principales.  Si no hay ninguna propiedad o m√©todo requerido en la instancia de la matriz, redirigir√° esta llamada a Array.prototype y, si es necesario, m√°s all√° de Object.prototype.  Por lo tanto, el mecanismo de herencia en Javascript se basa en la cadena de delegaci√≥n prototipo, que t√©cnicamente es una versi√≥n (sorpresa) de la composici√≥n. <br><br>  La combinaci√≥n de una matriz de objetos de estilo por delegaci√≥n se puede hacer de la siguiente manera. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delegate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(a), b); styles.reduceRight(delegate, {}) <span class="hljs-comment"><span class="hljs-comment">//{"fontSize":"12px","fontFamily":"Arial"} styles.reduceRight(delegate, {}).fontWeight //bold</span></span></code> </pre> <br>  Como puede ver, las propiedades de delegado no son accesibles por enumeraci√≥n (por ejemplo, usando Object.keys ()), pero solo son accesibles por acceso expl√≠cito.  El hecho de que esto nos da est√° al final del post. <br><br>  Ahora a los detalles.  Un buen ejemplo de un caso que alienta a un desarrollador a usar la composici√≥n en lugar de la herencia es en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">composici√≥n de objetos de</a> Michael Rise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Javascript</a> .  Aqu√≠, el autor considera el proceso de crear una jerarqu√≠a de personajes de rol.  Inicialmente, se requieren dos tipos de personajes: un guerrero y un mago, cada uno de los cuales tiene una reserva de salud y un nombre.  Estas propiedades son comunes y se pueden mover a la clase principal Car√°cter. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.health = <span class="hljs-number"><span class="hljs-number">100</span></span>; } }</code> </pre> <br>  El guerrero se distingue por el hecho de que sabe c√≥mo atacar, mientras gasta su resistencia, y el mago, la capacidad de lanzar hechizos, lo que reduce la cantidad de man√°. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fighter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina = <span class="hljs-number"><span class="hljs-number">100</span></span>; } fight() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> takes a mighty swing!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina -  ; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana = <span class="hljs-number"><span class="hljs-number">100</span></span>; } cast() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> casts a fireball!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana -  ; } }</code> </pre> <br>  Despu√©s de crear las clases Fighter y Mage, los descendientes de Character, el desarrollador se enfrenta a un problema inesperado cuando es necesario crear la clase Paladin.  El nuevo personaje se distingue por la capacidad envidiable de luchar y conjurar.  De improviso puede ver un par de soluciones que difieren en la misma falta de gracia. <br><br><ol><li>  Puedes hacer que Paladin sea un descendiente de Character e implementar ambos fight () y cast () desde cero.  En este caso, se viola gravemente el principio DRY, ya que cada uno de los m√©todos se duplicar√° durante la creaci√≥n y posteriormente necesitar√° una sincronizaci√≥n constante con los m√©todos de las clases Mage y Fighter para rastrear los cambios. </li><li>  Los m√©todos fight () y cast () se pueden implementar a nivel de la clase Charater para que los tres tipos de personajes los posean.  Esta es una soluci√≥n un poco m√°s agradable, sin embargo, en este caso, el desarrollador debe redefinir el m√©todo fight () para el mago y el m√©todo cast () para el guerrero, reemplaz√°ndolos con trozos vac√≠os. </li></ol><br>  En cualquiera de las opciones, tarde o temprano uno tiene que enfrentar los problemas de herencia expresados ‚Äã‚Äãal comienzo de la publicaci√≥n.  Se pueden resolver con un enfoque funcional para la implementaci√≥n de personajes.  Es suficiente para alejarse no de sus tipos, sino de sus funciones.  En resumen, tenemos dos caracter√≠sticas clave que determinan la capacidad de los personajes: la capacidad de luchar y la capacidad de conjurar.  Estas caracter√≠sticas se pueden configurar utilizando funciones de f√°brica que expanden el estado que define el car√°cter (un ejemplo de composici√≥n es la concatenaci√≥n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canCast = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">cast</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> casts </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${spell}</span></span></span><span class="hljs-string">!`</span></span>); state.mana -  ; } }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canFight = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">fight</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> slashes at the foe!`</span></span>); state.stamina -  ; } })</code> </pre> <br>  Por lo tanto, el personaje est√° determinado por el conjunto de estas caracter√≠sticas y las propiedades iniciales, tanto generales (nombre y salud) como privadas (resistencia y man√°). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fighter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canFight(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> paladin = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state), canFight(state)); }</code> </pre> <br>  Todo es hermoso: el c√≥digo de acci√≥n se reutiliza, puede agregar cualquier personaje nuevo con facilidad, sin tocar los anteriores y sin inflar la funcionalidad de ning√∫n objeto.  Para encontrar una mosca en el ung√ºento en la soluci√≥n propuesta, es suficiente comparar el rendimiento de la soluci√≥n basada en la herencia (delegaci√≥n de lectura) y la soluci√≥n basada en la concatenaci√≥n.  Crea un ej√©rcito millon√©simo de instancias de los personajes creados. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inheritanceArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compositionArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { compositionArmy.push(fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); compositionArmy.push(mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); }</code> </pre> <br>  Y compare la memoria y los costos computacionales entre la herencia y la composici√≥n necesaria para crear objetos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/158/509/b8f/158509b8fb1d5dc214b2728f72145565.png" alt="imagen"><br><br>  En promedio, una soluci√≥n que utiliza una composici√≥n por concatenaci√≥n requiere 100-150% m√°s de recursos.  Los resultados presentados se obtuvieron en el entorno NodeJS, puede ver los resultados para el motor del navegador ejecutando esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://medium.com/r/%3Furl%3D">prueba</a> . <br><br>  La ventaja de la soluci√≥n basada en la delegaci√≥n de herencia se puede explicar al ahorrar memoria debido a la falta de acceso impl√≠cito a las propiedades de delegado, as√≠ como al deshabilitar algunas optimizaciones de motor para delegados din√°micos.  A su vez, la soluci√≥n basada en concatenaci√≥n utiliza el costoso m√©todo Object.assign (), que afecta en gran medida su rendimiento.  Curiosamente, Firefox Quantum muestra resultados de cromo diametralmente opuestos: la segunda soluci√≥n funciona mucho m√°s r√°pido en Gecko. <br><br>  Por supuesto, vale la pena confiar en los resultados de las pruebas de rendimiento solo al resolver tareas bastante laboriosas relacionadas con la creaci√≥n de una gran cantidad de objetos de infraestructura compleja, por ejemplo, cuando se trabaja con un √°rbol virtual de elementos o se desarrolla una biblioteca gr√°fica.  En la mayor√≠a de los casos, la belleza estructural de una soluci√≥n, su confiabilidad y simplicidad resultan ser m√°s importantes, y una peque√±a diferencia en el rendimiento no juega un papel importante (las operaciones con elementos DOM requerir√°n muchos m√°s recursos). <br><br>  En conclusi√≥n, vale la pena se√±alar que los tipos de composici√≥n considerados no son √∫nicos y mutuamente excluyentes.  La delegaci√≥n se puede implementar mediante la agregaci√≥n y la herencia de clases mediante la delegaci√≥n (como se hace en JavaScript).  En esencia, cualquier combinaci√≥n de objetos ser√° una forma u otra de composici√≥n y, en √∫ltima instancia, solo importa la simplicidad y flexibilidad de la soluci√≥n resultante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438404/">https://habr.com/ru/post/438404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438394/index.html">Yii 2.0.16</a></li>
<li><a href="../438396/index.html">¬øPor qu√© deber√≠as pensar en la programaci√≥n funcional?</a></li>
<li><a href="../438398/index.html">C√≥mo lanc√© Keras en C ++</a></li>
<li><a href="../438400/index.html">Cient√≠ficos israel√≠es han desarrollado un tratamiento universal contra el c√°ncer.</a></li>
<li><a href="../438402/index.html">Neutralinojs: ¬øqu√© eres? O forma UNIX donde no esperaste</a></li>
<li><a href="../438406/index.html">ReactJS + MobX - Experiencia DI</a></li>
<li><a href="../438408/index.html">Nubes y pa√≠ses: caracter√≠sticas nacionales del mercado de nubes</a></li>
<li><a href="../438412/index.html">An√°lisis de 112654 tareas de prueba y tendencias en el mercado laboral de programadores en 2019</a></li>
<li><a href="../438414/index.html">Civilizaci√≥n de primavera, 3/5</a></li>
<li><a href="../438416/index.html">Sobre las hormonas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>