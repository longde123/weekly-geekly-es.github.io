<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¶ğŸ» ğŸ¤²ğŸ¼ ğŸ˜• Benchmarking Emely ğŸ¤« ğŸ™‡ğŸ¼ ğŸ’†ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ide utama 


 Banyak buku, artikel, dan tutorial telah ditulis tentang aplikasi pembandingan, mesin, dan berbagai sistem perangkat lunak. 


 Inilah y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benchmarking Emely</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449390/"><h1 id="osnovnaya-zadumka">  Ide utama </h1><br><p>  Banyak buku, artikel, dan tutorial telah ditulis tentang aplikasi pembandingan, mesin, dan berbagai sistem perangkat lunak. </p><br><p>  Inilah yang diberikan Wikipedia lama kepada kami tentang hal ini: </p><br><blockquote>  Uji kinerja, tolok ukur (tolok ukur bahasa Inggris) - tugas kontrol yang diperlukan untuk menentukan karakteristik kinerja komparatif dari sistem komputer. </blockquote><p>  Tetapi bagaimana jika kita sampai pada masalah pembandingan mesin game sedikit dari sisi lain?  Semua mesin game dan SDK untuk pengembangan game (dan tidak hanya) sering mengiklankan diri mereka sebagai alat yang sangat intuitif dan mudah dicerna.  Kami menjual kesederhanaan untuk dipelajari, kurva pembelajaran dan entri yang luar biasa, contoh-contoh ringan dan indah ditampilkan, di mana satu layar kode, ketika diluncurkan, menciptakan semacam keajaiban yang luar biasa.  Jadi, dalam persiapan untuk acara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ludum Dare yang</a> akan datang, saya sekali lagi memutuskan untuk melihat-lihat dan melihat apa yang "pasar" tawarkan kepada Emele sederhana - seseorang yang telah berada di game dev selama seminggu tanpa satu tahun.  Yaitu, salah satu kelompok orang-orang dari CA yang menjual kualitas-kualitas luar biasa dari kecernaan mesin yang mudah. </p><br><p><img src="https://habrastorage.org/webt/ke/mu/zr/kemuzrdhuns3k-oyijzd6kvhkxu.png" alt="Peter Griffin, seperti yang kita pikirkan, mesin permainan apa yang harus diambil untuk pengembangan"></p><a name="habracut"></a><br><p>  Bagaimana jika kita ... mencoba mengukur diri kita sendiri ketika bekerja dengan berbagai mesin untuk menulis game?  Ya, ya, artinya produktivitas mereka.  Secara harfiah, ambil beberapa dari mereka, mengunci diri di gua dengan laptop, Internet, dan stopwatch dan tulis semua hasil kami dalam tablet yang rapi, dan kemudian coba buat beberapa kesimpulan.  Pada saat yang sama, kami perhatikan bahwa saya menyukainya, yang mengejutkan atau tegang saat bekerja dengan satu atau beberapa mesin lainnya. </p><br><h1 id="pro-benchmark">  Tentang tolok ukur </h1><br><p>  Jadi, benda uji adalah tiga mesin game.  Di sini mungkin layak untuk sedikit banyak secara formal (sebisa mungkin) menggambarkan "konfigurasi" Anda (ya, seperti dalam kasus hasil benchmark biasa, mereka menulis konfigurasi besi, di mana mereka menjalankan, deskripsi benchmark, dan sebagainya). </p><br><h1 id="konfiguraciya-ili-o-sebe">  "Konfigurasi" atau Tentang Saya </h1><br><p>  Saya adalah pengembang Java.  Pengalaman pengembangan industri 5+ tahun.  Juga dalam karya saya menulis sedikit di JavaScript, Lua (benar-benar, sedikit), shell.  Pendidikan teknis yang lebih tinggi.  Saya tidak mengikuti kursus desain, saya tidak belajar desain game, saya hanya penggemar berat dari berbagai game PC.  Tahun lalu dia tertarik membuat game komputer yang paling sederhana. </p><br><h1 id="pro-zadachu">  Tentang tugas </h1><br><p>  Sebuah proyek uji klon gim Doodle Jump dipilih.  Saya yakin banyak orang tahu atau telah memainkannya, ini adalah game yang sangat keren dan dikembangkan dengan sangat baik untuk Android. </p><br><p><img src="https://habrastorage.org/webt/gh/7c/t2/gh7ct2uueypr-xwublm6wbpvo0m.png" alt="Game Doodle Jump Asli"></p><br><p>  Peraturannya adalah sebagai berikut: </p><br><ol><li>  Setiap mesin memiliki waktu <strong>4</strong> jam.  Ini termasuk belajar, berkenalan, mengupil, mencoba menulis prototipe, men-debug game, secara umum, siklus penuh pembuatan game. </li><li>  Setiap setengah jam, dalam waktu istirahat singkat, saya akan mencoba memperbaiki apa yang telah dilakukan untuk memperbaiki pekerjaan saya, untuk menjabarkan rencana kerja selanjutnya, membuat catatan, mencatat, dan sebagainya. </li><li>  Sebelum memulai pengujian setiap engine, kami akan mencoba menguraikan proyek game menjadi elemen-elemen penyusunnya untuk menetapkan unit konvensional pada mereka.  Dengan demikian, kami mengukur "produktivitas" pengembang game kami untuk setiap engine di burung beo dan dapat membandingkan hasilnya bukan dengan kata-kata, tetapi setidaknya dalam beberapa angka. </li></ol><br><h1 id="dekompoziciya-igry-na-sostavlyayuschie">  Dekomposisi permainan menjadi komponen-komponen </h1><br><p>  Dalam bentuk yang sangat abstrak dan tingkat atas, saya melihat sendiri komponen-komponen permainan seperti ini: </p><br><ol><li>  Pemain (sprite, perilaku lompat, reaksi terhadap tombol yang ditekan) </li><li>  Objek tingkat: platform, musuh, dll. </li><li>  Fisika: kecepatan lompat pemain, akselerasi jatuh bebas, platform seharusnya <strong>hanya</strong> menangani tabrakan <strong>jika mereka melompat dari atas dan membiarkan pemain melewatinya</strong> jika ia melewatinya dari bagian bawah platform. </li><li>  Generasi level prosedural: inisialisasi dan penambahan level (ke tempat sewenang-wenang, tetapi dengan aturan dan batasan tertentu) dengan cepat dari platform dan musuh baru, menciptakan situasi permainan yang memikat bagi pemain </li><li>  "Kamera" yang mengikuti pemain saat dia naik ke atas.  Kamera harus menjaga agar visibilitas pemain terhadap pemain dan secara bertahap "terpental" dengannya, menampilkan platform baru yang muncul di area render (dalam visibilitas kamera) </li><li> Mekanisme pemicu <code>Game Over</code> .  Seorang pemain kalah jika dia mencapai tepi bawah area yang terlihat (setelah dia melompat setidaknya sekali) </li><li>  Mencetak pemain.  Kami hanya akan memperbarui penghitung tinggi pemain.  Kami akan memperbarui konter sesuai dengan platform terakhir yang dicapai (platform yang ia tolak terakhir kali) </li><li>  <code>HUD</code> : kemajuan tampilan pemain.  Tampilan tinggi. </li></ol><br><p>  Untuk kesederhanaan, kami menetapkan setiap komponen satu poin dari unit parrot kami.  Total maksimum - mis.  Versi yang dapat dimainkan penuh dari proyek ini adalah <strong>8</strong> poin. </p><br><p>  Di bawah ini adalah aset yang digunakan pada layar.  Ini digambar tangan (saya bukan seorang seniman, seperti yang Anda lihat) karakter dan platform sprite dengan dimensi format 64x64, * .png. </p><br><p><img src="https://habrastorage.org/webt/ap/6q/6s/ap6q6s-9nmbpn5rei2qivwdgyvq.png" alt="Karakter memantul kami"></p><br><p><img src="https://habrastorage.org/webt/4i/t9/ax/4it9axv7jqhakv3phhewgb3350e.png" alt="Platform terbaik di dunia"></p><br><p>  Dan juga berikan beberapa diagram alur: </p><br><ol><li>  Dengan demikian, perhitungan "gender" untuk pemain akan dilaksanakan (ingat, dengan lompatan ke atas, layar bergeser, dan keberangkatan di tepi layar berarti selokan) <br><img src="https://habrastorage.org/webt/0i/jx/vv/0ijxvvvvj1ag_jjuk87ao5lx16e.png"></li><li>  Maka kami menghitung dan memperbarui kecepatan vertikal ( <code>y_velocity</code> ) dan koordinat <code>y</code> pemain dengan setiap ketukan, hal ini dipengaruhi oleh dua faktor: percepatan gravitasi ( <code>GRAVITY</code> ) dan platform, setelah mencapai yang mana, pemain ditolak dengan kecepatan yang sepenuhnya pulih. <br><img src="https://habrastorage.org/webt/ty/bs/br/tybsbrzi5persd_i-vyggqrzs5y.png"></li><li>  Algoritma untuk menghitung kecepatan horizontal, seperti mekanisme lainnya, tidak dimasukkan dalam ruang lingkup artikel. </li></ol><br><p>  Ngomong-ngomong, saya masih memiliki pertanyaan: </p><br><ol><li>  Bagaimana bisa lebih baik menerapkan pelacakan kamera untuk pemain?  Sejauh ini, itu akan dikaitkan dengan koordinat vertikal dari platform tertinggi terakhir yang dapat dijangkau pemain, sehingga platform ini berada di bagian bawah area yang terlihat, dan kami melihat potongan-potongan baru dari level yang dihasilkan. </li><li>  Algoritma generasi platform itu sendiri.  Menurut ide saya, ini akan menjadi semacam "pabrik platform", yang di setiap siklus siklus permainan ( <code>dt</code> ) mengetahui platform tertinggi yang ada di level dan dengan nilai ketinggian acak (ambang tertentu, tidak lebih dari ketinggian lompatan pemain, tetapi juga tidak kurang dari sebagian kecil dari ketinggiannya, sehingga platform tidak menempel satu sama lain) menambahkan platform baru ke level ketika pemain telah maju.  Pertanyaan meningkatkan kompleksitas permainan juga menarik di sini, bagaimana cara menghasilkan platform ini harus berubah. </li></ol><br><p>  Saya akan sangat senang dengan ide-ide Anda, hacks kehidupan dan saran dalam komentar dan PM tentang dua masalah desain-game ini. </p><br><h1 id="pro-dvizhki">  Tentang mesin </h1><br><p>  Tiga kandidat dipilih dengan fitur yang sangat menarik bagi saya.  Jadi, parameter yang akan berguna untuk diingat ketika menganalisis hasil tes Anda dirangkum di bawah ini. </p><br><div class="scrollable-table"><table><thead><tr><th>  Mesin </th><th>  YaP </th><th>  Pengalaman dalam mesin (0 - tidak, 1 - ada pengalaman dan beberapa permainan tertulis sederhana, 2 - mesin dikuasai sepanjang dan di seluruh </th><th>  Pengalaman di YP (0 - tidak, 1 - ada pengalaman dan pengetahuan dan pemahaman yang baik tentang sintaksis, idiom bahasa, 2 - pro untuk YP ini </th></tr></thead><tbody><tr><td>  Defold </td><td>  Lua </td><td>  0 </td><td>  1 </td></tr><tr><td>  Love2d </td><td>  Lua </td><td>  1 </td><td>  1 </td></tr><tr><td>  FXGL </td><td>  Jawa </td><td>  0 </td><td>  2 </td></tr></tbody></table></div><br><p>  Jadi, kami melihat bahwa pemilihannya cukup menarik.  Sangat menarik karena kami akan berurusan dengan kombinasi berbeda dari kualitas dan karakteristik mesin kami.  Dan mari kita lihat apa yang terselesaikan pada akhirnya: mesin di mana saya sudah mendapatkan tangan saya sedikit, YP dipompa atau mesin yang benar-benar segar dan baru bagi saya dengan chip yang menjanjikan, tetapi tidak dikuasai sama sekali, dan juga tidak dalam bahasa pengembangan utama saya. </p><br><h1 id="pochemu-ne-unityunreal-engineother-awesome-engine-etc">  Kenapa tidak Unity / Unreal Engine / Other Awesome Engine dll? </h1><br><p>  Banyak yang mungkin bertanya-tanya mengapa, saya tidak mengikuti cara standar, dan tidak menggunakan flagships paling umum di zaman kita: Unity atau Unreal Engine?  Saya akan merumuskan pikiran saya dengan cara ini: Saya ingin membangun gim yang sangat sederhana, minimalis dan mungil.  Dengan beberapa elemen gim yang membentuk mekanik gim, satu karakter yang dapat dimainkan, generasi level yang sederhana dan tanpa efek khusus atau efek khusus yang sangat konvensional, seperti pada mesin arcade lama.  Jadi, secara kiasan, tugas saya adalah menggambar lingkaran merah di kotak hitam, dan untuk ini saya diundang untuk mengambil <code>Photoshop</code> .  Sederhananya, serangkaian fitur, mode, dan kemampuan <code>Unity</code> membuatku takut.  Pada tahap ini, saya ingin memahami setiap detail permainan saya. </p><br><p><img src="https://habrastorage.org/webt/9p/fv/tx/9pfvtxikfd6mmhsfp_gwqx0_g0u.jpeg" alt="Memilih mesin pengembangan game"></p><br><p>  Ini paling baik dilakukan oleh mesin sederhana dan kecil, dengan serangkaian fitur terbatas, mungkin tidak dengan penyetelan dan ekosistem terbaik, tetapi kesederhanaan dan keterbatasan juga memiliki keindahannya sendiri.  Dengan hanya seperangkat alat terbatas - dan dalam kasus Love2D, alat Anda adalah kode Anda dan tidak lebih, Anda fokus pada kipas, menulis sesuatu yang keren, menghidupkan kembali karakter atau lingkungan pemain.  Mesin yang lebih rumit memperluas pilihan Anda, dan menulis kode dengan lancar mengalir ke banyak hal: menulis skrip (kode), menghubungkan skrip, memetakan aset, menambahkan konfigurasi, mendefinisikan ulang konfigurasi, mencampur plugin pihak ketiga, menulis skrip dan konfigurasi untuk plugin pihak ketiga, beberapa kali klik pada puluhan dan puluhan dialog dan jendela ... Anggap saja untuk saat ini saya masih takut dengan mesin pengembangan game yang begitu canggih dan kuat.  Ya, saya tidak ingin mengingat C # / JS / C ++ lagi dan menulisnya. </p><br><p>  Saya akan merangkum motivasi saya ketika memilih mesin dengan tautan ke video ini, di mana bagi saya tampaknya penulis benar-benar menghapus dari bahasa saya apa yang saya coba rumuskan dengan kata-kata untuk diri sendiri dan orang lain selama ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.youtube.com/watch ? v = JH8xwNOQ0TM</a> </p><br><h1 id="defold">  Defold </h1><br><p>  <code>Defold</code> adalah mesin lintas platform dari King. <br>  Platform yang didukung: </p><br><ul><li>  Html5 (WebGl) </li><li>  Android 2.3 (API level 9) + </li><li>  iOS 8.0+ </li><li>  Windows Vista + </li><li>  OSX 10.7+ </li><li>  Linux </li></ul><br><p>  Fakta yang aneh adalah bahwa King dimiliki oleh <strong>Activision Blizzard</strong> . <br>  Di mesin, saya tertarik dengan bahasa pengembangan - <code>Lua</code> , dukungan untuk banyak platform untuk pembuatan game, serta distribusi <code>IDE</code> lintas-platform mereka sendiri - dapat diinstal di Linux juga.  Ini menyuap saya ketika memilih antara <code>Defold</code> vs.  <code>Corona SDK</code> . <br>  Dan di bawah ini adalah log dari apa yang dilakukan pada titik kontrol: </p><br><div class="scrollable-table"><table><thead><tr><th>  Tidak. </th><th>  Waktu </th><th>  Komentar </th></tr></thead><tbody><tr><td>  1 </td><td>  30 m </td><td>  Kami meninjau 1 tutorial, beberapa deskripsi pengantar editor, menguji proyek uji (meng-encode handler klik, membaca dok proyek pelatihan) </td></tr><tr><td>  2 </td><td>  1 jam </td><td>  Menambahkan beberapa modifikasi pada proyek pelatihan tes.  Mungkin sudah waktunya untuk mengambil proyek Anda dan mencoba menerapkan setidaknya sesuatu di sana? </td></tr><tr><td>  3 </td><td>  1 jam 30 m </td><td>  Buatan manusia melompat (sprite with behaviour).  Tidak buruk!  :) </td></tr><tr><td>  4 </td><td>  2 jam </td><td>  Saatnya menambahkan kontrol.  Dan juga sudah waktunya menambahkan platform dan tabrakan?  Menambahkan manajemen dan platform, tetapi sayangnya, saya tidak berhasil menangani tabrakan .. </td></tr><tr><td>  5 </td><td>  2j 30m </td><td>  Tabrakan!  Seorang pria perlu tahu bagaimana cara melompat ke platform dan kemudian mendorongnya lebih jauh.  Baiklah kalau begitu.  Ada konflik, tapi sejauh ini mekanika bekerja bengkok :) </td></tr><tr><td>  6 </td><td>  3j </td><td>  Hore, ada konflik dan tampaknya benar.  Saya mencoba menempatkan beberapa salinan platform. </td></tr><tr><td>  7 </td><td>  3j 30m </td><td>  Sekarang kita harus berpikir tentang kamera mengambang yang melayang ketika pemain melompat ke platform baru yang lebih tinggi.  Saya tidak maju, tetapi hanya terkubur dalam seluk-beluk mengacaukan kamera ... Sepertinya mudah dan tidak mudah untuk memasang kamera. </td></tr><tr><td>  8 </td><td>  4 jam </td><td>  HUD.  Menampilkan ketinggian pemain saat ini di atas lantai. </td></tr></tbody></table></div><br><p>  Di bawah ini, di spoiler, ada beberapa animasi gif yang menunjukkan perkembangan waktu: </p><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><p>  <strong>0-1jam</strong> <br><img src="https://habrastorage.org/webt/p4/q7/wd/p4q7wdhlra-wxbgwmcdowldjuqm.gif" alt="0-1jam"><br>  <strong>1-2 jam</strong> <br><img src="https://habrastorage.org/webt/ag/cx/3j/agcx3j6vk7jpmqac-eo8lnvfv8i.gif" alt="1-2 jam"><br>  <strong>4 jam</strong> <br><img src="https://habrastorage.org/webt/ai/k3/4-/aik34-vbwqrioxv1nqrki55tpqi.gif" alt="4 jam"></p></div></div><br><p>  Hasil, poin tolok ukur: </p><br><ol><li>  Pemain (sprite, perilaku lompat, reaksi terhadap tombol yang ditekan) <code>(V) Yes</code> </li><li>  Objek tingkat: platform, musuh, dll. <code>(V) Yes</code> </li><li>  Fisika: kecepatan lompat pemain, akselerasi jatuh bebas, platform seharusnya hanya menangani tabrakan jika dilompati dari atas dan membiarkan pemain melewatinya jika ia melewatinya dari bagian bawah platform. <code>(V) Yes</code> </li><li>  Generasi level prosedural: inisialisasi dan menambah level (ke tempat sewenang-wenang, tetapi dengan aturan dan batasan tertentu) dengan cepat menerbangkan platform dan musuh baru, menciptakan situasi permainan yang memikat bagi pemain <code>(X) No</code> </li><li>  "Kamera" yang mengikuti pemain saat dia naik ke atas.  Kamera harus menjaga pemain dalam bidang tampilan untuk pemain dan secara bertahap "bangkit" dengannya, menampilkan platform baru yang muncul di area render (di bidang pandang kamera) <code>(X) No</code> </li><li>  Mekanisme pemicu Game Over.  Seorang pemain kalah jika dia mencapai tepi bawah area yang terlihat (setelah dia melompat setidaknya sekali) <code>(X) No</code> </li><li>  Mencetak pemain.  Kami hanya akan memperbarui penghitung tinggi pemain.  Kami akan memperbarui penghitung sesuai dengan platform terakhir yang dicapai (platform yang ia tolak terakhir kali) <code>(V) Yes</code> </li><li>  HUD: kemajuan tampilan pemain.  Tampilan tinggi.  Secara opsional, tampaknya tidak ada indikator kemajuan dalam game asli. <code>(V) Yes</code> </li></ol><br><p>  <strong>Skor Benchmark: 5/8</strong> </p><br><h1 id="love2d">  Love2d </h1><br><p>  Ini adalah mesin yang sangat minimalis, tetapi cukup kuat dan fleksibel untuk membuat prototipe.  Secara umum, dengan ketangkasan karena, bahkan cocok untuk menerbitkan game penuh ke pasar.  Ada beberapa contoh inspirasional yang baik.  Begitu saja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Satu</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dua</a> . </p><br><p>  Secara umum, untuk mesin ini saya merekomendasikan serangkaian tutorial yang sangat cocok dari Habr, yang memacu saya dan memberikan dorongan kuat untuk pengembangan mesin ini, saya hanya akan memberikan tautan ke bagian pertama, maka akan mungkin untuk mendapatkan dari itu ke bagian yang tersisa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat game di Lua dan LÃ–VE - 1</a> </p><br><p>  Jadi, di bawah ini adalah log dari apa yang dilakukan di pos pemeriksaan: </p><br><div class="scrollable-table"><table><thead><tr><th>  Tidak. </th><th>  Waktu </th><th>  Komentar </th></tr></thead><tbody><tr><td>  1 </td><td>  30 m </td><td>  Menyiapkan proyek, membuat penangan dasar, menciptakan kelas pemain (kerangka kerja dengan logika lompat dan gravitasi masih tidak berfungsi) </td></tr><tr><td>  2 </td><td>  1 jam </td><td>  Sebuah pabrik dibuat, menggambarkan platform, seorang pria melompat dibuat.  Hore! </td></tr><tr><td>  3 </td><td>  1 jam 30 m </td><td>  Mencoba mengacaukan pustaka hardoncollider.  Frustrasi terkait dengan kenyataan bahwa dermaga di situs web resmi ditulis sesuai dengan versi yang sudah ketinggalan zaman, mencari dermaga saat ini, mengacaukan tabrakan.  Belum ada tabrakan yang diterapkan </td></tr><tr><td>  4 </td><td>  2 jam </td><td>  Ada konflik, tetapi mereka adalah kurva :( </td></tr><tr><td>  5 </td><td>  2j 30m </td><td>  Tabrakan dibuat, ada beberapa kelemahan, tetapi secara umum - norma.  Coba kencangkan kamera melacak pemain, mengikuti lompatan ke atas.  Belum terlalu sukses .. </td></tr><tr><td>  6 </td><td>  3j </td><td>  Ada generasi platform, tetapi tabrakan masih buggy dan lumpuh :( </td></tr><tr><td>  7 </td><td>  3j 30m </td><td>  Definisi Game Over diterapkan - penentuan bahwa seorang pemain telah jatuh di tepi bawah area yang terlihat.  Penilaian dilaksanakan - yaitu  ditampilkan di sudut kiri atas ketinggian yang diambil terakhir </td></tr><tr><td>  8 </td><td>  4 jam </td><td>  Lihat di bawah tabel untuk mengetahui apa yang telah dicapai setelah 4 jam mengembangkan klon Doodle Jump pada mesin Love2d. </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/webt/oo/zk/si/oozksiscybfmanckw7llj6sohjy.gif" alt="Versi terakhir game di Love2D dalam 4 jam"></p><br><p>  Hitung "performa" mesin: </p><br><ol><li>  Pemain (sprite, perilaku lompat, reaksi terhadap tombol yang ditekan) <code>(V) Yes</code> </li><li>  Objek tingkat: platform, musuh, dll. <code>(V) Yes</code> </li><li>  Fisika: kecepatan lompat pemain, akselerasi jatuh bebas, platform seharusnya hanya menangani tabrakan jika mereka melompat dari atas dan membiarkan pemain melewatinya jika ia melewatinya dari bagian bawah platform. <br>  <code>(V) Yes</code> / <code>(X) No</code> // * Diimplementasikan, tetapi tidak cukup sempurna, dengan kekurangan yang signifikan.  Saya akan menempatkan di sini <strong>0,5</strong> poin untuk menyelesaikan item. </li><li>  Generasi level prosedural: inisialisasi dan penambahan level (ke tempat sewenang-wenang, tetapi dengan aturan dan batasan tertentu) dengan cepat dari platform dan musuh baru, menciptakan situasi permainan yang memikat bagi pemain <code>(V) Yes</code> </li><li>  "Kamera" yang mengikuti pemain saat dia naik ke atas.  Kamera harus menjaga visibilitas pemain terhadap pemain dan secara bertahap "memantul" bersamanya, menampilkan platform baru yang muncul di area render (dalam visibilitas kamera) <code>(V) Yes</code> </li><li>  Mekanisme pemicu Game Over.  Seorang pemain kalah jika dia mencapai tepi bawah area yang terlihat (setelah dia melompat setidaknya sekali) <code>(V) Yes</code> </li><li>  Mencetak pemain.  Kami hanya akan memperbarui penghitung tinggi pemain.  Kami akan memperbarui penghitung sesuai dengan platform terakhir yang dicapai (platform yang ia tolak terakhir kali) <code>(V) Yes</code> </li><li>  HUD: kemajuan tampilan pemain.  Tampilan tinggi.  Secara opsional, tampaknya tidak ada indikator kemajuan dalam game asli. <code>(V) Yes</code> </li></ol><br><p>  <strong>Skor Benchmark:</strong> <strong>7.5 / 8</strong> </p><br><h1 id="java">  Jawa </h1><br><p>  Mungkin langkah logis dan logis adalah untuk melihat lebih dekat pada mesin, di mana bahasa pengembangan adalah di mana saya memiliki pengalaman dan ketangkasan yang paling, bukan?  Sebenarnya, intuisi dan beberapa sensasi internal membuat saya sedikit dari ini.  Faktanya adalah sebagai seorang siswa, saya entah bagaimana menyaksikan teman sekelas saya dengan mesin <code>jMonkey</code> .  Perkakas, bekerja dengan mesin, dokumentasi, semua ini bersama-sama menciptakan semacam gambar yang tidak terlalu menyenangkan.  Sepertinya mesin itu sama sekali tidak memberi Anda kesempatan untuk berteman dengannya, sangat banyak penggunaannya yang tampak tidak menyenangkan. </p><br><p>  Namun demikian, saya memutuskan untuk melihat apa yang tersedia hari ini, dan saya hanya melihat ke arah mesin yang hanya menjamin <code>2D</code> , saya tidak peduli tentang dukungan <code>3D</code> .  Salah satu mesinnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lightweight Java Game Library 3</a> , memiliki namanya dan kata pengantar <code>Lightweight</code> .  Ironisnya, contoh-contoh dasar paling sederhana di halaman utama, beberapa layar panjangnya, hanya ditakuti. </p><br><p>  Ya, tentu saja, <code>Java</code> sangat verbose, apa yang Anda inginkan, katamu.  Tetapi saya tahu bahwa Anda dapat menulis hal-hal yang sangat ringkas dan sangat ekspresif.  Saya melihat API yang indah dan ringkas. <br>  Dan pada akhirnya, pilihan jatuh pada <code>FXGL</code> .  Pada awalnya, saya tidak memiliki antusiasme dan kegembiraan yang menyenangkan, yang terjadi sebelum awal pengembangan beberapa hal atau perpustakaan yang menarik.  Tapi sudah dari contoh pertama dan halaman singkat dokumentasi dan contoh, mesin ini sangat mengejutkan saya.  Semuanya logis, dapat dimengerti dan konsisten dalam pendekatan dan API yang ia usulkan.  Ini jelas membantu Anda membangun loop yang jelas dan fleksibel untuk gim, logika handler, <code>HUD</code> , <code>AI</code> , tabrakan, dan elemen lainnya. </p><br><h2 id="interesnye-momenty-i-fishki-fxgl">  Momen menarik dan chip FXGL: </h2><br><ul><li><p>  Seperti namanya, untuk bagian visual, mesin menggunakan JavaFX API ( <code>JavaFX</code> digunakan sebagai kerangka grafis) dengan semua barang dan anti-barangnya untuk rendering dan tata letak.  Secara umum, saya pikir ini adalah keputusan yang bagus dan cukup masuk akal.  Dengan demikian, penulis menghindari sejumlah masalah (tidak perlu menerapkan dan memelihara komponen rendering Anda, Anda dapat menggunakan solusi yang disempurnakan dari ekosistem <code>Java</code> ).  Inilah yang penulis sendiri katakan dalam salah satu tutorial pertamanya, dan saya sangat menyukai frasa ini: </p><br><blockquote>  "Untuk sebagian besar objek UI, kami cukup menggunakan objek JavaFX, karena tidak perlu menemukan kembali roda." </blockquote><p>  Tetapi secara umum, tentu saja, Anda mendapatkan banyak fitur dan beberapa kerugian <code>JavaFX</code> , juga (saya tidak tahu banyak tentang detail), tetapi sejauh yang saya tahu, ada beberapa pembatasan lisensi pada penggunaan <code>JavaFX</code> dalam proyek Anda, dan tampaknya <code>JavaFX</code> pergi dan hanya akan berjalan dalam pengiriman <code>JDK</code> terbatas ( <code>Oracle</code> , mungkin beberapa lagi). </p><br></li><li><p>  Sebuah proyek uji, miring dari repositori, atas dasar di mana saya mulai memahat permainan, silakan meletakkan log di <code>logs/</code> proyek setelah setiap permainan dimulai.  Ini sangat mudah, Anda dapat langsung melihat keluar dari kotak debug-informasi, sangat berguna untuk diagnosis, memahami di mana Anda mengacau jika Anda tiba-tiba bertemu dengan plug dalam studi mesin. </p><br></li><li><p>  Juga (tampaknya sekali lagi, dengan pengaturan dasar) permainan menyediakan menu pop-up dengan menekan tombol <code>Esc</code> .  Juga bonus yang bagus, saya harap ini disesuaikan atau setidaknya dinonaktifkan oleh kode atau konfigurasi. </p><br></li><li><p>  <strong>Debag</strong> akhirnya bekerja di <strong>sini</strong> !  Akhirnya!  Dalam <code>Love2D</code> untuk sedikitnya, tidak nyaman dan tidak menyenangkan. </p><br><h2 id="log-razrabotki">  Log pengembangan </h2><br><p>  Di bawah ini adalah ringkasan singkat dari kemajuan saya, di mana saya secara singkat mencatat apa yang dicapai setelah interval 30 menit, serta beberapa pemikiran dan komentar saya.  Lihatlah log kesadaran saya dalam 4 jam ini! </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Tidak. </th><th>  Waktu </th><th>  Komentar </th></tr></thead><tbody><tr><td>  1 </td><td>  30 m </td><td>  Mempelajari beberapa tutorial.  API Base dan struktur loop game.  Mempelajari cara menggambar sprite, memindahkan objek, menampilkan dan memperbarui HUD.  Mulai memasukkan tabrakan ke dalam permainan. </td></tr><tr><td>  2 </td><td>  1 jam </td><td>  Ada kotak melompat dengan tubuh tabrakan (Bounding Box) dan "mampu mendorong keluar dari lantai" (yaitu ada definisi batas bawah layar) </td></tr><tr><td>  3 </td><td>  1 jam 30 m </td><td>  Landasan pabrik platform diletakkan (PlatformFactory.java).  Tampaknya itu bahkan mungkin untuk "menjinakkan tabrakan" dan berhasil mencapai tolakan karakter dari platform.  Ini tidak diragukan lagi sukses untuk mesin baru dan dengan pengalaman dalam membaca setengah tutorial GitHubWiki di tempat. </td></tr><tr><td>  4 </td><td>  2 jam </td><td>  Tabrakan sedikit selesai dengan platform, tetapi masih buggy dan tidak sempurna.  Cukup cepat saya berhasil membuat pelacakan dengan kamera, sekali lagi, ini juga sedikit tajam dan kikuk, tetapi kelancaran memoles akan tetap berada di luar lingkup benchmark dan pengalaman dengan FXGL pada khususnya.  Juga, tidak sulit untuk menambahkan kode pabrik pembuatan platform sehingga platform dihasilkan pada jarak acak yang dapat diterima dari platform yang dihasilkan terakhir.  Dan kode yang menghasilkannya saat pemain berkembang juga diintegrasikan ke dalam siklus permainan utama.  Kemajuan yang cukup bagus, seperti untuk saya. </td></tr><tr><td>  5 </td><td>  2j 30m </td><td>  Baiklah kalau begitu.  Pada titik ini, hampir seluruh permainan sudah siap.  Semua komponen dasar diimplementasikan.  Dan bahkan mekanisme yang benar untuk mendorong pemain menjauh dari platform (wow!) Dipoles dan diselesaikan dengan file, yang tidak dicapai dengan sempurna dengan dua mesin sebelumnya.  Mungkin, akumulasi pengalaman dan intuisi sudah mempengaruhi di sini, saya tidak berpendapat.  Selain itu, pengacak untuk menghitung posisi untuk platform baru sedikit tercengang, karena dengan parameter sebelumnya platform yang benar-benar tidak dapat diakses muncul, yang mengarah ke Game Over. </td></tr><tr><td>  6 </td><td>  3j </td><td>  Fitur kunci lain dari Lompatan Doodle telah diterapkan (yang berada di luar lingkup tugas utama) - jika pemain melompati tepi kiri atau kanan level, ia muncul di sisi lain dengan tetap mempertahankan kecepatannya (impuls).  Gameplay ini adalah komponen yang sangat penting dari Doodle Jump;  apa yang membuat game beragam dan menarik di antara elemen-elemen lainnya.  Juga, fungsi reset game dengan cepat digulung dan kode musuh dan AI musuh digulung.  Sejauh ini, ini bukan di dalam game, tetapi di tingkat prototipe. </td></tr><tr><td>  7 </td><td>  3j 30m </td><td>  Algoritma untuk generasi acak musuh di tingkat diimplementasikan.  Ini tidak sempurna sama sekali, tetapi sudah menambah unsur kesenangan dan tantangan bagi pemain. AI ,         â€”    -  ,   ,      .      . </td></tr><tr><td>  8 </td><td> 4h </td><td>    .      â€”    .  ,       .   ,     ,           <code>Space</code> . </td></tr></tbody></table></div><br><p>        GIF-    ,    . </p><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><p> <em>0-1h</em> <br><img src="https://habrastorage.org/webt/ri/v0/mg/riv0mgwefn6xb7rxlkujgxd4vhy.gif" alt="*0-1h*"><br> <em>1h-1h 30m</em> <br><img src="https://habrastorage.org/webt/1o/wc/m-/1owcm-hu43iasjopd5zt5e4rs2m.gif" alt="*1h-1h 30m*"><br> <em>2h 30m (      )</em> <br><img src="https://habrastorage.org/webt/mz/cr/vg/mzcrvgyflbw08px8j76g4gnud14.gif" alt="2h 30m"><br> <em>3h 30m</em> <br><img src="https://habrastorage.org/webt/qh/wk/_9/qhwk_9zk522fbvcyhigxemlicw4.gif" alt="3h 30m"><br> <em>4h</em> <br><img src="https://habrastorage.org/webt/ml/jq/mt/mljqmt9wumswmmtyelzka9jdpcu.gif" alt="*4h*"></p></div></div><br><p>  "" â€¦  ,     ,   ,          ?    . </p><br><p> <strong>Benchmark Score:</strong> <strong>8</strong> </p><br><h1 id="vyvody-mysli-idei"> , ,  </h1><br><p>        : </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>  </th><th>    (0 â€” , 1 â€”       , 2 â€”      </th><th>    (0 â€” , 1 â€”        ,  , 2 â€”     </th><th> Benchmark Score </th><th>   </th></tr></thead><tbody><tr><td> Defold </td><td> Lua </td><td> 0 </td><td>  1 </td><td> <strong>5/8</strong> </td><td> <strong>166</strong> </td></tr><tr><td> Love2D </td><td> Lua </td><td>  1 </td><td>  1 </td><td> 7.5/8 </td><td> 701 </td></tr><tr><td> FXGL </td><td> Java </td><td> 0 </td><td>  <strong>2</strong> </td><td> <strong>8</strong> </td><td> 582 </td></tr></tbody></table></div><br><p> ,     ,         ,       (     ). ,  ,  Java       <code>FXGL</code> ,        ,     <code>Lua</code> ,     .  ,   , . </p><br><p>     : </p><br><ol><li>   <code>FXGL</code>    ?     . <code>Love2D</code>   ,     <code>Defold</code>      ,   ,    ,          ,  <code>Love2D</code>   -  ,              . </li><li>   ,   . ,   .      (, ),      . ,         -  .   ,   ,   ,        ,         .   ,  ,     ,          .       . </li><li>       gif-,     .        .  ,          , ""         ,            . </li></ol><br><h1 id="chto-eto-vsyo-dalo-mne">     ? </h1><br><p> ,   - ,              ? </p><br><p>  Jadi: </p><br><ol><li> ,  .  ,      , , ,     . -      , -      ( <code>Love2D</code> ). </li><li>     -    ,    <code>Love2D</code> ,     .  <code>F to pay respect</code> . </li><li>       .    ,      ,   ,    -       -    ,     ,   (, ,  ) </li><li>    .     <strong>4</strong>    ,       .  - <code>Game Jam</code> ,   . </li><li>  ! ,         ,     - Roadmap  ,     ,      .    (!)      (?)        .      <strong>30</strong>          .     ,                    . ,          ,  ! ,            pet-       <strong>44</strong> - <code>Ludum Dare</code> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449390/">https://habr.com/ru/post/id449390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449380/index.html">Apakah penasihatnya kompeten? Rekomendasi masalah â€œjangan menemukan kembali rodaâ€</a></li>
<li><a href="../id449382/index.html">Penelitian: Media Mengikuti Konten di Saluran Telegram</a></li>
<li><a href="../id449384/index.html">Tes: apakah udalenka cocok untuk Anda (bukan freelance!)?</a></li>
<li><a href="../id449386/index.html">Internet untuk penduduk musim panas. Kami mendapatkan kecepatan maksimum di jaringan 4G. Bagian 1. Memilih router yang tepat</a></li>
<li><a href="../id449388/index.html">Cetak ... Gairah?</a></li>
<li><a href="../id449392/index.html">Mendapatkan statistik untuk semua klien dari Yandex.Direct API berdasarkan hari menggunakan Python</a></li>
<li><a href="../id449398/index.html">Mikhail Larionov, Circles.is: Tentang Karier di Facebook, Kewirausahaan, Pembangunan Komunitas, dan Pemikiran Produk</a></li>
<li><a href="../id449408/index.html">Panel kontrol HMI berbasis HMI Advantech</a></li>
<li><a href="../id449410/index.html">Wawancara: Cepat. Tanya Jawab</a></li>
<li><a href="../id449412/index.html">Apa yang dilakukan komunitas konsumen untuk menghancurkan perangkat lunak open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>