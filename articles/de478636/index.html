<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèª ‚õ©Ô∏è üòº Wie Textcodierungen funktionieren. Woher kommen die "Krokodile"? Die Prinzipien der Kodierung. Verallgemeinerung und detaillierte Analyse üïµüèª üé∑ ‚ú≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel zielt darauf ab, die Prinzipien und Mechanismen der Arbeit von Textcodierungen zusammenzuf√ºhren und zu zerlegen, und diesen Mechanismus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Textcodierungen funktionieren. Woher kommen die "Krokodile"? Die Prinzipien der Kodierung. Verallgemeinerung und detaillierte Analyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478636/">  Dieser Artikel zielt darauf ab, die Prinzipien und Mechanismen der Arbeit von Textcodierungen zusammenzuf√ºhren und zu zerlegen, und diesen Mechanismus im Detail zu zerlegen und zu erkl√§ren.  Es ist n√ºtzlich f√ºr diejenigen, die sich nur grob vorstellen k√∂nnen, was Textcodierungen sind und wie sie funktionieren, wie sie sich voneinander unterscheiden, warum manchmal unlesbare Zeichen erscheinen, welches Codierungsprinzip verschiedene Codierungen haben. <br><br>  Um ein detailliertes Verst√§ndnis f√ºr dieses Problem zu erhalten, m√ºssen Sie mehr als einen Artikel lesen und zusammenstellen und viel Zeit damit verbringen.  In diesem Material ist dies alles zusammengefasst und sollte theoretisch Zeit sparen, und die Analyse hat sich meiner Meinung nach als ziemlich detailliert herausgestellt. <br><br>  Was wird unter der K√ºrzung passieren: das Funktionsprinzip von Einzelbyte-Codierungen (ASCII, Windows-1251 usw.), die Voraussetzungen f√ºr das Erscheinungsbild von Unicode, was ist Unicode, Unicode-Codierungen UTF-8, UTF-16, ihre Unterschiede, grundlegende Merkmale, Kompatibilit√§t und Inkompatibilit√§t verschiedener Codierungen, Prinzipien der Zeichencodierung, praktische Analyse der Codierung und Decodierung. <br><br>  Das Thema Kodierung hat jetzt sicherlich an Relevanz verloren, aber ich denke, es wird nicht √ºberfl√ºssig sein zu wissen, wie sie jetzt funktionieren und wie sie vorher gearbeitet haben. <br><a name="habracut"></a><br><h2>  Unicode-Voraussetzungen </h2><br>  Ich denke, es lohnt sich, von einer Zeit an zu beginnen, in der die Computerisierung noch nicht so weit fortgeschritten war und nur an Dynamik gewann.  Damals glaubten die Entwickler und Standardisierer nicht, dass Computer und das Internet eine solch enorme Popularit√§t und Verbreitung erlangen w√ºrden.  Eigentlich entstand dann das Bed√ºrfnis, den Text zu verschl√ºsseln.  In welcher Form war es notwendig, die Buchstaben im Computer zu speichern, und er (der Computer) versteht nur Einsen und Nullen.  Aus diesem Grund wurde eine Ein-Byte-ASCII-Codierung entwickelt (h√∂chstwahrscheinlich ist dies nicht die erste Codierung, aber die h√§ufigste und indikativste, weshalb wir sie als Referenz betrachten werden).  Wie ist sie?  Jedes Zeichen in dieser Codierung wird mit 8 Bits codiert.  Es ist leicht zu berechnen, dass die Codierung basierend darauf 256 Zeichen enthalten kann (acht Bits, Nullen oder Einsen 2 <sup>8</sup> = 256). <br><br>  Die ersten 7 Bits (128 Zeichen, 2, <sup>7</sup> = 128) in dieser Codierung wurden lateinischen Zeichen, Steuerzeichen (wie Zeilenumbr√ºche, Tabulatoren usw.) und Grammatikzeichen zugewiesen.  Der Rest war den Landessprachen vorbehalten.  Das hei√üt, es stellte sich heraus, dass die ersten 128 Zeichen immer gleich sind. Wenn Sie Ihre Muttersprache codieren m√∂chten, verwenden Sie bitte die verbleibende Kapazit√§t.  Tats√§chlich erschien ein riesiger Zoo nationaler Kodierungen.  Und jetzt k√∂nnen Sie sich vorstellen, wenn ich zum Beispiel in Russland bin und ein Textdokument erstelle, wird es standardm√§√üig in Windows-1251-Codierung (in Windows verwendete russische Codierung) erstellt und an jemanden gesendet, zum Beispiel in den USA.  Sogar die Tatsache, dass mein Gespr√§chspartner Russisch kann, hilft ihm nicht, denn wenn er mein Dokument auf seinem Computer √∂ffnet (im Editor mit der Standardcodierung desselben ASCII), sieht er keine russischen Buchstaben, sondern krakozyabry.  Genauer gesagt werden die Stellen in dem Dokument, die ich in Englisch schreibe, ohne Probleme angezeigt, da die ersten 128 Zeichen der Windows-1251- und ASCII-Codierung gleich sind, aber wo ich den russischen Text geschrieben habe, wenn er nicht die richtige Codierung in seinem Editor angibt, in Form eines Krokodils. <br><br>  Ich denke, das Problem mit den nationalen Kodierungen ist verst√§ndlich.  Tats√§chlich gibt es viele dieser nationalen Kodierungen, und das Internet ist sehr weit verbreitet, und jeder wollte in seiner eigenen Sprache schreiben und wollte nicht, dass seine Sprache wie krummes Haar aussieht.  Es gab zwei M√∂glichkeiten, f√ºr jede Seite der Codierung einen gemeinsamen Wert f√ºr alle Zeichen in der Weltsymboltabelle anzugeben.  Die zweite Option hat gewonnen, also haben wir eine Unicode-Zeichentabelle erstellt. <br><br><h3>  ASCII kleine Werkstatt </h3><br>  Es mag elementar erscheinen, aber da ich mich entschlossen habe, alles im Detail zu erkl√§ren, ist dies notwendig. <br><br>  Hier ist die ASCII-Zeichentabelle: <br><br><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"><br><br>  Hier haben wir 3 Spalten: <br><br><ul><li>  Dezimalzahl </li><li>  Zeichennummer im hexadezimalen Format </li><li>  Darstellung des Symbols selbst. </li></ul><br>  Kodieren Sie also die Zeichenfolge "ok" (ASCII).  Das Zeichen "o" (dt.) Hat eine Dezimalposition von 111 und eine Hexadezimalposition von <i>6F</i> .  <code><b>01101111</b></code> dies in ein bin√§res System √ºbersetzen - <code><b>01101111</b></code> .  Das Symbol "k" (dt.) - Position 107 in dezimaler und <i>6B</i> in hexadezimaler <code><b>01101011</b></code> in bin√§re <code><b>01101011</b></code> - <code><b>01101011</b></code> .  Die in ASCII codierte Gesamtzeichenfolge "ok" <code><b>01101111 01101011</b></code> : <code><b>01101111 01101011</b></code> .  Der Dekodierungsvorgang wird umgekehrt.  Wir nehmen 8 Bits, √ºbersetzen sie in eine 10-Dezimal-Codierung, ermitteln die Zeichennummer und sehen uns die Tabelle an, um welche Art von Zeichen es sich handelt. <br><br><h2>  Unicode </h2><br>  Mit den Voraussetzungen f√ºr die Erstellung einer gemeinsamen Tabelle f√ºr alle in der Welt der Charaktere, aussortiert.  Nun eigentlich zum Tisch selbst.  Unicode - Dies ist die Tabelle (dies ist keine Codierung, sondern eine Symboltabelle).  Es besteht aus 1.114.112 Positionen.  Die meisten dieser Positionen wurden noch nicht mit Symbolen besetzt, daher ist es unwahrscheinlich, dass dieser Bereich erweitert werden muss. <br><br>  Dieser gesamte Speicherplatz ist in 17 Bl√∂cke mit jeweils 65.536 Zeichen unterteilt.  Jeder Block enth√§lt eine eigene Zeichengruppe.  Der Nullblock ist der grundlegende, er enth√§lt die am h√§ufigsten verwendeten Zeichen aller modernen Alphabete.  Im zweiten Block stehen die Zeichen ausgestorbener Sprachen.  Es gibt zwei Bl√∂cke, die f√ºr den privaten Gebrauch reserviert sind.  Die meisten Bl√∂cke sind noch nicht gef√ºllt. <br><br>  Die Gesamtkapazit√§t von Unicode-Zeichen liegt zwischen <i>0</i> und <i>10FFFF</i> (hexadezimal). <br><br>  Hexadezimalzeichen werden mit dem Pr√§fix "U +" geschrieben.  Beispielsweise enth√§lt der erste Basisblock Zeichen von U + 0000 bis U + FFFF (von 0 bis 65.535) und der letzte siebzehnte Block von U + 100.000 bis U + 10FFFF (von 1.048.576 bis 1.114.111). <br><br>  Anstelle des Zoos der nationalen Kodierungen haben wir jetzt eine umfassende Tabelle, in der alle Zeichen verschl√ºsselt sind, die f√ºr uns n√ºtzlich sein k√∂nnen.  Es gibt aber auch Nachteile.  Wenn zuvor jedes Zeichen mit einem Byte codiert wurde, kann es jetzt mit einer anderen Anzahl von Bytes codiert werden.  Um beispielsweise alle Zeichen des englischen Alphabets zu codieren, reicht ein Byte aus. Beispielsweise ist das gleiche "o" -Zeichen in Englisch Unicode U + 006F, dh die gleiche Zahl wie in ASCII ist <i>6F</i> in Hexadezimal und 111 in Dezimal.  Aber um das Zeichen " <a href="https://unicode-table.com/ru/search/%3Fq%3DU%252B103D5" rel="nofollow">U + 103D5</a> " (das ist die alte persische Zahl einhundert) zu codieren - 103D5 in hexadezimal und 66.517 in dezimal, brauchen wir hier drei Bytes. <br><br>  Unicode-Codierungen wie UTF-8 und UTF-16 sollten dieses Problem bereits l√∂sen.  Weiter werden wir dar√ºber sprechen. <br><br><h2>  Utf-8 </h2><br>  UTF-8 ist eine Unicode-Codierung mit variabler L√§nge, mit der jedes Unicode-Zeichen dargestellt werden kann. <br><br>  Sprechen wir √ºber variable L√§nge. Was bedeutet das?  Das erste, was zu sagen ist, ist, dass die strukturelle (atomare) Einheit dieser Codierung ein Byte ist.  Die Tatsache, dass die Codierung einer Variablen lang ist, bedeutet, dass ein Zeichen mit einer anderen Anzahl von Struktureinheiten der Codierung codiert werden kann, dh mit einer anderen Anzahl von Bytes.  Beispielsweise wird Latein in einem Byte und Kyrillisch in zwei Bytes codiert. <br><br><h4>  Ein bisschen abschweifen vom Thema, es ist notwendig, √ºber die Kompatibilit√§t von ASCII und UTF zu schreiben </h4><br>  Die Tatsache, dass lateinische Zeichen und grundlegende Kontrollstrukturen wie Zeilenumbr√ºche, Tabulatoren usw.  Mit einem Byte codiert macht UTF-Codierungen kompatibel mit ASCII-Codierungen.  Das hei√üt, die lateinische Struktur und die Kontrollstruktur befinden sich in ASCII und UTF an denselben Stellen, und die Tatsache, dass sie dort und dort von einem Byte codiert sind, stellt diese Kompatibilit√§t sicher. <br><br>  Nehmen wir das Zeichen "o" aus dem obigen ASCII-Beispiel.  Denken Sie daran, dass es sich in der Tabelle der ASCII-Zeichen um 111 Stellen handelt, in <code><b>01101111</b></code> um <code><b>01101111</b></code> .  In der Unicode-Tabelle lautet dieses Zeichen U + 006F, das auch in <b><code>01101111</code></b> .  Und jetzt, da UTF eine Codierung mit variabler L√§nge ist, wird dieses Zeichen in einem Byte darin codiert.  Das hei√üt, die Darstellung dieses Symbols in beiden Codierungen ist gleich.  Dies gilt f√ºr den gesamten Zeichenbereich von 0 bis 128. Wenn Ihr Dokument also aus englischem Text besteht, werden Sie den Unterschied nicht bemerken, wenn Sie es in UTF-8 und UTF-16 und ASCII-Codierung √∂ffnen (in UTF-16 sind dies beispielsweise alle Zeichen) wird ebenfalls in zwei Bytes codiert, sodass Sie den Unterschied nicht bemerken, wenn Ihr Editor null Bytes ignoriert usw., bis Sie anfangen, mit dem nationalen Alphabet zu arbeiten. <br><br>  Vergleichen wir in der Praxis, wie der Ausdruck "Hello World" in drei verschiedenen Codierungen aussehen wird: Windows-1251 (russische Codierung), ISO-8859-1 (Codierung westeurop√§ischer Sprachen), UTF-8 (Unicode-Codierung).  Das Wesentliche dieses Beispiels ist, dass die Phrase in zwei Sprachen geschrieben ist.  Mal sehen, wie es in verschiedenen Codierungen aussehen wird. <br><br><img src="https://habrastorage.org/webt/cf/qa/_x/cfqa_xgr7adcrjoxgqj7nfbfcak.png"><br>  <i>In der Kodierung ISO-8859-1 gibt es keine solchen Zeichen "m", "und" und "p".</i> <br><br>  Nun wollen wir mit den Codierungen arbeiten und sehen, wie ein String von einer Codierung in eine andere konvertiert wird und was passiert, wenn die Konvertierung falsch ist oder aufgrund der unterschiedlichen Codierungen nicht m√∂glich ist. <br><br>  Wir gehen davon aus, dass die Phrase urspr√ºnglich in Windows-1251 kodiert wurde.  Basierend auf der obigen Tabelle schreiben wir diesen Ausdruck in bin√§rer Form, codiert in Windows-1251.  Dazu m√ºssen wir nur die Symbole von bin√§r nach dezimal oder hexadezimal (aus der obigen Tabelle) √ºbersetzen. <br><br> <code><b>01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000</b></code> <br>  <i>Nun, dies ist die Phrase "Hello World", die in Windows-1251 codiert ist.</i> <br><br>  Stellen Sie sich nun vor, Sie haben eine Datei mit Text, wissen aber nicht, in welcher Codierung sich dieser Text befindet.  Sie nehmen an, dass es in ISO-8859-1 codiert ist, und √∂ffnen es in Ihrem Editor in dieser Codierung.  Wie oben gesagt, mit einem Teil der Symbole ist alles in Ordnung, sie befinden sich in dieser Kodierung und sogar an den gleichen Stellen, aber mit den Symbolen aus dem Wort "Welt" ist alles komplizierter.  Diese Zeichen sind in dieser Kodierung nicht enthalten, und an ihrer Stelle in der Kodierung ISO-8859-1 handelt es sich um v√∂llig andere Zeichen.  Insbesondere ist "m" Position 236, "und" ist 232. "p" ist 240. Und an diesen Positionen in der ISO-8859-1-Codierung befinden sich die folgenden Zeichen, Position 236 - Zeichen "√¨", 232 - "√®", 240 - "√∞" <br><br>  Die in Windows-1251 codierte und in ISO-8859-1-Codierung ge√∂ffnete Phrase ‚ÄûHello World‚Äú sieht also folgenderma√üen aus: ‚ÄûHello √¨√®√∞‚Äú.  Es stellt sich also heraus, dass diese beiden Codierungen nur teilweise kompatibel sind und es nicht richtig funktioniert, eine Zeichenfolge von einer Codierung zur anderen zu codieren, da es einfach keine solchen Zeichen gibt. <br><br>  Hier werden Unicode-Codierungen ben√∂tigt, und speziell in diesem Fall ist UTF-8 zu ber√ºcksichtigen.  Dass die Zeichen darin mit einer anderen Anzahl von Bytes von 1 bis 4 codiert werden k√∂nnen, haben wir bereits herausgefunden.  Es ist jetzt erw√§hnenswert, dass mit UTF nicht nur 256 Zeichen, wie in den beiden vorherigen, codiert werden k√∂nnen, sondern nur alle Unicode-Zeichen <br><br>  Es funktioniert wie folgt.  Das erste Bit jedes Bytes des Kodierungszeichens ist nicht f√ºr das Zeichen selbst verantwortlich, sondern f√ºr die Bestimmung des Bytes.  Das hei√üt, wenn beispielsweise das f√ºhrende (erste) Bit Null ist, bedeutet dies, dass nur ein Byte zum Codieren eines Zeichens verwendet wird.  Welche bietet Kompatibilit√§t mit ASCII.  Wenn Sie sich die ASCII-Zeichentabelle genau ansehen, werden Sie feststellen, dass die ersten 128 Zeichen (englisches Alphabet, Steuerzeichen und Interpunktionszeichen), wenn sie in Bin√§rzeichen umgewandelt werden, mit einem Null-Bit beginnen (seien Sie vorsichtig, wenn Sie Zeichen in ein Bin√§rsystem √ºbersetzen, beispielsweise online) Konverter, dann kann das erste Null f√ºhrende Bit verworfen werden, was verwirrend sein kann). <br><br>  <b><code>01001000</code></b> - das erste Bit ist Null, dann codiert 1 Byte 1 Zeichen -&gt; "H" <br><br>  <b><code>01100101</code></b> - das erste Bit ist Null, was bedeutet, dass 1 Byte 1 Zeichen codiert -&gt; "e" <br><br>  Wenn das erste Bit nicht Null ist, wird das Zeichen in mehreren Bytes codiert. <br><br>  Bei Doppelbyte-Zeichen sollten die ersten drei Bits - 110 sein <br><br>  <b><code><font color="#cc0000">110</font> 10000 <font color="#008000">10</font> 111100</code></b> - Am Anfang von 110 codieren 2 Bytes 1 Zeichen.  Das zweite Byte beginnt in diesem Fall immer mit 10. <b><code>10000111100</code></b> insgesamt die Kontrollbits (die anf√§nglichen, rot und gr√ºn hervorgehobenen) und √ºbersetzen Sie alle verbleibenden <b><code>10000111100</code></b> ( <b><code>10000111100</code></b> ) in Hexadezimal (043C) -&gt; U + 043C in Unicode, das Symbol ‚Äûm ". <br><br>  F√ºr Drei-Byte-Zeichen im ersten Byte sind die f√ºhrenden Bits 1110 <br><br>  <b><code><font color="#cc0000">1110</font> 1000 <font color="#008000">10</font> 000111 <font color="#008000">10</font> 1010101</code></b> - wir fassen alles au√üer den <b><code><font color="#cc0000">1110</font> 1000 <font color="#008000">10</font> 000111 <font color="#008000">10</font> 1010101</code></b> und erhalten die hexadezimale Zahl 103V5, U + 103D5 ist die alte persische Ziffer einhundert ( <b><code>10000001111010101</code></b> ) <br><br>  Bei 4-Byte-Zeichen im ersten Byte sind die f√ºhrenden Bits 11110 <br><br>  <b><code><font color="#cc0000">11110</font> 100 <font color="#008000">10</font> 001111 <font color="#008000">10</font> 111111 <font color="#008000">10</font> 111111</code></b> - U + 10FFFF ist das letzte g√ºltige Zeichen in der Unicode-Tabelle ( <b><code>100001111111111111111</code></b> ) <br><br>  Auf Wunsch k√∂nnen wir unsere Phrase jetzt in UTF-8-Codierung aufzeichnen. <br><br><h2>  Utf-16 </h2><br>  UTF-16 ist auch eine Kodierung mit variabler L√§nge.  Der Hauptunterschied zu UTF-8 besteht darin, dass die Struktureinheit darin nicht nur ein, sondern zwei Bytes betr√§gt.  Das hei√üt, bei der UTF-16-Codierung kann jedes Unicode-Zeichen mit zwei oder vier Bytes codiert werden.  Lassen Sie mich der Klarheit halber ein Paar solcher Bytes ein Codepaar nennen.  Auf dieser Grundlage kann jedes in UTF-16 codierte Unicode-Zeichen entweder mit einem oder zwei Codepaaren codiert werden. <br><br>  Beginnen wir mit den Zeichen, die von einem Codepaar codiert werden.  Es ist leicht zu berechnen, dass es 65.535 solcher Zeichen (2v16) geben kann, was vollst√§ndig mit dem Basis-Unicode-Block √ºbereinstimmt.  Alle Zeichen, die sich in diesem Unicode-Block in UTF-16-Codierung befinden, werden mit einem Codepaar (zwei Bytes) codiert, hier ist alles einfach. <br><br>  das Symbol "o" (lateinisch) - <code><b>00000000 01101111</b></code> <br>  das Symbol "M" (kyrillisch) - <code><b>00000100 00011100</b></code> <br><br>  Betrachten Sie nun Zeichen au√üerhalb des Basis-Unicode-Bereichs.  F√ºr ihre Codierung werden zwei Codepaare (4 Bytes) ben√∂tigt.  Und der Mechanismus f√ºr die Codierung ist etwas komplizierter. Gehen wir in der richtigen Reihenfolge vor. <br><br>  Zun√§chst stellen wir die Konzepte eines Ersatzpaares vor.  Ein Ersatzpaar besteht aus zwei Codepaaren, die zum Codieren eines Zeichens verwendet werden (insgesamt 4 Bytes).  F√ºr solche <i>Ersatzpaare wird</i> in der Unicode-Tabelle ein spezieller Bereich von <i>D800</i> bis <i>DFFF</i> zugewiesen.  Dies bedeutet, dass Sie beim Konvertieren eines Codepaares von einer Byte-Form in eine hexadezimale Zahl aus diesem Bereich eine Zahl erhalten. Dies ist dann kein unabh√§ngiges Zeichen, sondern ein Ersatzpaar. <br><br>  Um ein Zeichen aus dem Bereich <i>10000</i> - <i>10FFFF</i> zu codieren ( <i>dh</i> ein Zeichen, f√ºr das Sie mehr als ein <i>Codepaar verwenden</i> m√ºssen), ben√∂tigen Sie: <br><br><ol><li>  Subtrahieren Sie <i>10000</i> (hexadezimal) vom Zeichencode (dies ist die kleinste Zahl aus dem Bereich <i>10000</i> - <i>10FFFF</i> ). </li><li>  Als Ergebnis des ersten Punktes wird eine Zahl erhalten, die nicht gr√∂√üer als <i>FFFFF</i> ist und bis zu 20 Bits belegt </li><li>  Die f√ºhrenden 10 Bits der empfangenen Nummer werden mit <i>D800</i> summiert (Beginn des Bereichs der Ersatzpaare in Unicode). </li><li>  Die n√§chsten 10 Bits werden mit <i>DC00</i> summiert (ebenfalls eine Zahl aus dem Bereich der <i>Ersatzpaare</i> ) </li><li>  Danach erhalten wir 2 Ersatzpaare mit jeweils 16 Bits. Die ersten 6 Bits in jedem dieser Paare sind daf√ºr verantwortlich, zu bestimmen, dass es sich um einen Ersatz handelt. </li><li>  Das zehnte Bit in jedem Vertreter ist f√ºr seine Reihenfolge verantwortlich, wenn es 1 ist, dann ist dies der erste Vertreter, wenn 0, dann der zweite </li></ol><br>  Wir werden dies in der Praxis analysieren, ich denke, es wird klarer. <br><br>  Zum Beispiel verschl√ºsseln wir das Symbol und entschl√ºsseln es dann.  Nehmen Sie die alte persische Nummer einhundert (U + 103D5): <br><br><ol><li>  <i>103D5</i> - <i>10000</i> = <i>3D5</i> </li><li>  <i>3D5</i> = <b><code>0000000000 1111010101</code></b> (die f√ºhrenden 10 Bits haben sich als Null herausgestellt, wir bringen dies auf eine hexadezimale Zahl, wir erhalten 0 (erste zehn), <i>3D5</i> (zweite zehn)) </li><li>  <i>0</i> + <i>D800</i> = <i>D800</i> ( <b><code><font color="#cc0000">110110</font> <font color="#008000">0</font> 000000000</code></b> ) Die ersten 6 Bits bestimmen, dass die Zahl aus dem Bereich der Ersatzpaare das zehnte Bit (rechts) Null ist. Dann ist dies der erste Ersatz </li><li>  <i>3D5</i> + <i>DC00</i> = <i>DFD5</i> ( <b><code><font color="#cc0000">110111</font> <font color="#008000">1</font> 111010101</code></b> ) Die ersten 6 Bits bestimmen, dass die Zahl im Bereich der <b><code><font color="#cc0000">110111</font> <font color="#008000">1</font> 111010101</code></b> das zehnte Bit (rechts) ist, dann ist dies das zweite Ersatzbit </li><li>  Insgesamt ist dieses Zeichen in UTF-16 <b><code>1101100000000000 1101111111010101</code></b> </li></ol><br>  Nun dekodiere das Gegenteil.  Angenommen, wir haben einen solchen Code - 1101100000100010 1101111010001000: <br><br><ol><li>  in hexadezimale Form √ºbersetzen = <i>D822</i> <i>DE88</i> (beide Werte stammen aus dem Bereich der <i>Ersatzpaare</i> , daher haben wir ein <i>Ersatzpaar</i> vor uns) </li><li>  <b><code><font color="#cc0000">110110</font> <font color="#008000">0</font> 000100010</code></b> - Das zehnte Bit (rechts) ist Null, dann der erste Ersatz </li><li>  <b><code><font color="#cc0000">110111</font> <font color="#008000">1</font> 010001000</code></b> - Das zehnte Bit (rechts) ist eins, dann der zweite Ersatz </li><li>  wir verwerfen 6 Bits der f√ºr die Bestimmung des <b><code>0000100010 1010001000</code></b> , wir erhalten <b><code>0000100010 1010001000</code></b> ( <i>8A88</i> ) </li><li>  <i>Addiere</i> <i>10.000</i> (weniger <i>Ersatzbereiche</i> ) <i>8A88</i> + <i>10000</i> = <i>18A88</i> </li><li>  Schauen Sie in der Unicode-Tabelle nach dem Zeichen U + 18A88 = Tangut Component-649.  Komponenten des Tangut-Skripts. </li></ol><br>  Dank derer, die bis zum Ende lesen konnten, hoffe ich, dass es n√ºtzlich und nicht sehr langweilig war. <br><br>  Hier einige interessante Links zu diesem Thema: <br>  <a href="https://habr.com/ru/post/158895/">habr.com/de/post/158895</a> - n√ºtzliche allgemeine Informationen zu Kodierungen <br>  <a href="https://habr.com/ru/post/312642/">habr.com/de/post/312642</a> - √ºber Unicode <br>  <a href="https://unicode-table.com/ru/" rel="nofollow">unicode-table.com/ru</a> - die Unicode-Zeichentabelle selbst <br><br>  Nun, wo w√§rst du eigentlich ohne sie? <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25AE%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B4" rel="nofollow">de.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4</a> - Unicode <br>  <a href="https://ru.wikipedia.org/wiki/ASCII" rel="nofollow">en.wikipedia.org/wiki/ASCII</a> - ASCII <br>  <a href="https://ru.wikipedia.org/wiki/UTF-8" rel="nofollow">en.wikipedia.org/wiki/UTF-8</a> - UTF-8 <br>  <a href="https://ru.wikipedia.org/wiki/UTF-16" rel="nofollow">en.wikipedia.org/wiki/UTF-16</a> - UTF-16 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478636/">https://habr.com/ru/post/de478636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478618/index.html">Schule der Magie PHP</a></li>
<li><a href="../de478620/index.html">Warum sollten Sie FastAPI ausprobieren?</a></li>
<li><a href="../de478626/index.html">Debuggen der Softwarebereitstellung mit strace</a></li>
<li><a href="../de478628/index.html">Hoher CRI auf Chinesisch</a></li>
<li><a href="../de478634/index.html">Fallstricke im Projektmanagement f√ºr maschinelles Lernen</a></li>
<li><a href="../de478638/index.html">db-tree: Durchsucht und navigiert die Datenbank</a></li>
<li><a href="../de478640/index.html">Autonome Autos auf Open Source</a></li>
<li><a href="../de478642/index.html">MOXA Nport - Innenansicht</a></li>
<li><a href="../de478646/index.html">JetQuad: D√ºsenflugzeug mit vertikalem Start und Landung</a></li>
<li><a href="../de478650/index.html">Dawn 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>