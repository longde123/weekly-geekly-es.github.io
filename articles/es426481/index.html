<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥ ‚û°Ô∏è üëî Mapas de hex√°gono en Unity: Path Finder, escuadrones de jugadores, animaciones üë®üèº‚Äç‚öïÔ∏è üë©üèª‚Äç‚úàÔ∏è üíÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malla, colores y alturas de celda 

 Partes 4-7: baches, r√≠os y caminos 

 Partes 8-11: agua, accidentes geogr√°ficos y murallas 

 Partes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas de hex√°gono en Unity: Path Finder, escuadrones de jugadores, animaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426481/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, r√≠os y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geogr√°ficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigaci√≥n de mapas, generaci√≥n de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 16: encontrar el camino </h1><br><ul><li>  Resaltar celdas </li><li>  Seleccione un objetivo de b√∫squeda </li><li>  Encuentra el camino m√°s corto </li><li>  Crear una cola prioritaria </li></ul><br>  Despu√©s de calcular las distancias entre las celdas, procedimos a encontrar los caminos entre ellas. <br><br>  A partir de esta parte, se crear√°n tutoriales de mapas hexagonales en Unity 5.6.0.  Cabe se√±alar que en 5.6 hay un error que destruye los conjuntos de texturas en ensamblajes para varias plataformas.  Puede evitarlo si incluye <em>Es legible</em> en el inspector de matriz de texturas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>Planeando un viaje</i> <br><a name="habracut"></a><br><h2>  Celdas resaltadas </h2><br>  Para buscar la ruta entre dos celdas, primero debemos seleccionar estas celdas.  Es m√°s que solo elegir una celda y monitorear la b√∫squeda en el mapa.  Por ejemplo, primero seleccionaremos la celda inicial y luego la final.  En este caso, ser√≠a conveniente que se resaltaran.  Por lo tanto, agreguemos dicha funcionalidad.  Hasta que creamos una forma sofisticada o eficiente de resaltar, solo creamos algo que nos ayude con el desarrollo. <br><br><h3>  Textura del esquema </h3><br>  Una forma sencilla de seleccionar celdas es agregarles una ruta.  La forma m√°s f√°cil de hacerlo es con una textura que contiene un contorno hexagonal.  <a href="">Aqu√≠</a> puedes descargar dicha textura.  Es transparente, excepto por el contorno blanco del hex√°gono.  Habi√©ndolo hecho blanco, en el futuro podremos colorearlo como lo necesitemos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>Esquema de celda sobre fondo negro</i> <br><br>  Importe la textura y establezca su <em>Tipo de textura</em> en <em>Sprite</em> .  Su <em>Modo Sprite</em> se establecer√° en <em>Individual</em> con la configuraci√≥n predeterminada.  Dado que esta es una textura excepcionalmente blanca, no necesitamos convertir a <em>sRGB</em> .  El canal alfa indica transparencia, por lo que habilitar <em>Alfa es Transparencia</em> .  Tambi√©n configur√© la textura del <em>Modo de filtro</em> en <em>Trilineal</em> , porque de lo contrario las transiciones de mip para las rutas pueden ser demasiado notables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>Opciones de importaci√≥n de texturas</i> <br><br><h3>  Un sprite por celda </h3><br>  La forma m√°s r√°pida es agregar un posible contorno a las celdas, agregando cada propio sprite.  Cree un nuevo objeto de juego, agregue el componente Imagen ( <em>Componente / UI / Imagen</em> ) y as√≠gnele nuestro sprite de esquema.  Luego inserte la instancia prefabricada de <em>etiqueta de celda hexadecimal</em> en la escena, haga que el objeto sprite sea secundario, aplique los cambios al prefab y luego elimine el prefab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>Elemento de selecci√≥n hijo prefabricado</i> <br><br>  Ahora cada celda tiene un sprite, pero ser√° demasiado grande.  Para hacer que los contornos coincidan con los centros de las celdas, cambie el <em>Ancho</em> y la <em>Altura</em> del componente de transformaci√≥n del sprite a 17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>Selecci√≥n de sprites parcialmente ocultos por un relieve</i> <br><br><h3>  Dibujando encima de todo </h3><br>  Dado que el contorno se superpone en el √°rea de los bordes de las celdas, a menudo aparece bajo la geometr√≠a del relieve.  Debido a esto, parte del circuito desaparece.  Esto se puede evitar elevando ligeramente los sprites verticalmente, pero no en el caso de roturas.  En cambio, podemos hacer lo siguiente: dibujar siempre sprites encima de todo lo dem√°s.  Para hacer esto, crea tu propio sombreador de sprites.  Ser√° suficiente para nosotros copiar el sombreador de sprites est√°ndar de Unity y hacerle algunos cambios. <br><br><pre><code class="hljs powershell">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Highlight"</span></span> { Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">MaterialToggle</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelSnap</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Pixel snap"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RendererColor</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"RendererColor"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Flip"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableExternalAlpha</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Enable External Alpha"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"PreviewType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Plane"</span></span> <span class="hljs-string"><span class="hljs-string">"CanUseSpriteAtlas"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> } Cull Off ZWrite Off Blend One OneMinusSrcAlpha Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">#pragma vertex SpriteVert #pragma fragment SpriteFrag #pragma target 2.0 #pragma multi_compile_instancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #include "UnitySprites.cginc" ENDCG } } }</span></span></code> </pre> <br>  El primer cambio es que ignoramos el b√∫fer de profundidad, haciendo que la prueba Z siempre tenga √©xito. <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br>  El segundo cambio es que estamos renderizando despu√©s del resto de la geometr√≠a transparente.  Suficiente para agregar 10 a la cola de transparencia. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br>  Crea un nuevo material que usar√° este sombreador.  Podemos ignorar todas sus propiedades, adhiri√©ndonos a los valores predeterminados.  Luego haga que el sprite prefabricado use este material. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>Usamos nuestro propio material de sprite</i> <br><br>  Ahora los contornos de la selecci√≥n son siempre visibles.  Incluso si la celda est√° oculta bajo un relieve m√°s alto, su contorno se dibujar√° sobre todo lo dem√°s.  Puede que no se vea hermoso, pero las celdas seleccionadas siempre estar√°n visibles, lo cual es √∫til para nosotros. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>Ignorar el b√∫fer de profundidad</i> <br><br><h3>  Control de selecci√≥n </h3><br>  No queremos que todas las celdas se resalten al mismo tiempo.  De hecho, inicialmente todos deber√≠an estar sin seleccionar.  Podemos implementar esto deshabilitando el componente Imagen del objeto prefabricado <em>Highlight</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>Componente de imagen deshabilitado</i> <br><br>  Para habilitar la selecci√≥n de celdas, agregue el m√©todo <code>EnableHighlight</code> a <code>EnableHighlight</code> .  Debe tomar el √∫nico hijo de su <code>uiRect</code> e incluir su componente de imagen.  Tambi√©n crearemos el m√©todo <code>DisableHighlight</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Finalmente, podemos especificar el color para que cuando se encienda, le d√© un tono a la luz de fondo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Encontrando el camino </h2><br>  Ahora que podemos seleccionar las celdas, debemos avanzar y seleccionar dos celdas, y luego encontrar la ruta entre ellas.  Primero necesitamos seleccionar las celdas, luego restringir la b√∫squeda a una ruta entre ellas y finalmente mostrar esta ruta. <br><br><h3>  Inicio de b√∫squeda </h3><br>  Necesitamos seleccionar dos celdas diferentes, los puntos inicial y final de la b√∫squeda.  Suponga que para seleccionar la celda de b√∫squeda inicial, mantenga presionada la tecla May√∫s izquierda mientras hace clic con el mouse.  En este caso, la celda se resalta en azul.  Necesitamos guardar el enlace a esta celda para buscar m√°s.  Adem√°s, al elegir una nueva celda inicial, la selecci√≥n de la anterior debe estar deshabilitada.  Por lo tanto, agregamos el campo <code>searchFromCell</code> a <code>searchFromCell</code> . <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br>  Dentro de <code>HandleInput</code> podemos usar <code>Input.GetKey(KeyCode.LeftShift)</code> para probar la tecla Shift presionada. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>Donde mirar</i> <br><br><h3>  Punto final de b√∫squeda </h3><br>  En lugar de buscar todas las distancias a una celda, ahora estamos buscando una ruta entre dos celdas espec√≠ficas.  Por lo tanto, cambie el nombre de <code>HexGrid.FindDistancesTo</code> a <code>HexGrid.FindPath</code> y dele el segundo par√°metro <code>HexCell</code> . Adem√°s, cambie el m√©todo de <code>Search</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); ‚Ä¶ }</code> </pre> <br>  Ahora <code>HexMapEditor.HandleInput</code> deber√≠a llamar al m√©todo modificado, utilizando <code>searchFromCell</code> y <code>currentCell</code> como argumentos.  Adem√°s, solo podemos buscar cuando sabemos desde qu√© celda buscar.  Y no tenemos que molestarnos en buscar si los puntos inicial y final coinciden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br>  En cuanto a la b√∫squeda, primero debemos deshacernos de todas las selecciones anteriores.  Por lo tanto, haga que <code>HexGrid.Search</code> desactive la selecci√≥n al restablecer distancias.  Como esto tambi√©n apaga la iluminaci√≥n de la celda inicial, enci√©ndala nuevamente.  En esta etapa, tambi√©n podemos resaltar el punto final.  Hag√°mosla roja. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>Puntos finales de una ruta potencial</i> <br><br><h3>  Limitar b√∫squeda </h3><br>  En este punto, nuestro algoritmo de b√∫squeda a√∫n calcula las distancias a todas las celdas a las que se puede llegar desde la celda inicial.  Pero ya no lo necesitamos.  Podemos detenernos tan pronto como encontremos la distancia final a la celda final.  Es decir, cuando la celda actual es finita, podemos salir del ciclo del algoritmo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>Pare en el punto final</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© sucede si no se puede alcanzar el punto final?</b> <div class="spoiler_text">  Luego, el algoritmo continuar√° funcionando hasta que encuentre todas las celdas accesibles.  Sin la posibilidad de una salida prematura, funcionar√° como el antiguo m√©todo <code>FindDistancesTo</code> . </div></div><br><h3>  Visualizaci√≥n de la ruta </h3><br>  Podemos encontrar la distancia entre el principio y el final del camino, pero a√∫n no sabemos cu√°l ser√° el camino real.  Para encontrarlo, necesita rastrear c√≥mo se llega a cada celda.  ¬øPero c√≥mo hacerlo? <br><br>  Al agregar una celda al borde, hacemos esto porque es un vecino de la celda actual.  La √∫nica excepci√≥n es la celda inicial.  Todas las otras celdas se han alcanzado a trav√©s de la celda actual.  Si hacemos un seguimiento de qu√© celda se lleg√≥ a cada celda, como resultado obtenemos una red de celdas.  M√°s precisamente, una red en forma de √°rbol, cuya ra√≠z es el punto de partida.  Podemos usarlo para construir el camino despu√©s de llegar al punto final. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>Red de √°rboles que describe caminos hacia el centro</i> <br><br>  Podemos guardar esta informaci√≥n agregando un enlace a otra celda en <code>HexCell</code> .  No necesitamos serializar estos datos, por lo que utilizamos la propiedad est√°ndar para esto. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  En <code>HexGrid.Search</code> establezca el valor <code>PathFrom</code> del vecino en la celda actual al agregarlo al borde.  Adem√°s, debemos cambiar este enlace cuando encontremos un camino m√°s corto hacia el vecino. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br>  Una vez alcanzado el punto final, podemos visualizar la ruta siguiendo estos enlaces de regreso a la celda inicial y seleccion√°ndolos. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>Ruta encontrada</i> <br><br>  Vale la pena considerar que a menudo hay varios caminos m√°s cortos.  El encontrado depende del orden de procesamiento de las celdas.  Algunos caminos pueden verse bien, otros pueden ser malos, pero nunca hay un camino m√°s corto.  Volveremos a esto m√°s tarde. <br><br><h3>  Cambiar inicio de b√∫squeda </h3><br>  Despu√©s de seleccionar el punto de inicio, cambiar el punto final desencadenar√° una nueva b√∫squeda.  Lo mismo deber√≠a suceder al elegir una nueva celda inicial.  Para que esto sea posible, <code>HexMapEditor</code> tambi√©n debe recordar el punto final. <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br>  Usando este campo, tambi√©n podemos iniciar una nueva b√∫squeda al elegir un nuevo comienzo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br>  Adem√°s, debemos evitar los mismos puntos de inicio y finalizaci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { ‚Ä¶ }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  B√∫squeda m√°s inteligente </h2><br>  Aunque nuestro algoritmo encuentra el camino m√°s corto, pasa mucho tiempo explorando puntos que obviamente no formar√°n parte de este camino.  Al menos es obvio para nosotros.  El algoritmo no puede mirar hacia abajo en el mapa; no puede ver que una b√∫squeda en algunas direcciones no tendr√° sentido.  Prefiere moverse por las carreteras, a pesar de que se dirigen en la direcci√≥n opuesta desde el punto final.  ¬øEs posible hacer la b√∫squeda m√°s inteligente? <br><br>  Por el momento, al elegir la celda que se procesar√° a continuaci√≥n, consideramos solo la distancia desde la celda hasta el comienzo.  Si queremos ser m√°s inteligentes, tambi√©n debemos considerar la distancia hasta el punto final.  Desafortunadamente, a√∫n no lo conocemos.  Pero podemos crear una estimaci√≥n de la distancia restante.  Agregar esta estimaci√≥n a la distancia a la celda nos da una idea de la longitud total de la ruta que pasa por esta celda.  Entonces podemos usarlo para priorizar las b√∫squedas de celdas. <br><br><h3>  B√∫squeda heur√≠stica </h3><br>  Cuando usamos estimaciones o conjeturas en lugar de datos exactamente conocidos, esto se llama usar heur√≠stica de b√∫squeda.  Esta heur√≠stica representa la mejor suposici√≥n de la distancia restante.  Debemos determinar este valor para cada celda que estamos buscando, por lo que agregaremos una propiedad entera <code>HexCell</code> .  No necesitamos serializarlo, por lo que bastar√° con otra propiedad est√°ndar. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  ¬øC√≥mo hacemos una suposici√≥n sobre la distancia restante?  En el caso m√°s ideal, tendremos un camino que conduce directamente al punto final.  Si es as√≠, la distancia es igual a la distancia sin cambios entre las coordenadas de esta celda y la celda final.  Aprovechemos esto en nuestra heur√≠stica. <br><br>  Dado que la heur√≠stica no depende de una ruta recorrida anteriormente, es constante en el proceso de b√∫squeda.  Por lo tanto, necesitamos calcularlo solo una vez cuando <code>HexGrid.Search</code> agrega una celda al borde. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3>  Prioridad de b√∫squeda </h3><br>  A partir de ahora, determinaremos la prioridad de la b√∫squeda en funci√≥n de la distancia a la celda m√°s sus heur√≠sticas.  <code>HexCell</code> una propiedad para este valor en <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br>  Para que esto funcione, <code>HexGrid.Search</code> para que use esta propiedad para ordenar el borde. <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>Buscar sin heur√≠stica y con heur√≠stica</i> <br><br><h3>  Heur√≠stica v√°lida </h3><br>  Gracias a las nuevas prioridades de b√∫squeda, como resultado, visitaremos menos celdas.  Sin embargo, en un mapa uniforme, el algoritmo a√∫n procesa celdas que est√°n en la direcci√≥n incorrecta.  Esto se debe a que, por defecto, los costos para cada paso de movimiento son 5, y la heur√≠stica por paso agrega solo 1. Es decir, la influencia de la heur√≠stica no es muy fuerte. <br><br>  Si los costos de mover todas las tarjetas son iguales, entonces podemos usar los mismos costos para determinar la heur√≠stica.  En nuestro caso, esta ser√° la heur√≠stica actual multiplicada por 5. Esto reducir√° significativamente el n√∫mero de celdas procesadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>Usando heur√≠stica √ó 5</i> <br><br>  Sin embargo, si hay carreteras en el mapa, podemos sobreestimar la distancia restante.  Como resultado, el algoritmo puede cometer errores y crear una ruta que en realidad no es la m√°s corta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>Heur√≠stica sobrevalorada y v√°lida</i> <br><br>  Para garantizar que se encuentre el camino m√°s corto, debemos asegurarnos de que nunca sobreestimamos la distancia restante.  Este enfoque se llama heur√≠stica v√°lida.  Dado que el costo m√≠nimo de mudanza es 1, no tenemos m√°s remedio que usar los mismos costos para determinar la heur√≠stica. <br><br>  Estrictamente hablando, es bastante normal usar costos a√∫n m√°s bajos, pero esto solo debilitar√° la heur√≠stica.  El m√≠nimo heur√≠stico posible es cero, lo que nos da solo el algoritmo de Dijkstra.  Con una heur√≠stica distinta de cero, el algoritmo se llama A <sup>*</sup> (pronunciado "A star"). <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© se llama A *?</b> <div class="spoiler_text">  Niels Nilsson propuso por primera vez la idea de agregar heur√≠stica al algoritmo de Dijkstra.  Llam√≥ a su versi√≥n A1.  Bertram Rafael m√°s tarde se le ocurri√≥ la mejor versi√≥n que llam√≥ A2.  Entonces Peter Hart demostr√≥ que con una buena heur√≠stica A2 es √≥ptimo, es decir, no puede haber una versi√≥n mejor.  Esto lo oblig√≥ a llamar al algoritmo A <sup>*</sup> para mostrar que no pod√≠a mejorarse, es decir, A3 o A4 no aparecer√≠an.  Entonces s√≠, el algoritmo A <sup>*</sup> es lo mejor que podemos obtener, pero es tan bueno como heur√≠stico. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Cola de prioridad </h2><br>  Aunque A <sup>* es un</sup> buen algoritmo, nuestra implementaci√≥n no es tan efectiva, porque para almacenar el borde, utilizamos una lista que debe ordenarse en cada iteraci√≥n.  Como se mencion√≥ en la parte anterior, necesitamos una cola prioritaria, pero su implementaci√≥n est√°ndar no existe.  Por lo tanto, cre√©moslo usted mismo. <br><br>  Nuestro turno debe apoyar la operaci√≥n de configuraci√≥n y exclusi√≥n de la cola en funci√≥n de la prioridad.  Tambi√©n deber√≠a permitir cambiar la prioridad de una celda que ya est√° en la cola.  Idealmente, lo implementamos, minimizando la b√∫squeda de clasificaci√≥n y memoria asignada.  Adem√°s, deber√≠a seguir siendo simple. <br><br><h3>  Crea tu propia cola </h3><br>  Cree una nueva clase <code>HexCellPriorityQueue</code> con los m√©todos comunes requeridos.  Usamos una lista simple para rastrear el contenido de una cola.  Adem√°s, agregaremos el m√©todo <code>Clear</code> para borrar la cola y poder usarla repetidamente. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br>  Almacenamos las prioridades de las c√©lulas en las propias c√©lulas.  Es decir, antes de agregar una celda a la cola, se debe establecer su prioridad.  Pero en caso de un cambio de prioridad, probablemente ser√° √∫til saber cu√°l era la prioridad anterior.  As√≠ que agreguemos esto a <code>Change</code> como par√°metro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Tambi√©n es √∫til saber cu√°ntas celdas hay en la cola, as√≠ que agreguemos la propiedad <code>Count</code> para esto.  Simplemente use el campo para el que realizaremos el incremento y la disminuci√≥n correspondientes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3>  Agregar a la cola </h3><br>  Cuando se agrega una celda a la cola, primero usemos su prioridad como √≠ndice, tratando la lista como una matriz simple. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br>  Sin embargo, esto solo funciona si la lista es lo suficientemente larga, de lo contrario, iremos m√°s all√° de las fronteras.  Puede evitar esto agregando elementos vac√≠os a la lista hasta que alcance la longitud requerida.  Estos elementos vac√≠os no hacen referencia a la celda, por lo que puede crearlos agregando <code>null</code> a la lista. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>Lista con agujeros</i> <br><br>  Pero as√≠ es como almacenamos solo una celda por prioridad, y lo m√°s probable es que haya varias.  Para rastrear todas las celdas con la misma prioridad, necesitamos usar otra lista.  Aunque podemos usar una lista real para cada prioridad, tambi√©n podemos agregar una propiedad a <code>HexCell</code> para unirlas.  Esto nos permite crear una cadena de celdas llamada lista vinculada. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Para crear una cadena, deje que <code>HexCellPriorityQueue.Enqueue</code> obligue a la celda reci√©n agregada a referirse al valor actual con la misma prioridad, antes de eliminarlo. <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>Lista de listas vinculadas</i> <br><br><h3>  Eliminar de la cola </h3><br>  Para obtener una celda de una cola prioritaria, necesitamos acceder a la lista vinculada en el √≠ndice no vac√≠o m√°s bajo.  Por lo tanto, recorreremos la lista en un ciclo hasta que la encontremos.  Si no lo encontramos, entonces la cola est√° vac√≠a y devolvemos <code>null</code> . <br><br>  De la cadena encontrada, podemos devolver cualquier celda, porque todas tienen la misma prioridad.  La forma m√°s f√°cil es devolver la celda desde el comienzo de la cadena. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Para mantener el enlace a la cadena restante, use la siguiente celda con la misma prioridad que el nuevo inicio.  Si solo hab√≠a una celda en este nivel de prioridad, el elemento se vuelve <code>null</code> y se omitir√° en el futuro. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3>  Seguimiento m√≠nimo </h3><br>  Este enfoque funciona, pero itera a trav√©s de la lista cada vez que se recibe una celda.  No podemos evitar encontrar el √≠ndice no vac√≠o m√°s peque√±o, pero no estamos obligados a comenzar desde cero cada vez.  En cambio, podemos rastrear la prioridad m√≠nima y comenzar la b√∫squeda con ella.  Inicialmente, el m√≠nimo es esencialmente igual al infinito. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br>  Al agregar una celda a la cola, cambiamos el m√≠nimo seg√∫n sea necesario. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } ‚Ä¶ }</code> </pre> <br>  Y cuando nos retiramos de la cola, usamos al menos la lista para las iteraciones, y no comenzamos desde cero. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Esto reduce significativamente la cantidad de tiempo que lleva pasar por alto en el bucle de lista de prioridades. <br><br><h3>  Cambiar prioridades </h3><br>  Al cambiar la prioridad de una celda, debe eliminarse de la lista vinculada de la que forma parte.  Para hacer esto, debemos seguir la cadena hasta que la encontremos. <br><br>  Comencemos declarando que el encabezado de la lista de prioridades anterior ser√° la celda actual, y tambi√©n rastrearemos la siguiente celda.  Podemos tomar inmediatamente la siguiente celda, porque sabemos que hay al menos una celda por este √≠ndice. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br>  Si la celda actual es una celda cambiada, entonces esta es la celda principal y podemos cortarla como si la hubi√©ramos sacado de la cola. <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br>  Si este no es el caso, entonces debemos seguir la cadena hasta que estemos en la celda frente a la celda cambiada.  Contiene un enlace a la celda que se ha modificado. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br>  En este punto, podemos eliminar la celda modificada de la lista vinculada, omiti√©ndola. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br>  Despu√©s de eliminar una celda, debe agregarla nuevamente para que aparezca en la lista de su nueva prioridad. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Enqueue(cell); }</code> </pre> <br>  El m√©todo <code>Enqueue</code> incrementa el contador, pero en realidad no estamos agregando una nueva celda.  Por lo tanto, para compensar esto, tendremos que disminuir el contador. <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3>  Uso de la cola </h3><br>  Ahora podemos aprovechar nuestra cola prioritaria en <code>HexGrid</code> .  Esto se puede hacer con una sola instancia, reutilizable para todas las b√∫squedas. <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar el ciclo, el m√©todo </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero debe agregarse a la cola </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y cada iteraci√≥n comienza con la salida de la celda desde la cola. </font><font style="vertical-align: inherit;">Esto reemplazar√° el antiguo c√≥digo de borde.</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie el c√≥digo para que agregue y cambie el vecino. </font><font style="vertical-align: inherit;">Antes del cambio recordaremos la antigua prioridad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s, ya no necesitamos ordenar el borde. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buscar usando una cola de prioridad</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como se mencion√≥ anteriormente, la ruta m√°s corta encontrada depende del orden de procesamiento de las celdas. </font><font style="vertical-align: inherit;">Nuestro turno crea un orden diferente del orden de la lista ordenada, para que podamos obtener otras formas. </font><font style="vertical-align: inherit;">Como agregamos y eliminamos del encabezado de la lista vinculada para cada prioridad, se parecen m√°s a las pilas que a las colas. </font><font style="vertical-align: inherit;">Las celdas agregadas en √∫ltimo lugar se procesan primero. </font><font style="vertical-align: inherit;">Un efecto secundario de este enfoque es que el algoritmo es propenso a zigzag. </font><font style="vertical-align: inherit;">Por lo tanto, la probabilidad de caminos en zigzag tambi√©n aumenta. </font><font style="vertical-align: inherit;">Afortunadamente, tales caminos generalmente se ven mejor, por lo que este efecto secundario est√° a nuestro favor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista y cola </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ordenadas </font></a><i><font style="vertical-align: inherit;">con prioridad de </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitpackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 17: movimiento limitado </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontramos formas de movimiento paso a paso. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar inmediatamente el camino. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos una b√∫squeda m√°s efectiva. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizamos solo el camino. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En esta parte dividiremos el movimiento en movimientos y aceleraremos la b√∫squeda tanto como sea posible. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viaja desde varios movimientos</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento paso a paso </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los juegos de estrategia que usan redes hexagonales casi siempre se basan en turnos. </font><font style="vertical-align: inherit;">Las unidades que se mueven en el mapa tienen una velocidad limitada, lo que limita la distancia recorrida en un turno.</font></font><br><br><h3>  Velocidad </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para proporcionar soporte para movimientos limitados, agregamos dentro </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y dentro del </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro entero </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Determina el rango de movimiento para un movimiento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los diferentes tipos de unidades en el juego usan diferentes velocidades. </font><font style="vertical-align: inherit;">La caballer√≠a es r√°pida, la infanter√≠a es lenta, y as√≠ sucesivamente. </font><font style="vertical-align: inherit;">Todav√≠a no tenemos unidades, as√≠ que por ahora usaremos una velocidad constante. </font><font style="vertical-align: inherit;">Tomemos un valor de 24. Este es un valor bastante grande, no divisible por 5 (el costo predeterminado de la mudanza). </font><font style="vertical-align: inherit;">A√±adir un argumento a favor </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una velocidad constante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimientos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de rastrear el costo total de moverse a lo largo del camino, ahora tambi√©n necesitamos saber cu√°ntos movimientos se necesitar√°n para avanzar. Pero no necesitamos almacenar esta informaci√≥n en cada celda. Se puede obtener dividiendo la distancia recorrida por la velocidad. Como estos son enteros, utilizaremos la divisi√≥n de enteros. Es decir, las distancias totales que no exceden 24 corresponden al curso 0. Esto significa que todo el camino puede completarse en el curso actual. Si el punto final est√° a una distancia de 30, entonces este debe ser el turno 1. Para llegar al punto final, la unidad tendr√° que gastar todo su movimiento en el turno actual y en parte del siguiente turno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinemos el curso de la celda actual y todos sus vecinos dentro</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El curso de la celda actual se puede calcular solo una vez, justo antes de dar la vuelta en el ciclo vecino. </font><font style="vertical-align: inherit;">El movimiento del vecino se puede determinar tan pronto como encontremos la distancia a √©l.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento perdido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el movimiento del vecino es mayor que el movimiento actual, entonces cruzamos el l√≠mite del movimiento. </font><font style="vertical-align: inherit;">Si el movimiento necesario para llegar a un vecino era 1, entonces todo est√° bien. </font><font style="vertical-align: inherit;">Pero si pasar a la siguiente celda es m√°s costoso, entonces todo se vuelve m√°s complicado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos que nos movemos a lo largo de un mapa homog√©neo, es decir, para entrar en cada celda necesita 5 unidades de movimiento. </font><font style="vertical-align: inherit;">Nuestra velocidad es 24. Despu√©s de cuatro pasos, gastamos 20 unidades de nuestro stock de movimiento, y quedan 4. En el siguiente paso, se necesitan nuevamente 5 unidades, es decir, una m√°s que las disponibles. </font><font style="vertical-align: inherit;">¬øQu√© necesitamos hacer en esta etapa?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos enfoques para esta situaci√≥n. El primero es permitir que la unidad ingrese a la quinta celda en el turno actual, incluso si no tenemos suficiente movimiento. El segundo es prohibir el movimiento durante el movimiento actual, es decir, los puntos de movimiento restantes no se pueden usar y se perder√°n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La elecci√≥n de la opci√≥n depende del juego. En general, el primer enfoque es m√°s apropiado para juegos en los que las unidades pueden moverse solo unos pocos pasos por turno, por ejemplo, para juegos de la serie Civilization. Esto asegura que las unidades siempre puedan mover al menos una celda por turno. Si las unidades pueden mover muchas celdas por turno, como en Age of Wonders o en Battle for Wesnoth, entonces la segunda opci√≥n es mejor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como usamos la velocidad 24, elijamos el segundo enfoque. </font><font style="vertical-align: inherit;">Para que comience a funcionar, necesitamos aislar los costos de ingresar a la siguiente celda antes de agregarlo a la distancia actual.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si como resultado cruzamos el borde del movimiento, entonces primero usamos todos los puntos de movimiento del movimiento actual. </font><font style="vertical-align: inherit;">Podemos hacer esto simplemente multiplicando el movimiento por la velocidad. </font><font style="vertical-align: inherit;">Despu√©s de eso, agregamos el costo de la mudanza.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado de esto, completaremos el primer movimiento en la cuarta celda con 4 puntos de movimiento no utilizados. </font><font style="vertical-align: inherit;">Estos puntos perdidos se suman a los costos de la quinta celda, por lo que su distancia se convierte en 29, no en 25. Como resultado, las distancias son mayores que antes. </font><font style="vertical-align: inherit;">Por ejemplo, la d√©cima celda ten√≠a una distancia de 50. Pero ahora para entrar en ella, necesitamos cruzar los bordes de dos movimientos, perdiendo 8 puntos de movimiento, es decir, la distancia a ella ahora se convierte en 58.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°s largo de lo esperado</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que los puntos de movimiento no utilizados se agregan a las distancias a las celdas, se tienen en cuenta al determinar la ruta m√°s corta. </font><font style="vertical-align: inherit;">La forma m√°s efectiva es desperdiciar la menor cantidad de puntos posible. </font><font style="vertical-align: inherit;">Por lo tanto, a diferentes velocidades, podemos obtener diferentes caminos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrando movimientos en lugar de distancias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando jugamos el juego, no estamos muy interesados ‚Äã‚Äãen los valores de distancia utilizados para encontrar el camino m√°s corto. </font><font style="vertical-align: inherit;">Estamos interesados ‚Äã‚Äãen la cantidad de movimientos necesarios para llegar al punto final. </font><font style="vertical-align: inherit;">Por lo tanto, en lugar de distancias, vamos a mostrar los movimientos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, deshazte de </font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">su llamada </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } ‚Ä¶ // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cambio, agregaremos al </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo general </font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que recibe una cadena arbitraria.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos este nuevo m√©todo en la </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limpieza de celdas. </font><font style="vertical-align: inherit;">Para ocultar celdas, simplemente as√≠gnelas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego asignamos a la marca del vecino el valor de su movimiento. </font><font style="vertical-align: inherit;">Despu√©s de eso, podremos ver cu√°ntos movimientos adicionales se necesitar√°n para llegar hasta el final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El n√∫mero de movimientos necesarios para moverse a lo largo de la ruta del </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">paquete de </font></a><i><font style="vertical-align: inherit;">la </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unidad.</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caminos instant√°neos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, cuando jugamos el juego, no nos importa c√≥mo el algoritmo de b√∫squeda de ruta encuentra el camino. </font><font style="vertical-align: inherit;">Queremos ver la ruta solicitada de inmediato. </font><font style="vertical-align: inherit;">Por el momento, podemos estar seguros de que el algoritmo funciona, as√≠ que eliminemos la visualizaci√≥n de b√∫squeda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sin corutina </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para un paso lento a trav√©s del algoritmo, usamos corutina. </font><font style="vertical-align: inherit;">Ya no necesitamos hacer esto, as√≠ que nos libraremos de las llamadas </font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En cambio, simplemente lo invocamos </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como un m√©todo regular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); ‚Ä¶ } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya no lo usamos </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como rutina, no necesita rendimiento, por lo que eliminaremos este operador. </font><font style="vertical-align: inherit;">Esto significa que tambi√©n eliminaremos la declaraci√≥n </font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y cambiaremos el tipo de retorno del m√©todo </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); ‚Ä¶ } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados instant√°neos</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definici√≥n del tiempo de b√∫squeda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos obtener las rutas al instante, pero ¬øqu√© tan r√°pido se calculan? Las rutas cortas aparecen casi de inmediato, pero las rutas largas en mapas grandes pueden parecer un poco lentas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Midamos cu√°nto tiempo lleva encontrar y mostrar el camino. Podemos usar un generador de perfiles para determinar el tiempo de b√∫squeda, pero esto es demasiado y crea costos adicionales. Usemos en su lugar </font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que est√° en el espacio de nombres </font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como lo usamos solo temporalmente, no agregar√© la construcci√≥n </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al comienzo del script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justo antes de la b√∫squeda, cree un nuevo cron√≥metro e in√≠cielo. Una vez completada la b√∫squeda, detenga el cron√≥metro y muestre el tiempo transcurrido en la consola.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elija el peor de los casos para nuestro algoritmo: una b√∫squeda desde la esquina inferior izquierda hasta la esquina superior derecha de un mapa grande. Lo peor es un mapa uniforme, porque el algoritmo tendr√° que procesar las 4.800 celdas del mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buscar en el peor de los casos El tiempo</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dedicado a buscarlo puede ser diferente, porque el editor de Unity no es el √∫nico proceso que se ejecuta en su m√°quina. Por lo tanto, pru√©belo varias veces para comprender la duraci√≥n promedio. En mi caso, la b√∫squeda toma alrededor de 45 milisegundos. Esto no es mucho y corresponde a 22.22 rutas por segundo; denota esto como 22 pps (rutas por segundo). Esto significa que la velocidad de fotogramas del juego tambi√©n disminuir√° en un m√°ximo de 22 fps en ese fotograma cuando se calcule esta ruta. Y esto sin tener en cuenta todos los dem√°s trabajos, por ejemplo, renderizar el marco en s√≠. Es decir, obtenemos una disminuci√≥n bastante grande en la velocidad de fotogramas, se reducir√° a 20 fps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al realizar una prueba de rendimiento de este tipo, debe tener en cuenta que el rendimiento del editor de Unity no ser√° tan alto como el rendimiento de la aplicaci√≥n finalizada. </font><font style="vertical-align: inherit;">Si realizo la misma prueba con el ensamblaje, en promedio solo tomar√° 15 ms. </font><font style="vertical-align: inherit;">Eso es 66 pps, que es mucho mejor. </font><font style="vertical-align: inherit;">Sin embargo, esto sigue siendo una gran parte de los recursos asignados por fotograma, por lo que la velocidad de fotogramas ser√° inferior a 60 fps.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øD√≥nde puedo ver el registro de depuraci√≥n para el ensamblado?</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Busque solo si es necesario. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos hacer una optimizaci√≥n simple: realice una b√∫squeda solo cuando sea necesario. </font><font style="vertical-align: inherit;">Mientras iniciamos una nueva b√∫squeda en cada cuadro en el que se mantiene presionado el bot√≥n del mouse. </font><font style="vertical-align: inherit;">Por lo tanto, la velocidad de fotogramas se subestimar√° constantemente al arrastrar y soltar. </font><font style="vertical-align: inherit;">Podemos evitar esto iniciando una nueva b√∫squeda </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo cuando realmente estamos tratando con un nuevo punto final. </font><font style="vertical-align: inherit;">De lo contrario, la ruta visible actual sigue siendo v√°lida.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar etiquetas solo para la ruta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar marcas de viaje es una operaci√≥n bastante costosa, especialmente porque usamos un enfoque no optimizado. </font><font style="vertical-align: inherit;">Realizar esta operaci√≥n para todas las celdas definitivamente ralentizar√° la ejecuci√≥n. </font><font style="vertical-align: inherit;">As√≠ que saltemos el etiquetado </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos ver esta informaci√≥n solo para la ruta encontrada. </font><font style="vertical-align: inherit;">Por lo tanto, despu√©s de llegar al punto final, calcularemos el curso y estableceremos las etiquetas de solo aquellas celdas que est√°n en camino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar etiquetas solo para celdas de ruta</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora incluimos solo etiquetas de celdas entre el inicio y el final. </font><font style="vertical-align: inherit;">Pero el punto final es lo m√°s importante, tambi√©n debemos establecer una etiqueta para ello. </font><font style="vertical-align: inherit;">Puede hacerlo iniciando el ciclo de ruta desde la celda de destino, y no desde la celda frente a ella. </font><font style="vertical-align: inherit;">En este caso, la iluminaci√≥n del punto final de rojo cambiar√° a blanco, por lo que eliminaremos su retroiluminaci√≥n durante el ciclo.</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La informaci√≥n de progreso es m√°s importante para el punto final.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de estos cambios, el peor de los casos se reduce a 23 milisegundos en el editor y a 6 milisegundos en el ensamblaje terminado. </font><font style="vertical-align: inherit;">Estos son 43 pps y 166 pps, mucho mejor. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La busqueda mas inteligente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte anterior, hicimos el procedimiento de b√∫squeda m√°s inteligente al implementar el algoritmo A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sin embargo, en realidad todav√≠a no estamos realizando la b√∫squeda de la manera m√°s √≥ptima. </font><font style="vertical-align: inherit;">En cada iteraci√≥n, calculamos las distancias desde la celda actual a todos sus vecinos. </font><font style="vertical-align: inherit;">Esto es cierto para las celdas que a√∫n no son o que actualmente son parte del borde de b√∫squeda. </font><font style="vertical-align: inherit;">Pero las celdas que ya se han eliminado del borde ya no necesitan ser consideradas, porque ya hemos encontrado el camino m√°s corto a estas celdas. </font><font style="vertical-align: inherit;">La implementaci√≥n correcta de A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> omite estas celdas, por lo que podemos hacer lo mismo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fase de b√∫squeda de celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo sabemos si una celda ya ha salido del borde? </font><font style="vertical-align: inherit;">Si bien no podemos determinar esto. </font><font style="vertical-align: inherit;">Por lo tanto, debe realizar un seguimiento en qu√© fase de la b√∫squeda se encuentra la celda. </font><font style="vertical-align: inherit;">Todav√≠a no ha estado en la frontera, o est√° en ella ahora, o est√° en el extranjero. </font><font style="vertical-align: inherit;">Podemos rastrear esto agregando a una </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad entera simple.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por ejemplo, 0 significa que las celdas a√∫n no han alcanzado, 1 - que la celda est√° en el borde ahora, y 2 - que ya se ha eliminado del borde. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Golpeando la frontera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos restablecer todas las celdas a 0 y usar siempre 1 para el borde. </font><font style="vertical-align: inherit;">O podemos aumentar el n√∫mero de bordes con cada nueva b√∫squeda. </font><font style="vertical-align: inherit;">Gracias a esto, no tendremos que lidiar con el vertido de celdas si cada vez aumentamos el n√∫mero de bordes en dos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos establecer la fase de b√∫squeda de celdas al agregarlas al borde. </font><font style="vertical-align: inherit;">El proceso comienza con una celda inicial, que se agrega al borde.</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y tambi√©n cada vez que agregamos un vecino a la frontera. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control de fronteras </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, para verificar que la celda a√∫n no se haya agregado al borde, usamos una distancia igual a </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ahora podemos comparar la fase de b√∫squeda de celdas con el borde actual.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto significa que ya no necesitamos restablecer las distancias de las celdas antes de buscar, es decir, tendremos que hacer menos trabajo, lo cual es bueno. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saliendo de la frontera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando una celda se elimina del l√≠mite, lo denotamos por un aumento en su fase de b√∫squeda. </font><font style="vertical-align: inherit;">Esto la coloca m√°s all√° de la frontera actual y antes de la pr√≥xima.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos omitir celdas eliminadas del borde, evitando el c√°lculo sin sentido y la comparaci√≥n de distancias. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, nuestro algoritmo a√∫n produce los mismos resultados, pero de manera m√°s eficiente. </font><font style="vertical-align: inherit;">En mi m√°quina, la b√∫squeda en el peor de los casos toma 20 ms en el editor y 5 ms en el ensamblado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n podemos calcular cu√°ntas veces la celda ha sido procesada por el algoritmo, aumentando el contador al calcular la distancia a la celda. </font><font style="vertical-align: inherit;">Anteriormente, nuestro algoritmo en el peor de los casos calculaba 28,239 distancias. </font><font style="vertical-align: inherit;">En el algoritmo A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> listo para usar, </font><font style="vertical-align: inherit;">calculamos sus 14.120 distancias. </font><font style="vertical-align: inherit;">La cantidad disminuy√≥ en un 50%. </font><font style="vertical-align: inherit;">El grado de impacto de estos indicadores en la productividad depende de los costos al calcular el costo de la mudanza. </font><font style="vertical-align: inherit;">En nuestro caso, no hay mucho trabajo aqu√≠, por lo que la mejora en el ensamblaje no es muy grande, pero es muy notable en el editor. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despejando el camino </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al iniciar una nueva b√∫squeda, primero debemos borrar la visualizaci√≥n de la ruta anterior. </font><font style="vertical-align: inherit;">Mientras hacemos esto, apague la selecci√≥n y elimine las etiquetas de cada celda de la cuadr√≠cula. </font><font style="vertical-align: inherit;">Este es un enfoque muy dif√≠cil. </font><font style="vertical-align: inherit;">Idealmente, necesitamos descartar solo aquellas celdas que fueron parte de la ruta anterior.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buscar solo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos por eliminar completamente el c√≥digo de visualizaci√≥n de </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Solo necesita realizar una b√∫squeda de ruta y no tiene que saber qu√© haremos con esta informaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } ‚Ä¶ } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para informar que </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hemos encontrado una manera, devolveremos boolean.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recuerda el camino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se encuentra el camino, debemos recordarlo. </font><font style="vertical-align: inherit;">Gracias a esto, podremos limpiarlo en el futuro. </font><font style="vertical-align: inherit;">Por lo tanto, rastrearemos los puntos finales y si hay una ruta entre ellos.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar el camino nuevamente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar los datos de b√∫squeda que grabamos para visualizar nuevamente la ruta. </font><font style="vertical-align: inherit;">Creemos un nuevo m√©todo para esto </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Recorrer√° el ciclo desde el final hasta el comienzo de la ruta, resaltando las celdas y asignando un valor de trazo a sus etiquetas. </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos saber la velocidad, as√≠ que convi√©rtalo en un par√°metro. </font><font style="vertical-align: inherit;">Si no tenemos una ruta, entonces el m√©todo simplemente selecciona los puntos finales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llame a este m√©todo </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despu√©s de la b√∫squeda.</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos el camino nuevamente, pero ahora no se est√° alejando. </font><font style="vertical-align: inherit;">Para borrarlo, cree un m√©todo </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De hecho, es una copia </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, excepto que deshabilita la selecci√≥n y las etiquetas, pero no las incluye. </font><font style="vertical-align: inherit;">Una vez hecho esto, debe borrar los datos de ruta grabados que ya no son v√°lidos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con este m√©todo, podemos borrar la visualizaci√≥n de la ruta anterior visitando solo las celdas necesarias, el tama√±o del mapa ya no es importante. </font><font style="vertical-align: inherit;">Lo llamaremos </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de comenzar una nueva b√∫squeda.</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s, despejaremos el camino al crear un nuevo mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y tambi√©n antes de cargar otra tarjeta. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visualizaci√≥n de la ruta se borra nuevamente, como antes de este cambio. </font><font style="vertical-align: inherit;">Pero ahora estamos utilizando un enfoque m√°s eficiente y, en el peor de los casos, el tiempo ha disminuido a 14 milisegundos. </font><font style="vertical-align: inherit;">Suficiente mejora seria solo debido a una limpieza m√°s inteligente. </font><font style="vertical-align: inherit;">El tiempo de montaje disminuy√≥ a 3 ms, que es 333 pps. </font><font style="vertical-align: inherit;">Gracias a esto, la b√∫squeda de rutas es exactamente aplicable en tiempo real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que hemos realizado una b√∫squeda r√°pida de rutas, podemos eliminar el c√≥digo de depuraci√≥n temporal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 18: unidades </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colocamos los escuadrones en el mapa. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar y cargar escuadrones. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontramos formas para las tropas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movemos las unidades. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora que hemos descubierto c√≥mo buscar un camino, ubiquemos los escuadrones en el mapa. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llegaron refuerzos</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creando escuadrones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora hemos tratado solo con c√©lulas y sus objetos fijos. </font><font style="vertical-align: inherit;">Las unidades difieren de ellas en que son m√≥viles. </font><font style="vertical-align: inherit;">Un escuadr√≥n puede significar cualquier cosa de cualquier escala, desde una persona o veh√≠culo hasta un ej√©rcito completo. </font><font style="vertical-align: inherit;">En este tutorial, nos restringimos a un tipo simple de unidad generalizada. </font><font style="vertical-align: inherit;">Despu√©s de eso, pasaremos a las combinaciones de apoyo de varios tipos de unidades.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escuadr√≥n prefabricado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para trabajar con escuadrones, cree un nuevo tipo de componente </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por ahora, comencemos con uno vac√≠o </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego agreguemos funcionalidad.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un objeto de juego vac√≠o con este componente, que deber√≠a convertirse en un prefabricado. </font><font style="vertical-align: inherit;">Este ser√° el objeto ra√≠z del escuadr√≥n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuadr√≥n prefabricado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un modelo 3D que simboliza el desprendimiento como un objeto secundario. </font><font style="vertical-align: inherit;">Utilic√© un cubo escalado simple para el que cre√© material azul. </font><font style="vertical-align: inherit;">El objeto ra√≠z determina el nivel del suelo del desprendimiento, por lo tanto, desplazamos en consecuencia el elemento hijo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemento de cubo secundario</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue un colisionador al escuadr√≥n para que sea m√°s f√°cil seleccionar en el futuro. </font><font style="vertical-align: inherit;">El colisionador del cubo est√°ndar es bastante adecuado para nosotros, solo haga que el colisionador encaje en una celda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear instancias de escuadr√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como todav√≠a no tenemos jugabilidad, la creaci√≥n de unidades se realiza en el modo de edici√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, esto debe abordarse </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para hacer esto, necesita un prefabricado, as√≠ que agregue un campo </font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y con√©ctelo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conectando el prefabricado</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al crear unidades, </font><i><font style="vertical-align: inherit;">las colocaremos</font></i><font style="vertical-align: inherit;"> en la celda debajo del cursor. </font><font style="vertical-align: inherit;">Hay </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un c√≥digo para encontrar esta celda al editar un terreno. </font><font style="vertical-align: inherit;">Ahora tambi√©n lo necesitamos para los escuadrones, por lo que moveremos el c√≥digo correspondiente a un m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar este m√©todo para </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplificarlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { ‚Ä¶ } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, agregue un nuevo m√©todo </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que tambi√©n use </font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si hay una celda, crearemos un nuevo escuadr√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para mantener limpia la jerarqu√≠a, usemos la cuadr√≠cula como padre para todos los objetos del juego en los escuadrones. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de agregar </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soporte para crear unidades es presionando una tecla. </font><font style="vertical-align: inherit;">Cambie el m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que llame </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando presiona la tecla U. Al igual que con c </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esto deber√≠a suceder si el cursor no est√° encima del elemento GUI. </font><font style="vertical-align: inherit;">Primero, verificaremos si debemos editar el mapa, y si no, verificaremos si debemos agregar un escuadr√≥n. </font><font style="vertical-align: inherit;">Si es as√≠, entonces llame </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instancia creada de escuadr√≥n</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colocaci√≥n de tropas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos crear unidades, pero aparecen en el origen del mapa. </font><font style="vertical-align: inherit;">Necesitamos ponerlos en el lugar correcto. </font><font style="vertical-align: inherit;">Para esto, es necesario que las tropas sean conscientes de su posici√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos a la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad que </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denota la celda que ocupan. </font><font style="vertical-align: inherit;">Al establecer la propiedad, cambiaremos la posici√≥n del escuadr√≥n para que coincida con la posici√≥n de la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debo asignar la posici√≥n de la celda del escuadr√≥n debajo del cursor. </font><font style="vertical-align: inherit;">Entonces las unidades estar√°n donde deber√≠an.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuadrones en el mapa</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Orientaci√≥n de la unidad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, todas las unidades tienen la misma orientaci√≥n, lo que parece poco natural. </font><font style="vertical-align: inherit;">Para revivirlos, agr√©guelos a la </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es un valor flotante que indica la rotaci√≥n del escuadr√≥n a lo largo del eje Y en grados. </font><font style="vertical-align: inherit;">Al configurarlo, cambiaremos la rotaci√≥n del objeto del juego.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignar una rotaci√≥n aleatoria de 0 a 360 grados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes orientaciones de la unidad.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un escuadr√≥n por celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las unidades se ven bien si no se crean en una celda. </font><font style="vertical-align: inherit;">En este caso, obtenemos un grupo de cubos de aspecto extra√±o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unidades superpuestas</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunos juegos permiten la colocaci√≥n de varias unidades en un solo lugar, otros no. </font><font style="vertical-align: inherit;">Como es m√°s f√°cil trabajar con un escuadr√≥n por celda, elegir√© esta opci√≥n. </font><font style="vertical-align: inherit;">Esto significa que deber√≠amos crear un nuevo escuadr√≥n solo cuando la celda actual no est√© ocupada. </font><font style="vertical-align: inherit;">Para que pueda averiguarlo, agregue a la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad est√°ndar </font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos esta propiedad </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que la celda sepa si la unidad est√° en ella.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede verificar si la celda actual est√° libre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edici√≥n de celdas ocupadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, las unidades se colocan correctamente, pero todo puede cambiar si sus celdas se editan m√°s tarde. </font><font style="vertical-align: inherit;">Si la altura de la celda cambia, entonces la unidad que la ocupa colgar√° sobre ella o se sumergir√° en ella.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuadrones colgados y ahogados</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La soluci√≥n es verificar la posici√≥n del escuadr√≥n despu√©s de hacer cambios. </font><font style="vertical-align: inherit;">Para hacer esto, agregue el m√©todo a </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hasta ahora, solo estamos interesados ‚Äã‚Äãen la posici√≥n del escuadr√≥n, as√≠ que preg√∫ntelo nuevamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debemos coordinar la posici√≥n del desprendimiento al actualizar la celda, lo que sucede cuando </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">llama a </font><font style="vertical-align: inherit;">los m√©todos </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objetos </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por supuesto, esto es necesario solo cuando realmente hay un desprendimiento en la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminando escuadrones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de crear unidades, ser√≠a √∫til destruirlas. </font><font style="vertical-align: inherit;">Por lo tanto, agregue al </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Debe verificar si hay un destacamento en la celda debajo del cursor, y si es as√≠, destruir el objeto del juego del destacamento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que, para llegar al escuadr√≥n, pasamos por la celda. </font><font style="vertical-align: inherit;">Para interactuar con el escuadr√≥n, simplemente mueva el mouse sobre su celda. </font><font style="vertical-align: inherit;">Por lo tanto, para que esto funcione, el escuadr√≥n no tiene que tener un colisionador. </font><font style="vertical-align: inherit;">Sin embargo, agregar un colisionador facilita la selecci√≥n porque bloquea los rayos que de otra manera colisionar√≠an con la celda detr√°s del escuadr√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usemos </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una combinaci√≥n de Shift + U izquierdo </font><font style="vertical-align: inherit;">para destruir el escuadr√≥n </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso en que creamos y destruimos varias unidades, tengamos cuidado y borremos la propiedad al eliminar la unidad. </font><font style="vertical-align: inherit;">Es decir, borramos expl√≠citamente el enlace de la celda al escuadr√≥n. </font><font style="vertical-align: inherit;">Agregue al </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se ocupa de esto, as√≠ como la destrucci√≥n de su propio objeto de juego.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este m√©todo </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no destruiremos el escuadr√≥n directamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar y cargar escuadrones </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que podemos tener unidades en el mapa, debemos incluirlas en el proceso de guardar y cargar. </font><font style="vertical-align: inherit;">Podemos abordar esta tarea de dos maneras. </font><font style="vertical-align: inherit;">El primero es registrar los datos del escuadr√≥n cuando se graba una celda para que los datos de la celda y el escuadr√≥n se mezclen. </font><font style="vertical-align: inherit;">La segunda forma es guardar los datos de celda y escuadr√≥n por separado. </font><font style="vertical-align: inherit;">Aunque parezca que el primer enfoque es m√°s f√°cil de implementar, el segundo nos proporciona datos m√°s estructurados. </font><font style="vertical-align: inherit;">Si compartimos los datos, ser√° m√°s f√°cil trabajar con ellos en el futuro.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de la unidad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mantener todas las unidades juntas, necesitamos rastrearlas. </font><font style="vertical-align: inherit;">Haremos esto agregando a la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lista de unidades. </font><font style="vertical-align: inherit;">Esta lista debe contener todas las unidades en el mapa.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al crear o cargar un nuevo mapa, necesitamos deshacernos de todas las unidades en el mapa. </font><font style="vertical-align: inherit;">Para simplificar este proceso, cree un m√©todo </font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que mate a todos en la lista y lo borre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamamos a este m√©todo in </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y in </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hag√°moslo despu√©s de limpiar el camino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); ClearUnits(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar escuadrones a la cuadr√≠cula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, al crear nuevas unidades, necesitamos agregarlas a la lista. </font><font style="vertical-align: inherit;">Vamos a establecer un m√©todo para esto </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que tambi√©n se ocupar√° de la ubicaci√≥n del escuadr√≥n y los par√°metros de su objeto padre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° suficiente llamar </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con una nueva instancia del destacamento, su ubicaci√≥n y orientaci√≥n aleatoria.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminar escuadrones de la cuadr√≠cula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo para eliminar el escuadr√≥n y c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Simplemente elimina el escuadr√≥n de la lista y ordena que muera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamamos a este m√©todo </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">en </font><font style="vertical-align: inherit;">lugar de destruir el escuadr√≥n directamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unidades de ahorro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vamos a mantener todas las unidades juntas, debemos recordar qu√© celdas ocupan. </font><font style="vertical-align: inherit;">La forma m√°s confiable es guardar las coordenadas de su ubicaci√≥n. </font><font style="vertical-align: inherit;">Para hacer esto posible, agregamos los </font><font style="vertical-align: inherit;">campos X y Z </font><font style="vertical-align: inherit;">al </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que lo escribe.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora puede registrar las coordenadas y la orientaci√≥n del escuadr√≥n. </font><font style="vertical-align: inherit;">Estos son todos los datos de las unidades que tenemos en este momento.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rastrea las unidades, su m√©todo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registrar√° los datos de las unidades. </font><font style="vertical-align: inherit;">Primero, escriba el n√∫mero total de unidades, y luego rep√°rtalas todas en un bucle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiamos los datos almacenados, por lo que aumentaremos el n√∫mero de versi√≥n </font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a 2. El antiguo c√≥digo de arranque seguir√° funcionando, porque simplemente no leer√° los datos del escuadr√≥n. </font><font style="vertical-align: inherit;">Sin embargo, debe aumentar el n√∫mero de versi√≥n para indicar que hay informaci√≥n de la unidad en el archivo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cargando escuadrones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una estructura, no tiene mucho sentido agregarle el m√©todo habitual </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hag√°moslo un m√©todo est√°tico que lea y devuelva coordenadas almacenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el n√∫mero de unidades es variable, no tenemos unidades preexistentes en las que se puedan cargar datos. </font><font style="vertical-align: inherit;">Podemos crear nuevas instancias de unidades antes de cargar sus datos, pero esto requerir√° que </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creamos instancias de nuevas unidades en el momento del arranque. </font><font style="vertical-align: inherit;">Entonces es mejor dejarlo </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambi√©n usamos el m√©todo est√°tico </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comencemos simplemente leyendo estos escuadrones. </font><font style="vertical-align: inherit;">Para leer el valor del flotador de orientaci√≥n, utilizamos el m√©todo </font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© soltero?</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente paso es crear una instancia de un nuevo escuadr√≥n. </font><font style="vertical-align: inherit;">Sin embargo, para esto necesitamos un enlace al prefabricado de la unidad. </font><font style="vertical-align: inherit;">Para no complicarlo a√∫n, agreguemos un </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo est√°tico </font><font style="vertical-align: inherit;">para esto </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para configurar este enlace, us√©moslo nuevamente </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como lo hicimos con la textura de ruido. </font><font style="vertical-align: inherit;">Cuando necesitemos soportar muchos tipos de unidades, pasaremos a una mejor soluci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasamos el prefabricado de la unidad.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de conectar el campo, ya no necesitamos un enlace directo a </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En cambio, √©l puede usar </font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; ‚Ä¶ void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos crear una instancia del nuevo escuadr√≥n en </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En lugar de devolverlo, podemos usar las coordenadas y la orientaci√≥n cargadas para agregarlo a la cuadr√≠cula. </font><font style="vertical-align: inherit;">Para hacer esto posible, agregue un par√°metro </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al final, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contamos el n√∫mero de unidades y lo usamos para cargar todas las unidades almacenadas, pas√°ndonos a nosotros mismos como argumento adicional.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por supuesto, esto solo funcionar√° para guardar archivos con una versi√≥n no inferior a 2, en versiones m√°s j√≥venes no hay unidades para cargar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos cargar correctamente los archivos de la versi√≥n 2, por lo tanto, </font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aumente el n√∫mero de la versi√≥n compatible a 2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento de tropas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los escuadrones son m√≥viles, por lo que debemos poder moverlos por el mapa. </font><font style="vertical-align: inherit;">Ya tenemos un c√≥digo de b√∫squeda de ruta, pero hasta ahora lo hemos probado solo para lugares arbitrarios. </font><font style="vertical-align: inherit;">Ahora necesitamos eliminar la antigua interfaz de usuario de prueba y crear una nueva interfaz de usuario para la administraci√≥n de escuadrones.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limpieza del editor de mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mover unidades a lo largo de los caminos es parte del juego, no se aplica al editor de mapas. </font><font style="vertical-align: inherit;">Por lo tanto, eliminaremos </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todo el c√≥digo asociado con la b√∫squeda de la ruta.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de eliminar este c√≥digo, ya no tiene sentido dejar el editor activo cuando no estamos en modo de edici√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, en lugar de un campo de seguimiento de modo, simplemente podemos habilitar o deshabilitar el componente </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adem√°s, el editor ahora no tiene que lidiar con las etiquetas de la interfaz de usuario.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; ‚Ä¶ public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como por defecto no estamos en el modo de edici√≥n de mapas, en Despertar desactivaremos el editor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar raycast para buscar la celda actual debajo del cursor es necesario al editar el mapa y para administrar unidades. </font><font style="vertical-align: inherit;">Quiz√°s en el futuro nos sea √∫til para otra cosa. </font><font style="vertical-align: inherit;">Pasemos la l√≥gica de la emisi√≥n de </font><font style="vertical-align: inherit;">rayos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un nuevo m√©todo </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un par√°metro de haz.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede llamar a este m√©todo con el haz del cursor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game UI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para controlar la interfaz de usuario del modo de juego, utilizaremos un nuevo componente. </font><font style="vertical-align: inherit;">Si bien solo se ocupar√° de la selecci√≥n y el movimiento de las unidades. </font><font style="vertical-align: inherit;">Cree un nuevo tipo de componente para √©l </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un enlace a la red es suficiente para que √©l haga su trabajo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue este componente al nuevo objeto del juego en la jerarqu√≠a de la interfaz de usuario. </font><font style="vertical-align: inherit;">No tiene que tener su propio objeto, pero ser√° obvio para nosotros que hay una interfaz de usuario separada para el juego.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juego UI Object</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue un </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como en </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La interfaz de usuario del juego debe estar activada cuando no estamos en modo de edici√≥n. </font><font style="vertical-align: inherit;">Adem√°s, las etiquetas deben incluirse aqu√≠ porque la interfaz de usuario del juego funciona con rutas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue el m√©todo de interfaz de usuario del juego con la lista de eventos del interruptor de modo de edici√≥n. </font><font style="vertical-align: inherit;">Esto significar√° que cuando el jugador cambia el modo, se llaman ambos m√©todos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varios m√©todos de eventos. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastrear celda actual </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependiendo de la situaci√≥n, </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesita saber qu√© celda est√° actualmente debajo del cursor. </font><font style="vertical-align: inherit;">Por lo tanto, le agregamos un campo </font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un m√©todo </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que use el </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haz </font><font style="vertical-align: inherit;">del </font><font style="vertical-align: inherit;">cursor para actualizar este campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al actualizar la celda actual, es posible que necesitemos averiguar si ha cambiado. </font><font style="vertical-align: inherit;">Fuerza para </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver esta informaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selecci√≥n de unidad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de mover un escuadr√≥n, debe seleccionarse y rastrearse. </font><font style="vertical-align: inherit;">Por lo tanto, agregue un campo </font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando intentamos hacer una selecci√≥n, debemos comenzar actualizando la celda actual. </font><font style="vertical-align: inherit;">Si la celda actual es, entonces la unidad que ocupa esta celda se convierte en la unidad seleccionada. </font><font style="vertical-align: inherit;">Si no hay unidad en la celda, entonces no se selecciona ninguna unidad. </font><font style="vertical-align: inherit;">Creemos un m√©todo para esto </font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos damos cuenta de la elecci√≥n de las unidades con un simple clic del mouse. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos un m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que realiza una selecci√≥n cuando se activa el bot√≥n del mouse. Por supuesto, necesitamos ejecutarlo solo cuando el cursor no est√° sobre el elemento GUI.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, aprendimos c√≥mo seleccionar una unidad a la vez con el clic de un mouse. </font><font style="vertical-align: inherit;">Cuando hace clic en una celda vac√≠a, se elimina la selecci√≥n de cualquier unidad. </font><font style="vertical-align: inherit;">Pero mientras no recibamos ninguna confirmaci√≥n visual de esto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B√∫squeda de escuadrones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se selecciona una unidad, podemos usar su ubicaci√≥n como punto de partida para encontrar una ruta. </font><font style="vertical-align: inherit;">Para activar esto, no necesitaremos otro clic del bot√≥n del mouse. </font><font style="vertical-align: inherit;">En su lugar, buscaremos y mostraremos autom√°ticamente el camino entre la posici√≥n del escuadr√≥n y la celda actual. </font><font style="vertical-align: inherit;">Siempre haremos esto </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, excepto cuando se haga la elecci√≥n. </font><font style="vertical-align: inherit;">Para hacer esto, cuando tenemos un destacamento, llamamos al m√©todo </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo actualiza la celda actual y llama </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si hay un punto final. </font><font style="vertical-align: inherit;">Nuevamente usamos una velocidad constante de 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tenga en cuenta que no debemos encontrar una nueva ruta cada vez que actualizamos, sino solo cuando cambia la celda actual. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar un camino para un escuadr√≥n</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora vemos los caminos que aparecen cuando mueve el cursor despu√©s de seleccionar un escuadr√≥n. </font><font style="vertical-align: inherit;">Gracias a esto, es obvio qu√© unidad est√° seleccionada. </font><font style="vertical-align: inherit;">Sin embargo, las rutas no siempre se borran correctamente. </font><font style="vertical-align: inherit;">Primero, borremos la ruta anterior si el cursor est√° fuera del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esto requiere que </font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sea ‚Äã‚Äãcom√∫n, por lo que hacemos un cambio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En segundo lugar, despejaremos el viejo camino al elegir un destacamento. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finalmente, despejaremos el camino al cambiar el modo de edici√≥n. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buscar solo puntos finales v√°lidos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No siempre podemos encontrar el camino, porque a veces es imposible llegar a la celda final. </font><font style="vertical-align: inherit;">Esto es normal </font><font style="vertical-align: inherit;">Pero a veces la celda final en s√≠ misma es inaceptable. </font><font style="vertical-align: inherit;">Por ejemplo, decidimos que los caminos no pueden incluir c√©lulas submarinas. </font><font style="vertical-align: inherit;">Pero puede depender de la unidad. </font><font style="vertical-align: inherit;">Agreguemos a un </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que nos dice si una celda es un punto final v√°lido. </font><font style="vertical-align: inherit;">Las c√©lulas submarinas no lo son.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, permitimos que solo una unidad permanezca en la celda. </font><font style="vertical-align: inherit;">Por lo tanto, la celda final no ser√° v√°lida si est√° ocupada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos este m√©todo </font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ignorar los puntos finales no v√°lidos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moverse al punto final </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tenemos una ruta v√°lida, entonces podemos mover el escuadr√≥n al punto final. </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sabe cu√°ndo se puede hacer esto. </font><font style="vertical-align: inherit;">Hacemos que pase esta informaci√≥n en una nueva propiedad de solo lectura </font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mover un escuadr√≥n, agregue al </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo se llamar√° cuando se emita un comando y si se selecciona una unidad. </font><font style="vertical-align: inherit;">Por lo tanto, debe verificar si hay una manera y, de ser as√≠, cambiar la ubicaci√≥n del destacamento. </font><font style="vertical-align: inherit;">Mientras teletransportamos de inmediato al escuadr√≥n hasta el punto final. </font><font style="vertical-align: inherit;">En uno de los siguientes tutoriales, haremos que el escuadr√≥n vaya realmente hasta el final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usemos el bot√≥n del mouse 1 (clic derecho) para enviar el comando. </font><font style="vertical-align: inherit;">Lo comprobaremos si se selecciona un destacamento. </font><font style="vertical-align: inherit;">Si no se presiona el bot√≥n, buscamos la ruta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora podemos mover unidades! </font><font style="vertical-align: inherit;">Pero a veces se niegan a encontrar el camino a algunas c√©lulas. </font><font style="vertical-align: inherit;">En particular, a aquellas celdas en las que sol√≠a estar el desprendimiento. </font><font style="vertical-align: inherit;">Esto sucede porque </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no actualiza la ubicaci√≥n anterior al configurar una nueva. </font><font style="vertical-align: inherit;">Para solucionar esto, borraremos el enlace al escuadr√≥n en su ubicaci√≥n anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar escuadrones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar el camino ahora funciona correctamente y las unidades pueden teletransportarse en el mapa. </font><font style="vertical-align: inherit;">Aunque no pueden pasar a celdas que ya tienen un escuadr√≥n, se ignoran los destacamentos que se interponen en el camino.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las unidades en el camino se ignoran. Las</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unidades de la misma facci√≥n generalmente pueden moverse entre s√≠, pero hasta ahora no tenemos facciones. </font><font style="vertical-align: inherit;">Por lo tanto, consideremos todas las unidades como desconectadas entre s√≠ y bloqueando los caminos. </font><font style="vertical-align: inherit;">Esto se puede implementar saltando las celdas ocupadas </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evita destacamentos </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 19: Animaci√≥n de movimiento </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimos las unidades entre las celdas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualiza el camino recorrido. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimos a las tropas a lo largo de las curvas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obligamos a las tropas a mirar en la direcci√≥n del movimiento. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En esta parte, forzaremos a las unidades en lugar de teletransportarse a moverse a lo largo de las pistas. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escuadrones en camino</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento en el camino </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte anterior, agregamos unidades y la capacidad de moverlas. </font><font style="vertical-align: inherit;">Aunque utilizamos una b√∫squeda del camino para determinar los puntos finales v√°lidos, despu√©s de dar el comando, las tropas simplemente se teletransportaron a la celda final. </font><font style="vertical-align: inherit;">Para que realmente sigan el camino encontrado, necesitamos rastrear este camino y crear un proceso de animaci√≥n que obligue al escuadr√≥n a moverse de una celda a otra. </font><font style="vertical-align: inherit;">Dado que mirar las animaciones es dif√≠cil notar c√≥mo se movi√≥ el escuadr√≥n, tambi√©n visualizamos el camino recorrido con la ayuda de artilugios. </font><font style="vertical-align: inherit;">Pero antes de continuar, debemos corregir el error.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Error con vueltas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a un descuido, calculamos incorrectamente el curso en el que se alcanzar√° la celda. </font><font style="vertical-align: inherit;">Ahora determinamos el rumbo dividiendo la distancia total por la velocidad del escuadr√≥n</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-5"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y descartando el resto. </font><font style="vertical-align: inherit;">El error ocurre cuando para ingresar a la celda necesitas gastar exactamente todos los puntos de movimiento restantes por movimiento. </font><font style="vertical-align: inherit;">Por ejemplo, cuando cada paso cuesta 1 y la velocidad es 3, entonces podemos mover tres celdas por turno. </font><font style="vertical-align: inherit;">Sin embargo, con los c√°lculos existentes, solo podemos dar dos pasos en el primer movimiento, porque para el tercer paso</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.407ex" height="2.66ex" viewBox="0 -832 3189.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-73" x="2719" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">t = d / s</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s </font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-21"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.254ex" height="2.66ex" viewBox="0 -832 7859.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-73" x="2719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="3466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-33" x="4523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2F" x="5023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-33" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="6302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-31" x="7358" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">t = d / s = 3 / 3 = 1</script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los costos sumados de moverse con movimientos incorrectamente definidos, velocidad 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para el c√°lculo correcto de los movimientos necesitamos mover el borde un paso desde la celda inicial. </font><font style="vertical-align: inherit;">Podemos hacer esto reduciendo la distancia en 1 antes de calcular el movimiento. Luego, el movimiento para el tercer paso ser√°</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.686ex" height="2.66ex" viewBox="0 -832 5031.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-32" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2F" x="2196" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-33" x="2696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="3474" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-30" x="4531" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimientos correctos</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos hacer esto cambiando la f√≥rmula de c√°lculo a</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.219ex" height="2.66ex" viewBox="0 -832 5691.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-28" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-64" x="2085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2212" x="2830" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-31" x="3831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-29" x="4332" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2F" x="4721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-73" x="5222" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">t = (d - 1) / s</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haremos este cambio a </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n cambiamos las marcas de los movimientos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; ‚Ä¶ } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que con este enfoque, la ruta de la celda inicial es -1. </font><font style="vertical-align: inherit;">Esto es normal, porque no lo mostramos, y el algoritmo de b√∫squeda permanece operativo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Camino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moverse por el camino es tarea del escuadr√≥n. </font><font style="vertical-align: inherit;">Para que pueda hacer esto, necesita saber el camino. </font><font style="vertical-align: inherit;">Tenemos esta informaci√≥n </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ que agreguemos un m√©todo para obtener la ruta actual en forma de una lista de celdas. </font><font style="vertical-align: inherit;">Puede tomarlo del grupo de listas y regresar si realmente hay un camino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La lista se completa siguiendo la ruta de enlace desde la celda final a la inicial, como se hace al visualizar la ruta. </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En este caso, necesitamos toda la ruta, que incluye la celda inicial. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos el camino en el orden inverso. </font><font style="vertical-align: inherit;">Podemos trabajar con √©l, pero no ser√° muy intuitivo. </font><font style="vertical-align: inherit;">Volteemos la lista para que vaya de principio a fin.</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solicitud de movimiento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos agregar al </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo, orden√°ndole que siga el camino. </font><font style="vertical-align: inherit;">Inicialmente, simplemente lo dejamos teletransportarse a la celda final. </font><font style="vertical-align: inherit;">No devolveremos de inmediato la lista al grupo, porque nos ser√° √∫til por un tiempo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para solicitar movimiento, lo cambiamos </font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que llame a un nuevo m√©todo con la ruta actual, y no solo establece la ubicaci√≥n de la unidad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizaci√≥n del camino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar a animar al escuadr√≥n, verifiquemos que los caminos sean correctos. </font><font style="vertical-align: inherit;">Haremos esto ordenando </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recordar la ruta a lo largo de la cual debe moverse, para que pueda visualizarse usando gizmos.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mostrar la √∫ltima ruta a seguir (si existe). </font><font style="vertical-align: inherit;">Si la unidad a√∫n no se ha movido, la ruta debe ser igual </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero debido a la serializaci√≥n de Unity durante la edici√≥n despu√©s de la compilaci√≥n en modo Play, tambi√©n puede ser una lista vac√≠a.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de mostrar el camino es dibujar una esfera de artilugios para cada celda del camino. </font><font style="vertical-align: inherit;">Una esfera con un radio de 2 unidades es adecuada para nosotros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como mostraremos los caminos para el destacamento, podremos ver simult√°neamente todos sus √∫ltimos caminos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gizmos muestra los √∫ltimos caminos recorridos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para mostrar mejor las conexiones de las celdas, dibujamos varias esferas en un bucle en una l√≠nea entre las celdas anteriores y actuales. </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos comenzar el proceso desde la segunda celda. </font><font style="vertical-align: inherit;">Las esferas se pueden organizar mediante interpolaci√≥n lineal con un incremento de 0.1 unidades, de modo que obtenemos diez esferas por segmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formas m√°s obvias</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deslizarse por el camino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puedes usar el mismo m√©todo para mover unidades. </font><font style="vertical-align: inherit;">Creemos una rutina para esto. </font><font style="vertical-align: inherit;">En lugar de dibujar un artilugio, estableceremos la posici√≥n del escuadr√≥n. </font><font style="vertical-align: inherit;">En lugar de incrementar, usaremos 0.1 delta de tiempo, y realizaremos el rendimiento para cada iteraci√≥n. </font><font style="vertical-align: inherit;">En este caso, el escuadr√≥n se mover√° de una celda a la siguiente en un segundo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos la rutina al final del m√©todo </font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero primero, detendremos todas las corutinas existentes. </font><font style="vertical-align: inherit;">Por lo tanto, garantizamos que dos corutinas no comenzar√°n al mismo tiempo, de lo contrario, esto conducir√≠a a resultados muy extra√±os.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mover una celda por segundo es bastante lento. </font><font style="vertical-align: inherit;">El jugador durante el juego no querr√° esperar tanto. </font><font style="vertical-align: inherit;">Puedes hacer que la velocidad de movimiento del escuadr√≥n sea una opci√≥n de configuraci√≥n, pero por ahora, usemos una constante. </font><font style="vertical-align: inherit;">Le asign√© un valor de 4 celdas por segundo; </font><font style="vertical-align: inherit;">es bastante r√°pido, pero notemos lo que est√° sucediendo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ como podemos visualizar varios caminos simult√°neamente, podemos hacer que varias unidades viajen al mismo tiempo. </font><font style="vertical-align: inherit;">Desde el punto de vista del estado del juego, el movimiento sigue siendo teletransportador, las animaciones son exclusivamente visuales. </font><font style="vertical-align: inherit;">Las unidades ocupan instant√°neamente la celda final. </font><font style="vertical-align: inherit;">Incluso puedes encontrar formas y comenzar un nuevo movimiento antes de que lleguen. </font><font style="vertical-align: inherit;">En este caso, se teletransportan visualmente al comienzo de un nuevo camino. </font><font style="vertical-align: inherit;">Esto puede evitarse bloqueando unidades o incluso toda la interfaz de usuario mientras se mueven, pero una reacci√≥n tan r√°pida es bastante conveniente al desarrollar y probar movimientos.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unidades m√≥viles </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa con la diferencia de altura?</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posici√≥n despu√©s de la compilaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno de los inconvenientes de la corutina es que no "sobreviven" cuando se vuelven a compilar en el modo Play. </font><font style="vertical-align: inherit;">Aunque el estado del juego siempre es cierto, esto puede llevar a que los escuadrones se atasquen en alg√∫n lugar de su √∫ltimo camino si la recompilaci√≥n se inicia mientras todav√≠a se est√°n moviendo. </font><font style="vertical-align: inherit;">Para mitigar las consecuencias, asegur√©monos de que, despu√©s de la compilaci√≥n, las unidades est√©n siempre en la posici√≥n correcta. </font><font style="vertical-align: inherit;">Esto se puede hacer actualizando su posici√≥n en </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento suave </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El movimiento desde el centro hacia el centro de la celda parece demasiado mecanicista y crea cambios bruscos de direcci√≥n. </font><font style="vertical-align: inherit;">Para muchos juegos, esto ser√° normal, pero inaceptable si necesita al menos un movimiento ligeramente realista. </font><font style="vertical-align: inherit;">As√≠ que cambiemos el movimiento para que se vea un poco m√°s org√°nico.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movi√©ndose de costilla a costilla </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El escuadr√≥n comienza su viaje desde el centro de la celda. </font><font style="vertical-align: inherit;">Pasa al centro del borde de la celda y luego ingresa a la siguiente celda. </font><font style="vertical-align: inherit;">En lugar de moverse hacia el centro, puede dirigirse directamente hacia el siguiente borde que debe cruzar. </font><font style="vertical-align: inherit;">De hecho, la unidad cortar√° el camino cuando necesite cambiar de direcci√≥n. </font><font style="vertical-align: inherit;">Esto es posible para todas las celdas, excepto los puntos finales de la ruta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres formas de moverse de borde a borde</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos a adaptarnos </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a mostrar las rutas generadas de esta manera. </font><font style="vertical-align: inherit;">Debe interpolar entre los bordes de las celdas, lo que se puede encontrar promediando las posiciones de las celdas vecinas. </font><font style="vertical-align: inherit;">Es suficiente para nosotros calcular un borde por iteraci√≥n, reutilizando el valor de la iteraci√≥n anterior. </font><font style="vertical-align: inherit;">Por lo tanto, podemos hacer que el m√©todo funcione para la celda inicial, pero en lugar del borde tomamos su posici√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para llegar al centro de la celda final, necesitamos usar la posici√≥n de la celda como el √∫ltimo punto, no el borde. </font><font style="vertical-align: inherit;">Puede agregar la verificaci√≥n de este caso al bucle, pero es un c√≥digo tan simple que ser√° m√°s obvio simplemente duplicar el c√≥digo y cambiarlo ligeramente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rutas basadas en costillas Las</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rutas resultantes son menos como zigzags, y el √°ngulo de giro m√°ximo se reduce de 120 ¬∞ a 90 ¬∞. </font><font style="vertical-align: inherit;">Esto puede considerarse una mejora, por lo que aplicamos los mismos cambios en la rutina </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ver c√≥mo se ve en la animaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moverse con una velocidad cambiante</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de cortar los √°ngulos, la longitud de los segmentos de la ruta se volvi√≥ dependiente del cambio de direcci√≥n. </font><font style="vertical-align: inherit;">Pero establecemos la velocidad en celdas por segundo. </font><font style="vertical-align: inherit;">Como resultado, la velocidad de desprendimiento cambia aleatoriamente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Siguientes curvas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los cambios instant√°neos en la direcci√≥n y la velocidad al cruzar los l√≠mites de las celdas se ven feos. </font><font style="vertical-align: inherit;">Mejor usar un cambio gradual de direcci√≥n. </font><font style="vertical-align: inherit;">Podemos agregar apoyo para esto al obligar a las tropas a seguir a lo largo de curvas en lugar de l√≠neas rectas. </font><font style="vertical-align: inherit;">Puedes usar curvas de Bezier para esto. </font><font style="vertical-align: inherit;">En particular, podemos tomar curvas de Bezier cuadr√°ticas en las que el centro de las celdas ser√°n los puntos de control intermedios. </font><font style="vertical-align: inherit;">En este caso, las tangentes de las curvas adyacentes ser√°n im√°genes especulares entre s√≠, es decir, todo el camino se convertir√° en una curva suave continua.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curvas de borde a borde</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cree una clase auxiliar </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un m√©todo para obtener puntos en una curva de Bezier cuadr√°tica. </font><font style="vertical-align: inherit;">Como se explica en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial Curves and Splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la f√≥rmula se usa para esto</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-49" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A </font></font></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.208ex" height="2.901ex" viewBox="0 -935.7 12575.6 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2212" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="2112" y="0"></use><g transform="translate(2474,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-32" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-41" x="3317" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2B" x="4290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-32" x="5291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-28" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-31" x="6181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2212" x="6904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="7904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-29" x="8266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="8655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-42" x="9017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-2B" x="9998" y="0"></use><g transform="translate(10999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMAIN-32" x="511" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-43" x="11815" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script>  donde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.057ex" viewBox="0 -780.1 750.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-41" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> A </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhjHp7ZjQKL-dly4geyPPLuI5nOMUA#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> B </script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son los puntos de control, y t es el interpolador.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8">C</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo deber√≠a limitarse GetPoint a 0-1?</font></font></b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar la trayectoria de la curva </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, necesitamos rastrear no dos, sino tres puntos. </font><font style="vertical-align: inherit;">Un punto adicional es el centro de la celda con la que estamos trabajando en la iteraci√≥n actual, que tiene un √≠ndice </font></font><code>i - 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque el ciclo comienza con 1. Habiendo recibido todos los puntos, podemos reemplazarlo </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>Bezier.GetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En las celdas de inicio y fin, en lugar de los puntos final y medio, simplemente podemos usar el centro de la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rutas creadas con curvas de Bezier Una</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ruta </font><i><font style="vertical-align: inherit;">curva se</font></i><font style="vertical-align: inherit;"> ve mucho mejor. </font><font style="vertical-align: inherit;">Aplicamos los mismos cambios </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y vemos c√≥mo se animan las unidades con este enfoque.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos movemos a lo largo de las curvas. La</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> animaci√≥n tambi√©n se suaviz√≥, incluso cuando la velocidad del desprendimiento es inestable. </font><font style="vertical-align: inherit;">Como las tangentes de la curva de los segmentos adyacentes coinciden, la velocidad es continua. </font><font style="vertical-align: inherit;">El cambio en la velocidad ocurre gradualmente y ocurre cuando un desprendimiento pasa a trav√©s de la celda, disminuyendo la velocidad al cambiar de direcci√≥n. </font><font style="vertical-align: inherit;">Si va derecho, entonces la velocidad permanece constante. </font><font style="vertical-align: inherit;">Adem√°s, el escuadr√≥n comienza y termina su viaje a velocidad cero. </font><font style="vertical-align: inherit;">Esto imita el movimiento natural, as√≠ que d√©jalo as√≠.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de tiempo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta este punto, comenzamos a iterar sobre cada uno de los segmentos desde 0, continuando hasta llegar a 1. Esto funciona bien cuando aumenta en un valor constante, pero nuestra iteraci√≥n depende del tiempo delta. Cuando se completa la iteraci√≥n sobre un segmento, es probable que excedamos 1 en cierta cantidad, dependiendo del delta de tiempo. Esto es invisible a velocidades de cuadro altas, pero puede provocar sacudidas a velocidades de cuadro bajas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar la p√©rdida de tiempo, necesitamos transferir el tiempo restante de un segmento al siguiente. Esto se puede hacer rastreando a lo </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">largo de toda la ruta, y no solo en cada segmento. Luego, al final de cada segmento, restaremos 1 de √©l.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ya estamos haciendo esto, asegur√©monos de que el tiempo delta se tenga en cuenta al comienzo de la ruta. </font><font style="vertical-align: inherit;">Esto significa que comenzaremos a movernos de inmediato y no estaremos inactivos durante un fotograma.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, no terminamos exactamente en el momento en que la ruta deber√≠a terminar, sino momentos antes. </font><font style="vertical-align: inherit;">Aqu√≠, la diferencia tambi√©n puede depender de la velocidad de fotogramas. </font><font style="vertical-align: inherit;">Por lo tanto, hagamos que el escuadr√≥n complete el camino exactamente en el punto final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animaci√≥n de orientaci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las unidades comenzaron a moverse a lo largo de una curva suave, pero no cambiaron la orientaci√≥n de acuerdo con la direcci√≥n del movimiento. </font><font style="vertical-align: inherit;">Como resultado, parecen deslizarse. </font><font style="vertical-align: inherit;">Para que el movimiento parezca un movimiento real, necesitamos rotarlos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mirando hacia adelante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial Curvas y Splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , podemos usar la derivada de la curva para determinar la orientaci√≥n de la unidad. </font><font style="vertical-align: inherit;">La f√≥rmula para la derivada de una curva de Bezier cuadr√°tica:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mn" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-75"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font></span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-91" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">2 ((1 - t) (B - A) + t (C - B))</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo para calcularlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El vector derivado se encuentra en una l√≠nea recta con la direcci√≥n del movimiento. </font><font style="vertical-align: inherit;">Podemos usar el m√©todo </font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para convertirlo en un turno de escuadr√≥n. </font><font style="vertical-align: inherit;">Lo llevaremos a cabo en cada paso </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo hay ning√∫n error al comienzo del camino?</font></font></b> <div class="spoiler_text">    ,        .    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">A</span></span></span><script type="math/tex" id="MathJax-Element-10"> A </script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">B</span></span></span><script type="math/tex" id="MathJax-Element-11"> B </script>  ,    .   ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">t</span><span class="MJXp-mo" id="MJXp-Span-98" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-99">0</span></span></span><script type="math/tex" id="MathJax-Element-12">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">t</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-103">0</span></span></span><script type="math/tex" id="MathJax-Element-13">t = 0</script>   .     .       ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">t</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-107">0</span></span></span><script type="math/tex" id="MathJax-Element-14">t > 0</script>    . <br>         ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-111">1</span></span></span><script type="math/tex" id="MathJax-Element-15">t < 1</script>  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En contraste con la posici√≥n del destacamento, la no idealidad de su orientaci√≥n al final del camino no es importante. </font><font style="vertical-align: inherit;">sin embargo, debemos asegurarnos de que su orientaci√≥n corresponda a la rotaci√≥n final. </font><font style="vertical-align: inherit;">Para hacer esto, despu√©s de la finalizaci√≥n, equiparamos su orientaci√≥n a su rotaci√≥n en Y.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora las unidades miran exactamente en la direcci√≥n del movimiento, tanto horizontal como verticalmente. </font><font style="vertical-align: inherit;">Esto significa que se inclinar√°n hacia adelante y hacia atr√°s, descendiendo de las laderas y subi√©ndolos. </font><font style="vertical-align: inherit;">Para asegurarnos de que siempre est√©n rectos, forzamos el componente Y del vector de direcci√≥n a cero antes de usarlo para determinar la rotaci√≥n de la unidad.</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); ‚Ä¶ Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mirando hacia adelante mientras te mueves</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nos fijamos en el punto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lo largo del camino, las unidades est√°n mirando hacia adelante, pero antes de comenzar a moverse, pueden mirar en la otra direcci√≥n. En este caso, cambian instant√°neamente su orientaci√≥n. Ser√° mejor si giran en la direcci√≥n del camino antes del inicio del movimiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mirar en la direcci√≥n correcta puede ser √∫til en otras situaciones, as√≠ que creemos un m√©todo </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que obligue al escuadr√≥n a cambiar de orientaci√≥n para mirar un cierto punto. La rotaci√≥n requerida se puede establecer utilizando el m√©todo </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primero colocando el punto en la misma posici√≥n vertical que el desprendimiento. Despu√©s de eso, podemos recuperar la orientaci√≥n del escuadr√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que el desprendimiento realmente gire, convertiremos el m√©todo en otra corutina que lo rotar√° a una velocidad constante. La velocidad de giro tambi√©n se puede ajustar, pero usaremos la constante nuevamente. La rotaci√≥n debe ser r√°pida, aproximadamente 180 ¬∞ por segundo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No es necesario jugar con la aceleraci√≥n del giro, porque es imperceptible. Ser√° suficiente para nosotros simplemente interpolar entre las dos orientaciones. Desafortunadamente, esto no es tan simple como en el caso de dos n√∫meros, porque los √°ngulos son circulares. Por ejemplo, una transici√≥n de 350 ¬∞ a 10 ¬∞ deber√≠a dar como resultado una rotaci√≥n de 20 ¬∞ en sentido horario, pero una interpolaci√≥n simple forzar√° una rotaci√≥n de 340 ¬∞ en sentido antihorario. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de crear una rotaci√≥n correcta es interpolar entre dos cuaterniones mediante interpolaci√≥n esf√©rica. Esto conducir√° al turno m√°s corto. Para hacer esto, obtenemos los cuaterniones del principio y el final, y luego hacemos una transici√≥n entre ellos usando </font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto funcionar√°, pero la interpolaci√≥n siempre va de 0 a 1, independientemente del √°ngulo de rotaci√≥n. </font><font style="vertical-align: inherit;">Para garantizar una velocidad angular uniforme, debemos reducir la velocidad de la interpolaci√≥n a medida que aumenta el √°ngulo de rotaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conociendo el √°ngulo, podemos omitir por completo el giro si resulta ser cero. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ‚Ä¶ ) { ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos agregar la rotaci√≥n de la unidad </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente realizando rendimiento antes de mover la </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posici√≥n de la segunda celda. </font><font style="vertical-align: inherit;">Unity lanzar√° autom√°ticamente la rutina </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar√° a que se complete.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si verifica el c√≥digo, el escuadr√≥n se teletransporta a la celda final, gira all√≠ y luego se teletransporta al comienzo del camino y comienza a moverse desde all√≠. </font><font style="vertical-align: inherit;">Esto sucede porque asignamos un valor a una propiedad </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes del comienzo de la rutina </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para deshacernos de la teletransportaci√≥n, al principio podemos </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver la posici√≥n del desprendimiento a la celda inicial.</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gire antes de moverse</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo recibido el movimiento que necesitamos, podemos deshacernos del m√©todo </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Elim√≠nelo o comente en caso de que necesitemos ver rutas en el futuro.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // ‚Ä¶ // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya no necesitamos recordar en qu√© direcci√≥n nos mov√≠amos, al final </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede liberar la lista de celdas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa con las animaciones de escuadrones reales?</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426481/">https://habr.com/ru/post/es426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426471/index.html">C√≥mo se filtran los datos de spyware</a></li>
<li><a href="../es426473/index.html">Arquitectura de Redux. Si o no</a></li>
<li><a href="../es426475/index.html">Miya - asistente desde el tel√©fono inteligente</a></li>
<li><a href="../es426477/index.html">Toda la verdad sobre RTOS. Art√≠culo # 15. Particiones de memoria: servicios y estructuras de datos</a></li>
<li><a href="../es426479/index.html">Banco de pruebas casero para placas base</a></li>
<li><a href="../es426483/index.html">Uno que supera a Tesla. Para m√°s rentable</a></li>
<li><a href="../es426485/index.html">Tercera prueba Qt 5 con PVS-Studio</a></li>
<li><a href="../es426487/index.html">Prueba de automatizaci√≥n desde cero. Parte 1</a></li>
<li><a href="../es426489/index.html">Sobre la relaci√≥n de n√∫meros primos e irracionales</a></li>
<li><a href="../es426491/index.html">Semana de la seguridad 39: a la muerte de Google+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>