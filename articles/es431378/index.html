<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî° üßòüèø üë©üèΩ‚Äçüé® Toda la verdad sobre RTOS. Art√≠culo 23. Colas: introducci√≥n y servicios b√°sicos. üëßüèΩ üñ•Ô∏è üì®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las colas se mencionaron en uno de los art√≠culos anteriores (# 5). Proporcionan una forma m√°s flexible de transferir mensajes simples entre tareas en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo 23. Colas: introducci√≥n y servicios b√°sicos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431378/"><img src="https://habrastorage.org/webt/oy/fg/jv/oyfgjvk1xivp4zfhajjwfzycshs.jpeg"><br><br>  Las colas se mencionaron en uno de los art√≠culos anteriores (# 5).  Proporcionan una forma m√°s flexible de transferir mensajes simples entre tareas en comparaci√≥n con los buzones. <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se√±ales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <br><br><h2>  Usar colas </h2><br>  En Nucleus SE, las colas se definen durante la fase de construcci√≥n.  Una aplicaci√≥n puede tener hasta 16 colas.  Si no hay colas en la aplicaci√≥n, ni las estructuras de datos ni el c√≥digo de servicio relacionado con las colas se incluyen en la aplicaci√≥n. <br><br>  Una cola es un conjunto de √°reas en la memoria que son lo suficientemente grandes para un elemento de tipo <b>ADDR</b> y a las que se puede acceder de forma segura para que varias tareas puedan usarlo.  Las tareas pueden escribir datos en la cola hasta que todas las √°reas est√©n llenas.  Las tareas pueden leer datos de la cola, y los datos generalmente entran en una FIFO (Primero en entrar, primero en salir).  Intentar escribir datos en una cola llena o leer datos de una cola vac√≠a puede provocar un error o una pausa en la tarea, dependiendo de los par√°metros de llamada API seleccionados y la configuraci√≥n de Nucleus SE. <br><br><h2>  Colas y enlaces de datos </h2><br>  Nucleus SE admite canales de datos, que tambi√©n se mencionaron en un art√≠culo anterior (n. ¬∞ 5) y se analizar√°n en detalle en uno de los siguientes.  La principal diferencia entre colas y canales es el tama√±o del mensaje.  Las colas contienen mensajes que consisten en una sola variable del tipo <b>ADDR</b> (generalmente punteros).  El canal contiene mensajes de un tama√±o arbitrario, individual para cada canal en la aplicaci√≥n y asignado durante la configuraci√≥n de par√°metros. <br><br><h2>  Configuraci√≥n de cola </h2><br><h3>  Numero de colas </h3><br>  Como con la mayor√≠a de los objetos de Nucleus SE, la configuraci√≥n de la cola est√° controlada principalmente por las directivas <b>#define</b> en el archivo <b>nuse_config.h</b> .  El par√°metro principal es <b>NUSE_QUEUE_NUMBER</b> , que determina el n√∫mero de colas configuradas en la aplicaci√≥n.  El valor predeterminado es cero (es decir, no hay colas en la aplicaci√≥n) y puede tomar valores hasta 16. Un valor incorrecto generar√° un error durante la compilaci√≥n, que se generar√° durante la verificaci√≥n en el archivo <b>nuse_config_check.h</b> (se incluye en el archivo <b>nuse_config.c</b> y se compila junto con √©l), que activar√° la directiva <b>#error</b> . <br><br>  La selecci√≥n de un valor distinto de cero sirve como activador principal para las colas.  Este par√°metro se utiliza al definir estructuras de datos y su tama√±o depende de su valor (m√°s sobre esto en el pr√≥ximo art√≠culo).  Adem√°s, un valor distinto de cero activa la configuraci√≥n de la API. <br><br><h3>  Activar llamadas API </h3><br>  Cada funci√≥n API (llamada de utilidad) en Nucleus SE tiene una directiva activadora <b>#define</b> en <b>nuse_config.h</b> .  Para las colas, estas directivas son: <br><br><pre><code class="plaintext hljs">NUSE_QUEUE_SEND NUSE_QUEUE_RECEIVE NUSE_QUEUE_JAM NUSE_QUEUE_RESET NUSE_QUEUE_INFORMATION NUSE_QUEUE_COUNT</code> </pre> <br>  Por defecto, est√°n configurados en <b>FALSO</b> , deshabilitando as√≠ todas las llamadas de servicio y bloqueando la inclusi√≥n de c√≥digo que las implementa.  Para configurar las colas en la aplicaci√≥n, debe seleccionar las llamadas API necesarias y establecerlas en <b>TRUE</b> . <br><br>  El siguiente es un fragmento de c√≥digo del archivo <b>nuse_config.h</b> : <br><br><pre> <code class="plaintext hljs">#define NUSE_QUEUE_NUMBER 0 /* Number of queues in the system - 0-16 */ /* Service call enablers */ #define NUSE_QUEUE_SEND FALSE #define NUSE_QUEUE_RECEIVE FALSE #define NUSE_QUEUE_JAM FALSE #define NUSE_QUEUE_RESET FALSE #define NUSE_QUEUE_INFORMATION FALSE #define NUSE_QUEUE_COUNT FALSE</code> </pre><br>  Si las funciones de la API de cola est√°n activadas, pero no hay colas en la aplicaci√≥n (excepto <b>NUSE_Queue_Count ()</b> , que siempre est√° habilitada), aparecer√° un error de compilaci√≥n.  Si su c√≥digo usa una llamada API que no se ha activado, esto causar√° un error de dise√±o porque el c√≥digo de implementaci√≥n no se incluy√≥ en la aplicaci√≥n. <br><br><h2>  Llamada en cola </h2><br>  Nucleus RTOS admite diez llamadas de servicio de cola que proporcionan la siguiente funcionalidad: <br><br><ul><li>  Poner en cola un mensaje.  Nucleus SE se implementa en la funci√≥n <b>NUSE_Queue_Send ()</b> . </li><li>  Aceptar un mensaje de la cola.  Nucleus SE implementa la funci√≥n <b>NUSE_Queue_Receive ()</b> . </li><li>  Publicando en la cabecera de la cola.  En Nucleus SE, implementado en <b>NUSE_Queue_Jam ()</b> . </li><li>  Restaurar la cola a un estado no utilizado con la liberaci√≥n de todas las tareas suspendidas (restablecer).  Nucleus SE se implementa en <b>NUSE_Queue_Reset ()</b> . </li><li>  Proporcionar informaci√≥n sobre una cola espec√≠fica.  Nucleus SE implementado en <b>NUSE_Queue_Information ()</b> . </li><li>  Devuelve el n√∫mero de colas configuradas actualmente en la aplicaci√≥n.  En Nucleus SE, implementado en <b>NUSE_Queue_Count ()</b> . </li><li>  Agregar una nueva cola a la aplicaci√≥n (crear una cola).  Nucleus SE no est√° implementado. </li><li>  Eliminar una cola de una aplicaci√≥n.  Nucleus SE no est√° implementado. </li><li>  Devuelva los punteros a todas las colas en la aplicaci√≥n.  Nucleus SE no est√° implementado. </li><li>  Enviar un mensaje a todas las tareas suspendidas en la cola (difusi√≥n).  Nucleus SE no est√° implementado. </li></ul><br>  La implementaci√≥n de cada una de estas llamadas generales se describe en detalle a continuaci√≥n. <br><br><h2>  Servicio de llamadas para escribir y leer desde colas </h2><br>  Las operaciones b√°sicas que se realizan en las colas son la escritura (que a veces se denomina mensajes de cola) y la lectura (tambi√©n conocida como recepci√≥n de mensajes).  Tambi√©n es posible escribir al comienzo de la cola (interferencia).  Nucleus RTOS y Nucleus SE proporcionan tres llamadas API b√°sicas para estas operaciones, que se analizar√°n a continuaci√≥n. <br><br><h3>  Haciendo cola </h3><br>  La llamada a la utilidad de la API Nucleus RTOS para escribir en la cola es muy flexible y le permite pausar la tarea impl√≠citamente, o con un tiempo de espera espec√≠fico si la operaci√≥n no puede completarse de inmediato (por ejemplo, al intentar escribir en una cola completa).  Nucleus SE ofrece las mismas caracter√≠sticas, pero la pausa de tareas es opcional y no se implementa un tiempo de espera. <br><br>  <b><i>Cola de llamadas en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Send_To_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> : un puntero al bloque de control de cola proporcionado por el usuario; <br>  <b>mensaje</b> - puntero al mensaje a enviar; <br>  <b>tama√±o</b> : el n√∫mero de elementos de datos <b>NO FIRMADOS</b> en el mensaje.  Si la cola admite mensajes de longitud variable, este par√°metro debe ser igual al tama√±o del mensaje o menor que el tama√±o del mensaje admitido por la cola.  Si la cola admite mensajes de un tama√±o fijo, este par√°metro debe coincidir exactamente con el tama√±o del mensaje admitido por la cola; <br>  <b>suspender</b> : la especificaci√≥n de la suspensi√≥n de la tarea, puede tomar los valores <b>NU_NO_SUSPEND</b> o <b>NU_SUSPEND</b> o un valor de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : el tama√±o del mensaje es incompatible con el tama√±o del mensaje admitido por la cola; <br>  <b>NU_INVALID_SUSPEND</b> : la suspensi√≥n se realiz√≥ desde un hilo no relacionado con la tarea; <br>  <b>NU_QUEUE_FULL</b> : la cola est√° llena y no se especific√≥ la suspensi√≥n; <br>  <b>NU_TIMEOUT</b> : la cola est√° llena incluso despu√©s de suspender la tarea por el tiempo de espera especificado; <br>  <b>NU_QUEUE_DELETED</b> : la cola se elimin√≥ mientras se suspendi√≥ la tarea; <br>  <b>NU_QUEUE_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br>  <b><i>Poner en cola un mensaje en Nucleus SE</i></b> <br>  Esta llamada de servicio API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Queue_Send (cola NUSE_QUEUE, mensaje ADDR *, suspensi√≥n U8);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> - √≠ndice de <b>cola</b> (ID); <br>  <b>mensaje</b> : un puntero al mensaje a enviar, es una variable de tipo <b>ADDR</b> ; <br>  <b>suspender</b> : especificaci√≥n para pausar tareas; puede tomar los valores <b>NUSE_NO_SUSPEND o NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : √≠ndice de cola no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> : intenta pausar una tarea desde un hilo no asociado con la tarea o cuando las llamadas al servicio API est√°n deshabilitadas para bloquear tareas; <br>  <b>NUSE_QUEUE_FULL</b> : la cola est√° llena y no se especific√≥ la suspensi√≥n; <br>  <b>NUSE_QUEUE_WAS_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br>  <b><i>Implementar cola en Nucleus SE</i></b> <br>  La variante de c√≥digo de funci√≥n API <b>NUSE_Queue_Send ()</b> (despu√©s de verificar los par√°metros) se selecciona mediante compilaci√≥n condicional, dependiendo de si el soporte para el bloqueo de tareas est√° activado o no.  Consideraremos ambas opciones. <br><br>  Si el bloqueo de tareas no est√° activado, el c√≥digo para esta llamada de servicio es bastante simple: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  La funci√≥n simplemente verifica si hay espacio libre en la cola y usa el √≠ndice <b>NUSE_Queue_Head []</b> para almacenar el mensaje en el √°rea de datos de la cola. <br><br>  Si se activa el bloqueo de tareas, el c√≥digo se vuelve m√°s complejo: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_FULL; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* queue element available */ NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Algunas aclaraciones pueden ser √∫tiles. <br><br>  El c√≥digo est√° encerrado en un <b>bucle do ... while</b> , que se ejecuta mientras el par√°metro de pausa de la tarea es <b>NUSE_SUSPEND</b> . <br><br>  Si la cola est√° llena y la <b>suspensi√≥n</b> es <b>NUSE_NO_SUSPEND</b> , la llamada a la API finaliza con <b>NUSE_QUEUE_FULL</b> .  Si el par√°metro de suspensi√≥n es <b>NUSE_SUSPEND</b> , la tarea se detiene.  Al finalizar (es decir, cuando se reanuda la tarea), si el valor de retorno es <b>NUSE_SUCCESS</b> , es decir, la tarea se reanud√≥ porque se ley√≥ el mensaje (y no porque se reinici√≥ la cola), el c√≥digo vuelve al comienzo del ciclo. <br>  Si la cola no est√° llena, el mensaje proporcionado se almacena utilizando el √≠ndice <b>NUSE_Queue_Head []</b> en el √°rea de datos de la cola.  Comprueba si hay tareas suspendidas (mensajes en espera) en la cola.  Si hay tales tareas, se reanuda la primera de ellas.  La variable de suspensi√≥n se establece en <b>NUSE_NO_SUSPEND</b> , y la llamada a la API se completa con el valor <b>NUSE_SUCCESS</b> . <br><br><h3>  Leyendo desde la cola </h3><br>  La llamada a la utilidad de la API Nucleus RTOS para leer desde la cola es muy flexible y le permite pausar tareas impl√≠citamente, o con un tiempo de espera espec√≠fico si la operaci√≥n no puede completarse de inmediato (por ejemplo, al intentar leer desde una cola vac√≠a).  Nucleus SE proporciona la misma funcionalidad, pero la pausa de tareas es opcional y no se implementa un tiempo de espera. <br><br>  <b><i>Llamar para recibir mensajes de la cola en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Receive_From_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED * actual_size, UNSIGNED suspend);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> : un puntero al bloque de control de cola proporcionado por el usuario; <br>  <b>mensaje</b> : un puntero al almacenamiento de los mensajes recibidos; <br>  <b>tama√±o</b> : el n√∫mero de elementos de datos <b>NO FIRMADOS</b> en el mensaje.  Este n√∫mero debe coincidir con el tama√±o del mensaje definido cuando se cre√≥ la cola; <br>  <b>suspender</b> : la especificaci√≥n de la suspensi√≥n de la tarea, puede tomar los valores <b>NU_NO_SUSPEND</b> o <b>NU_SUSPEND</b> o un valor de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND:</b> intenta pausar una tarea desde un hilo no relacionado con la tarea; <br>  <b>NU_QUEUE_EMPTY</b> : la cola est√° vac√≠a y no se especific√≥ la suspensi√≥n; <br>  <b>NU_TIMEOUT</b> : indica que la cola todav√≠a est√° vac√≠a, incluso despu√©s de que la tarea se suspende por un per√≠odo de tiempo espec√≠fico; <br>  <b>NU_QUEUE_DELETED</b> : la cola se elimin√≥ mientras se suspendi√≥ la tarea; <br>  <b>NU_QUEUE_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br>  <b><i>Llame para recibir mensajes de la cola de Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Queue_Receive (cola NUSE_QUEUE, mensaje ADDR *, suspensi√≥n U8);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> - √≠ndice de <b>cola</b> (ID); <br>  <b>mensaje</b> : un puntero al repositorio para los mensajes recibidos; es una variable del tipo <b>ADDR</b> ; <br>  <b>suspender</b> : especificaci√≥n de la suspensi√≥n de la tarea, puede tomar los valores <b>NUSE_NO_SUSPEND</b> o <b>NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : √≠ndice de cola no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> : un intento de suspender una tarea de un hilo no asociado con la tarea o con soporte deshabilitado para el bloqueo de tareas; <br>  <b>NUSE_QUEUE_EMPTY</b> : la cola est√° vac√≠a y no se especific√≥ la suspensi√≥n; <br>  <b>NUSE_QUEUE_WAS_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br>  <b><i>Implementaci√≥n de recibir mensajes de colas en Nucleus SE</i></b> <br>  La variante de c√≥digo de funci√≥n API <b>NUSE_Queue_Receive ()</b> (despu√©s de verificar los par√°metros) se selecciona mediante compilaci√≥n condicional, dependiendo de si el soporte para el bloqueo de tareas est√° activado o no.  Considera ambas opciones. <br><br>  Si el soporte de bloqueo est√° activado, el c√≥digo para esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { return_value = NUSE_QUEUE_EMPTY; } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; return_value = NUSE_SUCCESS; }</code> </pre><br>  La funci√≥n simplemente verifica si hay un mensaje en la cola y usa el √≠ndice <b>NUSE_Queue_Tail []</b> para recuperar el mensaje de la cola y devolver datos usando un puntero al mensaje. <br><br>  Si se activa el bloqueo de tareas, el c√≥digo se vuelve m√°s complejo: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_EMPTY; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked */ /* on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Algunas aclaraciones ser√°n √∫tiles. <br><br>  El c√≥digo est√° encerrado en un <b>bucle do ... while</b> , que se ejecuta mientras el par√°metro de pausa de la tarea es <b>NUSE_SUSPEND</b> . <br><br>  Si la cola est√° vac√≠a y la suspensi√≥n es <b>NUSE_NO_SUSPEND</b> , la llamada a la API finaliza con <b>NUSE_QUEUE_EMPTY</b> .  Si el par√°metro de <b>suspensi√≥n</b> es <b>NUSE_SUSPEND</b> , la tarea se detiene.  Al finalizar (es decir, cuando se reanuda la tarea), si el valor de retorno es <b>NUSE_SUCCESS</b> , es decir, la tarea se reanud√≥ porque se envi√≥ el mensaje (y no porque se restableci√≥ la cola), el c√≥digo vuelve al comienzo del ciclo. <br><br>  Si la cola contiene mensajes, el mensaje almacenado se devuelve utilizando el √≠ndice <b>NUSE_Queue_Tail []</b> .  Comprueba si hay tareas pausadas (pendientes) en esta cola.  Si hay tales tareas, se reanuda la primera de ellas.  La variable de suspensi√≥n se establece en <b>NUSE_NO_SUSPEND</b> , y la llamada a la API termina con el c√≥digo <b>NUSE_SUCCESS</b> . <br><br><h3>  Escribe al jefe de la cola </h3><br>  La llamada a la utilidad Nucleus RTOS API para escribir un mensaje en el encabezado de la cola es muy flexible y le permite pausar la tarea impl√≠citamente, o con un tiempo de espera espec√≠fico si la operaci√≥n no puede completarse de inmediato (por ejemplo, al intentar escribir en una cola llena).  Nucleus SE ofrece la misma funcionalidad, pero la pausa de tareas es opcional y no se implementa un tiempo de espera. <br><br>  <b><i>Llame para escribir un mensaje al jefe de la cola Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Send_To_Front_Of_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> : un puntero al bloque de control de cola proporcionado por el usuario; <br>  <b>mensaje</b> - puntero al mensaje a enviar; <br>  <b>tama√±o</b> : el n√∫mero de elementos de datos <b>NO FIRMADOS</b> en el mensaje.  Si la cola admite mensajes de longitud variable, este par√°metro debe ser igual al tama√±o del mensaje o menor que el tama√±o del mensaje admitido por la cola.  Si la cola admite mensajes de una longitud fija, este par√°metro debe coincidir exactamente con el tama√±o del mensaje admitido por la cola; <br>  <b>suspender</b> : la especificaci√≥n de la suspensi√≥n de la tarea, puede tomar los valores <b>NU_NO_SUSPEND</b> o <b>NU_SUSPEND</b> o un valor de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : el tama√±o del mensaje es incompatible con el tama√±o del mensaje admitido por la cola; <br>  <b>NU_INVALID_SUSPEND</b> : intenta pausar desde un flujo que no es de tarea <br>  <b>NU_QUEUE_FULL</b> : la cola est√° llena y no se especific√≥ la suspensi√≥n; <br>  <b>NU_TIMEOUT</b> : la cola est√° llena, incluso despu√©s de que la tarea se suspende por un cierto tiempo de espera; <br>  <b>NU_QUEUE_DELETED</b> : la cola se elimin√≥ mientras se suspendi√≥ la tarea; <br>  <b>NU_QUEUE_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br>  <b><i>Una llamada para escribir un mensaje al jefe de una cola en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Queue_Jam (cola NUSE_QUEUE, mensaje ADDR *, suspensi√≥n U8);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> - √≠ndice de <b>cola</b> (ID); <br>  <b>mensaje</b> : un puntero a un mensaje, es una variable de tipo <b>ADDR</b> ; <br>  <b>suspender</b> : especificaci√≥n de la suspensi√≥n de la tarea, puede tomar los valores <b>NUSE_NO_SUSPEND</b> o <b>NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : √≠ndice de cola no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> : un intento de suspender una tarea de un hilo no asociado con la tarea o con soporte deshabilitado para el bloqueo de tareas; <br>  <b>NUSE_QUEUE_FULL</b> : la cola est√° llena y no se especific√≥ la suspensi√≥n; <br>  <b>NUSE_QUEUE_WAS_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br>  <b><i>Implementaci√≥n de un registro superior de cola en Nucleus SE</i></b> <br>  La variante del c√≥digo de funci√≥n API <b>NUSE_Queue_Jam () es</b> muy similar a <b>NUSE_Queue_Send ()</b> , solo los datos se almacenan utilizando el √≠ndice <b>NUSE_Queue_Tail []</b> , por lo tanto: <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { if (NUSE_Queue_Tail[queue] == 0) { NUSE_Queue_Tail[queue] = NUSE_Queue_Size[queue] - 1; } else { NUSE_Queue_Tail[queue]--; } NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]] = *message; NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  El siguiente art√≠culo analizar√° las llamadas API adicionales asociadas con las colas, as√≠ como las estructuras de datos. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electr√≥nico: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431378/">https://habr.com/ru/post/es431378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431362/index.html">¬øC√≥mo puede un dise√±ador deshacerse de la rutina y mantener el inter√©s en su trabajo?</a></li>
<li><a href="../es431370/index.html">Los informes m√°s r√°pidos en el salvaje oeste. Y un pu√±ado de errores adem√°s ...</a></li>
<li><a href="../es431372/index.html">Interrupciones de dispositivos externos en un sistema x86. Parte 2. Opciones de arranque del kernel de Linux</a></li>
<li><a href="../es431374/index.html">Juicio final: an√°lisis de indicadores financieros del juego en acceso temprano</a></li>
<li><a href="../es431376/index.html">Migraci√≥n de datos en la empresa sangrienta: qu√© analizar para no abrumar al proyecto</a></li>
<li><a href="../es431380/index.html">Mitap Netologiya y Skyeng sobre habilidades blandas "Lo que un desarrollador necesita saber excepto el c√≥digo"</a></li>
<li><a href="../es431382/index.html">Resultados de la encuesta de ecosistemas de JVM</a></li>
<li><a href="../es431384/index.html">CLion 2018.3: desarrollo remoto, creaci√≥n de perfiles de c√≥digo, rendimiento y m√°s</a></li>
<li><a href="../es431388/index.html">El mundo a trav√©s de los ojos de un autom√≥vil. ¬øC√≥mo lo ven los drones?</a></li>
<li><a href="../es431390/index.html">Tendencias digitales de 2019 y su impacto en el cambio del comportamiento del consumidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>