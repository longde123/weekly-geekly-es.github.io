<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏿 🤹🏽 🔩 JavaScript引擎：它们如何工作？ 从调用堆栈到承诺，（几乎）您需要了解的所有内容 👲 🥣 ♒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您是否想知道浏览器如何读取和执行JavaScript代码？ 它看起来很神秘，但是在这篇文章中，您可以了解幕后发生的事情。 

 我们从游览JavaScript引擎的精彩世界开始我们的语言之旅。 

 在Chrome中打开控制台，然后转到“来源”标签。 您将看到几个部分，其中最有趣的部分是调用堆栈 （...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript引擎：它们如何工作？ 从调用堆栈到承诺，（几乎）您需要了解的所有内容</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br> 您是否想知道浏览器如何读取和执行JavaScript代码？ 它看起来很神秘，但是在这篇文章中，您可以了解幕后发生的事情。 <br><br> 我们从游览JavaScript引擎的精彩世界开始我们的语言之旅。 <br><a name="habracut"></a><br> 在Chrome中打开控制台，然后转到“来源”标签。 您将看到几个部分，其中最有趣的部分是<b>调用堆栈</b> （在Firefox中，将断点放入代码中将看到调用堆栈）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br> 什么是调用栈？ 即使为了执行几行代码，这里似乎也发生了很多事情。 实际上，并不是所有浏览器都附带JavaScript。 有一个很大的组件可以编译和解释我们的JavaScript代码-这是一个JavaScript引擎。 最受欢迎的是V8，它用于Google Chrome和Node.js，Firefox中的SpiderMonkey，Safari / WebKit中的JavaScriptCore。 <br><br> 今天的JavaScript引擎是软件工程的典范，几乎不可能谈论所有方面。 但是，代码执行的主要工作仅由引擎的几个组件完成：调用堆栈（调用堆栈），全局内存（全局内存）和执行上下文（执行上下文）。 准备见他们吗？ <br><br> 内容： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript引擎和全局内存</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript引擎：它们如何工作？</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全局执行上下文和调用堆栈</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript是单线程的，还有其他有趣的故事</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步JavaScript，回调队列和事件循环</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回调地狱并承诺ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建和使用JavaScript Promises</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ES6承诺中的错误处理</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ES6 Promise组合器：Promise.all，Promise.allSettled，Promise.any和其他</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ES6承诺和微任务队列</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript引擎：它们如何工作？</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步演进：从承诺到异步/等待</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript引擎：它们如何工作？</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">总结</a> <br></li></ol><br><a name="1"></a><h2>  1. JavaScript引擎和全局内存 </h2><br> 我说过，JavaScript既是编译语言，又是解释语言。 信不信由你，JavaScript引擎实际上在执行代码之前就会编译您的代码。 <br><br> 是某种魔术，对吧？ 这种魔术称为JIT（及时编译）。 仅这是一个很大的讨论主题，甚至书籍也不足以描述JIT的工作。 但是现在，我们将跳过理论，而将重点放在执行阶段，这同样很有趣。 <br><br> 首先，请看以下代码： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br> 假设我问您如何在浏览器中处理此代码？ 你会怎么回答？ 您可以说：“浏览器读取代码”或“浏览器执行代码”。 实际上，一切都不是那么简单。 首先，代码不是由浏览器读取，而是由引擎读取。  <b>JavaScript引擎读取代码</b> ，并在定义第一行后立即将几个链接放入<b>全局内存</b> 。 <br><br> 全局内存（也称为堆）是JavaScript引擎在其中存储变量和函数声明的区域。 当他阅读上面的代码时，两个绑定器将出现在全局存储器中： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br> 即使示例仅包含变量和函数，也可以想象您的JavaScript代码是在更大的环境中执行的：在浏览器或Node.js中。 在这样的环境中，有许多预定义的函数和变量称为全局变量。 因此，请记住，全局内存将不仅包含<code>num</code>和<code>pow</code> ，还包含更多的数据。 <br><br> 目前没有任何反应。 现在让我们尝试执行我们的功能： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br> 会发生什么？ 将会发生一些有趣的事情。 调用该函数时，JavaScript引擎将突出显示两个部分： <br><br><ul><li> 全局执行上下文 <br></li><li> 调用堆栈 <br></li></ul><br> 什么啊 <br><br><a name="2"></a><h2>  2. JavaScript引擎：它们如何工作？ 全局执行上下文和调用堆栈 </h2><br> 您了解了JavaScript引擎如何读取变量和函数声明。 它们落入全局内存（堆）中。 <br><br> 但是现在我们正在执行JavaScript函数，引擎应该注意这一点。 怎么了 每个JavaScript引擎都有一个<b>称为调用栈</b>的<b>关键组件</b> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是一个堆叠的数据结构</a> ：可以从上方将元素添加到其中，但是当它们上方还有其他元素时，不能将它们从结构中排除。 这就是JavaScript函数的工作方式。 在执行时，如果其中包含另一个函数，则它们无法离开调用堆栈。 请注意这一点，因为该概念有助于理解“ JavaScript是单线程的”语句。 <br><br> 但是回到我们的例子。  <b>调用函数时，引擎会将其发送到调用堆栈</b> ： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br> 我喜欢将呼叫堆栈显示为Pringles芯片堆栈。 在吃掉顶部的薯条之前，我们不能从堆栈的底部开始吃薯条。 幸运的是，我们的函数是同步的：它只是一个快速计算出的乘法。 <br><br> 同时，引擎将<b>全局执行上下文</b>放在内存中，这是在其中执行JavaScript代码的全局环境。 看起来是这样的： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br> 想象一下海洋中的全局执行上下文，其中全局JavaScript函数像鱼一样漂浮。 真甜！ 但这只是故事的一半。 如果我们的函数具有嵌套变量或内部函数怎么办？ <br><br> 即使在简单的情况下，如下所示，JavaScript引擎也会创建<b>本地执行上下文</b> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br> 请注意，我将<code>fixed</code>变量添加到<code>pow</code>函数。 在这种情况下，本地执行上下文将包含<code>fixed</code> 。 我不太擅长在其他小矩形内绘制小矩形，因此请发挥您的想象力。 <br><br> 本地执行上下文将出现在<code>pow</code>旁边，位于全局执行上下文内的绿色矩形部分内。 还要想象一下，引擎如何为嵌套函数内的每个嵌套函数创建其他本地执行上下文。 所有这些矩形部分很快就会出现！ 像一个嵌套娃娃！ <br><br> 让我们回到单线程的故事。 这是什么意思？ <br><br><a name="3"></a><h2>  3. JavaScript是单线程的，还有其他有趣的故事 </h2><br> 我们说<b>JavaScript是单线程的，因为只有一个调用堆栈可以处理我们的函数</b> 。 让我提醒您，如果其他函数需要执行，则函数不能离开调用堆栈。 <br><br> 如果我们使用同步代码，这不是问题。 例如，两个数字的加法是同步的，并且以微秒为单位进行计算。 网络通话以及与外界的其他交互又如何呢？ <br><br> 幸运的是， <b>JavaScript引擎默认情况下被设计为异步工作</b> 。 即使它们一次只能执行一个功能，也可以由外部实体执行较慢的功能-在我们的例子中，它是浏览器。 我们将在下面讨论。 <br><br> 同时，您知道当浏览器加载某种JavaScript代码时，引擎会逐行读取此代码并执行以下步骤： <br><br><ul><li> 将变量和函数声明放入全局内存（堆）。 <br></li><li> 将调用发送到调用堆栈上的每个函数。 <br></li><li> 创建在其中执行全局功能的全局执行上下文。 <br></li><li> 创建许多小的本地执行上下文（如果有内部变量或嵌套函数）。 <br></li></ul><br> 现在，您已经对所有JavaScript引擎基础的同步机制有了基本的了解。 在下一章中，我们将讨论异步代码如何在JavaScript中工作以及为什么这样工作。 <br><br><a name="4"></a><h2>  4.异步JavaScript，回调队列和事件循环 </h2><br> 多亏了全局内存，执行上下文和调用堆栈，同步的JavaScript代码才能在我们的浏览器中执行。 但是我们忘记了一些。 如果您需要执行某种异步功能会怎样？ <br><br> 异步功能是指与外界的每一次互动，这可能需要一些时间才能完成。 调用REST API或计时器是异步的，因为执行它们可能需要几秒钟。 借助引擎中可用的元素，我们可以处理这些功能而不会阻塞调用堆栈和浏览器。 别忘了，调用堆栈一次只能执行一个功能， <b>甚至一个阻塞功能也可以从字面上使浏览器停止</b> 。 幸运的是，JavaScript引擎很聪明，并且在浏览器的帮助下，它们可以解决问题。 <br><br> 当我们执行异步功能时，浏览器会使用它并为我们执行它。 像这样一个计时器： <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br> 我敢肯定，尽管您已经看过数百次<code>setTimeout</code> ，但是您可能不知道<b>JavaScript中没有内置此功能</b> 。 因此，当JavaScript出现时，其中没有<code>setTimeout</code>函数。 实际上，它是所谓的浏览器API的一部分，浏览器API是浏览器为我们提供的便捷工具的集合。 太好了！ 但是，这实际上意味着什么？ 由于<code>setTimeout</code>属于浏览器API，因此该功能由浏览器本身执行（暂时出现在调用堆栈中，但立即从那里删除）。 <br><br>  10秒钟后，浏览器将采用我们传递给它的回调函数，并将其放入<b>回调队列中</b> 。 目前，JavaScript引擎中还出现了两个矩形区域。 看一下这段代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br> 现在我们的方案如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code>在浏览器上下文中执行。  10秒钟后，计时器启动，回调函数准备执行。 但是首先，它必须经过回调队列。 这是队列形式的数据结构，顾名思义，它是函数的有序队列。 <br><br> 每个异步函数必须先通过回调队列，然后才能进入调用堆栈。 但是谁下一步发送功能呢？ 这使一个称为<b>事件循环</b>的组件<b>成为可能</b> 。 <br><br> 到目前为止，事件循环仅处理一件事：它检查调用堆栈是否为空。 如果回调队列中有任何函数，并且调用堆栈是空闲的，那么该将回调发送到调用堆栈的时候了。 <br><br> 之后，该功能被视为已执行。 这是使用JavaScript引擎处理异步和同步代码的通用方案： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br> 假设<code>callback()</code>已准备好执行。 当<code>pow()</code> <b>调用栈被释放，事件循环</b> <code>callback()</code> <b>发送</b> <code>callback()</code> 。 就是这样！ 尽管我做了一些简化，但是如果您理解了上图，就可以理解所有JavaScript。 <br><br> 请记住： <b>基于浏览器的API，回调队列和事件循环是异步JavaScript的基础</b> 。 <br><br> 而且，如果您有兴趣，可以观看Philip Roberts的好奇视频“无论如何，事件循环到底是怎么回事”。 这是事件循环的最佳解释之一。 <br><br> 但是我们还没有完成异步JavaScript主题。 在以下各章中，我们将考虑ES6承诺。 <br><br><a name="5"></a><h2>  5.回调地狱和ES6承诺 </h2><br> 回调函数在所有地方的JavaScript中都可以使用，包括同步代码和异步代码。 考虑以下方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code>是在<code>map</code>内部传递的回调函数。 上面的代码是同步的。 现在考虑这个间隔： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br> 这段代码是异步的，因为在<code>setInterval</code>内部我们传递了runMeEvery回调。 回调在整个JavaScript中都使用，因此多年来，我们一直遇到一个称为“回调地狱”的问题。 <br><br>  JavaScript中的“ <b>回调地狱</b> ”一词适用于编程的“样式”，在该样式中，回调函数嵌入在其他回调函数中，而其他回调函数又嵌入在其他回调函数中...由于异步特性，JavaScript程序员早就陷入了这一陷阱。 <br><br> 老实说，我从未创建过大型的回调金字塔。 也许是因为我重视可读代码，并始终尝试坚持其原则。 如果您遇到了回调难题，则意味着您的函数执行了太多操作。 <br><br> 如果您有兴趣，我不会详细讨论回调地狱，然后转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">callbackhell.com</a> ，在该处已详细研究了此问题，并提出了各种解决方案。 我们将讨论<b>ES6承诺</b> 。 这是一个JavaScript插件，旨在解决地狱回调问题。 但是什么是诺言？ <br><br>  <b>JavaScript承诺表示未来事件</b> 。 一个承诺可能会成功结束，或者在程序员的行话中，一个承诺将被“解决”（解决）。 但是，如果承诺以错误结尾，那么我们说它处于拒绝状态。 承诺也具有默认状态：每个新的承诺都以挂起状态开始。 我可以创造自己的诺言吗？ 是的 我们将在下一章中讨论这一点。 <br><br><a name="6"></a><h2>  6.创建和使用JavaScript promises </h2><br> 要创建新的Promise，您需要通过向其传递回调函数来调用构造函数。 它只能采用两个参数： <code>resolve</code>和<code>reject</code> 。 让我们创建一个新的Promise，它将在5秒内解决（您可以在浏览器控制台中测试示例）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br> 如您所见， <code>resolve</code>是我们调用的一个函数，以使诺言成功结束。  <code>reject</code>会创建一个被拒绝的承诺： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br> 请注意，您可以忽略<code>reject</code>因为这是第二个参数。 但是，如果您打算使用<code>reject</code> ， <b>则不能忽略<code>resolve</code></b> 。 也就是说，以下代码将不起作用，并以允许的承诺结尾： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br> 承诺现在看起来不太有用，对吧？ 这些示例不向用户显示任何内容。 让我们添加一些东西。 允许的，被拒绝的承诺可以返回数据。 例如： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br> 但是我们仍然看不到任何东西。  <b>要从诺言中提取数据，您需要将诺言与<code>then</code>方法关联</b> 。 他进行了回调（具有讽刺意味！），该回调接收当前数据： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br> 作为JavaScript开发人员和他人代码的使用者，您通常会与外部承诺进行交互。 库创建者通常将旧代码包装在Promise构造函数中，如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br> 并且，如有必要，我们还可以通过调用<code>Promise.resolve()</code>来创建和解决承诺： <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br> 因此，让我提醒您：JavaScript承诺是将来发生的事件的书签。 事件以“等待决策”状态开始，可以成功（允许，执行），也可以不成功（被拒绝）。 许诺可以返回可以通过附加<code>then</code>检索到的数据。 在下一章中，我们将讨论如何处理来自承诺的错误。 <br><br><a name="7"></a><h2>  7. ES6承诺中的错误处理 </h2><br> 在JavaScript中处理错误总是很容易的，至少在同步代码中是如此。 看一个例子： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br> 结果将是： <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br> 正如预期的那样，错误落入<code>catch</code> 。 现在尝试异步函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br> 由于<code>setTimeout</code>此代码是异步的。 如果执行它会发生什么？ <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br> 现在结果不同了。 错误没有被<code>catch</code> ，而是自由地上升到堆栈上。 原因是<code>try/catch</code>仅适用于同步代码。 如果您想了解更多， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>将详细讨论这个问题。 <br><br> 幸运的是，有了承诺，我们就可以像处理异步错误一样处理它们。 在上一章中，我说过调用<code>reject</code>会导致对诺言的拒绝： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br> 在这种情况下，我们可以通过再次使用回调来使用<code>catch</code>处理程序来处理错误： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br> 另外，要在正确的位置创建和拒绝承诺，可以调用<code>Promise.reject()</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br> 让我提醒您： <code>then</code>在执行诺言时执行<code>then</code>处理程序，对于拒绝的诺言则执行<code>catch</code>处理程序。 但这还不是故事的结局。 在下面，我们将看到<code>async/await</code>如何与<code>try/catch</code>一起很好地工作。 <br><br><a name="8"></a><h2>  8. ES6的组合者承诺：Promise.all，Promise.allSettled，Promise.any和其他 </h2><br> 承诺并非旨在单独工作。  Promise API提供了多种<b>组合诺言</b>的方法。 最有用的一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是Promise.all</a> ，它从promise获取一个数组并返回一个promise。 唯一的问题是，如果数组中至少有一个Promise被拒绝，Promise.all将被拒绝。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Promise.race</a>在数组中的promise之一收到相应状态后<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">立即</a>允许或拒绝。 <br><br> 在V8的最新版本中，还将引入两个新的组合器： <code>Promise.allSettled</code>和<code>Promise.any</code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Promise.any</a>仍处于提议的功能的早期阶段，在撰写本文<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时尚</a>不支持。 但是，从理论上讲，他将能够发出信号，是否已执行任何诺言。 与<code>Promise.race</code>的区别在于<b>，即使Promise.any之一被拒绝，也不会被Promise.any拒绝</b> 。 <br><br>  <code>Promise.allSettled</code>更加有趣。 他还接受了一系列承诺，但是如果其中一个承诺被拒绝，他不会“缩短”承诺。 当您需要检查数组中的所有promise是否都经过某个阶段，而不管是否存在被拒绝的promise时，此功能很有用。 可以认为它与<code>Promise.all</code>相反。 <br><br><a name="9"></a><h2>  9. ES6承诺和微任务队列 </h2><br> 如果您还记得上一章，那么JavaScript中的每个异步回调函数在到达调用堆栈之前都位于回调队列中。 但是传递给promise的回调函数有不同的命运：它们由微任务队列而不是任务队列处理。 <br><br> 在这里，您需要注意： <b>微任务队列在调用队列之前</b> 。 当事件循环检查新的回调是否准备好进入调用堆栈时，来自微任务队列的回调优先。 <br><br> 杰克·阿奇博尔德（Jake Archibald）在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，微任务，队列和日程安排</a> ，精彩阅读”中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对此</a>机制进行了更详细的描述。 <br><br><a name="10"></a><h2>  10. JavaScript引擎：它们如何工作？ 异步演进：从承诺到异步/等待 </h2><br>  JavaScript正在迅速发展，我们每年都在不断改进。  Promises看起来像一个结局，但<b>ECMAScript 2017（ES8）出现了新语法： <code>async/await</code></b> 。 <br><br>  <code>async/await</code>只是一种风格上的改进，我们称之为语法糖。  <code>async/await</code>不会以任何方式更改JavaScript（请不要忘记该语言应与旧版浏览器向后兼容，并且不应破坏现有代码）。 这只是一种基于Promise编写异步代码的新方法。 考虑一个例子。 上面，我们已经将诺言保存在相应的中： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br> 现在， <b>使用<code>async/await</code>我们可以处理异步代码，以便对我们清单的读者来说，这些代码看起来是同步的</b> 。 除了使用<code>then</code>我们还可以将promise包装在一个名为<code>async</code>的函数中，然后我们将<code>await</code>结果： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br> 看起来不错吧？ 有趣的是，异步函数总是返回promise，没有人可以阻止它执行此操作： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br> 错误呢？  <code>async/await</code>的优点之一是这种构造可以让我们使用<code><b>try/catch</b></code> 。 阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步函数中的错误处理及其测试的介绍</a> 。 <br><br> 让我们再次看一下promise，其中我们使用<code>catch</code>处理程序处理错误： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br> 使用异步函数，我们可以这样重构： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br> 但是，并不是每个人都切换到这种样式。  <code>try/catch</code>会使您的代码复杂化。 还有一件事要考虑。 在以下代码中查看此<code>try</code>块内如何发生错误： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br> 控制台中显示的两行呢？ 请记住， <b><code>try/catch</code>是一个同步结构，而我们的异步函数会生成一个promise</b> 。 他们遵循两条不同的路径，例如火车。     !  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     «Catch me if you can»,    «I will run no matter what!». <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> —   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript —     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   «» :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  —   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452906/">https://habr.com/ru/post/zh-CN452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452892/index.html">非程序员如何前往美国：分步说明</a></li>
<li><a href="../zh-CN452894/index.html">面部反欺骗或从技术上识别出千面作弊者</a></li>
<li><a href="../zh-CN452900/index.html">PostgreSQL中的索引-9（BRIN）</a></li>
<li><a href="../zh-CN452902/index.html">完成了4年的程序员培训之后，我了解我与程序员的距离很远</a></li>
<li><a href="../zh-CN452904/index.html">机器如何通信-MQTT协议</a></li>
<li><a href="../zh-CN452908/index.html">Selenium WebDriver-使用Grafana和InfluxDB的实时测试指标</a></li>
<li><a href="../zh-CN452910/index.html">哈Ha！ 你好特康</a></li>
<li><a href="../zh-CN452914/index.html">面向微笑不怕实验的人，Scala上的ML面带微笑</a></li>
<li><a href="../zh-CN452916/index.html">起来吧 脊柱外科：什么时候做，有什么危险</a></li>
<li><a href="../zh-CN452922/index.html">灵活的CSS网格表</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>